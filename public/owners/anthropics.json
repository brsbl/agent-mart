{
  "owner": {
    "id": "anthropics",
    "display_name": "Anthropic",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/76263028?v=4",
    "url": "https://github.com/anthropics",
    "bio": null,
    "stats": {
      "total_repos": 3,
      "total_plugins": 60,
      "total_commands": 176,
      "total_skills": 140,
      "total_stars": 97416,
      "total_forks": 7918
    }
  },
  "repos": [
    {
      "full_name": "anthropics/claude-code",
      "url": "https://github.com/anthropics/claude-code",
      "description": "Claude Code is an agentic coding tool that lives in your terminal, understands your codebase, and helps you code faster by executing routine tasks, explaining complex code, and handling git workflows - all through natural language commands.",
      "homepage": "https://code.claude.com/docs/en/overview",
      "signals": {
        "stars": 55716,
        "forks": 4044,
        "pushed_at": "2026-01-12T23:22:53Z",
        "created_at": "2025-02-22T17:41:21Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 5468
        },
        {
          "path": ".claude",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/commands/commit-push-pr.md",
          "type": "blob",
          "size": 795
        },
        {
          "path": ".claude/commands/dedupe.md",
          "type": "blob",
          "size": 1444
        },
        {
          "path": ".claude/commands/oncall-triage.md",
          "type": "blob",
          "size": 2178
        },
        {
          "path": ".devcontainer",
          "type": "tree",
          "size": null
        },
        {
          "path": ".devcontainer/Dockerfile",
          "type": "blob",
          "size": 2507
        },
        {
          "path": ".devcontainer/devcontainer.json",
          "type": "blob",
          "size": 1662
        },
        {
          "path": ".devcontainer/init-firewall.sh",
          "type": "blob",
          "size": 4578
        },
        {
          "path": ".gitattributes",
          "type": "blob",
          "size": 35
        },
        {
          "path": ".github",
          "type": "tree",
          "size": null
        },
        {
          "path": ".github/ISSUE_TEMPLATE",
          "type": "tree",
          "size": null
        },
        {
          "path": ".github/ISSUE_TEMPLATE/bug_report.yml",
          "type": "blob",
          "size": 5851
        },
        {
          "path": ".github/ISSUE_TEMPLATE/config.yml",
          "type": "blob",
          "size": 619
        },
        {
          "path": ".github/ISSUE_TEMPLATE/documentation.yml",
          "type": "blob",
          "size": 3489
        },
        {
          "path": ".github/ISSUE_TEMPLATE/feature_request.yml",
          "type": "blob",
          "size": 4208
        },
        {
          "path": ".github/ISSUE_TEMPLATE/model_behavior.yml",
          "type": "blob",
          "size": 6952
        },
        {
          "path": ".github/workflows",
          "type": "tree",
          "size": null
        },
        {
          "path": ".github/workflows/auto-close-duplicates.yml",
          "type": "blob",
          "size": 847
        },
        {
          "path": ".github/workflows/backfill-duplicate-comments.yml",
          "type": "blob",
          "size": 1143
        },
        {
          "path": ".github/workflows/claude-dedupe-issues.yml",
          "type": "blob",
          "size": 2847
        },
        {
          "path": ".github/workflows/claude-issue-triage.yml",
          "type": "blob",
          "size": 4827
        },
        {
          "path": ".github/workflows/claude.yml",
          "type": "blob",
          "size": 1204
        },
        {
          "path": ".github/workflows/issue-opened-dispatch.yml",
          "type": "blob",
          "size": 738
        },
        {
          "path": ".github/workflows/lock-closed-issues.yml",
          "type": "blob",
          "size": 3121
        },
        {
          "path": ".github/workflows/log-issue-events.yml",
          "type": "blob",
          "size": 1403
        },
        {
          "path": ".github/workflows/oncall-triage.yml",
          "type": "blob",
          "size": 5754
        },
        {
          "path": ".github/workflows/remove-autoclose-label.yml",
          "type": "blob",
          "size": 1447
        },
        {
          "path": ".github/workflows/stale-issue-manager.yml",
          "type": "blob",
          "size": 6467
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 11
        },
        {
          "path": ".vscode",
          "type": "tree",
          "size": null
        },
        {
          "path": ".vscode/extensions.json",
          "type": "blob",
          "size": 155
        },
        {
          "path": "CHANGELOG.md",
          "type": "blob",
          "size": 65730
        },
        {
          "path": "LICENSE.md",
          "type": "blob",
          "size": 150
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 2873
        },
        {
          "path": "SECURITY.md",
          "type": "blob",
          "size": 693
        },
        {
          "path": "Script",
          "type": "tree",
          "size": null
        },
        {
          "path": "Script/run_devcontainer_claude_code.ps1",
          "type": "blob",
          "size": 5319
        },
        {
          "path": "demo.gif",
          "type": "blob",
          "size": 11002760
        },
        {
          "path": "examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "examples/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "examples/hooks/bash_command_validator_example.py",
          "type": "blob",
          "size": 2078
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/README.md",
          "type": "blob",
          "size": 6530
        },
        {
          "path": "plugins/agent-sdk-dev",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/agent-sdk-dev/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/agent-sdk-dev/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 190
        },
        {
          "path": "plugins/agent-sdk-dev/README.md",
          "type": "blob",
          "size": 6397
        },
        {
          "path": "plugins/agent-sdk-dev/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/agent-sdk-dev/agents/agent-sdk-verifier-py.md",
          "type": "blob",
          "size": 5206
        },
        {
          "path": "plugins/agent-sdk-dev/agents/agent-sdk-verifier-ts.md",
          "type": "blob",
          "size": 5419
        },
        {
          "path": "plugins/agent-sdk-dev/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/agent-sdk-dev/commands/new-sdk-app.md",
          "type": "blob",
          "size": 7846
        },
        {
          "path": "plugins/claude-opus-4-5-migration",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude-opus-4-5-migration/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude-opus-4-5-migration/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 234
        },
        {
          "path": "plugins/claude-opus-4-5-migration/README.md",
          "type": "blob",
          "size": 707
        },
        {
          "path": "plugins/claude-opus-4-5-migration/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude-opus-4-5-migration/skills/claude-opus-4-5-migration",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude-opus-4-5-migration/skills/claude-opus-4-5-migration/SKILL.md",
          "type": "blob",
          "size": 4746
        },
        {
          "path": "plugins/claude-opus-4-5-migration/skills/claude-opus-4-5-migration/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude-opus-4-5-migration/skills/claude-opus-4-5-migration/references/effort.md",
          "type": "blob",
          "size": 1728
        },
        {
          "path": "plugins/claude-opus-4-5-migration/skills/claude-opus-4-5-migration/references/prompt-snippets.md",
          "type": "blob",
          "size": 6139
        },
        {
          "path": "plugins/code-review",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-review/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-review/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 257
        },
        {
          "path": "plugins/code-review/README.md",
          "type": "blob",
          "size": 7703
        },
        {
          "path": "plugins/code-review/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-review/commands/code-review.md",
          "type": "blob",
          "size": 6570
        },
        {
          "path": "plugins/commit-commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/commit-commands/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/commit-commands/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 258
        },
        {
          "path": "plugins/commit-commands/README.md",
          "type": "blob",
          "size": 5908
        },
        {
          "path": "plugins/commit-commands/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/commit-commands/commands/clean_gone.md",
          "type": "blob",
          "size": 1865
        },
        {
          "path": "plugins/commit-commands/commands/commit-push-pr.md",
          "type": "blob",
          "size": 796
        },
        {
          "path": "plugins/commit-commands/commands/commit.md",
          "type": "blob",
          "size": 624
        },
        {
          "path": "plugins/explanatory-output-style",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/explanatory-output-style/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/explanatory-output-style/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 293
        },
        {
          "path": "plugins/explanatory-output-style/README.md",
          "type": "blob",
          "size": 2470
        },
        {
          "path": "plugins/explanatory-output-style/hooks-handlers",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/explanatory-output-style/hooks-handlers/session-start.sh",
          "type": "blob",
          "size": 1468
        },
        {
          "path": "plugins/explanatory-output-style/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/explanatory-output-style/hooks/hooks.json",
          "type": "blob",
          "size": 314
        },
        {
          "path": "plugins/feature-dev",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/feature-dev/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/feature-dev/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 291
        },
        {
          "path": "plugins/feature-dev/README.md",
          "type": "blob",
          "size": 11697
        },
        {
          "path": "plugins/feature-dev/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/feature-dev/agents/code-architect.md",
          "type": "blob",
          "size": 2259
        },
        {
          "path": "plugins/feature-dev/agents/code-explorer.md",
          "type": "blob",
          "size": 2115
        },
        {
          "path": "plugins/feature-dev/agents/code-reviewer.md",
          "type": "blob",
          "size": 2994
        },
        {
          "path": "plugins/feature-dev/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/feature-dev/commands/feature-dev.md",
          "type": "blob",
          "size": 5097
        },
        {
          "path": "plugins/frontend-design",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/frontend-design/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/frontend-design/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 256
        },
        {
          "path": "plugins/frontend-design/README.md",
          "type": "blob",
          "size": 977
        },
        {
          "path": "plugins/frontend-design/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/frontend-design/skills/frontend-design",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/frontend-design/skills/frontend-design/SKILL.md",
          "type": "blob",
          "size": 4274
        },
        {
          "path": "plugins/hookify",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/hookify/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/hookify/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 234
        },
        {
          "path": "plugins/hookify/.gitignore",
          "type": "blob",
          "size": 291
        },
        {
          "path": "plugins/hookify/README.md",
          "type": "blob",
          "size": 7710
        },
        {
          "path": "plugins/hookify/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/hookify/agents/conversation-analyzer.md",
          "type": "blob",
          "size": 5478
        },
        {
          "path": "plugins/hookify/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/hookify/commands/configure.md",
          "type": "blob",
          "size": 2863
        },
        {
          "path": "plugins/hookify/commands/help.md",
          "type": "blob",
          "size": 4624
        },
        {
          "path": "plugins/hookify/commands/hookify.md",
          "type": "blob",
          "size": 7667
        },
        {
          "path": "plugins/hookify/commands/list.md",
          "type": "blob",
          "size": 2020
        },
        {
          "path": "plugins/hookify/core",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/hookify/core/__init__.py",
          "type": "blob",
          "size": null
        },
        {
          "path": "plugins/hookify/core/config_loader.py",
          "type": "blob",
          "size": 9690
        },
        {
          "path": "plugins/hookify/core/rule_engine.py",
          "type": "blob",
          "size": 10727
        },
        {
          "path": "plugins/hookify/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/hookify/examples/console-log-warning.local.md",
          "type": "blob",
          "size": 315
        },
        {
          "path": "plugins/hookify/examples/dangerous-rm.local.md",
          "type": "blob",
          "size": 278
        },
        {
          "path": "plugins/hookify/examples/require-tests-stop.local.md",
          "type": "blob",
          "size": 500
        },
        {
          "path": "plugins/hookify/examples/sensitive-files-warning.local.md",
          "type": "blob",
          "size": 421
        },
        {
          "path": "plugins/hookify/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/hookify/hooks/__init__.py",
          "type": "blob",
          "size": null
        },
        {
          "path": "plugins/hookify/hooks/hooks.json",
          "type": "blob",
          "size": 1020
        },
        {
          "path": "plugins/hookify/hooks/posttooluse.py",
          "type": "blob",
          "size": 1776
        },
        {
          "path": "plugins/hookify/hooks/pretooluse.py",
          "type": "blob",
          "size": 2205
        },
        {
          "path": "plugins/hookify/hooks/stop.py",
          "type": "blob",
          "size": 1557
        },
        {
          "path": "plugins/hookify/hooks/userpromptsubmit.py",
          "type": "blob",
          "size": 1543
        },
        {
          "path": "plugins/hookify/matchers",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/hookify/matchers/__init__.py",
          "type": "blob",
          "size": null
        },
        {
          "path": "plugins/hookify/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/hookify/skills/writing-rules",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/hookify/skills/writing-rules/SKILL.md",
          "type": "blob",
          "size": 8423
        },
        {
          "path": "plugins/hookify/utils",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/hookify/utils/__init__.py",
          "type": "blob",
          "size": null
        },
        {
          "path": "plugins/learning-output-style",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/learning-output-style/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/learning-output-style/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 296
        },
        {
          "path": "plugins/learning-output-style/README.md",
          "type": "blob",
          "size": 4687
        },
        {
          "path": "plugins/learning-output-style/hooks-handlers",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/learning-output-style/hooks-handlers/session-start.sh",
          "type": "blob",
          "size": 3564
        },
        {
          "path": "plugins/learning-output-style/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/learning-output-style/hooks/hooks.json",
          "type": "blob",
          "size": 311
        },
        {
          "path": "plugins/plugin-dev",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/README.md",
          "type": "blob",
          "size": 14592
        },
        {
          "path": "plugins/plugin-dev/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/agents/agent-creator.md",
          "type": "blob",
          "size": 7437
        },
        {
          "path": "plugins/plugin-dev/agents/plugin-validator.md",
          "type": "blob",
          "size": 6623
        },
        {
          "path": "plugins/plugin-dev/agents/skill-reviewer.md",
          "type": "blob",
          "size": 6079
        },
        {
          "path": "plugins/plugin-dev/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/commands/create-plugin.md",
          "type": "blob",
          "size": 14950
        },
        {
          "path": "plugins/plugin-dev/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/agent-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/agent-development/SKILL.md",
          "type": "blob",
          "size": 10430
        },
        {
          "path": "plugins/plugin-dev/skills/agent-development/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/agent-development/examples/agent-creation-prompt.md",
          "type": "blob",
          "size": 9390
        },
        {
          "path": "plugins/plugin-dev/skills/agent-development/examples/complete-agent-examples.md",
          "type": "blob",
          "size": 14117
        },
        {
          "path": "plugins/plugin-dev/skills/agent-development/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/agent-development/references/agent-creation-system-prompt.md",
          "type": "blob",
          "size": 8879
        },
        {
          "path": "plugins/plugin-dev/skills/agent-development/references/system-prompt-design.md",
          "type": "blob",
          "size": 9998
        },
        {
          "path": "plugins/plugin-dev/skills/agent-development/references/triggering-examples.md",
          "type": "blob",
          "size": 11613
        },
        {
          "path": "plugins/plugin-dev/skills/agent-development/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/agent-development/scripts/validate-agent.sh",
          "type": "blob",
          "size": 5796
        },
        {
          "path": "plugins/plugin-dev/skills/command-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/README.md",
          "type": "blob",
          "size": 7651
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/SKILL.md",
          "type": "blob",
          "size": 18941
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/examples/plugin-commands.md",
          "type": "blob",
          "size": 13989
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/examples/simple-commands.md",
          "type": "blob",
          "size": 8675
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/references/advanced-workflows.md",
          "type": "blob",
          "size": 13618
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/references/documentation-patterns.md",
          "type": "blob",
          "size": 14971
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/references/frontmatter-reference.md",
          "type": "blob",
          "size": 9162
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/references/interactive-commands.md",
          "type": "blob",
          "size": 20980
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/references/marketplace-considerations.md",
          "type": "blob",
          "size": 16437
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/references/plugin-features-reference.md",
          "type": "blob",
          "size": 14622
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/references/testing-strategies.md",
          "type": "blob",
          "size": 14803
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/SKILL.md",
          "type": "blob",
          "size": 16246
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/examples/load-context.sh",
          "type": "blob",
          "size": 1690
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/examples/validate-bash.sh",
          "type": "blob",
          "size": 1304
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/examples/validate-write.sh",
          "type": "blob",
          "size": 1222
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/references/advanced.md",
          "type": "blob",
          "size": 10148
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/references/migration.md",
          "type": "blob",
          "size": 8299
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/references/patterns.md",
          "type": "blob",
          "size": 7144
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/scripts/README.md",
          "type": "blob",
          "size": 3677
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/scripts/hook-linter.sh",
          "type": "blob",
          "size": 4200
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/scripts/test-hook.sh",
          "type": "blob",
          "size": 5336
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/scripts/validate-hook-schema.sh",
          "type": "blob",
          "size": 5081
        },
        {
          "path": "plugins/plugin-dev/skills/mcp-integration",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/mcp-integration/SKILL.md",
          "type": "blob",
          "size": 12519
        },
        {
          "path": "plugins/plugin-dev/skills/mcp-integration/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/mcp-integration/examples/http-server.json",
          "type": "blob",
          "size": 502
        },
        {
          "path": "plugins/plugin-dev/skills/mcp-integration/examples/sse-server.json",
          "type": "blob",
          "size": 413
        },
        {
          "path": "plugins/plugin-dev/skills/mcp-integration/examples/stdio-server.json",
          "type": "blob",
          "size": 686
        },
        {
          "path": "plugins/plugin-dev/skills/mcp-integration/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/mcp-integration/references/authentication.md",
          "type": "blob",
          "size": 10196
        },
        {
          "path": "plugins/plugin-dev/skills/mcp-integration/references/server-types.md",
          "type": "blob",
          "size": 10613
        },
        {
          "path": "plugins/plugin-dev/skills/mcp-integration/references/tool-usage.md",
          "type": "blob",
          "size": 11674
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings/SKILL.md",
          "type": "blob",
          "size": 12101
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings/examples/create-settings-command.md",
          "type": "blob",
          "size": 2177
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings/examples/example-settings.md",
          "type": "blob",
          "size": 2930
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings/examples/read-settings-hook.sh",
          "type": "blob",
          "size": 2205
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings/references/parsing-techniques.md",
          "type": "blob",
          "size": 11513
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings/references/real-world-examples.md",
          "type": "blob",
          "size": 9496
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings/scripts/parse-frontmatter.sh",
          "type": "blob",
          "size": 1269
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings/scripts/validate-settings.sh",
          "type": "blob",
          "size": 2712
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-structure",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-structure/README.md",
          "type": "blob",
          "size": 3210
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-structure/SKILL.md",
          "type": "blob",
          "size": 13796
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-structure/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-structure/examples/advanced-plugin.md",
          "type": "blob",
          "size": 18746
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-structure/examples/minimal-plugin.md",
          "type": "blob",
          "size": 1731
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-structure/examples/standard-plugin.md",
          "type": "blob",
          "size": 13310
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-structure/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-structure/references/component-patterns.md",
          "type": "blob",
          "size": 12086
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-structure/references/manifest-reference.md",
          "type": "blob",
          "size": 12061
        },
        {
          "path": "plugins/plugin-dev/skills/skill-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/skill-development/SKILL.md",
          "type": "blob",
          "size": 22827
        },
        {
          "path": "plugins/plugin-dev/skills/skill-development/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/skill-development/references/skill-creator-original.md",
          "type": "blob",
          "size": 11547
        },
        {
          "path": "plugins/pr-review-toolkit",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/pr-review-toolkit/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/pr-review-toolkit/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 282
        },
        {
          "path": "plugins/pr-review-toolkit/README.md",
          "type": "blob",
          "size": 7528
        },
        {
          "path": "plugins/pr-review-toolkit/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/pr-review-toolkit/agents/code-reviewer.md",
          "type": "blob",
          "size": 3985
        },
        {
          "path": "plugins/pr-review-toolkit/agents/code-simplifier.md",
          "type": "blob",
          "size": 5230
        },
        {
          "path": "plugins/pr-review-toolkit/agents/comment-analyzer.md",
          "type": "blob",
          "size": 5725
        },
        {
          "path": "plugins/pr-review-toolkit/agents/pr-test-analyzer.md",
          "type": "blob",
          "size": 4985
        },
        {
          "path": "plugins/pr-review-toolkit/agents/silent-failure-hunter.md",
          "type": "blob",
          "size": 7807
        },
        {
          "path": "plugins/pr-review-toolkit/agents/type-design-analyzer.md",
          "type": "blob",
          "size": 5368
        },
        {
          "path": "plugins/pr-review-toolkit/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/pr-review-toolkit/commands/review-pr.md",
          "type": "blob",
          "size": 4997
        },
        {
          "path": "plugins/ralph-wiggum",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ralph-wiggum/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ralph-wiggum/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 353
        },
        {
          "path": "plugins/ralph-wiggum/README.md",
          "type": "blob",
          "size": 5201
        },
        {
          "path": "plugins/ralph-wiggum/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ralph-wiggum/commands/cancel-ralph.md",
          "type": "blob",
          "size": 745
        },
        {
          "path": "plugins/ralph-wiggum/commands/help.md",
          "type": "blob",
          "size": 3229
        },
        {
          "path": "plugins/ralph-wiggum/commands/ralph-loop.md",
          "type": "blob",
          "size": 923
        },
        {
          "path": "plugins/ralph-wiggum/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ralph-wiggum/hooks/hooks.json",
          "type": "blob",
          "size": 284
        },
        {
          "path": "plugins/ralph-wiggum/hooks/stop-hook.sh",
          "type": "blob",
          "size": 6564
        },
        {
          "path": "plugins/ralph-wiggum/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ralph-wiggum/scripts/setup-ralph-loop.sh",
          "type": "blob",
          "size": 7009
        },
        {
          "path": "plugins/security-guidance",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/security-guidance/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/security-guidance/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 306
        },
        {
          "path": "plugins/security-guidance/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/security-guidance/hooks/hooks.json",
          "type": "blob",
          "size": 382
        },
        {
          "path": "plugins/security-guidance/hooks/security_reminder_hook.py",
          "type": "blob",
          "size": 10767
        },
        {
          "path": "scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "scripts/auto-close-duplicates.ts",
          "type": "blob",
          "size": 7753
        },
        {
          "path": "scripts/backfill-duplicate-comments.ts",
          "type": "blob",
          "size": 6830
        },
        {
          "path": "scripts/comment-on-duplicates.sh",
          "type": "blob",
          "size": 2449
        }
      ],
      "marketplace": {
        "name": "claude-code-plugins",
        "version": "1.0.0",
        "description": "Bundled plugins for Claude Code including Agent SDK development tools, PR review toolkit, and commit workflows",
        "owner_info": {
          "name": "Anthropic",
          "email": "support@anthropic.com"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "agent-sdk-dev",
            "description": "Development kit for working with the Claude Agent SDK",
            "source": "./plugins/agent-sdk-dev",
            "category": "development",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/claude-code",
              "/plugin install agent-sdk-dev@claude-code-plugins"
            ],
            "signals": {
              "stars": 55716,
              "forks": 4044,
              "pushed_at": "2026-01-12T23:22:53Z",
              "created_at": "2025-02-22T17:41:21Z",
              "license": null
            },
            "commands": [
              {
                "name": "/new-sdk-app",
                "description": "Create and setup a new Claude Agent SDK application",
                "path": "plugins/agent-sdk-dev/commands/new-sdk-app.md",
                "frontmatter": {
                  "description": "Create and setup a new Claude Agent SDK application",
                  "argument-hint": [
                    "project-name"
                  ]
                },
                "content": "You are tasked with helping the user create a new Claude Agent SDK application. Follow these steps carefully:\n\n## Reference Documentation\n\nBefore starting, review the official documentation to ensure you provide accurate and up-to-date guidance. Use WebFetch to read these pages:\n\n1. **Start with the overview**: https://docs.claude.com/en/api/agent-sdk/overview\n2. **Based on the user's language choice, read the appropriate SDK reference**:\n   - TypeScript: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Python: https://docs.claude.com/en/api/agent-sdk/python\n3. **Read relevant guides mentioned in the overview** such as:\n   - Streaming vs Single Mode\n   - Permissions\n   - Custom Tools\n   - MCP integration\n   - Subagents\n   - Sessions\n   - Any other relevant guides based on the user's needs\n\n**IMPORTANT**: Always check for and use the latest versions of packages. Use WebSearch or WebFetch to verify current versions before installation.\n\n## Gather Requirements\n\nIMPORTANT: Ask these questions one at a time. Wait for the user's response before asking the next question. This makes it easier for the user to respond.\n\nAsk the questions in this order (skip any that the user has already provided via arguments):\n\n1. **Language** (ask first): \"Would you like to use TypeScript or Python?\"\n\n   - Wait for response before continuing\n\n2. **Project name** (ask second): \"What would you like to name your project?\"\n\n   - If $ARGUMENTS is provided, use that as the project name and skip this question\n   - Wait for response before continuing\n\n3. **Agent type** (ask third, but skip if #2 was sufficiently detailed): \"What kind of agent are you building? Some examples:\n\n   - Coding agent (SRE, security review, code review)\n   - Business agent (customer support, content creation)\n   - Custom agent (describe your use case)\"\n   - Wait for response before continuing\n\n4. **Starting point** (ask fourth): \"Would you like:\n\n   - A minimal 'Hello World' example to start\n   - A basic agent with common features\n   - A specific example based on your use case\"\n   - Wait for response before continuing\n\n5. **Tooling choice** (ask fifth): Let the user know what tools you'll use, and confirm with them that these are the tools they want to use (for example, they may prefer pnpm or bun over npm). Respect the user's preferences when executing on the requirements.\n\nAfter all questions are answered, proceed to create the setup plan.\n\n## Setup Plan\n\nBased on the user's answers, create a plan that includes:\n\n1. **Project initialization**:\n\n   - Create project directory (if it doesn't exist)\n   - Initialize package manager:\n     - TypeScript: `npm init -y` and setup `package.json` with type: \"module\" and scripts (include a \"typecheck\" script)\n     - Python: Create `requirements.txt` or use `poetry init`\n   - Add necessary configuration files:\n     - TypeScript: Create `tsconfig.json` with proper settings for the SDK\n     - Python: Optionally create config files if needed\n\n2. **Check for Latest Versions**:\n\n   - BEFORE installing, use WebSearch or check npm/PyPI to find the latest version\n   - For TypeScript: Check https://www.npmjs.com/package/@anthropic-ai/claude-agent-sdk\n   - For Python: Check https://pypi.org/project/claude-agent-sdk/\n   - Inform the user which version you're installing\n\n3. **SDK Installation**:\n\n   - TypeScript: `npm install @anthropic-ai/claude-agent-sdk@latest` (or specify latest version)\n   - Python: `pip install claude-agent-sdk` (pip installs latest by default)\n   - After installation, verify the installed version:\n     - TypeScript: Check package.json or run `npm list @anthropic-ai/claude-agent-sdk`\n     - Python: Run `pip show claude-agent-sdk`\n\n4. **Create starter files**:\n\n   - TypeScript: Create an `index.ts` or `src/index.ts` with a basic query example\n   - Python: Create a `main.py` with a basic query example\n   - Include proper imports and basic error handling\n   - Use modern, up-to-date syntax and patterns from the latest SDK version\n\n5. **Environment setup**:\n\n   - Create a `.env.example` file with `ANTHROPIC_API_KEY=your_api_key_here`\n   - Add `.env` to `.gitignore`\n   - Explain how to get an API key from https://console.anthropic.com/\n\n6. **Optional: Create .claude directory structure**:\n   - Offer to create `.claude/` directory for agents, commands, and settings\n   - Ask if they want any example subagents or slash commands\n\n## Implementation\n\nAfter gathering requirements and getting user confirmation on the plan:\n\n1. Check for latest package versions using WebSearch or WebFetch\n2. Execute the setup steps\n3. Create all necessary files\n4. Install dependencies (always use latest stable versions)\n5. Verify installed versions and inform the user\n6. Create a working example based on their agent type\n7. Add helpful comments in the code explaining what each part does\n8. **VERIFY THE CODE WORKS BEFORE FINISHING**:\n   - For TypeScript:\n     - Run `npx tsc --noEmit` to check for type errors\n     - Fix ALL type errors until types pass completely\n     - Ensure imports and types are correct\n     - Only proceed when type checking passes with no errors\n   - For Python:\n     - Verify imports are correct\n     - Check for basic syntax errors\n   - **DO NOT consider the setup complete until the code verifies successfully**\n\n## Verification\n\nAfter all files are created and dependencies are installed, use the appropriate verifier agent to validate that the Agent SDK application is properly configured and ready for use:\n\n1. **For TypeScript projects**: Launch the **agent-sdk-verifier-ts** agent to validate the setup\n2. **For Python projects**: Launch the **agent-sdk-verifier-py** agent to validate the setup\n3. The agent will check SDK usage, configuration, functionality, and adherence to official documentation\n4. Review the verification report and address any issues\n\n## Getting Started Guide\n\nOnce setup is complete and verified, provide the user with:\n\n1. **Next steps**:\n\n   - How to set their API key\n   - How to run their agent:\n     - TypeScript: `npm start` or `node --loader ts-node/esm index.ts`\n     - Python: `python main.py`\n\n2. **Useful resources**:\n\n   - Link to TypeScript SDK reference: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Link to Python SDK reference: https://docs.claude.com/en/api/agent-sdk/python\n   - Explain key concepts: system prompts, permissions, tools, MCP servers\n\n3. **Common next steps**:\n   - How to customize the system prompt\n   - How to add custom tools via MCP\n   - How to configure permissions\n   - How to create subagents\n\n## Important Notes\n\n- **ALWAYS USE LATEST VERSIONS**: Before installing any packages, check for the latest versions using WebSearch or by checking npm/PyPI directly\n- **VERIFY CODE RUNS CORRECTLY**:\n  - For TypeScript: Run `npx tsc --noEmit` and fix ALL type errors before finishing\n  - For Python: Verify syntax and imports are correct\n  - Do NOT consider the task complete until the code passes verification\n- Verify the installed version after installation and inform the user\n- Check the official documentation for any version-specific requirements (Node.js version, Python version, etc.)\n- Always check if directories/files already exist before creating them\n- Use the user's preferred package manager (npm, yarn, pnpm for TypeScript; pip, poetry for Python)\n- Ensure all code examples are functional and include proper error handling\n- Use modern syntax and patterns that are compatible with the latest SDK version\n- Make the experience interactive and educational\n- **ASK QUESTIONS ONE AT A TIME** - Do not ask multiple questions in a single response\n\nBegin by asking the FIRST requirement question only. Wait for the user's answer before proceeding to the next question."
              }
            ],
            "skills": []
          },
          {
            "name": "claude-opus-4-5-migration",
            "description": "Migrate your code and prompts from Sonnet 4.x and Opus 4.1 to Opus 4.5.",
            "source": "./plugins/claude-opus-4-5-migration",
            "category": "development",
            "version": "1.0.0",
            "author": {
              "name": "William Hu",
              "email": "whu@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-code",
              "/plugin install claude-opus-4-5-migration@claude-code-plugins"
            ],
            "signals": {
              "stars": 55716,
              "forks": 4044,
              "pushed_at": "2026-01-12T23:22:53Z",
              "created_at": "2025-02-22T17:41:21Z",
              "license": null
            },
            "commands": [],
            "skills": [
              {
                "name": "claude-opus-4-5-migration",
                "description": "Migrate prompts and code from Claude Sonnet 4.0, Sonnet 4.5, or Opus 4.1 to Opus 4.5. Use when the user wants to update their codebase, prompts, or API calls to use Opus 4.5. Handles model string updates and prompt adjustments for known Opus 4.5 behavioral differences. Does NOT migrate Haiku 4.5.",
                "path": "plugins/claude-opus-4-5-migration/skills/claude-opus-4-5-migration/SKILL.md",
                "frontmatter": {
                  "name": "claude-opus-4-5-migration",
                  "description": "Migrate prompts and code from Claude Sonnet 4.0, Sonnet 4.5, or Opus 4.1 to Opus 4.5. Use when the user wants to update their codebase, prompts, or API calls to use Opus 4.5. Handles model string updates and prompt adjustments for known Opus 4.5 behavioral differences. Does NOT migrate Haiku 4.5."
                },
                "content": "# Opus 4.5 Migration Guide\n\nOne-shot migration from Sonnet 4.0, Sonnet 4.5, or Opus 4.1 to Opus 4.5.\n\n## Migration Workflow\n\n1. Search codebase for model strings and API calls\n2. Update model strings to Opus 4.5 (see platform-specific strings below)\n3. Remove unsupported beta headers\n4. Add effort parameter set to `\"high\"` (see `references/effort.md`)\n5. Summarize all changes made\n6. Tell the user: \"If you encounter any issues with Opus 4.5, let me know and I can help adjust your prompts.\"\n\n## Model String Updates\n\nIdentify which platform the codebase uses, then replace model strings accordingly.\n\n### Unsupported Beta Headers\n\nRemove the `context-1m-2025-08-07` beta header if presentâ€”it is not yet supported with Opus 4.5. Leave a comment noting this:\n\n```python\n# Note: 1M context beta (context-1m-2025-08-07) not yet supported with Opus 4.5\n```\n\n### Target Model Strings (Opus 4.5)\n\n| Platform | Opus 4.5 Model String |\n|----------|----------------------|\n| Anthropic API (1P) | `claude-opus-4-5-20251101` |\n| AWS Bedrock | `anthropic.claude-opus-4-5-20251101-v1:0` |\n| Google Vertex AI | `claude-opus-4-5@20251101` |\n| Azure AI Foundry | `claude-opus-4-5-20251101` |\n\n### Source Model Strings to Replace\n\n| Source Model | Anthropic API (1P) | AWS Bedrock | Google Vertex AI |\n|--------------|-------------------|-------------|------------------|\n| Sonnet 4.0 | `claude-sonnet-4-20250514` | `anthropic.claude-sonnet-4-20250514-v1:0` | `claude-sonnet-4@20250514` |\n| Sonnet 4.5 | `claude-sonnet-4-5-20250929` | `anthropic.claude-sonnet-4-5-20250929-v1:0` | `claude-sonnet-4-5@20250929` |\n| Opus 4.1 | `claude-opus-4-1-20250422` | `anthropic.claude-opus-4-1-20250422-v1:0` | `claude-opus-4-1@20250422` |\n\n**Do NOT migrate**: Any Haiku models (e.g., `claude-haiku-4-5-20251001`).\n\n## Prompt Adjustments\n\nOpus 4.5 has known behavioral differences from previous models. **Only apply these fixes if the user explicitly requests them or reports a specific issue.** By default, just update model strings.\n\n**Integration guidelines**: When adding snippets, don't just append them to prompts. Integrate them thoughtfully:\n- Use XML tags (e.g., `<code_guidelines>`, `<tool_usage>`) to organize additions\n- Match the style and structure of the existing prompt\n- Place snippets in logical locations (e.g., coding guidelines near other coding instructions)\n- If the prompt already uses XML tags, add new content within appropriate existing tags or create consistent new ones\n\n### 1. Tool Overtriggering\n\nOpus 4.5 is more responsive to system prompts. Aggressive language that prevented undertriggering on previous models may now cause overtriggering.\n\n**Apply if**: User reports tools being called too frequently or unnecessarily.\n\n**Find and soften**:\n- `CRITICAL:` â†’ remove or soften\n- `You MUST...` â†’ `You should...`\n- `ALWAYS do X` â†’ `Do X`\n- `NEVER skip...` â†’ `Don't skip...`\n- `REQUIRED` â†’ remove or soften\n\nOnly apply to tool-triggering instructions. Leave other uses of emphasis alone.\n\n### 2. Over-Engineering Prevention\n\nOpus 4.5 tends to create extra files, add unnecessary abstractions, or build unrequested flexibility.\n\n**Apply if**: User reports unwanted files, excessive abstraction, or unrequested features. Add the snippet from `references/prompt-snippets.md`.\n\n### 3. Code Exploration\n\nOpus 4.5 can be overly conservative about exploring code, proposing solutions without reading files.\n\n**Apply if**: User reports the model proposing fixes without inspecting relevant code. Add the snippet from `references/prompt-snippets.md`.\n\n### 4. Frontend Design\n\n**Apply if**: User requests improved frontend design quality or reports generic-looking outputs.\n\nAdd the frontend aesthetics snippet from `references/prompt-snippets.md`.\n\n### 5. Thinking Sensitivity\n\nWhen extended thinking is not enabled (the default), Opus 4.5 is particularly sensitive to the word \"think\" and its variants. Extended thinking is enabled only if the API request contains a `thinking` parameter.\n\n**Apply if**: User reports issues related to \"thinking\" while extended thinking is not enabled (no `thinking` parameter in request).\n\nReplace \"think\" with alternatives like \"consider,\" \"believe,\" or \"evaluate.\"\n\n## Reference\n\nSee `references/prompt-snippets.md` for the full text of each snippet to add.\n\nSee `references/effort.md` for configuring the effort parameter (only if user requests it)."
              }
            ]
          },
          {
            "name": "code-review",
            "description": "Automated code review for pull requests using multiple specialized agents with confidence-based scoring to filter false positives",
            "source": "./plugins/code-review",
            "category": "productivity",
            "version": "1.0.0",
            "author": {
              "name": "Boris Cherny",
              "email": "boris@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-code",
              "/plugin install code-review@claude-code-plugins"
            ],
            "signals": {
              "stars": 55716,
              "forks": 4044,
              "pushed_at": "2026-01-12T23:22:53Z",
              "created_at": "2025-02-22T17:41:21Z",
              "license": null
            },
            "commands": [
              {
                "name": "/code-review",
                "description": "Code review a pull request",
                "path": "plugins/code-review/commands/code-review.md",
                "frontmatter": {
                  "allowed-tools": "Bash(gh issue view:*), Bash(gh search:*), Bash(gh issue list:*), Bash(gh pr comment:*), Bash(gh pr diff:*), Bash(gh pr view:*), Bash(gh pr list:*), mcp__github_inline_comment__create_inline_comment",
                  "description": "Code review a pull request"
                },
                "content": "Provide a code review for the given pull request.\n\n**Agent assumptions (applies to all agents and subagents):**\n- All tools are functional and will work without error. Do not test tools or make exploratory calls.\n- Only call a tool if it is required to complete the task. Every tool call should have a clear purpose.\n\nTo do this, follow these steps precisely:\n\n1. Launch a haiku agent to check if any of the following are true:\n   - The pull request is closed\n   - The pull request is a draft\n   - The pull request does not need code review (e.g. automated PR, trivial change that is obviously correct)\n   - Claude has already commented on this PR (check `gh pr view <PR> --comments` for comments left by claude)\n\n   If any condition is true, stop and do not proceed.\n\nNote: Still review Claude generated PR's.\n\n2. Launch a haiku agent to return a list of file paths (not their contents) for all relevant CLAUDE.md files including:\n   - The root CLAUDE.md file, if it exists\n   - Any CLAUDE.md files in directories containing files modified by the pull request\n\n3. Launch a sonnet agent to view the pull request and return a summary of the changes\n\n4. Launch 4 agents in parallel to independently review the changes. Each agent should return the list of issues, where each issue includes a description and the reason it was flagged (e.g. \"CLAUDE.md adherence\", \"bug\"). The agents should do the following:\n\n   Agents 1 + 2: CLAUDE.md compliance sonnet agents\n   Audit changes for CLAUDE.md compliance in parallel. Note: When evaluating CLAUDE.md compliance for a file, you should only consider CLAUDE.md files that share a file path with the file or parents.\n\n   Agent 3: Opus bug agent (parallel subagent with agent 4)\n   Scan for obvious bugs. Focus only on the diff itself without reading extra context. Flag only significant bugs; ignore nitpicks and likely false positives. Do not flag issues that you cannot validate without looking at context outside of the git diff.\n\n   Agent 4: Opus bug agent (parallel subagent with agent 3)\n   Look for problems that exist in the introduced code. This could be security issues, incorrect logic, etc. Only look for issues that fall within the changed code.\n\n   **CRITICAL: We only want HIGH SIGNAL issues.** Flag issues where:\n   - The code will fail to compile or parse (syntax errors, type errors, missing imports, unresolved references)\n   - The code will definitely produce wrong results regardless of inputs (clear logic errors)\n   - Clear, unambiguous CLAUDE.md violations where you can quote the exact rule being broken\n\n   Do NOT flag:\n   - Code style or quality concerns\n   - Potential issues that depend on specific inputs or state\n   - Subjective suggestions or improvements\n\n   If you are not certain an issue is real, do not flag it. False positives erode trust and waste reviewer time.\n\n   In addition to the above, each subagent should be told the PR title and description. This will help provide context regarding the author's intent.\n\n5. For each issue found in the previous step by agents 3 and 4, launch parallel subagents to validate the issue. These subagents should get the PR title and description along with a description of the issue. The agent's job is to review the issue to validate that the stated issue is truly an issue with high confidence. For example, if an issue such as \"variable is not defined\" was flagged, the subagent's job would be to validate that is actually true in the code. Another example would be CLAUDE.md issues. The agent should validate that the CLAUDE.md rule that was violated is scoped for this file and is actually violated. Use Opus subagents for bugs and logic issues, and sonnet agents for CLAUDE.md violations.\n\n6. Filter out any issues that were not validated in step 5. This step will give us our list of high signal issues for our review.\n\n7. If issues were found, skip to step 8 to post inline comments directly.\n\n   If NO issues were found, post a summary comment using `gh pr comment` (if `--comment` argument is provided):\n   \"No issues found. Checked for bugs and CLAUDE.md compliance.\"\n\n8. Post inline comments for each issue using `mcp__github_inline_comment__create_inline_comment`. For each comment:\n   - Provide a brief description of the issue\n   - For small, self-contained fixes, include a committable suggestion block\n   - For larger fixes (6+ lines, structural changes, or changes spanning multiple locations), describe the issue and suggested fix without a suggestion block\n\n   **IMPORTANT: Only post ONE comment per unique issue. Do not post duplicate comments.**\n\nUse this list when evaluating issues in Steps 4 and 5 (these are false positives, do NOT flag):\n\n- Pre-existing issues\n- Something that appears to be a bug but is actually correct\n- Pedantic nitpicks that a senior engineer would not flag\n- Issues that a linter will catch (do not run the linter to verify)\n- General code quality concerns (e.g., lack of test coverage, general security issues) unless explicitly required in CLAUDE.md\n- Issues mentioned in CLAUDE.md but explicitly silenced in the code (e.g., via a lint ignore comment)\n\nNotes:\n\n- Use gh CLI to interact with GitHub (e.g., fetch pull requests, create comments). Do not use web fetch.\n- Create a todo list before starting.\n- You must cite and link each issue in inline comments (e.g., if referring to a CLAUDE.md, include a link to it).\n- If no issues are found, post a comment with the following format:\n\n---\n\n## Code review\n\nNo issues found. Checked for bugs and CLAUDE.md compliance.\n\n---\n\n- When linking to code in inline comments, follow the following format precisely, otherwise the Markdown preview won't render correctly: https://github.com/anthropics/claude-code/blob/c21d3c10bc8e898b7ac1a2d745bdc9bc4e423afe/package.json#L10-L15\n  - Requires full git sha\n  - You must provide the full sha. Commands like `https://github.com/owner/repo/blob/$(git rev-parse HEAD)/foo/bar` will not work, since your comment will be directly rendered in Markdown.\n  - Repo name must match the repo you're code reviewing\n  - # sign after the file name\n  - Line range format is L[start]-L[end]\n  - Provide at least 1 line of context before and after, centered on the line you are commenting about (eg. if you are commenting about lines 5-6, you should link to `L4-7`)"
              }
            ],
            "skills": []
          },
          {
            "name": "commit-commands",
            "description": "Commands for git commit workflows including commit, push, and PR creation",
            "source": "./plugins/commit-commands",
            "category": "productivity",
            "version": "1.0.0",
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-code",
              "/plugin install commit-commands@claude-code-plugins"
            ],
            "signals": {
              "stars": 55716,
              "forks": 4044,
              "pushed_at": "2026-01-12T23:22:53Z",
              "created_at": "2025-02-22T17:41:21Z",
              "license": null
            },
            "commands": [
              {
                "name": "/clean_gone",
                "description": "Cleans up all git branches marked as [gone] (branches that have been deleted on the remote but still exist locally), including removing associated worktrees.",
                "path": "plugins/commit-commands/commands/clean_gone.md",
                "frontmatter": {
                  "description": "Cleans up all git branches marked as [gone] (branches that have been deleted on the remote but still exist locally), including removing associated worktrees."
                },
                "content": "## Your Task\n\nYou need to execute the following bash commands to clean up stale local branches that have been deleted from the remote repository.\n\n## Commands to Execute\n\n1. **First, list branches to identify any with [gone] status**\n   Execute this command:\n   ```bash\n   git branch -v\n   ```\n   \n   Note: Branches with a '+' prefix have associated worktrees and must have their worktrees removed before deletion.\n\n2. **Next, identify worktrees that need to be removed for [gone] branches**\n   Execute this command:\n   ```bash\n   git worktree list\n   ```\n\n3. **Finally, remove worktrees and delete [gone] branches (handles both regular and worktree branches)**\n   Execute this command:\n   ```bash\n   # Process all [gone] branches, removing '+' prefix if present\n   git branch -v | grep '\\[gone\\]' | sed 's/^[+* ]//' | awk '{print $1}' | while read branch; do\n     echo \"Processing branch: $branch\"\n     # Find and remove worktree if it exists\n     worktree=$(git worktree list | grep \"\\\\[$branch\\\\]\" | awk '{print $1}')\n     if [ ! -z \"$worktree\" ] && [ \"$worktree\" != \"$(git rev-parse --show-toplevel)\" ]; then\n       echo \"  Removing worktree: $worktree\"\n       git worktree remove --force \"$worktree\"\n     fi\n     # Delete the branch\n     echo \"  Deleting branch: $branch\"\n     git branch -D \"$branch\"\n   done\n   ```\n\n## Expected Behavior\n\nAfter executing these commands, you will:\n\n- See a list of all local branches with their status\n- Identify and remove any worktrees associated with [gone] branches\n- Delete all branches marked as [gone]\n- Provide feedback on which worktrees and branches were removed\n\nIf no branches are marked as [gone], report that no cleanup was needed."
              },
              {
                "name": "/commit-push-pr",
                "description": "Commit, push, and open a PR",
                "path": "plugins/commit-commands/commands/commit-push-pr.md",
                "frontmatter": {
                  "allowed-tools": "Bash(git checkout --branch:*), Bash(git add:*), Bash(git status:*), Bash(git push:*), Bash(git commit:*), Bash(gh pr create:*)",
                  "description": "Commit, push, and open a PR"
                },
                "content": "## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n\n## Your task\n\nBased on the above changes:\n\n1. Create a new branch if on main\n2. Create a single commit with an appropriate message\n3. Push the branch to origin\n4. Create a pull request using `gh pr create`\n5. You have the capability to call multiple tools in a single response. You MUST do all of the above in a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls."
              },
              {
                "name": "/commit",
                "description": "Create a git commit",
                "path": "plugins/commit-commands/commands/commit.md",
                "frontmatter": {
                  "allowed-tools": "Bash(git add:*), Bash(git status:*), Bash(git commit:*)",
                  "description": "Create a git commit"
                },
                "content": "## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n- Recent commits: !`git log --oneline -10`\n\n## Your task\n\nBased on the above changes, create a single git commit.\n\nYou have the capability to call multiple tools in a single response. Stage and create the commit using a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls."
              }
            ],
            "skills": []
          },
          {
            "name": "explanatory-output-style",
            "description": "Adds educational insights about implementation choices and codebase patterns (mimics the deprecated Explanatory output style)",
            "source": "./plugins/explanatory-output-style",
            "category": "learning",
            "version": "1.0.0",
            "author": {
              "name": "Dickson Tsai",
              "email": "dickson@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-code",
              "/plugin install explanatory-output-style@claude-code-plugins"
            ],
            "signals": {
              "stars": 55716,
              "forks": 4044,
              "pushed_at": "2026-01-12T23:22:53Z",
              "created_at": "2025-02-22T17:41:21Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "feature-dev",
            "description": "Comprehensive feature development workflow with specialized agents for codebase exploration, architecture design, and quality review",
            "source": "./plugins/feature-dev",
            "category": "development",
            "version": "1.0.0",
            "author": {
              "name": "Siddharth Bidasaria",
              "email": "sbidasaria@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-code",
              "/plugin install feature-dev@claude-code-plugins"
            ],
            "signals": {
              "stars": 55716,
              "forks": 4044,
              "pushed_at": "2026-01-12T23:22:53Z",
              "created_at": "2025-02-22T17:41:21Z",
              "license": null
            },
            "commands": [
              {
                "name": "/feature-dev",
                "description": "Guided feature development with codebase understanding and architecture focus",
                "path": "plugins/feature-dev/commands/feature-dev.md",
                "frontmatter": {
                  "description": "Guided feature development with codebase understanding and architecture focus",
                  "argument-hint": "Optional feature description"
                },
                "content": "# Feature Development\n\nYou are helping a developer implement a new feature. Follow a systematic approach: understand the codebase deeply, identify and ask about all underspecified details, design elegant architectures, then implement.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities, edge cases, and underspecified behaviors. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation. Ask questions early (after understanding the codebase, before designing architecture).\n- **Understand before acting**: Read and comprehend existing code patterns first\n- **Read files identified by agents**: When launching agents, ask them to return lists of the most important files to read. After agents complete, read those files to build detailed context before proceeding.\n- **Simple and elegant**: Prioritize readable, maintainable, architecturally sound code\n- **Use TodoWrite**: Track all progress throughout\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what needs to be built\n\nInitial request: $ARGUMENTS\n\n**Actions**:\n1. Create todo list with all phases\n2. If feature unclear, ask user for:\n   - What problem are they solving?\n   - What should the feature do?\n   - Any constraints or requirements?\n3. Summarize understanding and confirm with user\n\n---\n\n## Phase 2: Codebase Exploration\n\n**Goal**: Understand relevant existing code and patterns at both high and low levels\n\n**Actions**:\n1. Launch 2-3 code-explorer agents in parallel. Each agent should:\n   - Trace through the code comprehensively and focus on getting a comprehensive understanding of abstractions, architecture and flow of control\n   - Target a different aspect of the codebase (eg. similar features, high level understanding, architectural understanding, user experience, etc)\n   - Include a list of 5-10 key files to read\n\n   **Example agent prompts**:\n   - \"Find features similar to [feature] and trace through their implementation comprehensively\"\n   - \"Map the architecture and abstractions for [feature area], tracing through the code comprehensively\"\n   - \"Analyze the current implementation of [existing feature/area], tracing through the code comprehensively\"\n   - \"Identify UI patterns, testing approaches, or extension points relevant to [feature]\"\n\n2. Once the agents return, please read all files identified by agents to build deep understanding\n3. Present comprehensive summary of findings and patterns discovered\n\n---\n\n## Phase 3: Clarifying Questions\n\n**Goal**: Fill in gaps and resolve all ambiguities before designing\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. Review the codebase findings and original feature request\n2. Identify underspecified aspects: edge cases, error handling, integration points, scope boundaries, design preferences, backward compatibility, performance needs\n3. **Present all questions to the user in a clear, organized list**\n4. **Wait for answers before proceeding to architecture design**\n\nIf the user says \"whatever you think is best\", provide your recommendation and get explicit confirmation.\n\n---\n\n## Phase 4: Architecture Design\n\n**Goal**: Design multiple implementation approaches with different trade-offs\n\n**Actions**:\n1. Launch 2-3 code-architect agents in parallel with different focuses: minimal changes (smallest change, maximum reuse), clean architecture (maintainability, elegant abstractions), or pragmatic balance (speed + quality)\n2. Review all approaches and form your opinion on which fits best for this specific task (consider: small fix vs large feature, urgency, complexity, team context)\n3. Present to user: brief summary of each approach, trade-offs comparison, **your recommendation with reasoning**, concrete implementation differences\n4. **Ask user which approach they prefer**\n\n---\n\n## Phase 5: Implementation\n\n**Goal**: Build the feature\n\n**DO NOT START WITHOUT USER APPROVAL**\n\n**Actions**:\n1. Wait for explicit user approval\n2. Read all relevant files identified in previous phases\n3. Implement following chosen architecture\n4. Follow codebase conventions strictly\n5. Write clean, well-documented code\n6. Update todos as you progress\n\n---\n\n## Phase 6: Quality Review\n\n**Goal**: Ensure code is simple, DRY, elegant, easy to read, and functionally correct\n\n**Actions**:\n1. Launch 3 code-reviewer agents in parallel with different focuses: simplicity/DRY/elegance, bugs/functional correctness, project conventions/abstractions\n2. Consolidate findings and identify highest severity issues that you recommend fixing\n3. **Present findings to user and ask what they want to do** (fix now, fix later, or proceed as-is)\n4. Address issues based on user decision\n\n---\n\n## Phase 7: Summary\n\n**Goal**: Document what was accomplished\n\n**Actions**:\n1. Mark all todos complete\n2. Summarize:\n   - What was built\n   - Key decisions made\n   - Files modified\n   - Suggested next steps\n\n---"
              }
            ],
            "skills": []
          },
          {
            "name": "frontend-design",
            "description": "Create distinctive, production-grade frontend interfaces with high design quality. Generates creative, polished code that avoids generic AI aesthetics.",
            "source": "./plugins/frontend-design",
            "category": "development",
            "version": "1.0.0",
            "author": {
              "name": "Prithvi Rajasekaran & Alexander Bricken",
              "email": "prithvi@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-code",
              "/plugin install frontend-design@claude-code-plugins"
            ],
            "signals": {
              "stars": 55716,
              "forks": 4044,
              "pushed_at": "2026-01-12T23:22:53Z",
              "created_at": "2025-02-22T17:41:21Z",
              "license": null
            },
            "commands": [],
            "skills": [
              {
                "name": "frontend-design",
                "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.",
                "path": "plugins/frontend-design/skills/frontend-design/SKILL.md",
                "frontmatter": {
                  "name": "frontend-design",
                  "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "This skill guides creation of distinctive, production-grade frontend interfaces that avoid generic \"AI slop\" aesthetics. Implement real working code with exceptional attention to aesthetic details and creative choices.\n\nThe user provides frontend requirements: a component, page, application, or interface to build. They may include context about the purpose, audience, or technical constraints.\n\n## Design Thinking\n\nBefore coding, understand the context and commit to a BOLD aesthetic direction:\n- **Purpose**: What problem does this interface solve? Who uses it?\n- **Tone**: Pick an extreme: brutally minimal, maximalist chaos, retro-futuristic, organic/natural, luxury/refined, playful/toy-like, editorial/magazine, brutalist/raw, art deco/geometric, soft/pastel, industrial/utilitarian, etc. There are so many flavors to choose from. Use these for inspiration but design one that is true to the aesthetic direction.\n- **Constraints**: Technical requirements (framework, performance, accessibility).\n- **Differentiation**: What makes this UNFORGETTABLE? What's the one thing someone will remember?\n\n**CRITICAL**: Choose a clear conceptual direction and execute it with precision. Bold maximalism and refined minimalism both work - the key is intentionality, not intensity.\n\nThen implement working code (HTML/CSS/JS, React, Vue, etc.) that is:\n- Production-grade and functional\n- Visually striking and memorable\n- Cohesive with a clear aesthetic point-of-view\n- Meticulously refined in every detail\n\n## Frontend Aesthetics Guidelines\n\nFocus on:\n- **Typography**: Choose fonts that are beautiful, unique, and interesting. Avoid generic fonts like Arial and Inter; opt instead for distinctive choices that elevate the frontend's aesthetics; unexpected, characterful font choices. Pair a distinctive display font with a refined body font.\n- **Color & Theme**: Commit to a cohesive aesthetic. Use CSS variables for consistency. Dominant colors with sharp accents outperform timid, evenly-distributed palettes.\n- **Motion**: Use animations for effects and micro-interactions. Prioritize CSS-only solutions for HTML. Use Motion library for React when available. Focus on high-impact moments: one well-orchestrated page load with staggered reveals (animation-delay) creates more delight than scattered micro-interactions. Use scroll-triggering and hover states that surprise.\n- **Spatial Composition**: Unexpected layouts. Asymmetry. Overlap. Diagonal flow. Grid-breaking elements. Generous negative space OR controlled density.\n- **Backgrounds & Visual Details**: Create atmosphere and depth rather than defaulting to solid colors. Add contextual effects and textures that match the overall aesthetic. Apply creative forms like gradient meshes, noise textures, geometric patterns, layered transparencies, dramatic shadows, decorative borders, custom cursors, and grain overlays.\n\nNEVER use generic AI-generated aesthetics like overused font families (Inter, Roboto, Arial, system fonts), cliched color schemes (particularly purple gradients on white backgrounds), predictable layouts and component patterns, and cookie-cutter design that lacks context-specific character.\n\nInterpret creatively and make unexpected choices that feel genuinely designed for the context. No design should be the same. Vary between light and dark themes, different fonts, different aesthetics. NEVER converge on common choices (Space Grotesk, for example) across generations.\n\n**IMPORTANT**: Match implementation complexity to the aesthetic vision. Maximalist designs need elaborate code with extensive animations and effects. Minimalist or refined designs need restraint, precision, and careful attention to spacing, typography, and subtle details. Elegance comes from executing the vision well.\n\nRemember: Claude is capable of extraordinary creative work. Don't hold back, show what can truly be created when thinking outside the box and committing fully to a distinctive vision."
              }
            ]
          },
          {
            "name": "hookify",
            "description": "Easily create custom hooks to prevent unwanted behaviors by analyzing conversation patterns or from explicit instructions. Define rules via simple markdown files.",
            "source": "./plugins/hookify",
            "category": "productivity",
            "version": "0.1.0",
            "author": {
              "name": "Daisy Hollman",
              "email": "daisy@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-code",
              "/plugin install hookify@claude-code-plugins"
            ],
            "signals": {
              "stars": 55716,
              "forks": 4044,
              "pushed_at": "2026-01-12T23:22:53Z",
              "created_at": "2025-02-22T17:41:21Z",
              "license": null
            },
            "commands": [
              {
                "name": "/configure",
                "description": "Enable or disable hookify rules interactively",
                "path": "plugins/hookify/commands/configure.md",
                "frontmatter": {
                  "description": "Enable or disable hookify rules interactively",
                  "allowed-tools": [
                    "Glob",
                    "Read",
                    "Edit",
                    "AskUserQuestion",
                    "Skill"
                  ]
                },
                "content": "# Configure Hookify Rules\n\n**Load hookify:writing-rules skill first** to understand rule format.\n\nEnable or disable existing hookify rules using an interactive interface.\n\n## Steps\n\n### 1. Find Existing Rules\n\nUse Glob tool to find all hookify rule files:\n```\npattern: \".claude/hookify.*.local.md\"\n```\n\nIf no rules found, inform user:\n```\nNo hookify rules configured yet. Use `/hookify` to create your first rule.\n```\n\n### 2. Read Current State\n\nFor each rule file:\n- Read the file\n- Extract `name` and `enabled` fields from frontmatter\n- Build list of rules with current state\n\n### 3. Ask User Which Rules to Toggle\n\nUse AskUserQuestion to let user select rules:\n\n```json\n{\n  \"questions\": [\n    {\n      \"question\": \"Which rules would you like to enable or disable?\",\n      \"header\": \"Configure\",\n      \"multiSelect\": true,\n      \"options\": [\n        {\n          \"label\": \"warn-dangerous-rm (currently enabled)\",\n          \"description\": \"Warns about rm -rf commands\"\n        },\n        {\n          \"label\": \"warn-console-log (currently disabled)\",\n          \"description\": \"Warns about console.log in code\"\n        },\n        {\n          \"label\": \"require-tests (currently enabled)\",\n          \"description\": \"Requires tests before stopping\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Option format:**\n- Label: `{rule-name} (currently {enabled|disabled})`\n- Description: Brief description from rule's message or pattern\n\n### 4. Parse User Selection\n\nFor each selected rule:\n- Determine current state from label (enabled/disabled)\n- Toggle state: enabled â†’ disabled, disabled â†’ enabled\n\n### 5. Update Rule Files\n\nFor each rule to toggle:\n- Use Read tool to read current content\n- Use Edit tool to change `enabled: true` to `enabled: false` (or vice versa)\n- Handle both with and without quotes\n\n**Edit pattern for enabling:**\n```\nold_string: \"enabled: false\"\nnew_string: \"enabled: true\"\n```\n\n**Edit pattern for disabling:**\n```\nold_string: \"enabled: true\"\nnew_string: \"enabled: false\"\n```\n\n### 6. Confirm Changes\n\nShow user what was changed:\n\n```\n## Hookify Rules Updated\n\n**Enabled:**\n- warn-console-log\n\n**Disabled:**\n- warn-dangerous-rm\n\n**Unchanged:**\n- require-tests\n\nChanges apply immediately - no restart needed\n```\n\n## Important Notes\n\n- Changes take effect immediately on next tool use\n- You can also manually edit .claude/hookify.*.local.md files\n- To permanently remove a rule, delete its .local.md file\n- Use `/hookify:list` to see all configured rules\n\n## Edge Cases\n\n**No rules to configure:**\n- Show message about using `/hookify` to create rules first\n\n**User selects no rules:**\n- Inform that no changes were made\n\n**File read/write errors:**\n- Inform user of specific error\n- Suggest manual editing as fallback"
              },
              {
                "name": "/help",
                "description": "Get help with the hookify plugin",
                "path": "plugins/hookify/commands/help.md",
                "frontmatter": {
                  "description": "Get help with the hookify plugin",
                  "allowed-tools": [
                    "Read"
                  ]
                },
                "content": "# Hookify Plugin Help\n\nExplain how the hookify plugin works and how to use it.\n\n## Overview\n\nThe hookify plugin makes it easy to create custom hooks that prevent unwanted behaviors. Instead of editing `hooks.json` files, users create simple markdown configuration files that define patterns to watch for.\n\n## How It Works\n\n### 1. Hook System\n\nHookify installs generic hooks that run on these events:\n- **PreToolUse**: Before any tool executes (Bash, Edit, Write, etc.)\n- **PostToolUse**: After a tool executes\n- **Stop**: When Claude wants to stop working\n- **UserPromptSubmit**: When user submits a prompt\n\nThese hooks read configuration files from `.claude/hookify.*.local.md` and check if any rules match the current operation.\n\n### 2. Configuration Files\n\nUsers create rules in `.claude/hookify.{rule-name}.local.md` files:\n\n```markdown\n---\nname: warn-dangerous-rm\nenabled: true\nevent: bash\npattern: rm\\s+-rf\n---\n\nâš ï¸ **Dangerous rm command detected!**\n\nThis command could delete important files. Please verify the path.\n```\n\n**Key fields:**\n- `name`: Unique identifier for the rule\n- `enabled`: true/false to activate/deactivate\n- `event`: bash, file, stop, prompt, or all\n- `pattern`: Regex pattern to match\n\nThe message body is what Claude sees when the rule triggers.\n\n### 3. Creating Rules\n\n**Option A: Use /hookify command**\n```\n/hookify Don't use console.log in production files\n```\n\nThis analyzes your request and creates the appropriate rule file.\n\n**Option B: Create manually**\nCreate `.claude/hookify.my-rule.local.md` with the format above.\n\n**Option C: Analyze conversation**\n```\n/hookify\n```\n\nWithout arguments, hookify analyzes recent conversation to find behaviors you want to prevent.\n\n## Available Commands\n\n- **`/hookify`** - Create hooks from conversation analysis or explicit instructions\n- **`/hookify:help`** - Show this help (what you're reading now)\n- **`/hookify:list`** - List all configured hooks\n- **`/hookify:configure`** - Enable/disable existing hooks interactively\n\n## Example Use Cases\n\n**Prevent dangerous commands:**\n```markdown\n---\nname: block-chmod-777\nenabled: true\nevent: bash\npattern: chmod\\s+777\n---\n\nDon't use chmod 777 - it's a security risk. Use specific permissions instead.\n```\n\n**Warn about debugging code:**\n```markdown\n---\nname: warn-console-log\nenabled: true\nevent: file\npattern: console\\.log\\(\n---\n\nConsole.log detected. Remember to remove debug logging before committing.\n```\n\n**Require tests before stopping:**\n```markdown\n---\nname: require-tests\nenabled: true\nevent: stop\npattern: .*\n---\n\nDid you run tests before finishing? Make sure `npm test` or equivalent was executed.\n```\n\n## Pattern Syntax\n\nUse Python regex syntax:\n- `\\s` - whitespace\n- `\\.` - literal dot\n- `|` - OR\n- `+` - one or more\n- `*` - zero or more\n- `\\d` - digit\n- `[abc]` - character class\n\n**Examples:**\n- `rm\\s+-rf` - matches \"rm -rf\"\n- `console\\.log\\(` - matches \"console.log(\"\n- `(eval|exec)\\(` - matches \"eval(\" or \"exec(\"\n- `\\.env$` - matches files ending in .env\n\n## Important Notes\n\n**No Restart Needed**: Hookify rules (`.local.md` files) take effect immediately on the next tool use. The hookify hooks are already loaded and read your rules dynamically.\n\n**Block or Warn**: Rules can either `block` operations (prevent execution) or `warn` (show message but allow). Set `action: block` or `action: warn` in the rule's frontmatter.\n\n**Rule Files**: Keep rules in `.claude/hookify.*.local.md` - they should be git-ignored (add to .gitignore if needed).\n\n**Disable Rules**: Set `enabled: false` in frontmatter or delete the file.\n\n## Troubleshooting\n\n**Hook not triggering:**\n- Check rule file is in `.claude/` directory\n- Verify `enabled: true` in frontmatter\n- Confirm pattern is valid regex\n- Test pattern: `python3 -c \"import re; print(re.search('your_pattern', 'test_text'))\"`\n- Rules take effect immediately - no restart needed\n\n**Import errors:**\n- Check Python 3 is available: `python3 --version`\n- Verify hookify plugin is installed correctly\n\n**Pattern not matching:**\n- Test regex separately\n- Check for escaping issues (use unquoted patterns in YAML)\n- Try simpler pattern first, then refine\n\n## Getting Started\n\n1. Create your first rule:\n   ```\n   /hookify Warn me when I try to use rm -rf\n   ```\n\n2. Try to trigger it:\n   - Ask Claude to run `rm -rf /tmp/test`\n   - You should see the warning\n\n4. Refine the rule by editing `.claude/hookify.warn-rm.local.md`\n\n5. Create more rules as you encounter unwanted behaviors\n\nFor more examples, check the `${CLAUDE_PLUGIN_ROOT}/examples/` directory."
              },
              {
                "name": "/hookify",
                "description": "Create hooks to prevent unwanted behaviors from conversation analysis or explicit instructions",
                "path": "plugins/hookify/commands/hookify.md",
                "frontmatter": {
                  "description": "Create hooks to prevent unwanted behaviors from conversation analysis or explicit instructions",
                  "argument-hint": "Optional specific behavior to address",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "AskUserQuestion",
                    "Task",
                    "Grep",
                    "TodoWrite",
                    "Skill"
                  ]
                },
                "content": "# Hookify - Create Hooks from Unwanted Behaviors\n\n**FIRST: Load the hookify:writing-rules skill** using the Skill tool to understand rule file format and syntax.\n\nCreate hook rules to prevent problematic behaviors by analyzing the conversation or from explicit user instructions.\n\n## Your Task\n\nYou will help the user create hookify rules to prevent unwanted behaviors. Follow these steps:\n\n### Step 1: Gather Behavior Information\n\n**If $ARGUMENTS is provided:**\n- User has given specific instructions: `$ARGUMENTS`\n- Still analyze recent conversation (last 10-15 user messages) for additional context\n- Look for examples of the behavior happening\n\n**If $ARGUMENTS is empty:**\n- Launch the conversation-analyzer agent to find problematic behaviors\n- Agent will scan user prompts for frustration signals\n- Agent will return structured findings\n\n**To analyze conversation:**\nUse the Task tool to launch conversation-analyzer agent:\n```\n{\n  \"subagent_type\": \"general-purpose\",\n  \"description\": \"Analyze conversation for unwanted behaviors\",\n  \"prompt\": \"You are analyzing a Claude Code conversation to find behaviors the user wants to prevent.\n\nRead user messages in the current conversation and identify:\n1. Explicit requests to avoid something (\\\"don't do X\\\", \\\"stop doing Y\\\")\n2. Corrections or reversions (user fixing Claude's actions)\n3. Frustrated reactions (\\\"why did you do X?\\\", \\\"I didn't ask for that\\\")\n4. Repeated issues (same problem multiple times)\n\nFor each issue found, extract:\n- What tool was used (Bash, Edit, Write, etc.)\n- Specific pattern or command\n- Why it was problematic\n- User's stated reason\n\nReturn findings as a structured list with:\n- category: Type of issue\n- tool: Which tool was involved\n- pattern: Regex or literal pattern to match\n- context: What happened\n- severity: high/medium/low\n\nFocus on the most recent issues (last 20-30 messages). Don't go back further unless explicitly asked.\"\n}\n```\n\n### Step 2: Present Findings to User\n\nAfter gathering behaviors (from arguments or agent), present to user using AskUserQuestion:\n\n**Question 1: Which behaviors to hookify?**\n- Header: \"Create Rules\"\n- multiSelect: true\n- Options: List each detected behavior (max 4)\n  - Label: Short description (e.g., \"Block rm -rf\")\n  - Description: Why it's problematic\n\n**Question 2: For each selected behavior, ask about action:**\n- \"Should this block the operation or just warn?\"\n- Options:\n  - \"Just warn\" (action: warn - shows message but allows)\n  - \"Block operation\" (action: block - prevents execution)\n\n**Question 3: Ask for example patterns:**\n- \"What patterns should trigger this rule?\"\n- Show detected patterns\n- Allow user to refine or add more\n\n### Step 3: Generate Rule Files\n\nFor each confirmed behavior, create a `.claude/hookify.{rule-name}.local.md` file:\n\n**Rule naming convention:**\n- Use kebab-case\n- Be descriptive: `block-dangerous-rm`, `warn-console-log`, `require-tests-before-stop`\n- Start with action verb: block, warn, prevent, require\n\n**File format:**\n```markdown\n---\nname: {rule-name}\nenabled: true\nevent: {bash|file|stop|prompt|all}\npattern: {regex pattern}\naction: {warn|block}\n---\n\n{Message to show Claude when rule triggers}\n```\n\n**Action values:**\n- `warn`: Show message but allow operation (default)\n- `block`: Prevent operation or stop session\n\n**For more complex rules (multiple conditions):**\n```markdown\n---\nname: {rule-name}\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$\n  - field: new_text\n    operator: contains\n    pattern: API_KEY\n---\n\n{Warning message}\n```\n\n### Step 4: Create Files and Confirm\n\n**IMPORTANT**: Rule files must be created in the current working directory's `.claude/` folder, NOT the plugin directory.\n\nUse the current working directory (where Claude Code was started) as the base path.\n\n1. Check if `.claude/` directory exists in current working directory\n   - If not, create it first with: `mkdir -p .claude`\n\n2. Use Write tool to create each `.claude/hookify.{name}.local.md` file\n   - Use relative path from current working directory: `.claude/hookify.{name}.local.md`\n   - The path should resolve to the project's .claude directory, not the plugin's\n\n3. Show user what was created:\n   ```\n   Created 3 hookify rules:\n   - .claude/hookify.dangerous-rm.local.md\n   - .claude/hookify.console-log.local.md\n   - .claude/hookify.sensitive-files.local.md\n\n   These rules will trigger on:\n   - dangerous-rm: Bash commands matching \"rm -rf\"\n   - console-log: Edits adding console.log statements\n   - sensitive-files: Edits to .env or credentials files\n   ```\n\n4. Verify files were created in the correct location by listing them\n\n5. Inform user: **\"Rules are active immediately - no restart needed!\"**\n\n   The hookify hooks are already loaded and will read your new rules on the next tool use.\n\n## Event Types Reference\n\n- **bash**: Matches Bash tool commands\n- **file**: Matches Edit, Write, MultiEdit tools\n- **stop**: Matches when agent wants to stop (use for completion checks)\n- **prompt**: Matches when user submits prompts\n- **all**: Matches all events\n\n## Pattern Writing Tips\n\n**Bash patterns:**\n- Match dangerous commands: `rm\\s+-rf|chmod\\s+777|dd\\s+if=`\n- Match specific tools: `npm\\s+install\\s+|pip\\s+install`\n\n**File patterns:**\n- Match code patterns: `console\\.log\\(|eval\\(|innerHTML\\s*=`\n- Match file paths: `\\.env$|\\.git/|node_modules/`\n\n**Stop patterns:**\n- Check for missing steps: (check transcript or completion criteria)\n\n## Example Workflow\n\n**User says**: \"/hookify Don't use rm -rf without asking me first\"\n\n**Your response**:\n1. Analyze: User wants to prevent rm -rf commands\n2. Ask: \"Should I block this command or just warn you?\"\n3. User selects: \"Just warn\"\n4. Create `.claude/hookify.dangerous-rm.local.md`:\n   ```markdown\n   ---\n   name: warn-dangerous-rm\n   enabled: true\n   event: bash\n   pattern: rm\\s+-rf\n   ---\n\n   âš ï¸ **Dangerous rm command detected**\n\n   You requested to be warned before using rm -rf.\n   Please verify the path is correct.\n   ```\n5. Confirm: \"Created hookify rule. It's active immediately - try triggering it!\"\n\n## Important Notes\n\n- **No restart needed**: Rules take effect immediately on the next tool use\n- **File location**: Create files in project's `.claude/` directory (current working directory), NOT the plugin's .claude/\n- **Regex syntax**: Use Python regex syntax (raw strings, no need to escape in YAML)\n- **Action types**: Rules can `warn` (default) or `block` operations\n- **Testing**: Test rules immediately after creating them\n\n## Troubleshooting\n\n**If rule file creation fails:**\n1. Check current working directory with pwd\n2. Ensure `.claude/` directory exists (create with mkdir if needed)\n3. Use absolute path if needed: `{cwd}/.claude/hookify.{name}.local.md`\n4. Verify file was created with Glob or ls\n\n**If rule doesn't trigger after creation:**\n1. Verify file is in project `.claude/` not plugin `.claude/`\n2. Check file with Read tool to ensure pattern is correct\n3. Test pattern with: `python3 -c \"import re; print(re.search(r'pattern', 'test text'))\"`\n4. Verify `enabled: true` in frontmatter\n5. Remember: Rules work immediately, no restart needed\n\n**If blocking seems too strict:**\n1. Change `action: block` to `action: warn` in the rule file\n2. Or adjust the pattern to be more specific\n3. Changes take effect on next tool use\n\nUse TodoWrite to track your progress through the steps."
              },
              {
                "name": "/list",
                "description": "List all configured hookify rules",
                "path": "plugins/hookify/commands/list.md",
                "frontmatter": {
                  "description": "List all configured hookify rules",
                  "allowed-tools": [
                    "Glob",
                    "Read",
                    "Skill"
                  ]
                },
                "content": "# List Hookify Rules\n\n**Load hookify:writing-rules skill first** to understand rule format.\n\nShow all configured hookify rules in the project.\n\n## Steps\n\n1. Use Glob tool to find all hookify rule files:\n   ```\n   pattern: \".claude/hookify.*.local.md\"\n   ```\n\n2. For each file found:\n   - Use Read tool to read the file\n   - Extract frontmatter fields: name, enabled, event, pattern\n   - Extract message preview (first 100 chars)\n\n3. Present results in a table:\n\n```\n## Configured Hookify Rules\n\n| Name | Enabled | Event | Pattern | File |\n|------|---------|-------|---------|------|\n| warn-dangerous-rm | âœ… Yes | bash | rm\\s+-rf | hookify.dangerous-rm.local.md |\n| warn-console-log | âœ… Yes | file | console\\.log\\( | hookify.console-log.local.md |\n| check-tests | âŒ No | stop | .* | hookify.require-tests.local.md |\n\n**Total**: 3 rules (2 enabled, 1 disabled)\n```\n\n4. For each rule, show a brief preview:\n```\n### warn-dangerous-rm\n**Event**: bash\n**Pattern**: `rm\\s+-rf`\n**Message**: \"âš ï¸ **Dangerous rm command detected!** This command could delete...\"\n\n**Status**: âœ… Active\n**File**: .claude/hookify.dangerous-rm.local.md\n```\n\n5. Add helpful footer:\n```\n---\n\nTo modify a rule: Edit the .local.md file directly\nTo disable a rule: Set `enabled: false` in frontmatter\nTo enable a rule: Set `enabled: true` in frontmatter\nTo delete a rule: Remove the .local.md file\nTo create a rule: Use `/hookify` command\n\n**Remember**: Changes take effect immediately - no restart needed\n```\n\n## If No Rules Found\n\nIf no hookify rules exist:\n\n```\n## No Hookify Rules Configured\n\nYou haven't created any hookify rules yet.\n\nTo get started:\n1. Use `/hookify` to analyze conversation and create rules\n2. Or manually create `.claude/hookify.my-rule.local.md` files\n3. See `/hookify:help` for documentation\n\nExample:\n```\n/hookify Warn me when I use console.log\n```\n\nCheck `${CLAUDE_PLUGIN_ROOT}/examples/` for example rule files.\n```"
              }
            ],
            "skills": [
              {
                "name": "Writing Hookify Rules",
                "description": "This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"configure hookify\", \"add a hookify rule\", or needs guidance on hookify rule syntax and patterns.",
                "path": "plugins/hookify/skills/writing-rules/SKILL.md",
                "frontmatter": {
                  "name": "Writing Hookify Rules",
                  "description": "This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"configure hookify\", \"add a hookify rule\", or needs guidance on hookify rule syntax and patterns.",
                  "version": "0.1.0"
                },
                "content": "# Writing Hookify Rules\n\n## Overview\n\nHookify rules are markdown files with YAML frontmatter that define patterns to watch for and messages to show when those patterns match. Rules are stored in `.claude/hookify.{rule-name}.local.md` files.\n\n## Rule File Format\n\n### Basic Structure\n\n```markdown\n---\nname: rule-identifier\nenabled: true\nevent: bash|file|stop|prompt|all\npattern: regex-pattern-here\n---\n\nMessage to show Claude when this rule triggers.\nCan include markdown formatting, warnings, suggestions, etc.\n```\n\n### Frontmatter Fields\n\n**name** (required): Unique identifier for the rule\n- Use kebab-case: `warn-dangerous-rm`, `block-console-log`\n- Be descriptive and action-oriented\n- Start with verb: warn, prevent, block, require, check\n\n**enabled** (required): Boolean to activate/deactivate\n- `true`: Rule is active\n- `false`: Rule is disabled (won't trigger)\n- Can toggle without deleting rule\n\n**event** (required): Which hook event to trigger on\n- `bash`: Bash tool commands\n- `file`: Edit, Write, MultiEdit tools\n- `stop`: When agent wants to stop\n- `prompt`: When user submits a prompt\n- `all`: All events\n\n**action** (optional): What to do when rule matches\n- `warn`: Show message but allow operation (default)\n- `block`: Prevent operation (PreToolUse) or stop session (Stop events)\n- If omitted, defaults to `warn`\n\n**pattern** (simple format): Regex pattern to match\n- Used for simple single-condition rules\n- Matches against command (bash) or new_text (file)\n- Python regex syntax\n\n**Example:**\n```yaml\nevent: bash\npattern: rm\\s+-rf\n```\n\n### Advanced Format (Multiple Conditions)\n\nFor complex rules with multiple conditions:\n\n```markdown\n---\nname: warn-env-file-edits\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$\n  - field: new_text\n    operator: contains\n    pattern: API_KEY\n---\n\nYou're adding an API key to a .env file. Ensure this file is in .gitignore!\n```\n\n**Condition fields:**\n- `field`: Which field to check\n  - For bash: `command`\n  - For file: `file_path`, `new_text`, `old_text`, `content`\n- `operator`: How to match\n  - `regex_match`: Regex pattern matching\n  - `contains`: Substring check\n  - `equals`: Exact match\n  - `not_contains`: Substring must NOT be present\n  - `starts_with`: Prefix check\n  - `ends_with`: Suffix check\n- `pattern`: Pattern or string to match\n\n**All conditions must match for rule to trigger.**\n\n## Message Body\n\nThe markdown content after frontmatter is shown to Claude when the rule triggers.\n\n**Good messages:**\n- Explain what was detected\n- Explain why it's problematic\n- Suggest alternatives or best practices\n- Use formatting for clarity (bold, lists, etc.)\n\n**Example:**\n```markdown\nâš ï¸ **Console.log detected!**\n\nYou're adding console.log to production code.\n\n**Why this matters:**\n- Debug logs shouldn't ship to production\n- Console.log can expose sensitive data\n- Impacts browser performance\n\n**Alternatives:**\n- Use a proper logging library\n- Remove before committing\n- Use conditional debug builds\n```\n\n## Event Type Guide\n\n### bash Events\n\nMatch Bash command patterns:\n\n```markdown\n---\nevent: bash\npattern: sudo\\s+|rm\\s+-rf|chmod\\s+777\n---\n\nDangerous command detected!\n```\n\n**Common patterns:**\n- Dangerous commands: `rm\\s+-rf`, `dd\\s+if=`, `mkfs`\n- Privilege escalation: `sudo\\s+`, `su\\s+`\n- Permission issues: `chmod\\s+777`, `chown\\s+root`\n\n### file Events\n\nMatch Edit/Write/MultiEdit operations:\n\n```markdown\n---\nevent: file\npattern: console\\.log\\(|eval\\(|innerHTML\\s*=\n---\n\nPotentially problematic code pattern detected!\n```\n\n**Match on different fields:**\n```markdown\n---\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.tsx?$\n  - field: new_text\n    operator: regex_match\n    pattern: console\\.log\\(\n---\n\nConsole.log in TypeScript file!\n```\n\n**Common patterns:**\n- Debug code: `console\\.log\\(`, `debugger`, `print\\(`\n- Security risks: `eval\\(`, `innerHTML\\s*=`, `dangerouslySetInnerHTML`\n- Sensitive files: `\\.env$`, `credentials`, `\\.pem$`\n- Generated files: `node_modules/`, `dist/`, `build/`\n\n### stop Events\n\nMatch when agent wants to stop (completion checks):\n\n```markdown\n---\nevent: stop\npattern: .*\n---\n\nBefore stopping, verify:\n- [ ] Tests were run\n- [ ] Build succeeded\n- [ ] Documentation updated\n```\n\n**Use for:**\n- Reminders about required steps\n- Completion checklists\n- Process enforcement\n\n### prompt Events\n\nMatch user prompt content (advanced):\n\n```markdown\n---\nevent: prompt\nconditions:\n  - field: user_prompt\n    operator: contains\n    pattern: deploy to production\n---\n\nProduction deployment checklist:\n- [ ] Tests passing?\n- [ ] Reviewed by team?\n- [ ] Monitoring ready?\n```\n\n## Pattern Writing Tips\n\n### Regex Basics\n\n**Literal characters:** Most characters match themselves\n- `rm` matches \"rm\"\n- `console.log` matches \"console.log\"\n\n**Special characters need escaping:**\n- `.` (any char) â†’ `\\.` (literal dot)\n- `(` `)` â†’ `\\(` `\\)` (literal parens)\n- `[` `]` â†’ `\\[` `\\]` (literal brackets)\n\n**Common metacharacters:**\n- `\\s` - whitespace (space, tab, newline)\n- `\\d` - digit (0-9)\n- `\\w` - word character (a-z, A-Z, 0-9, _)\n- `.` - any character\n- `+` - one or more\n- `*` - zero or more\n- `?` - zero or one\n- `|` - OR\n\n**Examples:**\n```\nrm\\s+-rf         Matches: rm -rf, rm  -rf\nconsole\\.log\\(   Matches: console.log(\n(eval|exec)\\(    Matches: eval( or exec(\nchmod\\s+777      Matches: chmod 777, chmod  777\nAPI_KEY\\s*=      Matches: API_KEY=, API_KEY =\n```\n\n### Testing Patterns\n\nTest regex patterns before using:\n\n```bash\npython3 -c \"import re; print(re.search(r'your_pattern', 'test text'))\"\n```\n\nOr use online regex testers (regex101.com with Python flavor).\n\n### Common Pitfalls\n\n**Too broad:**\n```yaml\npattern: log    # Matches \"log\", \"login\", \"dialog\", \"catalog\"\n```\nBetter: `console\\.log\\(|logger\\.`\n\n**Too specific:**\n```yaml\npattern: rm -rf /tmp  # Only matches exact path\n```\nBetter: `rm\\s+-rf`\n\n**Escaping issues:**\n- YAML quoted strings: `\"pattern\"` requires double backslashes `\\\\s`\n- YAML unquoted: `pattern: \\s` works as-is\n- **Recommendation**: Use unquoted patterns in YAML\n\n## File Organization\n\n**Location:** All rules in `.claude/` directory\n**Naming:** `.claude/hookify.{descriptive-name}.local.md`\n**Gitignore:** Add `.claude/*.local.md` to `.gitignore`\n\n**Good names:**\n- `hookify.dangerous-rm.local.md`\n- `hookify.console-log.local.md`\n- `hookify.require-tests.local.md`\n- `hookify.sensitive-files.local.md`\n\n**Bad names:**\n- `hookify.rule1.local.md` (not descriptive)\n- `hookify.md` (missing .local)\n- `danger.local.md` (missing hookify prefix)\n\n## Workflow\n\n### Creating a Rule\n\n1. Identify unwanted behavior\n2. Determine which tool is involved (Bash, Edit, etc.)\n3. Choose event type (bash, file, stop, etc.)\n4. Write regex pattern\n5. Create `.claude/hookify.{name}.local.md` file in project root\n6. Test immediately - rules are read dynamically on next tool use\n\n### Refining a Rule\n\n1. Edit the `.local.md` file\n2. Adjust pattern or message\n3. Test immediately - changes take effect on next tool use\n\n### Disabling a Rule\n\n**Temporary:** Set `enabled: false` in frontmatter\n**Permanent:** Delete the `.local.md` file\n\n## Examples\n\nSee `${CLAUDE_PLUGIN_ROOT}/examples/` for complete examples:\n- `dangerous-rm.local.md` - Block dangerous rm commands\n- `console-log-warning.local.md` - Warn about console.log\n- `sensitive-files-warning.local.md` - Warn about editing .env files\n\n## Quick Reference\n\n**Minimum viable rule:**\n```markdown\n---\nname: my-rule\nenabled: true\nevent: bash\npattern: dangerous_command\n---\n\nWarning message here\n```\n\n**Rule with conditions:**\n```markdown\n---\nname: my-rule\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.ts$\n  - field: new_text\n    operator: contains\n    pattern: any\n---\n\nWarning message\n```\n\n**Event types:**\n- `bash` - Bash commands\n- `file` - File edits\n- `stop` - Completion checks\n- `prompt` - User input\n- `all` - All events\n\n**Field options:**\n- Bash: `command`\n- File: `file_path`, `new_text`, `old_text`, `content`\n- Prompt: `user_prompt`\n\n**Operators:**\n- `regex_match`, `contains`, `equals`, `not_contains`, `starts_with`, `ends_with`"
              }
            ]
          },
          {
            "name": "learning-output-style",
            "description": "Interactive learning mode that requests meaningful code contributions at decision points (mimics the unshipped Learning output style)",
            "source": "./plugins/learning-output-style",
            "category": "learning",
            "version": "1.0.0",
            "author": {
              "name": "Boris Cherny",
              "email": "boris@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-code",
              "/plugin install learning-output-style@claude-code-plugins"
            ],
            "signals": {
              "stars": 55716,
              "forks": 4044,
              "pushed_at": "2026-01-12T23:22:53Z",
              "created_at": "2025-02-22T17:41:21Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "plugin-dev",
            "description": "Comprehensive toolkit for developing Claude Code plugins. Includes 7 expert skills covering hooks, MCP integration, commands, agents, and best practices. AI-assisted plugin creation and validation.",
            "source": "./plugins/plugin-dev",
            "category": "development",
            "version": "0.1.0",
            "author": {
              "name": "Daisy Hollman",
              "email": "daisy@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-code",
              "/plugin install plugin-dev@claude-code-plugins"
            ],
            "signals": {
              "stars": 55716,
              "forks": 4044,
              "pushed_at": "2026-01-12T23:22:53Z",
              "created_at": "2025-02-22T17:41:21Z",
              "license": null
            },
            "commands": [
              {
                "name": "/create-plugin",
                "description": "Guided end-to-end plugin creation workflow with component design, implementation, and validation",
                "path": "plugins/plugin-dev/commands/create-plugin.md",
                "frontmatter": {
                  "description": "Guided end-to-end plugin creation workflow with component design, implementation, and validation",
                  "argument-hint": "Optional plugin description",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "Grep",
                    "Glob",
                    "Bash",
                    "TodoWrite",
                    "AskUserQuestion",
                    "Skill",
                    "Task"
                  ]
                },
                "content": "# Plugin Creation Workflow\n\nGuide the user through creating a complete, high-quality Claude Code plugin from initial concept to tested implementation. Follow a systematic approach: understand requirements, design components, clarify details, implement following best practices, validate, and test.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities about plugin purpose, triggering, scope, and components. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation.\n- **Load relevant skills**: Use the Skill tool to load plugin-dev skills when needed (plugin-structure, hook-development, agent-development, etc.)\n- **Use specialized agents**: Leverage agent-creator, plugin-validator, and skill-reviewer agents for AI-assisted development\n- **Follow best practices**: Apply patterns from plugin-dev's own implementation\n- **Progressive disclosure**: Create lean skills with references/examples\n- **Use TodoWrite**: Track all progress throughout all phases\n\n**Initial request:** $ARGUMENTS\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what plugin needs to be built and what problem it solves\n\n**Actions**:\n1. Create todo list with all 7 phases\n2. If plugin purpose is clear from arguments:\n   - Summarize understanding\n   - Identify plugin type (integration, workflow, analysis, toolkit, etc.)\n3. If plugin purpose is unclear, ask user:\n   - What problem does this plugin solve?\n   - Who will use it and when?\n   - What should it do?\n   - Any similar plugins to reference?\n4. Summarize understanding and confirm with user before proceeding\n\n**Output**: Clear statement of plugin purpose and target users\n\n---\n\n## Phase 2: Component Planning\n\n**Goal**: Determine what plugin components are needed\n\n**MUST load plugin-structure skill** using Skill tool before this phase.\n\n**Actions**:\n1. Load plugin-structure skill to understand component types\n2. Analyze plugin requirements and determine needed components:\n   - **Skills**: Does it need specialized knowledge? (hooks API, MCP patterns, etc.)\n   - **Commands**: User-initiated actions? (deploy, configure, analyze)\n   - **Agents**: Autonomous tasks? (validation, generation, analysis)\n   - **Hooks**: Event-driven automation? (validation, notifications)\n   - **MCP**: External service integration? (databases, APIs)\n   - **Settings**: User configuration? (.local.md files)\n3. For each component type needed, identify:\n   - How many of each type\n   - What each one does\n   - Rough triggering/usage patterns\n4. Present component plan to user as table:\n   ```\n   | Component Type | Count | Purpose |\n   |----------------|-------|---------|\n   | Skills         | 2     | Hook patterns, MCP usage |\n   | Commands       | 3     | Deploy, configure, validate |\n   | Agents         | 1     | Autonomous validation |\n   | Hooks          | 0     | Not needed |\n   | MCP            | 1     | Database integration |\n   ```\n5. Get user confirmation or adjustments\n\n**Output**: Confirmed list of components to create\n\n---\n\n## Phase 3: Detailed Design & Clarifying Questions\n\n**Goal**: Specify each component in detail and resolve all ambiguities\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. For each component in the plan, identify underspecified aspects:\n   - **Skills**: What triggers them? What knowledge do they provide? How detailed?\n   - **Commands**: What arguments? What tools? Interactive or automated?\n   - **Agents**: When to trigger (proactive/reactive)? What tools? Output format?\n   - **Hooks**: Which events? Prompt or command based? Validation criteria?\n   - **MCP**: What server type? Authentication? Which tools?\n   - **Settings**: What fields? Required vs optional? Defaults?\n\n2. **Present all questions to user in organized sections** (one section per component type)\n\n3. **Wait for answers before proceeding to implementation**\n\n4. If user says \"whatever you think is best\", provide specific recommendations and get explicit confirmation\n\n**Example questions for a skill**:\n- What specific user queries should trigger this skill?\n- Should it include utility scripts? What functionality?\n- How detailed should the core SKILL.md be vs references/?\n- Any real-world examples to include?\n\n**Example questions for an agent**:\n- Should this agent trigger proactively after certain actions, or only when explicitly requested?\n- What tools does it need (Read, Write, Bash, etc.)?\n- What should the output format be?\n- Any specific quality standards to enforce?\n\n**Output**: Detailed specification for each component\n\n---\n\n## Phase 4: Plugin Structure Creation\n\n**Goal**: Create plugin directory structure and manifest\n\n**Actions**:\n1. Determine plugin name (kebab-case, descriptive)\n2. Choose plugin location:\n   - Ask user: \"Where should I create the plugin?\"\n   - Offer options: current directory, ../new-plugin-name, custom path\n3. Create directory structure using bash:\n   ```bash\n   mkdir -p plugin-name/.claude-plugin\n   mkdir -p plugin-name/skills     # if needed\n   mkdir -p plugin-name/commands   # if needed\n   mkdir -p plugin-name/agents     # if needed\n   mkdir -p plugin-name/hooks      # if needed\n   ```\n4. Create plugin.json manifest using Write tool:\n   ```json\n   {\n     \"name\": \"plugin-name\",\n     \"version\": \"0.1.0\",\n     \"description\": \"[brief description]\",\n     \"author\": {\n       \"name\": \"[author from user or default]\",\n       \"email\": \"[email or default]\"\n     }\n   }\n   ```\n5. Create README.md template\n6. Create .gitignore if needed (for .claude/*.local.md, etc.)\n7. Initialize git repo if creating new directory\n\n**Output**: Plugin directory structure created and ready for components\n\n---\n\n## Phase 5: Component Implementation\n\n**Goal**: Create each component following best practices\n\n**LOAD RELEVANT SKILLS** before implementing each component type:\n- Skills: Load skill-development skill\n- Commands: Load command-development skill\n- Agents: Load agent-development skill\n- Hooks: Load hook-development skill\n- MCP: Load mcp-integration skill\n- Settings: Load plugin-settings skill\n\n**Actions for each component**:\n\n### For Skills:\n1. Load skill-development skill using Skill tool\n2. For each skill:\n   - Ask user for concrete usage examples (or use from Phase 3)\n   - Plan resources (scripts/, references/, examples/)\n   - Create skill directory structure\n   - Write SKILL.md with:\n     - Third-person description with specific trigger phrases\n     - Lean body (1,500-2,000 words) in imperative form\n     - References to supporting files\n   - Create reference files for detailed content\n   - Create example files for working code\n   - Create utility scripts if needed\n3. Use skill-reviewer agent to validate each skill\n\n### For Commands:\n1. Load command-development skill using Skill tool\n2. For each command:\n   - Write command markdown with frontmatter\n   - Include clear description and argument-hint\n   - Specify allowed-tools (minimal necessary)\n   - Write instructions FOR Claude (not TO user)\n   - Provide usage examples and tips\n   - Reference relevant skills if applicable\n\n### For Agents:\n1. Load agent-development skill using Skill tool\n2. For each agent, use agent-creator agent:\n   - Provide description of what agent should do\n   - Agent-creator generates: identifier, whenToUse with examples, systemPrompt\n   - Create agent markdown file with frontmatter and system prompt\n   - Add appropriate model, color, and tools\n   - Validate with validate-agent.sh script\n\n### For Hooks:\n1. Load hook-development skill using Skill tool\n2. For each hook:\n   - Create hooks/hooks.json with hook configuration\n   - Prefer prompt-based hooks for complex logic\n   - Use ${CLAUDE_PLUGIN_ROOT} for portability\n   - Create hook scripts if needed (in examples/ not scripts/)\n   - Test with validate-hook-schema.sh and test-hook.sh utilities\n\n### For MCP:\n1. Load mcp-integration skill using Skill tool\n2. Create .mcp.json configuration with:\n   - Server type (stdio for local, SSE for hosted)\n   - Command and args (with ${CLAUDE_PLUGIN_ROOT})\n   - extensionToLanguage mapping if LSP\n   - Environment variables as needed\n3. Document required env vars in README\n4. Provide setup instructions\n\n### For Settings:\n1. Load plugin-settings skill using Skill tool\n2. Create settings template in README\n3. Create example .claude/plugin-name.local.md file (as documentation)\n4. Implement settings reading in hooks/commands as needed\n5. Add to .gitignore: `.claude/*.local.md`\n\n**Progress tracking**: Update todos as each component is completed\n\n**Output**: All plugin components implemented\n\n---\n\n## Phase 6: Validation & Quality Check\n\n**Goal**: Ensure plugin meets quality standards and works correctly\n\n**Actions**:\n1. **Run plugin-validator agent**:\n   - Use plugin-validator agent to comprehensively validate plugin\n   - Check: manifest, structure, naming, components, security\n   - Review validation report\n\n2. **Fix critical issues**:\n   - Address any critical errors from validation\n   - Fix any warnings that indicate real problems\n\n3. **Review with skill-reviewer** (if plugin has skills):\n   - For each skill, use skill-reviewer agent\n   - Check description quality, progressive disclosure, writing style\n   - Apply recommendations\n\n4. **Test agent triggering** (if plugin has agents):\n   - For each agent, verify <example> blocks are clear\n   - Check triggering conditions are specific\n   - Run validate-agent.sh on agent files\n\n5. **Test hook configuration** (if plugin has hooks):\n   - Run validate-hook-schema.sh on hooks/hooks.json\n   - Test hook scripts with test-hook.sh\n   - Verify ${CLAUDE_PLUGIN_ROOT} usage\n\n6. **Present findings**:\n   - Summary of validation results\n   - Any remaining issues\n   - Overall quality assessment\n\n7. **Ask user**: \"Validation complete. Issues found: [count critical], [count warnings]. Would you like me to fix them now, or proceed to testing?\"\n\n**Output**: Plugin validated and ready for testing\n\n---\n\n## Phase 7: Testing & Verification\n\n**Goal**: Test that plugin works correctly in Claude Code\n\n**Actions**:\n1. **Installation instructions**:\n   - Show user how to test locally:\n     ```bash\n     cc --plugin-dir /path/to/plugin-name\n     ```\n   - Or copy to `.claude-plugin/` for project testing\n\n2. **Verification checklist** for user to perform:\n   - [ ] Skills load when triggered (ask questions with trigger phrases)\n   - [ ] Commands appear in `/help` and execute correctly\n   - [ ] Agents trigger on appropriate scenarios\n   - [ ] Hooks activate on events (if applicable)\n   - [ ] MCP servers connect (if applicable)\n   - [ ] Settings files work (if applicable)\n\n3. **Testing recommendations**:\n   - For skills: Ask questions using trigger phrases from descriptions\n   - For commands: Run `/plugin-name:command-name` with various arguments\n   - For agents: Create scenarios matching agent examples\n   - For hooks: Use `claude --debug` to see hook execution\n   - For MCP: Use `/mcp` to verify servers and tools\n\n4. **Ask user**: \"I've prepared the plugin for testing. Would you like me to guide you through testing each component, or do you want to test it yourself?\"\n\n5. **If user wants guidance**, walk through testing each component with specific test cases\n\n**Output**: Plugin tested and verified working\n\n---\n\n## Phase 8: Documentation & Next Steps\n\n**Goal**: Ensure plugin is well-documented and ready for distribution\n\n**Actions**:\n1. **Verify README completeness**:\n   - Check README has: overview, features, installation, prerequisites, usage\n   - For MCP plugins: Document required environment variables\n   - For hook plugins: Explain hook activation\n   - For settings: Provide configuration templates\n\n2. **Add marketplace entry** (if publishing):\n   - Show user how to add to marketplace.json\n   - Help draft marketplace description\n   - Suggest category and tags\n\n3. **Create summary**:\n   - Mark all todos complete\n   - List what was created:\n     - Plugin name and purpose\n     - Components created (X skills, Y commands, Z agents, etc.)\n     - Key files and their purposes\n     - Total file count and structure\n   - Next steps:\n     - Testing recommendations\n     - Publishing to marketplace (if desired)\n     - Iteration based on usage\n\n4. **Suggest improvements** (optional):\n   - Additional components that could enhance plugin\n   - Integration opportunities\n   - Testing strategies\n\n**Output**: Complete, documented plugin ready for use or publication\n\n---\n\n## Important Notes\n\n### Throughout All Phases\n\n- **Use TodoWrite** to track progress at every phase\n- **Load skills with Skill tool** when working on specific component types\n- **Use specialized agents** (agent-creator, plugin-validator, skill-reviewer)\n- **Ask for user confirmation** at key decision points\n- **Follow plugin-dev's own patterns** as reference examples\n- **Apply best practices**:\n  - Third-person descriptions for skills\n  - Imperative form in skill bodies\n  - Commands written FOR Claude\n  - Strong trigger phrases\n  - ${CLAUDE_PLUGIN_ROOT} for portability\n  - Progressive disclosure\n  - Security-first (HTTPS, no hardcoded credentials)\n\n### Key Decision Points (Wait for User)\n\n1. After Phase 1: Confirm plugin purpose\n2. After Phase 2: Approve component plan\n3. After Phase 3: Proceed to implementation\n4. After Phase 6: Fix issues or proceed\n5. After Phase 7: Continue to documentation\n\n### Skills to Load by Phase\n\n- **Phase 2**: plugin-structure\n- **Phase 5**: skill-development, command-development, agent-development, hook-development, mcp-integration, plugin-settings (as needed)\n- **Phase 6**: (agents will use skills automatically)\n\n### Quality Standards\n\nEvery component must meet these standards:\n- âœ… Follows plugin-dev's proven patterns\n- âœ… Uses correct naming conventions\n- âœ… Has strong trigger conditions (skills/agents)\n- âœ… Includes working examples\n- âœ… Properly documented\n- âœ… Validated with utilities\n- âœ… Tested in Claude Code\n\n---\n\n## Example Workflow\n\n### User Request\n\"Create a plugin for managing database migrations\"\n\n### Phase 1: Discovery\n- Understand: Migration management, database schema versioning\n- Confirm: User wants to create, run, rollback migrations\n\n### Phase 2: Component Planning\n- Skills: 1 (migration best practices)\n- Commands: 3 (create-migration, run-migrations, rollback)\n- Agents: 1 (migration-validator)\n- MCP: 1 (database connection)\n\n### Phase 3: Clarifying Questions\n- Which databases? (PostgreSQL, MySQL, etc.)\n- Migration file format? (SQL, code-based?)\n- Should agent validate before applying?\n- What MCP tools needed? (query, execute, schema)\n\n### Phase 4-8: Implementation, Validation, Testing, Documentation\n\n---\n\n**Begin with Phase 1: Discovery**"
              }
            ],
            "skills": [
              {
                "name": "Agent Development",
                "description": "This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins.",
                "path": "plugins/plugin-dev/skills/agent-development/SKILL.md",
                "frontmatter": {
                  "name": "Agent Development",
                  "description": "This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins.",
                  "version": "0.1.0"
                },
                "content": "# Agent Development for Claude Code Plugins\n\n## Overview\n\nAgents are autonomous subprocesses that handle complex, multi-step tasks independently. Understanding agent structure, triggering conditions, and system prompt design enables creating powerful autonomous capabilities.\n\n**Key concepts:**\n- Agents are FOR autonomous work, commands are FOR user-initiated actions\n- Markdown file format with YAML frontmatter\n- Triggering via description field with examples\n- System prompt defines agent behavior\n- Model and color customization\n\n## Agent File Structure\n\n### Complete Format\n\n```markdown\n---\nname: agent-identifier\ndescription: Use this agent when [triggering conditions]. Examples:\n\n<example>\nContext: [Situation description]\nuser: \"[User request]\"\nassistant: \"[How assistant should respond and use this agent]\"\n<commentary>\n[Why this agent should be triggered]\n</commentary>\n</example>\n\n<example>\n[Additional example...]\n</example>\n\nmodel: inherit\ncolor: blue\ntools: [\"Read\", \"Write\", \"Grep\"]\n---\n\nYou are [agent role description]...\n\n**Your Core Responsibilities:**\n1. [Responsibility 1]\n2. [Responsibility 2]\n\n**Analysis Process:**\n[Step-by-step workflow]\n\n**Output Format:**\n[What to return]\n```\n\n## Frontmatter Fields\n\n### name (required)\n\nAgent identifier used for namespacing and invocation.\n\n**Format:** lowercase, numbers, hyphens only\n**Length:** 3-50 characters\n**Pattern:** Must start and end with alphanumeric\n\n**Good examples:**\n- `code-reviewer`\n- `test-generator`\n- `api-docs-writer`\n- `security-analyzer`\n\n**Bad examples:**\n- `helper` (too generic)\n- `-agent-` (starts/ends with hyphen)\n- `my_agent` (underscores not allowed)\n- `ag` (too short, < 3 chars)\n\n### description (required)\n\nDefines when Claude should trigger this agent. **This is the most critical field.**\n\n**Must include:**\n1. Triggering conditions (\"Use this agent when...\")\n2. Multiple `<example>` blocks showing usage\n3. Context, user request, and assistant response in each example\n4. `<commentary>` explaining why agent triggers\n\n**Format:**\n```\nUse this agent when [conditions]. Examples:\n\n<example>\nContext: [Scenario description]\nuser: \"[What user says]\"\nassistant: \"[How Claude should respond]\"\n<commentary>\n[Why this agent is appropriate]\n</commentary>\n</example>\n\n[More examples...]\n```\n\n**Best practices:**\n- Include 2-4 concrete examples\n- Show proactive and reactive triggering\n- Cover different phrasings of same intent\n- Explain reasoning in commentary\n- Be specific about when NOT to use the agent\n\n### model (required)\n\nWhich model the agent should use.\n\n**Options:**\n- `inherit` - Use same model as parent (recommended)\n- `sonnet` - Claude Sonnet (balanced)\n- `opus` - Claude Opus (most capable, expensive)\n- `haiku` - Claude Haiku (fast, cheap)\n\n**Recommendation:** Use `inherit` unless agent needs specific model capabilities.\n\n### color (required)\n\nVisual identifier for agent in UI.\n\n**Options:** `blue`, `cyan`, `green`, `yellow`, `magenta`, `red`\n\n**Guidelines:**\n- Choose distinct colors for different agents in same plugin\n- Use consistent colors for similar agent types\n- Blue/cyan: Analysis, review\n- Green: Success-oriented tasks\n- Yellow: Caution, validation\n- Red: Critical, security\n- Magenta: Creative, generation\n\n### tools (optional)\n\nRestrict agent to specific tools.\n\n**Format:** Array of tool names\n\n```yaml\ntools: [\"Read\", \"Write\", \"Grep\", \"Bash\"]\n```\n\n**Default:** If omitted, agent has access to all tools\n\n**Best practice:** Limit tools to minimum needed (principle of least privilege)\n\n**Common tool sets:**\n- Read-only analysis: `[\"Read\", \"Grep\", \"Glob\"]`\n- Code generation: `[\"Read\", \"Write\", \"Grep\"]`\n- Testing: `[\"Read\", \"Bash\", \"Grep\"]`\n- Full access: Omit field or use `[\"*\"]`\n\n## System Prompt Design\n\nThe markdown body becomes the agent's system prompt. Write in second person, addressing the agent directly.\n\n### Structure\n\n**Standard template:**\n```markdown\nYou are [role] specializing in [domain].\n\n**Your Core Responsibilities:**\n1. [Primary responsibility]\n2. [Secondary responsibility]\n3. [Additional responsibilities...]\n\n**Analysis Process:**\n1. [Step one]\n2. [Step two]\n3. [Step three]\n[...]\n\n**Quality Standards:**\n- [Standard 1]\n- [Standard 2]\n\n**Output Format:**\nProvide results in this format:\n- [What to include]\n- [How to structure]\n\n**Edge Cases:**\nHandle these situations:\n- [Edge case 1]: [How to handle]\n- [Edge case 2]: [How to handle]\n```\n\n### Best Practices\n\nâœ… **DO:**\n- Write in second person (\"You are...\", \"You will...\")\n- Be specific about responsibilities\n- Provide step-by-step process\n- Define output format\n- Include quality standards\n- Address edge cases\n- Keep under 10,000 characters\n\nâŒ **DON'T:**\n- Write in first person (\"I am...\", \"I will...\")\n- Be vague or generic\n- Omit process steps\n- Leave output format undefined\n- Skip quality guidance\n- Ignore error cases\n\n## Creating Agents\n\n### Method 1: AI-Assisted Generation\n\nUse this prompt pattern (extracted from Claude Code):\n\n```\nCreate an agent configuration based on this request: \"[YOUR DESCRIPTION]\"\n\nRequirements:\n1. Extract core intent and responsibilities\n2. Design expert persona for the domain\n3. Create comprehensive system prompt with:\n   - Clear behavioral boundaries\n   - Specific methodologies\n   - Edge case handling\n   - Output format\n4. Create identifier (lowercase, hyphens, 3-50 chars)\n5. Write description with triggering conditions\n6. Include 2-3 <example> blocks showing when to use\n\nReturn JSON with:\n{\n  \"identifier\": \"agent-name\",\n  \"whenToUse\": \"Use this agent when... Examples: <example>...</example>\",\n  \"systemPrompt\": \"You are...\"\n}\n```\n\nThen convert to agent file format with frontmatter.\n\nSee `examples/agent-creation-prompt.md` for complete template.\n\n### Method 2: Manual Creation\n\n1. Choose agent identifier (3-50 chars, lowercase, hyphens)\n2. Write description with examples\n3. Select model (usually `inherit`)\n4. Choose color for visual identification\n5. Define tools (if restricting access)\n6. Write system prompt with structure above\n7. Save as `agents/agent-name.md`\n\n## Validation Rules\n\n### Identifier Validation\n\n```\nâœ… Valid: code-reviewer, test-gen, api-analyzer-v2\nâŒ Invalid: ag (too short), -start (starts with hyphen), my_agent (underscore)\n```\n\n**Rules:**\n- 3-50 characters\n- Lowercase letters, numbers, hyphens only\n- Must start and end with alphanumeric\n- No underscores, spaces, or special characters\n\n### Description Validation\n\n**Length:** 10-5,000 characters\n**Must include:** Triggering conditions and examples\n**Best:** 200-1,000 characters with 2-4 examples\n\n### System Prompt Validation\n\n**Length:** 20-10,000 characters\n**Best:** 500-3,000 characters\n**Structure:** Clear responsibilities, process, output format\n\n## Agent Organization\n\n### Plugin Agents Directory\n\n```\nplugin-name/\nâ””â”€â”€ agents/\n    â”œâ”€â”€ analyzer.md\n    â”œâ”€â”€ reviewer.md\n    â””â”€â”€ generator.md\n```\n\nAll `.md` files in `agents/` are auto-discovered.\n\n### Namespacing\n\nAgents are namespaced automatically:\n- Single plugin: `agent-name`\n- With subdirectories: `plugin:subdir:agent-name`\n\n## Testing Agents\n\n### Test Triggering\n\nCreate test scenarios to verify agent triggers correctly:\n\n1. Write agent with specific triggering examples\n2. Use similar phrasing to examples in test\n3. Check Claude loads the agent\n4. Verify agent provides expected functionality\n\n### Test System Prompt\n\nEnsure system prompt is complete:\n\n1. Give agent typical task\n2. Check it follows process steps\n3. Verify output format is correct\n4. Test edge cases mentioned in prompt\n5. Confirm quality standards are met\n\n## Quick Reference\n\n### Minimal Agent\n\n```markdown\n---\nname: simple-agent\ndescription: Use this agent when... Examples: <example>...</example>\nmodel: inherit\ncolor: blue\n---\n\nYou are an agent that [does X].\n\nProcess:\n1. [Step 1]\n2. [Step 2]\n\nOutput: [What to provide]\n```\n\n### Frontmatter Fields Summary\n\n| Field | Required | Format | Example |\n|-------|----------|--------|---------|\n| name | Yes | lowercase-hyphens | code-reviewer |\n| description | Yes | Text + examples | Use when... <example>... |\n| model | Yes | inherit/sonnet/opus/haiku | inherit |\n| color | Yes | Color name | blue |\n| tools | No | Array of tool names | [\"Read\", \"Grep\"] |\n\n### Best Practices\n\n**DO:**\n- âœ… Include 2-4 concrete examples in description\n- âœ… Write specific triggering conditions\n- âœ… Use `inherit` for model unless specific need\n- âœ… Choose appropriate tools (least privilege)\n- âœ… Write clear, structured system prompts\n- âœ… Test agent triggering thoroughly\n\n**DON'T:**\n- âŒ Use generic descriptions without examples\n- âŒ Omit triggering conditions\n- âŒ Give all agents same color\n- âŒ Grant unnecessary tool access\n- âŒ Write vague system prompts\n- âŒ Skip testing\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed guidance, consult:\n\n- **`references/system-prompt-design.md`** - Complete system prompt patterns\n- **`references/triggering-examples.md`** - Example formats and best practices\n- **`references/agent-creation-system-prompt.md`** - The exact prompt from Claude Code\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`agent-creation-prompt.md`** - AI-assisted agent generation template\n- **`complete-agent-examples.md`** - Full agent examples for different use cases\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-agent.sh`** - Validate agent file structure\n- **`test-agent-trigger.sh`** - Test if agent triggers correctly\n\n## Implementation Workflow\n\nTo create an agent for a plugin:\n\n1. Define agent purpose and triggering conditions\n2. Choose creation method (AI-assisted or manual)\n3. Create `agents/agent-name.md` file\n4. Write frontmatter with all required fields\n5. Write system prompt following best practices\n6. Include 2-4 triggering examples in description\n7. Validate with `scripts/validate-agent.sh`\n8. Test triggering with real scenarios\n9. Document agent in plugin README\n\nFocus on clear triggering conditions and comprehensive system prompts for autonomous operation."
              },
              {
                "name": "Command Development",
                "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
                "path": "plugins/plugin-dev/skills/command-development/SKILL.md",
                "frontmatter": {
                  "name": "Command Development",
                  "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
                  "version": "0.2.0"
                },
                "content": "# Command Development for Claude Code\n\n## Overview\n\nSlash commands are frequently-used prompts defined as Markdown files that Claude executes during interactive sessions. Understanding command structure, frontmatter options, and dynamic features enables creating powerful, reusable workflows.\n\n**Key concepts:**\n- Markdown file format for commands\n- YAML frontmatter for configuration\n- Dynamic arguments and file references\n- Bash execution for context\n- Command organization and namespacing\n\n## Command Basics\n\n### What is a Slash Command?\n\nA slash command is a Markdown file containing a prompt that Claude executes when invoked. Commands provide:\n- **Reusability**: Define once, use repeatedly\n- **Consistency**: Standardize common workflows\n- **Sharing**: Distribute across team or projects\n- **Efficiency**: Quick access to complex prompts\n\n### Critical: Commands are Instructions FOR Claude\n\n**Commands are written for agent consumption, not human consumption.**\n\nWhen a user invokes `/command-name`, the command content becomes Claude's instructions. Write commands as directives TO Claude about what to do, not as messages TO the user.\n\n**Correct approach (instructions for Claude):**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication issues\n\nProvide specific line numbers and severity ratings.\n```\n\n**Incorrect approach (messages to user):**\n```markdown\nThis command will review your code for security issues.\nYou'll receive a report with vulnerability details.\n```\n\nThe first example tells Claude what to do. The second tells the user what will happen but doesn't instruct Claude. Always use the first approach.\n\n### Command Locations\n\n**Project commands** (shared with team):\n- Location: `.claude/commands/`\n- Scope: Available in specific project\n- Label: Shown as \"(project)\" in `/help`\n- Use for: Team workflows, project-specific tasks\n\n**Personal commands** (available everywhere):\n- Location: `~/.claude/commands/`\n- Scope: Available in all projects\n- Label: Shown as \"(user)\" in `/help`\n- Use for: Personal workflows, cross-project utilities\n\n**Plugin commands** (bundled with plugins):\n- Location: `plugin-name/commands/`\n- Scope: Available when plugin installed\n- Label: Shown as \"(plugin-name)\" in `/help`\n- Use for: Plugin-specific functionality\n\n## File Format\n\n### Basic Structure\n\nCommands are Markdown files with `.md` extension:\n\n```\n.claude/commands/\nâ”œâ”€â”€ review.md           # /review command\nâ”œâ”€â”€ test.md             # /test command\nâ””â”€â”€ deploy.md           # /deploy command\n```\n\n**Simple command:**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication bypass\n- Insecure data handling\n```\n\nNo frontmatter needed for basic commands.\n\n### With YAML Frontmatter\n\nAdd configuration using YAML frontmatter:\n\n```markdown\n---\ndescription: Review code for security issues\nallowed-tools: Read, Grep, Bash(git:*)\nmodel: sonnet\n---\n\nReview this code for security vulnerabilities...\n```\n\n## YAML Frontmatter Fields\n\n### description\n\n**Purpose:** Brief description shown in `/help`\n**Type:** String\n**Default:** First line of command prompt\n\n```yaml\n---\ndescription: Review pull request for code quality\n---\n```\n\n**Best practice:** Clear, actionable description (under 60 characters)\n\n### allowed-tools\n\n**Purpose:** Specify which tools command can use\n**Type:** String or Array\n**Default:** Inherits from conversation\n\n```yaml\n---\nallowed-tools: Read, Write, Edit, Bash(git:*)\n---\n```\n\n**Patterns:**\n- `Read, Write, Edit` - Specific tools\n- `Bash(git:*)` - Bash with git commands only\n- `*` - All tools (rarely needed)\n\n**Use when:** Command requires specific tool access\n\n### model\n\n**Purpose:** Specify model for command execution\n**Type:** String (sonnet, opus, haiku)\n**Default:** Inherits from conversation\n\n```yaml\n---\nmodel: haiku\n---\n```\n\n**Use cases:**\n- `haiku` - Fast, simple commands\n- `sonnet` - Standard workflows\n- `opus` - Complex analysis\n\n### argument-hint\n\n**Purpose:** Document expected arguments for autocomplete\n**Type:** String\n**Default:** None\n\n```yaml\n---\nargument-hint: [pr-number] [priority] [assignee]\n---\n```\n\n**Benefits:**\n- Helps users understand command arguments\n- Improves command discovery\n- Documents command interface\n\n### disable-model-invocation\n\n**Purpose:** Prevent SlashCommand tool from programmatically calling command\n**Type:** Boolean\n**Default:** false\n\n```yaml\n---\ndisable-model-invocation: true\n---\n```\n\n**Use when:** Command should only be manually invoked\n\n## Dynamic Arguments\n\n### Using $ARGUMENTS\n\nCapture all arguments as single string:\n\n```markdown\n---\ndescription: Fix issue by number\nargument-hint: [issue-number]\n---\n\nFix issue #$ARGUMENTS following our coding standards and best practices.\n```\n\n**Usage:**\n```\n> /fix-issue 123\n> /fix-issue 456\n```\n\n**Expands to:**\n```\nFix issue #123 following our coding standards...\nFix issue #456 following our coding standards...\n```\n\n### Using Positional Arguments\n\nCapture individual arguments with `$1`, `$2`, `$3`, etc.:\n\n```markdown\n---\ndescription: Review PR with priority and assignee\nargument-hint: [pr-number] [priority] [assignee]\n---\n\nReview pull request #$1 with priority level $2.\nAfter review, assign to $3 for follow-up.\n```\n\n**Usage:**\n```\n> /review-pr 123 high alice\n```\n\n**Expands to:**\n```\nReview pull request #123 with priority level high.\nAfter review, assign to alice for follow-up.\n```\n\n### Combining Arguments\n\nMix positional and remaining arguments:\n\n```markdown\nDeploy $1 to $2 environment with options: $3\n```\n\n**Usage:**\n```\n> /deploy api staging --force --skip-tests\n```\n\n**Expands to:**\n```\nDeploy api to staging environment with options: --force --skip-tests\n```\n\n## File References\n\n### Using @ Syntax\n\nInclude file contents in command:\n\n```markdown\n---\ndescription: Review specific file\nargument-hint: [file-path]\n---\n\nReview @$1 for:\n- Code quality\n- Best practices\n- Potential bugs\n```\n\n**Usage:**\n```\n> /review-file src/api/users.ts\n```\n\n**Effect:** Claude reads `src/api/users.ts` before processing command\n\n### Multiple File References\n\nReference multiple files:\n\n```markdown\nCompare @src/old-version.js with @src/new-version.js\n\nIdentify:\n- Breaking changes\n- New features\n- Bug fixes\n```\n\n### Static File References\n\nReference known files without arguments:\n\n```markdown\nReview @package.json and @tsconfig.json for consistency\n\nEnsure:\n- TypeScript version matches\n- Dependencies are aligned\n- Build configuration is correct\n```\n\n## Bash Execution in Commands\n\nCommands can execute bash commands inline to dynamically gather context before Claude processes the command. This is useful for including repository state, environment information, or project-specific context.\n\n**When to use:**\n- Include dynamic context (git status, environment vars, etc.)\n- Gather project/repository state\n- Build context-aware workflows\n\n**Implementation details:**\nFor complete syntax, examples, and best practices, see `references/plugin-features-reference.md` section on bash execution. The reference includes the exact syntax and multiple working examples to avoid execution issues\n\n## Command Organization\n\n### Flat Structure\n\nSimple organization for small command sets:\n\n```\n.claude/commands/\nâ”œâ”€â”€ build.md\nâ”œâ”€â”€ test.md\nâ”œâ”€â”€ deploy.md\nâ”œâ”€â”€ review.md\nâ””â”€â”€ docs.md\n```\n\n**Use when:** 5-15 commands, no clear categories\n\n### Namespaced Structure\n\nOrganize commands in subdirectories:\n\n```\n.claude/commands/\nâ”œâ”€â”€ ci/\nâ”‚   â”œâ”€â”€ build.md        # /build (project:ci)\nâ”‚   â”œâ”€â”€ test.md         # /test (project:ci)\nâ”‚   â””â”€â”€ lint.md         # /lint (project:ci)\nâ”œâ”€â”€ git/\nâ”‚   â”œâ”€â”€ commit.md       # /commit (project:git)\nâ”‚   â””â”€â”€ pr.md           # /pr (project:git)\nâ””â”€â”€ docs/\n    â”œâ”€â”€ generate.md     # /generate (project:docs)\n    â””â”€â”€ publish.md      # /publish (project:docs)\n```\n\n**Benefits:**\n- Logical grouping by category\n- Namespace shown in `/help`\n- Easier to find related commands\n\n**Use when:** 15+ commands, clear categories\n\n## Best Practices\n\n### Command Design\n\n1. **Single responsibility:** One command, one task\n2. **Clear descriptions:** Self-explanatory in `/help`\n3. **Explicit dependencies:** Use `allowed-tools` when needed\n4. **Document arguments:** Always provide `argument-hint`\n5. **Consistent naming:** Use verb-noun pattern (review-pr, fix-issue)\n\n### Argument Handling\n\n1. **Validate arguments:** Check for required arguments in prompt\n2. **Provide defaults:** Suggest defaults when arguments missing\n3. **Document format:** Explain expected argument format\n4. **Handle edge cases:** Consider missing or invalid arguments\n\n```markdown\n---\nargument-hint: [pr-number]\n---\n\n$IF($1,\n  Review PR #$1,\n  Please provide a PR number. Usage: /review-pr [number]\n)\n```\n\n### File References\n\n1. **Explicit paths:** Use clear file paths\n2. **Check existence:** Handle missing files gracefully\n3. **Relative paths:** Use project-relative paths\n4. **Glob support:** Consider using Glob tool for patterns\n\n### Bash Commands\n\n1. **Limit scope:** Use `Bash(git:*)` not `Bash(*)`\n2. **Safe commands:** Avoid destructive operations\n3. **Handle errors:** Consider command failures\n4. **Keep fast:** Long-running commands slow invocation\n\n### Documentation\n\n1. **Add comments:** Explain complex logic\n2. **Provide examples:** Show usage in comments\n3. **List requirements:** Document dependencies\n4. **Version commands:** Note breaking changes\n\n```markdown\n---\ndescription: Deploy application to environment\nargument-hint: [environment] [version]\n---\n\n<!--\nUsage: /deploy [staging|production] [version]\nRequires: AWS credentials configured\nExample: /deploy staging v1.2.3\n-->\n\nDeploy application to $1 environment using version $2...\n```\n\n## Common Patterns\n\n### Review Pattern\n\n```markdown\n---\ndescription: Review code changes\nallowed-tools: Read, Bash(git:*)\n---\n\nFiles changed: !`git diff --name-only`\n\nReview each file for:\n1. Code quality and style\n2. Potential bugs or issues\n3. Test coverage\n4. Documentation needs\n\nProvide specific feedback for each file.\n```\n\n### Testing Pattern\n\n```markdown\n---\ndescription: Run tests for specific file\nargument-hint: [test-file]\nallowed-tools: Bash(npm:*)\n---\n\nRun tests: !`npm test $1`\n\nAnalyze results and suggest fixes for failures.\n```\n\n### Documentation Pattern\n\n```markdown\n---\ndescription: Generate documentation for file\nargument-hint: [source-file]\n---\n\nGenerate comprehensive documentation for @$1 including:\n- Function/class descriptions\n- Parameter documentation\n- Return value descriptions\n- Usage examples\n- Edge cases and errors\n```\n\n### Workflow Pattern\n\n```markdown\n---\ndescription: Complete PR workflow\nargument-hint: [pr-number]\nallowed-tools: Bash(gh:*), Read\n---\n\nPR #$1 Workflow:\n\n1. Fetch PR: !`gh pr view $1`\n2. Review changes\n3. Run checks\n4. Approve or request changes\n```\n\n## Troubleshooting\n\n**Command not appearing:**\n- Check file is in correct directory\n- Verify `.md` extension present\n- Ensure valid Markdown format\n- Restart Claude Code\n\n**Arguments not working:**\n- Verify `$1`, `$2` syntax correct\n- Check `argument-hint` matches usage\n- Ensure no extra spaces\n\n**Bash execution failing:**\n- Check `allowed-tools` includes Bash\n- Verify command syntax in backticks\n- Test command in terminal first\n- Check for required permissions\n\n**File references not working:**\n- Verify `@` syntax correct\n- Check file path is valid\n- Ensure Read tool allowed\n- Use absolute or project-relative paths\n\n## Plugin-Specific Features\n\n### CLAUDE_PLUGIN_ROOT Variable\n\nPlugin commands have access to `${CLAUDE_PLUGIN_ROOT}`, an environment variable that resolves to the plugin's absolute path.\n\n**Purpose:**\n- Reference plugin files portably\n- Execute plugin scripts\n- Load plugin configuration\n- Access plugin templates\n\n**Basic usage:**\n\n```markdown\n---\ndescription: Analyze using plugin script\nallowed-tools: Bash(node:*)\n---\n\nRun analysis: !`node ${CLAUDE_PLUGIN_ROOT}/scripts/analyze.js $1`\n\nReview results and report findings.\n```\n\n**Common patterns:**\n\n```markdown\n# Execute plugin script\n!`bash ${CLAUDE_PLUGIN_ROOT}/scripts/script.sh`\n\n# Load plugin configuration\n@${CLAUDE_PLUGIN_ROOT}/config/settings.json\n\n# Use plugin template\n@${CLAUDE_PLUGIN_ROOT}/templates/report.md\n\n# Access plugin resources\n@${CLAUDE_PLUGIN_ROOT}/docs/reference.md\n```\n\n**Why use it:**\n- Works across all installations\n- Portable between systems\n- No hardcoded paths needed\n- Essential for multi-file plugins\n\n### Plugin Command Organization\n\nPlugin commands discovered automatically from `commands/` directory:\n\n```\nplugin-name/\nâ”œâ”€â”€ commands/\nâ”‚   â”œâ”€â”€ foo.md              # /foo (plugin:plugin-name)\nâ”‚   â”œâ”€â”€ bar.md              # /bar (plugin:plugin-name)\nâ”‚   â””â”€â”€ utils/\nâ”‚       â””â”€â”€ helper.md       # /helper (plugin:plugin-name:utils)\nâ””â”€â”€ plugin.json\n```\n\n**Namespace benefits:**\n- Logical command grouping\n- Shown in `/help` output\n- Avoid name conflicts\n- Organize related commands\n\n**Naming conventions:**\n- Use descriptive action names\n- Avoid generic names (test, run)\n- Consider plugin-specific prefix\n- Use hyphens for multi-word names\n\n### Plugin Command Patterns\n\n**Configuration-based pattern:**\n\n```markdown\n---\ndescription: Deploy using plugin configuration\nargument-hint: [environment]\nallowed-tools: Read, Bash(*)\n---\n\nLoad configuration: @${CLAUDE_PLUGIN_ROOT}/config/$1-deploy.json\n\nDeploy to $1 using configuration settings.\nMonitor deployment and report status.\n```\n\n**Template-based pattern:**\n\n```markdown\n---\ndescription: Generate docs from template\nargument-hint: [component]\n---\n\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/docs.md\n\nGenerate documentation for $1 following template structure.\n```\n\n**Multi-script pattern:**\n\n```markdown\n---\ndescription: Complete build workflow\nallowed-tools: Bash(*)\n---\n\nBuild: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh`\nTest: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/test.sh`\nPackage: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/package.sh`\n\nReview outputs and report workflow status.\n```\n\n**See `references/plugin-features-reference.md` for detailed patterns.**\n\n## Integration with Plugin Components\n\nCommands can integrate with other plugin components for powerful workflows.\n\n### Agent Integration\n\nLaunch plugin agents for complex tasks:\n\n```markdown\n---\ndescription: Deep code review\nargument-hint: [file-path]\n---\n\nInitiate comprehensive review of @$1 using the code-reviewer agent.\n\nThe agent will analyze:\n- Code structure\n- Security issues\n- Performance\n- Best practices\n\nAgent uses plugin resources:\n- ${CLAUDE_PLUGIN_ROOT}/config/rules.json\n- ${CLAUDE_PLUGIN_ROOT}/checklists/review.md\n```\n\n**Key points:**\n- Agent must exist in `plugin/agents/` directory\n- Claude uses Task tool to launch agent\n- Document agent capabilities\n- Reference plugin resources agent uses\n\n### Skill Integration\n\nLeverage plugin skills for specialized knowledge:\n\n```markdown\n---\ndescription: Document API with standards\nargument-hint: [api-file]\n---\n\nDocument API in @$1 following plugin standards.\n\nUse the api-docs-standards skill to ensure:\n- Complete endpoint documentation\n- Consistent formatting\n- Example quality\n- Error documentation\n\nGenerate production-ready API docs.\n```\n\n**Key points:**\n- Skill must exist in `plugin/skills/` directory\n- Mention skill name to trigger invocation\n- Document skill purpose\n- Explain what skill provides\n\n### Hook Coordination\n\nDesign commands that work with plugin hooks:\n- Commands can prepare state for hooks to process\n- Hooks execute automatically on tool events\n- Commands should document expected hook behavior\n- Guide Claude on interpreting hook output\n\nSee `references/plugin-features-reference.md` for examples of commands that coordinate with hooks\n\n### Multi-Component Workflows\n\nCombine agents, skills, and scripts:\n\n```markdown\n---\ndescription: Comprehensive review workflow\nargument-hint: [file]\nallowed-tools: Bash(node:*), Read\n---\n\nTarget: @$1\n\nPhase 1 - Static Analysis:\n!`node ${CLAUDE_PLUGIN_ROOT}/scripts/lint.js $1`\n\nPhase 2 - Deep Review:\nLaunch code-reviewer agent for detailed analysis.\n\nPhase 3 - Standards Check:\nUse coding-standards skill for validation.\n\nPhase 4 - Report:\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/review.md\n\nCompile findings into report following template.\n```\n\n**When to use:**\n- Complex multi-step workflows\n- Leverage multiple plugin capabilities\n- Require specialized analysis\n- Need structured outputs\n\n## Validation Patterns\n\nCommands should validate inputs and resources before processing.\n\n### Argument Validation\n\n```markdown\n---\ndescription: Deploy with validation\nargument-hint: [environment]\n---\n\nValidate environment: !`echo \"$1\" | grep -E \"^(dev|staging|prod)$\" || echo \"INVALID\"`\n\nIf $1 is valid environment:\n  Deploy to $1\nOtherwise:\n  Explain valid environments: dev, staging, prod\n  Show usage: /deploy [environment]\n```\n\n### File Existence Checks\n\n```markdown\n---\ndescription: Process configuration\nargument-hint: [config-file]\n---\n\nCheck file exists: !`test -f $1 && echo \"EXISTS\" || echo \"MISSING\"`\n\nIf file exists:\n  Process configuration: @$1\nOtherwise:\n  Explain where to place config file\n  Show expected format\n  Provide example configuration\n```\n\n### Plugin Resource Validation\n\n```markdown\n---\ndescription: Run plugin analyzer\nallowed-tools: Bash(test:*)\n---\n\nValidate plugin setup:\n- Script: !`test -x ${CLAUDE_PLUGIN_ROOT}/bin/analyze && echo \"âœ“\" || echo \"âœ—\"`\n- Config: !`test -f ${CLAUDE_PLUGIN_ROOT}/config.json && echo \"âœ“\" || echo \"âœ—\"`\n\nIf all checks pass, run analysis.\nOtherwise, report missing components.\n```\n\n### Error Handling\n\n```markdown\n---\ndescription: Build with error handling\nallowed-tools: Bash(*)\n---\n\nExecute build: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh 2>&1 || echo \"BUILD_FAILED\"`\n\nIf build succeeded:\n  Report success and output location\nIf build failed:\n  Analyze error output\n  Suggest likely causes\n  Provide troubleshooting steps\n```\n\n**Best practices:**\n- Validate early in command\n- Provide helpful error messages\n- Suggest corrective actions\n- Handle edge cases gracefully\n\n---\n\nFor detailed frontmatter field specifications, see `references/frontmatter-reference.md`.\nFor plugin-specific features and patterns, see `references/plugin-features-reference.md`.\nFor command pattern examples, see `examples/` directory."
              },
              {
                "name": "Hook Development",
                "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
                "path": "plugins/plugin-dev/skills/hook-development/SKILL.md",
                "frontmatter": {
                  "name": "Hook Development",
                  "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
                  "version": "0.1.0"
                },
                "content": "# Hook Development for Claude Code Plugins\n\n## Overview\n\nHooks are event-driven automation scripts that execute in response to Claude Code events. Use hooks to validate operations, enforce policies, add context, and integrate external tools into workflows.\n\n**Key capabilities:**\n- Validate tool calls before execution (PreToolUse)\n- React to tool results (PostToolUse)\n- Enforce completion standards (Stop, SubagentStop)\n- Load project context (SessionStart)\n- Automate workflows across the development lifecycle\n\n## Hook Types\n\n### Prompt-Based Hooks (Recommended)\n\nUse LLM-driven decision making for context-aware validation:\n\n```json\n{\n  \"type\": \"prompt\",\n  \"prompt\": \"Evaluate if this tool use is appropriate: $TOOL_INPUT\",\n  \"timeout\": 30\n}\n```\n\n**Supported events:** Stop, SubagentStop, UserPromptSubmit, PreToolUse\n\n**Benefits:**\n- Context-aware decisions based on natural language reasoning\n- Flexible evaluation logic without bash scripting\n- Better edge case handling\n- Easier to maintain and extend\n\n### Command Hooks\n\nExecute bash commands for deterministic checks:\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\",\n  \"timeout\": 60\n}\n```\n\n**Use for:**\n- Fast deterministic validations\n- File system operations\n- External tool integrations\n- Performance-critical checks\n\n## Hook Configuration Formats\n\n### Plugin hooks.json Format\n\n**For plugin hooks** in `hooks/hooks.json`, use wrapper format:\n\n```json\n{\n  \"description\": \"Brief explanation of hooks (optional)\",\n  \"hooks\": {\n    \"PreToolUse\": [...],\n    \"Stop\": [...],\n    \"SessionStart\": [...]\n  }\n}\n```\n\n**Key points:**\n- `description` field is optional\n- `hooks` field is required wrapper containing actual hook events\n- This is the **plugin-specific format**\n\n**Example:**\n```json\n{\n  \"description\": \"Validation hooks for code quality\",\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Write\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/validate.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n### Settings Format (Direct)\n\n**For user settings** in `.claude/settings.json`, use direct format:\n\n```json\n{\n  \"PreToolUse\": [...],\n  \"Stop\": [...],\n  \"SessionStart\": [...]\n}\n```\n\n**Key points:**\n- No wrapper - events directly at top level\n- No description field\n- This is the **settings format**\n\n**Important:** The examples below show the hook event structure that goes inside either format. For plugin hooks.json, wrap these in `{\"hooks\": {...}}`.\n\n## Hook Events\n\n### PreToolUse\n\nExecute before any tool runs. Use to approve, deny, or modify tool calls.\n\n**Example (prompt-based):**\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety. Check: system paths, credentials, path traversal, sensitive content. Return 'approve' or 'deny'.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output for PreToolUse:**\n```json\n{\n  \"hookSpecificOutput\": {\n    \"permissionDecision\": \"allow|deny|ask\",\n    \"updatedInput\": {\"field\": \"modified_value\"}\n  },\n  \"systemMessage\": \"Explanation for Claude\"\n}\n```\n\n### PostToolUse\n\nExecute after tool completes. Use to react to results, provide feedback, or log.\n\n**Example:**\n```json\n{\n  \"PostToolUse\": [\n    {\n      \"matcher\": \"Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Analyze edit result for potential issues: syntax errors, security vulnerabilities, breaking changes. Provide feedback.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output behavior:**\n- Exit 0: stdout shown in transcript\n- Exit 2: stderr fed back to Claude\n- systemMessage included in context\n\n### Stop\n\nExecute when main agent considers stopping. Use to validate completeness.\n\n**Example:**\n```json\n{\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion: tests run, build succeeded, questions answered. Return 'approve' to stop or 'block' with reason to continue.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Decision output:**\n```json\n{\n  \"decision\": \"approve|block\",\n  \"reason\": \"Explanation\",\n  \"systemMessage\": \"Additional context\"\n}\n```\n\n### SubagentStop\n\nExecute when subagent considers stopping. Use to ensure subagent completed its task.\n\nSimilar to Stop hook, but for subagents.\n\n### UserPromptSubmit\n\nExecute when user submits a prompt. Use to add context, validate, or block prompts.\n\n**Example:**\n```json\n{\n  \"UserPromptSubmit\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Check if prompt requires security guidance. If discussing auth, permissions, or API security, return relevant warnings.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### SessionStart\n\nExecute when Claude Code session begins. Use to load context and set environment.\n\n**Example:**\n```json\n{\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Special capability:** Persist environment variables using `$CLAUDE_ENV_FILE`:\n```bash\necho \"export PROJECT_TYPE=nodejs\" >> \"$CLAUDE_ENV_FILE\"\n```\n\nSee `examples/load-context.sh` for complete example.\n\n### SessionEnd\n\nExecute when session ends. Use for cleanup, logging, and state preservation.\n\n### PreCompact\n\nExecute before context compaction. Use to add critical information to preserve.\n\n### Notification\n\nExecute when Claude sends notifications. Use to react to user notifications.\n\n## Hook Output Format\n\n### Standard Output (All Hooks)\n\n```json\n{\n  \"continue\": true,\n  \"suppressOutput\": false,\n  \"systemMessage\": \"Message for Claude\"\n}\n```\n\n- `continue`: If false, halt processing (default true)\n- `suppressOutput`: Hide output from transcript (default false)\n- `systemMessage`: Message shown to Claude\n\n### Exit Codes\n\n- `0` - Success (stdout shown in transcript)\n- `2` - Blocking error (stderr fed back to Claude)\n- Other - Non-blocking error\n\n## Hook Input Format\n\nAll hooks receive JSON via stdin with common fields:\n\n```json\n{\n  \"session_id\": \"abc123\",\n  \"transcript_path\": \"/path/to/transcript.txt\",\n  \"cwd\": \"/current/working/dir\",\n  \"permission_mode\": \"ask|allow\",\n  \"hook_event_name\": \"PreToolUse\"\n}\n```\n\n**Event-specific fields:**\n\n- **PreToolUse/PostToolUse:** `tool_name`, `tool_input`, `tool_result`\n- **UserPromptSubmit:** `user_prompt`\n- **Stop/SubagentStop:** `reason`\n\nAccess fields in prompts using `$TOOL_INPUT`, `$TOOL_RESULT`, `$USER_PROMPT`, etc.\n\n## Environment Variables\n\nAvailable in all command hooks:\n\n- `$CLAUDE_PROJECT_DIR` - Project root path\n- `$CLAUDE_PLUGIN_ROOT` - Plugin directory (use for portable paths)\n- `$CLAUDE_ENV_FILE` - SessionStart only: persist env vars here\n- `$CLAUDE_CODE_REMOTE` - Set if running in remote context\n\n**Always use ${CLAUDE_PLUGIN_ROOT} in hook commands for portability:**\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\"\n}\n```\n\n## Plugin Hook Configuration\n\nIn plugins, define hooks in `hooks/hooks.json`:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety\"\n        }\n      ]\n    }\n  ],\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion\"\n        }\n      ]\n    }\n  ],\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\",\n          \"timeout\": 10\n        }\n      ]\n    }\n  ]\n}\n```\n\nPlugin hooks merge with user's hooks and run in parallel.\n\n## Matchers\n\n### Tool Name Matching\n\n**Exact match:**\n```json\n\"matcher\": \"Write\"\n```\n\n**Multiple tools:**\n```json\n\"matcher\": \"Read|Write|Edit\"\n```\n\n**Wildcard (all tools):**\n```json\n\"matcher\": \"*\"\n```\n\n**Regex patterns:**\n```json\n\"matcher\": \"mcp__.*__delete.*\"  // All MCP delete tools\n```\n\n**Note:** Matchers are case-sensitive.\n\n### Common Patterns\n\n```json\n// All MCP tools\n\"matcher\": \"mcp__.*\"\n\n// Specific plugin's MCP tools\n\"matcher\": \"mcp__plugin_asana_.*\"\n\n// All file operations\n\"matcher\": \"Read|Write|Edit\"\n\n// Bash commands only\n\"matcher\": \"Bash\"\n```\n\n## Security Best Practices\n\n### Input Validation\n\nAlways validate inputs in command hooks:\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\ninput=$(cat)\ntool_name=$(echo \"$input\" | jq -r '.tool_name')\n\n# Validate tool name format\nif [[ ! \"$tool_name\" =~ ^[a-zA-Z0-9_]+$ ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Invalid tool name\"}' >&2\n  exit 2\nfi\n```\n\n### Path Safety\n\nCheck for path traversal and sensitive files:\n\n```bash\nfile_path=$(echo \"$input\" | jq -r '.tool_input.file_path')\n\n# Deny path traversal\nif [[ \"$file_path\" == *\"..\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Path traversal detected\"}' >&2\n  exit 2\nfi\n\n# Deny sensitive files\nif [[ \"$file_path\" == *\".env\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Sensitive file\"}' >&2\n  exit 2\nfi\n```\n\nSee `examples/validate-write.sh` and `examples/validate-bash.sh` for complete examples.\n\n### Quote All Variables\n\n```bash\n# GOOD: Quoted\necho \"$file_path\"\ncd \"$CLAUDE_PROJECT_DIR\"\n\n# BAD: Unquoted (injection risk)\necho $file_path\ncd $CLAUDE_PROJECT_DIR\n```\n\n### Set Appropriate Timeouts\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash script.sh\",\n  \"timeout\": 10\n}\n```\n\n**Defaults:** Command hooks (60s), Prompt hooks (30s)\n\n## Performance Considerations\n\n### Parallel Execution\n\nAll matching hooks run **in parallel**:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write\",\n      \"hooks\": [\n        {\"type\": \"command\", \"command\": \"check1.sh\"},  // Parallel\n        {\"type\": \"command\", \"command\": \"check2.sh\"},  // Parallel\n        {\"type\": \"prompt\", \"prompt\": \"Validate...\"}   // Parallel\n      ]\n    }\n  ]\n}\n```\n\n**Design implications:**\n- Hooks don't see each other's output\n- Non-deterministic ordering\n- Design for independence\n\n### Optimization\n\n1. Use command hooks for quick deterministic checks\n2. Use prompt hooks for complex reasoning\n3. Cache validation results in temp files\n4. Minimize I/O in hot paths\n\n## Temporarily Active Hooks\n\nCreate hooks that activate conditionally by checking for a flag file or configuration:\n\n**Pattern: Flag file activation**\n```bash\n#!/bin/bash\n# Only active when flag file exists\nFLAG_FILE=\"$CLAUDE_PROJECT_DIR/.enable-strict-validation\"\n\nif [ ! -f \"$FLAG_FILE\" ]; then\n  # Flag not present, skip validation\n  exit 0\nfi\n\n# Flag present, run validation\ninput=$(cat)\n# ... validation logic ...\n```\n\n**Pattern: Configuration-based activation**\n```bash\n#!/bin/bash\n# Check configuration for activation\nCONFIG_FILE=\"$CLAUDE_PROJECT_DIR/.claude/plugin-config.json\"\n\nif [ -f \"$CONFIG_FILE\" ]; then\n  enabled=$(jq -r '.strictMode // false' \"$CONFIG_FILE\")\n  if [ \"$enabled\" != \"true\" ]; then\n    exit 0  # Not enabled, skip\n  fi\nfi\n\n# Enabled, run hook logic\ninput=$(cat)\n# ... hook logic ...\n```\n\n**Use cases:**\n- Enable strict validation only when needed\n- Temporary debugging hooks\n- Project-specific hook behavior\n- Feature flags for hooks\n\n**Best practice:** Document activation mechanism in plugin README so users know how to enable/disable temporary hooks.\n\n## Hook Lifecycle and Limitations\n\n### Hooks Load at Session Start\n\n**Important:** Hooks are loaded when Claude Code session starts. Changes to hook configuration require restarting Claude Code.\n\n**Cannot hot-swap hooks:**\n- Editing `hooks/hooks.json` won't affect current session\n- Adding new hook scripts won't be recognized\n- Changing hook commands/prompts won't update\n- Must restart Claude Code: exit and run `claude` again\n\n**To test hook changes:**\n1. Edit hook configuration or scripts\n2. Exit Claude Code session\n3. Restart: `claude` or `cc`\n4. New hook configuration loads\n5. Test hooks with `claude --debug`\n\n### Hook Validation at Startup\n\nHooks are validated when Claude Code starts:\n- Invalid JSON in hooks.json causes loading failure\n- Missing scripts cause warnings\n- Syntax errors reported in debug mode\n\nUse `/hooks` command to review loaded hooks in current session.\n\n## Debugging Hooks\n\n### Enable Debug Mode\n\n```bash\nclaude --debug\n```\n\nLook for hook registration, execution logs, input/output JSON, and timing information.\n\n### Test Hook Scripts\n\nTest command hooks directly:\n\n```bash\necho '{\"tool_name\": \"Write\", \"tool_input\": {\"file_path\": \"/test\"}}' | \\\n  bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\n\necho \"Exit code: $?\"\n```\n\n### Validate JSON Output\n\nEnsure hooks output valid JSON:\n\n```bash\noutput=$(./your-hook.sh < test-input.json)\necho \"$output\" | jq .\n```\n\n## Quick Reference\n\n### Hook Events Summary\n\n| Event | When | Use For |\n|-------|------|---------|\n| PreToolUse | Before tool | Validation, modification |\n| PostToolUse | After tool | Feedback, logging |\n| UserPromptSubmit | User input | Context, validation |\n| Stop | Agent stopping | Completeness check |\n| SubagentStop | Subagent done | Task validation |\n| SessionStart | Session begins | Context loading |\n| SessionEnd | Session ends | Cleanup, logging |\n| PreCompact | Before compact | Preserve context |\n| Notification | User notified | Logging, reactions |\n\n### Best Practices\n\n**DO:**\n- âœ… Use prompt-based hooks for complex logic\n- âœ… Use ${CLAUDE_PLUGIN_ROOT} for portability\n- âœ… Validate all inputs in command hooks\n- âœ… Quote all bash variables\n- âœ… Set appropriate timeouts\n- âœ… Return structured JSON output\n- âœ… Test hooks thoroughly\n\n**DON'T:**\n- âŒ Use hardcoded paths\n- âŒ Trust user input without validation\n- âŒ Create long-running hooks\n- âŒ Rely on hook execution order\n- âŒ Modify global state unpredictably\n- âŒ Log sensitive information\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and advanced techniques, consult:\n\n- **`references/patterns.md`** - Common hook patterns (8+ proven patterns)\n- **`references/migration.md`** - Migrating from basic to advanced hooks\n- **`references/advanced.md`** - Advanced use cases and techniques\n\n### Example Hook Scripts\n\nWorking examples in `examples/`:\n\n- **`validate-write.sh`** - File write validation example\n- **`validate-bash.sh`** - Bash command validation example\n- **`load-context.sh`** - SessionStart context loading example\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-hook-schema.sh`** - Validate hooks.json structure and syntax\n- **`test-hook.sh`** - Test hooks with sample input before deployment\n- **`hook-linter.sh`** - Check hook scripts for common issues and best practices\n\n### External Resources\n\n- **Official Docs**: https://docs.claude.com/en/docs/claude-code/hooks\n- **Examples**: See security-guidance plugin in marketplace\n- **Testing**: Use `claude --debug` for detailed logs\n- **Validation**: Use `jq` to validate hook JSON output\n\n## Implementation Workflow\n\nTo implement hooks in a plugin:\n\n1. Identify events to hook into (PreToolUse, Stop, SessionStart, etc.)\n2. Decide between prompt-based (flexible) or command (deterministic) hooks\n3. Write hook configuration in `hooks/hooks.json`\n4. For command hooks, create hook scripts\n5. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n6. Validate configuration with `scripts/validate-hook-schema.sh hooks/hooks.json`\n7. Test hooks with `scripts/test-hook.sh` before deployment\n8. Test in Claude Code with `claude --debug`\n9. Document hooks in plugin README\n\nFocus on prompt-based hooks for most use cases. Reserve command hooks for performance-critical or deterministic checks."
              },
              {
                "name": "MCP Integration",
                "description": "This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration.",
                "path": "plugins/plugin-dev/skills/mcp-integration/SKILL.md",
                "frontmatter": {
                  "name": "MCP Integration",
                  "description": "This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration.",
                  "version": "0.1.0"
                },
                "content": "# MCP Integration for Claude Code Plugins\n\n## Overview\n\nModel Context Protocol (MCP) enables Claude Code plugins to integrate with external services and APIs by providing structured tool access. Use MCP integration to expose external service capabilities as tools within Claude Code.\n\n**Key capabilities:**\n- Connect to external services (databases, APIs, file systems)\n- Provide 10+ related tools from a single service\n- Handle OAuth and complex authentication flows\n- Bundle MCP servers with plugins for automatic setup\n\n## MCP Server Configuration Methods\n\nPlugins can bundle MCP servers in two ways:\n\n### Method 1: Dedicated .mcp.json (Recommended)\n\nCreate `.mcp.json` at plugin root:\n\n```json\n{\n  \"database-tools\": {\n    \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/db-server\",\n    \"args\": [\"--config\", \"${CLAUDE_PLUGIN_ROOT}/config.json\"],\n    \"env\": {\n      \"DB_URL\": \"${DB_URL}\"\n    }\n  }\n}\n```\n\n**Benefits:**\n- Clear separation of concerns\n- Easier to maintain\n- Better for multiple servers\n\n### Method 2: Inline in plugin.json\n\nAdd `mcpServers` field to plugin.json:\n\n```json\n{\n  \"name\": \"my-plugin\",\n  \"version\": \"1.0.0\",\n  \"mcpServers\": {\n    \"plugin-api\": {\n      \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/api-server\",\n      \"args\": [\"--port\", \"8080\"]\n    }\n  }\n}\n```\n\n**Benefits:**\n- Single configuration file\n- Good for simple single-server plugins\n\n## MCP Server Types\n\n### stdio (Local Process)\n\nExecute local MCP servers as child processes. Best for local tools and custom servers.\n\n**Configuration:**\n```json\n{\n  \"filesystem\": {\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/allowed/path\"],\n    \"env\": {\n      \"LOG_LEVEL\": \"debug\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- File system access\n- Local database connections\n- Custom MCP servers\n- NPM-packaged MCP servers\n\n**Process management:**\n- Claude Code spawns and manages the process\n- Communicates via stdin/stdout\n- Terminates when Claude Code exits\n\n### SSE (Server-Sent Events)\n\nConnect to hosted MCP servers with OAuth support. Best for cloud services.\n\n**Configuration:**\n```json\n{\n  \"asana\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.asana.com/sse\"\n  }\n}\n```\n\n**Use cases:**\n- Official hosted MCP servers (Asana, GitHub, etc.)\n- Cloud services with MCP endpoints\n- OAuth-based authentication\n- No local installation needed\n\n**Authentication:**\n- OAuth flows handled automatically\n- User prompted on first use\n- Tokens managed by Claude Code\n\n### HTTP (REST API)\n\nConnect to RESTful MCP servers with token authentication.\n\n**Configuration:**\n```json\n{\n  \"api-service\": {\n    \"type\": \"http\",\n    \"url\": \"https://api.example.com/mcp\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${API_TOKEN}\",\n      \"X-Custom-Header\": \"value\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- REST API-based MCP servers\n- Token-based authentication\n- Custom API backends\n- Stateless interactions\n\n### WebSocket (Real-time)\n\nConnect to WebSocket MCP servers for real-time bidirectional communication.\n\n**Configuration:**\n```json\n{\n  \"realtime-service\": {\n    \"type\": \"ws\",\n    \"url\": \"wss://mcp.example.com/ws\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${TOKEN}\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- Real-time data streaming\n- Persistent connections\n- Push notifications from server\n- Low-latency requirements\n\n## Environment Variable Expansion\n\nAll MCP configurations support environment variable substitution:\n\n**${CLAUDE_PLUGIN_ROOT}** - Plugin directory (always use for portability):\n```json\n{\n  \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/my-server\"\n}\n```\n\n**User environment variables** - From user's shell:\n```json\n{\n  \"env\": {\n    \"API_KEY\": \"${MY_API_KEY}\",\n    \"DATABASE_URL\": \"${DB_URL}\"\n  }\n}\n```\n\n**Best practice:** Document all required environment variables in plugin README.\n\n## MCP Tool Naming\n\nWhen MCP servers provide tools, they're automatically prefixed:\n\n**Format:** `mcp__plugin_<plugin-name>_<server-name>__<tool-name>`\n\n**Example:**\n- Plugin: `asana`\n- Server: `asana`\n- Tool: `create_task`\n- **Full name:** `mcp__plugin_asana_asana__asana_create_task`\n\n### Using MCP Tools in Commands\n\nPre-allow specific MCP tools in command frontmatter:\n\n```markdown\n---\nallowed-tools: [\n  \"mcp__plugin_asana_asana__asana_create_task\",\n  \"mcp__plugin_asana_asana__asana_search_tasks\"\n]\n---\n```\n\n**Wildcard (use sparingly):**\n```markdown\n---\nallowed-tools: [\"mcp__plugin_asana_asana__*\"]\n---\n```\n\n**Best practice:** Pre-allow specific tools, not wildcards, for security.\n\n## Lifecycle Management\n\n**Automatic startup:**\n- MCP servers start when plugin enables\n- Connection established before first tool use\n- Restart required for configuration changes\n\n**Lifecycle:**\n1. Plugin loads\n2. MCP configuration parsed\n3. Server process started (stdio) or connection established (SSE/HTTP/WS)\n4. Tools discovered and registered\n5. Tools available as `mcp__plugin_...__...`\n\n**Viewing servers:**\nUse `/mcp` command to see all servers including plugin-provided ones.\n\n## Authentication Patterns\n\n### OAuth (SSE/HTTP)\n\nOAuth handled automatically by Claude Code:\n\n```json\n{\n  \"type\": \"sse\",\n  \"url\": \"https://mcp.example.com/sse\"\n}\n```\n\nUser authenticates in browser on first use. No additional configuration needed.\n\n### Token-Based (Headers)\n\nStatic or environment variable tokens:\n\n```json\n{\n  \"type\": \"http\",\n  \"url\": \"https://api.example.com\",\n  \"headers\": {\n    \"Authorization\": \"Bearer ${API_TOKEN}\"\n  }\n}\n```\n\nDocument required environment variables in README.\n\n### Environment Variables (stdio)\n\nPass configuration to MCP server:\n\n```json\n{\n  \"command\": \"python\",\n  \"args\": [\"-m\", \"my_mcp_server\"],\n  \"env\": {\n    \"DATABASE_URL\": \"${DB_URL}\",\n    \"API_KEY\": \"${API_KEY}\",\n    \"LOG_LEVEL\": \"info\"\n  }\n}\n```\n\n## Integration Patterns\n\n### Pattern 1: Simple Tool Wrapper\n\nCommands use MCP tools with user interaction:\n\n```markdown\n# Command: create-item.md\n---\nallowed-tools: [\"mcp__plugin_name_server__create_item\"]\n---\n\nSteps:\n1. Gather item details from user\n2. Use mcp__plugin_name_server__create_item\n3. Confirm creation\n```\n\n**Use for:** Adding validation or preprocessing before MCP calls.\n\n### Pattern 2: Autonomous Agent\n\nAgents use MCP tools autonomously:\n\n```markdown\n# Agent: data-analyzer.md\n\nAnalysis Process:\n1. Query data via mcp__plugin_db_server__query\n2. Process and analyze results\n3. Generate insights report\n```\n\n**Use for:** Multi-step MCP workflows without user interaction.\n\n### Pattern 3: Multi-Server Plugin\n\nIntegrate multiple MCP servers:\n\n```json\n{\n  \"github\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.github.com/sse\"\n  },\n  \"jira\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.jira.com/sse\"\n  }\n}\n```\n\n**Use for:** Workflows spanning multiple services.\n\n## Security Best Practices\n\n### Use HTTPS/WSS\n\nAlways use secure connections:\n\n```json\nâœ… \"url\": \"https://mcp.example.com/sse\"\nâŒ \"url\": \"http://mcp.example.com/sse\"\n```\n\n### Token Management\n\n**DO:**\n- âœ… Use environment variables for tokens\n- âœ… Document required env vars in README\n- âœ… Let OAuth flow handle authentication\n\n**DON'T:**\n- âŒ Hardcode tokens in configuration\n- âŒ Commit tokens to git\n- âŒ Share tokens in documentation\n\n### Permission Scoping\n\nPre-allow only necessary MCP tools:\n\n```markdown\nâœ… allowed-tools: [\n  \"mcp__plugin_api_server__read_data\",\n  \"mcp__plugin_api_server__create_item\"\n]\n\nâŒ allowed-tools: [\"mcp__plugin_api_server__*\"]\n```\n\n## Error Handling\n\n### Connection Failures\n\nHandle MCP server unavailability:\n- Provide fallback behavior in commands\n- Inform user of connection issues\n- Check server URL and configuration\n\n### Tool Call Errors\n\nHandle failed MCP operations:\n- Validate inputs before calling MCP tools\n- Provide clear error messages\n- Check rate limiting and quotas\n\n### Configuration Errors\n\nValidate MCP configuration:\n- Test server connectivity during development\n- Validate JSON syntax\n- Check required environment variables\n\n## Performance Considerations\n\n### Lazy Loading\n\nMCP servers connect on-demand:\n- Not all servers connect at startup\n- First tool use triggers connection\n- Connection pooling managed automatically\n\n### Batching\n\nBatch similar requests when possible:\n\n```\n# Good: Single query with filters\ntasks = search_tasks(project=\"X\", assignee=\"me\", limit=50)\n\n# Avoid: Many individual queries\nfor id in task_ids:\n    task = get_task(id)\n```\n\n## Testing MCP Integration\n\n### Local Testing\n\n1. Configure MCP server in `.mcp.json`\n2. Install plugin locally (`.claude-plugin/`)\n3. Run `/mcp` to verify server appears\n4. Test tool calls in commands\n5. Check `claude --debug` logs for connection issues\n\n### Validation Checklist\n\n- [ ] MCP configuration is valid JSON\n- [ ] Server URL is correct and accessible\n- [ ] Required environment variables documented\n- [ ] Tools appear in `/mcp` output\n- [ ] Authentication works (OAuth or tokens)\n- [ ] Tool calls succeed from commands\n- [ ] Error cases handled gracefully\n\n## Debugging\n\n### Enable Debug Logging\n\n```bash\nclaude --debug\n```\n\nLook for:\n- MCP server connection attempts\n- Tool discovery logs\n- Authentication flows\n- Tool call errors\n\n### Common Issues\n\n**Server not connecting:**\n- Check URL is correct\n- Verify server is running (stdio)\n- Check network connectivity\n- Review authentication configuration\n\n**Tools not available:**\n- Verify server connected successfully\n- Check tool names match exactly\n- Run `/mcp` to see available tools\n- Restart Claude Code after config changes\n\n**Authentication failing:**\n- Clear cached auth tokens\n- Re-authenticate\n- Check token scopes and permissions\n- Verify environment variables set\n\n## Quick Reference\n\n### MCP Server Types\n\n| Type | Transport | Best For | Auth |\n|------|-----------|----------|------|\n| stdio | Process | Local tools, custom servers | Env vars |\n| SSE | HTTP | Hosted services, cloud APIs | OAuth |\n| HTTP | REST | API backends, token auth | Tokens |\n| ws | WebSocket | Real-time, streaming | Tokens |\n\n### Configuration Checklist\n\n- [ ] Server type specified (stdio/SSE/HTTP/ws)\n- [ ] Type-specific fields complete (command or url)\n- [ ] Authentication configured\n- [ ] Environment variables documented\n- [ ] HTTPS/WSS used (not HTTP/WS)\n- [ ] ${CLAUDE_PLUGIN_ROOT} used for paths\n\n### Best Practices\n\n**DO:**\n- âœ… Use ${CLAUDE_PLUGIN_ROOT} for portable paths\n- âœ… Document required environment variables\n- âœ… Use secure connections (HTTPS/WSS)\n- âœ… Pre-allow specific MCP tools in commands\n- âœ… Test MCP integration before publishing\n- âœ… Handle connection and tool errors gracefully\n\n**DON'T:**\n- âŒ Hardcode absolute paths\n- âŒ Commit credentials to git\n- âŒ Use HTTP instead of HTTPS\n- âŒ Pre-allow all tools with wildcards\n- âŒ Skip error handling\n- âŒ Forget to document setup\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed information, consult:\n\n- **`references/server-types.md`** - Deep dive on each server type\n- **`references/authentication.md`** - Authentication patterns and OAuth\n- **`references/tool-usage.md`** - Using MCP tools in commands and agents\n\n### Example Configurations\n\nWorking examples in `examples/`:\n\n- **`stdio-server.json`** - Local stdio MCP server\n- **`sse-server.json`** - Hosted SSE server with OAuth\n- **`http-server.json`** - REST API with token auth\n\n### External Resources\n\n- **Official MCP Docs**: https://modelcontextprotocol.io/\n- **Claude Code MCP Docs**: https://docs.claude.com/en/docs/claude-code/mcp\n- **MCP SDK**: @modelcontextprotocol/sdk\n- **Testing**: Use `claude --debug` and `/mcp` command\n\n## Implementation Workflow\n\nTo add MCP integration to a plugin:\n\n1. Choose MCP server type (stdio, SSE, HTTP, ws)\n2. Create `.mcp.json` at plugin root with configuration\n3. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n4. Document required environment variables in README\n5. Test locally with `/mcp` command\n6. Pre-allow MCP tools in relevant commands\n7. Handle authentication (OAuth or tokens)\n8. Test error cases (connection failures, auth errors)\n9. Document MCP integration in plugin README\n\nFocus on stdio for custom/local servers, SSE for hosted services with OAuth."
              },
              {
                "name": "Plugin Settings",
                "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.",
                "path": "plugins/plugin-dev/skills/plugin-settings/SKILL.md",
                "frontmatter": {
                  "name": "Plugin Settings",
                  "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.",
                  "version": "0.1.0"
                },
                "content": "# Plugin Settings Pattern for Claude Code Plugins\n\n## Overview\n\nPlugins can store user-configurable settings and state in `.claude/plugin-name.local.md` files within the project directory. This pattern uses YAML frontmatter for structured configuration and markdown content for prompts or additional context.\n\n**Key characteristics:**\n- File location: `.claude/plugin-name.local.md` in project root\n- Structure: YAML frontmatter + markdown body\n- Purpose: Per-project plugin configuration and state\n- Usage: Read from hooks, commands, and agents\n- Lifecycle: User-managed (not in git, should be in `.gitignore`)\n\n## File Structure\n\n### Basic Template\n\n```markdown\n---\nenabled: true\nsetting1: value1\nsetting2: value2\nnumeric_setting: 42\nlist_setting: [\"item1\", \"item2\"]\n---\n\n# Additional Context\n\nThis markdown body can contain:\n- Task descriptions\n- Additional instructions\n- Prompts to feed back to Claude\n- Documentation or notes\n```\n\n### Example: Plugin State File\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nenabled: true\nstrict_mode: false\nmax_retries: 3\nnotification_level: info\ncoordinator_session: team-leader\n---\n\n# Plugin Configuration\n\nThis plugin is configured for standard validation mode.\nContact @team-lead with questions.\n```\n\n## Reading Settings Files\n\n### From Hooks (Bash Scripts)\n\n**Pattern: Check existence and parse frontmatter**\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\n# Define state file path\nSTATE_FILE=\".claude/my-plugin.local.md\"\n\n# Quick exit if file doesn't exist\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0  # Plugin not configured, skip\nfi\n\n# Parse YAML frontmatter (between --- markers)\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\n\n# Extract individual fields\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\nSTRICT_MODE=$(echo \"$FRONTMATTER\" | grep '^strict_mode:' | sed 's/strict_mode: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n\n# Check if enabled\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Use configuration in hook logic\nif [[ \"$STRICT_MODE\" == \"true\" ]]; then\n  # Apply strict validation\n  # ...\nfi\n```\n\nSee `examples/read-settings-hook.sh` for complete working example.\n\n### From Commands\n\nCommands can read settings files to customize behavior:\n\n```markdown\n---\ndescription: Process data with plugin\nallowed-tools: [\"Read\", \"Bash\"]\n---\n\n# Process Command\n\nSteps:\n1. Check if settings exist at `.claude/my-plugin.local.md`\n2. Read configuration using Read tool\n3. Parse YAML frontmatter to extract settings\n4. Apply settings to processing logic\n5. Execute with configured behavior\n```\n\n### From Agents\n\nAgents can reference settings in their instructions:\n\n```markdown\n---\nname: configured-agent\ndescription: Agent that adapts to project settings\n---\n\nCheck for plugin settings at `.claude/my-plugin.local.md`.\nIf present, parse YAML frontmatter and adapt behavior according to:\n- enabled: Whether plugin is active\n- mode: Processing mode (strict, standard, lenient)\n- Additional configuration fields\n```\n\n## Parsing Techniques\n\n### Extract Frontmatter\n\n```bash\n# Extract everything between --- markers\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n```\n\n### Read Individual Fields\n\n**String fields:**\n```bash\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field_name:' | sed 's/field_name: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n**Boolean fields:**\n```bash\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n# Compare: if [[ \"$ENABLED\" == \"true\" ]]; then\n```\n\n**Numeric fields:**\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n# Use: if [[ $MAX -gt 100 ]]; then\n```\n\n### Read Markdown Body\n\nExtract content after second `---`:\n\n```bash\n# Get everything after closing ---\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n## Common Patterns\n\n### Pattern 1: Temporarily Active Hooks\n\nUse settings file to control hook activation:\n\n```bash\n#!/bin/bash\nSTATE_FILE=\".claude/security-scan.local.md\"\n\n# Quick exit if not configured\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0\nfi\n\n# Read enabled flag\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Run hook logic\n# ...\n```\n\n**Use case:** Enable/disable hooks without editing hooks.json (requires restart).\n\n### Pattern 2: Agent State Management\n\nStore agent-specific state and configuration:\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-agent\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\n---\n\n# Task Assignment\n\nImplement JWT authentication for the API.\n\n**Success Criteria:**\n- Authentication endpoints created\n- Tests passing\n- PR created and CI green\n```\n\nRead from hooks to coordinate agents:\n\n```bash\nAGENT_NAME=$(echo \"$FRONTMATTER\" | grep '^agent_name:' | sed 's/agent_name: *//')\nCOORDINATOR=$(echo \"$FRONTMATTER\" | grep '^coordinator_session:' | sed 's/coordinator_session: *//')\n\n# Send notification to coordinator\ntmux send-keys -t \"$COORDINATOR\" \"Agent $AGENT_NAME completed task\" Enter\n```\n\n### Pattern 3: Configuration-Driven Behavior\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nvalidation_level: strict\nmax_file_size: 1000000\nallowed_extensions: [\".js\", \".ts\", \".tsx\"]\nenable_logging: true\n---\n\n# Validation Configuration\n\nStrict mode enabled for this project.\nAll writes validated against security policies.\n```\n\nUse in hooks or commands:\n\n```bash\nLEVEL=$(echo \"$FRONTMATTER\" | grep '^validation_level:' | sed 's/validation_level: *//')\n\ncase \"$LEVEL\" in\n  strict)\n    # Apply strict validation\n    ;;\n  standard)\n    # Apply standard validation\n    ;;\n  lenient)\n    # Apply lenient validation\n    ;;\nesac\n```\n\n## Creating Settings Files\n\n### From Commands\n\nCommands can create settings files:\n\n```markdown\n# Setup Command\n\nSteps:\n1. Ask user for configuration preferences\n2. Create `.claude/my-plugin.local.md` with YAML frontmatter\n3. Set appropriate values based on user input\n4. Inform user that settings are saved\n5. Remind user to restart Claude Code for hooks to recognize changes\n```\n\n### Template Generation\n\nProvide template in plugin README:\n\n```markdown\n## Configuration\n\nCreate `.claude/my-plugin.local.md` in your project:\n\n\\`\\`\\`markdown\n---\nenabled: true\nmode: standard\nmax_retries: 3\n---\n\n# Plugin Configuration\n\nYour settings are active.\n\\`\\`\\`\n\nAfter creating or editing, restart Claude Code for changes to take effect.\n```\n\n## Best Practices\n\n### File Naming\n\nâœ… **DO:**\n- Use `.claude/plugin-name.local.md` format\n- Match plugin name exactly\n- Use `.local.md` suffix for user-local files\n\nâŒ **DON'T:**\n- Use different directory (not `.claude/`)\n- Use inconsistent naming\n- Use `.md` without `.local` (might be committed)\n\n### Gitignore\n\nAlways add to `.gitignore`:\n\n```gitignore\n.claude/*.local.md\n.claude/*.local.json\n```\n\nDocument this in plugin README.\n\n### Defaults\n\nProvide sensible defaults when settings file doesn't exist:\n\n```bash\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  # Use defaults\n  ENABLED=true\n  MODE=standard\nelse\n  # Read from file\n  # ...\nfi\n```\n\n### Validation\n\nValidate settings values:\n\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n\n# Validate numeric range\nif ! [[ \"$MAX\" =~ ^[0-9]+$ ]] || [[ $MAX -lt 1 ]] || [[ $MAX -gt 100 ]]; then\n  echo \"âš ï¸  Invalid max_value in settings (must be 1-100)\" >&2\n  MAX=10  # Use default\nfi\n```\n\n### Restart Requirement\n\n**Important:** Settings changes require Claude Code restart.\n\nDocument in your README:\n\n```markdown\n## Changing Settings\n\nAfter editing `.claude/my-plugin.local.md`:\n1. Save the file\n2. Exit Claude Code\n3. Restart: `claude` or `cc`\n4. New settings will be loaded\n```\n\nHooks cannot be hot-swapped within a session.\n\n## Security Considerations\n\n### Sanitize User Input\n\nWhen writing settings files from user input:\n\n```bash\n# Escape quotes in user input\nSAFE_VALUE=$(echo \"$USER_INPUT\" | sed 's/\"/\\\\\"/g')\n\n# Write to file\ncat > \"$STATE_FILE\" <<EOF\n---\nuser_setting: \"$SAFE_VALUE\"\n---\nEOF\n```\n\n### Validate File Paths\n\nIf settings contain file paths:\n\n```bash\nFILE_PATH=$(echo \"$FRONTMATTER\" | grep '^data_file:' | sed 's/data_file: *//')\n\n# Check for path traversal\nif [[ \"$FILE_PATH\" == *\"..\"* ]]; then\n  echo \"âš ï¸  Invalid path in settings (path traversal)\" >&2\n  exit 2\nfi\n```\n\n### Permissions\n\nSettings files should be:\n- Readable by user only (`chmod 600`)\n- Not committed to git\n- Not shared between users\n\n## Real-World Examples\n\n### multi-agent-swarm Plugin\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-implementation\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\nadditional_instructions: Use JWT tokens, not sessions\n---\n\n# Task: Implement Authentication\n\nBuild JWT-based authentication for the REST API.\nCoordinate with auth-agent on shared types.\n```\n\n**Hook usage (agent-stop-notification.sh):**\n- Checks if file exists (line 15-18: quick exit if not)\n- Parses frontmatter to get coordinator_session, agent_name, enabled\n- Sends notifications to coordinator if enabled\n- Allows quick activation/deactivation via `enabled: true/false`\n\n### ralph-wiggum Plugin\n\n**.claude/ralph-loop.local.md:**\n```markdown\n---\niteration: 1\nmax_iterations: 10\ncompletion_promise: \"All tests passing and build successful\"\n---\n\nFix all the linting errors in the project.\nMake sure tests pass after each fix.\n```\n\n**Hook usage (stop-hook.sh):**\n- Checks if file exists (line 15-18: quick exit if not active)\n- Reads iteration count and max_iterations\n- Extracts completion_promise for loop termination\n- Reads body as the prompt to feed back\n- Updates iteration count on each loop\n\n## Quick Reference\n\n### File Location\n\n```\nproject-root/\nâ””â”€â”€ .claude/\n    â””â”€â”€ plugin-name.local.md\n```\n\n### Frontmatter Parsing\n\n```bash\n# Extract frontmatter\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n\n# Read field\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field:' | sed 's/field: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n### Body Parsing\n\n```bash\n# Extract body (after second ---)\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n### Quick Exit Pattern\n\n```bash\nif [[ ! -f \".claude/my-plugin.local.md\" ]]; then\n  exit 0  # Not configured\nfi\n```\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed implementation patterns:\n\n- **`references/parsing-techniques.md`** - Complete guide to parsing YAML frontmatter and markdown bodies\n- **`references/real-world-examples.md`** - Deep dive into multi-agent-swarm and ralph-wiggum implementations\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`read-settings-hook.sh`** - Hook that reads and uses settings\n- **`create-settings-command.md`** - Command that creates settings file\n- **`example-settings.md`** - Template settings file\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-settings.sh`** - Validate settings file structure\n- **`parse-frontmatter.sh`** - Extract frontmatter fields\n\n## Implementation Workflow\n\nTo add settings to a plugin:\n\n1. Design settings schema (which fields, types, defaults)\n2. Create template file in plugin documentation\n3. Add gitignore entry for `.claude/*.local.md`\n4. Implement settings parsing in hooks/commands\n5. Use quick-exit pattern (check file exists, check enabled field)\n6. Document settings in plugin README with template\n7. Remind users that changes require Claude Code restart\n\nFocus on keeping settings simple and providing good defaults when settings file doesn't exist."
              },
              {
                "name": "Plugin Structure",
                "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.",
                "path": "plugins/plugin-dev/skills/plugin-structure/SKILL.md",
                "frontmatter": {
                  "name": "Plugin Structure",
                  "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.",
                  "version": "0.1.0"
                },
                "content": "# Plugin Structure for Claude Code\n\n## Overview\n\nClaude Code plugins follow a standardized directory structure with automatic component discovery. Understanding this structure enables creating well-organized, maintainable plugins that integrate seamlessly with Claude Code.\n\n**Key concepts:**\n- Conventional directory layout for automatic discovery\n- Manifest-driven configuration in `.claude-plugin/plugin.json`\n- Component-based organization (commands, agents, skills, hooks)\n- Portable path references using `${CLAUDE_PLUGIN_ROOT}`\n- Explicit vs. auto-discovered component loading\n\n## Directory Structure\n\nEvery Claude Code plugin follows this organizational pattern:\n\n```\nplugin-name/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json          # Required: Plugin manifest\nâ”œâ”€â”€ commands/                 # Slash commands (.md files)\nâ”œâ”€â”€ agents/                   # Subagent definitions (.md files)\nâ”œâ”€â”€ skills/                   # Agent skills (subdirectories)\nâ”‚   â””â”€â”€ skill-name/\nâ”‚       â””â”€â”€ SKILL.md         # Required for each skill\nâ”œâ”€â”€ hooks/\nâ”‚   â””â”€â”€ hooks.json           # Event handler configuration\nâ”œâ”€â”€ .mcp.json                # MCP server definitions\nâ””â”€â”€ scripts/                 # Helper scripts and utilities\n```\n\n**Critical rules:**\n\n1. **Manifest location**: The `plugin.json` manifest MUST be in `.claude-plugin/` directory\n2. **Component locations**: All component directories (commands, agents, skills, hooks) MUST be at plugin root level, NOT nested inside `.claude-plugin/`\n3. **Optional components**: Only create directories for components the plugin actually uses\n4. **Naming convention**: Use kebab-case for all directory and file names\n\n## Plugin Manifest (plugin.json)\n\nThe manifest defines plugin metadata and configuration. Located at `.claude-plugin/plugin.json`:\n\n### Required Fields\n\n```json\n{\n  \"name\": \"plugin-name\"\n}\n```\n\n**Name requirements:**\n- Use kebab-case format (lowercase with hyphens)\n- Must be unique across installed plugins\n- No spaces or special characters\n- Example: `code-review-assistant`, `test-runner`, `api-docs`\n\n### Recommended Metadata\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Brief explanation of plugin purpose\",\n  \"author\": {\n    \"name\": \"Author Name\",\n    \"email\": \"author@example.com\",\n    \"url\": \"https://example.com\"\n  },\n  \"homepage\": \"https://docs.example.com\",\n  \"repository\": \"https://github.com/user/plugin-name\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"testing\", \"automation\", \"ci-cd\"]\n}\n```\n\n**Version format**: Follow semantic versioning (MAJOR.MINOR.PATCH)\n**Keywords**: Use for plugin discovery and categorization\n\n### Component Path Configuration\n\nSpecify custom paths for components (supplements default directories):\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"commands\": \"./custom-commands\",\n  \"agents\": [\"./agents\", \"./specialized-agents\"],\n  \"hooks\": \"./config/hooks.json\",\n  \"mcpServers\": \"./.mcp.json\"\n}\n```\n\n**Important**: Custom paths supplement defaultsâ€”they don't replace them. Components in both default directories and custom paths will load.\n\n**Path rules:**\n- Must be relative to plugin root\n- Must start with `./`\n- Cannot use absolute paths\n- Support arrays for multiple locations\n\n## Component Organization\n\n### Commands\n\n**Location**: `commands/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `commands/` load automatically\n\n**Example structure**:\n```\ncommands/\nâ”œâ”€â”€ review.md        # /review command\nâ”œâ”€â”€ test.md          # /test command\nâ””â”€â”€ deploy.md        # /deploy command\n```\n\n**File format**:\n```markdown\n---\nname: command-name\ndescription: Command description\n---\n\nCommand implementation instructions...\n```\n\n**Usage**: Commands integrate as native slash commands in Claude Code\n\n### Agents\n\n**Location**: `agents/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `agents/` load automatically\n\n**Example structure**:\n```\nagents/\nâ”œâ”€â”€ code-reviewer.md\nâ”œâ”€â”€ test-generator.md\nâ””â”€â”€ refactorer.md\n```\n\n**File format**:\n```markdown\n---\ndescription: Agent role and expertise\ncapabilities:\n  - Specific task 1\n  - Specific task 2\n---\n\nDetailed agent instructions and knowledge...\n```\n\n**Usage**: Users can invoke agents manually, or Claude Code selects them automatically based on task context\n\n### Skills\n\n**Location**: `skills/` directory with subdirectories per skill\n**Format**: Each skill in its own directory with `SKILL.md` file\n**Auto-discovery**: All `SKILL.md` files in skill subdirectories load automatically\n\n**Example structure**:\n```\nskills/\nâ”œâ”€â”€ api-testing/\nâ”‚   â”œâ”€â”€ SKILL.md\nâ”‚   â”œâ”€â”€ scripts/\nâ”‚   â”‚   â””â”€â”€ test-runner.py\nâ”‚   â””â”€â”€ references/\nâ”‚       â””â”€â”€ api-spec.md\nâ””â”€â”€ database-migrations/\n    â”œâ”€â”€ SKILL.md\n    â””â”€â”€ examples/\n        â””â”€â”€ migration-template.sql\n```\n\n**SKILL.md format**:\n```markdown\n---\nname: Skill Name\ndescription: When to use this skill\nversion: 1.0.0\n---\n\nSkill instructions and guidance...\n```\n\n**Supporting files**: Skills can include scripts, references, examples, or assets in subdirectories\n\n**Usage**: Claude Code autonomously activates skills based on task context matching the description\n\n### Hooks\n\n**Location**: `hooks/hooks.json` or inline in `plugin.json`\n**Format**: JSON configuration defining event handlers\n**Registration**: Hooks register automatically when plugin enables\n\n**Example structure**:\n```\nhooks/\nâ”œâ”€â”€ hooks.json           # Hook configuration\nâ””â”€â”€ scripts/\n    â”œâ”€â”€ validate.sh      # Hook script\n    â””â”€â”€ check-style.sh   # Hook script\n```\n\n**Configuration format**:\n```json\n{\n  \"PreToolUse\": [{\n    \"matcher\": \"Write|Edit\",\n    \"hooks\": [{\n      \"type\": \"command\",\n      \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/validate.sh\",\n      \"timeout\": 30\n    }]\n  }]\n}\n```\n\n**Available events**: PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification\n\n**Usage**: Hooks execute automatically in response to Claude Code events\n\n### MCP Servers\n\n**Location**: `.mcp.json` at plugin root or inline in `plugin.json`\n**Format**: JSON configuration for MCP server definitions\n**Auto-start**: Servers start automatically when plugin enables\n\n**Example format**:\n```json\n{\n  \"mcpServers\": {\n    \"server-name\": {\n      \"command\": \"node\",\n      \"args\": [\"${CLAUDE_PLUGIN_ROOT}/servers/server.js\"],\n      \"env\": {\n        \"API_KEY\": \"${API_KEY}\"\n      }\n    }\n  }\n}\n```\n\n**Usage**: MCP servers integrate seamlessly with Claude Code's tool system\n\n## Portable Path References\n\n### ${CLAUDE_PLUGIN_ROOT}\n\nUse `${CLAUDE_PLUGIN_ROOT}` environment variable for all intra-plugin path references:\n\n```json\n{\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/run.sh\"\n}\n```\n\n**Why it matters**: Plugins install in different locations depending on:\n- User installation method (marketplace, local, npm)\n- Operating system conventions\n- User preferences\n\n**Where to use it**:\n- Hook command paths\n- MCP server command arguments\n- Script execution references\n- Resource file paths\n\n**Never use**:\n- Hardcoded absolute paths (`/Users/name/plugins/...`)\n- Relative paths from working directory (`./scripts/...` in commands)\n- Home directory shortcuts (`~/plugins/...`)\n\n### Path Resolution Rules\n\n**In manifest JSON fields** (hooks, MCP servers):\n```json\n\"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/tool.sh\"\n```\n\n**In component files** (commands, agents, skills):\n```markdown\nReference scripts at: ${CLAUDE_PLUGIN_ROOT}/scripts/helper.py\n```\n\n**In executed scripts**:\n```bash\n#!/bin/bash\n# ${CLAUDE_PLUGIN_ROOT} available as environment variable\nsource \"${CLAUDE_PLUGIN_ROOT}/lib/common.sh\"\n```\n\n## File Naming Conventions\n\n### Component Files\n\n**Commands**: Use kebab-case `.md` files\n- `code-review.md` â†’ `/code-review`\n- `run-tests.md` â†’ `/run-tests`\n- `api-docs.md` â†’ `/api-docs`\n\n**Agents**: Use kebab-case `.md` files describing role\n- `test-generator.md`\n- `code-reviewer.md`\n- `performance-analyzer.md`\n\n**Skills**: Use kebab-case directory names\n- `api-testing/`\n- `database-migrations/`\n- `error-handling/`\n\n### Supporting Files\n\n**Scripts**: Use descriptive kebab-case names with appropriate extensions\n- `validate-input.sh`\n- `generate-report.py`\n- `process-data.js`\n\n**Documentation**: Use kebab-case markdown files\n- `api-reference.md`\n- `migration-guide.md`\n- `best-practices.md`\n\n**Configuration**: Use standard names\n- `hooks.json`\n- `.mcp.json`\n- `plugin.json`\n\n## Auto-Discovery Mechanism\n\nClaude Code automatically discovers and loads components:\n\n1. **Plugin manifest**: Reads `.claude-plugin/plugin.json` when plugin enables\n2. **Commands**: Scans `commands/` directory for `.md` files\n3. **Agents**: Scans `agents/` directory for `.md` files\n4. **Skills**: Scans `skills/` for subdirectories containing `SKILL.md`\n5. **Hooks**: Loads configuration from `hooks/hooks.json` or manifest\n6. **MCP servers**: Loads configuration from `.mcp.json` or manifest\n\n**Discovery timing**:\n- Plugin installation: Components register with Claude Code\n- Plugin enable: Components become available for use\n- No restart required: Changes take effect on next Claude Code session\n\n**Override behavior**: Custom paths in `plugin.json` supplement (not replace) default directories\n\n## Best Practices\n\n### Organization\n\n1. **Logical grouping**: Group related components together\n   - Put test-related commands, agents, and skills together\n   - Create subdirectories in `scripts/` for different purposes\n\n2. **Minimal manifest**: Keep `plugin.json` lean\n   - Only specify custom paths when necessary\n   - Rely on auto-discovery for standard layouts\n   - Use inline configuration only for simple cases\n\n3. **Documentation**: Include README files\n   - Plugin root: Overall purpose and usage\n   - Component directories: Specific guidance\n   - Script directories: Usage and requirements\n\n### Naming\n\n1. **Consistency**: Use consistent naming across components\n   - If command is `test-runner`, name related agent `test-runner-agent`\n   - Match skill directory names to their purpose\n\n2. **Clarity**: Use descriptive names that indicate purpose\n   - Good: `api-integration-testing/`, `code-quality-checker.md`\n   - Avoid: `utils/`, `misc.md`, `temp.sh`\n\n3. **Length**: Balance brevity with clarity\n   - Commands: 2-3 words (`review-pr`, `run-ci`)\n   - Agents: Describe role clearly (`code-reviewer`, `test-generator`)\n   - Skills: Topic-focused (`error-handling`, `api-design`)\n\n### Portability\n\n1. **Always use ${CLAUDE_PLUGIN_ROOT}**: Never hardcode paths\n2. **Test on multiple systems**: Verify on macOS, Linux, Windows\n3. **Document dependencies**: List required tools and versions\n4. **Avoid system-specific features**: Use portable bash/Python constructs\n\n### Maintenance\n\n1. **Version consistently**: Update version in plugin.json for releases\n2. **Deprecate gracefully**: Mark old components clearly before removal\n3. **Document breaking changes**: Note changes affecting existing users\n4. **Test thoroughly**: Verify all components work after changes\n\n## Common Patterns\n\n### Minimal Plugin\n\nSingle command with no dependencies:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json    # Just name field\nâ””â”€â”€ commands/\n    â””â”€â”€ hello.md       # Single command\n```\n\n### Full-Featured Plugin\n\nComplete plugin with all component types:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/          # User-facing commands\nâ”œâ”€â”€ agents/            # Specialized subagents\nâ”œâ”€â”€ skills/            # Auto-activating skills\nâ”œâ”€â”€ hooks/             # Event handlers\nâ”‚   â”œâ”€â”€ hooks.json\nâ”‚   â””â”€â”€ scripts/\nâ”œâ”€â”€ .mcp.json          # External integrations\nâ””â”€â”€ scripts/           # Shared utilities\n```\n\n### Skill-Focused Plugin\n\nPlugin providing only skills:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ””â”€â”€ skills/\n    â”œâ”€â”€ skill-one/\n    â”‚   â””â”€â”€ SKILL.md\n    â””â”€â”€ skill-two/\n        â””â”€â”€ SKILL.md\n```\n\n## Troubleshooting\n\n**Component not loading**:\n- Verify file is in correct directory with correct extension\n- Check YAML frontmatter syntax (commands, agents, skills)\n- Ensure skill has `SKILL.md` (not `README.md` or other name)\n- Confirm plugin is enabled in Claude Code settings\n\n**Path resolution errors**:\n- Replace all hardcoded paths with `${CLAUDE_PLUGIN_ROOT}`\n- Verify paths are relative and start with `./` in manifest\n- Check that referenced files exist at specified paths\n- Test with `echo $CLAUDE_PLUGIN_ROOT` in hook scripts\n\n**Auto-discovery not working**:\n- Confirm directories are at plugin root (not in `.claude-plugin/`)\n- Check file naming follows conventions (kebab-case, correct extensions)\n- Verify custom paths in manifest are correct\n- Restart Claude Code to reload plugin configuration\n\n**Conflicts between plugins**:\n- Use unique, descriptive component names\n- Namespace commands with plugin name if needed\n- Document potential conflicts in plugin README\n- Consider command prefixes for related functionality\n\n---\n\nFor detailed examples and advanced patterns, see files in `references/` and `examples/` directories."
              },
              {
                "name": "Skill Development",
                "description": "This skill should be used when the user wants to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins.",
                "path": "plugins/plugin-dev/skills/skill-development/SKILL.md",
                "frontmatter": {
                  "name": "Skill Development",
                  "description": "This skill should be used when the user wants to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins.",
                  "version": "0.1.0"
                },
                "content": "# Skill Development for Claude Code Plugins\n\nThis skill provides guidance for creating effective skills for Claude Code plugins.\n\n## About Skills\n\nSkills are modular, self-contained packages that extend Claude's capabilities by providing\nspecialized knowledge, workflows, and tools. Think of them as \"onboarding guides\" for specific\ndomains or tasksâ€”they transform Claude from a general-purpose agent into a specialized agent\nequipped with procedural knowledge that no model can fully possess.\n\n### What Skills Provide\n\n1. Specialized workflows - Multi-step procedures for specific domains\n2. Tool integrations - Instructions for working with specific file formats or APIs\n3. Domain expertise - Company-specific knowledge, schemas, business logic\n4. Bundled resources - Scripts, references, and assets for complex and repetitive tasks\n\n### Anatomy of a Skill\n\nEvery skill consists of a required SKILL.md file and optional bundled resources:\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md (required)\nâ”‚   â”œâ”€â”€ YAML frontmatter metadata (required)\nâ”‚   â”‚   â”œâ”€â”€ name: (required)\nâ”‚   â”‚   â””â”€â”€ description: (required)\nâ”‚   â””â”€â”€ Markdown instructions (required)\nâ””â”€â”€ Bundled Resources (optional)\n    â”œâ”€â”€ scripts/          - Executable code (Python/Bash/etc.)\n    â”œâ”€â”€ references/       - Documentation intended to be loaded into context as needed\n    â””â”€â”€ assets/           - Files used in output (templates, icons, fonts, etc.)\n```\n\n#### SKILL.md (required)\n\n**Metadata Quality:** The `name` and `description` in YAML frontmatter determine when Claude will use the skill. Be specific about what the skill does and when to use it. Use the third-person (e.g. \"This skill should be used when...\" instead of \"Use this skill when...\").\n\n#### Bundled Resources (optional)\n\n##### Scripts (`scripts/`)\n\nExecutable code (Python/Bash/etc.) for tasks that require deterministic reliability or are repeatedly rewritten.\n\n- **When to include**: When the same code is being rewritten repeatedly or deterministic reliability is needed\n- **Example**: `scripts/rotate_pdf.py` for PDF rotation tasks\n- **Benefits**: Token efficient, deterministic, may be executed without loading into context\n- **Note**: Scripts may still need to be read by Claude for patching or environment-specific adjustments\n\n##### References (`references/`)\n\nDocumentation and reference material intended to be loaded as needed into context to inform Claude's process and thinking.\n\n- **When to include**: For documentation that Claude should reference while working\n- **Examples**: `references/finance.md` for financial schemas, `references/mnda.md` for company NDA template, `references/policies.md` for company policies, `references/api_docs.md` for API specifications\n- **Use cases**: Database schemas, API documentation, domain knowledge, company policies, detailed workflow guides\n- **Benefits**: Keeps SKILL.md lean, loaded only when Claude determines it's needed\n- **Best practice**: If files are large (>10k words), include grep search patterns in SKILL.md\n- **Avoid duplication**: Information should live in either SKILL.md or references files, not both. Prefer references files for detailed information unless it's truly core to the skillâ€”this keeps SKILL.md lean while making information discoverable without hogging the context window. Keep only essential procedural instructions and workflow guidance in SKILL.md; move detailed reference material, schemas, and examples to references files.\n\n##### Assets (`assets/`)\n\nFiles not intended to be loaded into context, but rather used within the output Claude produces.\n\n- **When to include**: When the skill needs files that will be used in the final output\n- **Examples**: `assets/logo.png` for brand assets, `assets/slides.pptx` for PowerPoint templates, `assets/frontend-template/` for HTML/React boilerplate, `assets/font.ttf` for typography\n- **Use cases**: Templates, images, icons, boilerplate code, fonts, sample documents that get copied or modified\n- **Benefits**: Separates output resources from documentation, enables Claude to use files without loading them into context\n\n### Progressive Disclosure Design Principle\n\nSkills use a three-level loading system to manage context efficiently:\n\n1. **Metadata (name + description)** - Always in context (~100 words)\n2. **SKILL.md body** - When skill triggers (<5k words)\n3. **Bundled resources** - As needed by Claude (Unlimited*)\n\n*Unlimited because scripts can be executed without reading into context window.\n\n## Skill Creation Process\n\nTo create a skill, follow the \"Skill Creation Process\" in order, skipping steps only if there is a clear reason why they are not applicable.\n\n### Step 1: Understanding the Skill with Concrete Examples\n\nSkip this step only when the skill's usage patterns are already clearly understood. It remains valuable even when working with an existing skill.\n\nTo create an effective skill, clearly understand concrete examples of how the skill will be used. This understanding can come from either direct user examples or generated examples that are validated with user feedback.\n\nFor example, when building an image-editor skill, relevant questions include:\n\n- \"What functionality should the image-editor skill support? Editing, rotating, anything else?\"\n- \"Can you give some examples of how this skill would be used?\"\n- \"I can imagine users asking for things like 'Remove the red-eye from this image' or 'Rotate this image'. Are there other ways you imagine this skill being used?\"\n- \"What would a user say that should trigger this skill?\"\n\nTo avoid overwhelming users, avoid asking too many questions in a single message. Start with the most important questions and follow up as needed for better effectiveness.\n\nConclude this step when there is a clear sense of the functionality the skill should support.\n\n### Step 2: Planning the Reusable Skill Contents\n\nTo turn concrete examples into an effective skill, analyze each example by:\n\n1. Considering how to execute on the example from scratch\n2. Identifying what scripts, references, and assets would be helpful when executing these workflows repeatedly\n\nExample: When building a `pdf-editor` skill to handle queries like \"Help me rotate this PDF,\" the analysis shows:\n\n1. Rotating a PDF requires re-writing the same code each time\n2. A `scripts/rotate_pdf.py` script would be helpful to store in the skill\n\nExample: When designing a `frontend-webapp-builder` skill for queries like \"Build me a todo app\" or \"Build me a dashboard to track my steps,\" the analysis shows:\n\n1. Writing a frontend webapp requires the same boilerplate HTML/React each time\n2. An `assets/hello-world/` template containing the boilerplate HTML/React project files would be helpful to store in the skill\n\nExample: When building a `big-query` skill to handle queries like \"How many users have logged in today?\" the analysis shows:\n\n1. Querying BigQuery requires re-discovering the table schemas and relationships each time\n2. A `references/schema.md` file documenting the table schemas would be helpful to store in the skill\n\n**For Claude Code plugins:** When building a hooks skill, the analysis shows:\n1. Developers repeatedly need to validate hooks.json and test hook scripts\n2. `scripts/validate-hook-schema.sh` and `scripts/test-hook.sh` utilities would be helpful\n3. `references/patterns.md` for detailed hook patterns to avoid bloating SKILL.md\n\nTo establish the skill's contents, analyze each concrete example to create a list of the reusable resources to include: scripts, references, and assets.\n\n### Step 3: Create Skill Structure\n\nFor Claude Code plugins, create the skill directory structure:\n\n```bash\nmkdir -p plugin-name/skills/skill-name/{references,examples,scripts}\ntouch plugin-name/skills/skill-name/SKILL.md\n```\n\n**Note:** Unlike the generic skill-creator which uses `init_skill.py`, plugin skills are created directly in the plugin's `skills/` directory with a simpler manual structure.\n\n### Step 4: Edit the Skill\n\nWhen editing the (newly-created or existing) skill, remember that the skill is being created for another instance of Claude to use. Focus on including information that would be beneficial and non-obvious to Claude. Consider what procedural knowledge, domain-specific details, or reusable assets would help another Claude instance execute these tasks more effectively.\n\n#### Start with Reusable Skill Contents\n\nTo begin implementation, start with the reusable resources identified above: `scripts/`, `references/`, and `assets/` files. Note that this step may require user input. For example, when implementing a `brand-guidelines` skill, the user may need to provide brand assets or templates to store in `assets/`, or documentation to store in `references/`.\n\nAlso, delete any example files and directories not needed for the skill. Create only the directories you actually need (references/, examples/, scripts/).\n\n#### Update SKILL.md\n\n**Writing Style:** Write the entire skill using **imperative/infinitive form** (verb-first instructions), not second person. Use objective, instructional language (e.g., \"To accomplish X, do Y\" rather than \"You should do X\" or \"If you need to do X\"). This maintains consistency and clarity for AI consumption.\n\n**Description (Frontmatter):** Use third-person format with specific trigger phrases:\n\n```yaml\n---\nname: Skill Name\ndescription: This skill should be used when the user asks to \"specific phrase 1\", \"specific phrase 2\", \"specific phrase 3\". Include exact phrases users would say that should trigger this skill. Be concrete and specific.\nversion: 0.1.0\n---\n```\n\n**Good description examples:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", \"implement prompt-based hooks\", or mentions hook events (PreToolUse, PostToolUse, Stop).\n```\n\n**Bad description examples:**\n```yaml\ndescription: Use this skill when working with hooks.  # Wrong person, vague\ndescription: Load when user needs hook help.  # Not third person\ndescription: Provides hook guidance.  # No trigger phrases\n```\n\nTo complete SKILL.md body, answer the following questions:\n\n1. What is the purpose of the skill, in a few sentences?\n2. When should the skill be used? (Include this in frontmatter description with specific triggers)\n3. In practice, how should Claude use the skill? All reusable skill contents developed above should be referenced so that Claude knows how to use them.\n\n**Keep SKILL.md lean:** Target 1,500-2,000 words for the body. Move detailed content to references/:\n- Detailed patterns â†’ `references/patterns.md`\n- Advanced techniques â†’ `references/advanced.md`\n- Migration guides â†’ `references/migration.md`\n- API references â†’ `references/api-reference.md`\n\n**Reference resources in SKILL.md:**\n```markdown\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and techniques, consult:\n- **`references/patterns.md`** - Common patterns\n- **`references/advanced.md`** - Advanced use cases\n\n### Example Files\n\nWorking examples in `examples/`:\n- **`example-script.sh`** - Working example\n```\n\n### Step 5: Validate and Test\n\n**For plugin skills, validation is different from generic skills:**\n\n1. **Check structure**: Skill directory in `plugin-name/skills/skill-name/`\n2. **Validate SKILL.md**: Has frontmatter with name and description\n3. **Check trigger phrases**: Description includes specific user queries\n4. **Verify writing style**: Body uses imperative/infinitive form, not second person\n5. **Test progressive disclosure**: SKILL.md is lean (~1,500-2,000 words), detailed content in references/\n6. **Check references**: All referenced files exist\n7. **Validate examples**: Examples are complete and correct\n8. **Test scripts**: Scripts are executable and work correctly\n\n**Use the skill-reviewer agent:**\n```\nAsk: \"Review my skill and check if it follows best practices\"\n```\n\nThe skill-reviewer agent will check description quality, content organization, and progressive disclosure.\n\n### Step 6: Iterate\n\nAfter testing the skill, users may request improvements. Often this happens right after using the skill, with fresh context of how the skill performed.\n\n**Iteration workflow:**\n1. Use the skill on real tasks\n2. Notice struggles or inefficiencies\n3. Identify how SKILL.md or bundled resources should be updated\n4. Implement changes and test again\n\n**Common improvements:**\n- Strengthen trigger phrases in description\n- Move long sections from SKILL.md to references/\n- Add missing examples or scripts\n- Clarify ambiguous instructions\n- Add edge case handling\n\n## Plugin-Specific Considerations\n\n### Skill Location in Plugins\n\nPlugin skills live in the plugin's `skills/` directory:\n\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/\nâ”œâ”€â”€ agents/\nâ””â”€â”€ skills/\n    â””â”€â”€ my-skill/\n        â”œâ”€â”€ SKILL.md\n        â”œâ”€â”€ references/\n        â”œâ”€â”€ examples/\n        â””â”€â”€ scripts/\n```\n\n### Auto-Discovery\n\nClaude Code automatically discovers skills:\n- Scans `skills/` directory\n- Finds subdirectories containing `SKILL.md`\n- Loads skill metadata (name + description) always\n- Loads SKILL.md body when skill triggers\n- Loads references/examples when needed\n\n### No Packaging Needed\n\nPlugin skills are distributed as part of the plugin, not as separate ZIP files. Users get skills when they install the plugin.\n\n### Testing in Plugins\n\nTest skills by installing plugin locally:\n\n```bash\n# Test with --plugin-dir\ncc --plugin-dir /path/to/plugin\n\n# Ask questions that should trigger the skill\n# Verify skill loads correctly\n```\n\n## Examples from Plugin-Dev\n\nStudy the skills in this plugin as examples of best practices:\n\n**hook-development skill:**\n- Excellent trigger phrases: \"create a hook\", \"add a PreToolUse hook\", etc.\n- Lean SKILL.md (1,651 words)\n- 3 references/ files for detailed content\n- 3 examples/ of working hooks\n- 3 scripts/ utilities\n\n**agent-development skill:**\n- Strong triggers: \"create an agent\", \"agent frontmatter\", etc.\n- Focused SKILL.md (1,438 words)\n- References include the AI generation prompt from Claude Code\n- Complete agent examples\n\n**plugin-settings skill:**\n- Specific triggers: \"plugin settings\", \".local.md files\", \"YAML frontmatter\"\n- References show real implementations (multi-agent-swarm, ralph-wiggum)\n- Working parsing scripts\n\nEach demonstrates progressive disclosure and strong triggering.\n\n## Progressive Disclosure in Practice\n\n### What Goes in SKILL.md\n\n**Include (always loaded when skill triggers):**\n- Core concepts and overview\n- Essential procedures and workflows\n- Quick reference tables\n- Pointers to references/examples/scripts\n- Most common use cases\n\n**Keep under 3,000 words, ideally 1,500-2,000 words**\n\n### What Goes in references/\n\n**Move to references/ (loaded as needed):**\n- Detailed patterns and advanced techniques\n- Comprehensive API documentation\n- Migration guides\n- Edge cases and troubleshooting\n- Extensive examples and walkthroughs\n\n**Each reference file can be large (2,000-5,000+ words)**\n\n### What Goes in examples/\n\n**Working code examples:**\n- Complete, runnable scripts\n- Configuration files\n- Template files\n- Real-world usage examples\n\n**Users can copy and adapt these directly**\n\n### What Goes in scripts/\n\n**Utility scripts:**\n- Validation tools\n- Testing helpers\n- Parsing utilities\n- Automation scripts\n\n**Should be executable and documented**\n\n## Writing Style Requirements\n\n### Imperative/Infinitive Form\n\nWrite using verb-first instructions, not second person:\n\n**Correct (imperative):**\n```\nTo create a hook, define the event type.\nConfigure the MCP server with authentication.\nValidate settings before use.\n```\n\n**Incorrect (second person):**\n```\nYou should create a hook by defining the event type.\nYou need to configure the MCP server.\nYou must validate settings before use.\n```\n\n### Third-Person in Description\n\nThe frontmatter description must use third person:\n\n**Correct:**\n```yaml\ndescription: This skill should be used when the user asks to \"create X\", \"configure Y\"...\n```\n\n**Incorrect:**\n```yaml\ndescription: Use this skill when you want to create X...\ndescription: Load this skill when user asks...\n```\n\n### Objective, Instructional Language\n\nFocus on what to do, not who should do it:\n\n**Correct:**\n```\nParse the frontmatter using sed.\nExtract fields with grep.\nValidate values before use.\n```\n\n**Incorrect:**\n```\nYou can parse the frontmatter...\nClaude should extract fields...\nThe user might validate values...\n```\n\n## Validation Checklist\n\nBefore finalizing a skill:\n\n**Structure:**\n- [ ] SKILL.md file exists with valid YAML frontmatter\n- [ ] Frontmatter has `name` and `description` fields\n- [ ] Markdown body is present and substantial\n- [ ] Referenced files actually exist\n\n**Description Quality:**\n- [ ] Uses third person (\"This skill should be used when...\")\n- [ ] Includes specific trigger phrases users would say\n- [ ] Lists concrete scenarios (\"create X\", \"configure Y\")\n- [ ] Not vague or generic\n\n**Content Quality:**\n- [ ] SKILL.md body uses imperative/infinitive form\n- [ ] Body is focused and lean (1,500-2,000 words ideal, <5k max)\n- [ ] Detailed content moved to references/\n- [ ] Examples are complete and working\n- [ ] Scripts are executable and documented\n\n**Progressive Disclosure:**\n- [ ] Core concepts in SKILL.md\n- [ ] Detailed docs in references/\n- [ ] Working code in examples/\n- [ ] Utilities in scripts/\n- [ ] SKILL.md references these resources\n\n**Testing:**\n- [ ] Skill triggers on expected user queries\n- [ ] Content is helpful for intended tasks\n- [ ] No duplicated information across files\n- [ ] References load when needed\n\n## Common Mistakes to Avoid\n\n### Mistake 1: Weak Trigger Description\n\nâŒ **Bad:**\n```yaml\ndescription: Provides guidance for working with hooks.\n```\n\n**Why bad:** Vague, no specific trigger phrases, not third person\n\nâœ… **Good:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", or mentions hook events. Provides comprehensive hooks API guidance.\n```\n\n**Why good:** Third person, specific phrases, concrete scenarios\n\n### Mistake 2: Too Much in SKILL.md\n\nâŒ **Bad:**\n```\nskill-name/\nâ””â”€â”€ SKILL.md  (8,000 words - everything in one file)\n```\n\n**Why bad:** Bloats context when skill loads, detailed content always loaded\n\nâœ… **Good:**\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md  (1,800 words - core essentials)\nâ””â”€â”€ references/\n    â”œâ”€â”€ patterns.md (2,500 words)\n    â””â”€â”€ advanced.md (3,700 words)\n```\n\n**Why good:** Progressive disclosure, detailed content loaded only when needed\n\n### Mistake 3: Second Person Writing\n\nâŒ **Bad:**\n```markdown\nYou should start by reading the configuration file.\nYou need to validate the input.\nYou can use the grep tool to search.\n```\n\n**Why bad:** Second person, not imperative form\n\nâœ… **Good:**\n```markdown\nStart by reading the configuration file.\nValidate the input before processing.\nUse the grep tool to search for patterns.\n```\n\n**Why good:** Imperative form, direct instructions\n\n### Mistake 4: Missing Resource References\n\nâŒ **Bad:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n[No mention of references/ or examples/]\n```\n\n**Why bad:** Claude doesn't know references exist\n\nâœ… **Good:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n## Additional Resources\n\n### Reference Files\n- **`references/patterns.md`** - Detailed patterns\n- **`references/advanced.md`** - Advanced techniques\n\n### Examples\n- **`examples/script.sh`** - Working example\n```\n\n**Why good:** Claude knows where to find additional information\n\n## Quick Reference\n\n### Minimal Skill\n\n```\nskill-name/\nâ””â”€â”€ SKILL.md\n```\n\nGood for: Simple knowledge, no complex resources needed\n\n### Standard Skill (Recommended)\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md\nâ”œâ”€â”€ references/\nâ”‚   â””â”€â”€ detailed-guide.md\nâ””â”€â”€ examples/\n    â””â”€â”€ working-example.sh\n```\n\nGood for: Most plugin skills with detailed documentation\n\n### Complete Skill\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md\nâ”œâ”€â”€ references/\nâ”‚   â”œâ”€â”€ patterns.md\nâ”‚   â””â”€â”€ advanced.md\nâ”œâ”€â”€ examples/\nâ”‚   â”œâ”€â”€ example1.sh\nâ”‚   â””â”€â”€ example2.json\nâ””â”€â”€ scripts/\n    â””â”€â”€ validate.sh\n```\n\nGood for: Complex domains with validation utilities\n\n## Best Practices Summary\n\nâœ… **DO:**\n- Use third-person in description (\"This skill should be used when...\")\n- Include specific trigger phrases (\"create X\", \"configure Y\")\n- Keep SKILL.md lean (1,500-2,000 words)\n- Use progressive disclosure (move details to references/)\n- Write in imperative/infinitive form\n- Reference supporting files clearly\n- Provide working examples\n- Create utility scripts for common operations\n- Study plugin-dev's skills as templates\n\nâŒ **DON'T:**\n- Use second person anywhere\n- Have vague trigger conditions\n- Put everything in SKILL.md (>3,000 words without references/)\n- Write in second person (\"You should...\")\n- Leave resources unreferenced\n- Include broken or incomplete examples\n- Skip validation\n\n## Additional Resources\n\n### Study These Skills\n\nPlugin-dev's skills demonstrate best practices:\n- `../hook-development/` - Progressive disclosure, utilities\n- `../agent-development/` - AI-assisted creation, references\n- `../mcp-integration/` - Comprehensive references\n- `../plugin-settings/` - Real-world examples\n- `../command-development/` - Clear critical concepts\n- `../plugin-structure/` - Good organization\n\n### Reference Files\n\nFor complete skill-creator methodology:\n- **`references/skill-creator-original.md`** - Full original skill-creator content\n\n## Implementation Workflow\n\nTo create a skill for your plugin:\n\n1. **Understand use cases**: Identify concrete examples of skill usage\n2. **Plan resources**: Determine what scripts/references/examples needed\n3. **Create structure**: `mkdir -p skills/skill-name/{references,examples,scripts}`\n4. **Write SKILL.md**:\n   - Frontmatter with third-person description and trigger phrases\n   - Lean body (1,500-2,000 words) in imperative form\n   - Reference supporting files\n5. **Add resources**: Create references/, examples/, scripts/ as needed\n6. **Validate**: Check description, writing style, organization\n7. **Test**: Verify skill loads on expected triggers\n8. **Iterate**: Improve based on usage\n\nFocus on strong trigger descriptions, progressive disclosure, and imperative writing style for effective skills that load when needed and provide targeted guidance."
              }
            ]
          },
          {
            "name": "pr-review-toolkit",
            "description": "Comprehensive PR review agents specializing in comments, tests, error handling, type design, code quality, and code simplification",
            "source": "./plugins/pr-review-toolkit",
            "category": "productivity",
            "version": "1.0.0",
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-code",
              "/plugin install pr-review-toolkit@claude-code-plugins"
            ],
            "signals": {
              "stars": 55716,
              "forks": 4044,
              "pushed_at": "2026-01-12T23:22:53Z",
              "created_at": "2025-02-22T17:41:21Z",
              "license": null
            },
            "commands": [
              {
                "name": "/review-pr",
                "description": "Comprehensive PR review using specialized agents",
                "path": "plugins/pr-review-toolkit/commands/review-pr.md",
                "frontmatter": {
                  "description": "Comprehensive PR review using specialized agents",
                  "argument-hint": "[review-aspects]",
                  "allowed-tools": [
                    "Bash",
                    "Glob",
                    "Grep",
                    "Read",
                    "Task"
                  ]
                },
                "content": "# Comprehensive PR Review\n\nRun a comprehensive pull request review using multiple specialized agents, each focusing on a different aspect of code quality.\n\n**Review Aspects (optional):** \"$ARGUMENTS\"\n\n## Review Workflow:\n\n1. **Determine Review Scope**\n   - Check git status to identify changed files\n   - Parse arguments to see if user requested specific review aspects\n   - Default: Run all applicable reviews\n\n2. **Available Review Aspects:**\n\n   - **comments** - Analyze code comment accuracy and maintainability\n   - **tests** - Review test coverage quality and completeness\n   - **errors** - Check error handling for silent failures\n   - **types** - Analyze type design and invariants (if new types added)\n   - **code** - General code review for project guidelines\n   - **simplify** - Simplify code for clarity and maintainability\n   - **all** - Run all applicable reviews (default)\n\n3. **Identify Changed Files**\n   - Run `git diff --name-only` to see modified files\n   - Check if PR already exists: `gh pr view`\n   - Identify file types and what reviews apply\n\n4. **Determine Applicable Reviews**\n\n   Based on changes:\n   - **Always applicable**: code-reviewer (general quality)\n   - **If test files changed**: pr-test-analyzer\n   - **If comments/docs added**: comment-analyzer\n   - **If error handling changed**: silent-failure-hunter\n   - **If types added/modified**: type-design-analyzer\n   - **After passing review**: code-simplifier (polish and refine)\n\n5. **Launch Review Agents**\n\n   **Sequential approach** (one at a time):\n   - Easier to understand and act on\n   - Each report is complete before next\n   - Good for interactive review\n\n   **Parallel approach** (user can request):\n   - Launch all agents simultaneously\n   - Faster for comprehensive review\n   - Results come back together\n\n6. **Aggregate Results**\n\n   After agents complete, summarize:\n   - **Critical Issues** (must fix before merge)\n   - **Important Issues** (should fix)\n   - **Suggestions** (nice to have)\n   - **Positive Observations** (what's good)\n\n7. **Provide Action Plan**\n\n   Organize findings:\n   ```markdown\n   # PR Review Summary\n\n   ## Critical Issues (X found)\n   - [agent-name]: Issue description [file:line]\n\n   ## Important Issues (X found)\n   - [agent-name]: Issue description [file:line]\n\n   ## Suggestions (X found)\n   - [agent-name]: Suggestion [file:line]\n\n   ## Strengths\n   - What's well-done in this PR\n\n   ## Recommended Action\n   1. Fix critical issues first\n   2. Address important issues\n   3. Consider suggestions\n   4. Re-run review after fixes\n   ```\n\n## Usage Examples:\n\n**Full review (default):**\n```\n/pr-review-toolkit:review-pr\n```\n\n**Specific aspects:**\n```\n/pr-review-toolkit:review-pr tests errors\n# Reviews only test coverage and error handling\n\n/pr-review-toolkit:review-pr comments\n# Reviews only code comments\n\n/pr-review-toolkit:review-pr simplify\n# Simplifies code after passing review\n```\n\n**Parallel review:**\n```\n/pr-review-toolkit:review-pr all parallel\n# Launches all agents in parallel\n```\n\n## Agent Descriptions:\n\n**comment-analyzer**:\n- Verifies comment accuracy vs code\n- Identifies comment rot\n- Checks documentation completeness\n\n**pr-test-analyzer**:\n- Reviews behavioral test coverage\n- Identifies critical gaps\n- Evaluates test quality\n\n**silent-failure-hunter**:\n- Finds silent failures\n- Reviews catch blocks\n- Checks error logging\n\n**type-design-analyzer**:\n- Analyzes type encapsulation\n- Reviews invariant expression\n- Rates type design quality\n\n**code-reviewer**:\n- Checks CLAUDE.md compliance\n- Detects bugs and issues\n- Reviews general code quality\n\n**code-simplifier**:\n- Simplifies complex code\n- Improves clarity and readability\n- Applies project standards\n- Preserves functionality\n\n## Tips:\n\n- **Run early**: Before creating PR, not after\n- **Focus on changes**: Agents analyze git diff by default\n- **Address critical first**: Fix high-priority issues before lower priority\n- **Re-run after fixes**: Verify issues are resolved\n- **Use specific reviews**: Target specific aspects when you know the concern\n\n## Workflow Integration:\n\n**Before committing:**\n```\n1. Write code\n2. Run: /pr-review-toolkit:review-pr code errors\n3. Fix any critical issues\n4. Commit\n```\n\n**Before creating PR:**\n```\n1. Stage all changes\n2. Run: /pr-review-toolkit:review-pr all\n3. Address all critical and important issues\n4. Run specific reviews again to verify\n5. Create PR\n```\n\n**After PR feedback:**\n```\n1. Make requested changes\n2. Run targeted reviews based on feedback\n3. Verify issues are resolved\n4. Push updates\n```\n\n## Notes:\n\n- Agents run autonomously and return detailed reports\n- Each agent focuses on its specialty for deep analysis\n- Results are actionable with specific file:line references\n- Agents use appropriate models for their complexity\n- All agents available in `/agents` list"
              }
            ],
            "skills": []
          },
          {
            "name": "ralph-wiggum",
            "description": "Interactive self-referential AI loops for iterative development. Claude works on the same task repeatedly, seeing its previous work, until completion.",
            "source": "./plugins/ralph-wiggum",
            "category": "development",
            "version": "1.0.0",
            "author": {
              "name": "Daisy Hollman",
              "email": "daisy@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-code",
              "/plugin install ralph-wiggum@claude-code-plugins"
            ],
            "signals": {
              "stars": 55716,
              "forks": 4044,
              "pushed_at": "2026-01-12T23:22:53Z",
              "created_at": "2025-02-22T17:41:21Z",
              "license": null
            },
            "commands": [
              {
                "name": "/cancel-ralph",
                "description": "Cancel active Ralph Wiggum loop",
                "path": "plugins/ralph-wiggum/commands/cancel-ralph.md",
                "frontmatter": {
                  "description": "Cancel active Ralph Wiggum loop",
                  "allowed-tools": [
                    "Bash(test -f .claude/ralph-loop.local.md:*)",
                    "Bash(rm .claude/ralph-loop.local.md)",
                    "Read(.claude/ralph-loop.local.md)"
                  ],
                  "hide-from-slash-command-tool": "true"
                },
                "content": "# Cancel Ralph\n\nTo cancel the Ralph loop:\n\n1. Check if `.claude/ralph-loop.local.md` exists using Bash: `test -f .claude/ralph-loop.local.md && echo \"EXISTS\" || echo \"NOT_FOUND\"`\n\n2. **If NOT_FOUND**: Say \"No active Ralph loop found.\"\n\n3. **If EXISTS**:\n   - Read `.claude/ralph-loop.local.md` to get the current iteration number from the `iteration:` field\n   - Remove the file using Bash: `rm .claude/ralph-loop.local.md`\n   - Report: \"Cancelled Ralph loop (was at iteration N)\" where N is the iteration value"
              },
              {
                "name": "/help",
                "description": "Explain Ralph Wiggum technique and available commands",
                "path": "plugins/ralph-wiggum/commands/help.md",
                "frontmatter": {
                  "description": "Explain Ralph Wiggum technique and available commands"
                },
                "content": "# Ralph Wiggum Plugin Help\n\nPlease explain the following to the user:\n\n## What is the Ralph Wiggum Technique?\n\nThe Ralph Wiggum technique is an iterative development methodology based on continuous AI loops, pioneered by Geoffrey Huntley.\n\n**Core concept:**\n```bash\nwhile :; do\n  cat PROMPT.md | claude-code --continue\ndone\n```\n\nThe same prompt is fed to Claude repeatedly. The \"self-referential\" aspect comes from Claude seeing its own previous work in the files and git history, not from feeding output back as input.\n\n**Each iteration:**\n1. Claude receives the SAME prompt\n2. Works on the task, modifying files\n3. Tries to exit\n4. Stop hook intercepts and feeds the same prompt again\n5. Claude sees its previous work in the files\n6. Iteratively improves until completion\n\nThe technique is described as \"deterministically bad in an undeterministic world\" - failures are predictable, enabling systematic improvement through prompt tuning.\n\n## Available Commands\n\n### /ralph-loop <PROMPT> [OPTIONS]\n\nStart a Ralph loop in your current session.\n\n**Usage:**\n```\n/ralph-loop \"Refactor the cache layer\" --max-iterations 20\n/ralph-loop \"Add tests\" --completion-promise \"TESTS COMPLETE\"\n```\n\n**Options:**\n- `--max-iterations <n>` - Max iterations before auto-stop\n- `--completion-promise <text>` - Promise phrase to signal completion\n\n**How it works:**\n1. Creates `.claude/.ralph-loop.local.md` state file\n2. You work on the task\n3. When you try to exit, stop hook intercepts\n4. Same prompt fed back\n5. You see your previous work\n6. Continues until promise detected or max iterations\n\n---\n\n### /cancel-ralph\n\nCancel an active Ralph loop (removes the loop state file).\n\n**Usage:**\n```\n/cancel-ralph\n```\n\n**How it works:**\n- Checks for active loop state file\n- Removes `.claude/.ralph-loop.local.md`\n- Reports cancellation with iteration count\n\n---\n\n## Key Concepts\n\n### Completion Promises\n\nTo signal completion, Claude must output a `<promise>` tag:\n\n```\n<promise>TASK COMPLETE</promise>\n```\n\nThe stop hook looks for this specific tag. Without it (or `--max-iterations`), Ralph runs infinitely.\n\n### Self-Reference Mechanism\n\nThe \"loop\" doesn't mean Claude talks to itself. It means:\n- Same prompt repeated\n- Claude's work persists in files\n- Each iteration sees previous attempts\n- Builds incrementally toward goal\n\n## Example\n\n### Interactive Bug Fix\n\n```\n/ralph-loop \"Fix the token refresh logic in auth.ts. Output <promise>FIXED</promise> when all tests pass.\" --completion-promise \"FIXED\" --max-iterations 10\n```\n\nYou'll see Ralph:\n- Attempt fixes\n- Run tests\n- See failures\n- Iterate on solution\n- In your current session\n\n## When to Use Ralph\n\n**Good for:**\n- Well-defined tasks with clear success criteria\n- Tasks requiring iteration and refinement\n- Iterative development with self-correction\n- Greenfield projects\n\n**Not good for:**\n- Tasks requiring human judgment or design decisions\n- One-shot operations\n- Tasks with unclear success criteria\n- Debugging production issues (use targeted debugging instead)\n\n## Learn More\n\n- Original technique: https://ghuntley.com/ralph/\n- Ralph Orchestrator: https://github.com/mikeyobrien/ralph-orchestrator"
              },
              {
                "name": "/ralph-loop",
                "description": "Start Ralph Wiggum loop in current session",
                "path": "plugins/ralph-wiggum/commands/ralph-loop.md",
                "frontmatter": {
                  "description": "Start Ralph Wiggum loop in current session",
                  "argument-hint": "PROMPT [--max-iterations N] [--completion-promise TEXT]",
                  "allowed-tools": [
                    "Bash(${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh:*)"
                  ],
                  "hide-from-slash-command-tool": "true"
                },
                "content": "# Ralph Loop Command\n\nExecute the setup script to initialize the Ralph loop:\n\n```!\n\"${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh\" $ARGUMENTS\n```\n\nPlease work on the task. When you try to exit, the Ralph loop will feed the SAME PROMPT back to you for the next iteration. You'll see your previous work in files and git history, allowing you to iterate and improve.\n\nCRITICAL RULE: If a completion promise is set, you may ONLY output it when the statement is completely and unequivocally TRUE. Do not output false promises to escape the loop, even if you think you're stuck or should exit for other reasons. The loop is designed to continue until genuine completion."
              }
            ],
            "skills": []
          },
          {
            "name": "security-guidance",
            "description": "Security reminder hook that warns about potential security issues when editing files, including command injection, XSS, and unsafe code patterns",
            "source": "./plugins/security-guidance",
            "category": "security",
            "version": "1.0.0",
            "author": {
              "name": "David Dworken",
              "email": "dworken@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-code",
              "/plugin install security-guidance@claude-code-plugins"
            ],
            "signals": {
              "stars": 55716,
              "forks": 4044,
              "pushed_at": "2026-01-12T23:22:53Z",
              "created_at": "2025-02-22T17:41:21Z",
              "license": null
            },
            "commands": [],
            "skills": []
          }
        ]
      }
    },
    {
      "full_name": "anthropics/skills",
      "url": "https://github.com/anthropics/skills",
      "description": "Public repository for Agent Skills",
      "homepage": "",
      "signals": {
        "stars": 38467,
        "forks": 3501,
        "pushed_at": "2025-12-20T18:09:45Z",
        "created_at": "2025-09-22T15:53:31Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1358
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 40
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 5460
        },
        {
          "path": "THIRD_PARTY_NOTICES.md",
          "type": "blob",
          "size": 46162
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/algorithmic-art",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/algorithmic-art/LICENSE.txt",
          "type": "blob",
          "size": 11357
        },
        {
          "path": "skills/algorithmic-art/SKILL.md",
          "type": "blob",
          "size": 19769
        },
        {
          "path": "skills/algorithmic-art/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/algorithmic-art/templates/generator_template.js",
          "type": "blob",
          "size": 7826
        },
        {
          "path": "skills/algorithmic-art/templates/viewer.html",
          "type": "blob",
          "size": 20844
        },
        {
          "path": "skills/brand-guidelines",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/brand-guidelines/LICENSE.txt",
          "type": "blob",
          "size": 11357
        },
        {
          "path": "skills/brand-guidelines/SKILL.md",
          "type": "blob",
          "size": 2235
        },
        {
          "path": "skills/canvas-design",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/canvas-design/LICENSE.txt",
          "type": "blob",
          "size": 11357
        },
        {
          "path": "skills/canvas-design/SKILL.md",
          "type": "blob",
          "size": 11939
        },
        {
          "path": "skills/canvas-design/canvas-fonts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/canvas-design/canvas-fonts/ArsenalSC-OFL.txt",
          "type": "blob",
          "size": 4373
        },
        {
          "path": "skills/canvas-design/canvas-fonts/ArsenalSC-Regular.ttf",
          "type": "blob",
          "size": 165848
        },
        {
          "path": "skills/canvas-design/canvas-fonts/BigShoulders-Bold.ttf",
          "type": "blob",
          "size": 94528
        },
        {
          "path": "skills/canvas-design/canvas-fonts/BigShoulders-OFL.txt",
          "type": "blob",
          "size": 4397
        },
        {
          "path": "skills/canvas-design/canvas-fonts/BigShoulders-Regular.ttf",
          "type": "blob",
          "size": 94396
        },
        {
          "path": "skills/canvas-design/canvas-fonts/Boldonse-OFL.txt",
          "type": "blob",
          "size": 4390
        },
        {
          "path": "skills/canvas-design/canvas-fonts/Boldonse-Regular.ttf",
          "type": "blob",
          "size": 77168
        },
        {
          "path": "skills/canvas-design/canvas-fonts/BricolageGrotesque-Bold.ttf",
          "type": "blob",
          "size": 90952
        },
        {
          "path": "skills/canvas-design/canvas-fonts/BricolageGrotesque-OFL.txt",
          "type": "blob",
          "size": 4403
        },
        {
          "path": "skills/canvas-design/canvas-fonts/BricolageGrotesque-Regular.ttf",
          "type": "blob",
          "size": 90920
        },
        {
          "path": "skills/canvas-design/canvas-fonts/CrimsonPro-Bold.ttf",
          "type": "blob",
          "size": 107352
        },
        {
          "path": "skills/canvas-design/canvas-fonts/CrimsonPro-Italic.ttf",
          "type": "blob",
          "size": 108828
        },
        {
          "path": "skills/canvas-design/canvas-fonts/CrimsonPro-OFL.txt",
          "type": "blob",
          "size": 4394
        },
        {
          "path": "skills/canvas-design/canvas-fonts/CrimsonPro-Regular.ttf",
          "type": "blob",
          "size": 106696
        },
        {
          "path": "skills/canvas-design/canvas-fonts/DMMono-OFL.txt",
          "type": "blob",
          "size": 4392
        },
        {
          "path": "skills/canvas-design/canvas-fonts/DMMono-Regular.ttf",
          "type": "blob",
          "size": 48852
        },
        {
          "path": "skills/canvas-design/canvas-fonts/EricaOne-OFL.txt",
          "type": "blob",
          "size": 4410
        },
        {
          "path": "skills/canvas-design/canvas-fonts/EricaOne-Regular.ttf",
          "type": "blob",
          "size": 24872
        },
        {
          "path": "skills/canvas-design/canvas-fonts/GeistMono-Bold.ttf",
          "type": "blob",
          "size": 78304
        },
        {
          "path": "skills/canvas-design/canvas-fonts/GeistMono-OFL.txt",
          "type": "blob",
          "size": 4388
        },
        {
          "path": "skills/canvas-design/canvas-fonts/GeistMono-Regular.ttf",
          "type": "blob",
          "size": 78232
        },
        {
          "path": "skills/canvas-design/canvas-fonts/Gloock-OFL.txt",
          "type": "blob",
          "size": 4381
        },
        {
          "path": "skills/canvas-design/canvas-fonts/Gloock-Regular.ttf",
          "type": "blob",
          "size": 95156
        },
        {
          "path": "skills/canvas-design/canvas-fonts/IBMPlexMono-Bold.ttf",
          "type": "blob",
          "size": 136008
        },
        {
          "path": "skills/canvas-design/canvas-fonts/IBMPlexMono-OFL.txt",
          "type": "blob",
          "size": 4363
        },
        {
          "path": "skills/canvas-design/canvas-fonts/IBMPlexMono-Regular.ttf",
          "type": "blob",
          "size": 133796
        },
        {
          "path": "skills/canvas-design/canvas-fonts/IBMPlexSerif-Bold.ttf",
          "type": "blob",
          "size": 161000
        },
        {
          "path": "skills/canvas-design/canvas-fonts/IBMPlexSerif-BoldItalic.ttf",
          "type": "blob",
          "size": 169840
        },
        {
          "path": "skills/canvas-design/canvas-fonts/IBMPlexSerif-Italic.ttf",
          "type": "blob",
          "size": 170004
        },
        {
          "path": "skills/canvas-design/canvas-fonts/IBMPlexSerif-Regular.ttf",
          "type": "blob",
          "size": 160380
        },
        {
          "path": "skills/canvas-design/canvas-fonts/InstrumentSans-Bold.ttf",
          "type": "blob",
          "size": 68084
        },
        {
          "path": "skills/canvas-design/canvas-fonts/InstrumentSans-BoldItalic.ttf",
          "type": "blob",
          "size": 70004
        },
        {
          "path": "skills/canvas-design/canvas-fonts/InstrumentSans-Italic.ttf",
          "type": "blob",
          "size": 69900
        },
        {
          "path": "skills/canvas-design/canvas-fonts/InstrumentSans-OFL.txt",
          "type": "blob",
          "size": 4403
        },
        {
          "path": "skills/canvas-design/canvas-fonts/InstrumentSans-Regular.ttf",
          "type": "blob",
          "size": 68028
        },
        {
          "path": "skills/canvas-design/canvas-fonts/InstrumentSerif-Italic.ttf",
          "type": "blob",
          "size": 70868
        },
        {
          "path": "skills/canvas-design/canvas-fonts/InstrumentSerif-Regular.ttf",
          "type": "blob",
          "size": 69312
        },
        {
          "path": "skills/canvas-design/canvas-fonts/Italiana-OFL.txt",
          "type": "blob",
          "size": 4394
        },
        {
          "path": "skills/canvas-design/canvas-fonts/Italiana-Regular.ttf",
          "type": "blob",
          "size": 27184
        },
        {
          "path": "skills/canvas-design/canvas-fonts/JetBrainsMono-Bold.ttf",
          "type": "blob",
          "size": 114828
        },
        {
          "path": "skills/canvas-design/canvas-fonts/JetBrainsMono-OFL.txt",
          "type": "blob",
          "size": 4399
        },
        {
          "path": "skills/canvas-design/canvas-fonts/JetBrainsMono-Regular.ttf",
          "type": "blob",
          "size": 114904
        },
        {
          "path": "skills/canvas-design/canvas-fonts/Jura-Light.ttf",
          "type": "blob",
          "size": 154308
        },
        {
          "path": "skills/canvas-design/canvas-fonts/Jura-Medium.ttf",
          "type": "blob",
          "size": 154488
        },
        {
          "path": "skills/canvas-design/canvas-fonts/Jura-OFL.txt",
          "type": "blob",
          "size": 4380
        },
        {
          "path": "skills/canvas-design/canvas-fonts/LibreBaskerville-OFL.txt",
          "type": "blob",
          "size": 4449
        },
        {
          "path": "skills/canvas-design/canvas-fonts/LibreBaskerville-Regular.ttf",
          "type": "blob",
          "size": 147584
        },
        {
          "path": "skills/canvas-design/canvas-fonts/Lora-Bold.ttf",
          "type": "blob",
          "size": 133828
        },
        {
          "path": "skills/canvas-design/canvas-fonts/Lora-BoldItalic.ttf",
          "type": "blob",
          "size": 140332
        },
        {
          "path": "skills/canvas-design/canvas-fonts/Lora-Italic.ttf",
          "type": "blob",
          "size": 139328
        },
        {
          "path": "skills/canvas-design/canvas-fonts/Lora-OFL.txt",
          "type": "blob",
          "size": 4423
        },
        {
          "path": "skills/canvas-design/canvas-fonts/Lora-Regular.ttf",
          "type": "blob",
          "size": 133888
        },
        {
          "path": "skills/canvas-design/canvas-fonts/NationalPark-Bold.ttf",
          "type": "blob",
          "size": 79208
        },
        {
          "path": "skills/canvas-design/canvas-fonts/NationalPark-OFL.txt",
          "type": "blob",
          "size": 4399
        },
        {
          "path": "skills/canvas-design/canvas-fonts/NationalPark-Regular.ttf",
          "type": "blob",
          "size": 76424
        },
        {
          "path": "skills/canvas-design/canvas-fonts/NothingYouCouldDo-OFL.txt",
          "type": "blob",
          "size": 4363
        },
        {
          "path": "skills/canvas-design/canvas-fonts/NothingYouCouldDo-Regular.ttf",
          "type": "blob",
          "size": 32020
        },
        {
          "path": "skills/canvas-design/canvas-fonts/Outfit-Bold.ttf",
          "type": "blob",
          "size": 55392
        },
        {
          "path": "skills/canvas-design/canvas-fonts/Outfit-OFL.txt",
          "type": "blob",
          "size": 4389
        },
        {
          "path": "skills/canvas-design/canvas-fonts/Outfit-Regular.ttf",
          "type": "blob",
          "size": 54912
        },
        {
          "path": "skills/canvas-design/canvas-fonts/PixelifySans-Medium.ttf",
          "type": "blob",
          "size": 51072
        },
        {
          "path": "skills/canvas-design/canvas-fonts/PixelifySans-OFL.txt",
          "type": "blob",
          "size": 4395
        },
        {
          "path": "skills/canvas-design/canvas-fonts/PoiretOne-OFL.txt",
          "type": "blob",
          "size": 4366
        },
        {
          "path": "skills/canvas-design/canvas-fonts/PoiretOne-Regular.ttf",
          "type": "blob",
          "size": 45244
        },
        {
          "path": "skills/canvas-design/canvas-fonts/RedHatMono-Bold.ttf",
          "type": "blob",
          "size": 34420
        },
        {
          "path": "skills/canvas-design/canvas-fonts/RedHatMono-OFL.txt",
          "type": "blob",
          "size": 4394
        },
        {
          "path": "skills/canvas-design/canvas-fonts/RedHatMono-Regular.ttf",
          "type": "blob",
          "size": 34488
        },
        {
          "path": "skills/canvas-design/canvas-fonts/Silkscreen-OFL.txt",
          "type": "blob",
          "size": 4394
        },
        {
          "path": "skills/canvas-design/canvas-fonts/Silkscreen-Regular.ttf",
          "type": "blob",
          "size": 31960
        },
        {
          "path": "skills/canvas-design/canvas-fonts/SmoochSans-Medium.ttf",
          "type": "blob",
          "size": 59704
        },
        {
          "path": "skills/canvas-design/canvas-fonts/SmoochSans-OFL.txt",
          "type": "blob",
          "size": 4396
        },
        {
          "path": "skills/canvas-design/canvas-fonts/Tektur-Medium.ttf",
          "type": "blob",
          "size": 76248
        },
        {
          "path": "skills/canvas-design/canvas-fonts/Tektur-OFL.txt",
          "type": "blob",
          "size": 4385
        },
        {
          "path": "skills/canvas-design/canvas-fonts/Tektur-Regular.ttf",
          "type": "blob",
          "size": 75604
        },
        {
          "path": "skills/canvas-design/canvas-fonts/WorkSans-Bold.ttf",
          "type": "blob",
          "size": 191304
        },
        {
          "path": "skills/canvas-design/canvas-fonts/WorkSans-BoldItalic.ttf",
          "type": "blob",
          "size": 175772
        },
        {
          "path": "skills/canvas-design/canvas-fonts/WorkSans-Italic.ttf",
          "type": "blob",
          "size": 174280
        },
        {
          "path": "skills/canvas-design/canvas-fonts/WorkSans-OFL.txt",
          "type": "blob",
          "size": 4397
        },
        {
          "path": "skills/canvas-design/canvas-fonts/WorkSans-Regular.ttf",
          "type": "blob",
          "size": 188916
        },
        {
          "path": "skills/canvas-design/canvas-fonts/YoungSerif-OFL.txt",
          "type": "blob",
          "size": 4398
        },
        {
          "path": "skills/canvas-design/canvas-fonts/YoungSerif-Regular.ttf",
          "type": "blob",
          "size": 105136
        },
        {
          "path": "skills/doc-coauthoring",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/doc-coauthoring/SKILL.md",
          "type": "blob",
          "size": 15815
        },
        {
          "path": "skills/docx",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/docx/LICENSE.txt",
          "type": "blob",
          "size": 1467
        },
        {
          "path": "skills/docx/SKILL.md",
          "type": "blob",
          "size": 10150
        },
        {
          "path": "skills/docx/docx-js.md",
          "type": "blob",
          "size": 16509
        },
        {
          "path": "skills/docx/ooxml.md",
          "type": "blob",
          "size": 23572
        },
        {
          "path": "skills/docx/ooxml",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/docx/ooxml/schemas",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/dml-chart.xsd",
          "type": "blob",
          "size": 74984
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/dml-chartDrawing.xsd",
          "type": "blob",
          "size": 6956
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/dml-diagram.xsd",
          "type": "blob",
          "size": 51302
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/dml-lockedCanvas.xsd",
          "type": "blob",
          "size": 624
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/dml-main.xsd",
          "type": "blob",
          "size": 152039
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/dml-picture.xsd",
          "type": "blob",
          "size": 1231
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/dml-spreadsheetDrawing.xsd",
          "type": "blob",
          "size": 8862
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/dml-wordprocessingDrawing.xsd",
          "type": "blob",
          "size": 14795
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/pml.xsd",
          "type": "blob",
          "size": 83612
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/shared-additionalCharacteristics.xsd",
          "type": "blob",
          "size": 1269
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/shared-bibliography.xsd",
          "type": "blob",
          "size": 7328
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/shared-commonSimpleTypes.xsd",
          "type": "blob",
          "size": 6382
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/shared-customXmlDataProperties.xsd",
          "type": "blob",
          "size": 1248
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/shared-customXmlSchemaProperties.xsd",
          "type": "blob",
          "size": 880
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/shared-documentPropertiesCustom.xsd",
          "type": "blob",
          "size": 2608
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/shared-documentPropertiesExtended.xsd",
          "type": "blob",
          "size": 3507
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/shared-documentPropertiesVariantTypes.xsd",
          "type": "blob",
          "size": 7507
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/shared-math.xsd",
          "type": "blob",
          "size": 23313
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/shared-relationshipReference.xsd",
          "type": "blob",
          "size": 1367
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/sml.xsd",
          "type": "blob",
          "size": 242277
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/vml-main.xsd",
          "type": "blob",
          "size": 26148
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/vml-officeDrawing.xsd",
          "type": "blob",
          "size": 25279
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/vml-presentationDrawing.xsd",
          "type": "blob",
          "size": 535
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/vml-spreadsheetDrawing.xsd",
          "type": "blob",
          "size": 5712
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/vml-wordprocessingDrawing.xsd",
          "type": "blob",
          "size": 4010
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/wml.xsd",
          "type": "blob",
          "size": 171367
        },
        {
          "path": "skills/docx/ooxml/schemas/ISO-IEC29500-4_2016/xml.xsd",
          "type": "blob",
          "size": 4646
        },
        {
          "path": "skills/docx/ooxml/schemas/ecma",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/docx/ooxml/schemas/ecma/fouth-edition",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/docx/ooxml/schemas/ecma/fouth-edition/opc-contentTypes.xsd",
          "type": "blob",
          "size": 1963
        },
        {
          "path": "skills/docx/ooxml/schemas/ecma/fouth-edition/opc-coreProperties.xsd",
          "type": "blob",
          "size": 2515
        },
        {
          "path": "skills/docx/ooxml/schemas/ecma/fouth-edition/opc-digSig.xsd",
          "type": "blob",
          "size": 2856
        },
        {
          "path": "skills/docx/ooxml/schemas/ecma/fouth-edition/opc-relationships.xsd",
          "type": "blob",
          "size": 1344
        },
        {
          "path": "skills/docx/ooxml/schemas/mce",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/docx/ooxml/schemas/mce/mc.xsd",
          "type": "blob",
          "size": 3127
        },
        {
          "path": "skills/docx/ooxml/schemas/microsoft",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/docx/ooxml/schemas/microsoft/wml-2010.xsd",
          "type": "blob",
          "size": 26549
        },
        {
          "path": "skills/docx/ooxml/schemas/microsoft/wml-2012.xsd",
          "type": "blob",
          "size": 3745
        },
        {
          "path": "skills/docx/ooxml/schemas/microsoft/wml-2018.xsd",
          "type": "blob",
          "size": 901
        },
        {
          "path": "skills/docx/ooxml/schemas/microsoft/wml-cex-2018.xsd",
          "type": "blob",
          "size": 1778
        },
        {
          "path": "skills/docx/ooxml/schemas/microsoft/wml-cid-2016.xsd",
          "type": "blob",
          "size": 1002
        },
        {
          "path": "skills/docx/ooxml/schemas/microsoft/wml-sdtdatahash-2020.xsd",
          "type": "blob",
          "size": 600
        },
        {
          "path": "skills/docx/ooxml/schemas/microsoft/wml-symex-2015.xsd",
          "type": "blob",
          "size": 745
        },
        {
          "path": "skills/docx/ooxml/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/docx/ooxml/scripts/pack.py",
          "type": "blob",
          "size": 5596
        },
        {
          "path": "skills/docx/ooxml/scripts/unpack.py",
          "type": "blob",
          "size": 1037
        },
        {
          "path": "skills/docx/ooxml/scripts/validate.py",
          "type": "blob",
          "size": 1959
        },
        {
          "path": "skills/docx/ooxml/scripts/validation",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/docx/ooxml/scripts/validation/__init__.py",
          "type": "blob",
          "size": 336
        },
        {
          "path": "skills/docx/ooxml/scripts/validation/base.py",
          "type": "blob",
          "size": 39892
        },
        {
          "path": "skills/docx/ooxml/scripts/validation/docx.py",
          "type": "blob",
          "size": 9996
        },
        {
          "path": "skills/docx/ooxml/scripts/validation/pptx.py",
          "type": "blob",
          "size": 12327
        },
        {
          "path": "skills/docx/ooxml/scripts/validation/redlining.py",
          "type": "blob",
          "size": 11179
        },
        {
          "path": "skills/docx/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/docx/scripts/__init__.py",
          "type": "blob",
          "size": 65
        },
        {
          "path": "skills/docx/scripts/document.py",
          "type": "blob",
          "size": 50409
        },
        {
          "path": "skills/docx/scripts/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/docx/scripts/templates/comments.xml",
          "type": "blob",
          "size": 2635
        },
        {
          "path": "skills/docx/scripts/templates/commentsExtended.xml",
          "type": "blob",
          "size": 2643
        },
        {
          "path": "skills/docx/scripts/templates/commentsExtensible.xml",
          "type": "blob",
          "size": 2739
        },
        {
          "path": "skills/docx/scripts/templates/commentsIds.xml",
          "type": "blob",
          "size": 2651
        },
        {
          "path": "skills/docx/scripts/templates/people.xml",
          "type": "blob",
          "size": 147
        },
        {
          "path": "skills/docx/scripts/utilities.py",
          "type": "blob",
          "size": 13694
        },
        {
          "path": "skills/frontend-design",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/frontend-design/LICENSE.txt",
          "type": "blob",
          "size": 10174
        },
        {
          "path": "skills/frontend-design/SKILL.md",
          "type": "blob",
          "size": 4440
        },
        {
          "path": "skills/internal-comms",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/internal-comms/LICENSE.txt",
          "type": "blob",
          "size": 11357
        },
        {
          "path": "skills/internal-comms/SKILL.md",
          "type": "blob",
          "size": 1511
        },
        {
          "path": "skills/internal-comms/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/internal-comms/examples/3p-updates.md",
          "type": "blob",
          "size": 3274
        },
        {
          "path": "skills/internal-comms/examples/company-newsletter.md",
          "type": "blob",
          "size": 3295
        },
        {
          "path": "skills/internal-comms/examples/faq-answers.md",
          "type": "blob",
          "size": 2366
        },
        {
          "path": "skills/internal-comms/examples/general-comms.md",
          "type": "blob",
          "size": 602
        },
        {
          "path": "skills/mcp-builder",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/mcp-builder/LICENSE.txt",
          "type": "blob",
          "size": 11357
        },
        {
          "path": "skills/mcp-builder/SKILL.md",
          "type": "blob",
          "size": 9092
        },
        {
          "path": "skills/mcp-builder/reference",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/mcp-builder/reference/evaluation.md",
          "type": "blob",
          "size": 21663
        },
        {
          "path": "skills/mcp-builder/reference/mcp_best_practices.md",
          "type": "blob",
          "size": 7330
        },
        {
          "path": "skills/mcp-builder/reference/node_mcp_server.md",
          "type": "blob",
          "size": 28550
        },
        {
          "path": "skills/mcp-builder/reference/python_mcp_server.md",
          "type": "blob",
          "size": 25099
        },
        {
          "path": "skills/mcp-builder/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/mcp-builder/scripts/connections.py",
          "type": "blob",
          "size": 4875
        },
        {
          "path": "skills/mcp-builder/scripts/evaluation.py",
          "type": "blob",
          "size": 12579
        },
        {
          "path": "skills/mcp-builder/scripts/example_evaluation.xml",
          "type": "blob",
          "size": 1194
        },
        {
          "path": "skills/mcp-builder/scripts/requirements.txt",
          "type": "blob",
          "size": 29
        },
        {
          "path": "skills/pdf",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/pdf/LICENSE.txt",
          "type": "blob",
          "size": 1467
        },
        {
          "path": "skills/pdf/SKILL.md",
          "type": "blob",
          "size": 7068
        },
        {
          "path": "skills/pdf/forms.md",
          "type": "blob",
          "size": 9438
        },
        {
          "path": "skills/pdf/reference.md",
          "type": "blob",
          "size": 16692
        },
        {
          "path": "skills/pdf/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/pdf/scripts/check_bounding_boxes.py",
          "type": "blob",
          "size": 3139
        },
        {
          "path": "skills/pdf/scripts/check_bounding_boxes_test.py",
          "type": "blob",
          "size": 8818
        },
        {
          "path": "skills/pdf/scripts/check_fillable_fields.py",
          "type": "blob",
          "size": 362
        },
        {
          "path": "skills/pdf/scripts/convert_pdf_to_images.py",
          "type": "blob",
          "size": 1123
        },
        {
          "path": "skills/pdf/scripts/create_validation_image.py",
          "type": "blob",
          "size": 1603
        },
        {
          "path": "skills/pdf/scripts/extract_form_field_info.py",
          "type": "blob",
          "size": 6127
        },
        {
          "path": "skills/pdf/scripts/fill_fillable_fields.py",
          "type": "blob",
          "size": 4863
        },
        {
          "path": "skills/pdf/scripts/fill_pdf_form_with_annotations.py",
          "type": "blob",
          "size": 3596
        },
        {
          "path": "skills/pptx",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/pptx/LICENSE.txt",
          "type": "blob",
          "size": 1467
        },
        {
          "path": "skills/pptx/SKILL.md",
          "type": "blob",
          "size": 25551
        },
        {
          "path": "skills/pptx/html2pptx.md",
          "type": "blob",
          "size": 19859
        },
        {
          "path": "skills/pptx/ooxml.md",
          "type": "blob",
          "size": 10388
        },
        {
          "path": "skills/pptx/ooxml",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/pptx/ooxml/schemas",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/dml-chart.xsd",
          "type": "blob",
          "size": 74984
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/dml-chartDrawing.xsd",
          "type": "blob",
          "size": 6956
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/dml-diagram.xsd",
          "type": "blob",
          "size": 51302
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/dml-lockedCanvas.xsd",
          "type": "blob",
          "size": 624
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/dml-main.xsd",
          "type": "blob",
          "size": 152039
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/dml-picture.xsd",
          "type": "blob",
          "size": 1231
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/dml-spreadsheetDrawing.xsd",
          "type": "blob",
          "size": 8862
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/dml-wordprocessingDrawing.xsd",
          "type": "blob",
          "size": 14795
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/pml.xsd",
          "type": "blob",
          "size": 83612
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/shared-additionalCharacteristics.xsd",
          "type": "blob",
          "size": 1269
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/shared-bibliography.xsd",
          "type": "blob",
          "size": 7328
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/shared-commonSimpleTypes.xsd",
          "type": "blob",
          "size": 6382
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/shared-customXmlDataProperties.xsd",
          "type": "blob",
          "size": 1248
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/shared-customXmlSchemaProperties.xsd",
          "type": "blob",
          "size": 880
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/shared-documentPropertiesCustom.xsd",
          "type": "blob",
          "size": 2608
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/shared-documentPropertiesExtended.xsd",
          "type": "blob",
          "size": 3507
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/shared-documentPropertiesVariantTypes.xsd",
          "type": "blob",
          "size": 7507
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/shared-math.xsd",
          "type": "blob",
          "size": 23313
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/shared-relationshipReference.xsd",
          "type": "blob",
          "size": 1367
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/sml.xsd",
          "type": "blob",
          "size": 242277
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/vml-main.xsd",
          "type": "blob",
          "size": 26148
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/vml-officeDrawing.xsd",
          "type": "blob",
          "size": 25279
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/vml-presentationDrawing.xsd",
          "type": "blob",
          "size": 535
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/vml-spreadsheetDrawing.xsd",
          "type": "blob",
          "size": 5712
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/vml-wordprocessingDrawing.xsd",
          "type": "blob",
          "size": 4010
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/wml.xsd",
          "type": "blob",
          "size": 171367
        },
        {
          "path": "skills/pptx/ooxml/schemas/ISO-IEC29500-4_2016/xml.xsd",
          "type": "blob",
          "size": 4646
        },
        {
          "path": "skills/pptx/ooxml/schemas/ecma",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/pptx/ooxml/schemas/ecma/fouth-edition",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/pptx/ooxml/schemas/ecma/fouth-edition/opc-contentTypes.xsd",
          "type": "blob",
          "size": 1963
        },
        {
          "path": "skills/pptx/ooxml/schemas/ecma/fouth-edition/opc-coreProperties.xsd",
          "type": "blob",
          "size": 2515
        },
        {
          "path": "skills/pptx/ooxml/schemas/ecma/fouth-edition/opc-digSig.xsd",
          "type": "blob",
          "size": 2856
        },
        {
          "path": "skills/pptx/ooxml/schemas/ecma/fouth-edition/opc-relationships.xsd",
          "type": "blob",
          "size": 1344
        },
        {
          "path": "skills/pptx/ooxml/schemas/mce",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/pptx/ooxml/schemas/mce/mc.xsd",
          "type": "blob",
          "size": 3127
        },
        {
          "path": "skills/pptx/ooxml/schemas/microsoft",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/pptx/ooxml/schemas/microsoft/wml-2010.xsd",
          "type": "blob",
          "size": 26549
        },
        {
          "path": "skills/pptx/ooxml/schemas/microsoft/wml-2012.xsd",
          "type": "blob",
          "size": 3745
        },
        {
          "path": "skills/pptx/ooxml/schemas/microsoft/wml-2018.xsd",
          "type": "blob",
          "size": 901
        },
        {
          "path": "skills/pptx/ooxml/schemas/microsoft/wml-cex-2018.xsd",
          "type": "blob",
          "size": 1778
        },
        {
          "path": "skills/pptx/ooxml/schemas/microsoft/wml-cid-2016.xsd",
          "type": "blob",
          "size": 1002
        },
        {
          "path": "skills/pptx/ooxml/schemas/microsoft/wml-sdtdatahash-2020.xsd",
          "type": "blob",
          "size": 600
        },
        {
          "path": "skills/pptx/ooxml/schemas/microsoft/wml-symex-2015.xsd",
          "type": "blob",
          "size": 745
        },
        {
          "path": "skills/pptx/ooxml/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/pptx/ooxml/scripts/pack.py",
          "type": "blob",
          "size": 5596
        },
        {
          "path": "skills/pptx/ooxml/scripts/unpack.py",
          "type": "blob",
          "size": 1037
        },
        {
          "path": "skills/pptx/ooxml/scripts/validate.py",
          "type": "blob",
          "size": 1959
        },
        {
          "path": "skills/pptx/ooxml/scripts/validation",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/pptx/ooxml/scripts/validation/__init__.py",
          "type": "blob",
          "size": 336
        },
        {
          "path": "skills/pptx/ooxml/scripts/validation/base.py",
          "type": "blob",
          "size": 39892
        },
        {
          "path": "skills/pptx/ooxml/scripts/validation/docx.py",
          "type": "blob",
          "size": 9996
        },
        {
          "path": "skills/pptx/ooxml/scripts/validation/pptx.py",
          "type": "blob",
          "size": 12327
        },
        {
          "path": "skills/pptx/ooxml/scripts/validation/redlining.py",
          "type": "blob",
          "size": 11179
        },
        {
          "path": "skills/pptx/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/pptx/scripts/html2pptx.js",
          "type": "blob",
          "size": 37795
        },
        {
          "path": "skills/pptx/scripts/inventory.py",
          "type": "blob",
          "size": 38126
        },
        {
          "path": "skills/pptx/scripts/rearrange.py",
          "type": "blob",
          "size": 8514
        },
        {
          "path": "skills/pptx/scripts/replace.py",
          "type": "blob",
          "size": 13594
        },
        {
          "path": "skills/pptx/scripts/thumbnail.py",
          "type": "blob",
          "size": 15484
        },
        {
          "path": "skills/skill-creator",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/skill-creator/LICENSE.txt",
          "type": "blob",
          "size": 11357
        },
        {
          "path": "skills/skill-creator/SKILL.md",
          "type": "blob",
          "size": 17837
        },
        {
          "path": "skills/skill-creator/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/skill-creator/references/output-patterns.md",
          "type": "blob",
          "size": 1813
        },
        {
          "path": "skills/skill-creator/references/workflows.md",
          "type": "blob",
          "size": 818
        },
        {
          "path": "skills/skill-creator/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/skill-creator/scripts/init_skill.py",
          "type": "blob",
          "size": 10863
        },
        {
          "path": "skills/skill-creator/scripts/package_skill.py",
          "type": "blob",
          "size": 3288
        },
        {
          "path": "skills/skill-creator/scripts/quick_validate.py",
          "type": "blob",
          "size": 3523
        },
        {
          "path": "skills/slack-gif-creator",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/slack-gif-creator/LICENSE.txt",
          "type": "blob",
          "size": 11357
        },
        {
          "path": "skills/slack-gif-creator/SKILL.md",
          "type": "blob",
          "size": 7841
        },
        {
          "path": "skills/slack-gif-creator/core",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/slack-gif-creator/core/easing.py",
          "type": "blob",
          "size": 6265
        },
        {
          "path": "skills/slack-gif-creator/core/frame_composer.py",
          "type": "blob",
          "size": 4548
        },
        {
          "path": "skills/slack-gif-creator/core/gif_builder.py",
          "type": "blob",
          "size": 9847
        },
        {
          "path": "skills/slack-gif-creator/core/validators.py",
          "type": "blob",
          "size": 3785
        },
        {
          "path": "skills/slack-gif-creator/requirements.txt",
          "type": "blob",
          "size": 66
        },
        {
          "path": "skills/theme-factory",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/theme-factory/LICENSE.txt",
          "type": "blob",
          "size": 11357
        },
        {
          "path": "skills/theme-factory/SKILL.md",
          "type": "blob",
          "size": 3124
        },
        {
          "path": "skills/theme-factory/theme-showcase.pdf",
          "type": "blob",
          "size": 124310
        },
        {
          "path": "skills/theme-factory/themes",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/theme-factory/themes/arctic-frost.md",
          "type": "blob",
          "size": 544
        },
        {
          "path": "skills/theme-factory/themes/botanical-garden.md",
          "type": "blob",
          "size": 519
        },
        {
          "path": "skills/theme-factory/themes/desert-rose.md",
          "type": "blob",
          "size": 496
        },
        {
          "path": "skills/theme-factory/themes/forest-canopy.md",
          "type": "blob",
          "size": 506
        },
        {
          "path": "skills/theme-factory/themes/golden-hour.md",
          "type": "blob",
          "size": 528
        },
        {
          "path": "skills/theme-factory/themes/midnight-galaxy.md",
          "type": "blob",
          "size": 513
        },
        {
          "path": "skills/theme-factory/themes/modern-minimalist.md",
          "type": "blob",
          "size": 549
        },
        {
          "path": "skills/theme-factory/themes/ocean-depths.md",
          "type": "blob",
          "size": 555
        },
        {
          "path": "skills/theme-factory/themes/sunset-boulevard.md",
          "type": "blob",
          "size": 558
        },
        {
          "path": "skills/theme-factory/themes/tech-innovation.md",
          "type": "blob",
          "size": 547
        },
        {
          "path": "skills/web-artifacts-builder",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/web-artifacts-builder/LICENSE.txt",
          "type": "blob",
          "size": 11357
        },
        {
          "path": "skills/web-artifacts-builder/SKILL.md",
          "type": "blob",
          "size": 3087
        },
        {
          "path": "skills/web-artifacts-builder/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/web-artifacts-builder/scripts/bundle-artifact.sh",
          "type": "blob",
          "size": 1517
        },
        {
          "path": "skills/web-artifacts-builder/scripts/init-artifact.sh",
          "type": "blob",
          "size": 9924
        },
        {
          "path": "skills/web-artifacts-builder/scripts/shadcn-components.tar.gz",
          "type": "blob",
          "size": 19967
        },
        {
          "path": "skills/webapp-testing",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/webapp-testing/LICENSE.txt",
          "type": "blob",
          "size": 11357
        },
        {
          "path": "skills/webapp-testing/SKILL.md",
          "type": "blob",
          "size": 3913
        },
        {
          "path": "skills/webapp-testing/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/webapp-testing/examples/console_logging.py",
          "type": "blob",
          "size": 1027
        },
        {
          "path": "skills/webapp-testing/examples/element_discovery.py",
          "type": "blob",
          "size": 1463
        },
        {
          "path": "skills/webapp-testing/examples/static_html_automation.py",
          "type": "blob",
          "size": 953
        },
        {
          "path": "skills/webapp-testing/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/webapp-testing/scripts/with_server.py",
          "type": "blob",
          "size": 3693
        },
        {
          "path": "skills/xlsx",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/xlsx/LICENSE.txt",
          "type": "blob",
          "size": 1467
        },
        {
          "path": "skills/xlsx/SKILL.md",
          "type": "blob",
          "size": 10632
        },
        {
          "path": "skills/xlsx/recalc.py",
          "type": "blob",
          "size": 6408
        },
        {
          "path": "spec",
          "type": "tree",
          "size": null
        },
        {
          "path": "spec/agent-skills-spec.md",
          "type": "blob",
          "size": 87
        },
        {
          "path": "template",
          "type": "tree",
          "size": null
        },
        {
          "path": "template/SKILL.md",
          "type": "blob",
          "size": 140
        }
      ],
      "marketplace": {
        "name": "anthropic-agent-skills",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "Keith Lazuka",
          "email": "klazuka@anthropic.com"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "document-skills",
            "description": "Collection of document processing suite including Excel, Word, PowerPoint, and PDF capabilities",
            "source": "./",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/skills",
              "/plugin install document-skills@anthropic-agent-skills"
            ],
            "signals": {
              "stars": 38467,
              "forks": 3501,
              "pushed_at": "2025-12-20T18:09:45Z",
              "created_at": "2025-09-22T15:53:31Z",
              "license": null
            },
            "commands": [],
            "skills": [
              {
                "name": "algorithmic-art",
                "description": "Creating algorithmic art using p5.js with seeded randomness and interactive parameter exploration. Use this when users request creating art using code, generative art, algorithmic art, flow fields, or particle systems. Create original algorithmic art rather than copying existing artists' work to avoid copyright violations.",
                "path": "skills/algorithmic-art/SKILL.md",
                "frontmatter": {
                  "name": "algorithmic-art",
                  "description": "Creating algorithmic art using p5.js with seeded randomness and interactive parameter exploration. Use this when users request creating art using code, generative art, algorithmic art, flow fields, or particle systems. Create original algorithmic art rather than copying existing artists' work to avoid copyright violations.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "Algorithmic philosophies are computational aesthetic movements that are then expressed through code. Output .md files (philosophy), .html files (interactive viewer), and .js files (generative algorithms).\n\nThis happens in two steps:\n1. Algorithmic Philosophy Creation (.md file)\n2. Express by creating p5.js generative art (.html + .js files)\n\nFirst, undertake this task:\n\n## ALGORITHMIC PHILOSOPHY CREATION\n\nTo begin, create an ALGORITHMIC PHILOSOPHY (not static images or templates) that will be interpreted through:\n- Computational processes, emergent behavior, mathematical beauty\n- Seeded randomness, noise fields, organic systems\n- Particles, flows, fields, forces\n- Parametric variation and controlled chaos\n\n### THE CRITICAL UNDERSTANDING\n- What is received: Some subtle input or instructions by the user to take into account, but use as a foundation; it should not constrain creative freedom.\n- What is created: An algorithmic philosophy/generative aesthetic movement.\n- What happens next: The same version receives the philosophy and EXPRESSES IT IN CODE - creating p5.js sketches that are 90% algorithmic generation, 10% essential parameters.\n\nConsider this approach:\n- Write a manifesto for a generative art movement\n- The next phase involves writing the algorithm that brings it to life\n\nThe philosophy must emphasize: Algorithmic expression. Emergent behavior. Computational beauty. Seeded variation.\n\n### HOW TO GENERATE AN ALGORITHMIC PHILOSOPHY\n\n**Name the movement** (1-2 words): \"Organic Turbulence\" / \"Quantum Harmonics\" / \"Emergent Stillness\"\n\n**Articulate the philosophy** (4-6 paragraphs - concise but complete):\n\nTo capture the ALGORITHMIC essence, express how this philosophy manifests through:\n- Computational processes and mathematical relationships?\n- Noise functions and randomness patterns?\n- Particle behaviors and field dynamics?\n- Temporal evolution and system states?\n- Parametric variation and emergent complexity?\n\n**CRITICAL GUIDELINES:**\n- **Avoid redundancy**: Each algorithmic aspect should be mentioned once. Avoid repeating concepts about noise theory, particle dynamics, or mathematical principles unless adding new depth.\n- **Emphasize craftsmanship REPEATEDLY**: The philosophy MUST stress multiple times that the final algorithm should appear as though it took countless hours to develop, was refined with care, and comes from someone at the absolute top of their field. This framing is essential - repeat phrases like \"meticulously crafted algorithm,\" \"the product of deep computational expertise,\" \"painstaking optimization,\" \"master-level implementation.\"\n- **Leave creative space**: Be specific about the algorithmic direction, but concise enough that the next Claude has room to make interpretive implementation choices at an extremely high level of craftsmanship.\n\nThe philosophy must guide the next version to express ideas ALGORITHMICALLY, not through static images. Beauty lives in the process, not the final frame.\n\n### PHILOSOPHY EXAMPLES\n\n**\"Organic Turbulence\"**\nPhilosophy: Chaos constrained by natural law, order emerging from disorder.\nAlgorithmic expression: Flow fields driven by layered Perlin noise. Thousands of particles following vector forces, their trails accumulating into organic density maps. Multiple noise octaves create turbulent regions and calm zones. Color emerges from velocity and density - fast particles burn bright, slow ones fade to shadow. The algorithm runs until equilibrium - a meticulously tuned balance where every parameter was refined through countless iterations by a master of computational aesthetics.\n\n**\"Quantum Harmonics\"**\nPhilosophy: Discrete entities exhibiting wave-like interference patterns.\nAlgorithmic expression: Particles initialized on a grid, each carrying a phase value that evolves through sine waves. When particles are near, their phases interfere - constructive interference creates bright nodes, destructive creates voids. Simple harmonic motion generates complex emergent mandalas. The result of painstaking frequency calibration where every ratio was carefully chosen to produce resonant beauty.\n\n**\"Recursive Whispers\"**\nPhilosophy: Self-similarity across scales, infinite depth in finite space.\nAlgorithmic expression: Branching structures that subdivide recursively. Each branch slightly randomized but constrained by golden ratios. L-systems or recursive subdivision generate tree-like forms that feel both mathematical and organic. Subtle noise perturbations break perfect symmetry. Line weights diminish with each recursion level. Every branching angle the product of deep mathematical exploration.\n\n**\"Field Dynamics\"**\nPhilosophy: Invisible forces made visible through their effects on matter.\nAlgorithmic expression: Vector fields constructed from mathematical functions or noise. Particles born at edges, flowing along field lines, dying when they reach equilibrium or boundaries. Multiple fields can attract, repel, or rotate particles. The visualization shows only the traces - ghost-like evidence of invisible forces. A computational dance meticulously choreographed through force balance.\n\n**\"Stochastic Crystallization\"**\nPhilosophy: Random processes crystallizing into ordered structures.\nAlgorithmic expression: Randomized circle packing or Voronoi tessellation. Start with random points, let them evolve through relaxation algorithms. Cells push apart until equilibrium. Color based on cell size, neighbor count, or distance from center. The organic tiling that emerges feels both random and inevitable. Every seed produces unique crystalline beauty - the mark of a master-level generative algorithm.\n\n*These are condensed examples. The actual algorithmic philosophy should be 4-6 substantial paragraphs.*\n\n### ESSENTIAL PRINCIPLES\n- **ALGORITHMIC PHILOSOPHY**: Creating a computational worldview to be expressed through code\n- **PROCESS OVER PRODUCT**: Always emphasize that beauty emerges from the algorithm's execution - each run is unique\n- **PARAMETRIC EXPRESSION**: Ideas communicate through mathematical relationships, forces, behaviors - not static composition\n- **ARTISTIC FREEDOM**: The next Claude interprets the philosophy algorithmically - provide creative implementation room\n- **PURE GENERATIVE ART**: This is about making LIVING ALGORITHMS, not static images with randomness\n- **EXPERT CRAFTSMANSHIP**: Repeatedly emphasize the final algorithm must feel meticulously crafted, refined through countless iterations, the product of deep expertise by someone at the absolute top of their field in computational aesthetics\n\n**The algorithmic philosophy should be 4-6 paragraphs long.** Fill it with poetic computational philosophy that brings together the intended vision. Avoid repeating the same points. Output this algorithmic philosophy as a .md file.\n\n---\n\n## DEDUCING THE CONCEPTUAL SEED\n\n**CRITICAL STEP**: Before implementing the algorithm, identify the subtle conceptual thread from the original request.\n\n**THE ESSENTIAL PRINCIPLE**:\nThe concept is a **subtle, niche reference embedded within the algorithm itself** - not always literal, always sophisticated. Someone familiar with the subject should feel it intuitively, while others simply experience a masterful generative composition. The algorithmic philosophy provides the computational language. The deduced concept provides the soul - the quiet conceptual DNA woven invisibly into parameters, behaviors, and emergence patterns.\n\nThis is **VERY IMPORTANT**: The reference must be so refined that it enhances the work's depth without announcing itself. Think like a jazz musician quoting another song through algorithmic harmony - only those who know will catch it, but everyone appreciates the generative beauty.\n\n---\n\n## P5.JS IMPLEMENTATION\n\nWith the philosophy AND conceptual framework established, express it through code. Pause to gather thoughts before proceeding. Use only the algorithmic philosophy created and the instructions below.\n\n### âš ï¸ STEP 0: READ THE TEMPLATE FIRST âš ï¸\n\n**CRITICAL: BEFORE writing any HTML:**\n\n1. **Read** `templates/viewer.html` using the Read tool\n2. **Study** the exact structure, styling, and Anthropic branding\n3. **Use that file as the LITERAL STARTING POINT** - not just inspiration\n4. **Keep all FIXED sections exactly as shown** (header, sidebar structure, Anthropic colors/fonts, seed controls, action buttons)\n5. **Replace only the VARIABLE sections** marked in the file's comments (algorithm, parameters, UI controls for parameters)\n\n**Avoid:**\n- âŒ Creating HTML from scratch\n- âŒ Inventing custom styling or color schemes\n- âŒ Using system fonts or dark themes\n- âŒ Changing the sidebar structure\n\n**Follow these practices:**\n- âœ… Copy the template's exact HTML structure\n- âœ… Keep Anthropic branding (Poppins/Lora fonts, light colors, gradient backdrop)\n- âœ… Maintain the sidebar layout (Seed â†’ Parameters â†’ Colors? â†’ Actions)\n- âœ… Replace only the p5.js algorithm and parameter controls\n\nThe template is the foundation. Build on it, don't rebuild it.\n\n---\n\nTo create gallery-quality computational art that lives and breathes, use the algorithmic philosophy as the foundation.\n\n### TECHNICAL REQUIREMENTS\n\n**Seeded Randomness (Art Blocks Pattern)**:\n```javascript\n// ALWAYS use a seed for reproducibility\nlet seed = 12345; // or hash from user input\nrandomSeed(seed);\nnoiseSeed(seed);\n```\n\n**Parameter Structure - FOLLOW THE PHILOSOPHY**:\n\nTo establish parameters that emerge naturally from the algorithmic philosophy, consider: \"What qualities of this system can be adjusted?\"\n\n```javascript\nlet params = {\n  seed: 12345,  // Always include seed for reproducibility\n  // colors\n  // Add parameters that control YOUR algorithm:\n  // - Quantities (how many?)\n  // - Scales (how big? how fast?)\n  // - Probabilities (how likely?)\n  // - Ratios (what proportions?)\n  // - Angles (what direction?)\n  // - Thresholds (when does behavior change?)\n};\n```\n\n**To design effective parameters, focus on the properties the system needs to be tunable rather than thinking in terms of \"pattern types\".**\n\n**Core Algorithm - EXPRESS THE PHILOSOPHY**:\n\n**CRITICAL**: The algorithmic philosophy should dictate what to build.\n\nTo express the philosophy through code, avoid thinking \"which pattern should I use?\" and instead think \"how to express this philosophy through code?\"\n\nIf the philosophy is about **organic emergence**, consider using:\n- Elements that accumulate or grow over time\n- Random processes constrained by natural rules\n- Feedback loops and interactions\n\nIf the philosophy is about **mathematical beauty**, consider using:\n- Geometric relationships and ratios\n- Trigonometric functions and harmonics\n- Precise calculations creating unexpected patterns\n\nIf the philosophy is about **controlled chaos**, consider using:\n- Random variation within strict boundaries\n- Bifurcation and phase transitions\n- Order emerging from disorder\n\n**The algorithm flows from the philosophy, not from a menu of options.**\n\nTo guide the implementation, let the conceptual essence inform creative and original choices. Build something that expresses the vision for this particular request.\n\n**Canvas Setup**: Standard p5.js structure:\n```javascript\nfunction setup() {\n  createCanvas(1200, 1200);\n  // Initialize your system\n}\n\nfunction draw() {\n  // Your generative algorithm\n  // Can be static (noLoop) or animated\n}\n```\n\n### CRAFTSMANSHIP REQUIREMENTS\n\n**CRITICAL**: To achieve mastery, create algorithms that feel like they emerged through countless iterations by a master generative artist. Tune every parameter carefully. Ensure every pattern emerges with purpose. This is NOT random noise - this is CONTROLLED CHAOS refined through deep expertise.\n\n- **Balance**: Complexity without visual noise, order without rigidity\n- **Color Harmony**: Thoughtful palettes, not random RGB values\n- **Composition**: Even in randomness, maintain visual hierarchy and flow\n- **Performance**: Smooth execution, optimized for real-time if animated\n- **Reproducibility**: Same seed ALWAYS produces identical output\n\n### OUTPUT FORMAT\n\nOutput:\n1. **Algorithmic Philosophy** - As markdown or text explaining the generative aesthetic\n2. **Single HTML Artifact** - Self-contained interactive generative art built from `templates/viewer.html` (see STEP 0 and next section)\n\nThe HTML artifact contains everything: p5.js (from CDN), the algorithm, parameter controls, and UI - all in one file that works immediately in claude.ai artifacts or any browser. Start from the template file, not from scratch.\n\n---\n\n## INTERACTIVE ARTIFACT CREATION\n\n**REMINDER: `templates/viewer.html` should have already been read (see STEP 0). Use that file as the starting point.**\n\nTo allow exploration of the generative art, create a single, self-contained HTML artifact. Ensure this artifact works immediately in claude.ai or any browser - no setup required. Embed everything inline.\n\n### CRITICAL: WHAT'S FIXED VS VARIABLE\n\nThe `templates/viewer.html` file is the foundation. It contains the exact structure and styling needed.\n\n**FIXED (always include exactly as shown):**\n- Layout structure (header, sidebar, main canvas area)\n- Anthropic branding (UI colors, fonts, gradients)\n- Seed section in sidebar:\n  - Seed display\n  - Previous/Next buttons\n  - Random button\n  - Jump to seed input + Go button\n- Actions section in sidebar:\n  - Regenerate button\n  - Reset button\n\n**VARIABLE (customize for each artwork):**\n- The entire p5.js algorithm (setup/draw/classes)\n- The parameters object (define what the art needs)\n- The Parameters section in sidebar:\n  - Number of parameter controls\n  - Parameter names\n  - Min/max/step values for sliders\n  - Control types (sliders, inputs, etc.)\n- Colors section (optional):\n  - Some art needs color pickers\n  - Some art might use fixed colors\n  - Some art might be monochrome (no color controls needed)\n  - Decide based on the art's needs\n\n**Every artwork should have unique parameters and algorithm!** The fixed parts provide consistent UX - everything else expresses the unique vision.\n\n### REQUIRED FEATURES\n\n**1. Parameter Controls**\n- Sliders for numeric parameters (particle count, noise scale, speed, etc.)\n- Color pickers for palette colors\n- Real-time updates when parameters change\n- Reset button to restore defaults\n\n**2. Seed Navigation**\n- Display current seed number\n- \"Previous\" and \"Next\" buttons to cycle through seeds\n- \"Random\" button for random seed\n- Input field to jump to specific seed\n- Generate 100 variations when requested (seeds 1-100)\n\n**3. Single Artifact Structure**\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <!-- p5.js from CDN - always available -->\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js\"></script>\n  <style>\n    /* All styling inline - clean, minimal */\n    /* Canvas on top, controls below */\n  </style>\n</head>\n<body>\n  <div id=\"canvas-container\"></div>\n  <div id=\"controls\">\n    <!-- All parameter controls -->\n  </div>\n  <script>\n    // ALL p5.js code inline here\n    // Parameter objects, classes, functions\n    // setup() and draw()\n    // UI handlers\n    // Everything self-contained\n  </script>\n</body>\n</html>\n```\n\n**CRITICAL**: This is a single artifact. No external files, no imports (except p5.js CDN). Everything inline.\n\n**4. Implementation Details - BUILD THE SIDEBAR**\n\nThe sidebar structure:\n\n**1. Seed (FIXED)** - Always include exactly as shown:\n- Seed display\n- Prev/Next/Random/Jump buttons\n\n**2. Parameters (VARIABLE)** - Create controls for the art:\n```html\n<div class=\"control-group\">\n    <label>Parameter Name</label>\n    <input type=\"range\" id=\"param\" min=\"...\" max=\"...\" step=\"...\" value=\"...\" oninput=\"updateParam('param', this.value)\">\n    <span class=\"value-display\" id=\"param-value\">...</span>\n</div>\n```\nAdd as many control-group divs as there are parameters.\n\n**3. Colors (OPTIONAL/VARIABLE)** - Include if the art needs adjustable colors:\n- Add color pickers if users should control palette\n- Skip this section if the art uses fixed colors\n- Skip if the art is monochrome\n\n**4. Actions (FIXED)** - Always include exactly as shown:\n- Regenerate button\n- Reset button\n- Download PNG button\n\n**Requirements**:\n- Seed controls must work (prev/next/random/jump/display)\n- All parameters must have UI controls\n- Regenerate, Reset, Download buttons must work\n- Keep Anthropic branding (UI styling, not art colors)\n\n### USING THE ARTIFACT\n\nThe HTML artifact works immediately:\n1. **In claude.ai**: Displayed as an interactive artifact - runs instantly\n2. **As a file**: Save and open in any browser - no server needed\n3. **Sharing**: Send the HTML file - it's completely self-contained\n\n---\n\n## VARIATIONS & EXPLORATION\n\nThe artifact includes seed navigation by default (prev/next/random buttons), allowing users to explore variations without creating multiple files. If the user wants specific variations highlighted:\n\n- Include seed presets (buttons for \"Variation 1: Seed 42\", \"Variation 2: Seed 127\", etc.)\n- Add a \"Gallery Mode\" that shows thumbnails of multiple seeds side-by-side\n- All within the same single artifact\n\nThis is like creating a series of prints from the same plate - the algorithm is consistent, but each seed reveals different facets of its potential. The interactive nature means users discover their own favorites by exploring the seed space.\n\n---\n\n## THE CREATIVE PROCESS\n\n**User request** â†’ **Algorithmic philosophy** â†’ **Implementation**\n\nEach request is unique. The process involves:\n\n1. **Interpret the user's intent** - What aesthetic is being sought?\n2. **Create an algorithmic philosophy** (4-6 paragraphs) describing the computational approach\n3. **Implement it in code** - Build the algorithm that expresses this philosophy\n4. **Design appropriate parameters** - What should be tunable?\n5. **Build matching UI controls** - Sliders/inputs for those parameters\n\n**The constants**:\n- Anthropic branding (colors, fonts, layout)\n- Seed navigation (always present)\n- Self-contained HTML artifact\n\n**Everything else is variable**:\n- The algorithm itself\n- The parameters\n- The UI controls\n- The visual outcome\n\nTo achieve the best results, trust creativity and let the philosophy guide the implementation.\n\n---\n\n## RESOURCES\n\nThis skill includes helpful templates and documentation:\n\n- **templates/viewer.html**: REQUIRED STARTING POINT for all HTML artifacts.\n  - This is the foundation - contains the exact structure and Anthropic branding\n  - **Keep unchanged**: Layout structure, sidebar organization, Anthropic colors/fonts, seed controls, action buttons\n  - **Replace**: The p5.js algorithm, parameter definitions, and UI controls in Parameters section\n  - The extensive comments in the file mark exactly what to keep vs replace\n\n- **templates/generator_template.js**: Reference for p5.js best practices and code structure principles.\n  - Shows how to organize parameters, use seeded randomness, structure classes\n  - NOT a pattern menu - use these principles to build unique algorithms\n  - Embed algorithms inline in the HTML artifact (don't create separate .js files)\n\n**Critical reminder**:\n- The **template is the STARTING POINT**, not inspiration\n- The **algorithm is where to create** something unique\n- Don't copy the flow field example - build what the philosophy demands\n- But DO keep the exact UI structure and Anthropic branding from the template"
              },
              {
                "name": "brand-guidelines",
                "description": "Applies Anthropic's official brand colors and typography to any sort of artifact that may benefit from having Anthropic's look-and-feel. Use it when brand colors or style guidelines, visual formatting, or company design standards apply.",
                "path": "skills/brand-guidelines/SKILL.md",
                "frontmatter": {
                  "name": "brand-guidelines",
                  "description": "Applies Anthropic's official brand colors and typography to any sort of artifact that may benefit from having Anthropic's look-and-feel. Use it when brand colors or style guidelines, visual formatting, or company design standards apply.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "# Anthropic Brand Styling\n\n## Overview\n\nTo access Anthropic's official brand identity and style resources, use this skill.\n\n**Keywords**: branding, corporate identity, visual identity, post-processing, styling, brand colors, typography, Anthropic brand, visual formatting, visual design\n\n## Brand Guidelines\n\n### Colors\n\n**Main Colors:**\n\n- Dark: `#141413` - Primary text and dark backgrounds\n- Light: `#faf9f5` - Light backgrounds and text on dark\n- Mid Gray: `#b0aea5` - Secondary elements\n- Light Gray: `#e8e6dc` - Subtle backgrounds\n\n**Accent Colors:**\n\n- Orange: `#d97757` - Primary accent\n- Blue: `#6a9bcc` - Secondary accent\n- Green: `#788c5d` - Tertiary accent\n\n### Typography\n\n- **Headings**: Poppins (with Arial fallback)\n- **Body Text**: Lora (with Georgia fallback)\n- **Note**: Fonts should be pre-installed in your environment for best results\n\n## Features\n\n### Smart Font Application\n\n- Applies Poppins font to headings (24pt and larger)\n- Applies Lora font to body text\n- Automatically falls back to Arial/Georgia if custom fonts unavailable\n- Preserves readability across all systems\n\n### Text Styling\n\n- Headings (24pt+): Poppins font\n- Body text: Lora font\n- Smart color selection based on background\n- Preserves text hierarchy and formatting\n\n### Shape and Accent Colors\n\n- Non-text shapes use accent colors\n- Cycles through orange, blue, and green accents\n- Maintains visual interest while staying on-brand\n\n## Technical Details\n\n### Font Management\n\n- Uses system-installed Poppins and Lora fonts when available\n- Provides automatic fallback to Arial (headings) and Georgia (body)\n- No font installation required - works with existing system fonts\n- For best results, pre-install Poppins and Lora fonts in your environment\n\n### Color Application\n\n- Uses RGB color values for precise brand matching\n- Applied via python-pptx's RGBColor class\n- Maintains color fidelity across different systems"
              },
              {
                "name": "canvas-design",
                "description": "Create beautiful visual art in .png and .pdf documents using design philosophy. You should use this skill when the user asks to create a poster, piece of art, design, or other static piece. Create original visual designs, never copying existing artists' work to avoid copyright violations.",
                "path": "skills/canvas-design/SKILL.md",
                "frontmatter": {
                  "name": "canvas-design",
                  "description": "Create beautiful visual art in .png and .pdf documents using design philosophy. You should use this skill when the user asks to create a poster, piece of art, design, or other static piece. Create original visual designs, never copying existing artists' work to avoid copyright violations.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "These are instructions for creating design philosophies - aesthetic movements that are then EXPRESSED VISUALLY. Output only .md files, .pdf files, and .png files.\n\nComplete this in two steps:\n1. Design Philosophy Creation (.md file)\n2. Express by creating it on a canvas (.pdf file or .png file)\n\nFirst, undertake this task:\n\n## DESIGN PHILOSOPHY CREATION\n\nTo begin, create a VISUAL PHILOSOPHY (not layouts or templates) that will be interpreted through:\n- Form, space, color, composition\n- Images, graphics, shapes, patterns\n- Minimal text as visual accent\n\n### THE CRITICAL UNDERSTANDING\n- What is received: Some subtle input or instructions by the user that should be taken into account, but used as a foundation; it should not constrain creative freedom.\n- What is created: A design philosophy/aesthetic movement.\n- What happens next: Then, the same version receives the philosophy and EXPRESSES IT VISUALLY - creating artifacts that are 90% visual design, 10% essential text.\n\nConsider this approach:\n- Write a manifesto for an art movement\n- The next phase involves making the artwork\n\nThe philosophy must emphasize: Visual expression. Spatial communication. Artistic interpretation. Minimal words.\n\n### HOW TO GENERATE A VISUAL PHILOSOPHY\n\n**Name the movement** (1-2 words): \"Brutalist Joy\" / \"Chromatic Silence\" / \"Metabolist Dreams\"\n\n**Articulate the philosophy** (4-6 paragraphs - concise but complete):\n\nTo capture the VISUAL essence, express how the philosophy manifests through:\n- Space and form\n- Color and material\n- Scale and rhythm\n- Composition and balance\n- Visual hierarchy\n\n**CRITICAL GUIDELINES:**\n- **Avoid redundancy**: Each design aspect should be mentioned once. Avoid repeating points about color theory, spatial relationships, or typographic principles unless adding new depth.\n- **Emphasize craftsmanship REPEATEDLY**: The philosophy MUST stress multiple times that the final work should appear as though it took countless hours to create, was labored over with care, and comes from someone at the absolute top of their field. This framing is essential - repeat phrases like \"meticulously crafted,\" \"the product of deep expertise,\" \"painstaking attention,\" \"master-level execution.\"\n- **Leave creative space**: Remain specific about the aesthetic direction, but concise enough that the next Claude has room to make interpretive choices also at a extremely high level of craftmanship.\n\nThe philosophy must guide the next version to express ideas VISUALLY, not through text. Information lives in design, not paragraphs.\n\n### PHILOSOPHY EXAMPLES\n\n**\"Concrete Poetry\"**\nPhilosophy: Communication through monumental form and bold geometry.\nVisual expression: Massive color blocks, sculptural typography (huge single words, tiny labels), Brutalist spatial divisions, Polish poster energy meets Le Corbusier. Ideas expressed through visual weight and spatial tension, not explanation. Text as rare, powerful gesture - never paragraphs, only essential words integrated into the visual architecture. Every element placed with the precision of a master craftsman.\n\n**\"Chromatic Language\"**\nPhilosophy: Color as the primary information system.\nVisual expression: Geometric precision where color zones create meaning. Typography minimal - small sans-serif labels letting chromatic fields communicate. Think Josef Albers' interaction meets data visualization. Information encoded spatially and chromatically. Words only to anchor what color already shows. The result of painstaking chromatic calibration.\n\n**\"Analog Meditation\"**\nPhilosophy: Quiet visual contemplation through texture and breathing room.\nVisual expression: Paper grain, ink bleeds, vast negative space. Photography and illustration dominate. Typography whispered (small, restrained, serving the visual). Japanese photobook aesthetic. Images breathe across pages. Text appears sparingly - short phrases, never explanatory blocks. Each composition balanced with the care of a meditation practice.\n\n**\"Organic Systems\"**\nPhilosophy: Natural clustering and modular growth patterns.\nVisual expression: Rounded forms, organic arrangements, color from nature through architecture. Information shown through visual diagrams, spatial relationships, iconography. Text only for key labels floating in space. The composition tells the story through expert spatial orchestration.\n\n**\"Geometric Silence\"**\nPhilosophy: Pure order and restraint.\nVisual expression: Grid-based precision, bold photography or stark graphics, dramatic negative space. Typography precise but minimal - small essential text, large quiet zones. Swiss formalism meets Brutalist material honesty. Structure communicates, not words. Every alignment the work of countless refinements.\n\n*These are condensed examples. The actual design philosophy should be 4-6 substantial paragraphs.*\n\n### ESSENTIAL PRINCIPLES\n- **VISUAL PHILOSOPHY**: Create an aesthetic worldview to be expressed through design\n- **MINIMAL TEXT**: Always emphasize that text is sparse, essential-only, integrated as visual element - never lengthy\n- **SPATIAL EXPRESSION**: Ideas communicate through space, form, color, composition - not paragraphs\n- **ARTISTIC FREEDOM**: The next Claude interprets the philosophy visually - provide creative room\n- **PURE DESIGN**: This is about making ART OBJECTS, not documents with decoration\n- **EXPERT CRAFTSMANSHIP**: Repeatedly emphasize the final work must look meticulously crafted, labored over with care, the product of countless hours by someone at the top of their field\n\n**The design philosophy should be 4-6 paragraphs long.** Fill it with poetic design philosophy that brings together the core vision. Avoid repeating the same points. Keep the design philosophy generic without mentioning the intention of the art, as if it can be used wherever. Output the design philosophy as a .md file.\n\n---\n\n## DEDUCING THE SUBTLE REFERENCE\n\n**CRITICAL STEP**: Before creating the canvas, identify the subtle conceptual thread from the original request.\n\n**THE ESSENTIAL PRINCIPLE**:\nThe topic is a **subtle, niche reference embedded within the art itself** - not always literal, always sophisticated. Someone familiar with the subject should feel it intuitively, while others simply experience a masterful abstract composition. The design philosophy provides the aesthetic language. The deduced topic provides the soul - the quiet conceptual DNA woven invisibly into form, color, and composition.\n\nThis is **VERY IMPORTANT**: The reference must be refined so it enhances the work's depth without announcing itself. Think like a jazz musician quoting another song - only those who know will catch it, but everyone appreciates the music.\n\n---\n\n## CANVAS CREATION\n\nWith both the philosophy and the conceptual framework established, express it on a canvas. Take a moment to gather thoughts and clear the mind. Use the design philosophy created and the instructions below to craft a masterpiece, embodying all aspects of the philosophy with expert craftsmanship.\n\n**IMPORTANT**: For any type of content, even if the user requests something for a movie/game/book, the approach should still be sophisticated. Never lose sight of the idea that this should be art, not something that's cartoony or amateur.\n\nTo create museum or magazine quality work, use the design philosophy as the foundation. Create one single page, highly visual, design-forward PDF or PNG output (unless asked for more pages). Generally use repeating patterns and perfect shapes. Treat the abstract philosophical design as if it were a scientific bible, borrowing the visual language of systematic observationâ€”dense accumulation of marks, repeated elements, or layered patterns that build meaning through patient repetition and reward sustained viewing. Add sparse, clinical typography and systematic reference markers that suggest this could be a diagram from an imaginary discipline, treating the invisible subject with the same reverence typically reserved for documenting observable phenomena. Anchor the piece with simple phrase(s) or details positioned subtly, using a limited color palette that feels intentional and cohesive. Embrace the paradox of using analytical visual language to express ideas about human experience: the result should feel like an artifact that proves something ephemeral can be studied, mapped, and understood through careful attention. This is true art. \n\n**Text as a contextual element**: Text is always minimal and visual-first, but let context guide whether that means whisper-quiet labels or bold typographic gestures. A punk venue poster might have larger, more aggressive type than a minimalist ceramics studio identity. Most of the time, font should be thin. All use of fonts must be design-forward and prioritize visual communication. Regardless of text scale, nothing falls off the page and nothing overlaps. Every element must be contained within the canvas boundaries with proper margins. Check carefully that all text, graphics, and visual elements have breathing room and clear separation. This is non-negotiable for professional execution. **IMPORTANT: Use different fonts if writing text. Search the `./canvas-fonts` directory. Regardless of approach, sophistication is non-negotiable.**\n\nDownload and use whatever fonts are needed to make this a reality. Get creative by making the typography actually part of the art itself -- if the art is abstract, bring the font onto the canvas, not typeset digitally.\n\nTo push boundaries, follow design instinct/intuition while using the philosophy as a guiding principle. Embrace ultimate design freedom and choice. Push aesthetics and design to the frontier. \n\n**CRITICAL**: To achieve human-crafted quality (not AI-generated), create work that looks like it took countless hours. Make it appear as though someone at the absolute top of their field labored over every detail with painstaking care. Ensure the composition, spacing, color choices, typography - everything screams expert-level craftsmanship. Double-check that nothing overlaps, formatting is flawless, every detail perfect. Create something that could be shown to people to prove expertise and rank as undeniably impressive.\n\nOutput the final result as a single, downloadable .pdf or .png file, alongside the design philosophy used as a .md file.\n\n---\n\n## FINAL STEP\n\n**IMPORTANT**: The user ALREADY said \"It isn't perfect enough. It must be pristine, a masterpiece if craftsmanship, as if it were about to be displayed in a museum.\"\n\n**CRITICAL**: To refine the work, avoid adding more graphics; instead refine what has been created and make it extremely crisp, respecting the design philosophy and the principles of minimalism entirely. Rather than adding a fun filter or refactoring a font, consider how to make the existing composition more cohesive with the art. If the instinct is to call a new function or draw a new shape, STOP and instead ask: \"How can I make what's already here more of a piece of art?\"\n\nTake a second pass. Go back to the code and refine/polish further to make this a philosophically designed masterpiece.\n\n## MULTI-PAGE OPTION\n\nTo create additional pages when requested, create more creative pages along the same lines as the design philosophy but distinctly different as well. Bundle those pages in the same .pdf or many .pngs. Treat the first page as just a single page in a whole coffee table book waiting to be filled. Make the next pages unique twists and memories of the original. Have them almost tell a story in a very tasteful way. Exercise full creative freedom."
              },
              {
                "name": "doc-coauthoring",
                "description": "Guide users through a structured workflow for co-authoring documentation. Use when user wants to write documentation, proposals, technical specs, decision docs, or similar structured content. This workflow helps users efficiently transfer context, refine content through iteration, and verify the doc works for readers. Trigger when user mentions writing docs, creating proposals, drafting specs, or similar documentation tasks.",
                "path": "skills/doc-coauthoring/SKILL.md",
                "frontmatter": {
                  "name": "doc-coauthoring",
                  "description": "Guide users through a structured workflow for co-authoring documentation. Use when user wants to write documentation, proposals, technical specs, decision docs, or similar structured content. This workflow helps users efficiently transfer context, refine content through iteration, and verify the doc works for readers. Trigger when user mentions writing docs, creating proposals, drafting specs, or similar documentation tasks."
                },
                "content": "# Doc Co-Authoring Workflow\n\nThis skill provides a structured workflow for guiding users through collaborative document creation. Act as an active guide, walking users through three stages: Context Gathering, Refinement & Structure, and Reader Testing.\n\n## When to Offer This Workflow\n\n**Trigger conditions:**\n- User mentions writing documentation: \"write a doc\", \"draft a proposal\", \"create a spec\", \"write up\"\n- User mentions specific doc types: \"PRD\", \"design doc\", \"decision doc\", \"RFC\"\n- User seems to be starting a substantial writing task\n\n**Initial offer:**\nOffer the user a structured workflow for co-authoring the document. Explain the three stages:\n\n1. **Context Gathering**: User provides all relevant context while Claude asks clarifying questions\n2. **Refinement & Structure**: Iteratively build each section through brainstorming and editing\n3. **Reader Testing**: Test the doc with a fresh Claude (no context) to catch blind spots before others read it\n\nExplain that this approach helps ensure the doc works well when others read it (including when they paste it into Claude). Ask if they want to try this workflow or prefer to work freeform.\n\nIf user declines, work freeform. If user accepts, proceed to Stage 1.\n\n## Stage 1: Context Gathering\n\n**Goal:** Close the gap between what the user knows and what Claude knows, enabling smart guidance later.\n\n### Initial Questions\n\nStart by asking the user for meta-context about the document:\n\n1. What type of document is this? (e.g., technical spec, decision doc, proposal)\n2. Who's the primary audience?\n3. What's the desired impact when someone reads this?\n4. Is there a template or specific format to follow?\n5. Any other constraints or context to know?\n\nInform them they can answer in shorthand or dump information however works best for them.\n\n**If user provides a template or mentions a doc type:**\n- Ask if they have a template document to share\n- If they provide a link to a shared document, use the appropriate integration to fetch it\n- If they provide a file, read it\n\n**If user mentions editing an existing shared document:**\n- Use the appropriate integration to read the current state\n- Check for images without alt-text\n- If images exist without alt-text, explain that when others use Claude to understand the doc, Claude won't be able to see them. Ask if they want alt-text generated. If so, request they paste each image into chat for descriptive alt-text generation.\n\n### Info Dumping\n\nOnce initial questions are answered, encourage the user to dump all the context they have. Request information such as:\n- Background on the project/problem\n- Related team discussions or shared documents\n- Why alternative solutions aren't being used\n- Organizational context (team dynamics, past incidents, politics)\n- Timeline pressures or constraints\n- Technical architecture or dependencies\n- Stakeholder concerns\n\nAdvise them not to worry about organizing it - just get it all out. Offer multiple ways to provide context:\n- Info dump stream-of-consciousness\n- Point to team channels or threads to read\n- Link to shared documents\n\n**If integrations are available** (e.g., Slack, Teams, Google Drive, SharePoint, or other MCP servers), mention that these can be used to pull in context directly.\n\n**If no integrations are detected and in Claude.ai or Claude app:** Suggest they can enable connectors in their Claude settings to allow pulling context from messaging apps and document storage directly.\n\nInform them clarifying questions will be asked once they've done their initial dump.\n\n**During context gathering:**\n\n- If user mentions team channels or shared documents:\n  - If integrations available: Inform them the content will be read now, then use the appropriate integration\n  - If integrations not available: Explain lack of access. Suggest they enable connectors in Claude settings, or paste the relevant content directly.\n\n- If user mentions entities/projects that are unknown:\n  - Ask if connected tools should be searched to learn more\n  - Wait for user confirmation before searching\n\n- As user provides context, track what's being learned and what's still unclear\n\n**Asking clarifying questions:**\n\nWhen user signals they've done their initial dump (or after substantial context provided), ask clarifying questions to ensure understanding:\n\nGenerate 5-10 numbered questions based on gaps in the context.\n\nInform them they can use shorthand to answer (e.g., \"1: yes, 2: see #channel, 3: no because backwards compat\"), link to more docs, point to channels to read, or just keep info-dumping. Whatever's most efficient for them.\n\n**Exit condition:**\nSufficient context has been gathered when questions show understanding - when edge cases and trade-offs can be asked about without needing basics explained.\n\n**Transition:**\nAsk if there's any more context they want to provide at this stage, or if it's time to move on to drafting the document.\n\nIf user wants to add more, let them. When ready, proceed to Stage 2.\n\n## Stage 2: Refinement & Structure\n\n**Goal:** Build the document section by section through brainstorming, curation, and iterative refinement.\n\n**Instructions to user:**\nExplain that the document will be built section by section. For each section:\n1. Clarifying questions will be asked about what to include\n2. 5-20 options will be brainstormed\n3. User will indicate what to keep/remove/combine\n4. The section will be drafted\n5. It will be refined through surgical edits\n\nStart with whichever section has the most unknowns (usually the core decision/proposal), then work through the rest.\n\n**Section ordering:**\n\nIf the document structure is clear:\nAsk which section they'd like to start with.\n\nSuggest starting with whichever section has the most unknowns. For decision docs, that's usually the core proposal. For specs, it's typically the technical approach. Summary sections are best left for last.\n\nIf user doesn't know what sections they need:\nBased on the type of document and template, suggest 3-5 sections appropriate for the doc type.\n\nAsk if this structure works, or if they want to adjust it.\n\n**Once structure is agreed:**\n\nCreate the initial document structure with placeholder text for all sections.\n\n**If access to artifacts is available:**\nUse `create_file` to create an artifact. This gives both Claude and the user a scaffold to work from.\n\nInform them that the initial structure with placeholders for all sections will be created.\n\nCreate artifact with all section headers and brief placeholder text like \"[To be written]\" or \"[Content here]\".\n\nProvide the scaffold link and indicate it's time to fill in each section.\n\n**If no access to artifacts:**\nCreate a markdown file in the working directory. Name it appropriately (e.g., `decision-doc.md`, `technical-spec.md`).\n\nInform them that the initial structure with placeholders for all sections will be created.\n\nCreate file with all section headers and placeholder text.\n\nConfirm the filename has been created and indicate it's time to fill in each section.\n\n**For each section:**\n\n### Step 1: Clarifying Questions\n\nAnnounce work will begin on the [SECTION NAME] section. Ask 5-10 clarifying questions about what should be included:\n\nGenerate 5-10 specific questions based on context and section purpose.\n\nInform them they can answer in shorthand or just indicate what's important to cover.\n\n### Step 2: Brainstorming\n\nFor the [SECTION NAME] section, brainstorm [5-20] things that might be included, depending on the section's complexity. Look for:\n- Context shared that might have been forgotten\n- Angles or considerations not yet mentioned\n\nGenerate 5-20 numbered options based on section complexity. At the end, offer to brainstorm more if they want additional options.\n\n### Step 3: Curation\n\nAsk which points should be kept, removed, or combined. Request brief justifications to help learn priorities for the next sections.\n\nProvide examples:\n- \"Keep 1,4,7,9\"\n- \"Remove 3 (duplicates 1)\"\n- \"Remove 6 (audience already knows this)\"\n- \"Combine 11 and 12\"\n\n**If user gives freeform feedback** (e.g., \"looks good\" or \"I like most of it but...\") instead of numbered selections, extract their preferences and proceed. Parse what they want kept/removed/changed and apply it.\n\n### Step 4: Gap Check\n\nBased on what they've selected, ask if there's anything important missing for the [SECTION NAME] section.\n\n### Step 5: Drafting\n\nUse `str_replace` to replace the placeholder text for this section with the actual drafted content.\n\nAnnounce the [SECTION NAME] section will be drafted now based on what they've selected.\n\n**If using artifacts:**\nAfter drafting, provide a link to the artifact.\n\nAsk them to read through it and indicate what to change. Note that being specific helps learning for the next sections.\n\n**If using a file (no artifacts):**\nAfter drafting, confirm completion.\n\nInform them the [SECTION NAME] section has been drafted in [filename]. Ask them to read through it and indicate what to change. Note that being specific helps learning for the next sections.\n\n**Key instruction for user (include when drafting the first section):**\nProvide a note: Instead of editing the doc directly, ask them to indicate what to change. This helps learning of their style for future sections. For example: \"Remove the X bullet - already covered by Y\" or \"Make the third paragraph more concise\".\n\n### Step 6: Iterative Refinement\n\nAs user provides feedback:\n- Use `str_replace` to make edits (never reprint the whole doc)\n- **If using artifacts:** Provide link to artifact after each edit\n- **If using files:** Just confirm edits are complete\n- If user edits doc directly and asks to read it: mentally note the changes they made and keep them in mind for future sections (this shows their preferences)\n\n**Continue iterating** until user is satisfied with the section.\n\n### Quality Checking\n\nAfter 3 consecutive iterations with no substantial changes, ask if anything can be removed without losing important information.\n\nWhen section is done, confirm [SECTION NAME] is complete. Ask if ready to move to the next section.\n\n**Repeat for all sections.**\n\n### Near Completion\n\nAs approaching completion (80%+ of sections done), announce intention to re-read the entire document and check for:\n- Flow and consistency across sections\n- Redundancy or contradictions\n- Anything that feels like \"slop\" or generic filler\n- Whether every sentence carries weight\n\nRead entire document and provide feedback.\n\n**When all sections are drafted and refined:**\nAnnounce all sections are drafted. Indicate intention to review the complete document one more time.\n\nReview for overall coherence, flow, completeness.\n\nProvide any final suggestions.\n\nAsk if ready to move to Reader Testing, or if they want to refine anything else.\n\n## Stage 3: Reader Testing\n\n**Goal:** Test the document with a fresh Claude (no context bleed) to verify it works for readers.\n\n**Instructions to user:**\nExplain that testing will now occur to see if the document actually works for readers. This catches blind spots - things that make sense to the authors but might confuse others.\n\n### Testing Approach\n\n**If access to sub-agents is available (e.g., in Claude Code):**\n\nPerform the testing directly without user involvement.\n\n### Step 1: Predict Reader Questions\n\nAnnounce intention to predict what questions readers might ask when trying to discover this document.\n\nGenerate 5-10 questions that readers would realistically ask.\n\n### Step 2: Test with Sub-Agent\n\nAnnounce that these questions will be tested with a fresh Claude instance (no context from this conversation).\n\nFor each question, invoke a sub-agent with just the document content and the question.\n\nSummarize what Reader Claude got right/wrong for each question.\n\n### Step 3: Run Additional Checks\n\nAnnounce additional checks will be performed.\n\nInvoke sub-agent to check for ambiguity, false assumptions, contradictions.\n\nSummarize any issues found.\n\n### Step 4: Report and Fix\n\nIf issues found:\nReport that Reader Claude struggled with specific issues.\n\nList the specific issues.\n\nIndicate intention to fix these gaps.\n\nLoop back to refinement for problematic sections.\n\n---\n\n**If no access to sub-agents (e.g., claude.ai web interface):**\n\nThe user will need to do the testing manually.\n\n### Step 1: Predict Reader Questions\n\nAsk what questions people might ask when trying to discover this document. What would they type into Claude.ai?\n\nGenerate 5-10 questions that readers would realistically ask.\n\n### Step 2: Setup Testing\n\nProvide testing instructions:\n1. Open a fresh Claude conversation: https://claude.ai\n2. Paste or share the document content (if using a shared doc platform with connectors enabled, provide the link)\n3. Ask Reader Claude the generated questions\n\nFor each question, instruct Reader Claude to provide:\n- The answer\n- Whether anything was ambiguous or unclear\n- What knowledge/context the doc assumes is already known\n\nCheck if Reader Claude gives correct answers or misinterprets anything.\n\n### Step 3: Additional Checks\n\nAlso ask Reader Claude:\n- \"What in this doc might be ambiguous or unclear to readers?\"\n- \"What knowledge or context does this doc assume readers already have?\"\n- \"Are there any internal contradictions or inconsistencies?\"\n\n### Step 4: Iterate Based on Results\n\nAsk what Reader Claude got wrong or struggled with. Indicate intention to fix those gaps.\n\nLoop back to refinement for any problematic sections.\n\n---\n\n### Exit Condition (Both Approaches)\n\nWhen Reader Claude consistently answers questions correctly and doesn't surface new gaps or ambiguities, the doc is ready.\n\n## Final Review\n\nWhen Reader Testing passes:\nAnnounce the doc has passed Reader Claude testing. Before completion:\n\n1. Recommend they do a final read-through themselves - they own this document and are responsible for its quality\n2. Suggest double-checking any facts, links, or technical details\n3. Ask them to verify it achieves the impact they wanted\n\nAsk if they want one more review, or if the work is done.\n\n**If user wants final review, provide it. Otherwise:**\nAnnounce document completion. Provide a few final tips:\n- Consider linking this conversation in an appendix so readers can see how the doc was developed\n- Use appendices to provide depth without bloating the main doc\n- Update the doc as feedback is received from real readers\n\n## Tips for Effective Guidance\n\n**Tone:**\n- Be direct and procedural\n- Explain rationale briefly when it affects user behavior\n- Don't try to \"sell\" the approach - just execute it\n\n**Handling Deviations:**\n- If user wants to skip a stage: Ask if they want to skip this and write freeform\n- If user seems frustrated: Acknowledge this is taking longer than expected. Suggest ways to move faster\n- Always give user agency to adjust the process\n\n**Context Management:**\n- Throughout, if context is missing on something mentioned, proactively ask\n- Don't let gaps accumulate - address them as they come up\n\n**Artifact Management:**\n- Use `create_file` for drafting full sections\n- Use `str_replace` for all edits\n- Provide artifact link after every change\n- Never use artifacts for brainstorming lists - that's just conversation\n\n**Quality over Speed:**\n- Don't rush through stages\n- Each iteration should make meaningful improvements\n- The goal is a document that actually works for readers"
              },
              {
                "name": "docx",
                "description": "Comprehensive document creation, editing, and analysis with support for tracked changes, comments, formatting preservation, and text extraction. When Claude needs to work with professional documents (.docx files) for: (1) Creating new documents, (2) Modifying or editing content, (3) Working with tracked changes, (4) Adding comments, or any other document tasks",
                "path": "skills/docx/SKILL.md",
                "frontmatter": {
                  "name": "docx",
                  "description": "Comprehensive document creation, editing, and analysis with support for tracked changes, comments, formatting preservation, and text extraction. When Claude needs to work with professional documents (.docx files) for: (1) Creating new documents, (2) Modifying or editing content, (3) Working with tracked changes, (4) Adding comments, or any other document tasks",
                  "license": "Proprietary. LICENSE.txt has complete terms"
                },
                "content": "# DOCX creation, editing, and analysis\n\n## Overview\n\nA user may ask you to create, edit, or analyze the contents of a .docx file. A .docx file is essentially a ZIP archive containing XML files and other resources that you can read or edit. You have different tools and workflows available for different tasks.\n\n## Workflow Decision Tree\n\n### Reading/Analyzing Content\nUse \"Text extraction\" or \"Raw XML access\" sections below\n\n### Creating New Document\nUse \"Creating a new Word document\" workflow\n\n### Editing Existing Document\n- **Your own document + simple changes**\n  Use \"Basic OOXML editing\" workflow\n\n- **Someone else's document**\n  Use **\"Redlining workflow\"** (recommended default)\n\n- **Legal, academic, business, or government docs**\n  Use **\"Redlining workflow\"** (required)\n\n## Reading and analyzing content\n\n### Text extraction\nIf you just need to read the text contents of a document, you should convert the document to markdown using pandoc. Pandoc provides excellent support for preserving document structure and can show tracked changes:\n\n```bash\n# Convert document to markdown with tracked changes\npandoc --track-changes=all path-to-file.docx -o output.md\n# Options: --track-changes=accept/reject/all\n```\n\n### Raw XML access\nYou need raw XML access for: comments, complex formatting, document structure, embedded media, and metadata. For any of these features, you'll need to unpack a document and read its raw XML contents.\n\n#### Unpacking a file\n`python ooxml/scripts/unpack.py <office_file> <output_directory>`\n\n#### Key file structures\n* `word/document.xml` - Main document contents\n* `word/comments.xml` - Comments referenced in document.xml\n* `word/media/` - Embedded images and media files\n* Tracked changes use `<w:ins>` (insertions) and `<w:del>` (deletions) tags\n\n## Creating a new Word document\n\nWhen creating a new Word document from scratch, use **docx-js**, which allows you to create Word documents using JavaScript/TypeScript.\n\n### Workflow\n1. **MANDATORY - READ ENTIRE FILE**: Read [`docx-js.md`](docx-js.md) (~500 lines) completely from start to finish. **NEVER set any range limits when reading this file.** Read the full file content for detailed syntax, critical formatting rules, and best practices before proceeding with document creation.\n2. Create a JavaScript/TypeScript file using Document, Paragraph, TextRun components (You can assume all dependencies are installed, but if not, refer to the dependencies section below)\n3. Export as .docx using Packer.toBuffer()\n\n## Editing an existing Word document\n\nWhen editing an existing Word document, use the **Document library** (a Python library for OOXML manipulation). The library automatically handles infrastructure setup and provides methods for document manipulation. For complex scenarios, you can access the underlying DOM directly through the library.\n\n### Workflow\n1. **MANDATORY - READ ENTIRE FILE**: Read [`ooxml.md`](ooxml.md) (~600 lines) completely from start to finish. **NEVER set any range limits when reading this file.** Read the full file content for the Document library API and XML patterns for directly editing document files.\n2. Unpack the document: `python ooxml/scripts/unpack.py <office_file> <output_directory>`\n3. Create and run a Python script using the Document library (see \"Document Library\" section in ooxml.md)\n4. Pack the final document: `python ooxml/scripts/pack.py <input_directory> <office_file>`\n\nThe Document library provides both high-level methods for common operations and direct DOM access for complex scenarios.\n\n## Redlining workflow for document review\n\nThis workflow allows you to plan comprehensive tracked changes using markdown before implementing them in OOXML. **CRITICAL**: For complete tracked changes, you must implement ALL changes systematically.\n\n**Batching Strategy**: Group related changes into batches of 3-10 changes. This makes debugging manageable while maintaining efficiency. Test each batch before moving to the next.\n\n**Principle: Minimal, Precise Edits**\nWhen implementing tracked changes, only mark text that actually changes. Repeating unchanged text makes edits harder to review and appears unprofessional. Break replacements into: [unchanged text] + [deletion] + [insertion] + [unchanged text]. Preserve the original run's RSID for unchanged text by extracting the `<w:r>` element from the original and reusing it.\n\nExample - Changing \"30 days\" to \"60 days\" in a sentence:\n```python\n# BAD - Replaces entire sentence\n'<w:del><w:r><w:delText>The term is 30 days.</w:delText></w:r></w:del><w:ins><w:r><w:t>The term is 60 days.</w:t></w:r></w:ins>'\n\n# GOOD - Only marks what changed, preserves original <w:r> for unchanged text\n'<w:r w:rsidR=\"00AB12CD\"><w:t>The term is </w:t></w:r><w:del><w:r><w:delText>30</w:delText></w:r></w:del><w:ins><w:r><w:t>60</w:t></w:r></w:ins><w:r w:rsidR=\"00AB12CD\"><w:t> days.</w:t></w:r>'\n```\n\n### Tracked changes workflow\n\n1. **Get markdown representation**: Convert document to markdown with tracked changes preserved:\n   ```bash\n   pandoc --track-changes=all path-to-file.docx -o current.md\n   ```\n\n2. **Identify and group changes**: Review the document and identify ALL changes needed, organizing them into logical batches:\n\n   **Location methods** (for finding changes in XML):\n   - Section/heading numbers (e.g., \"Section 3.2\", \"Article IV\")\n   - Paragraph identifiers if numbered\n   - Grep patterns with unique surrounding text\n   - Document structure (e.g., \"first paragraph\", \"signature block\")\n   - **DO NOT use markdown line numbers** - they don't map to XML structure\n\n   **Batch organization** (group 3-10 related changes per batch):\n   - By section: \"Batch 1: Section 2 amendments\", \"Batch 2: Section 5 updates\"\n   - By type: \"Batch 1: Date corrections\", \"Batch 2: Party name changes\"\n   - By complexity: Start with simple text replacements, then tackle complex structural changes\n   - Sequential: \"Batch 1: Pages 1-3\", \"Batch 2: Pages 4-6\"\n\n3. **Read documentation and unpack**:\n   - **MANDATORY - READ ENTIRE FILE**: Read [`ooxml.md`](ooxml.md) (~600 lines) completely from start to finish. **NEVER set any range limits when reading this file.** Pay special attention to the \"Document Library\" and \"Tracked Change Patterns\" sections.\n   - **Unpack the document**: `python ooxml/scripts/unpack.py <file.docx> <dir>`\n   - **Note the suggested RSID**: The unpack script will suggest an RSID to use for your tracked changes. Copy this RSID for use in step 4b.\n\n4. **Implement changes in batches**: Group changes logically (by section, by type, or by proximity) and implement them together in a single script. This approach:\n   - Makes debugging easier (smaller batch = easier to isolate errors)\n   - Allows incremental progress\n   - Maintains efficiency (batch size of 3-10 changes works well)\n\n   **Suggested batch groupings:**\n   - By document section (e.g., \"Section 3 changes\", \"Definitions\", \"Termination clause\")\n   - By change type (e.g., \"Date changes\", \"Party name updates\", \"Legal term replacements\")\n   - By proximity (e.g., \"Changes on pages 1-3\", \"Changes in first half of document\")\n\n   For each batch of related changes:\n\n   **a. Map text to XML**: Grep for text in `word/document.xml` to verify how text is split across `<w:r>` elements.\n\n   **b. Create and run script**: Use `get_node` to find nodes, implement changes, then `doc.save()`. See **\"Document Library\"** section in ooxml.md for patterns.\n\n   **Note**: Always grep `word/document.xml` immediately before writing a script to get current line numbers and verify text content. Line numbers change after each script run.\n\n5. **Pack the document**: After all batches are complete, convert the unpacked directory back to .docx:\n   ```bash\n   python ooxml/scripts/pack.py unpacked reviewed-document.docx\n   ```\n\n6. **Final verification**: Do a comprehensive check of the complete document:\n   - Convert final document to markdown:\n     ```bash\n     pandoc --track-changes=all reviewed-document.docx -o verification.md\n     ```\n   - Verify ALL changes were applied correctly:\n     ```bash\n     grep \"original phrase\" verification.md  # Should NOT find it\n     grep \"replacement phrase\" verification.md  # Should find it\n     ```\n   - Check that no unintended changes were introduced\n\n\n## Converting Documents to Images\n\nTo visually analyze Word documents, convert them to images using a two-step process:\n\n1. **Convert DOCX to PDF**:\n   ```bash\n   soffice --headless --convert-to pdf document.docx\n   ```\n\n2. **Convert PDF pages to JPEG images**:\n   ```bash\n   pdftoppm -jpeg -r 150 document.pdf page\n   ```\n   This creates files like `page-1.jpg`, `page-2.jpg`, etc.\n\nOptions:\n- `-r 150`: Sets resolution to 150 DPI (adjust for quality/size balance)\n- `-jpeg`: Output JPEG format (use `-png` for PNG if preferred)\n- `-f N`: First page to convert (e.g., `-f 2` starts from page 2)\n- `-l N`: Last page to convert (e.g., `-l 5` stops at page 5)\n- `page`: Prefix for output files\n\nExample for specific range:\n```bash\npdftoppm -jpeg -r 150 -f 2 -l 5 document.pdf page  # Converts only pages 2-5\n```\n\n## Code Style Guidelines\n**IMPORTANT**: When generating code for DOCX operations:\n- Write concise code\n- Avoid verbose variable names and redundant operations\n- Avoid unnecessary print statements\n\n## Dependencies\n\nRequired dependencies (install if not available):\n\n- **pandoc**: `sudo apt-get install pandoc` (for text extraction)\n- **docx**: `npm install -g docx` (for creating new documents)\n- **LibreOffice**: `sudo apt-get install libreoffice` (for PDF conversion)\n- **Poppler**: `sudo apt-get install poppler-utils` (for pdftoppm to convert PDF to images)\n- **defusedxml**: `pip install defusedxml` (for secure XML parsing)"
              },
              {
                "name": "frontend-design",
                "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, artifacts, posters, or applications (examples include websites, landing pages, dashboards, React components, HTML/CSS layouts, or when styling/beautifying any web UI). Generates creative, polished code and UI design that avoids generic AI aesthetics.",
                "path": "skills/frontend-design/SKILL.md",
                "frontmatter": {
                  "name": "frontend-design",
                  "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, artifacts, posters, or applications (examples include websites, landing pages, dashboards, React components, HTML/CSS layouts, or when styling/beautifying any web UI). Generates creative, polished code and UI design that avoids generic AI aesthetics.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "This skill guides creation of distinctive, production-grade frontend interfaces that avoid generic \"AI slop\" aesthetics. Implement real working code with exceptional attention to aesthetic details and creative choices.\n\nThe user provides frontend requirements: a component, page, application, or interface to build. They may include context about the purpose, audience, or technical constraints.\n\n## Design Thinking\n\nBefore coding, understand the context and commit to a BOLD aesthetic direction:\n- **Purpose**: What problem does this interface solve? Who uses it?\n- **Tone**: Pick an extreme: brutally minimal, maximalist chaos, retro-futuristic, organic/natural, luxury/refined, playful/toy-like, editorial/magazine, brutalist/raw, art deco/geometric, soft/pastel, industrial/utilitarian, etc. There are so many flavors to choose from. Use these for inspiration but design one that is true to the aesthetic direction.\n- **Constraints**: Technical requirements (framework, performance, accessibility).\n- **Differentiation**: What makes this UNFORGETTABLE? What's the one thing someone will remember?\n\n**CRITICAL**: Choose a clear conceptual direction and execute it with precision. Bold maximalism and refined minimalism both work - the key is intentionality, not intensity.\n\nThen implement working code (HTML/CSS/JS, React, Vue, etc.) that is:\n- Production-grade and functional\n- Visually striking and memorable\n- Cohesive with a clear aesthetic point-of-view\n- Meticulously refined in every detail\n\n## Frontend Aesthetics Guidelines\n\nFocus on:\n- **Typography**: Choose fonts that are beautiful, unique, and interesting. Avoid generic fonts like Arial and Inter; opt instead for distinctive choices that elevate the frontend's aesthetics; unexpected, characterful font choices. Pair a distinctive display font with a refined body font.\n- **Color & Theme**: Commit to a cohesive aesthetic. Use CSS variables for consistency. Dominant colors with sharp accents outperform timid, evenly-distributed palettes.\n- **Motion**: Use animations for effects and micro-interactions. Prioritize CSS-only solutions for HTML. Use Motion library for React when available. Focus on high-impact moments: one well-orchestrated page load with staggered reveals (animation-delay) creates more delight than scattered micro-interactions. Use scroll-triggering and hover states that surprise.\n- **Spatial Composition**: Unexpected layouts. Asymmetry. Overlap. Diagonal flow. Grid-breaking elements. Generous negative space OR controlled density.\n- **Backgrounds & Visual Details**: Create atmosphere and depth rather than defaulting to solid colors. Add contextual effects and textures that match the overall aesthetic. Apply creative forms like gradient meshes, noise textures, geometric patterns, layered transparencies, dramatic shadows, decorative borders, custom cursors, and grain overlays.\n\nNEVER use generic AI-generated aesthetics like overused font families (Inter, Roboto, Arial, system fonts), cliched color schemes (particularly purple gradients on white backgrounds), predictable layouts and component patterns, and cookie-cutter design that lacks context-specific character.\n\nInterpret creatively and make unexpected choices that feel genuinely designed for the context. No design should be the same. Vary between light and dark themes, different fonts, different aesthetics. NEVER converge on common choices (Space Grotesk, for example) across generations.\n\n**IMPORTANT**: Match implementation complexity to the aesthetic vision. Maximalist designs need elaborate code with extensive animations and effects. Minimalist or refined designs need restraint, precision, and careful attention to spacing, typography, and subtle details. Elegance comes from executing the vision well.\n\nRemember: Claude is capable of extraordinary creative work. Don't hold back, show what can truly be created when thinking outside the box and committing fully to a distinctive vision."
              },
              {
                "name": "internal-comms",
                "description": "A set of resources to help me write all kinds of internal communications, using the formats that my company likes to use. Claude should use this skill whenever asked to write some sort of internal communications (status reports, leadership updates, 3P updates, company newsletters, FAQs, incident reports, project updates, etc.).",
                "path": "skills/internal-comms/SKILL.md",
                "frontmatter": {
                  "name": "internal-comms",
                  "description": "A set of resources to help me write all kinds of internal communications, using the formats that my company likes to use. Claude should use this skill whenever asked to write some sort of internal communications (status reports, leadership updates, 3P updates, company newsletters, FAQs, incident reports, project updates, etc.).",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "## When to use this skill\nTo write internal communications, use this skill for:\n- 3P updates (Progress, Plans, Problems)\n- Company newsletters\n- FAQ responses\n- Status reports\n- Leadership updates\n- Project updates\n- Incident reports\n\n## How to use this skill\n\nTo write any internal communication:\n\n1. **Identify the communication type** from the request\n2. **Load the appropriate guideline file** from the `examples/` directory:\n    - `examples/3p-updates.md` - For Progress/Plans/Problems team updates\n    - `examples/company-newsletter.md` - For company-wide newsletters\n    - `examples/faq-answers.md` - For answering frequently asked questions\n    - `examples/general-comms.md` - For anything else that doesn't explicitly match one of the above\n3. **Follow the specific instructions** in that file for formatting, tone, and content gathering\n\nIf the communication type doesn't match any existing guideline, ask for clarification or more context about the desired format.\n\n## Keywords\n3P updates, company newsletter, company comms, weekly update, faqs, common questions, updates, internal comms"
              },
              {
                "name": "mcp-builder",
                "description": "Guide for creating high-quality MCP (Model Context Protocol) servers that enable LLMs to interact with external services through well-designed tools. Use when building MCP servers to integrate external APIs or services, whether in Python (FastMCP) or Node/TypeScript (MCP SDK).",
                "path": "skills/mcp-builder/SKILL.md",
                "frontmatter": {
                  "name": "mcp-builder",
                  "description": "Guide for creating high-quality MCP (Model Context Protocol) servers that enable LLMs to interact with external services through well-designed tools. Use when building MCP servers to integrate external APIs or services, whether in Python (FastMCP) or Node/TypeScript (MCP SDK).",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "# MCP Server Development Guide\n\n## Overview\n\nCreate MCP (Model Context Protocol) servers that enable LLMs to interact with external services through well-designed tools. The quality of an MCP server is measured by how well it enables LLMs to accomplish real-world tasks.\n\n---\n\n# Process\n\n## ðŸš€ High-Level Workflow\n\nCreating a high-quality MCP server involves four main phases:\n\n### Phase 1: Deep Research and Planning\n\n#### 1.1 Understand Modern MCP Design\n\n**API Coverage vs. Workflow Tools:**\nBalance comprehensive API endpoint coverage with specialized workflow tools. Workflow tools can be more convenient for specific tasks, while comprehensive coverage gives agents flexibility to compose operations. Performance varies by clientâ€”some clients benefit from code execution that combines basic tools, while others work better with higher-level workflows. When uncertain, prioritize comprehensive API coverage.\n\n**Tool Naming and Discoverability:**\nClear, descriptive tool names help agents find the right tools quickly. Use consistent prefixes (e.g., `github_create_issue`, `github_list_repos`) and action-oriented naming.\n\n**Context Management:**\nAgents benefit from concise tool descriptions and the ability to filter/paginate results. Design tools that return focused, relevant data. Some clients support code execution which can help agents filter and process data efficiently.\n\n**Actionable Error Messages:**\nError messages should guide agents toward solutions with specific suggestions and next steps.\n\n#### 1.2 Study MCP Protocol Documentation\n\n**Navigate the MCP specification:**\n\nStart with the sitemap to find relevant pages: `https://modelcontextprotocol.io/sitemap.xml`\n\nThen fetch specific pages with `.md` suffix for markdown format (e.g., `https://modelcontextprotocol.io/specification/draft.md`).\n\nKey pages to review:\n- Specification overview and architecture\n- Transport mechanisms (streamable HTTP, stdio)\n- Tool, resource, and prompt definitions\n\n#### 1.3 Study Framework Documentation\n\n**Recommended stack:**\n- **Language**: TypeScript (high-quality SDK support and good compatibility in many execution environments e.g. MCPB. Plus AI models are good at generating TypeScript code, benefiting from its broad usage, static typing and good linting tools)\n- **Transport**: Streamable HTTP for remote servers, using stateless JSON (simpler to scale and maintain, as opposed to stateful sessions and streaming responses). stdio for local servers.\n\n**Load framework documentation:**\n\n- **MCP Best Practices**: [ðŸ“‹ View Best Practices](./reference/mcp_best_practices.md) - Core guidelines\n\n**For TypeScript (recommended):**\n- **TypeScript SDK**: Use WebFetch to load `https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/main/README.md`\n- [âš¡ TypeScript Guide](./reference/node_mcp_server.md) - TypeScript patterns and examples\n\n**For Python:**\n- **Python SDK**: Use WebFetch to load `https://raw.githubusercontent.com/modelcontextprotocol/python-sdk/main/README.md`\n- [ðŸ Python Guide](./reference/python_mcp_server.md) - Python patterns and examples\n\n#### 1.4 Plan Your Implementation\n\n**Understand the API:**\nReview the service's API documentation to identify key endpoints, authentication requirements, and data models. Use web search and WebFetch as needed.\n\n**Tool Selection:**\nPrioritize comprehensive API coverage. List endpoints to implement, starting with the most common operations.\n\n---\n\n### Phase 2: Implementation\n\n#### 2.1 Set Up Project Structure\n\nSee language-specific guides for project setup:\n- [âš¡ TypeScript Guide](./reference/node_mcp_server.md) - Project structure, package.json, tsconfig.json\n- [ðŸ Python Guide](./reference/python_mcp_server.md) - Module organization, dependencies\n\n#### 2.2 Implement Core Infrastructure\n\nCreate shared utilities:\n- API client with authentication\n- Error handling helpers\n- Response formatting (JSON/Markdown)\n- Pagination support\n\n#### 2.3 Implement Tools\n\nFor each tool:\n\n**Input Schema:**\n- Use Zod (TypeScript) or Pydantic (Python)\n- Include constraints and clear descriptions\n- Add examples in field descriptions\n\n**Output Schema:**\n- Define `outputSchema` where possible for structured data\n- Use `structuredContent` in tool responses (TypeScript SDK feature)\n- Helps clients understand and process tool outputs\n\n**Tool Description:**\n- Concise summary of functionality\n- Parameter descriptions\n- Return type schema\n\n**Implementation:**\n- Async/await for I/O operations\n- Proper error handling with actionable messages\n- Support pagination where applicable\n- Return both text content and structured data when using modern SDKs\n\n**Annotations:**\n- `readOnlyHint`: true/false\n- `destructiveHint`: true/false\n- `idempotentHint`: true/false\n- `openWorldHint`: true/false\n\n---\n\n### Phase 3: Review and Test\n\n#### 3.1 Code Quality\n\nReview for:\n- No duplicated code (DRY principle)\n- Consistent error handling\n- Full type coverage\n- Clear tool descriptions\n\n#### 3.2 Build and Test\n\n**TypeScript:**\n- Run `npm run build` to verify compilation\n- Test with MCP Inspector: `npx @modelcontextprotocol/inspector`\n\n**Python:**\n- Verify syntax: `python -m py_compile your_server.py`\n- Test with MCP Inspector\n\nSee language-specific guides for detailed testing approaches and quality checklists.\n\n---\n\n### Phase 4: Create Evaluations\n\nAfter implementing your MCP server, create comprehensive evaluations to test its effectiveness.\n\n**Load [âœ… Evaluation Guide](./reference/evaluation.md) for complete evaluation guidelines.**\n\n#### 4.1 Understand Evaluation Purpose\n\nUse evaluations to test whether LLMs can effectively use your MCP server to answer realistic, complex questions.\n\n#### 4.2 Create 10 Evaluation Questions\n\nTo create effective evaluations, follow the process outlined in the evaluation guide:\n\n1. **Tool Inspection**: List available tools and understand their capabilities\n2. **Content Exploration**: Use READ-ONLY operations to explore available data\n3. **Question Generation**: Create 10 complex, realistic questions\n4. **Answer Verification**: Solve each question yourself to verify answers\n\n#### 4.3 Evaluation Requirements\n\nEnsure each question is:\n- **Independent**: Not dependent on other questions\n- **Read-only**: Only non-destructive operations required\n- **Complex**: Requiring multiple tool calls and deep exploration\n- **Realistic**: Based on real use cases humans would care about\n- **Verifiable**: Single, clear answer that can be verified by string comparison\n- **Stable**: Answer won't change over time\n\n#### 4.4 Output Format\n\nCreate an XML file with this structure:\n\n```xml\n<evaluation>\n  <qa_pair>\n    <question>Find discussions about AI model launches with animal codenames. One model needed a specific safety designation that uses the format ASL-X. What number X was being determined for the model named after a spotted wild cat?</question>\n    <answer>3</answer>\n  </qa_pair>\n<!-- More qa_pairs... -->\n</evaluation>\n```\n\n---\n\n# Reference Files\n\n## ðŸ“š Documentation Library\n\nLoad these resources as needed during development:\n\n### Core MCP Documentation (Load First)\n- **MCP Protocol**: Start with sitemap at `https://modelcontextprotocol.io/sitemap.xml`, then fetch specific pages with `.md` suffix\n- [ðŸ“‹ MCP Best Practices](./reference/mcp_best_practices.md) - Universal MCP guidelines including:\n  - Server and tool naming conventions\n  - Response format guidelines (JSON vs Markdown)\n  - Pagination best practices\n  - Transport selection (streamable HTTP vs stdio)\n  - Security and error handling standards\n\n### SDK Documentation (Load During Phase 1/2)\n- **Python SDK**: Fetch from `https://raw.githubusercontent.com/modelcontextprotocol/python-sdk/main/README.md`\n- **TypeScript SDK**: Fetch from `https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/main/README.md`\n\n### Language-Specific Implementation Guides (Load During Phase 2)\n- [ðŸ Python Implementation Guide](./reference/python_mcp_server.md) - Complete Python/FastMCP guide with:\n  - Server initialization patterns\n  - Pydantic model examples\n  - Tool registration with `@mcp.tool`\n  - Complete working examples\n  - Quality checklist\n\n- [âš¡ TypeScript Implementation Guide](./reference/node_mcp_server.md) - Complete TypeScript guide with:\n  - Project structure\n  - Zod schema patterns\n  - Tool registration with `server.registerTool`\n  - Complete working examples\n  - Quality checklist\n\n### Evaluation Guide (Load During Phase 4)\n- [âœ… Evaluation Guide](./reference/evaluation.md) - Complete evaluation creation guide with:\n  - Question creation guidelines\n  - Answer verification strategies\n  - XML format specifications\n  - Example questions and answers\n  - Running an evaluation with the provided scripts"
              },
              {
                "name": "pdf",
                "description": "Comprehensive PDF manipulation toolkit for extracting text and tables, creating new PDFs, merging/splitting documents, and handling forms. When Claude needs to fill in a PDF form or programmatically process, generate, or analyze PDF documents at scale.",
                "path": "skills/pdf/SKILL.md",
                "frontmatter": {
                  "name": "pdf",
                  "description": "Comprehensive PDF manipulation toolkit for extracting text and tables, creating new PDFs, merging/splitting documents, and handling forms. When Claude needs to fill in a PDF form or programmatically process, generate, or analyze PDF documents at scale.",
                  "license": "Proprietary. LICENSE.txt has complete terms"
                },
                "content": "# PDF Processing Guide\n\n## Overview\n\nThis guide covers essential PDF processing operations using Python libraries and command-line tools. For advanced features, JavaScript libraries, and detailed examples, see reference.md. If you need to fill out a PDF form, read forms.md and follow its instructions.\n\n## Quick Start\n\n```python\nfrom pypdf import PdfReader, PdfWriter\n\n# Read a PDF\nreader = PdfReader(\"document.pdf\")\nprint(f\"Pages: {len(reader.pages)}\")\n\n# Extract text\ntext = \"\"\nfor page in reader.pages:\n    text += page.extract_text()\n```\n\n## Python Libraries\n\n### pypdf - Basic Operations\n\n#### Merge PDFs\n```python\nfrom pypdf import PdfWriter, PdfReader\n\nwriter = PdfWriter()\nfor pdf_file in [\"doc1.pdf\", \"doc2.pdf\", \"doc3.pdf\"]:\n    reader = PdfReader(pdf_file)\n    for page in reader.pages:\n        writer.add_page(page)\n\nwith open(\"merged.pdf\", \"wb\") as output:\n    writer.write(output)\n```\n\n#### Split PDF\n```python\nreader = PdfReader(\"input.pdf\")\nfor i, page in enumerate(reader.pages):\n    writer = PdfWriter()\n    writer.add_page(page)\n    with open(f\"page_{i+1}.pdf\", \"wb\") as output:\n        writer.write(output)\n```\n\n#### Extract Metadata\n```python\nreader = PdfReader(\"document.pdf\")\nmeta = reader.metadata\nprint(f\"Title: {meta.title}\")\nprint(f\"Author: {meta.author}\")\nprint(f\"Subject: {meta.subject}\")\nprint(f\"Creator: {meta.creator}\")\n```\n\n#### Rotate Pages\n```python\nreader = PdfReader(\"input.pdf\")\nwriter = PdfWriter()\n\npage = reader.pages[0]\npage.rotate(90)  # Rotate 90 degrees clockwise\nwriter.add_page(page)\n\nwith open(\"rotated.pdf\", \"wb\") as output:\n    writer.write(output)\n```\n\n### pdfplumber - Text and Table Extraction\n\n#### Extract Text with Layout\n```python\nimport pdfplumber\n\nwith pdfplumber.open(\"document.pdf\") as pdf:\n    for page in pdf.pages:\n        text = page.extract_text()\n        print(text)\n```\n\n#### Extract Tables\n```python\nwith pdfplumber.open(\"document.pdf\") as pdf:\n    for i, page in enumerate(pdf.pages):\n        tables = page.extract_tables()\n        for j, table in enumerate(tables):\n            print(f\"Table {j+1} on page {i+1}:\")\n            for row in table:\n                print(row)\n```\n\n#### Advanced Table Extraction\n```python\nimport pandas as pd\n\nwith pdfplumber.open(\"document.pdf\") as pdf:\n    all_tables = []\n    for page in pdf.pages:\n        tables = page.extract_tables()\n        for table in tables:\n            if table:  # Check if table is not empty\n                df = pd.DataFrame(table[1:], columns=table[0])\n                all_tables.append(df)\n\n# Combine all tables\nif all_tables:\n    combined_df = pd.concat(all_tables, ignore_index=True)\n    combined_df.to_excel(\"extracted_tables.xlsx\", index=False)\n```\n\n### reportlab - Create PDFs\n\n#### Basic PDF Creation\n```python\nfrom reportlab.lib.pagesizes import letter\nfrom reportlab.pdfgen import canvas\n\nc = canvas.Canvas(\"hello.pdf\", pagesize=letter)\nwidth, height = letter\n\n# Add text\nc.drawString(100, height - 100, \"Hello World!\")\nc.drawString(100, height - 120, \"This is a PDF created with reportlab\")\n\n# Add a line\nc.line(100, height - 140, 400, height - 140)\n\n# Save\nc.save()\n```\n\n#### Create PDF with Multiple Pages\n```python\nfrom reportlab.lib.pagesizes import letter\nfrom reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak\nfrom reportlab.lib.styles import getSampleStyleSheet\n\ndoc = SimpleDocTemplate(\"report.pdf\", pagesize=letter)\nstyles = getSampleStyleSheet()\nstory = []\n\n# Add content\ntitle = Paragraph(\"Report Title\", styles['Title'])\nstory.append(title)\nstory.append(Spacer(1, 12))\n\nbody = Paragraph(\"This is the body of the report. \" * 20, styles['Normal'])\nstory.append(body)\nstory.append(PageBreak())\n\n# Page 2\nstory.append(Paragraph(\"Page 2\", styles['Heading1']))\nstory.append(Paragraph(\"Content for page 2\", styles['Normal']))\n\n# Build PDF\ndoc.build(story)\n```\n\n## Command-Line Tools\n\n### pdftotext (poppler-utils)\n```bash\n# Extract text\npdftotext input.pdf output.txt\n\n# Extract text preserving layout\npdftotext -layout input.pdf output.txt\n\n# Extract specific pages\npdftotext -f 1 -l 5 input.pdf output.txt  # Pages 1-5\n```\n\n### qpdf\n```bash\n# Merge PDFs\nqpdf --empty --pages file1.pdf file2.pdf -- merged.pdf\n\n# Split pages\nqpdf input.pdf --pages . 1-5 -- pages1-5.pdf\nqpdf input.pdf --pages . 6-10 -- pages6-10.pdf\n\n# Rotate pages\nqpdf input.pdf output.pdf --rotate=+90:1  # Rotate page 1 by 90 degrees\n\n# Remove password\nqpdf --password=mypassword --decrypt encrypted.pdf decrypted.pdf\n```\n\n### pdftk (if available)\n```bash\n# Merge\npdftk file1.pdf file2.pdf cat output merged.pdf\n\n# Split\npdftk input.pdf burst\n\n# Rotate\npdftk input.pdf rotate 1east output rotated.pdf\n```\n\n## Common Tasks\n\n### Extract Text from Scanned PDFs\n```python\n# Requires: pip install pytesseract pdf2image\nimport pytesseract\nfrom pdf2image import convert_from_path\n\n# Convert PDF to images\nimages = convert_from_path('scanned.pdf')\n\n# OCR each page\ntext = \"\"\nfor i, image in enumerate(images):\n    text += f\"Page {i+1}:\\n\"\n    text += pytesseract.image_to_string(image)\n    text += \"\\n\\n\"\n\nprint(text)\n```\n\n### Add Watermark\n```python\nfrom pypdf import PdfReader, PdfWriter\n\n# Create watermark (or load existing)\nwatermark = PdfReader(\"watermark.pdf\").pages[0]\n\n# Apply to all pages\nreader = PdfReader(\"document.pdf\")\nwriter = PdfWriter()\n\nfor page in reader.pages:\n    page.merge_page(watermark)\n    writer.add_page(page)\n\nwith open(\"watermarked.pdf\", \"wb\") as output:\n    writer.write(output)\n```\n\n### Extract Images\n```bash\n# Using pdfimages (poppler-utils)\npdfimages -j input.pdf output_prefix\n\n# This extracts all images as output_prefix-000.jpg, output_prefix-001.jpg, etc.\n```\n\n### Password Protection\n```python\nfrom pypdf import PdfReader, PdfWriter\n\nreader = PdfReader(\"input.pdf\")\nwriter = PdfWriter()\n\nfor page in reader.pages:\n    writer.add_page(page)\n\n# Add password\nwriter.encrypt(\"userpassword\", \"ownerpassword\")\n\nwith open(\"encrypted.pdf\", \"wb\") as output:\n    writer.write(output)\n```\n\n## Quick Reference\n\n| Task | Best Tool | Command/Code |\n|------|-----------|--------------|\n| Merge PDFs | pypdf | `writer.add_page(page)` |\n| Split PDFs | pypdf | One page per file |\n| Extract text | pdfplumber | `page.extract_text()` |\n| Extract tables | pdfplumber | `page.extract_tables()` |\n| Create PDFs | reportlab | Canvas or Platypus |\n| Command line merge | qpdf | `qpdf --empty --pages ...` |\n| OCR scanned PDFs | pytesseract | Convert to image first |\n| Fill PDF forms | pdf-lib or pypdf (see forms.md) | See forms.md |\n\n## Next Steps\n\n- For advanced pypdfium2 usage, see reference.md\n- For JavaScript libraries (pdf-lib), see reference.md\n- If you need to fill out a PDF form, follow the instructions in forms.md\n- For troubleshooting guides, see reference.md"
              },
              {
                "name": "pptx",
                "description": "Presentation creation, editing, and analysis. When Claude needs to work with presentations (.pptx files) for: (1) Creating new presentations, (2) Modifying or editing content, (3) Working with layouts, (4) Adding comments or speaker notes, or any other presentation tasks",
                "path": "skills/pptx/SKILL.md",
                "frontmatter": {
                  "name": "pptx",
                  "description": "Presentation creation, editing, and analysis. When Claude needs to work with presentations (.pptx files) for: (1) Creating new presentations, (2) Modifying or editing content, (3) Working with layouts, (4) Adding comments or speaker notes, or any other presentation tasks",
                  "license": "Proprietary. LICENSE.txt has complete terms"
                },
                "content": "# PPTX creation, editing, and analysis\n\n## Overview\n\nA user may ask you to create, edit, or analyze the contents of a .pptx file. A .pptx file is essentially a ZIP archive containing XML files and other resources that you can read or edit. You have different tools and workflows available for different tasks.\n\n## Reading and analyzing content\n\n### Text extraction\nIf you just need to read the text contents of a presentation, you should convert the document to markdown:\n\n```bash\n# Convert document to markdown\npython -m markitdown path-to-file.pptx\n```\n\n### Raw XML access\nYou need raw XML access for: comments, speaker notes, slide layouts, animations, design elements, and complex formatting. For any of these features, you'll need to unpack a presentation and read its raw XML contents.\n\n#### Unpacking a file\n`python ooxml/scripts/unpack.py <office_file> <output_dir>`\n\n**Note**: The unpack.py script is located at `skills/pptx/ooxml/scripts/unpack.py` relative to the project root. If the script doesn't exist at this path, use `find . -name \"unpack.py\"` to locate it.\n\n#### Key file structures\n* `ppt/presentation.xml` - Main presentation metadata and slide references\n* `ppt/slides/slide{N}.xml` - Individual slide contents (slide1.xml, slide2.xml, etc.)\n* `ppt/notesSlides/notesSlide{N}.xml` - Speaker notes for each slide\n* `ppt/comments/modernComment_*.xml` - Comments for specific slides\n* `ppt/slideLayouts/` - Layout templates for slides\n* `ppt/slideMasters/` - Master slide templates\n* `ppt/theme/` - Theme and styling information\n* `ppt/media/` - Images and other media files\n\n#### Typography and color extraction\n**When given an example design to emulate**: Always analyze the presentation's typography and colors first using the methods below:\n1. **Read theme file**: Check `ppt/theme/theme1.xml` for colors (`<a:clrScheme>`) and fonts (`<a:fontScheme>`)\n2. **Sample slide content**: Examine `ppt/slides/slide1.xml` for actual font usage (`<a:rPr>`) and colors\n3. **Search for patterns**: Use grep to find color (`<a:solidFill>`, `<a:srgbClr>`) and font references across all XML files\n\n## Creating a new PowerPoint presentation **without a template**\n\nWhen creating a new PowerPoint presentation from scratch, use the **html2pptx** workflow to convert HTML slides to PowerPoint with accurate positioning.\n\n### Design Principles\n\n**CRITICAL**: Before creating any presentation, analyze the content and choose appropriate design elements:\n1. **Consider the subject matter**: What is this presentation about? What tone, industry, or mood does it suggest?\n2. **Check for branding**: If the user mentions a company/organization, consider their brand colors and identity\n3. **Match palette to content**: Select colors that reflect the subject\n4. **State your approach**: Explain your design choices before writing code\n\n**Requirements**:\n- âœ… State your content-informed design approach BEFORE writing code\n- âœ… Use web-safe fonts only: Arial, Helvetica, Times New Roman, Georgia, Courier New, Verdana, Tahoma, Trebuchet MS, Impact\n- âœ… Create clear visual hierarchy through size, weight, and color\n- âœ… Ensure readability: strong contrast, appropriately sized text, clean alignment\n- âœ… Be consistent: repeat patterns, spacing, and visual language across slides\n\n#### Color Palette Selection\n\n**Choosing colors creatively**:\n- **Think beyond defaults**: What colors genuinely match this specific topic? Avoid autopilot choices.\n- **Consider multiple angles**: Topic, industry, mood, energy level, target audience, brand identity (if mentioned)\n- **Be adventurous**: Try unexpected combinations - a healthcare presentation doesn't have to be green, finance doesn't have to be navy\n- **Build your palette**: Pick 3-5 colors that work together (dominant colors + supporting tones + accent)\n- **Ensure contrast**: Text must be clearly readable on backgrounds\n\n**Example color palettes** (use these to spark creativity - choose one, adapt it, or create your own):\n\n1. **Classic Blue**: Deep navy (#1C2833), slate gray (#2E4053), silver (#AAB7B8), off-white (#F4F6F6)\n2. **Teal & Coral**: Teal (#5EA8A7), deep teal (#277884), coral (#FE4447), white (#FFFFFF)\n3. **Bold Red**: Red (#C0392B), bright red (#E74C3C), orange (#F39C12), yellow (#F1C40F), green (#2ECC71)\n4. **Warm Blush**: Mauve (#A49393), blush (#EED6D3), rose (#E8B4B8), cream (#FAF7F2)\n5. **Burgundy Luxury**: Burgundy (#5D1D2E), crimson (#951233), rust (#C15937), gold (#997929)\n6. **Deep Purple & Emerald**: Purple (#B165FB), dark blue (#181B24), emerald (#40695B), white (#FFFFFF)\n7. **Cream & Forest Green**: Cream (#FFE1C7), forest green (#40695B), white (#FCFCFC)\n8. **Pink & Purple**: Pink (#F8275B), coral (#FF574A), rose (#FF737D), purple (#3D2F68)\n9. **Lime & Plum**: Lime (#C5DE82), plum (#7C3A5F), coral (#FD8C6E), blue-gray (#98ACB5)\n10. **Black & Gold**: Gold (#BF9A4A), black (#000000), cream (#F4F6F6)\n11. **Sage & Terracotta**: Sage (#87A96B), terracotta (#E07A5F), cream (#F4F1DE), charcoal (#2C2C2C)\n12. **Charcoal & Red**: Charcoal (#292929), red (#E33737), light gray (#CCCBCB)\n13. **Vibrant Orange**: Orange (#F96D00), light gray (#F2F2F2), charcoal (#222831)\n14. **Forest Green**: Black (#191A19), green (#4E9F3D), dark green (#1E5128), white (#FFFFFF)\n15. **Retro Rainbow**: Purple (#722880), pink (#D72D51), orange (#EB5C18), amber (#F08800), gold (#DEB600)\n16. **Vintage Earthy**: Mustard (#E3B448), sage (#CBD18F), forest green (#3A6B35), cream (#F4F1DE)\n17. **Coastal Rose**: Old rose (#AD7670), beaver (#B49886), eggshell (#F3ECDC), ash gray (#BFD5BE)\n18. **Orange & Turquoise**: Light orange (#FC993E), grayish turquoise (#667C6F), white (#FCFCFC)\n\n#### Visual Details Options\n\n**Geometric Patterns**:\n- Diagonal section dividers instead of horizontal\n- Asymmetric column widths (30/70, 40/60, 25/75)\n- Rotated text headers at 90Â° or 270Â°\n- Circular/hexagonal frames for images\n- Triangular accent shapes in corners\n- Overlapping shapes for depth\n\n**Border & Frame Treatments**:\n- Thick single-color borders (10-20pt) on one side only\n- Double-line borders with contrasting colors\n- Corner brackets instead of full frames\n- L-shaped borders (top+left or bottom+right)\n- Underline accents beneath headers (3-5pt thick)\n\n**Typography Treatments**:\n- Extreme size contrast (72pt headlines vs 11pt body)\n- All-caps headers with wide letter spacing\n- Numbered sections in oversized display type\n- Monospace (Courier New) for data/stats/technical content\n- Condensed fonts (Arial Narrow) for dense information\n- Outlined text for emphasis\n\n**Chart & Data Styling**:\n- Monochrome charts with single accent color for key data\n- Horizontal bar charts instead of vertical\n- Dot plots instead of bar charts\n- Minimal gridlines or none at all\n- Data labels directly on elements (no legends)\n- Oversized numbers for key metrics\n\n**Layout Innovations**:\n- Full-bleed images with text overlays\n- Sidebar column (20-30% width) for navigation/context\n- Modular grid systems (3Ã—3, 4Ã—4 blocks)\n- Z-pattern or F-pattern content flow\n- Floating text boxes over colored shapes\n- Magazine-style multi-column layouts\n\n**Background Treatments**:\n- Solid color blocks occupying 40-60% of slide\n- Gradient fills (vertical or diagonal only)\n- Split backgrounds (two colors, diagonal or vertical)\n- Edge-to-edge color bands\n- Negative space as a design element\n\n### Layout Tips\n**When creating slides with charts or tables:**\n- **Two-column layout (PREFERRED)**: Use a header spanning the full width, then two columns below - text/bullets in one column and the featured content in the other. This provides better balance and makes charts/tables more readable. Use flexbox with unequal column widths (e.g., 40%/60% split) to optimize space for each content type.\n- **Full-slide layout**: Let the featured content (chart/table) take up the entire slide for maximum impact and readability\n- **NEVER vertically stack**: Do not place charts/tables below text in a single column - this causes poor readability and layout issues\n\n### Workflow\n1. **MANDATORY - READ ENTIRE FILE**: Read [`html2pptx.md`](html2pptx.md) completely from start to finish. **NEVER set any range limits when reading this file.** Read the full file content for detailed syntax, critical formatting rules, and best practices before proceeding with presentation creation.\n2. Create an HTML file for each slide with proper dimensions (e.g., 720pt Ã— 405pt for 16:9)\n   - Use `<p>`, `<h1>`-`<h6>`, `<ul>`, `<ol>` for all text content\n   - Use `class=\"placeholder\"` for areas where charts/tables will be added (render with gray background for visibility)\n   - **CRITICAL**: Rasterize gradients and icons as PNG images FIRST using Sharp, then reference in HTML\n   - **LAYOUT**: For slides with charts/tables/images, use either full-slide layout or two-column layout for better readability\n3. Create and run a JavaScript file using the [`html2pptx.js`](scripts/html2pptx.js) library to convert HTML slides to PowerPoint and save the presentation\n   - Use the `html2pptx()` function to process each HTML file\n   - Add charts and tables to placeholder areas using PptxGenJS API\n   - Save the presentation using `pptx.writeFile()`\n4. **Visual validation**: Generate thumbnails and inspect for layout issues\n   - Create thumbnail grid: `python scripts/thumbnail.py output.pptx workspace/thumbnails --cols 4`\n   - Read and carefully examine the thumbnail image for:\n     - **Text cutoff**: Text being cut off by header bars, shapes, or slide edges\n     - **Text overlap**: Text overlapping with other text or shapes\n     - **Positioning issues**: Content too close to slide boundaries or other elements\n     - **Contrast issues**: Insufficient contrast between text and backgrounds\n   - If issues found, adjust HTML margins/spacing/colors and regenerate the presentation\n   - Repeat until all slides are visually correct\n\n## Editing an existing PowerPoint presentation\n\nWhen edit slides in an existing PowerPoint presentation, you need to work with the raw Office Open XML (OOXML) format. This involves unpacking the .pptx file, editing the XML content, and repacking it.\n\n### Workflow\n1. **MANDATORY - READ ENTIRE FILE**: Read [`ooxml.md`](ooxml.md) (~500 lines) completely from start to finish.  **NEVER set any range limits when reading this file.**  Read the full file content for detailed guidance on OOXML structure and editing workflows before any presentation editing.\n2. Unpack the presentation: `python ooxml/scripts/unpack.py <office_file> <output_dir>`\n3. Edit the XML files (primarily `ppt/slides/slide{N}.xml` and related files)\n4. **CRITICAL**: Validate immediately after each edit and fix any validation errors before proceeding: `python ooxml/scripts/validate.py <dir> --original <file>`\n5. Pack the final presentation: `python ooxml/scripts/pack.py <input_directory> <office_file>`\n\n## Creating a new PowerPoint presentation **using a template**\n\nWhen you need to create a presentation that follows an existing template's design, you'll need to duplicate and re-arrange template slides before then replacing placeholder context.\n\n### Workflow\n1. **Extract template text AND create visual thumbnail grid**:\n   * Extract text: `python -m markitdown template.pptx > template-content.md`\n   * Read `template-content.md`: Read the entire file to understand the contents of the template presentation. **NEVER set any range limits when reading this file.**\n   * Create thumbnail grids: `python scripts/thumbnail.py template.pptx`\n   * See [Creating Thumbnail Grids](#creating-thumbnail-grids) section for more details\n\n2. **Analyze template and save inventory to a file**:\n   * **Visual Analysis**: Review thumbnail grid(s) to understand slide layouts, design patterns, and visual structure\n   * Create and save a template inventory file at `template-inventory.md` containing:\n     ```markdown\n     # Template Inventory Analysis\n     **Total Slides: [count]**\n     **IMPORTANT: Slides are 0-indexed (first slide = 0, last slide = count-1)**\n\n     ## [Category Name]\n     - Slide 0: [Layout code if available] - Description/purpose\n     - Slide 1: [Layout code] - Description/purpose\n     - Slide 2: [Layout code] - Description/purpose\n     [... EVERY slide must be listed individually with its index ...]\n     ```\n   * **Using the thumbnail grid**: Reference the visual thumbnails to identify:\n     - Layout patterns (title slides, content layouts, section dividers)\n     - Image placeholder locations and counts\n     - Design consistency across slide groups\n     - Visual hierarchy and structure\n   * This inventory file is REQUIRED for selecting appropriate templates in the next step\n\n3. **Create presentation outline based on template inventory**:\n   * Review available templates from step 2.\n   * Choose an intro or title template for the first slide. This should be one of the first templates.\n   * Choose safe, text-based layouts for the other slides.\n   * **CRITICAL: Match layout structure to actual content**:\n     - Single-column layouts: Use for unified narrative or single topic\n     - Two-column layouts: Use ONLY when you have exactly 2 distinct items/concepts\n     - Three-column layouts: Use ONLY when you have exactly 3 distinct items/concepts\n     - Image + text layouts: Use ONLY when you have actual images to insert\n     - Quote layouts: Use ONLY for actual quotes from people (with attribution), never for emphasis\n     - Never use layouts with more placeholders than you have content\n     - If you have 2 items, don't force them into a 3-column layout\n     - If you have 4+ items, consider breaking into multiple slides or using a list format\n   * Count your actual content pieces BEFORE selecting the layout\n   * Verify each placeholder in the chosen layout will be filled with meaningful content\n   * Select one option representing the **best** layout for each content section.\n   * Save `outline.md` with content AND template mapping that leverages available designs\n   * Example template mapping:\n      ```\n      # Template slides to use (0-based indexing)\n      # WARNING: Verify indices are within range! Template with 73 slides has indices 0-72\n      # Mapping: slide numbers from outline -> template slide indices\n      template_mapping = [\n          0,   # Use slide 0 (Title/Cover)\n          34,  # Use slide 34 (B1: Title and body)\n          34,  # Use slide 34 again (duplicate for second B1)\n          50,  # Use slide 50 (E1: Quote)\n          54,  # Use slide 54 (F2: Closing + Text)\n      ]\n      ```\n\n4. **Duplicate, reorder, and delete slides using `rearrange.py`**:\n   * Use the `scripts/rearrange.py` script to create a new presentation with slides in the desired order:\n     ```bash\n     python scripts/rearrange.py template.pptx working.pptx 0,34,34,50,52\n     ```\n   * The script handles duplicating repeated slides, deleting unused slides, and reordering automatically\n   * Slide indices are 0-based (first slide is 0, second is 1, etc.)\n   * The same slide index can appear multiple times to duplicate that slide\n\n5. **Extract ALL text using the `inventory.py` script**:\n   * **Run inventory extraction**:\n     ```bash\n     python scripts/inventory.py working.pptx text-inventory.json\n     ```\n   * **Read text-inventory.json**: Read the entire text-inventory.json file to understand all shapes and their properties. **NEVER set any range limits when reading this file.**\n\n   * The inventory JSON structure:\n      ```json\n        {\n          \"slide-0\": {\n            \"shape-0\": {\n              \"placeholder_type\": \"TITLE\",  // or null for non-placeholders\n              \"left\": 1.5,                  // position in inches\n              \"top\": 2.0,\n              \"width\": 7.5,\n              \"height\": 1.2,\n              \"paragraphs\": [\n                {\n                  \"text\": \"Paragraph text\",\n                  // Optional properties (only included when non-default):\n                  \"bullet\": true,           // explicit bullet detected\n                  \"level\": 0,               // only included when bullet is true\n                  \"alignment\": \"CENTER\",    // CENTER, RIGHT (not LEFT)\n                  \"space_before\": 10.0,     // space before paragraph in points\n                  \"space_after\": 6.0,       // space after paragraph in points\n                  \"line_spacing\": 22.4,     // line spacing in points\n                  \"font_name\": \"Arial\",     // from first run\n                  \"font_size\": 14.0,        // in points\n                  \"bold\": true,\n                  \"italic\": false,\n                  \"underline\": false,\n                  \"color\": \"FF0000\"         // RGB color\n                }\n              ]\n            }\n          }\n        }\n      ```\n\n   * Key features:\n     - **Slides**: Named as \"slide-0\", \"slide-1\", etc.\n     - **Shapes**: Ordered by visual position (top-to-bottom, left-to-right) as \"shape-0\", \"shape-1\", etc.\n     - **Placeholder types**: TITLE, CENTER_TITLE, SUBTITLE, BODY, OBJECT, or null\n     - **Default font size**: `default_font_size` in points extracted from layout placeholders (when available)\n     - **Slide numbers are filtered**: Shapes with SLIDE_NUMBER placeholder type are automatically excluded from inventory\n     - **Bullets**: When `bullet: true`, `level` is always included (even if 0)\n     - **Spacing**: `space_before`, `space_after`, and `line_spacing` in points (only included when set)\n     - **Colors**: `color` for RGB (e.g., \"FF0000\"), `theme_color` for theme colors (e.g., \"DARK_1\")\n     - **Properties**: Only non-default values are included in the output\n\n6. **Generate replacement text and save the data to a JSON file**\n   Based on the text inventory from the previous step:\n   - **CRITICAL**: First verify which shapes exist in the inventory - only reference shapes that are actually present\n   - **VALIDATION**: The replace.py script will validate that all shapes in your replacement JSON exist in the inventory\n     - If you reference a non-existent shape, you'll get an error showing available shapes\n     - If you reference a non-existent slide, you'll get an error indicating the slide doesn't exist\n     - All validation errors are shown at once before the script exits\n   - **IMPORTANT**: The replace.py script uses inventory.py internally to identify ALL text shapes\n   - **AUTOMATIC CLEARING**: ALL text shapes from the inventory will be cleared unless you provide \"paragraphs\" for them\n   - Add a \"paragraphs\" field to shapes that need content (not \"replacement_paragraphs\")\n   - Shapes without \"paragraphs\" in the replacement JSON will have their text cleared automatically\n   - Paragraphs with bullets will be automatically left aligned. Don't set the `alignment` property on when `\"bullet\": true`\n   - Generate appropriate replacement content for placeholder text\n   - Use shape size to determine appropriate content length\n   - **CRITICAL**: Include paragraph properties from the original inventory - don't just provide text\n   - **IMPORTANT**: When bullet: true, do NOT include bullet symbols (â€¢, -, *) in text - they're added automatically\n   - **ESSENTIAL FORMATTING RULES**:\n     - Headers/titles should typically have `\"bold\": true`\n     - List items should have `\"bullet\": true, \"level\": 0` (level is required when bullet is true)\n     - Preserve any alignment properties (e.g., `\"alignment\": \"CENTER\"` for centered text)\n     - Include font properties when different from default (e.g., `\"font_size\": 14.0`, `\"font_name\": \"Lora\"`)\n     - Colors: Use `\"color\": \"FF0000\"` for RGB or `\"theme_color\": \"DARK_1\"` for theme colors\n     - The replacement script expects **properly formatted paragraphs**, not just text strings\n     - **Overlapping shapes**: Prefer shapes with larger default_font_size or more appropriate placeholder_type\n   - Save the updated inventory with replacements to `replacement-text.json`\n   - **WARNING**: Different template layouts have different shape counts - always check the actual inventory before creating replacements\n\n   Example paragraphs field showing proper formatting:\n   ```json\n   \"paragraphs\": [\n     {\n       \"text\": \"New presentation title text\",\n       \"alignment\": \"CENTER\",\n       \"bold\": true\n     },\n     {\n       \"text\": \"Section Header\",\n       \"bold\": true\n     },\n     {\n       \"text\": \"First bullet point without bullet symbol\",\n       \"bullet\": true,\n       \"level\": 0\n     },\n     {\n       \"text\": \"Red colored text\",\n       \"color\": \"FF0000\"\n     },\n     {\n       \"text\": \"Theme colored text\",\n       \"theme_color\": \"DARK_1\"\n     },\n     {\n       \"text\": \"Regular paragraph text without special formatting\"\n     }\n   ]\n   ```\n\n   **Shapes not listed in the replacement JSON are automatically cleared**:\n   ```json\n   {\n     \"slide-0\": {\n       \"shape-0\": {\n         \"paragraphs\": [...] // This shape gets new text\n       }\n       // shape-1 and shape-2 from inventory will be cleared automatically\n     }\n   }\n   ```\n\n   **Common formatting patterns for presentations**:\n   - Title slides: Bold text, sometimes centered\n   - Section headers within slides: Bold text\n   - Bullet lists: Each item needs `\"bullet\": true, \"level\": 0`\n   - Body text: Usually no special properties needed\n   - Quotes: May have special alignment or font properties\n\n7. **Apply replacements using the `replace.py` script**\n   ```bash\n   python scripts/replace.py working.pptx replacement-text.json output.pptx\n   ```\n\n   The script will:\n   - First extract the inventory of ALL text shapes using functions from inventory.py\n   - Validate that all shapes in the replacement JSON exist in the inventory\n   - Clear text from ALL shapes identified in the inventory\n   - Apply new text only to shapes with \"paragraphs\" defined in the replacement JSON\n   - Preserve formatting by applying paragraph properties from the JSON\n   - Handle bullets, alignment, font properties, and colors automatically\n   - Save the updated presentation\n\n   Example validation errors:\n   ```\n   ERROR: Invalid shapes in replacement JSON:\n     - Shape 'shape-99' not found on 'slide-0'. Available shapes: shape-0, shape-1, shape-4\n     - Slide 'slide-999' not found in inventory\n   ```\n\n   ```\n   ERROR: Replacement text made overflow worse in these shapes:\n     - slide-0/shape-2: overflow worsened by 1.25\" (was 0.00\", now 1.25\")\n   ```\n\n## Creating Thumbnail Grids\n\nTo create visual thumbnail grids of PowerPoint slides for quick analysis and reference:\n\n```bash\npython scripts/thumbnail.py template.pptx [output_prefix]\n```\n\n**Features**:\n- Creates: `thumbnails.jpg` (or `thumbnails-1.jpg`, `thumbnails-2.jpg`, etc. for large decks)\n- Default: 5 columns, max 30 slides per grid (5Ã—6)\n- Custom prefix: `python scripts/thumbnail.py template.pptx my-grid`\n  - Note: The output prefix should include the path if you want output in a specific directory (e.g., `workspace/my-grid`)\n- Adjust columns: `--cols 4` (range: 3-6, affects slides per grid)\n- Grid limits: 3 cols = 12 slides/grid, 4 cols = 20, 5 cols = 30, 6 cols = 42\n- Slides are zero-indexed (Slide 0, Slide 1, etc.)\n\n**Use cases**:\n- Template analysis: Quickly understand slide layouts and design patterns\n- Content review: Visual overview of entire presentation\n- Navigation reference: Find specific slides by their visual appearance\n- Quality check: Verify all slides are properly formatted\n\n**Examples**:\n```bash\n# Basic usage\npython scripts/thumbnail.py presentation.pptx\n\n# Combine options: custom name, columns\npython scripts/thumbnail.py template.pptx analysis --cols 4\n```\n\n## Converting Slides to Images\n\nTo visually analyze PowerPoint slides, convert them to images using a two-step process:\n\n1. **Convert PPTX to PDF**:\n   ```bash\n   soffice --headless --convert-to pdf template.pptx\n   ```\n\n2. **Convert PDF pages to JPEG images**:\n   ```bash\n   pdftoppm -jpeg -r 150 template.pdf slide\n   ```\n   This creates files like `slide-1.jpg`, `slide-2.jpg`, etc.\n\nOptions:\n- `-r 150`: Sets resolution to 150 DPI (adjust for quality/size balance)\n- `-jpeg`: Output JPEG format (use `-png` for PNG if preferred)\n- `-f N`: First page to convert (e.g., `-f 2` starts from page 2)\n- `-l N`: Last page to convert (e.g., `-l 5` stops at page 5)\n- `slide`: Prefix for output files\n\nExample for specific range:\n```bash\npdftoppm -jpeg -r 150 -f 2 -l 5 template.pdf slide  # Converts only pages 2-5\n```\n\n## Code Style Guidelines\n**IMPORTANT**: When generating code for PPTX operations:\n- Write concise code\n- Avoid verbose variable names and redundant operations\n- Avoid unnecessary print statements\n\n## Dependencies\n\nRequired dependencies (should already be installed):\n\n- **markitdown**: `pip install \"markitdown[pptx]\"` (for text extraction from presentations)\n- **pptxgenjs**: `npm install -g pptxgenjs` (for creating presentations via html2pptx)\n- **playwright**: `npm install -g playwright` (for HTML rendering in html2pptx)\n- **react-icons**: `npm install -g react-icons react react-dom` (for icons)\n- **sharp**: `npm install -g sharp` (for SVG rasterization and image processing)\n- **LibreOffice**: `sudo apt-get install libreoffice` (for PDF conversion)\n- **Poppler**: `sudo apt-get install poppler-utils` (for pdftoppm to convert PDF to images)\n- **defusedxml**: `pip install defusedxml` (for secure XML parsing)"
              },
              {
                "name": "skill-creator",
                "description": "Guide for creating effective skills. This skill should be used when users want to create a new skill (or update an existing skill) that extends Claude's capabilities with specialized knowledge, workflows, or tool integrations.",
                "path": "skills/skill-creator/SKILL.md",
                "frontmatter": {
                  "name": "skill-creator",
                  "description": "Guide for creating effective skills. This skill should be used when users want to create a new skill (or update an existing skill) that extends Claude's capabilities with specialized knowledge, workflows, or tool integrations.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "# Skill Creator\n\nThis skill provides guidance for creating effective skills.\n\n## About Skills\n\nSkills are modular, self-contained packages that extend Claude's capabilities by providing\nspecialized knowledge, workflows, and tools. Think of them as \"onboarding guides\" for specific\ndomains or tasksâ€”they transform Claude from a general-purpose agent into a specialized agent\nequipped with procedural knowledge that no model can fully possess.\n\n### What Skills Provide\n\n1. Specialized workflows - Multi-step procedures for specific domains\n2. Tool integrations - Instructions for working with specific file formats or APIs\n3. Domain expertise - Company-specific knowledge, schemas, business logic\n4. Bundled resources - Scripts, references, and assets for complex and repetitive tasks\n\n## Core Principles\n\n### Concise is Key\n\nThe context window is a public good. Skills share the context window with everything else Claude needs: system prompt, conversation history, other Skills' metadata, and the actual user request.\n\n**Default assumption: Claude is already very smart.** Only add context Claude doesn't already have. Challenge each piece of information: \"Does Claude really need this explanation?\" and \"Does this paragraph justify its token cost?\"\n\nPrefer concise examples over verbose explanations.\n\n### Set Appropriate Degrees of Freedom\n\nMatch the level of specificity to the task's fragility and variability:\n\n**High freedom (text-based instructions)**: Use when multiple approaches are valid, decisions depend on context, or heuristics guide the approach.\n\n**Medium freedom (pseudocode or scripts with parameters)**: Use when a preferred pattern exists, some variation is acceptable, or configuration affects behavior.\n\n**Low freedom (specific scripts, few parameters)**: Use when operations are fragile and error-prone, consistency is critical, or a specific sequence must be followed.\n\nThink of Claude as exploring a path: a narrow bridge with cliffs needs specific guardrails (low freedom), while an open field allows many routes (high freedom).\n\n### Anatomy of a Skill\n\nEvery skill consists of a required SKILL.md file and optional bundled resources:\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md (required)\nâ”‚   â”œâ”€â”€ YAML frontmatter metadata (required)\nâ”‚   â”‚   â”œâ”€â”€ name: (required)\nâ”‚   â”‚   â””â”€â”€ description: (required)\nâ”‚   â””â”€â”€ Markdown instructions (required)\nâ””â”€â”€ Bundled Resources (optional)\n    â”œâ”€â”€ scripts/          - Executable code (Python/Bash/etc.)\n    â”œâ”€â”€ references/       - Documentation intended to be loaded into context as needed\n    â””â”€â”€ assets/           - Files used in output (templates, icons, fonts, etc.)\n```\n\n#### SKILL.md (required)\n\nEvery SKILL.md consists of:\n\n- **Frontmatter** (YAML): Contains `name` and `description` fields. These are the only fields that Claude reads to determine when the skill gets used, thus it is very important to be clear and comprehensive in describing what the skill is, and when it should be used.\n- **Body** (Markdown): Instructions and guidance for using the skill. Only loaded AFTER the skill triggers (if at all).\n\n#### Bundled Resources (optional)\n\n##### Scripts (`scripts/`)\n\nExecutable code (Python/Bash/etc.) for tasks that require deterministic reliability or are repeatedly rewritten.\n\n- **When to include**: When the same code is being rewritten repeatedly or deterministic reliability is needed\n- **Example**: `scripts/rotate_pdf.py` for PDF rotation tasks\n- **Benefits**: Token efficient, deterministic, may be executed without loading into context\n- **Note**: Scripts may still need to be read by Claude for patching or environment-specific adjustments\n\n##### References (`references/`)\n\nDocumentation and reference material intended to be loaded as needed into context to inform Claude's process and thinking.\n\n- **When to include**: For documentation that Claude should reference while working\n- **Examples**: `references/finance.md` for financial schemas, `references/mnda.md` for company NDA template, `references/policies.md` for company policies, `references/api_docs.md` for API specifications\n- **Use cases**: Database schemas, API documentation, domain knowledge, company policies, detailed workflow guides\n- **Benefits**: Keeps SKILL.md lean, loaded only when Claude determines it's needed\n- **Best practice**: If files are large (>10k words), include grep search patterns in SKILL.md\n- **Avoid duplication**: Information should live in either SKILL.md or references files, not both. Prefer references files for detailed information unless it's truly core to the skillâ€”this keeps SKILL.md lean while making information discoverable without hogging the context window. Keep only essential procedural instructions and workflow guidance in SKILL.md; move detailed reference material, schemas, and examples to references files.\n\n##### Assets (`assets/`)\n\nFiles not intended to be loaded into context, but rather used within the output Claude produces.\n\n- **When to include**: When the skill needs files that will be used in the final output\n- **Examples**: `assets/logo.png` for brand assets, `assets/slides.pptx` for PowerPoint templates, `assets/frontend-template/` for HTML/React boilerplate, `assets/font.ttf` for typography\n- **Use cases**: Templates, images, icons, boilerplate code, fonts, sample documents that get copied or modified\n- **Benefits**: Separates output resources from documentation, enables Claude to use files without loading them into context\n\n#### What to Not Include in a Skill\n\nA skill should only contain essential files that directly support its functionality. Do NOT create extraneous documentation or auxiliary files, including:\n\n- README.md\n- INSTALLATION_GUIDE.md\n- QUICK_REFERENCE.md\n- CHANGELOG.md\n- etc.\n\nThe skill should only contain the information needed for an AI agent to do the job at hand. It should not contain auxilary context about the process that went into creating it, setup and testing procedures, user-facing documentation, etc. Creating additional documentation files just adds clutter and confusion.\n\n### Progressive Disclosure Design Principle\n\nSkills use a three-level loading system to manage context efficiently:\n\n1. **Metadata (name + description)** - Always in context (~100 words)\n2. **SKILL.md body** - When skill triggers (<5k words)\n3. **Bundled resources** - As needed by Claude (Unlimited because scripts can be executed without reading into context window)\n\n#### Progressive Disclosure Patterns\n\nKeep SKILL.md body to the essentials and under 500 lines to minimize context bloat. Split content into separate files when approaching this limit. When splitting out content into other files, it is very important to reference them from SKILL.md and describe clearly when to read them, to ensure the reader of the skill knows they exist and when to use them.\n\n**Key principle:** When a skill supports multiple variations, frameworks, or options, keep only the core workflow and selection guidance in SKILL.md. Move variant-specific details (patterns, examples, configuration) into separate reference files.\n\n**Pattern 1: High-level guide with references**\n\n```markdown\n# PDF Processing\n\n## Quick start\n\nExtract text with pdfplumber:\n[code example]\n\n## Advanced features\n\n- **Form filling**: See [FORMS.md](FORMS.md) for complete guide\n- **API reference**: See [REFERENCE.md](REFERENCE.md) for all methods\n- **Examples**: See [EXAMPLES.md](EXAMPLES.md) for common patterns\n```\n\nClaude loads FORMS.md, REFERENCE.md, or EXAMPLES.md only when needed.\n\n**Pattern 2: Domain-specific organization**\n\nFor Skills with multiple domains, organize content by domain to avoid loading irrelevant context:\n\n```\nbigquery-skill/\nâ”œâ”€â”€ SKILL.md (overview and navigation)\nâ””â”€â”€ reference/\n    â”œâ”€â”€ finance.md (revenue, billing metrics)\n    â”œâ”€â”€ sales.md (opportunities, pipeline)\n    â”œâ”€â”€ product.md (API usage, features)\n    â””â”€â”€ marketing.md (campaigns, attribution)\n```\n\nWhen a user asks about sales metrics, Claude only reads sales.md.\n\nSimilarly, for skills supporting multiple frameworks or variants, organize by variant:\n\n```\ncloud-deploy/\nâ”œâ”€â”€ SKILL.md (workflow + provider selection)\nâ””â”€â”€ references/\n    â”œâ”€â”€ aws.md (AWS deployment patterns)\n    â”œâ”€â”€ gcp.md (GCP deployment patterns)\n    â””â”€â”€ azure.md (Azure deployment patterns)\n```\n\nWhen the user chooses AWS, Claude only reads aws.md.\n\n**Pattern 3: Conditional details**\n\nShow basic content, link to advanced content:\n\n```markdown\n# DOCX Processing\n\n## Creating documents\n\nUse docx-js for new documents. See [DOCX-JS.md](DOCX-JS.md).\n\n## Editing documents\n\nFor simple edits, modify the XML directly.\n\n**For tracked changes**: See [REDLINING.md](REDLINING.md)\n**For OOXML details**: See [OOXML.md](OOXML.md)\n```\n\nClaude reads REDLINING.md or OOXML.md only when the user needs those features.\n\n**Important guidelines:**\n\n- **Avoid deeply nested references** - Keep references one level deep from SKILL.md. All reference files should link directly from SKILL.md.\n- **Structure longer reference files** - For files longer than 100 lines, include a table of contents at the top so Claude can see the full scope when previewing.\n\n## Skill Creation Process\n\nSkill creation involves these steps:\n\n1. Understand the skill with concrete examples\n2. Plan reusable skill contents (scripts, references, assets)\n3. Initialize the skill (run init_skill.py)\n4. Edit the skill (implement resources and write SKILL.md)\n5. Package the skill (run package_skill.py)\n6. Iterate based on real usage\n\nFollow these steps in order, skipping only if there is a clear reason why they are not applicable.\n\n### Step 1: Understanding the Skill with Concrete Examples\n\nSkip this step only when the skill's usage patterns are already clearly understood. It remains valuable even when working with an existing skill.\n\nTo create an effective skill, clearly understand concrete examples of how the skill will be used. This understanding can come from either direct user examples or generated examples that are validated with user feedback.\n\nFor example, when building an image-editor skill, relevant questions include:\n\n- \"What functionality should the image-editor skill support? Editing, rotating, anything else?\"\n- \"Can you give some examples of how this skill would be used?\"\n- \"I can imagine users asking for things like 'Remove the red-eye from this image' or 'Rotate this image'. Are there other ways you imagine this skill being used?\"\n- \"What would a user say that should trigger this skill?\"\n\nTo avoid overwhelming users, avoid asking too many questions in a single message. Start with the most important questions and follow up as needed for better effectiveness.\n\nConclude this step when there is a clear sense of the functionality the skill should support.\n\n### Step 2: Planning the Reusable Skill Contents\n\nTo turn concrete examples into an effective skill, analyze each example by:\n\n1. Considering how to execute on the example from scratch\n2. Identifying what scripts, references, and assets would be helpful when executing these workflows repeatedly\n\nExample: When building a `pdf-editor` skill to handle queries like \"Help me rotate this PDF,\" the analysis shows:\n\n1. Rotating a PDF requires re-writing the same code each time\n2. A `scripts/rotate_pdf.py` script would be helpful to store in the skill\n\nExample: When designing a `frontend-webapp-builder` skill for queries like \"Build me a todo app\" or \"Build me a dashboard to track my steps,\" the analysis shows:\n\n1. Writing a frontend webapp requires the same boilerplate HTML/React each time\n2. An `assets/hello-world/` template containing the boilerplate HTML/React project files would be helpful to store in the skill\n\nExample: When building a `big-query` skill to handle queries like \"How many users have logged in today?\" the analysis shows:\n\n1. Querying BigQuery requires re-discovering the table schemas and relationships each time\n2. A `references/schema.md` file documenting the table schemas would be helpful to store in the skill\n\nTo establish the skill's contents, analyze each concrete example to create a list of the reusable resources to include: scripts, references, and assets.\n\n### Step 3: Initializing the Skill\n\nAt this point, it is time to actually create the skill.\n\nSkip this step only if the skill being developed already exists, and iteration or packaging is needed. In this case, continue to the next step.\n\nWhen creating a new skill from scratch, always run the `init_skill.py` script. The script conveniently generates a new template skill directory that automatically includes everything a skill requires, making the skill creation process much more efficient and reliable.\n\nUsage:\n\n```bash\nscripts/init_skill.py <skill-name> --path <output-directory>\n```\n\nThe script:\n\n- Creates the skill directory at the specified path\n- Generates a SKILL.md template with proper frontmatter and TODO placeholders\n- Creates example resource directories: `scripts/`, `references/`, and `assets/`\n- Adds example files in each directory that can be customized or deleted\n\nAfter initialization, customize or remove the generated SKILL.md and example files as needed.\n\n### Step 4: Edit the Skill\n\nWhen editing the (newly-generated or existing) skill, remember that the skill is being created for another instance of Claude to use. Include information that would be beneficial and non-obvious to Claude. Consider what procedural knowledge, domain-specific details, or reusable assets would help another Claude instance execute these tasks more effectively.\n\n#### Learn Proven Design Patterns\n\nConsult these helpful guides based on your skill's needs:\n\n- **Multi-step processes**: See references/workflows.md for sequential workflows and conditional logic\n- **Specific output formats or quality standards**: See references/output-patterns.md for template and example patterns\n\nThese files contain established best practices for effective skill design.\n\n#### Start with Reusable Skill Contents\n\nTo begin implementation, start with the reusable resources identified above: `scripts/`, `references/`, and `assets/` files. Note that this step may require user input. For example, when implementing a `brand-guidelines` skill, the user may need to provide brand assets or templates to store in `assets/`, or documentation to store in `references/`.\n\nAdded scripts must be tested by actually running them to ensure there are no bugs and that the output matches what is expected. If there are many similar scripts, only a representative sample needs to be tested to ensure confidence that they all work while balancing time to completion.\n\nAny example files and directories not needed for the skill should be deleted. The initialization script creates example files in `scripts/`, `references/`, and `assets/` to demonstrate structure, but most skills won't need all of them.\n\n#### Update SKILL.md\n\n**Writing Guidelines:** Always use imperative/infinitive form.\n\n##### Frontmatter\n\nWrite the YAML frontmatter with `name` and `description`:\n\n- `name`: The skill name\n- `description`: This is the primary triggering mechanism for your skill, and helps Claude understand when to use the skill.\n  - Include both what the Skill does and specific triggers/contexts for when to use it.\n  - Include all \"when to use\" information here - Not in the body. The body is only loaded after triggering, so \"When to Use This Skill\" sections in the body are not helpful to Claude.\n  - Example description for a `docx` skill: \"Comprehensive document creation, editing, and analysis with support for tracked changes, comments, formatting preservation, and text extraction. Use when Claude needs to work with professional documents (.docx files) for: (1) Creating new documents, (2) Modifying or editing content, (3) Working with tracked changes, (4) Adding comments, or any other document tasks\"\n\nDo not include any other fields in YAML frontmatter.\n\n##### Body\n\nWrite instructions for using the skill and its bundled resources.\n\n### Step 5: Packaging a Skill\n\nOnce development of the skill is complete, it must be packaged into a distributable .skill file that gets shared with the user. The packaging process automatically validates the skill first to ensure it meets all requirements:\n\n```bash\nscripts/package_skill.py <path/to/skill-folder>\n```\n\nOptional output directory specification:\n\n```bash\nscripts/package_skill.py <path/to/skill-folder> ./dist\n```\n\nThe packaging script will:\n\n1. **Validate** the skill automatically, checking:\n\n   - YAML frontmatter format and required fields\n   - Skill naming conventions and directory structure\n   - Description completeness and quality\n   - File organization and resource references\n\n2. **Package** the skill if validation passes, creating a .skill file named after the skill (e.g., `my-skill.skill`) that includes all files and maintains the proper directory structure for distribution. The .skill file is a zip file with a .skill extension.\n\nIf validation fails, the script will report the errors and exit without creating a package. Fix any validation errors and run the packaging command again.\n\n### Step 6: Iterate\n\nAfter testing the skill, users may request improvements. Often this happens right after using the skill, with fresh context of how the skill performed.\n\n**Iteration workflow:**\n\n1. Use the skill on real tasks\n2. Notice struggles or inefficiencies\n3. Identify how SKILL.md or bundled resources should be updated\n4. Implement changes and test again"
              },
              {
                "name": "slack-gif-creator",
                "description": "Knowledge and utilities for creating animated GIFs optimized for Slack. Provides constraints, validation tools, and animation concepts. Use when users request animated GIFs for Slack like \"make me a GIF of X doing Y for Slack.\"",
                "path": "skills/slack-gif-creator/SKILL.md",
                "frontmatter": {
                  "name": "slack-gif-creator",
                  "description": "Knowledge and utilities for creating animated GIFs optimized for Slack. Provides constraints, validation tools, and animation concepts. Use when users request animated GIFs for Slack like \"make me a GIF of X doing Y for Slack.\"",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "# Slack GIF Creator\n\nA toolkit providing utilities and knowledge for creating animated GIFs optimized for Slack.\n\n## Slack Requirements\n\n**Dimensions:**\n- Emoji GIFs: 128x128 (recommended)\n- Message GIFs: 480x480\n\n**Parameters:**\n- FPS: 10-30 (lower is smaller file size)\n- Colors: 48-128 (fewer = smaller file size)\n- Duration: Keep under 3 seconds for emoji GIFs\n\n## Core Workflow\n\n```python\nfrom core.gif_builder import GIFBuilder\nfrom PIL import Image, ImageDraw\n\n# 1. Create builder\nbuilder = GIFBuilder(width=128, height=128, fps=10)\n\n# 2. Generate frames\nfor i in range(12):\n    frame = Image.new('RGB', (128, 128), (240, 248, 255))\n    draw = ImageDraw.Draw(frame)\n\n    # Draw your animation using PIL primitives\n    # (circles, polygons, lines, etc.)\n\n    builder.add_frame(frame)\n\n# 3. Save with optimization\nbuilder.save('output.gif', num_colors=48, optimize_for_emoji=True)\n```\n\n## Drawing Graphics\n\n### Working with User-Uploaded Images\nIf a user uploads an image, consider whether they want to:\n- **Use it directly** (e.g., \"animate this\", \"split this into frames\")\n- **Use it as inspiration** (e.g., \"make something like this\")\n\nLoad and work with images using PIL:\n```python\nfrom PIL import Image\n\nuploaded = Image.open('file.png')\n# Use directly, or just as reference for colors/style\n```\n\n### Drawing from Scratch\nWhen drawing graphics from scratch, use PIL ImageDraw primitives:\n\n```python\nfrom PIL import ImageDraw\n\ndraw = ImageDraw.Draw(frame)\n\n# Circles/ovals\ndraw.ellipse([x1, y1, x2, y2], fill=(r, g, b), outline=(r, g, b), width=3)\n\n# Stars, triangles, any polygon\npoints = [(x1, y1), (x2, y2), (x3, y3), ...]\ndraw.polygon(points, fill=(r, g, b), outline=(r, g, b), width=3)\n\n# Lines\ndraw.line([(x1, y1), (x2, y2)], fill=(r, g, b), width=5)\n\n# Rectangles\ndraw.rectangle([x1, y1, x2, y2], fill=(r, g, b), outline=(r, g, b), width=3)\n```\n\n**Don't use:** Emoji fonts (unreliable across platforms) or assume pre-packaged graphics exist in this skill.\n\n### Making Graphics Look Good\n\nGraphics should look polished and creative, not basic. Here's how:\n\n**Use thicker lines** - Always set `width=2` or higher for outlines and lines. Thin lines (width=1) look choppy and amateurish.\n\n**Add visual depth**:\n- Use gradients for backgrounds (`create_gradient_background`)\n- Layer multiple shapes for complexity (e.g., a star with a smaller star inside)\n\n**Make shapes more interesting**:\n- Don't just draw a plain circle - add highlights, rings, or patterns\n- Stars can have glows (draw larger, semi-transparent versions behind)\n- Combine multiple shapes (stars + sparkles, circles + rings)\n\n**Pay attention to colors**:\n- Use vibrant, complementary colors\n- Add contrast (dark outlines on light shapes, light outlines on dark shapes)\n- Consider the overall composition\n\n**For complex shapes** (hearts, snowflakes, etc.):\n- Use combinations of polygons and ellipses\n- Calculate points carefully for symmetry\n- Add details (a heart can have a highlight curve, snowflakes have intricate branches)\n\nBe creative and detailed! A good Slack GIF should look polished, not like placeholder graphics.\n\n## Available Utilities\n\n### GIFBuilder (`core.gif_builder`)\nAssembles frames and optimizes for Slack:\n```python\nbuilder = GIFBuilder(width=128, height=128, fps=10)\nbuilder.add_frame(frame)  # Add PIL Image\nbuilder.add_frames(frames)  # Add list of frames\nbuilder.save('out.gif', num_colors=48, optimize_for_emoji=True, remove_duplicates=True)\n```\n\n### Validators (`core.validators`)\nCheck if GIF meets Slack requirements:\n```python\nfrom core.validators import validate_gif, is_slack_ready\n\n# Detailed validation\npasses, info = validate_gif('my.gif', is_emoji=True, verbose=True)\n\n# Quick check\nif is_slack_ready('my.gif'):\n    print(\"Ready!\")\n```\n\n### Easing Functions (`core.easing`)\nSmooth motion instead of linear:\n```python\nfrom core.easing import interpolate\n\n# Progress from 0.0 to 1.0\nt = i / (num_frames - 1)\n\n# Apply easing\ny = interpolate(start=0, end=400, t=t, easing='ease_out')\n\n# Available: linear, ease_in, ease_out, ease_in_out,\n#           bounce_out, elastic_out, back_out\n```\n\n### Frame Helpers (`core.frame_composer`)\nConvenience functions for common needs:\n```python\nfrom core.frame_composer import (\n    create_blank_frame,         # Solid color background\n    create_gradient_background,  # Vertical gradient\n    draw_circle,                # Helper for circles\n    draw_text,                  # Simple text rendering\n    draw_star                   # 5-pointed star\n)\n```\n\n## Animation Concepts\n\n### Shake/Vibrate\nOffset object position with oscillation:\n- Use `math.sin()` or `math.cos()` with frame index\n- Add small random variations for natural feel\n- Apply to x and/or y position\n\n### Pulse/Heartbeat\nScale object size rhythmically:\n- Use `math.sin(t * frequency * 2 * math.pi)` for smooth pulse\n- For heartbeat: two quick pulses then pause (adjust sine wave)\n- Scale between 0.8 and 1.2 of base size\n\n### Bounce\nObject falls and bounces:\n- Use `interpolate()` with `easing='bounce_out'` for landing\n- Use `easing='ease_in'` for falling (accelerating)\n- Apply gravity by increasing y velocity each frame\n\n### Spin/Rotate\nRotate object around center:\n- PIL: `image.rotate(angle, resample=Image.BICUBIC)`\n- For wobble: use sine wave for angle instead of linear\n\n### Fade In/Out\nGradually appear or disappear:\n- Create RGBA image, adjust alpha channel\n- Or use `Image.blend(image1, image2, alpha)`\n- Fade in: alpha from 0 to 1\n- Fade out: alpha from 1 to 0\n\n### Slide\nMove object from off-screen to position:\n- Start position: outside frame bounds\n- End position: target location\n- Use `interpolate()` with `easing='ease_out'` for smooth stop\n- For overshoot: use `easing='back_out'`\n\n### Zoom\nScale and position for zoom effect:\n- Zoom in: scale from 0.1 to 2.0, crop center\n- Zoom out: scale from 2.0 to 1.0\n- Can add motion blur for drama (PIL filter)\n\n### Explode/Particle Burst\nCreate particles radiating outward:\n- Generate particles with random angles and velocities\n- Update each particle: `x += vx`, `y += vy`\n- Add gravity: `vy += gravity_constant`\n- Fade out particles over time (reduce alpha)\n\n## Optimization Strategies\n\nOnly when asked to make the file size smaller, implement a few of the following methods:\n\n1. **Fewer frames** - Lower FPS (10 instead of 20) or shorter duration\n2. **Fewer colors** - `num_colors=48` instead of 128\n3. **Smaller dimensions** - 128x128 instead of 480x480\n4. **Remove duplicates** - `remove_duplicates=True` in save()\n5. **Emoji mode** - `optimize_for_emoji=True` auto-optimizes\n\n```python\n# Maximum optimization for emoji\nbuilder.save(\n    'emoji.gif',\n    num_colors=48,\n    optimize_for_emoji=True,\n    remove_duplicates=True\n)\n```\n\n## Philosophy\n\nThis skill provides:\n- **Knowledge**: Slack's requirements and animation concepts\n- **Utilities**: GIFBuilder, validators, easing functions\n- **Flexibility**: Create the animation logic using PIL primitives\n\nIt does NOT provide:\n- Rigid animation templates or pre-made functions\n- Emoji font rendering (unreliable across platforms)\n- A library of pre-packaged graphics built into the skill\n\n**Note on user uploads**: This skill doesn't include pre-built graphics, but if a user uploads an image, use PIL to load and work with it - interpret based on their request whether they want it used directly or just as inspiration.\n\nBe creative! Combine concepts (bouncing + rotating, pulsing + sliding, etc.) and use PIL's full capabilities.\n\n## Dependencies\n\n```bash\npip install pillow imageio numpy\n```"
              },
              {
                "name": "theme-factory",
                "description": "Toolkit for styling artifacts with a theme. These artifacts can be slides, docs, reportings, HTML landing pages, etc. There are 10 pre-set themes with colors/fonts that you can apply to any artifact that has been creating, or can generate a new theme on-the-fly.",
                "path": "skills/theme-factory/SKILL.md",
                "frontmatter": {
                  "name": "theme-factory",
                  "description": "Toolkit for styling artifacts with a theme. These artifacts can be slides, docs, reportings, HTML landing pages, etc. There are 10 pre-set themes with colors/fonts that you can apply to any artifact that has been creating, or can generate a new theme on-the-fly.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "# Theme Factory Skill\n\nThis skill provides a curated collection of professional font and color themes themes, each with carefully selected color palettes and font pairings. Once a theme is chosen, it can be applied to any artifact.\n\n## Purpose\n\nTo apply consistent, professional styling to presentation slide decks, use this skill. Each theme includes:\n- A cohesive color palette with hex codes\n- Complementary font pairings for headers and body text\n- A distinct visual identity suitable for different contexts and audiences\n\n## Usage Instructions\n\nTo apply styling to a slide deck or other artifact:\n\n1. **Show the theme showcase**: Display the `theme-showcase.pdf` file to allow users to see all available themes visually. Do not make any modifications to it; simply show the file for viewing.\n2. **Ask for their choice**: Ask which theme to apply to the deck\n3. **Wait for selection**: Get explicit confirmation about the chosen theme\n4. **Apply the theme**: Once a theme has been chosen, apply the selected theme's colors and fonts to the deck/artifact\n\n## Themes Available\n\nThe following 10 themes are available, each showcased in `theme-showcase.pdf`:\n\n1. **Ocean Depths** - Professional and calming maritime theme\n2. **Sunset Boulevard** - Warm and vibrant sunset colors\n3. **Forest Canopy** - Natural and grounded earth tones\n4. **Modern Minimalist** - Clean and contemporary grayscale\n5. **Golden Hour** - Rich and warm autumnal palette\n6. **Arctic Frost** - Cool and crisp winter-inspired theme\n7. **Desert Rose** - Soft and sophisticated dusty tones\n8. **Tech Innovation** - Bold and modern tech aesthetic\n9. **Botanical Garden** - Fresh and organic garden colors\n10. **Midnight Galaxy** - Dramatic and cosmic deep tones\n\n## Theme Details\n\nEach theme is defined in the `themes/` directory with complete specifications including:\n- Cohesive color palette with hex codes\n- Complementary font pairings for headers and body text\n- Distinct visual identity suitable for different contexts and audiences\n\n## Application Process\n\nAfter a preferred theme is selected:\n1. Read the corresponding theme file from the `themes/` directory\n2. Apply the specified colors and fonts consistently throughout the deck\n3. Ensure proper contrast and readability\n4. Maintain the theme's visual identity across all slides\n\n## Create your Own Theme\nTo handle cases where none of the existing themes work for an artifact, create a custom theme. Based on provided inputs, generate a new theme similar to the ones above. Give the theme a similar name describing what the font/color combinations represent. Use any basic description provided to choose appropriate colors/fonts. After generating the theme, show it for review and verification. Following that, apply the theme as described above."
              },
              {
                "name": "web-artifacts-builder",
                "description": "Suite of tools for creating elaborate, multi-component claude.ai HTML artifacts using modern frontend web technologies (React, Tailwind CSS, shadcn/ui). Use for complex artifacts requiring state management, routing, or shadcn/ui components - not for simple single-file HTML/JSX artifacts.",
                "path": "skills/web-artifacts-builder/SKILL.md",
                "frontmatter": {
                  "name": "web-artifacts-builder",
                  "description": "Suite of tools for creating elaborate, multi-component claude.ai HTML artifacts using modern frontend web technologies (React, Tailwind CSS, shadcn/ui). Use for complex artifacts requiring state management, routing, or shadcn/ui components - not for simple single-file HTML/JSX artifacts.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "# Web Artifacts Builder\n\nTo build powerful frontend claude.ai artifacts, follow these steps:\n1. Initialize the frontend repo using `scripts/init-artifact.sh`\n2. Develop your artifact by editing the generated code\n3. Bundle all code into a single HTML file using `scripts/bundle-artifact.sh`\n4. Display artifact to user\n5. (Optional) Test the artifact\n\n**Stack**: React 18 + TypeScript + Vite + Parcel (bundling) + Tailwind CSS + shadcn/ui\n\n## Design & Style Guidelines\n\nVERY IMPORTANT: To avoid what is often referred to as \"AI slop\", avoid using excessive centered layouts, purple gradients, uniform rounded corners, and Inter font.\n\n## Quick Start\n\n### Step 1: Initialize Project\n\nRun the initialization script to create a new React project:\n```bash\nbash scripts/init-artifact.sh <project-name>\ncd <project-name>\n```\n\nThis creates a fully configured project with:\n- âœ… React + TypeScript (via Vite)\n- âœ… Tailwind CSS 3.4.1 with shadcn/ui theming system\n- âœ… Path aliases (`@/`) configured\n- âœ… 40+ shadcn/ui components pre-installed\n- âœ… All Radix UI dependencies included\n- âœ… Parcel configured for bundling (via .parcelrc)\n- âœ… Node 18+ compatibility (auto-detects and pins Vite version)\n\n### Step 2: Develop Your Artifact\n\nTo build the artifact, edit the generated files. See **Common Development Tasks** below for guidance.\n\n### Step 3: Bundle to Single HTML File\n\nTo bundle the React app into a single HTML artifact:\n```bash\nbash scripts/bundle-artifact.sh\n```\n\nThis creates `bundle.html` - a self-contained artifact with all JavaScript, CSS, and dependencies inlined. This file can be directly shared in Claude conversations as an artifact.\n\n**Requirements**: Your project must have an `index.html` in the root directory.\n\n**What the script does**:\n- Installs bundling dependencies (parcel, @parcel/config-default, parcel-resolver-tspaths, html-inline)\n- Creates `.parcelrc` config with path alias support\n- Builds with Parcel (no source maps)\n- Inlines all assets into single HTML using html-inline\n\n### Step 4: Share Artifact with User\n\nFinally, share the bundled HTML file in conversation with the user so they can view it as an artifact.\n\n### Step 5: Testing/Visualizing the Artifact (Optional)\n\nNote: This is a completely optional step. Only perform if necessary or requested.\n\nTo test/visualize the artifact, use available tools (including other Skills or built-in tools like Playwright or Puppeteer). In general, avoid testing the artifact upfront as it adds latency between the request and when the finished artifact can be seen. Test later, after presenting the artifact, if requested or if issues arise.\n\n## Reference\n\n- **shadcn/ui components**: https://ui.shadcn.com/docs/components"
              },
              {
                "name": "webapp-testing",
                "description": "Toolkit for interacting with and testing local web applications using Playwright. Supports verifying frontend functionality, debugging UI behavior, capturing browser screenshots, and viewing browser logs.",
                "path": "skills/webapp-testing/SKILL.md",
                "frontmatter": {
                  "name": "webapp-testing",
                  "description": "Toolkit for interacting with and testing local web applications using Playwright. Supports verifying frontend functionality, debugging UI behavior, capturing browser screenshots, and viewing browser logs.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "# Web Application Testing\n\nTo test local web applications, write native Python Playwright scripts.\n\n**Helper Scripts Available**:\n- `scripts/with_server.py` - Manages server lifecycle (supports multiple servers)\n\n**Always run scripts with `--help` first** to see usage. DO NOT read the source until you try running the script first and find that a customized solution is abslutely necessary. These scripts can be very large and thus pollute your context window. They exist to be called directly as black-box scripts rather than ingested into your context window.\n\n## Decision Tree: Choosing Your Approach\n\n```\nUser task â†’ Is it static HTML?\n    â”œâ”€ Yes â†’ Read HTML file directly to identify selectors\n    â”‚         â”œâ”€ Success â†’ Write Playwright script using selectors\n    â”‚         â””â”€ Fails/Incomplete â†’ Treat as dynamic (below)\n    â”‚\n    â””â”€ No (dynamic webapp) â†’ Is the server already running?\n        â”œâ”€ No â†’ Run: python scripts/with_server.py --help\n        â”‚        Then use the helper + write simplified Playwright script\n        â”‚\n        â””â”€ Yes â†’ Reconnaissance-then-action:\n            1. Navigate and wait for networkidle\n            2. Take screenshot or inspect DOM\n            3. Identify selectors from rendered state\n            4. Execute actions with discovered selectors\n```\n\n## Example: Using with_server.py\n\nTo start a server, run `--help` first, then use the helper:\n\n**Single server:**\n```bash\npython scripts/with_server.py --server \"npm run dev\" --port 5173 -- python your_automation.py\n```\n\n**Multiple servers (e.g., backend + frontend):**\n```bash\npython scripts/with_server.py \\\n  --server \"cd backend && python server.py\" --port 3000 \\\n  --server \"cd frontend && npm run dev\" --port 5173 \\\n  -- python your_automation.py\n```\n\nTo create an automation script, include only Playwright logic (servers are managed automatically):\n```python\nfrom playwright.sync_api import sync_playwright\n\nwith sync_playwright() as p:\n    browser = p.chromium.launch(headless=True) # Always launch chromium in headless mode\n    page = browser.new_page()\n    page.goto('http://localhost:5173') # Server already running and ready\n    page.wait_for_load_state('networkidle') # CRITICAL: Wait for JS to execute\n    # ... your automation logic\n    browser.close()\n```\n\n## Reconnaissance-Then-Action Pattern\n\n1. **Inspect rendered DOM**:\n   ```python\n   page.screenshot(path='/tmp/inspect.png', full_page=True)\n   content = page.content()\n   page.locator('button').all()\n   ```\n\n2. **Identify selectors** from inspection results\n\n3. **Execute actions** using discovered selectors\n\n## Common Pitfall\n\nâŒ **Don't** inspect the DOM before waiting for `networkidle` on dynamic apps\nâœ… **Do** wait for `page.wait_for_load_state('networkidle')` before inspection\n\n## Best Practices\n\n- **Use bundled scripts as black boxes** - To accomplish a task, consider whether one of the scripts available in `scripts/` can help. These scripts handle common, complex workflows reliably without cluttering the context window. Use `--help` to see usage, then invoke directly. \n- Use `sync_playwright()` for synchronous scripts\n- Always close the browser when done\n- Use descriptive selectors: `text=`, `role=`, CSS selectors, or IDs\n- Add appropriate waits: `page.wait_for_selector()` or `page.wait_for_timeout()`\n\n## Reference Files\n\n- **examples/** - Examples showing common patterns:\n  - `element_discovery.py` - Discovering buttons, links, and inputs on a page\n  - `static_html_automation.py` - Using file:// URLs for local HTML\n  - `console_logging.py` - Capturing console logs during automation"
              },
              {
                "name": "xlsx",
                "description": "Comprehensive spreadsheet creation, editing, and analysis with support for formulas, formatting, data analysis, and visualization. When Claude needs to work with spreadsheets (.xlsx, .xlsm, .csv, .tsv, etc) for: (1) Creating new spreadsheets with formulas and formatting, (2) Reading or analyzing data, (3) Modify existing spreadsheets while preserving formulas, (4) Data analysis and visualization in spreadsheets, or (5) Recalculating formulas",
                "path": "skills/xlsx/SKILL.md",
                "frontmatter": {
                  "name": "xlsx",
                  "description": "Comprehensive spreadsheet creation, editing, and analysis with support for formulas, formatting, data analysis, and visualization. When Claude needs to work with spreadsheets (.xlsx, .xlsm, .csv, .tsv, etc) for: (1) Creating new spreadsheets with formulas and formatting, (2) Reading or analyzing data, (3) Modify existing spreadsheets while preserving formulas, (4) Data analysis and visualization in spreadsheets, or (5) Recalculating formulas",
                  "license": "Proprietary. LICENSE.txt has complete terms"
                },
                "content": "# Requirements for Outputs\n\n## All Excel files\n\n### Zero Formula Errors\n- Every Excel model MUST be delivered with ZERO formula errors (#REF!, #DIV/0!, #VALUE!, #N/A, #NAME?)\n\n### Preserve Existing Templates (when updating templates)\n- Study and EXACTLY match existing format, style, and conventions when modifying files\n- Never impose standardized formatting on files with established patterns\n- Existing template conventions ALWAYS override these guidelines\n\n## Financial models\n\n### Color Coding Standards\nUnless otherwise stated by the user or existing template\n\n#### Industry-Standard Color Conventions\n- **Blue text (RGB: 0,0,255)**: Hardcoded inputs, and numbers users will change for scenarios\n- **Black text (RGB: 0,0,0)**: ALL formulas and calculations\n- **Green text (RGB: 0,128,0)**: Links pulling from other worksheets within same workbook\n- **Red text (RGB: 255,0,0)**: External links to other files\n- **Yellow background (RGB: 255,255,0)**: Key assumptions needing attention or cells that need to be updated\n\n### Number Formatting Standards\n\n#### Required Format Rules\n- **Years**: Format as text strings (e.g., \"2024\" not \"2,024\")\n- **Currency**: Use $#,##0 format; ALWAYS specify units in headers (\"Revenue ($mm)\")\n- **Zeros**: Use number formatting to make all zeros \"-\", including percentages (e.g., \"$#,##0;($#,##0);-\")\n- **Percentages**: Default to 0.0% format (one decimal)\n- **Multiples**: Format as 0.0x for valuation multiples (EV/EBITDA, P/E)\n- **Negative numbers**: Use parentheses (123) not minus -123\n\n### Formula Construction Rules\n\n#### Assumptions Placement\n- Place ALL assumptions (growth rates, margins, multiples, etc.) in separate assumption cells\n- Use cell references instead of hardcoded values in formulas\n- Example: Use =B5*(1+$B$6) instead of =B5*1.05\n\n#### Formula Error Prevention\n- Verify all cell references are correct\n- Check for off-by-one errors in ranges\n- Ensure consistent formulas across all projection periods\n- Test with edge cases (zero values, negative numbers)\n- Verify no unintended circular references\n\n#### Documentation Requirements for Hardcodes\n- Comment or in cells beside (if end of table). Format: \"Source: [System/Document], [Date], [Specific Reference], [URL if applicable]\"\n- Examples:\n  - \"Source: Company 10-K, FY2024, Page 45, Revenue Note, [SEC EDGAR URL]\"\n  - \"Source: Company 10-Q, Q2 2025, Exhibit 99.1, [SEC EDGAR URL]\"\n  - \"Source: Bloomberg Terminal, 8/15/2025, AAPL US Equity\"\n  - \"Source: FactSet, 8/20/2025, Consensus Estimates Screen\"\n\n# XLSX creation, editing, and analysis\n\n## Overview\n\nA user may ask you to create, edit, or analyze the contents of an .xlsx file. You have different tools and workflows available for different tasks.\n\n## Important Requirements\n\n**LibreOffice Required for Formula Recalculation**: You can assume LibreOffice is installed for recalculating formula values using the `recalc.py` script. The script automatically configures LibreOffice on first run\n\n## Reading and analyzing data\n\n### Data analysis with pandas\nFor data analysis, visualization, and basic operations, use **pandas** which provides powerful data manipulation capabilities:\n\n```python\nimport pandas as pd\n\n# Read Excel\ndf = pd.read_excel('file.xlsx')  # Default: first sheet\nall_sheets = pd.read_excel('file.xlsx', sheet_name=None)  # All sheets as dict\n\n# Analyze\ndf.head()      # Preview data\ndf.info()      # Column info\ndf.describe()  # Statistics\n\n# Write Excel\ndf.to_excel('output.xlsx', index=False)\n```\n\n## Excel File Workflows\n\n## CRITICAL: Use Formulas, Not Hardcoded Values\n\n**Always use Excel formulas instead of calculating values in Python and hardcoding them.** This ensures the spreadsheet remains dynamic and updateable.\n\n### âŒ WRONG - Hardcoding Calculated Values\n```python\n# Bad: Calculating in Python and hardcoding result\ntotal = df['Sales'].sum()\nsheet['B10'] = total  # Hardcodes 5000\n\n# Bad: Computing growth rate in Python\ngrowth = (df.iloc[-1]['Revenue'] - df.iloc[0]['Revenue']) / df.iloc[0]['Revenue']\nsheet['C5'] = growth  # Hardcodes 0.15\n\n# Bad: Python calculation for average\navg = sum(values) / len(values)\nsheet['D20'] = avg  # Hardcodes 42.5\n```\n\n### âœ… CORRECT - Using Excel Formulas\n```python\n# Good: Let Excel calculate the sum\nsheet['B10'] = '=SUM(B2:B9)'\n\n# Good: Growth rate as Excel formula\nsheet['C5'] = '=(C4-C2)/C2'\n\n# Good: Average using Excel function\nsheet['D20'] = '=AVERAGE(D2:D19)'\n```\n\nThis applies to ALL calculations - totals, percentages, ratios, differences, etc. The spreadsheet should be able to recalculate when source data changes.\n\n## Common Workflow\n1. **Choose tool**: pandas for data, openpyxl for formulas/formatting\n2. **Create/Load**: Create new workbook or load existing file\n3. **Modify**: Add/edit data, formulas, and formatting\n4. **Save**: Write to file\n5. **Recalculate formulas (MANDATORY IF USING FORMULAS)**: Use the recalc.py script\n   ```bash\n   python recalc.py output.xlsx\n   ```\n6. **Verify and fix any errors**: \n   - The script returns JSON with error details\n   - If `status` is `errors_found`, check `error_summary` for specific error types and locations\n   - Fix the identified errors and recalculate again\n   - Common errors to fix:\n     - `#REF!`: Invalid cell references\n     - `#DIV/0!`: Division by zero\n     - `#VALUE!`: Wrong data type in formula\n     - `#NAME?`: Unrecognized formula name\n\n### Creating new Excel files\n\n```python\n# Using openpyxl for formulas and formatting\nfrom openpyxl import Workbook\nfrom openpyxl.styles import Font, PatternFill, Alignment\n\nwb = Workbook()\nsheet = wb.active\n\n# Add data\nsheet['A1'] = 'Hello'\nsheet['B1'] = 'World'\nsheet.append(['Row', 'of', 'data'])\n\n# Add formula\nsheet['B2'] = '=SUM(A1:A10)'\n\n# Formatting\nsheet['A1'].font = Font(bold=True, color='FF0000')\nsheet['A1'].fill = PatternFill('solid', start_color='FFFF00')\nsheet['A1'].alignment = Alignment(horizontal='center')\n\n# Column width\nsheet.column_dimensions['A'].width = 20\n\nwb.save('output.xlsx')\n```\n\n### Editing existing Excel files\n\n```python\n# Using openpyxl to preserve formulas and formatting\nfrom openpyxl import load_workbook\n\n# Load existing file\nwb = load_workbook('existing.xlsx')\nsheet = wb.active  # or wb['SheetName'] for specific sheet\n\n# Working with multiple sheets\nfor sheet_name in wb.sheetnames:\n    sheet = wb[sheet_name]\n    print(f\"Sheet: {sheet_name}\")\n\n# Modify cells\nsheet['A1'] = 'New Value'\nsheet.insert_rows(2)  # Insert row at position 2\nsheet.delete_cols(3)  # Delete column 3\n\n# Add new sheet\nnew_sheet = wb.create_sheet('NewSheet')\nnew_sheet['A1'] = 'Data'\n\nwb.save('modified.xlsx')\n```\n\n## Recalculating formulas\n\nExcel files created or modified by openpyxl contain formulas as strings but not calculated values. Use the provided `recalc.py` script to recalculate formulas:\n\n```bash\npython recalc.py <excel_file> [timeout_seconds]\n```\n\nExample:\n```bash\npython recalc.py output.xlsx 30\n```\n\nThe script:\n- Automatically sets up LibreOffice macro on first run\n- Recalculates all formulas in all sheets\n- Scans ALL cells for Excel errors (#REF!, #DIV/0!, etc.)\n- Returns JSON with detailed error locations and counts\n- Works on both Linux and macOS\n\n## Formula Verification Checklist\n\nQuick checks to ensure formulas work correctly:\n\n### Essential Verification\n- [ ] **Test 2-3 sample references**: Verify they pull correct values before building full model\n- [ ] **Column mapping**: Confirm Excel columns match (e.g., column 64 = BL, not BK)\n- [ ] **Row offset**: Remember Excel rows are 1-indexed (DataFrame row 5 = Excel row 6)\n\n### Common Pitfalls\n- [ ] **NaN handling**: Check for null values with `pd.notna()`\n- [ ] **Far-right columns**: FY data often in columns 50+ \n- [ ] **Multiple matches**: Search all occurrences, not just first\n- [ ] **Division by zero**: Check denominators before using `/` in formulas (#DIV/0!)\n- [ ] **Wrong references**: Verify all cell references point to intended cells (#REF!)\n- [ ] **Cross-sheet references**: Use correct format (Sheet1!A1) for linking sheets\n\n### Formula Testing Strategy\n- [ ] **Start small**: Test formulas on 2-3 cells before applying broadly\n- [ ] **Verify dependencies**: Check all cells referenced in formulas exist\n- [ ] **Test edge cases**: Include zero, negative, and very large values\n\n### Interpreting recalc.py Output\nThe script returns JSON with error details:\n```json\n{\n  \"status\": \"success\",           // or \"errors_found\"\n  \"total_errors\": 0,              // Total error count\n  \"total_formulas\": 42,           // Number of formulas in file\n  \"error_summary\": {              // Only present if errors found\n    \"#REF!\": {\n      \"count\": 2,\n      \"locations\": [\"Sheet1!B5\", \"Sheet1!C10\"]\n    }\n  }\n}\n```\n\n## Best Practices\n\n### Library Selection\n- **pandas**: Best for data analysis, bulk operations, and simple data export\n- **openpyxl**: Best for complex formatting, formulas, and Excel-specific features\n\n### Working with openpyxl\n- Cell indices are 1-based (row=1, column=1 refers to cell A1)\n- Use `data_only=True` to read calculated values: `load_workbook('file.xlsx', data_only=True)`\n- **Warning**: If opened with `data_only=True` and saved, formulas are replaced with values and permanently lost\n- For large files: Use `read_only=True` for reading or `write_only=True` for writing\n- Formulas are preserved but not evaluated - use recalc.py to update values\n\n### Working with pandas\n- Specify data types to avoid inference issues: `pd.read_excel('file.xlsx', dtype={'id': str})`\n- For large files, read specific columns: `pd.read_excel('file.xlsx', usecols=['A', 'C', 'E'])`\n- Handle dates properly: `pd.read_excel('file.xlsx', parse_dates=['date_column'])`\n\n## Code Style Guidelines\n**IMPORTANT**: When generating Python code for Excel operations:\n- Write minimal, concise Python code without unnecessary comments\n- Avoid verbose variable names and redundant operations\n- Avoid unnecessary print statements\n\n**For Excel files themselves**:\n- Add comments to cells with complex formulas or important assumptions\n- Document data sources for hardcoded values\n- Include notes for key calculations and model sections"
              }
            ]
          },
          {
            "name": "example-skills",
            "description": "Collection of example skills demonstrating various capabilities including skill creation, MCP building, visual design, algorithmic art, internal communications, web testing, artifact building, Slack GIFs, and theme styling",
            "source": "./",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/skills",
              "/plugin install example-skills@anthropic-agent-skills"
            ],
            "signals": {
              "stars": 38467,
              "forks": 3501,
              "pushed_at": "2025-12-20T18:09:45Z",
              "created_at": "2025-09-22T15:53:31Z",
              "license": null
            },
            "commands": [],
            "skills": [
              {
                "name": "algorithmic-art",
                "description": "Creating algorithmic art using p5.js with seeded randomness and interactive parameter exploration. Use this when users request creating art using code, generative art, algorithmic art, flow fields, or particle systems. Create original algorithmic art rather than copying existing artists' work to avoid copyright violations.",
                "path": "skills/algorithmic-art/SKILL.md",
                "frontmatter": {
                  "name": "algorithmic-art",
                  "description": "Creating algorithmic art using p5.js with seeded randomness and interactive parameter exploration. Use this when users request creating art using code, generative art, algorithmic art, flow fields, or particle systems. Create original algorithmic art rather than copying existing artists' work to avoid copyright violations.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "Algorithmic philosophies are computational aesthetic movements that are then expressed through code. Output .md files (philosophy), .html files (interactive viewer), and .js files (generative algorithms).\n\nThis happens in two steps:\n1. Algorithmic Philosophy Creation (.md file)\n2. Express by creating p5.js generative art (.html + .js files)\n\nFirst, undertake this task:\n\n## ALGORITHMIC PHILOSOPHY CREATION\n\nTo begin, create an ALGORITHMIC PHILOSOPHY (not static images or templates) that will be interpreted through:\n- Computational processes, emergent behavior, mathematical beauty\n- Seeded randomness, noise fields, organic systems\n- Particles, flows, fields, forces\n- Parametric variation and controlled chaos\n\n### THE CRITICAL UNDERSTANDING\n- What is received: Some subtle input or instructions by the user to take into account, but use as a foundation; it should not constrain creative freedom.\n- What is created: An algorithmic philosophy/generative aesthetic movement.\n- What happens next: The same version receives the philosophy and EXPRESSES IT IN CODE - creating p5.js sketches that are 90% algorithmic generation, 10% essential parameters.\n\nConsider this approach:\n- Write a manifesto for a generative art movement\n- The next phase involves writing the algorithm that brings it to life\n\nThe philosophy must emphasize: Algorithmic expression. Emergent behavior. Computational beauty. Seeded variation.\n\n### HOW TO GENERATE AN ALGORITHMIC PHILOSOPHY\n\n**Name the movement** (1-2 words): \"Organic Turbulence\" / \"Quantum Harmonics\" / \"Emergent Stillness\"\n\n**Articulate the philosophy** (4-6 paragraphs - concise but complete):\n\nTo capture the ALGORITHMIC essence, express how this philosophy manifests through:\n- Computational processes and mathematical relationships?\n- Noise functions and randomness patterns?\n- Particle behaviors and field dynamics?\n- Temporal evolution and system states?\n- Parametric variation and emergent complexity?\n\n**CRITICAL GUIDELINES:**\n- **Avoid redundancy**: Each algorithmic aspect should be mentioned once. Avoid repeating concepts about noise theory, particle dynamics, or mathematical principles unless adding new depth.\n- **Emphasize craftsmanship REPEATEDLY**: The philosophy MUST stress multiple times that the final algorithm should appear as though it took countless hours to develop, was refined with care, and comes from someone at the absolute top of their field. This framing is essential - repeat phrases like \"meticulously crafted algorithm,\" \"the product of deep computational expertise,\" \"painstaking optimization,\" \"master-level implementation.\"\n- **Leave creative space**: Be specific about the algorithmic direction, but concise enough that the next Claude has room to make interpretive implementation choices at an extremely high level of craftsmanship.\n\nThe philosophy must guide the next version to express ideas ALGORITHMICALLY, not through static images. Beauty lives in the process, not the final frame.\n\n### PHILOSOPHY EXAMPLES\n\n**\"Organic Turbulence\"**\nPhilosophy: Chaos constrained by natural law, order emerging from disorder.\nAlgorithmic expression: Flow fields driven by layered Perlin noise. Thousands of particles following vector forces, their trails accumulating into organic density maps. Multiple noise octaves create turbulent regions and calm zones. Color emerges from velocity and density - fast particles burn bright, slow ones fade to shadow. The algorithm runs until equilibrium - a meticulously tuned balance where every parameter was refined through countless iterations by a master of computational aesthetics.\n\n**\"Quantum Harmonics\"**\nPhilosophy: Discrete entities exhibiting wave-like interference patterns.\nAlgorithmic expression: Particles initialized on a grid, each carrying a phase value that evolves through sine waves. When particles are near, their phases interfere - constructive interference creates bright nodes, destructive creates voids. Simple harmonic motion generates complex emergent mandalas. The result of painstaking frequency calibration where every ratio was carefully chosen to produce resonant beauty.\n\n**\"Recursive Whispers\"**\nPhilosophy: Self-similarity across scales, infinite depth in finite space.\nAlgorithmic expression: Branching structures that subdivide recursively. Each branch slightly randomized but constrained by golden ratios. L-systems or recursive subdivision generate tree-like forms that feel both mathematical and organic. Subtle noise perturbations break perfect symmetry. Line weights diminish with each recursion level. Every branching angle the product of deep mathematical exploration.\n\n**\"Field Dynamics\"**\nPhilosophy: Invisible forces made visible through their effects on matter.\nAlgorithmic expression: Vector fields constructed from mathematical functions or noise. Particles born at edges, flowing along field lines, dying when they reach equilibrium or boundaries. Multiple fields can attract, repel, or rotate particles. The visualization shows only the traces - ghost-like evidence of invisible forces. A computational dance meticulously choreographed through force balance.\n\n**\"Stochastic Crystallization\"**\nPhilosophy: Random processes crystallizing into ordered structures.\nAlgorithmic expression: Randomized circle packing or Voronoi tessellation. Start with random points, let them evolve through relaxation algorithms. Cells push apart until equilibrium. Color based on cell size, neighbor count, or distance from center. The organic tiling that emerges feels both random and inevitable. Every seed produces unique crystalline beauty - the mark of a master-level generative algorithm.\n\n*These are condensed examples. The actual algorithmic philosophy should be 4-6 substantial paragraphs.*\n\n### ESSENTIAL PRINCIPLES\n- **ALGORITHMIC PHILOSOPHY**: Creating a computational worldview to be expressed through code\n- **PROCESS OVER PRODUCT**: Always emphasize that beauty emerges from the algorithm's execution - each run is unique\n- **PARAMETRIC EXPRESSION**: Ideas communicate through mathematical relationships, forces, behaviors - not static composition\n- **ARTISTIC FREEDOM**: The next Claude interprets the philosophy algorithmically - provide creative implementation room\n- **PURE GENERATIVE ART**: This is about making LIVING ALGORITHMS, not static images with randomness\n- **EXPERT CRAFTSMANSHIP**: Repeatedly emphasize the final algorithm must feel meticulously crafted, refined through countless iterations, the product of deep expertise by someone at the absolute top of their field in computational aesthetics\n\n**The algorithmic philosophy should be 4-6 paragraphs long.** Fill it with poetic computational philosophy that brings together the intended vision. Avoid repeating the same points. Output this algorithmic philosophy as a .md file.\n\n---\n\n## DEDUCING THE CONCEPTUAL SEED\n\n**CRITICAL STEP**: Before implementing the algorithm, identify the subtle conceptual thread from the original request.\n\n**THE ESSENTIAL PRINCIPLE**:\nThe concept is a **subtle, niche reference embedded within the algorithm itself** - not always literal, always sophisticated. Someone familiar with the subject should feel it intuitively, while others simply experience a masterful generative composition. The algorithmic philosophy provides the computational language. The deduced concept provides the soul - the quiet conceptual DNA woven invisibly into parameters, behaviors, and emergence patterns.\n\nThis is **VERY IMPORTANT**: The reference must be so refined that it enhances the work's depth without announcing itself. Think like a jazz musician quoting another song through algorithmic harmony - only those who know will catch it, but everyone appreciates the generative beauty.\n\n---\n\n## P5.JS IMPLEMENTATION\n\nWith the philosophy AND conceptual framework established, express it through code. Pause to gather thoughts before proceeding. Use only the algorithmic philosophy created and the instructions below.\n\n### âš ï¸ STEP 0: READ THE TEMPLATE FIRST âš ï¸\n\n**CRITICAL: BEFORE writing any HTML:**\n\n1. **Read** `templates/viewer.html` using the Read tool\n2. **Study** the exact structure, styling, and Anthropic branding\n3. **Use that file as the LITERAL STARTING POINT** - not just inspiration\n4. **Keep all FIXED sections exactly as shown** (header, sidebar structure, Anthropic colors/fonts, seed controls, action buttons)\n5. **Replace only the VARIABLE sections** marked in the file's comments (algorithm, parameters, UI controls for parameters)\n\n**Avoid:**\n- âŒ Creating HTML from scratch\n- âŒ Inventing custom styling or color schemes\n- âŒ Using system fonts or dark themes\n- âŒ Changing the sidebar structure\n\n**Follow these practices:**\n- âœ… Copy the template's exact HTML structure\n- âœ… Keep Anthropic branding (Poppins/Lora fonts, light colors, gradient backdrop)\n- âœ… Maintain the sidebar layout (Seed â†’ Parameters â†’ Colors? â†’ Actions)\n- âœ… Replace only the p5.js algorithm and parameter controls\n\nThe template is the foundation. Build on it, don't rebuild it.\n\n---\n\nTo create gallery-quality computational art that lives and breathes, use the algorithmic philosophy as the foundation.\n\n### TECHNICAL REQUIREMENTS\n\n**Seeded Randomness (Art Blocks Pattern)**:\n```javascript\n// ALWAYS use a seed for reproducibility\nlet seed = 12345; // or hash from user input\nrandomSeed(seed);\nnoiseSeed(seed);\n```\n\n**Parameter Structure - FOLLOW THE PHILOSOPHY**:\n\nTo establish parameters that emerge naturally from the algorithmic philosophy, consider: \"What qualities of this system can be adjusted?\"\n\n```javascript\nlet params = {\n  seed: 12345,  // Always include seed for reproducibility\n  // colors\n  // Add parameters that control YOUR algorithm:\n  // - Quantities (how many?)\n  // - Scales (how big? how fast?)\n  // - Probabilities (how likely?)\n  // - Ratios (what proportions?)\n  // - Angles (what direction?)\n  // - Thresholds (when does behavior change?)\n};\n```\n\n**To design effective parameters, focus on the properties the system needs to be tunable rather than thinking in terms of \"pattern types\".**\n\n**Core Algorithm - EXPRESS THE PHILOSOPHY**:\n\n**CRITICAL**: The algorithmic philosophy should dictate what to build.\n\nTo express the philosophy through code, avoid thinking \"which pattern should I use?\" and instead think \"how to express this philosophy through code?\"\n\nIf the philosophy is about **organic emergence**, consider using:\n- Elements that accumulate or grow over time\n- Random processes constrained by natural rules\n- Feedback loops and interactions\n\nIf the philosophy is about **mathematical beauty**, consider using:\n- Geometric relationships and ratios\n- Trigonometric functions and harmonics\n- Precise calculations creating unexpected patterns\n\nIf the philosophy is about **controlled chaos**, consider using:\n- Random variation within strict boundaries\n- Bifurcation and phase transitions\n- Order emerging from disorder\n\n**The algorithm flows from the philosophy, not from a menu of options.**\n\nTo guide the implementation, let the conceptual essence inform creative and original choices. Build something that expresses the vision for this particular request.\n\n**Canvas Setup**: Standard p5.js structure:\n```javascript\nfunction setup() {\n  createCanvas(1200, 1200);\n  // Initialize your system\n}\n\nfunction draw() {\n  // Your generative algorithm\n  // Can be static (noLoop) or animated\n}\n```\n\n### CRAFTSMANSHIP REQUIREMENTS\n\n**CRITICAL**: To achieve mastery, create algorithms that feel like they emerged through countless iterations by a master generative artist. Tune every parameter carefully. Ensure every pattern emerges with purpose. This is NOT random noise - this is CONTROLLED CHAOS refined through deep expertise.\n\n- **Balance**: Complexity without visual noise, order without rigidity\n- **Color Harmony**: Thoughtful palettes, not random RGB values\n- **Composition**: Even in randomness, maintain visual hierarchy and flow\n- **Performance**: Smooth execution, optimized for real-time if animated\n- **Reproducibility**: Same seed ALWAYS produces identical output\n\n### OUTPUT FORMAT\n\nOutput:\n1. **Algorithmic Philosophy** - As markdown or text explaining the generative aesthetic\n2. **Single HTML Artifact** - Self-contained interactive generative art built from `templates/viewer.html` (see STEP 0 and next section)\n\nThe HTML artifact contains everything: p5.js (from CDN), the algorithm, parameter controls, and UI - all in one file that works immediately in claude.ai artifacts or any browser. Start from the template file, not from scratch.\n\n---\n\n## INTERACTIVE ARTIFACT CREATION\n\n**REMINDER: `templates/viewer.html` should have already been read (see STEP 0). Use that file as the starting point.**\n\nTo allow exploration of the generative art, create a single, self-contained HTML artifact. Ensure this artifact works immediately in claude.ai or any browser - no setup required. Embed everything inline.\n\n### CRITICAL: WHAT'S FIXED VS VARIABLE\n\nThe `templates/viewer.html` file is the foundation. It contains the exact structure and styling needed.\n\n**FIXED (always include exactly as shown):**\n- Layout structure (header, sidebar, main canvas area)\n- Anthropic branding (UI colors, fonts, gradients)\n- Seed section in sidebar:\n  - Seed display\n  - Previous/Next buttons\n  - Random button\n  - Jump to seed input + Go button\n- Actions section in sidebar:\n  - Regenerate button\n  - Reset button\n\n**VARIABLE (customize for each artwork):**\n- The entire p5.js algorithm (setup/draw/classes)\n- The parameters object (define what the art needs)\n- The Parameters section in sidebar:\n  - Number of parameter controls\n  - Parameter names\n  - Min/max/step values for sliders\n  - Control types (sliders, inputs, etc.)\n- Colors section (optional):\n  - Some art needs color pickers\n  - Some art might use fixed colors\n  - Some art might be monochrome (no color controls needed)\n  - Decide based on the art's needs\n\n**Every artwork should have unique parameters and algorithm!** The fixed parts provide consistent UX - everything else expresses the unique vision.\n\n### REQUIRED FEATURES\n\n**1. Parameter Controls**\n- Sliders for numeric parameters (particle count, noise scale, speed, etc.)\n- Color pickers for palette colors\n- Real-time updates when parameters change\n- Reset button to restore defaults\n\n**2. Seed Navigation**\n- Display current seed number\n- \"Previous\" and \"Next\" buttons to cycle through seeds\n- \"Random\" button for random seed\n- Input field to jump to specific seed\n- Generate 100 variations when requested (seeds 1-100)\n\n**3. Single Artifact Structure**\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <!-- p5.js from CDN - always available -->\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js\"></script>\n  <style>\n    /* All styling inline - clean, minimal */\n    /* Canvas on top, controls below */\n  </style>\n</head>\n<body>\n  <div id=\"canvas-container\"></div>\n  <div id=\"controls\">\n    <!-- All parameter controls -->\n  </div>\n  <script>\n    // ALL p5.js code inline here\n    // Parameter objects, classes, functions\n    // setup() and draw()\n    // UI handlers\n    // Everything self-contained\n  </script>\n</body>\n</html>\n```\n\n**CRITICAL**: This is a single artifact. No external files, no imports (except p5.js CDN). Everything inline.\n\n**4. Implementation Details - BUILD THE SIDEBAR**\n\nThe sidebar structure:\n\n**1. Seed (FIXED)** - Always include exactly as shown:\n- Seed display\n- Prev/Next/Random/Jump buttons\n\n**2. Parameters (VARIABLE)** - Create controls for the art:\n```html\n<div class=\"control-group\">\n    <label>Parameter Name</label>\n    <input type=\"range\" id=\"param\" min=\"...\" max=\"...\" step=\"...\" value=\"...\" oninput=\"updateParam('param', this.value)\">\n    <span class=\"value-display\" id=\"param-value\">...</span>\n</div>\n```\nAdd as many control-group divs as there are parameters.\n\n**3. Colors (OPTIONAL/VARIABLE)** - Include if the art needs adjustable colors:\n- Add color pickers if users should control palette\n- Skip this section if the art uses fixed colors\n- Skip if the art is monochrome\n\n**4. Actions (FIXED)** - Always include exactly as shown:\n- Regenerate button\n- Reset button\n- Download PNG button\n\n**Requirements**:\n- Seed controls must work (prev/next/random/jump/display)\n- All parameters must have UI controls\n- Regenerate, Reset, Download buttons must work\n- Keep Anthropic branding (UI styling, not art colors)\n\n### USING THE ARTIFACT\n\nThe HTML artifact works immediately:\n1. **In claude.ai**: Displayed as an interactive artifact - runs instantly\n2. **As a file**: Save and open in any browser - no server needed\n3. **Sharing**: Send the HTML file - it's completely self-contained\n\n---\n\n## VARIATIONS & EXPLORATION\n\nThe artifact includes seed navigation by default (prev/next/random buttons), allowing users to explore variations without creating multiple files. If the user wants specific variations highlighted:\n\n- Include seed presets (buttons for \"Variation 1: Seed 42\", \"Variation 2: Seed 127\", etc.)\n- Add a \"Gallery Mode\" that shows thumbnails of multiple seeds side-by-side\n- All within the same single artifact\n\nThis is like creating a series of prints from the same plate - the algorithm is consistent, but each seed reveals different facets of its potential. The interactive nature means users discover their own favorites by exploring the seed space.\n\n---\n\n## THE CREATIVE PROCESS\n\n**User request** â†’ **Algorithmic philosophy** â†’ **Implementation**\n\nEach request is unique. The process involves:\n\n1. **Interpret the user's intent** - What aesthetic is being sought?\n2. **Create an algorithmic philosophy** (4-6 paragraphs) describing the computational approach\n3. **Implement it in code** - Build the algorithm that expresses this philosophy\n4. **Design appropriate parameters** - What should be tunable?\n5. **Build matching UI controls** - Sliders/inputs for those parameters\n\n**The constants**:\n- Anthropic branding (colors, fonts, layout)\n- Seed navigation (always present)\n- Self-contained HTML artifact\n\n**Everything else is variable**:\n- The algorithm itself\n- The parameters\n- The UI controls\n- The visual outcome\n\nTo achieve the best results, trust creativity and let the philosophy guide the implementation.\n\n---\n\n## RESOURCES\n\nThis skill includes helpful templates and documentation:\n\n- **templates/viewer.html**: REQUIRED STARTING POINT for all HTML artifacts.\n  - This is the foundation - contains the exact structure and Anthropic branding\n  - **Keep unchanged**: Layout structure, sidebar organization, Anthropic colors/fonts, seed controls, action buttons\n  - **Replace**: The p5.js algorithm, parameter definitions, and UI controls in Parameters section\n  - The extensive comments in the file mark exactly what to keep vs replace\n\n- **templates/generator_template.js**: Reference for p5.js best practices and code structure principles.\n  - Shows how to organize parameters, use seeded randomness, structure classes\n  - NOT a pattern menu - use these principles to build unique algorithms\n  - Embed algorithms inline in the HTML artifact (don't create separate .js files)\n\n**Critical reminder**:\n- The **template is the STARTING POINT**, not inspiration\n- The **algorithm is where to create** something unique\n- Don't copy the flow field example - build what the philosophy demands\n- But DO keep the exact UI structure and Anthropic branding from the template"
              },
              {
                "name": "brand-guidelines",
                "description": "Applies Anthropic's official brand colors and typography to any sort of artifact that may benefit from having Anthropic's look-and-feel. Use it when brand colors or style guidelines, visual formatting, or company design standards apply.",
                "path": "skills/brand-guidelines/SKILL.md",
                "frontmatter": {
                  "name": "brand-guidelines",
                  "description": "Applies Anthropic's official brand colors and typography to any sort of artifact that may benefit from having Anthropic's look-and-feel. Use it when brand colors or style guidelines, visual formatting, or company design standards apply.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "# Anthropic Brand Styling\n\n## Overview\n\nTo access Anthropic's official brand identity and style resources, use this skill.\n\n**Keywords**: branding, corporate identity, visual identity, post-processing, styling, brand colors, typography, Anthropic brand, visual formatting, visual design\n\n## Brand Guidelines\n\n### Colors\n\n**Main Colors:**\n\n- Dark: `#141413` - Primary text and dark backgrounds\n- Light: `#faf9f5` - Light backgrounds and text on dark\n- Mid Gray: `#b0aea5` - Secondary elements\n- Light Gray: `#e8e6dc` - Subtle backgrounds\n\n**Accent Colors:**\n\n- Orange: `#d97757` - Primary accent\n- Blue: `#6a9bcc` - Secondary accent\n- Green: `#788c5d` - Tertiary accent\n\n### Typography\n\n- **Headings**: Poppins (with Arial fallback)\n- **Body Text**: Lora (with Georgia fallback)\n- **Note**: Fonts should be pre-installed in your environment for best results\n\n## Features\n\n### Smart Font Application\n\n- Applies Poppins font to headings (24pt and larger)\n- Applies Lora font to body text\n- Automatically falls back to Arial/Georgia if custom fonts unavailable\n- Preserves readability across all systems\n\n### Text Styling\n\n- Headings (24pt+): Poppins font\n- Body text: Lora font\n- Smart color selection based on background\n- Preserves text hierarchy and formatting\n\n### Shape and Accent Colors\n\n- Non-text shapes use accent colors\n- Cycles through orange, blue, and green accents\n- Maintains visual interest while staying on-brand\n\n## Technical Details\n\n### Font Management\n\n- Uses system-installed Poppins and Lora fonts when available\n- Provides automatic fallback to Arial (headings) and Georgia (body)\n- No font installation required - works with existing system fonts\n- For best results, pre-install Poppins and Lora fonts in your environment\n\n### Color Application\n\n- Uses RGB color values for precise brand matching\n- Applied via python-pptx's RGBColor class\n- Maintains color fidelity across different systems"
              },
              {
                "name": "canvas-design",
                "description": "Create beautiful visual art in .png and .pdf documents using design philosophy. You should use this skill when the user asks to create a poster, piece of art, design, or other static piece. Create original visual designs, never copying existing artists' work to avoid copyright violations.",
                "path": "skills/canvas-design/SKILL.md",
                "frontmatter": {
                  "name": "canvas-design",
                  "description": "Create beautiful visual art in .png and .pdf documents using design philosophy. You should use this skill when the user asks to create a poster, piece of art, design, or other static piece. Create original visual designs, never copying existing artists' work to avoid copyright violations.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "These are instructions for creating design philosophies - aesthetic movements that are then EXPRESSED VISUALLY. Output only .md files, .pdf files, and .png files.\n\nComplete this in two steps:\n1. Design Philosophy Creation (.md file)\n2. Express by creating it on a canvas (.pdf file or .png file)\n\nFirst, undertake this task:\n\n## DESIGN PHILOSOPHY CREATION\n\nTo begin, create a VISUAL PHILOSOPHY (not layouts or templates) that will be interpreted through:\n- Form, space, color, composition\n- Images, graphics, shapes, patterns\n- Minimal text as visual accent\n\n### THE CRITICAL UNDERSTANDING\n- What is received: Some subtle input or instructions by the user that should be taken into account, but used as a foundation; it should not constrain creative freedom.\n- What is created: A design philosophy/aesthetic movement.\n- What happens next: Then, the same version receives the philosophy and EXPRESSES IT VISUALLY - creating artifacts that are 90% visual design, 10% essential text.\n\nConsider this approach:\n- Write a manifesto for an art movement\n- The next phase involves making the artwork\n\nThe philosophy must emphasize: Visual expression. Spatial communication. Artistic interpretation. Minimal words.\n\n### HOW TO GENERATE A VISUAL PHILOSOPHY\n\n**Name the movement** (1-2 words): \"Brutalist Joy\" / \"Chromatic Silence\" / \"Metabolist Dreams\"\n\n**Articulate the philosophy** (4-6 paragraphs - concise but complete):\n\nTo capture the VISUAL essence, express how the philosophy manifests through:\n- Space and form\n- Color and material\n- Scale and rhythm\n- Composition and balance\n- Visual hierarchy\n\n**CRITICAL GUIDELINES:**\n- **Avoid redundancy**: Each design aspect should be mentioned once. Avoid repeating points about color theory, spatial relationships, or typographic principles unless adding new depth.\n- **Emphasize craftsmanship REPEATEDLY**: The philosophy MUST stress multiple times that the final work should appear as though it took countless hours to create, was labored over with care, and comes from someone at the absolute top of their field. This framing is essential - repeat phrases like \"meticulously crafted,\" \"the product of deep expertise,\" \"painstaking attention,\" \"master-level execution.\"\n- **Leave creative space**: Remain specific about the aesthetic direction, but concise enough that the next Claude has room to make interpretive choices also at a extremely high level of craftmanship.\n\nThe philosophy must guide the next version to express ideas VISUALLY, not through text. Information lives in design, not paragraphs.\n\n### PHILOSOPHY EXAMPLES\n\n**\"Concrete Poetry\"**\nPhilosophy: Communication through monumental form and bold geometry.\nVisual expression: Massive color blocks, sculptural typography (huge single words, tiny labels), Brutalist spatial divisions, Polish poster energy meets Le Corbusier. Ideas expressed through visual weight and spatial tension, not explanation. Text as rare, powerful gesture - never paragraphs, only essential words integrated into the visual architecture. Every element placed with the precision of a master craftsman.\n\n**\"Chromatic Language\"**\nPhilosophy: Color as the primary information system.\nVisual expression: Geometric precision where color zones create meaning. Typography minimal - small sans-serif labels letting chromatic fields communicate. Think Josef Albers' interaction meets data visualization. Information encoded spatially and chromatically. Words only to anchor what color already shows. The result of painstaking chromatic calibration.\n\n**\"Analog Meditation\"**\nPhilosophy: Quiet visual contemplation through texture and breathing room.\nVisual expression: Paper grain, ink bleeds, vast negative space. Photography and illustration dominate. Typography whispered (small, restrained, serving the visual). Japanese photobook aesthetic. Images breathe across pages. Text appears sparingly - short phrases, never explanatory blocks. Each composition balanced with the care of a meditation practice.\n\n**\"Organic Systems\"**\nPhilosophy: Natural clustering and modular growth patterns.\nVisual expression: Rounded forms, organic arrangements, color from nature through architecture. Information shown through visual diagrams, spatial relationships, iconography. Text only for key labels floating in space. The composition tells the story through expert spatial orchestration.\n\n**\"Geometric Silence\"**\nPhilosophy: Pure order and restraint.\nVisual expression: Grid-based precision, bold photography or stark graphics, dramatic negative space. Typography precise but minimal - small essential text, large quiet zones. Swiss formalism meets Brutalist material honesty. Structure communicates, not words. Every alignment the work of countless refinements.\n\n*These are condensed examples. The actual design philosophy should be 4-6 substantial paragraphs.*\n\n### ESSENTIAL PRINCIPLES\n- **VISUAL PHILOSOPHY**: Create an aesthetic worldview to be expressed through design\n- **MINIMAL TEXT**: Always emphasize that text is sparse, essential-only, integrated as visual element - never lengthy\n- **SPATIAL EXPRESSION**: Ideas communicate through space, form, color, composition - not paragraphs\n- **ARTISTIC FREEDOM**: The next Claude interprets the philosophy visually - provide creative room\n- **PURE DESIGN**: This is about making ART OBJECTS, not documents with decoration\n- **EXPERT CRAFTSMANSHIP**: Repeatedly emphasize the final work must look meticulously crafted, labored over with care, the product of countless hours by someone at the top of their field\n\n**The design philosophy should be 4-6 paragraphs long.** Fill it with poetic design philosophy that brings together the core vision. Avoid repeating the same points. Keep the design philosophy generic without mentioning the intention of the art, as if it can be used wherever. Output the design philosophy as a .md file.\n\n---\n\n## DEDUCING THE SUBTLE REFERENCE\n\n**CRITICAL STEP**: Before creating the canvas, identify the subtle conceptual thread from the original request.\n\n**THE ESSENTIAL PRINCIPLE**:\nThe topic is a **subtle, niche reference embedded within the art itself** - not always literal, always sophisticated. Someone familiar with the subject should feel it intuitively, while others simply experience a masterful abstract composition. The design philosophy provides the aesthetic language. The deduced topic provides the soul - the quiet conceptual DNA woven invisibly into form, color, and composition.\n\nThis is **VERY IMPORTANT**: The reference must be refined so it enhances the work's depth without announcing itself. Think like a jazz musician quoting another song - only those who know will catch it, but everyone appreciates the music.\n\n---\n\n## CANVAS CREATION\n\nWith both the philosophy and the conceptual framework established, express it on a canvas. Take a moment to gather thoughts and clear the mind. Use the design philosophy created and the instructions below to craft a masterpiece, embodying all aspects of the philosophy with expert craftsmanship.\n\n**IMPORTANT**: For any type of content, even if the user requests something for a movie/game/book, the approach should still be sophisticated. Never lose sight of the idea that this should be art, not something that's cartoony or amateur.\n\nTo create museum or magazine quality work, use the design philosophy as the foundation. Create one single page, highly visual, design-forward PDF or PNG output (unless asked for more pages). Generally use repeating patterns and perfect shapes. Treat the abstract philosophical design as if it were a scientific bible, borrowing the visual language of systematic observationâ€”dense accumulation of marks, repeated elements, or layered patterns that build meaning through patient repetition and reward sustained viewing. Add sparse, clinical typography and systematic reference markers that suggest this could be a diagram from an imaginary discipline, treating the invisible subject with the same reverence typically reserved for documenting observable phenomena. Anchor the piece with simple phrase(s) or details positioned subtly, using a limited color palette that feels intentional and cohesive. Embrace the paradox of using analytical visual language to express ideas about human experience: the result should feel like an artifact that proves something ephemeral can be studied, mapped, and understood through careful attention. This is true art. \n\n**Text as a contextual element**: Text is always minimal and visual-first, but let context guide whether that means whisper-quiet labels or bold typographic gestures. A punk venue poster might have larger, more aggressive type than a minimalist ceramics studio identity. Most of the time, font should be thin. All use of fonts must be design-forward and prioritize visual communication. Regardless of text scale, nothing falls off the page and nothing overlaps. Every element must be contained within the canvas boundaries with proper margins. Check carefully that all text, graphics, and visual elements have breathing room and clear separation. This is non-negotiable for professional execution. **IMPORTANT: Use different fonts if writing text. Search the `./canvas-fonts` directory. Regardless of approach, sophistication is non-negotiable.**\n\nDownload and use whatever fonts are needed to make this a reality. Get creative by making the typography actually part of the art itself -- if the art is abstract, bring the font onto the canvas, not typeset digitally.\n\nTo push boundaries, follow design instinct/intuition while using the philosophy as a guiding principle. Embrace ultimate design freedom and choice. Push aesthetics and design to the frontier. \n\n**CRITICAL**: To achieve human-crafted quality (not AI-generated), create work that looks like it took countless hours. Make it appear as though someone at the absolute top of their field labored over every detail with painstaking care. Ensure the composition, spacing, color choices, typography - everything screams expert-level craftsmanship. Double-check that nothing overlaps, formatting is flawless, every detail perfect. Create something that could be shown to people to prove expertise and rank as undeniably impressive.\n\nOutput the final result as a single, downloadable .pdf or .png file, alongside the design philosophy used as a .md file.\n\n---\n\n## FINAL STEP\n\n**IMPORTANT**: The user ALREADY said \"It isn't perfect enough. It must be pristine, a masterpiece if craftsmanship, as if it were about to be displayed in a museum.\"\n\n**CRITICAL**: To refine the work, avoid adding more graphics; instead refine what has been created and make it extremely crisp, respecting the design philosophy and the principles of minimalism entirely. Rather than adding a fun filter or refactoring a font, consider how to make the existing composition more cohesive with the art. If the instinct is to call a new function or draw a new shape, STOP and instead ask: \"How can I make what's already here more of a piece of art?\"\n\nTake a second pass. Go back to the code and refine/polish further to make this a philosophically designed masterpiece.\n\n## MULTI-PAGE OPTION\n\nTo create additional pages when requested, create more creative pages along the same lines as the design philosophy but distinctly different as well. Bundle those pages in the same .pdf or many .pngs. Treat the first page as just a single page in a whole coffee table book waiting to be filled. Make the next pages unique twists and memories of the original. Have them almost tell a story in a very tasteful way. Exercise full creative freedom."
              },
              {
                "name": "doc-coauthoring",
                "description": "Guide users through a structured workflow for co-authoring documentation. Use when user wants to write documentation, proposals, technical specs, decision docs, or similar structured content. This workflow helps users efficiently transfer context, refine content through iteration, and verify the doc works for readers. Trigger when user mentions writing docs, creating proposals, drafting specs, or similar documentation tasks.",
                "path": "skills/doc-coauthoring/SKILL.md",
                "frontmatter": {
                  "name": "doc-coauthoring",
                  "description": "Guide users through a structured workflow for co-authoring documentation. Use when user wants to write documentation, proposals, technical specs, decision docs, or similar structured content. This workflow helps users efficiently transfer context, refine content through iteration, and verify the doc works for readers. Trigger when user mentions writing docs, creating proposals, drafting specs, or similar documentation tasks."
                },
                "content": "# Doc Co-Authoring Workflow\n\nThis skill provides a structured workflow for guiding users through collaborative document creation. Act as an active guide, walking users through three stages: Context Gathering, Refinement & Structure, and Reader Testing.\n\n## When to Offer This Workflow\n\n**Trigger conditions:**\n- User mentions writing documentation: \"write a doc\", \"draft a proposal\", \"create a spec\", \"write up\"\n- User mentions specific doc types: \"PRD\", \"design doc\", \"decision doc\", \"RFC\"\n- User seems to be starting a substantial writing task\n\n**Initial offer:**\nOffer the user a structured workflow for co-authoring the document. Explain the three stages:\n\n1. **Context Gathering**: User provides all relevant context while Claude asks clarifying questions\n2. **Refinement & Structure**: Iteratively build each section through brainstorming and editing\n3. **Reader Testing**: Test the doc with a fresh Claude (no context) to catch blind spots before others read it\n\nExplain that this approach helps ensure the doc works well when others read it (including when they paste it into Claude). Ask if they want to try this workflow or prefer to work freeform.\n\nIf user declines, work freeform. If user accepts, proceed to Stage 1.\n\n## Stage 1: Context Gathering\n\n**Goal:** Close the gap between what the user knows and what Claude knows, enabling smart guidance later.\n\n### Initial Questions\n\nStart by asking the user for meta-context about the document:\n\n1. What type of document is this? (e.g., technical spec, decision doc, proposal)\n2. Who's the primary audience?\n3. What's the desired impact when someone reads this?\n4. Is there a template or specific format to follow?\n5. Any other constraints or context to know?\n\nInform them they can answer in shorthand or dump information however works best for them.\n\n**If user provides a template or mentions a doc type:**\n- Ask if they have a template document to share\n- If they provide a link to a shared document, use the appropriate integration to fetch it\n- If they provide a file, read it\n\n**If user mentions editing an existing shared document:**\n- Use the appropriate integration to read the current state\n- Check for images without alt-text\n- If images exist without alt-text, explain that when others use Claude to understand the doc, Claude won't be able to see them. Ask if they want alt-text generated. If so, request they paste each image into chat for descriptive alt-text generation.\n\n### Info Dumping\n\nOnce initial questions are answered, encourage the user to dump all the context they have. Request information such as:\n- Background on the project/problem\n- Related team discussions or shared documents\n- Why alternative solutions aren't being used\n- Organizational context (team dynamics, past incidents, politics)\n- Timeline pressures or constraints\n- Technical architecture or dependencies\n- Stakeholder concerns\n\nAdvise them not to worry about organizing it - just get it all out. Offer multiple ways to provide context:\n- Info dump stream-of-consciousness\n- Point to team channels or threads to read\n- Link to shared documents\n\n**If integrations are available** (e.g., Slack, Teams, Google Drive, SharePoint, or other MCP servers), mention that these can be used to pull in context directly.\n\n**If no integrations are detected and in Claude.ai or Claude app:** Suggest they can enable connectors in their Claude settings to allow pulling context from messaging apps and document storage directly.\n\nInform them clarifying questions will be asked once they've done their initial dump.\n\n**During context gathering:**\n\n- If user mentions team channels or shared documents:\n  - If integrations available: Inform them the content will be read now, then use the appropriate integration\n  - If integrations not available: Explain lack of access. Suggest they enable connectors in Claude settings, or paste the relevant content directly.\n\n- If user mentions entities/projects that are unknown:\n  - Ask if connected tools should be searched to learn more\n  - Wait for user confirmation before searching\n\n- As user provides context, track what's being learned and what's still unclear\n\n**Asking clarifying questions:**\n\nWhen user signals they've done their initial dump (or after substantial context provided), ask clarifying questions to ensure understanding:\n\nGenerate 5-10 numbered questions based on gaps in the context.\n\nInform them they can use shorthand to answer (e.g., \"1: yes, 2: see #channel, 3: no because backwards compat\"), link to more docs, point to channels to read, or just keep info-dumping. Whatever's most efficient for them.\n\n**Exit condition:**\nSufficient context has been gathered when questions show understanding - when edge cases and trade-offs can be asked about without needing basics explained.\n\n**Transition:**\nAsk if there's any more context they want to provide at this stage, or if it's time to move on to drafting the document.\n\nIf user wants to add more, let them. When ready, proceed to Stage 2.\n\n## Stage 2: Refinement & Structure\n\n**Goal:** Build the document section by section through brainstorming, curation, and iterative refinement.\n\n**Instructions to user:**\nExplain that the document will be built section by section. For each section:\n1. Clarifying questions will be asked about what to include\n2. 5-20 options will be brainstormed\n3. User will indicate what to keep/remove/combine\n4. The section will be drafted\n5. It will be refined through surgical edits\n\nStart with whichever section has the most unknowns (usually the core decision/proposal), then work through the rest.\n\n**Section ordering:**\n\nIf the document structure is clear:\nAsk which section they'd like to start with.\n\nSuggest starting with whichever section has the most unknowns. For decision docs, that's usually the core proposal. For specs, it's typically the technical approach. Summary sections are best left for last.\n\nIf user doesn't know what sections they need:\nBased on the type of document and template, suggest 3-5 sections appropriate for the doc type.\n\nAsk if this structure works, or if they want to adjust it.\n\n**Once structure is agreed:**\n\nCreate the initial document structure with placeholder text for all sections.\n\n**If access to artifacts is available:**\nUse `create_file` to create an artifact. This gives both Claude and the user a scaffold to work from.\n\nInform them that the initial structure with placeholders for all sections will be created.\n\nCreate artifact with all section headers and brief placeholder text like \"[To be written]\" or \"[Content here]\".\n\nProvide the scaffold link and indicate it's time to fill in each section.\n\n**If no access to artifacts:**\nCreate a markdown file in the working directory. Name it appropriately (e.g., `decision-doc.md`, `technical-spec.md`).\n\nInform them that the initial structure with placeholders for all sections will be created.\n\nCreate file with all section headers and placeholder text.\n\nConfirm the filename has been created and indicate it's time to fill in each section.\n\n**For each section:**\n\n### Step 1: Clarifying Questions\n\nAnnounce work will begin on the [SECTION NAME] section. Ask 5-10 clarifying questions about what should be included:\n\nGenerate 5-10 specific questions based on context and section purpose.\n\nInform them they can answer in shorthand or just indicate what's important to cover.\n\n### Step 2: Brainstorming\n\nFor the [SECTION NAME] section, brainstorm [5-20] things that might be included, depending on the section's complexity. Look for:\n- Context shared that might have been forgotten\n- Angles or considerations not yet mentioned\n\nGenerate 5-20 numbered options based on section complexity. At the end, offer to brainstorm more if they want additional options.\n\n### Step 3: Curation\n\nAsk which points should be kept, removed, or combined. Request brief justifications to help learn priorities for the next sections.\n\nProvide examples:\n- \"Keep 1,4,7,9\"\n- \"Remove 3 (duplicates 1)\"\n- \"Remove 6 (audience already knows this)\"\n- \"Combine 11 and 12\"\n\n**If user gives freeform feedback** (e.g., \"looks good\" or \"I like most of it but...\") instead of numbered selections, extract their preferences and proceed. Parse what they want kept/removed/changed and apply it.\n\n### Step 4: Gap Check\n\nBased on what they've selected, ask if there's anything important missing for the [SECTION NAME] section.\n\n### Step 5: Drafting\n\nUse `str_replace` to replace the placeholder text for this section with the actual drafted content.\n\nAnnounce the [SECTION NAME] section will be drafted now based on what they've selected.\n\n**If using artifacts:**\nAfter drafting, provide a link to the artifact.\n\nAsk them to read through it and indicate what to change. Note that being specific helps learning for the next sections.\n\n**If using a file (no artifacts):**\nAfter drafting, confirm completion.\n\nInform them the [SECTION NAME] section has been drafted in [filename]. Ask them to read through it and indicate what to change. Note that being specific helps learning for the next sections.\n\n**Key instruction for user (include when drafting the first section):**\nProvide a note: Instead of editing the doc directly, ask them to indicate what to change. This helps learning of their style for future sections. For example: \"Remove the X bullet - already covered by Y\" or \"Make the third paragraph more concise\".\n\n### Step 6: Iterative Refinement\n\nAs user provides feedback:\n- Use `str_replace` to make edits (never reprint the whole doc)\n- **If using artifacts:** Provide link to artifact after each edit\n- **If using files:** Just confirm edits are complete\n- If user edits doc directly and asks to read it: mentally note the changes they made and keep them in mind for future sections (this shows their preferences)\n\n**Continue iterating** until user is satisfied with the section.\n\n### Quality Checking\n\nAfter 3 consecutive iterations with no substantial changes, ask if anything can be removed without losing important information.\n\nWhen section is done, confirm [SECTION NAME] is complete. Ask if ready to move to the next section.\n\n**Repeat for all sections.**\n\n### Near Completion\n\nAs approaching completion (80%+ of sections done), announce intention to re-read the entire document and check for:\n- Flow and consistency across sections\n- Redundancy or contradictions\n- Anything that feels like \"slop\" or generic filler\n- Whether every sentence carries weight\n\nRead entire document and provide feedback.\n\n**When all sections are drafted and refined:**\nAnnounce all sections are drafted. Indicate intention to review the complete document one more time.\n\nReview for overall coherence, flow, completeness.\n\nProvide any final suggestions.\n\nAsk if ready to move to Reader Testing, or if they want to refine anything else.\n\n## Stage 3: Reader Testing\n\n**Goal:** Test the document with a fresh Claude (no context bleed) to verify it works for readers.\n\n**Instructions to user:**\nExplain that testing will now occur to see if the document actually works for readers. This catches blind spots - things that make sense to the authors but might confuse others.\n\n### Testing Approach\n\n**If access to sub-agents is available (e.g., in Claude Code):**\n\nPerform the testing directly without user involvement.\n\n### Step 1: Predict Reader Questions\n\nAnnounce intention to predict what questions readers might ask when trying to discover this document.\n\nGenerate 5-10 questions that readers would realistically ask.\n\n### Step 2: Test with Sub-Agent\n\nAnnounce that these questions will be tested with a fresh Claude instance (no context from this conversation).\n\nFor each question, invoke a sub-agent with just the document content and the question.\n\nSummarize what Reader Claude got right/wrong for each question.\n\n### Step 3: Run Additional Checks\n\nAnnounce additional checks will be performed.\n\nInvoke sub-agent to check for ambiguity, false assumptions, contradictions.\n\nSummarize any issues found.\n\n### Step 4: Report and Fix\n\nIf issues found:\nReport that Reader Claude struggled with specific issues.\n\nList the specific issues.\n\nIndicate intention to fix these gaps.\n\nLoop back to refinement for problematic sections.\n\n---\n\n**If no access to sub-agents (e.g., claude.ai web interface):**\n\nThe user will need to do the testing manually.\n\n### Step 1: Predict Reader Questions\n\nAsk what questions people might ask when trying to discover this document. What would they type into Claude.ai?\n\nGenerate 5-10 questions that readers would realistically ask.\n\n### Step 2: Setup Testing\n\nProvide testing instructions:\n1. Open a fresh Claude conversation: https://claude.ai\n2. Paste or share the document content (if using a shared doc platform with connectors enabled, provide the link)\n3. Ask Reader Claude the generated questions\n\nFor each question, instruct Reader Claude to provide:\n- The answer\n- Whether anything was ambiguous or unclear\n- What knowledge/context the doc assumes is already known\n\nCheck if Reader Claude gives correct answers or misinterprets anything.\n\n### Step 3: Additional Checks\n\nAlso ask Reader Claude:\n- \"What in this doc might be ambiguous or unclear to readers?\"\n- \"What knowledge or context does this doc assume readers already have?\"\n- \"Are there any internal contradictions or inconsistencies?\"\n\n### Step 4: Iterate Based on Results\n\nAsk what Reader Claude got wrong or struggled with. Indicate intention to fix those gaps.\n\nLoop back to refinement for any problematic sections.\n\n---\n\n### Exit Condition (Both Approaches)\n\nWhen Reader Claude consistently answers questions correctly and doesn't surface new gaps or ambiguities, the doc is ready.\n\n## Final Review\n\nWhen Reader Testing passes:\nAnnounce the doc has passed Reader Claude testing. Before completion:\n\n1. Recommend they do a final read-through themselves - they own this document and are responsible for its quality\n2. Suggest double-checking any facts, links, or technical details\n3. Ask them to verify it achieves the impact they wanted\n\nAsk if they want one more review, or if the work is done.\n\n**If user wants final review, provide it. Otherwise:**\nAnnounce document completion. Provide a few final tips:\n- Consider linking this conversation in an appendix so readers can see how the doc was developed\n- Use appendices to provide depth without bloating the main doc\n- Update the doc as feedback is received from real readers\n\n## Tips for Effective Guidance\n\n**Tone:**\n- Be direct and procedural\n- Explain rationale briefly when it affects user behavior\n- Don't try to \"sell\" the approach - just execute it\n\n**Handling Deviations:**\n- If user wants to skip a stage: Ask if they want to skip this and write freeform\n- If user seems frustrated: Acknowledge this is taking longer than expected. Suggest ways to move faster\n- Always give user agency to adjust the process\n\n**Context Management:**\n- Throughout, if context is missing on something mentioned, proactively ask\n- Don't let gaps accumulate - address them as they come up\n\n**Artifact Management:**\n- Use `create_file` for drafting full sections\n- Use `str_replace` for all edits\n- Provide artifact link after every change\n- Never use artifacts for brainstorming lists - that's just conversation\n\n**Quality over Speed:**\n- Don't rush through stages\n- Each iteration should make meaningful improvements\n- The goal is a document that actually works for readers"
              },
              {
                "name": "docx",
                "description": "Comprehensive document creation, editing, and analysis with support for tracked changes, comments, formatting preservation, and text extraction. When Claude needs to work with professional documents (.docx files) for: (1) Creating new documents, (2) Modifying or editing content, (3) Working with tracked changes, (4) Adding comments, or any other document tasks",
                "path": "skills/docx/SKILL.md",
                "frontmatter": {
                  "name": "docx",
                  "description": "Comprehensive document creation, editing, and analysis with support for tracked changes, comments, formatting preservation, and text extraction. When Claude needs to work with professional documents (.docx files) for: (1) Creating new documents, (2) Modifying or editing content, (3) Working with tracked changes, (4) Adding comments, or any other document tasks",
                  "license": "Proprietary. LICENSE.txt has complete terms"
                },
                "content": "# DOCX creation, editing, and analysis\n\n## Overview\n\nA user may ask you to create, edit, or analyze the contents of a .docx file. A .docx file is essentially a ZIP archive containing XML files and other resources that you can read or edit. You have different tools and workflows available for different tasks.\n\n## Workflow Decision Tree\n\n### Reading/Analyzing Content\nUse \"Text extraction\" or \"Raw XML access\" sections below\n\n### Creating New Document\nUse \"Creating a new Word document\" workflow\n\n### Editing Existing Document\n- **Your own document + simple changes**\n  Use \"Basic OOXML editing\" workflow\n\n- **Someone else's document**\n  Use **\"Redlining workflow\"** (recommended default)\n\n- **Legal, academic, business, or government docs**\n  Use **\"Redlining workflow\"** (required)\n\n## Reading and analyzing content\n\n### Text extraction\nIf you just need to read the text contents of a document, you should convert the document to markdown using pandoc. Pandoc provides excellent support for preserving document structure and can show tracked changes:\n\n```bash\n# Convert document to markdown with tracked changes\npandoc --track-changes=all path-to-file.docx -o output.md\n# Options: --track-changes=accept/reject/all\n```\n\n### Raw XML access\nYou need raw XML access for: comments, complex formatting, document structure, embedded media, and metadata. For any of these features, you'll need to unpack a document and read its raw XML contents.\n\n#### Unpacking a file\n`python ooxml/scripts/unpack.py <office_file> <output_directory>`\n\n#### Key file structures\n* `word/document.xml` - Main document contents\n* `word/comments.xml` - Comments referenced in document.xml\n* `word/media/` - Embedded images and media files\n* Tracked changes use `<w:ins>` (insertions) and `<w:del>` (deletions) tags\n\n## Creating a new Word document\n\nWhen creating a new Word document from scratch, use **docx-js**, which allows you to create Word documents using JavaScript/TypeScript.\n\n### Workflow\n1. **MANDATORY - READ ENTIRE FILE**: Read [`docx-js.md`](docx-js.md) (~500 lines) completely from start to finish. **NEVER set any range limits when reading this file.** Read the full file content for detailed syntax, critical formatting rules, and best practices before proceeding with document creation.\n2. Create a JavaScript/TypeScript file using Document, Paragraph, TextRun components (You can assume all dependencies are installed, but if not, refer to the dependencies section below)\n3. Export as .docx using Packer.toBuffer()\n\n## Editing an existing Word document\n\nWhen editing an existing Word document, use the **Document library** (a Python library for OOXML manipulation). The library automatically handles infrastructure setup and provides methods for document manipulation. For complex scenarios, you can access the underlying DOM directly through the library.\n\n### Workflow\n1. **MANDATORY - READ ENTIRE FILE**: Read [`ooxml.md`](ooxml.md) (~600 lines) completely from start to finish. **NEVER set any range limits when reading this file.** Read the full file content for the Document library API and XML patterns for directly editing document files.\n2. Unpack the document: `python ooxml/scripts/unpack.py <office_file> <output_directory>`\n3. Create and run a Python script using the Document library (see \"Document Library\" section in ooxml.md)\n4. Pack the final document: `python ooxml/scripts/pack.py <input_directory> <office_file>`\n\nThe Document library provides both high-level methods for common operations and direct DOM access for complex scenarios.\n\n## Redlining workflow for document review\n\nThis workflow allows you to plan comprehensive tracked changes using markdown before implementing them in OOXML. **CRITICAL**: For complete tracked changes, you must implement ALL changes systematically.\n\n**Batching Strategy**: Group related changes into batches of 3-10 changes. This makes debugging manageable while maintaining efficiency. Test each batch before moving to the next.\n\n**Principle: Minimal, Precise Edits**\nWhen implementing tracked changes, only mark text that actually changes. Repeating unchanged text makes edits harder to review and appears unprofessional. Break replacements into: [unchanged text] + [deletion] + [insertion] + [unchanged text]. Preserve the original run's RSID for unchanged text by extracting the `<w:r>` element from the original and reusing it.\n\nExample - Changing \"30 days\" to \"60 days\" in a sentence:\n```python\n# BAD - Replaces entire sentence\n'<w:del><w:r><w:delText>The term is 30 days.</w:delText></w:r></w:del><w:ins><w:r><w:t>The term is 60 days.</w:t></w:r></w:ins>'\n\n# GOOD - Only marks what changed, preserves original <w:r> for unchanged text\n'<w:r w:rsidR=\"00AB12CD\"><w:t>The term is </w:t></w:r><w:del><w:r><w:delText>30</w:delText></w:r></w:del><w:ins><w:r><w:t>60</w:t></w:r></w:ins><w:r w:rsidR=\"00AB12CD\"><w:t> days.</w:t></w:r>'\n```\n\n### Tracked changes workflow\n\n1. **Get markdown representation**: Convert document to markdown with tracked changes preserved:\n   ```bash\n   pandoc --track-changes=all path-to-file.docx -o current.md\n   ```\n\n2. **Identify and group changes**: Review the document and identify ALL changes needed, organizing them into logical batches:\n\n   **Location methods** (for finding changes in XML):\n   - Section/heading numbers (e.g., \"Section 3.2\", \"Article IV\")\n   - Paragraph identifiers if numbered\n   - Grep patterns with unique surrounding text\n   - Document structure (e.g., \"first paragraph\", \"signature block\")\n   - **DO NOT use markdown line numbers** - they don't map to XML structure\n\n   **Batch organization** (group 3-10 related changes per batch):\n   - By section: \"Batch 1: Section 2 amendments\", \"Batch 2: Section 5 updates\"\n   - By type: \"Batch 1: Date corrections\", \"Batch 2: Party name changes\"\n   - By complexity: Start with simple text replacements, then tackle complex structural changes\n   - Sequential: \"Batch 1: Pages 1-3\", \"Batch 2: Pages 4-6\"\n\n3. **Read documentation and unpack**:\n   - **MANDATORY - READ ENTIRE FILE**: Read [`ooxml.md`](ooxml.md) (~600 lines) completely from start to finish. **NEVER set any range limits when reading this file.** Pay special attention to the \"Document Library\" and \"Tracked Change Patterns\" sections.\n   - **Unpack the document**: `python ooxml/scripts/unpack.py <file.docx> <dir>`\n   - **Note the suggested RSID**: The unpack script will suggest an RSID to use for your tracked changes. Copy this RSID for use in step 4b.\n\n4. **Implement changes in batches**: Group changes logically (by section, by type, or by proximity) and implement them together in a single script. This approach:\n   - Makes debugging easier (smaller batch = easier to isolate errors)\n   - Allows incremental progress\n   - Maintains efficiency (batch size of 3-10 changes works well)\n\n   **Suggested batch groupings:**\n   - By document section (e.g., \"Section 3 changes\", \"Definitions\", \"Termination clause\")\n   - By change type (e.g., \"Date changes\", \"Party name updates\", \"Legal term replacements\")\n   - By proximity (e.g., \"Changes on pages 1-3\", \"Changes in first half of document\")\n\n   For each batch of related changes:\n\n   **a. Map text to XML**: Grep for text in `word/document.xml` to verify how text is split across `<w:r>` elements.\n\n   **b. Create and run script**: Use `get_node` to find nodes, implement changes, then `doc.save()`. See **\"Document Library\"** section in ooxml.md for patterns.\n\n   **Note**: Always grep `word/document.xml` immediately before writing a script to get current line numbers and verify text content. Line numbers change after each script run.\n\n5. **Pack the document**: After all batches are complete, convert the unpacked directory back to .docx:\n   ```bash\n   python ooxml/scripts/pack.py unpacked reviewed-document.docx\n   ```\n\n6. **Final verification**: Do a comprehensive check of the complete document:\n   - Convert final document to markdown:\n     ```bash\n     pandoc --track-changes=all reviewed-document.docx -o verification.md\n     ```\n   - Verify ALL changes were applied correctly:\n     ```bash\n     grep \"original phrase\" verification.md  # Should NOT find it\n     grep \"replacement phrase\" verification.md  # Should find it\n     ```\n   - Check that no unintended changes were introduced\n\n\n## Converting Documents to Images\n\nTo visually analyze Word documents, convert them to images using a two-step process:\n\n1. **Convert DOCX to PDF**:\n   ```bash\n   soffice --headless --convert-to pdf document.docx\n   ```\n\n2. **Convert PDF pages to JPEG images**:\n   ```bash\n   pdftoppm -jpeg -r 150 document.pdf page\n   ```\n   This creates files like `page-1.jpg`, `page-2.jpg`, etc.\n\nOptions:\n- `-r 150`: Sets resolution to 150 DPI (adjust for quality/size balance)\n- `-jpeg`: Output JPEG format (use `-png` for PNG if preferred)\n- `-f N`: First page to convert (e.g., `-f 2` starts from page 2)\n- `-l N`: Last page to convert (e.g., `-l 5` stops at page 5)\n- `page`: Prefix for output files\n\nExample for specific range:\n```bash\npdftoppm -jpeg -r 150 -f 2 -l 5 document.pdf page  # Converts only pages 2-5\n```\n\n## Code Style Guidelines\n**IMPORTANT**: When generating code for DOCX operations:\n- Write concise code\n- Avoid verbose variable names and redundant operations\n- Avoid unnecessary print statements\n\n## Dependencies\n\nRequired dependencies (install if not available):\n\n- **pandoc**: `sudo apt-get install pandoc` (for text extraction)\n- **docx**: `npm install -g docx` (for creating new documents)\n- **LibreOffice**: `sudo apt-get install libreoffice` (for PDF conversion)\n- **Poppler**: `sudo apt-get install poppler-utils` (for pdftoppm to convert PDF to images)\n- **defusedxml**: `pip install defusedxml` (for secure XML parsing)"
              },
              {
                "name": "frontend-design",
                "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, artifacts, posters, or applications (examples include websites, landing pages, dashboards, React components, HTML/CSS layouts, or when styling/beautifying any web UI). Generates creative, polished code and UI design that avoids generic AI aesthetics.",
                "path": "skills/frontend-design/SKILL.md",
                "frontmatter": {
                  "name": "frontend-design",
                  "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, artifacts, posters, or applications (examples include websites, landing pages, dashboards, React components, HTML/CSS layouts, or when styling/beautifying any web UI). Generates creative, polished code and UI design that avoids generic AI aesthetics.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "This skill guides creation of distinctive, production-grade frontend interfaces that avoid generic \"AI slop\" aesthetics. Implement real working code with exceptional attention to aesthetic details and creative choices.\n\nThe user provides frontend requirements: a component, page, application, or interface to build. They may include context about the purpose, audience, or technical constraints.\n\n## Design Thinking\n\nBefore coding, understand the context and commit to a BOLD aesthetic direction:\n- **Purpose**: What problem does this interface solve? Who uses it?\n- **Tone**: Pick an extreme: brutally minimal, maximalist chaos, retro-futuristic, organic/natural, luxury/refined, playful/toy-like, editorial/magazine, brutalist/raw, art deco/geometric, soft/pastel, industrial/utilitarian, etc. There are so many flavors to choose from. Use these for inspiration but design one that is true to the aesthetic direction.\n- **Constraints**: Technical requirements (framework, performance, accessibility).\n- **Differentiation**: What makes this UNFORGETTABLE? What's the one thing someone will remember?\n\n**CRITICAL**: Choose a clear conceptual direction and execute it with precision. Bold maximalism and refined minimalism both work - the key is intentionality, not intensity.\n\nThen implement working code (HTML/CSS/JS, React, Vue, etc.) that is:\n- Production-grade and functional\n- Visually striking and memorable\n- Cohesive with a clear aesthetic point-of-view\n- Meticulously refined in every detail\n\n## Frontend Aesthetics Guidelines\n\nFocus on:\n- **Typography**: Choose fonts that are beautiful, unique, and interesting. Avoid generic fonts like Arial and Inter; opt instead for distinctive choices that elevate the frontend's aesthetics; unexpected, characterful font choices. Pair a distinctive display font with a refined body font.\n- **Color & Theme**: Commit to a cohesive aesthetic. Use CSS variables for consistency. Dominant colors with sharp accents outperform timid, evenly-distributed palettes.\n- **Motion**: Use animations for effects and micro-interactions. Prioritize CSS-only solutions for HTML. Use Motion library for React when available. Focus on high-impact moments: one well-orchestrated page load with staggered reveals (animation-delay) creates more delight than scattered micro-interactions. Use scroll-triggering and hover states that surprise.\n- **Spatial Composition**: Unexpected layouts. Asymmetry. Overlap. Diagonal flow. Grid-breaking elements. Generous negative space OR controlled density.\n- **Backgrounds & Visual Details**: Create atmosphere and depth rather than defaulting to solid colors. Add contextual effects and textures that match the overall aesthetic. Apply creative forms like gradient meshes, noise textures, geometric patterns, layered transparencies, dramatic shadows, decorative borders, custom cursors, and grain overlays.\n\nNEVER use generic AI-generated aesthetics like overused font families (Inter, Roboto, Arial, system fonts), cliched color schemes (particularly purple gradients on white backgrounds), predictable layouts and component patterns, and cookie-cutter design that lacks context-specific character.\n\nInterpret creatively and make unexpected choices that feel genuinely designed for the context. No design should be the same. Vary between light and dark themes, different fonts, different aesthetics. NEVER converge on common choices (Space Grotesk, for example) across generations.\n\n**IMPORTANT**: Match implementation complexity to the aesthetic vision. Maximalist designs need elaborate code with extensive animations and effects. Minimalist or refined designs need restraint, precision, and careful attention to spacing, typography, and subtle details. Elegance comes from executing the vision well.\n\nRemember: Claude is capable of extraordinary creative work. Don't hold back, show what can truly be created when thinking outside the box and committing fully to a distinctive vision."
              },
              {
                "name": "internal-comms",
                "description": "A set of resources to help me write all kinds of internal communications, using the formats that my company likes to use. Claude should use this skill whenever asked to write some sort of internal communications (status reports, leadership updates, 3P updates, company newsletters, FAQs, incident reports, project updates, etc.).",
                "path": "skills/internal-comms/SKILL.md",
                "frontmatter": {
                  "name": "internal-comms",
                  "description": "A set of resources to help me write all kinds of internal communications, using the formats that my company likes to use. Claude should use this skill whenever asked to write some sort of internal communications (status reports, leadership updates, 3P updates, company newsletters, FAQs, incident reports, project updates, etc.).",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "## When to use this skill\nTo write internal communications, use this skill for:\n- 3P updates (Progress, Plans, Problems)\n- Company newsletters\n- FAQ responses\n- Status reports\n- Leadership updates\n- Project updates\n- Incident reports\n\n## How to use this skill\n\nTo write any internal communication:\n\n1. **Identify the communication type** from the request\n2. **Load the appropriate guideline file** from the `examples/` directory:\n    - `examples/3p-updates.md` - For Progress/Plans/Problems team updates\n    - `examples/company-newsletter.md` - For company-wide newsletters\n    - `examples/faq-answers.md` - For answering frequently asked questions\n    - `examples/general-comms.md` - For anything else that doesn't explicitly match one of the above\n3. **Follow the specific instructions** in that file for formatting, tone, and content gathering\n\nIf the communication type doesn't match any existing guideline, ask for clarification or more context about the desired format.\n\n## Keywords\n3P updates, company newsletter, company comms, weekly update, faqs, common questions, updates, internal comms"
              },
              {
                "name": "mcp-builder",
                "description": "Guide for creating high-quality MCP (Model Context Protocol) servers that enable LLMs to interact with external services through well-designed tools. Use when building MCP servers to integrate external APIs or services, whether in Python (FastMCP) or Node/TypeScript (MCP SDK).",
                "path": "skills/mcp-builder/SKILL.md",
                "frontmatter": {
                  "name": "mcp-builder",
                  "description": "Guide for creating high-quality MCP (Model Context Protocol) servers that enable LLMs to interact with external services through well-designed tools. Use when building MCP servers to integrate external APIs or services, whether in Python (FastMCP) or Node/TypeScript (MCP SDK).",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "# MCP Server Development Guide\n\n## Overview\n\nCreate MCP (Model Context Protocol) servers that enable LLMs to interact with external services through well-designed tools. The quality of an MCP server is measured by how well it enables LLMs to accomplish real-world tasks.\n\n---\n\n# Process\n\n## ðŸš€ High-Level Workflow\n\nCreating a high-quality MCP server involves four main phases:\n\n### Phase 1: Deep Research and Planning\n\n#### 1.1 Understand Modern MCP Design\n\n**API Coverage vs. Workflow Tools:**\nBalance comprehensive API endpoint coverage with specialized workflow tools. Workflow tools can be more convenient for specific tasks, while comprehensive coverage gives agents flexibility to compose operations. Performance varies by clientâ€”some clients benefit from code execution that combines basic tools, while others work better with higher-level workflows. When uncertain, prioritize comprehensive API coverage.\n\n**Tool Naming and Discoverability:**\nClear, descriptive tool names help agents find the right tools quickly. Use consistent prefixes (e.g., `github_create_issue`, `github_list_repos`) and action-oriented naming.\n\n**Context Management:**\nAgents benefit from concise tool descriptions and the ability to filter/paginate results. Design tools that return focused, relevant data. Some clients support code execution which can help agents filter and process data efficiently.\n\n**Actionable Error Messages:**\nError messages should guide agents toward solutions with specific suggestions and next steps.\n\n#### 1.2 Study MCP Protocol Documentation\n\n**Navigate the MCP specification:**\n\nStart with the sitemap to find relevant pages: `https://modelcontextprotocol.io/sitemap.xml`\n\nThen fetch specific pages with `.md` suffix for markdown format (e.g., `https://modelcontextprotocol.io/specification/draft.md`).\n\nKey pages to review:\n- Specification overview and architecture\n- Transport mechanisms (streamable HTTP, stdio)\n- Tool, resource, and prompt definitions\n\n#### 1.3 Study Framework Documentation\n\n**Recommended stack:**\n- **Language**: TypeScript (high-quality SDK support and good compatibility in many execution environments e.g. MCPB. Plus AI models are good at generating TypeScript code, benefiting from its broad usage, static typing and good linting tools)\n- **Transport**: Streamable HTTP for remote servers, using stateless JSON (simpler to scale and maintain, as opposed to stateful sessions and streaming responses). stdio for local servers.\n\n**Load framework documentation:**\n\n- **MCP Best Practices**: [ðŸ“‹ View Best Practices](./reference/mcp_best_practices.md) - Core guidelines\n\n**For TypeScript (recommended):**\n- **TypeScript SDK**: Use WebFetch to load `https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/main/README.md`\n- [âš¡ TypeScript Guide](./reference/node_mcp_server.md) - TypeScript patterns and examples\n\n**For Python:**\n- **Python SDK**: Use WebFetch to load `https://raw.githubusercontent.com/modelcontextprotocol/python-sdk/main/README.md`\n- [ðŸ Python Guide](./reference/python_mcp_server.md) - Python patterns and examples\n\n#### 1.4 Plan Your Implementation\n\n**Understand the API:**\nReview the service's API documentation to identify key endpoints, authentication requirements, and data models. Use web search and WebFetch as needed.\n\n**Tool Selection:**\nPrioritize comprehensive API coverage. List endpoints to implement, starting with the most common operations.\n\n---\n\n### Phase 2: Implementation\n\n#### 2.1 Set Up Project Structure\n\nSee language-specific guides for project setup:\n- [âš¡ TypeScript Guide](./reference/node_mcp_server.md) - Project structure, package.json, tsconfig.json\n- [ðŸ Python Guide](./reference/python_mcp_server.md) - Module organization, dependencies\n\n#### 2.2 Implement Core Infrastructure\n\nCreate shared utilities:\n- API client with authentication\n- Error handling helpers\n- Response formatting (JSON/Markdown)\n- Pagination support\n\n#### 2.3 Implement Tools\n\nFor each tool:\n\n**Input Schema:**\n- Use Zod (TypeScript) or Pydantic (Python)\n- Include constraints and clear descriptions\n- Add examples in field descriptions\n\n**Output Schema:**\n- Define `outputSchema` where possible for structured data\n- Use `structuredContent` in tool responses (TypeScript SDK feature)\n- Helps clients understand and process tool outputs\n\n**Tool Description:**\n- Concise summary of functionality\n- Parameter descriptions\n- Return type schema\n\n**Implementation:**\n- Async/await for I/O operations\n- Proper error handling with actionable messages\n- Support pagination where applicable\n- Return both text content and structured data when using modern SDKs\n\n**Annotations:**\n- `readOnlyHint`: true/false\n- `destructiveHint`: true/false\n- `idempotentHint`: true/false\n- `openWorldHint`: true/false\n\n---\n\n### Phase 3: Review and Test\n\n#### 3.1 Code Quality\n\nReview for:\n- No duplicated code (DRY principle)\n- Consistent error handling\n- Full type coverage\n- Clear tool descriptions\n\n#### 3.2 Build and Test\n\n**TypeScript:**\n- Run `npm run build` to verify compilation\n- Test with MCP Inspector: `npx @modelcontextprotocol/inspector`\n\n**Python:**\n- Verify syntax: `python -m py_compile your_server.py`\n- Test with MCP Inspector\n\nSee language-specific guides for detailed testing approaches and quality checklists.\n\n---\n\n### Phase 4: Create Evaluations\n\nAfter implementing your MCP server, create comprehensive evaluations to test its effectiveness.\n\n**Load [âœ… Evaluation Guide](./reference/evaluation.md) for complete evaluation guidelines.**\n\n#### 4.1 Understand Evaluation Purpose\n\nUse evaluations to test whether LLMs can effectively use your MCP server to answer realistic, complex questions.\n\n#### 4.2 Create 10 Evaluation Questions\n\nTo create effective evaluations, follow the process outlined in the evaluation guide:\n\n1. **Tool Inspection**: List available tools and understand their capabilities\n2. **Content Exploration**: Use READ-ONLY operations to explore available data\n3. **Question Generation**: Create 10 complex, realistic questions\n4. **Answer Verification**: Solve each question yourself to verify answers\n\n#### 4.3 Evaluation Requirements\n\nEnsure each question is:\n- **Independent**: Not dependent on other questions\n- **Read-only**: Only non-destructive operations required\n- **Complex**: Requiring multiple tool calls and deep exploration\n- **Realistic**: Based on real use cases humans would care about\n- **Verifiable**: Single, clear answer that can be verified by string comparison\n- **Stable**: Answer won't change over time\n\n#### 4.4 Output Format\n\nCreate an XML file with this structure:\n\n```xml\n<evaluation>\n  <qa_pair>\n    <question>Find discussions about AI model launches with animal codenames. One model needed a specific safety designation that uses the format ASL-X. What number X was being determined for the model named after a spotted wild cat?</question>\n    <answer>3</answer>\n  </qa_pair>\n<!-- More qa_pairs... -->\n</evaluation>\n```\n\n---\n\n# Reference Files\n\n## ðŸ“š Documentation Library\n\nLoad these resources as needed during development:\n\n### Core MCP Documentation (Load First)\n- **MCP Protocol**: Start with sitemap at `https://modelcontextprotocol.io/sitemap.xml`, then fetch specific pages with `.md` suffix\n- [ðŸ“‹ MCP Best Practices](./reference/mcp_best_practices.md) - Universal MCP guidelines including:\n  - Server and tool naming conventions\n  - Response format guidelines (JSON vs Markdown)\n  - Pagination best practices\n  - Transport selection (streamable HTTP vs stdio)\n  - Security and error handling standards\n\n### SDK Documentation (Load During Phase 1/2)\n- **Python SDK**: Fetch from `https://raw.githubusercontent.com/modelcontextprotocol/python-sdk/main/README.md`\n- **TypeScript SDK**: Fetch from `https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/main/README.md`\n\n### Language-Specific Implementation Guides (Load During Phase 2)\n- [ðŸ Python Implementation Guide](./reference/python_mcp_server.md) - Complete Python/FastMCP guide with:\n  - Server initialization patterns\n  - Pydantic model examples\n  - Tool registration with `@mcp.tool`\n  - Complete working examples\n  - Quality checklist\n\n- [âš¡ TypeScript Implementation Guide](./reference/node_mcp_server.md) - Complete TypeScript guide with:\n  - Project structure\n  - Zod schema patterns\n  - Tool registration with `server.registerTool`\n  - Complete working examples\n  - Quality checklist\n\n### Evaluation Guide (Load During Phase 4)\n- [âœ… Evaluation Guide](./reference/evaluation.md) - Complete evaluation creation guide with:\n  - Question creation guidelines\n  - Answer verification strategies\n  - XML format specifications\n  - Example questions and answers\n  - Running an evaluation with the provided scripts"
              },
              {
                "name": "pdf",
                "description": "Comprehensive PDF manipulation toolkit for extracting text and tables, creating new PDFs, merging/splitting documents, and handling forms. When Claude needs to fill in a PDF form or programmatically process, generate, or analyze PDF documents at scale.",
                "path": "skills/pdf/SKILL.md",
                "frontmatter": {
                  "name": "pdf",
                  "description": "Comprehensive PDF manipulation toolkit for extracting text and tables, creating new PDFs, merging/splitting documents, and handling forms. When Claude needs to fill in a PDF form or programmatically process, generate, or analyze PDF documents at scale.",
                  "license": "Proprietary. LICENSE.txt has complete terms"
                },
                "content": "# PDF Processing Guide\n\n## Overview\n\nThis guide covers essential PDF processing operations using Python libraries and command-line tools. For advanced features, JavaScript libraries, and detailed examples, see reference.md. If you need to fill out a PDF form, read forms.md and follow its instructions.\n\n## Quick Start\n\n```python\nfrom pypdf import PdfReader, PdfWriter\n\n# Read a PDF\nreader = PdfReader(\"document.pdf\")\nprint(f\"Pages: {len(reader.pages)}\")\n\n# Extract text\ntext = \"\"\nfor page in reader.pages:\n    text += page.extract_text()\n```\n\n## Python Libraries\n\n### pypdf - Basic Operations\n\n#### Merge PDFs\n```python\nfrom pypdf import PdfWriter, PdfReader\n\nwriter = PdfWriter()\nfor pdf_file in [\"doc1.pdf\", \"doc2.pdf\", \"doc3.pdf\"]:\n    reader = PdfReader(pdf_file)\n    for page in reader.pages:\n        writer.add_page(page)\n\nwith open(\"merged.pdf\", \"wb\") as output:\n    writer.write(output)\n```\n\n#### Split PDF\n```python\nreader = PdfReader(\"input.pdf\")\nfor i, page in enumerate(reader.pages):\n    writer = PdfWriter()\n    writer.add_page(page)\n    with open(f\"page_{i+1}.pdf\", \"wb\") as output:\n        writer.write(output)\n```\n\n#### Extract Metadata\n```python\nreader = PdfReader(\"document.pdf\")\nmeta = reader.metadata\nprint(f\"Title: {meta.title}\")\nprint(f\"Author: {meta.author}\")\nprint(f\"Subject: {meta.subject}\")\nprint(f\"Creator: {meta.creator}\")\n```\n\n#### Rotate Pages\n```python\nreader = PdfReader(\"input.pdf\")\nwriter = PdfWriter()\n\npage = reader.pages[0]\npage.rotate(90)  # Rotate 90 degrees clockwise\nwriter.add_page(page)\n\nwith open(\"rotated.pdf\", \"wb\") as output:\n    writer.write(output)\n```\n\n### pdfplumber - Text and Table Extraction\n\n#### Extract Text with Layout\n```python\nimport pdfplumber\n\nwith pdfplumber.open(\"document.pdf\") as pdf:\n    for page in pdf.pages:\n        text = page.extract_text()\n        print(text)\n```\n\n#### Extract Tables\n```python\nwith pdfplumber.open(\"document.pdf\") as pdf:\n    for i, page in enumerate(pdf.pages):\n        tables = page.extract_tables()\n        for j, table in enumerate(tables):\n            print(f\"Table {j+1} on page {i+1}:\")\n            for row in table:\n                print(row)\n```\n\n#### Advanced Table Extraction\n```python\nimport pandas as pd\n\nwith pdfplumber.open(\"document.pdf\") as pdf:\n    all_tables = []\n    for page in pdf.pages:\n        tables = page.extract_tables()\n        for table in tables:\n            if table:  # Check if table is not empty\n                df = pd.DataFrame(table[1:], columns=table[0])\n                all_tables.append(df)\n\n# Combine all tables\nif all_tables:\n    combined_df = pd.concat(all_tables, ignore_index=True)\n    combined_df.to_excel(\"extracted_tables.xlsx\", index=False)\n```\n\n### reportlab - Create PDFs\n\n#### Basic PDF Creation\n```python\nfrom reportlab.lib.pagesizes import letter\nfrom reportlab.pdfgen import canvas\n\nc = canvas.Canvas(\"hello.pdf\", pagesize=letter)\nwidth, height = letter\n\n# Add text\nc.drawString(100, height - 100, \"Hello World!\")\nc.drawString(100, height - 120, \"This is a PDF created with reportlab\")\n\n# Add a line\nc.line(100, height - 140, 400, height - 140)\n\n# Save\nc.save()\n```\n\n#### Create PDF with Multiple Pages\n```python\nfrom reportlab.lib.pagesizes import letter\nfrom reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak\nfrom reportlab.lib.styles import getSampleStyleSheet\n\ndoc = SimpleDocTemplate(\"report.pdf\", pagesize=letter)\nstyles = getSampleStyleSheet()\nstory = []\n\n# Add content\ntitle = Paragraph(\"Report Title\", styles['Title'])\nstory.append(title)\nstory.append(Spacer(1, 12))\n\nbody = Paragraph(\"This is the body of the report. \" * 20, styles['Normal'])\nstory.append(body)\nstory.append(PageBreak())\n\n# Page 2\nstory.append(Paragraph(\"Page 2\", styles['Heading1']))\nstory.append(Paragraph(\"Content for page 2\", styles['Normal']))\n\n# Build PDF\ndoc.build(story)\n```\n\n## Command-Line Tools\n\n### pdftotext (poppler-utils)\n```bash\n# Extract text\npdftotext input.pdf output.txt\n\n# Extract text preserving layout\npdftotext -layout input.pdf output.txt\n\n# Extract specific pages\npdftotext -f 1 -l 5 input.pdf output.txt  # Pages 1-5\n```\n\n### qpdf\n```bash\n# Merge PDFs\nqpdf --empty --pages file1.pdf file2.pdf -- merged.pdf\n\n# Split pages\nqpdf input.pdf --pages . 1-5 -- pages1-5.pdf\nqpdf input.pdf --pages . 6-10 -- pages6-10.pdf\n\n# Rotate pages\nqpdf input.pdf output.pdf --rotate=+90:1  # Rotate page 1 by 90 degrees\n\n# Remove password\nqpdf --password=mypassword --decrypt encrypted.pdf decrypted.pdf\n```\n\n### pdftk (if available)\n```bash\n# Merge\npdftk file1.pdf file2.pdf cat output merged.pdf\n\n# Split\npdftk input.pdf burst\n\n# Rotate\npdftk input.pdf rotate 1east output rotated.pdf\n```\n\n## Common Tasks\n\n### Extract Text from Scanned PDFs\n```python\n# Requires: pip install pytesseract pdf2image\nimport pytesseract\nfrom pdf2image import convert_from_path\n\n# Convert PDF to images\nimages = convert_from_path('scanned.pdf')\n\n# OCR each page\ntext = \"\"\nfor i, image in enumerate(images):\n    text += f\"Page {i+1}:\\n\"\n    text += pytesseract.image_to_string(image)\n    text += \"\\n\\n\"\n\nprint(text)\n```\n\n### Add Watermark\n```python\nfrom pypdf import PdfReader, PdfWriter\n\n# Create watermark (or load existing)\nwatermark = PdfReader(\"watermark.pdf\").pages[0]\n\n# Apply to all pages\nreader = PdfReader(\"document.pdf\")\nwriter = PdfWriter()\n\nfor page in reader.pages:\n    page.merge_page(watermark)\n    writer.add_page(page)\n\nwith open(\"watermarked.pdf\", \"wb\") as output:\n    writer.write(output)\n```\n\n### Extract Images\n```bash\n# Using pdfimages (poppler-utils)\npdfimages -j input.pdf output_prefix\n\n# This extracts all images as output_prefix-000.jpg, output_prefix-001.jpg, etc.\n```\n\n### Password Protection\n```python\nfrom pypdf import PdfReader, PdfWriter\n\nreader = PdfReader(\"input.pdf\")\nwriter = PdfWriter()\n\nfor page in reader.pages:\n    writer.add_page(page)\n\n# Add password\nwriter.encrypt(\"userpassword\", \"ownerpassword\")\n\nwith open(\"encrypted.pdf\", \"wb\") as output:\n    writer.write(output)\n```\n\n## Quick Reference\n\n| Task | Best Tool | Command/Code |\n|------|-----------|--------------|\n| Merge PDFs | pypdf | `writer.add_page(page)` |\n| Split PDFs | pypdf | One page per file |\n| Extract text | pdfplumber | `page.extract_text()` |\n| Extract tables | pdfplumber | `page.extract_tables()` |\n| Create PDFs | reportlab | Canvas or Platypus |\n| Command line merge | qpdf | `qpdf --empty --pages ...` |\n| OCR scanned PDFs | pytesseract | Convert to image first |\n| Fill PDF forms | pdf-lib or pypdf (see forms.md) | See forms.md |\n\n## Next Steps\n\n- For advanced pypdfium2 usage, see reference.md\n- For JavaScript libraries (pdf-lib), see reference.md\n- If you need to fill out a PDF form, follow the instructions in forms.md\n- For troubleshooting guides, see reference.md"
              },
              {
                "name": "pptx",
                "description": "Presentation creation, editing, and analysis. When Claude needs to work with presentations (.pptx files) for: (1) Creating new presentations, (2) Modifying or editing content, (3) Working with layouts, (4) Adding comments or speaker notes, or any other presentation tasks",
                "path": "skills/pptx/SKILL.md",
                "frontmatter": {
                  "name": "pptx",
                  "description": "Presentation creation, editing, and analysis. When Claude needs to work with presentations (.pptx files) for: (1) Creating new presentations, (2) Modifying or editing content, (3) Working with layouts, (4) Adding comments or speaker notes, or any other presentation tasks",
                  "license": "Proprietary. LICENSE.txt has complete terms"
                },
                "content": "# PPTX creation, editing, and analysis\n\n## Overview\n\nA user may ask you to create, edit, or analyze the contents of a .pptx file. A .pptx file is essentially a ZIP archive containing XML files and other resources that you can read or edit. You have different tools and workflows available for different tasks.\n\n## Reading and analyzing content\n\n### Text extraction\nIf you just need to read the text contents of a presentation, you should convert the document to markdown:\n\n```bash\n# Convert document to markdown\npython -m markitdown path-to-file.pptx\n```\n\n### Raw XML access\nYou need raw XML access for: comments, speaker notes, slide layouts, animations, design elements, and complex formatting. For any of these features, you'll need to unpack a presentation and read its raw XML contents.\n\n#### Unpacking a file\n`python ooxml/scripts/unpack.py <office_file> <output_dir>`\n\n**Note**: The unpack.py script is located at `skills/pptx/ooxml/scripts/unpack.py` relative to the project root. If the script doesn't exist at this path, use `find . -name \"unpack.py\"` to locate it.\n\n#### Key file structures\n* `ppt/presentation.xml` - Main presentation metadata and slide references\n* `ppt/slides/slide{N}.xml` - Individual slide contents (slide1.xml, slide2.xml, etc.)\n* `ppt/notesSlides/notesSlide{N}.xml` - Speaker notes for each slide\n* `ppt/comments/modernComment_*.xml` - Comments for specific slides\n* `ppt/slideLayouts/` - Layout templates for slides\n* `ppt/slideMasters/` - Master slide templates\n* `ppt/theme/` - Theme and styling information\n* `ppt/media/` - Images and other media files\n\n#### Typography and color extraction\n**When given an example design to emulate**: Always analyze the presentation's typography and colors first using the methods below:\n1. **Read theme file**: Check `ppt/theme/theme1.xml` for colors (`<a:clrScheme>`) and fonts (`<a:fontScheme>`)\n2. **Sample slide content**: Examine `ppt/slides/slide1.xml` for actual font usage (`<a:rPr>`) and colors\n3. **Search for patterns**: Use grep to find color (`<a:solidFill>`, `<a:srgbClr>`) and font references across all XML files\n\n## Creating a new PowerPoint presentation **without a template**\n\nWhen creating a new PowerPoint presentation from scratch, use the **html2pptx** workflow to convert HTML slides to PowerPoint with accurate positioning.\n\n### Design Principles\n\n**CRITICAL**: Before creating any presentation, analyze the content and choose appropriate design elements:\n1. **Consider the subject matter**: What is this presentation about? What tone, industry, or mood does it suggest?\n2. **Check for branding**: If the user mentions a company/organization, consider their brand colors and identity\n3. **Match palette to content**: Select colors that reflect the subject\n4. **State your approach**: Explain your design choices before writing code\n\n**Requirements**:\n- âœ… State your content-informed design approach BEFORE writing code\n- âœ… Use web-safe fonts only: Arial, Helvetica, Times New Roman, Georgia, Courier New, Verdana, Tahoma, Trebuchet MS, Impact\n- âœ… Create clear visual hierarchy through size, weight, and color\n- âœ… Ensure readability: strong contrast, appropriately sized text, clean alignment\n- âœ… Be consistent: repeat patterns, spacing, and visual language across slides\n\n#### Color Palette Selection\n\n**Choosing colors creatively**:\n- **Think beyond defaults**: What colors genuinely match this specific topic? Avoid autopilot choices.\n- **Consider multiple angles**: Topic, industry, mood, energy level, target audience, brand identity (if mentioned)\n- **Be adventurous**: Try unexpected combinations - a healthcare presentation doesn't have to be green, finance doesn't have to be navy\n- **Build your palette**: Pick 3-5 colors that work together (dominant colors + supporting tones + accent)\n- **Ensure contrast**: Text must be clearly readable on backgrounds\n\n**Example color palettes** (use these to spark creativity - choose one, adapt it, or create your own):\n\n1. **Classic Blue**: Deep navy (#1C2833), slate gray (#2E4053), silver (#AAB7B8), off-white (#F4F6F6)\n2. **Teal & Coral**: Teal (#5EA8A7), deep teal (#277884), coral (#FE4447), white (#FFFFFF)\n3. **Bold Red**: Red (#C0392B), bright red (#E74C3C), orange (#F39C12), yellow (#F1C40F), green (#2ECC71)\n4. **Warm Blush**: Mauve (#A49393), blush (#EED6D3), rose (#E8B4B8), cream (#FAF7F2)\n5. **Burgundy Luxury**: Burgundy (#5D1D2E), crimson (#951233), rust (#C15937), gold (#997929)\n6. **Deep Purple & Emerald**: Purple (#B165FB), dark blue (#181B24), emerald (#40695B), white (#FFFFFF)\n7. **Cream & Forest Green**: Cream (#FFE1C7), forest green (#40695B), white (#FCFCFC)\n8. **Pink & Purple**: Pink (#F8275B), coral (#FF574A), rose (#FF737D), purple (#3D2F68)\n9. **Lime & Plum**: Lime (#C5DE82), plum (#7C3A5F), coral (#FD8C6E), blue-gray (#98ACB5)\n10. **Black & Gold**: Gold (#BF9A4A), black (#000000), cream (#F4F6F6)\n11. **Sage & Terracotta**: Sage (#87A96B), terracotta (#E07A5F), cream (#F4F1DE), charcoal (#2C2C2C)\n12. **Charcoal & Red**: Charcoal (#292929), red (#E33737), light gray (#CCCBCB)\n13. **Vibrant Orange**: Orange (#F96D00), light gray (#F2F2F2), charcoal (#222831)\n14. **Forest Green**: Black (#191A19), green (#4E9F3D), dark green (#1E5128), white (#FFFFFF)\n15. **Retro Rainbow**: Purple (#722880), pink (#D72D51), orange (#EB5C18), amber (#F08800), gold (#DEB600)\n16. **Vintage Earthy**: Mustard (#E3B448), sage (#CBD18F), forest green (#3A6B35), cream (#F4F1DE)\n17. **Coastal Rose**: Old rose (#AD7670), beaver (#B49886), eggshell (#F3ECDC), ash gray (#BFD5BE)\n18. **Orange & Turquoise**: Light orange (#FC993E), grayish turquoise (#667C6F), white (#FCFCFC)\n\n#### Visual Details Options\n\n**Geometric Patterns**:\n- Diagonal section dividers instead of horizontal\n- Asymmetric column widths (30/70, 40/60, 25/75)\n- Rotated text headers at 90Â° or 270Â°\n- Circular/hexagonal frames for images\n- Triangular accent shapes in corners\n- Overlapping shapes for depth\n\n**Border & Frame Treatments**:\n- Thick single-color borders (10-20pt) on one side only\n- Double-line borders with contrasting colors\n- Corner brackets instead of full frames\n- L-shaped borders (top+left or bottom+right)\n- Underline accents beneath headers (3-5pt thick)\n\n**Typography Treatments**:\n- Extreme size contrast (72pt headlines vs 11pt body)\n- All-caps headers with wide letter spacing\n- Numbered sections in oversized display type\n- Monospace (Courier New) for data/stats/technical content\n- Condensed fonts (Arial Narrow) for dense information\n- Outlined text for emphasis\n\n**Chart & Data Styling**:\n- Monochrome charts with single accent color for key data\n- Horizontal bar charts instead of vertical\n- Dot plots instead of bar charts\n- Minimal gridlines or none at all\n- Data labels directly on elements (no legends)\n- Oversized numbers for key metrics\n\n**Layout Innovations**:\n- Full-bleed images with text overlays\n- Sidebar column (20-30% width) for navigation/context\n- Modular grid systems (3Ã—3, 4Ã—4 blocks)\n- Z-pattern or F-pattern content flow\n- Floating text boxes over colored shapes\n- Magazine-style multi-column layouts\n\n**Background Treatments**:\n- Solid color blocks occupying 40-60% of slide\n- Gradient fills (vertical or diagonal only)\n- Split backgrounds (two colors, diagonal or vertical)\n- Edge-to-edge color bands\n- Negative space as a design element\n\n### Layout Tips\n**When creating slides with charts or tables:**\n- **Two-column layout (PREFERRED)**: Use a header spanning the full width, then two columns below - text/bullets in one column and the featured content in the other. This provides better balance and makes charts/tables more readable. Use flexbox with unequal column widths (e.g., 40%/60% split) to optimize space for each content type.\n- **Full-slide layout**: Let the featured content (chart/table) take up the entire slide for maximum impact and readability\n- **NEVER vertically stack**: Do not place charts/tables below text in a single column - this causes poor readability and layout issues\n\n### Workflow\n1. **MANDATORY - READ ENTIRE FILE**: Read [`html2pptx.md`](html2pptx.md) completely from start to finish. **NEVER set any range limits when reading this file.** Read the full file content for detailed syntax, critical formatting rules, and best practices before proceeding with presentation creation.\n2. Create an HTML file for each slide with proper dimensions (e.g., 720pt Ã— 405pt for 16:9)\n   - Use `<p>`, `<h1>`-`<h6>`, `<ul>`, `<ol>` for all text content\n   - Use `class=\"placeholder\"` for areas where charts/tables will be added (render with gray background for visibility)\n   - **CRITICAL**: Rasterize gradients and icons as PNG images FIRST using Sharp, then reference in HTML\n   - **LAYOUT**: For slides with charts/tables/images, use either full-slide layout or two-column layout for better readability\n3. Create and run a JavaScript file using the [`html2pptx.js`](scripts/html2pptx.js) library to convert HTML slides to PowerPoint and save the presentation\n   - Use the `html2pptx()` function to process each HTML file\n   - Add charts and tables to placeholder areas using PptxGenJS API\n   - Save the presentation using `pptx.writeFile()`\n4. **Visual validation**: Generate thumbnails and inspect for layout issues\n   - Create thumbnail grid: `python scripts/thumbnail.py output.pptx workspace/thumbnails --cols 4`\n   - Read and carefully examine the thumbnail image for:\n     - **Text cutoff**: Text being cut off by header bars, shapes, or slide edges\n     - **Text overlap**: Text overlapping with other text or shapes\n     - **Positioning issues**: Content too close to slide boundaries or other elements\n     - **Contrast issues**: Insufficient contrast between text and backgrounds\n   - If issues found, adjust HTML margins/spacing/colors and regenerate the presentation\n   - Repeat until all slides are visually correct\n\n## Editing an existing PowerPoint presentation\n\nWhen edit slides in an existing PowerPoint presentation, you need to work with the raw Office Open XML (OOXML) format. This involves unpacking the .pptx file, editing the XML content, and repacking it.\n\n### Workflow\n1. **MANDATORY - READ ENTIRE FILE**: Read [`ooxml.md`](ooxml.md) (~500 lines) completely from start to finish.  **NEVER set any range limits when reading this file.**  Read the full file content for detailed guidance on OOXML structure and editing workflows before any presentation editing.\n2. Unpack the presentation: `python ooxml/scripts/unpack.py <office_file> <output_dir>`\n3. Edit the XML files (primarily `ppt/slides/slide{N}.xml` and related files)\n4. **CRITICAL**: Validate immediately after each edit and fix any validation errors before proceeding: `python ooxml/scripts/validate.py <dir> --original <file>`\n5. Pack the final presentation: `python ooxml/scripts/pack.py <input_directory> <office_file>`\n\n## Creating a new PowerPoint presentation **using a template**\n\nWhen you need to create a presentation that follows an existing template's design, you'll need to duplicate and re-arrange template slides before then replacing placeholder context.\n\n### Workflow\n1. **Extract template text AND create visual thumbnail grid**:\n   * Extract text: `python -m markitdown template.pptx > template-content.md`\n   * Read `template-content.md`: Read the entire file to understand the contents of the template presentation. **NEVER set any range limits when reading this file.**\n   * Create thumbnail grids: `python scripts/thumbnail.py template.pptx`\n   * See [Creating Thumbnail Grids](#creating-thumbnail-grids) section for more details\n\n2. **Analyze template and save inventory to a file**:\n   * **Visual Analysis**: Review thumbnail grid(s) to understand slide layouts, design patterns, and visual structure\n   * Create and save a template inventory file at `template-inventory.md` containing:\n     ```markdown\n     # Template Inventory Analysis\n     **Total Slides: [count]**\n     **IMPORTANT: Slides are 0-indexed (first slide = 0, last slide = count-1)**\n\n     ## [Category Name]\n     - Slide 0: [Layout code if available] - Description/purpose\n     - Slide 1: [Layout code] - Description/purpose\n     - Slide 2: [Layout code] - Description/purpose\n     [... EVERY slide must be listed individually with its index ...]\n     ```\n   * **Using the thumbnail grid**: Reference the visual thumbnails to identify:\n     - Layout patterns (title slides, content layouts, section dividers)\n     - Image placeholder locations and counts\n     - Design consistency across slide groups\n     - Visual hierarchy and structure\n   * This inventory file is REQUIRED for selecting appropriate templates in the next step\n\n3. **Create presentation outline based on template inventory**:\n   * Review available templates from step 2.\n   * Choose an intro or title template for the first slide. This should be one of the first templates.\n   * Choose safe, text-based layouts for the other slides.\n   * **CRITICAL: Match layout structure to actual content**:\n     - Single-column layouts: Use for unified narrative or single topic\n     - Two-column layouts: Use ONLY when you have exactly 2 distinct items/concepts\n     - Three-column layouts: Use ONLY when you have exactly 3 distinct items/concepts\n     - Image + text layouts: Use ONLY when you have actual images to insert\n     - Quote layouts: Use ONLY for actual quotes from people (with attribution), never for emphasis\n     - Never use layouts with more placeholders than you have content\n     - If you have 2 items, don't force them into a 3-column layout\n     - If you have 4+ items, consider breaking into multiple slides or using a list format\n   * Count your actual content pieces BEFORE selecting the layout\n   * Verify each placeholder in the chosen layout will be filled with meaningful content\n   * Select one option representing the **best** layout for each content section.\n   * Save `outline.md` with content AND template mapping that leverages available designs\n   * Example template mapping:\n      ```\n      # Template slides to use (0-based indexing)\n      # WARNING: Verify indices are within range! Template with 73 slides has indices 0-72\n      # Mapping: slide numbers from outline -> template slide indices\n      template_mapping = [\n          0,   # Use slide 0 (Title/Cover)\n          34,  # Use slide 34 (B1: Title and body)\n          34,  # Use slide 34 again (duplicate for second B1)\n          50,  # Use slide 50 (E1: Quote)\n          54,  # Use slide 54 (F2: Closing + Text)\n      ]\n      ```\n\n4. **Duplicate, reorder, and delete slides using `rearrange.py`**:\n   * Use the `scripts/rearrange.py` script to create a new presentation with slides in the desired order:\n     ```bash\n     python scripts/rearrange.py template.pptx working.pptx 0,34,34,50,52\n     ```\n   * The script handles duplicating repeated slides, deleting unused slides, and reordering automatically\n   * Slide indices are 0-based (first slide is 0, second is 1, etc.)\n   * The same slide index can appear multiple times to duplicate that slide\n\n5. **Extract ALL text using the `inventory.py` script**:\n   * **Run inventory extraction**:\n     ```bash\n     python scripts/inventory.py working.pptx text-inventory.json\n     ```\n   * **Read text-inventory.json**: Read the entire text-inventory.json file to understand all shapes and their properties. **NEVER set any range limits when reading this file.**\n\n   * The inventory JSON structure:\n      ```json\n        {\n          \"slide-0\": {\n            \"shape-0\": {\n              \"placeholder_type\": \"TITLE\",  // or null for non-placeholders\n              \"left\": 1.5,                  // position in inches\n              \"top\": 2.0,\n              \"width\": 7.5,\n              \"height\": 1.2,\n              \"paragraphs\": [\n                {\n                  \"text\": \"Paragraph text\",\n                  // Optional properties (only included when non-default):\n                  \"bullet\": true,           // explicit bullet detected\n                  \"level\": 0,               // only included when bullet is true\n                  \"alignment\": \"CENTER\",    // CENTER, RIGHT (not LEFT)\n                  \"space_before\": 10.0,     // space before paragraph in points\n                  \"space_after\": 6.0,       // space after paragraph in points\n                  \"line_spacing\": 22.4,     // line spacing in points\n                  \"font_name\": \"Arial\",     // from first run\n                  \"font_size\": 14.0,        // in points\n                  \"bold\": true,\n                  \"italic\": false,\n                  \"underline\": false,\n                  \"color\": \"FF0000\"         // RGB color\n                }\n              ]\n            }\n          }\n        }\n      ```\n\n   * Key features:\n     - **Slides**: Named as \"slide-0\", \"slide-1\", etc.\n     - **Shapes**: Ordered by visual position (top-to-bottom, left-to-right) as \"shape-0\", \"shape-1\", etc.\n     - **Placeholder types**: TITLE, CENTER_TITLE, SUBTITLE, BODY, OBJECT, or null\n     - **Default font size**: `default_font_size` in points extracted from layout placeholders (when available)\n     - **Slide numbers are filtered**: Shapes with SLIDE_NUMBER placeholder type are automatically excluded from inventory\n     - **Bullets**: When `bullet: true`, `level` is always included (even if 0)\n     - **Spacing**: `space_before`, `space_after`, and `line_spacing` in points (only included when set)\n     - **Colors**: `color` for RGB (e.g., \"FF0000\"), `theme_color` for theme colors (e.g., \"DARK_1\")\n     - **Properties**: Only non-default values are included in the output\n\n6. **Generate replacement text and save the data to a JSON file**\n   Based on the text inventory from the previous step:\n   - **CRITICAL**: First verify which shapes exist in the inventory - only reference shapes that are actually present\n   - **VALIDATION**: The replace.py script will validate that all shapes in your replacement JSON exist in the inventory\n     - If you reference a non-existent shape, you'll get an error showing available shapes\n     - If you reference a non-existent slide, you'll get an error indicating the slide doesn't exist\n     - All validation errors are shown at once before the script exits\n   - **IMPORTANT**: The replace.py script uses inventory.py internally to identify ALL text shapes\n   - **AUTOMATIC CLEARING**: ALL text shapes from the inventory will be cleared unless you provide \"paragraphs\" for them\n   - Add a \"paragraphs\" field to shapes that need content (not \"replacement_paragraphs\")\n   - Shapes without \"paragraphs\" in the replacement JSON will have their text cleared automatically\n   - Paragraphs with bullets will be automatically left aligned. Don't set the `alignment` property on when `\"bullet\": true`\n   - Generate appropriate replacement content for placeholder text\n   - Use shape size to determine appropriate content length\n   - **CRITICAL**: Include paragraph properties from the original inventory - don't just provide text\n   - **IMPORTANT**: When bullet: true, do NOT include bullet symbols (â€¢, -, *) in text - they're added automatically\n   - **ESSENTIAL FORMATTING RULES**:\n     - Headers/titles should typically have `\"bold\": true`\n     - List items should have `\"bullet\": true, \"level\": 0` (level is required when bullet is true)\n     - Preserve any alignment properties (e.g., `\"alignment\": \"CENTER\"` for centered text)\n     - Include font properties when different from default (e.g., `\"font_size\": 14.0`, `\"font_name\": \"Lora\"`)\n     - Colors: Use `\"color\": \"FF0000\"` for RGB or `\"theme_color\": \"DARK_1\"` for theme colors\n     - The replacement script expects **properly formatted paragraphs**, not just text strings\n     - **Overlapping shapes**: Prefer shapes with larger default_font_size or more appropriate placeholder_type\n   - Save the updated inventory with replacements to `replacement-text.json`\n   - **WARNING**: Different template layouts have different shape counts - always check the actual inventory before creating replacements\n\n   Example paragraphs field showing proper formatting:\n   ```json\n   \"paragraphs\": [\n     {\n       \"text\": \"New presentation title text\",\n       \"alignment\": \"CENTER\",\n       \"bold\": true\n     },\n     {\n       \"text\": \"Section Header\",\n       \"bold\": true\n     },\n     {\n       \"text\": \"First bullet point without bullet symbol\",\n       \"bullet\": true,\n       \"level\": 0\n     },\n     {\n       \"text\": \"Red colored text\",\n       \"color\": \"FF0000\"\n     },\n     {\n       \"text\": \"Theme colored text\",\n       \"theme_color\": \"DARK_1\"\n     },\n     {\n       \"text\": \"Regular paragraph text without special formatting\"\n     }\n   ]\n   ```\n\n   **Shapes not listed in the replacement JSON are automatically cleared**:\n   ```json\n   {\n     \"slide-0\": {\n       \"shape-0\": {\n         \"paragraphs\": [...] // This shape gets new text\n       }\n       // shape-1 and shape-2 from inventory will be cleared automatically\n     }\n   }\n   ```\n\n   **Common formatting patterns for presentations**:\n   - Title slides: Bold text, sometimes centered\n   - Section headers within slides: Bold text\n   - Bullet lists: Each item needs `\"bullet\": true, \"level\": 0`\n   - Body text: Usually no special properties needed\n   - Quotes: May have special alignment or font properties\n\n7. **Apply replacements using the `replace.py` script**\n   ```bash\n   python scripts/replace.py working.pptx replacement-text.json output.pptx\n   ```\n\n   The script will:\n   - First extract the inventory of ALL text shapes using functions from inventory.py\n   - Validate that all shapes in the replacement JSON exist in the inventory\n   - Clear text from ALL shapes identified in the inventory\n   - Apply new text only to shapes with \"paragraphs\" defined in the replacement JSON\n   - Preserve formatting by applying paragraph properties from the JSON\n   - Handle bullets, alignment, font properties, and colors automatically\n   - Save the updated presentation\n\n   Example validation errors:\n   ```\n   ERROR: Invalid shapes in replacement JSON:\n     - Shape 'shape-99' not found on 'slide-0'. Available shapes: shape-0, shape-1, shape-4\n     - Slide 'slide-999' not found in inventory\n   ```\n\n   ```\n   ERROR: Replacement text made overflow worse in these shapes:\n     - slide-0/shape-2: overflow worsened by 1.25\" (was 0.00\", now 1.25\")\n   ```\n\n## Creating Thumbnail Grids\n\nTo create visual thumbnail grids of PowerPoint slides for quick analysis and reference:\n\n```bash\npython scripts/thumbnail.py template.pptx [output_prefix]\n```\n\n**Features**:\n- Creates: `thumbnails.jpg` (or `thumbnails-1.jpg`, `thumbnails-2.jpg`, etc. for large decks)\n- Default: 5 columns, max 30 slides per grid (5Ã—6)\n- Custom prefix: `python scripts/thumbnail.py template.pptx my-grid`\n  - Note: The output prefix should include the path if you want output in a specific directory (e.g., `workspace/my-grid`)\n- Adjust columns: `--cols 4` (range: 3-6, affects slides per grid)\n- Grid limits: 3 cols = 12 slides/grid, 4 cols = 20, 5 cols = 30, 6 cols = 42\n- Slides are zero-indexed (Slide 0, Slide 1, etc.)\n\n**Use cases**:\n- Template analysis: Quickly understand slide layouts and design patterns\n- Content review: Visual overview of entire presentation\n- Navigation reference: Find specific slides by their visual appearance\n- Quality check: Verify all slides are properly formatted\n\n**Examples**:\n```bash\n# Basic usage\npython scripts/thumbnail.py presentation.pptx\n\n# Combine options: custom name, columns\npython scripts/thumbnail.py template.pptx analysis --cols 4\n```\n\n## Converting Slides to Images\n\nTo visually analyze PowerPoint slides, convert them to images using a two-step process:\n\n1. **Convert PPTX to PDF**:\n   ```bash\n   soffice --headless --convert-to pdf template.pptx\n   ```\n\n2. **Convert PDF pages to JPEG images**:\n   ```bash\n   pdftoppm -jpeg -r 150 template.pdf slide\n   ```\n   This creates files like `slide-1.jpg`, `slide-2.jpg`, etc.\n\nOptions:\n- `-r 150`: Sets resolution to 150 DPI (adjust for quality/size balance)\n- `-jpeg`: Output JPEG format (use `-png` for PNG if preferred)\n- `-f N`: First page to convert (e.g., `-f 2` starts from page 2)\n- `-l N`: Last page to convert (e.g., `-l 5` stops at page 5)\n- `slide`: Prefix for output files\n\nExample for specific range:\n```bash\npdftoppm -jpeg -r 150 -f 2 -l 5 template.pdf slide  # Converts only pages 2-5\n```\n\n## Code Style Guidelines\n**IMPORTANT**: When generating code for PPTX operations:\n- Write concise code\n- Avoid verbose variable names and redundant operations\n- Avoid unnecessary print statements\n\n## Dependencies\n\nRequired dependencies (should already be installed):\n\n- **markitdown**: `pip install \"markitdown[pptx]\"` (for text extraction from presentations)\n- **pptxgenjs**: `npm install -g pptxgenjs` (for creating presentations via html2pptx)\n- **playwright**: `npm install -g playwright` (for HTML rendering in html2pptx)\n- **react-icons**: `npm install -g react-icons react react-dom` (for icons)\n- **sharp**: `npm install -g sharp` (for SVG rasterization and image processing)\n- **LibreOffice**: `sudo apt-get install libreoffice` (for PDF conversion)\n- **Poppler**: `sudo apt-get install poppler-utils` (for pdftoppm to convert PDF to images)\n- **defusedxml**: `pip install defusedxml` (for secure XML parsing)"
              },
              {
                "name": "skill-creator",
                "description": "Guide for creating effective skills. This skill should be used when users want to create a new skill (or update an existing skill) that extends Claude's capabilities with specialized knowledge, workflows, or tool integrations.",
                "path": "skills/skill-creator/SKILL.md",
                "frontmatter": {
                  "name": "skill-creator",
                  "description": "Guide for creating effective skills. This skill should be used when users want to create a new skill (or update an existing skill) that extends Claude's capabilities with specialized knowledge, workflows, or tool integrations.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "# Skill Creator\n\nThis skill provides guidance for creating effective skills.\n\n## About Skills\n\nSkills are modular, self-contained packages that extend Claude's capabilities by providing\nspecialized knowledge, workflows, and tools. Think of them as \"onboarding guides\" for specific\ndomains or tasksâ€”they transform Claude from a general-purpose agent into a specialized agent\nequipped with procedural knowledge that no model can fully possess.\n\n### What Skills Provide\n\n1. Specialized workflows - Multi-step procedures for specific domains\n2. Tool integrations - Instructions for working with specific file formats or APIs\n3. Domain expertise - Company-specific knowledge, schemas, business logic\n4. Bundled resources - Scripts, references, and assets for complex and repetitive tasks\n\n## Core Principles\n\n### Concise is Key\n\nThe context window is a public good. Skills share the context window with everything else Claude needs: system prompt, conversation history, other Skills' metadata, and the actual user request.\n\n**Default assumption: Claude is already very smart.** Only add context Claude doesn't already have. Challenge each piece of information: \"Does Claude really need this explanation?\" and \"Does this paragraph justify its token cost?\"\n\nPrefer concise examples over verbose explanations.\n\n### Set Appropriate Degrees of Freedom\n\nMatch the level of specificity to the task's fragility and variability:\n\n**High freedom (text-based instructions)**: Use when multiple approaches are valid, decisions depend on context, or heuristics guide the approach.\n\n**Medium freedom (pseudocode or scripts with parameters)**: Use when a preferred pattern exists, some variation is acceptable, or configuration affects behavior.\n\n**Low freedom (specific scripts, few parameters)**: Use when operations are fragile and error-prone, consistency is critical, or a specific sequence must be followed.\n\nThink of Claude as exploring a path: a narrow bridge with cliffs needs specific guardrails (low freedom), while an open field allows many routes (high freedom).\n\n### Anatomy of a Skill\n\nEvery skill consists of a required SKILL.md file and optional bundled resources:\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md (required)\nâ”‚   â”œâ”€â”€ YAML frontmatter metadata (required)\nâ”‚   â”‚   â”œâ”€â”€ name: (required)\nâ”‚   â”‚   â””â”€â”€ description: (required)\nâ”‚   â””â”€â”€ Markdown instructions (required)\nâ””â”€â”€ Bundled Resources (optional)\n    â”œâ”€â”€ scripts/          - Executable code (Python/Bash/etc.)\n    â”œâ”€â”€ references/       - Documentation intended to be loaded into context as needed\n    â””â”€â”€ assets/           - Files used in output (templates, icons, fonts, etc.)\n```\n\n#### SKILL.md (required)\n\nEvery SKILL.md consists of:\n\n- **Frontmatter** (YAML): Contains `name` and `description` fields. These are the only fields that Claude reads to determine when the skill gets used, thus it is very important to be clear and comprehensive in describing what the skill is, and when it should be used.\n- **Body** (Markdown): Instructions and guidance for using the skill. Only loaded AFTER the skill triggers (if at all).\n\n#### Bundled Resources (optional)\n\n##### Scripts (`scripts/`)\n\nExecutable code (Python/Bash/etc.) for tasks that require deterministic reliability or are repeatedly rewritten.\n\n- **When to include**: When the same code is being rewritten repeatedly or deterministic reliability is needed\n- **Example**: `scripts/rotate_pdf.py` for PDF rotation tasks\n- **Benefits**: Token efficient, deterministic, may be executed without loading into context\n- **Note**: Scripts may still need to be read by Claude for patching or environment-specific adjustments\n\n##### References (`references/`)\n\nDocumentation and reference material intended to be loaded as needed into context to inform Claude's process and thinking.\n\n- **When to include**: For documentation that Claude should reference while working\n- **Examples**: `references/finance.md` for financial schemas, `references/mnda.md` for company NDA template, `references/policies.md` for company policies, `references/api_docs.md` for API specifications\n- **Use cases**: Database schemas, API documentation, domain knowledge, company policies, detailed workflow guides\n- **Benefits**: Keeps SKILL.md lean, loaded only when Claude determines it's needed\n- **Best practice**: If files are large (>10k words), include grep search patterns in SKILL.md\n- **Avoid duplication**: Information should live in either SKILL.md or references files, not both. Prefer references files for detailed information unless it's truly core to the skillâ€”this keeps SKILL.md lean while making information discoverable without hogging the context window. Keep only essential procedural instructions and workflow guidance in SKILL.md; move detailed reference material, schemas, and examples to references files.\n\n##### Assets (`assets/`)\n\nFiles not intended to be loaded into context, but rather used within the output Claude produces.\n\n- **When to include**: When the skill needs files that will be used in the final output\n- **Examples**: `assets/logo.png` for brand assets, `assets/slides.pptx` for PowerPoint templates, `assets/frontend-template/` for HTML/React boilerplate, `assets/font.ttf` for typography\n- **Use cases**: Templates, images, icons, boilerplate code, fonts, sample documents that get copied or modified\n- **Benefits**: Separates output resources from documentation, enables Claude to use files without loading them into context\n\n#### What to Not Include in a Skill\n\nA skill should only contain essential files that directly support its functionality. Do NOT create extraneous documentation or auxiliary files, including:\n\n- README.md\n- INSTALLATION_GUIDE.md\n- QUICK_REFERENCE.md\n- CHANGELOG.md\n- etc.\n\nThe skill should only contain the information needed for an AI agent to do the job at hand. It should not contain auxilary context about the process that went into creating it, setup and testing procedures, user-facing documentation, etc. Creating additional documentation files just adds clutter and confusion.\n\n### Progressive Disclosure Design Principle\n\nSkills use a three-level loading system to manage context efficiently:\n\n1. **Metadata (name + description)** - Always in context (~100 words)\n2. **SKILL.md body** - When skill triggers (<5k words)\n3. **Bundled resources** - As needed by Claude (Unlimited because scripts can be executed without reading into context window)\n\n#### Progressive Disclosure Patterns\n\nKeep SKILL.md body to the essentials and under 500 lines to minimize context bloat. Split content into separate files when approaching this limit. When splitting out content into other files, it is very important to reference them from SKILL.md and describe clearly when to read them, to ensure the reader of the skill knows they exist and when to use them.\n\n**Key principle:** When a skill supports multiple variations, frameworks, or options, keep only the core workflow and selection guidance in SKILL.md. Move variant-specific details (patterns, examples, configuration) into separate reference files.\n\n**Pattern 1: High-level guide with references**\n\n```markdown\n# PDF Processing\n\n## Quick start\n\nExtract text with pdfplumber:\n[code example]\n\n## Advanced features\n\n- **Form filling**: See [FORMS.md](FORMS.md) for complete guide\n- **API reference**: See [REFERENCE.md](REFERENCE.md) for all methods\n- **Examples**: See [EXAMPLES.md](EXAMPLES.md) for common patterns\n```\n\nClaude loads FORMS.md, REFERENCE.md, or EXAMPLES.md only when needed.\n\n**Pattern 2: Domain-specific organization**\n\nFor Skills with multiple domains, organize content by domain to avoid loading irrelevant context:\n\n```\nbigquery-skill/\nâ”œâ”€â”€ SKILL.md (overview and navigation)\nâ””â”€â”€ reference/\n    â”œâ”€â”€ finance.md (revenue, billing metrics)\n    â”œâ”€â”€ sales.md (opportunities, pipeline)\n    â”œâ”€â”€ product.md (API usage, features)\n    â””â”€â”€ marketing.md (campaigns, attribution)\n```\n\nWhen a user asks about sales metrics, Claude only reads sales.md.\n\nSimilarly, for skills supporting multiple frameworks or variants, organize by variant:\n\n```\ncloud-deploy/\nâ”œâ”€â”€ SKILL.md (workflow + provider selection)\nâ””â”€â”€ references/\n    â”œâ”€â”€ aws.md (AWS deployment patterns)\n    â”œâ”€â”€ gcp.md (GCP deployment patterns)\n    â””â”€â”€ azure.md (Azure deployment patterns)\n```\n\nWhen the user chooses AWS, Claude only reads aws.md.\n\n**Pattern 3: Conditional details**\n\nShow basic content, link to advanced content:\n\n```markdown\n# DOCX Processing\n\n## Creating documents\n\nUse docx-js for new documents. See [DOCX-JS.md](DOCX-JS.md).\n\n## Editing documents\n\nFor simple edits, modify the XML directly.\n\n**For tracked changes**: See [REDLINING.md](REDLINING.md)\n**For OOXML details**: See [OOXML.md](OOXML.md)\n```\n\nClaude reads REDLINING.md or OOXML.md only when the user needs those features.\n\n**Important guidelines:**\n\n- **Avoid deeply nested references** - Keep references one level deep from SKILL.md. All reference files should link directly from SKILL.md.\n- **Structure longer reference files** - For files longer than 100 lines, include a table of contents at the top so Claude can see the full scope when previewing.\n\n## Skill Creation Process\n\nSkill creation involves these steps:\n\n1. Understand the skill with concrete examples\n2. Plan reusable skill contents (scripts, references, assets)\n3. Initialize the skill (run init_skill.py)\n4. Edit the skill (implement resources and write SKILL.md)\n5. Package the skill (run package_skill.py)\n6. Iterate based on real usage\n\nFollow these steps in order, skipping only if there is a clear reason why they are not applicable.\n\n### Step 1: Understanding the Skill with Concrete Examples\n\nSkip this step only when the skill's usage patterns are already clearly understood. It remains valuable even when working with an existing skill.\n\nTo create an effective skill, clearly understand concrete examples of how the skill will be used. This understanding can come from either direct user examples or generated examples that are validated with user feedback.\n\nFor example, when building an image-editor skill, relevant questions include:\n\n- \"What functionality should the image-editor skill support? Editing, rotating, anything else?\"\n- \"Can you give some examples of how this skill would be used?\"\n- \"I can imagine users asking for things like 'Remove the red-eye from this image' or 'Rotate this image'. Are there other ways you imagine this skill being used?\"\n- \"What would a user say that should trigger this skill?\"\n\nTo avoid overwhelming users, avoid asking too many questions in a single message. Start with the most important questions and follow up as needed for better effectiveness.\n\nConclude this step when there is a clear sense of the functionality the skill should support.\n\n### Step 2: Planning the Reusable Skill Contents\n\nTo turn concrete examples into an effective skill, analyze each example by:\n\n1. Considering how to execute on the example from scratch\n2. Identifying what scripts, references, and assets would be helpful when executing these workflows repeatedly\n\nExample: When building a `pdf-editor` skill to handle queries like \"Help me rotate this PDF,\" the analysis shows:\n\n1. Rotating a PDF requires re-writing the same code each time\n2. A `scripts/rotate_pdf.py` script would be helpful to store in the skill\n\nExample: When designing a `frontend-webapp-builder` skill for queries like \"Build me a todo app\" or \"Build me a dashboard to track my steps,\" the analysis shows:\n\n1. Writing a frontend webapp requires the same boilerplate HTML/React each time\n2. An `assets/hello-world/` template containing the boilerplate HTML/React project files would be helpful to store in the skill\n\nExample: When building a `big-query` skill to handle queries like \"How many users have logged in today?\" the analysis shows:\n\n1. Querying BigQuery requires re-discovering the table schemas and relationships each time\n2. A `references/schema.md` file documenting the table schemas would be helpful to store in the skill\n\nTo establish the skill's contents, analyze each concrete example to create a list of the reusable resources to include: scripts, references, and assets.\n\n### Step 3: Initializing the Skill\n\nAt this point, it is time to actually create the skill.\n\nSkip this step only if the skill being developed already exists, and iteration or packaging is needed. In this case, continue to the next step.\n\nWhen creating a new skill from scratch, always run the `init_skill.py` script. The script conveniently generates a new template skill directory that automatically includes everything a skill requires, making the skill creation process much more efficient and reliable.\n\nUsage:\n\n```bash\nscripts/init_skill.py <skill-name> --path <output-directory>\n```\n\nThe script:\n\n- Creates the skill directory at the specified path\n- Generates a SKILL.md template with proper frontmatter and TODO placeholders\n- Creates example resource directories: `scripts/`, `references/`, and `assets/`\n- Adds example files in each directory that can be customized or deleted\n\nAfter initialization, customize or remove the generated SKILL.md and example files as needed.\n\n### Step 4: Edit the Skill\n\nWhen editing the (newly-generated or existing) skill, remember that the skill is being created for another instance of Claude to use. Include information that would be beneficial and non-obvious to Claude. Consider what procedural knowledge, domain-specific details, or reusable assets would help another Claude instance execute these tasks more effectively.\n\n#### Learn Proven Design Patterns\n\nConsult these helpful guides based on your skill's needs:\n\n- **Multi-step processes**: See references/workflows.md for sequential workflows and conditional logic\n- **Specific output formats or quality standards**: See references/output-patterns.md for template and example patterns\n\nThese files contain established best practices for effective skill design.\n\n#### Start with Reusable Skill Contents\n\nTo begin implementation, start with the reusable resources identified above: `scripts/`, `references/`, and `assets/` files. Note that this step may require user input. For example, when implementing a `brand-guidelines` skill, the user may need to provide brand assets or templates to store in `assets/`, or documentation to store in `references/`.\n\nAdded scripts must be tested by actually running them to ensure there are no bugs and that the output matches what is expected. If there are many similar scripts, only a representative sample needs to be tested to ensure confidence that they all work while balancing time to completion.\n\nAny example files and directories not needed for the skill should be deleted. The initialization script creates example files in `scripts/`, `references/`, and `assets/` to demonstrate structure, but most skills won't need all of them.\n\n#### Update SKILL.md\n\n**Writing Guidelines:** Always use imperative/infinitive form.\n\n##### Frontmatter\n\nWrite the YAML frontmatter with `name` and `description`:\n\n- `name`: The skill name\n- `description`: This is the primary triggering mechanism for your skill, and helps Claude understand when to use the skill.\n  - Include both what the Skill does and specific triggers/contexts for when to use it.\n  - Include all \"when to use\" information here - Not in the body. The body is only loaded after triggering, so \"When to Use This Skill\" sections in the body are not helpful to Claude.\n  - Example description for a `docx` skill: \"Comprehensive document creation, editing, and analysis with support for tracked changes, comments, formatting preservation, and text extraction. Use when Claude needs to work with professional documents (.docx files) for: (1) Creating new documents, (2) Modifying or editing content, (3) Working with tracked changes, (4) Adding comments, or any other document tasks\"\n\nDo not include any other fields in YAML frontmatter.\n\n##### Body\n\nWrite instructions for using the skill and its bundled resources.\n\n### Step 5: Packaging a Skill\n\nOnce development of the skill is complete, it must be packaged into a distributable .skill file that gets shared with the user. The packaging process automatically validates the skill first to ensure it meets all requirements:\n\n```bash\nscripts/package_skill.py <path/to/skill-folder>\n```\n\nOptional output directory specification:\n\n```bash\nscripts/package_skill.py <path/to/skill-folder> ./dist\n```\n\nThe packaging script will:\n\n1. **Validate** the skill automatically, checking:\n\n   - YAML frontmatter format and required fields\n   - Skill naming conventions and directory structure\n   - Description completeness and quality\n   - File organization and resource references\n\n2. **Package** the skill if validation passes, creating a .skill file named after the skill (e.g., `my-skill.skill`) that includes all files and maintains the proper directory structure for distribution. The .skill file is a zip file with a .skill extension.\n\nIf validation fails, the script will report the errors and exit without creating a package. Fix any validation errors and run the packaging command again.\n\n### Step 6: Iterate\n\nAfter testing the skill, users may request improvements. Often this happens right after using the skill, with fresh context of how the skill performed.\n\n**Iteration workflow:**\n\n1. Use the skill on real tasks\n2. Notice struggles or inefficiencies\n3. Identify how SKILL.md or bundled resources should be updated\n4. Implement changes and test again"
              },
              {
                "name": "slack-gif-creator",
                "description": "Knowledge and utilities for creating animated GIFs optimized for Slack. Provides constraints, validation tools, and animation concepts. Use when users request animated GIFs for Slack like \"make me a GIF of X doing Y for Slack.\"",
                "path": "skills/slack-gif-creator/SKILL.md",
                "frontmatter": {
                  "name": "slack-gif-creator",
                  "description": "Knowledge and utilities for creating animated GIFs optimized for Slack. Provides constraints, validation tools, and animation concepts. Use when users request animated GIFs for Slack like \"make me a GIF of X doing Y for Slack.\"",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "# Slack GIF Creator\n\nA toolkit providing utilities and knowledge for creating animated GIFs optimized for Slack.\n\n## Slack Requirements\n\n**Dimensions:**\n- Emoji GIFs: 128x128 (recommended)\n- Message GIFs: 480x480\n\n**Parameters:**\n- FPS: 10-30 (lower is smaller file size)\n- Colors: 48-128 (fewer = smaller file size)\n- Duration: Keep under 3 seconds for emoji GIFs\n\n## Core Workflow\n\n```python\nfrom core.gif_builder import GIFBuilder\nfrom PIL import Image, ImageDraw\n\n# 1. Create builder\nbuilder = GIFBuilder(width=128, height=128, fps=10)\n\n# 2. Generate frames\nfor i in range(12):\n    frame = Image.new('RGB', (128, 128), (240, 248, 255))\n    draw = ImageDraw.Draw(frame)\n\n    # Draw your animation using PIL primitives\n    # (circles, polygons, lines, etc.)\n\n    builder.add_frame(frame)\n\n# 3. Save with optimization\nbuilder.save('output.gif', num_colors=48, optimize_for_emoji=True)\n```\n\n## Drawing Graphics\n\n### Working with User-Uploaded Images\nIf a user uploads an image, consider whether they want to:\n- **Use it directly** (e.g., \"animate this\", \"split this into frames\")\n- **Use it as inspiration** (e.g., \"make something like this\")\n\nLoad and work with images using PIL:\n```python\nfrom PIL import Image\n\nuploaded = Image.open('file.png')\n# Use directly, or just as reference for colors/style\n```\n\n### Drawing from Scratch\nWhen drawing graphics from scratch, use PIL ImageDraw primitives:\n\n```python\nfrom PIL import ImageDraw\n\ndraw = ImageDraw.Draw(frame)\n\n# Circles/ovals\ndraw.ellipse([x1, y1, x2, y2], fill=(r, g, b), outline=(r, g, b), width=3)\n\n# Stars, triangles, any polygon\npoints = [(x1, y1), (x2, y2), (x3, y3), ...]\ndraw.polygon(points, fill=(r, g, b), outline=(r, g, b), width=3)\n\n# Lines\ndraw.line([(x1, y1), (x2, y2)], fill=(r, g, b), width=5)\n\n# Rectangles\ndraw.rectangle([x1, y1, x2, y2], fill=(r, g, b), outline=(r, g, b), width=3)\n```\n\n**Don't use:** Emoji fonts (unreliable across platforms) or assume pre-packaged graphics exist in this skill.\n\n### Making Graphics Look Good\n\nGraphics should look polished and creative, not basic. Here's how:\n\n**Use thicker lines** - Always set `width=2` or higher for outlines and lines. Thin lines (width=1) look choppy and amateurish.\n\n**Add visual depth**:\n- Use gradients for backgrounds (`create_gradient_background`)\n- Layer multiple shapes for complexity (e.g., a star with a smaller star inside)\n\n**Make shapes more interesting**:\n- Don't just draw a plain circle - add highlights, rings, or patterns\n- Stars can have glows (draw larger, semi-transparent versions behind)\n- Combine multiple shapes (stars + sparkles, circles + rings)\n\n**Pay attention to colors**:\n- Use vibrant, complementary colors\n- Add contrast (dark outlines on light shapes, light outlines on dark shapes)\n- Consider the overall composition\n\n**For complex shapes** (hearts, snowflakes, etc.):\n- Use combinations of polygons and ellipses\n- Calculate points carefully for symmetry\n- Add details (a heart can have a highlight curve, snowflakes have intricate branches)\n\nBe creative and detailed! A good Slack GIF should look polished, not like placeholder graphics.\n\n## Available Utilities\n\n### GIFBuilder (`core.gif_builder`)\nAssembles frames and optimizes for Slack:\n```python\nbuilder = GIFBuilder(width=128, height=128, fps=10)\nbuilder.add_frame(frame)  # Add PIL Image\nbuilder.add_frames(frames)  # Add list of frames\nbuilder.save('out.gif', num_colors=48, optimize_for_emoji=True, remove_duplicates=True)\n```\n\n### Validators (`core.validators`)\nCheck if GIF meets Slack requirements:\n```python\nfrom core.validators import validate_gif, is_slack_ready\n\n# Detailed validation\npasses, info = validate_gif('my.gif', is_emoji=True, verbose=True)\n\n# Quick check\nif is_slack_ready('my.gif'):\n    print(\"Ready!\")\n```\n\n### Easing Functions (`core.easing`)\nSmooth motion instead of linear:\n```python\nfrom core.easing import interpolate\n\n# Progress from 0.0 to 1.0\nt = i / (num_frames - 1)\n\n# Apply easing\ny = interpolate(start=0, end=400, t=t, easing='ease_out')\n\n# Available: linear, ease_in, ease_out, ease_in_out,\n#           bounce_out, elastic_out, back_out\n```\n\n### Frame Helpers (`core.frame_composer`)\nConvenience functions for common needs:\n```python\nfrom core.frame_composer import (\n    create_blank_frame,         # Solid color background\n    create_gradient_background,  # Vertical gradient\n    draw_circle,                # Helper for circles\n    draw_text,                  # Simple text rendering\n    draw_star                   # 5-pointed star\n)\n```\n\n## Animation Concepts\n\n### Shake/Vibrate\nOffset object position with oscillation:\n- Use `math.sin()` or `math.cos()` with frame index\n- Add small random variations for natural feel\n- Apply to x and/or y position\n\n### Pulse/Heartbeat\nScale object size rhythmically:\n- Use `math.sin(t * frequency * 2 * math.pi)` for smooth pulse\n- For heartbeat: two quick pulses then pause (adjust sine wave)\n- Scale between 0.8 and 1.2 of base size\n\n### Bounce\nObject falls and bounces:\n- Use `interpolate()` with `easing='bounce_out'` for landing\n- Use `easing='ease_in'` for falling (accelerating)\n- Apply gravity by increasing y velocity each frame\n\n### Spin/Rotate\nRotate object around center:\n- PIL: `image.rotate(angle, resample=Image.BICUBIC)`\n- For wobble: use sine wave for angle instead of linear\n\n### Fade In/Out\nGradually appear or disappear:\n- Create RGBA image, adjust alpha channel\n- Or use `Image.blend(image1, image2, alpha)`\n- Fade in: alpha from 0 to 1\n- Fade out: alpha from 1 to 0\n\n### Slide\nMove object from off-screen to position:\n- Start position: outside frame bounds\n- End position: target location\n- Use `interpolate()` with `easing='ease_out'` for smooth stop\n- For overshoot: use `easing='back_out'`\n\n### Zoom\nScale and position for zoom effect:\n- Zoom in: scale from 0.1 to 2.0, crop center\n- Zoom out: scale from 2.0 to 1.0\n- Can add motion blur for drama (PIL filter)\n\n### Explode/Particle Burst\nCreate particles radiating outward:\n- Generate particles with random angles and velocities\n- Update each particle: `x += vx`, `y += vy`\n- Add gravity: `vy += gravity_constant`\n- Fade out particles over time (reduce alpha)\n\n## Optimization Strategies\n\nOnly when asked to make the file size smaller, implement a few of the following methods:\n\n1. **Fewer frames** - Lower FPS (10 instead of 20) or shorter duration\n2. **Fewer colors** - `num_colors=48` instead of 128\n3. **Smaller dimensions** - 128x128 instead of 480x480\n4. **Remove duplicates** - `remove_duplicates=True` in save()\n5. **Emoji mode** - `optimize_for_emoji=True` auto-optimizes\n\n```python\n# Maximum optimization for emoji\nbuilder.save(\n    'emoji.gif',\n    num_colors=48,\n    optimize_for_emoji=True,\n    remove_duplicates=True\n)\n```\n\n## Philosophy\n\nThis skill provides:\n- **Knowledge**: Slack's requirements and animation concepts\n- **Utilities**: GIFBuilder, validators, easing functions\n- **Flexibility**: Create the animation logic using PIL primitives\n\nIt does NOT provide:\n- Rigid animation templates or pre-made functions\n- Emoji font rendering (unreliable across platforms)\n- A library of pre-packaged graphics built into the skill\n\n**Note on user uploads**: This skill doesn't include pre-built graphics, but if a user uploads an image, use PIL to load and work with it - interpret based on their request whether they want it used directly or just as inspiration.\n\nBe creative! Combine concepts (bouncing + rotating, pulsing + sliding, etc.) and use PIL's full capabilities.\n\n## Dependencies\n\n```bash\npip install pillow imageio numpy\n```"
              },
              {
                "name": "theme-factory",
                "description": "Toolkit for styling artifacts with a theme. These artifacts can be slides, docs, reportings, HTML landing pages, etc. There are 10 pre-set themes with colors/fonts that you can apply to any artifact that has been creating, or can generate a new theme on-the-fly.",
                "path": "skills/theme-factory/SKILL.md",
                "frontmatter": {
                  "name": "theme-factory",
                  "description": "Toolkit for styling artifacts with a theme. These artifacts can be slides, docs, reportings, HTML landing pages, etc. There are 10 pre-set themes with colors/fonts that you can apply to any artifact that has been creating, or can generate a new theme on-the-fly.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "# Theme Factory Skill\n\nThis skill provides a curated collection of professional font and color themes themes, each with carefully selected color palettes and font pairings. Once a theme is chosen, it can be applied to any artifact.\n\n## Purpose\n\nTo apply consistent, professional styling to presentation slide decks, use this skill. Each theme includes:\n- A cohesive color palette with hex codes\n- Complementary font pairings for headers and body text\n- A distinct visual identity suitable for different contexts and audiences\n\n## Usage Instructions\n\nTo apply styling to a slide deck or other artifact:\n\n1. **Show the theme showcase**: Display the `theme-showcase.pdf` file to allow users to see all available themes visually. Do not make any modifications to it; simply show the file for viewing.\n2. **Ask for their choice**: Ask which theme to apply to the deck\n3. **Wait for selection**: Get explicit confirmation about the chosen theme\n4. **Apply the theme**: Once a theme has been chosen, apply the selected theme's colors and fonts to the deck/artifact\n\n## Themes Available\n\nThe following 10 themes are available, each showcased in `theme-showcase.pdf`:\n\n1. **Ocean Depths** - Professional and calming maritime theme\n2. **Sunset Boulevard** - Warm and vibrant sunset colors\n3. **Forest Canopy** - Natural and grounded earth tones\n4. **Modern Minimalist** - Clean and contemporary grayscale\n5. **Golden Hour** - Rich and warm autumnal palette\n6. **Arctic Frost** - Cool and crisp winter-inspired theme\n7. **Desert Rose** - Soft and sophisticated dusty tones\n8. **Tech Innovation** - Bold and modern tech aesthetic\n9. **Botanical Garden** - Fresh and organic garden colors\n10. **Midnight Galaxy** - Dramatic and cosmic deep tones\n\n## Theme Details\n\nEach theme is defined in the `themes/` directory with complete specifications including:\n- Cohesive color palette with hex codes\n- Complementary font pairings for headers and body text\n- Distinct visual identity suitable for different contexts and audiences\n\n## Application Process\n\nAfter a preferred theme is selected:\n1. Read the corresponding theme file from the `themes/` directory\n2. Apply the specified colors and fonts consistently throughout the deck\n3. Ensure proper contrast and readability\n4. Maintain the theme's visual identity across all slides\n\n## Create your Own Theme\nTo handle cases where none of the existing themes work for an artifact, create a custom theme. Based on provided inputs, generate a new theme similar to the ones above. Give the theme a similar name describing what the font/color combinations represent. Use any basic description provided to choose appropriate colors/fonts. After generating the theme, show it for review and verification. Following that, apply the theme as described above."
              },
              {
                "name": "web-artifacts-builder",
                "description": "Suite of tools for creating elaborate, multi-component claude.ai HTML artifacts using modern frontend web technologies (React, Tailwind CSS, shadcn/ui). Use for complex artifacts requiring state management, routing, or shadcn/ui components - not for simple single-file HTML/JSX artifacts.",
                "path": "skills/web-artifacts-builder/SKILL.md",
                "frontmatter": {
                  "name": "web-artifacts-builder",
                  "description": "Suite of tools for creating elaborate, multi-component claude.ai HTML artifacts using modern frontend web technologies (React, Tailwind CSS, shadcn/ui). Use for complex artifacts requiring state management, routing, or shadcn/ui components - not for simple single-file HTML/JSX artifacts.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "# Web Artifacts Builder\n\nTo build powerful frontend claude.ai artifacts, follow these steps:\n1. Initialize the frontend repo using `scripts/init-artifact.sh`\n2. Develop your artifact by editing the generated code\n3. Bundle all code into a single HTML file using `scripts/bundle-artifact.sh`\n4. Display artifact to user\n5. (Optional) Test the artifact\n\n**Stack**: React 18 + TypeScript + Vite + Parcel (bundling) + Tailwind CSS + shadcn/ui\n\n## Design & Style Guidelines\n\nVERY IMPORTANT: To avoid what is often referred to as \"AI slop\", avoid using excessive centered layouts, purple gradients, uniform rounded corners, and Inter font.\n\n## Quick Start\n\n### Step 1: Initialize Project\n\nRun the initialization script to create a new React project:\n```bash\nbash scripts/init-artifact.sh <project-name>\ncd <project-name>\n```\n\nThis creates a fully configured project with:\n- âœ… React + TypeScript (via Vite)\n- âœ… Tailwind CSS 3.4.1 with shadcn/ui theming system\n- âœ… Path aliases (`@/`) configured\n- âœ… 40+ shadcn/ui components pre-installed\n- âœ… All Radix UI dependencies included\n- âœ… Parcel configured for bundling (via .parcelrc)\n- âœ… Node 18+ compatibility (auto-detects and pins Vite version)\n\n### Step 2: Develop Your Artifact\n\nTo build the artifact, edit the generated files. See **Common Development Tasks** below for guidance.\n\n### Step 3: Bundle to Single HTML File\n\nTo bundle the React app into a single HTML artifact:\n```bash\nbash scripts/bundle-artifact.sh\n```\n\nThis creates `bundle.html` - a self-contained artifact with all JavaScript, CSS, and dependencies inlined. This file can be directly shared in Claude conversations as an artifact.\n\n**Requirements**: Your project must have an `index.html` in the root directory.\n\n**What the script does**:\n- Installs bundling dependencies (parcel, @parcel/config-default, parcel-resolver-tspaths, html-inline)\n- Creates `.parcelrc` config with path alias support\n- Builds with Parcel (no source maps)\n- Inlines all assets into single HTML using html-inline\n\n### Step 4: Share Artifact with User\n\nFinally, share the bundled HTML file in conversation with the user so they can view it as an artifact.\n\n### Step 5: Testing/Visualizing the Artifact (Optional)\n\nNote: This is a completely optional step. Only perform if necessary or requested.\n\nTo test/visualize the artifact, use available tools (including other Skills or built-in tools like Playwright or Puppeteer). In general, avoid testing the artifact upfront as it adds latency between the request and when the finished artifact can be seen. Test later, after presenting the artifact, if requested or if issues arise.\n\n## Reference\n\n- **shadcn/ui components**: https://ui.shadcn.com/docs/components"
              },
              {
                "name": "webapp-testing",
                "description": "Toolkit for interacting with and testing local web applications using Playwright. Supports verifying frontend functionality, debugging UI behavior, capturing browser screenshots, and viewing browser logs.",
                "path": "skills/webapp-testing/SKILL.md",
                "frontmatter": {
                  "name": "webapp-testing",
                  "description": "Toolkit for interacting with and testing local web applications using Playwright. Supports verifying frontend functionality, debugging UI behavior, capturing browser screenshots, and viewing browser logs.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "# Web Application Testing\n\nTo test local web applications, write native Python Playwright scripts.\n\n**Helper Scripts Available**:\n- `scripts/with_server.py` - Manages server lifecycle (supports multiple servers)\n\n**Always run scripts with `--help` first** to see usage. DO NOT read the source until you try running the script first and find that a customized solution is abslutely necessary. These scripts can be very large and thus pollute your context window. They exist to be called directly as black-box scripts rather than ingested into your context window.\n\n## Decision Tree: Choosing Your Approach\n\n```\nUser task â†’ Is it static HTML?\n    â”œâ”€ Yes â†’ Read HTML file directly to identify selectors\n    â”‚         â”œâ”€ Success â†’ Write Playwright script using selectors\n    â”‚         â””â”€ Fails/Incomplete â†’ Treat as dynamic (below)\n    â”‚\n    â””â”€ No (dynamic webapp) â†’ Is the server already running?\n        â”œâ”€ No â†’ Run: python scripts/with_server.py --help\n        â”‚        Then use the helper + write simplified Playwright script\n        â”‚\n        â””â”€ Yes â†’ Reconnaissance-then-action:\n            1. Navigate and wait for networkidle\n            2. Take screenshot or inspect DOM\n            3. Identify selectors from rendered state\n            4. Execute actions with discovered selectors\n```\n\n## Example: Using with_server.py\n\nTo start a server, run `--help` first, then use the helper:\n\n**Single server:**\n```bash\npython scripts/with_server.py --server \"npm run dev\" --port 5173 -- python your_automation.py\n```\n\n**Multiple servers (e.g., backend + frontend):**\n```bash\npython scripts/with_server.py \\\n  --server \"cd backend && python server.py\" --port 3000 \\\n  --server \"cd frontend && npm run dev\" --port 5173 \\\n  -- python your_automation.py\n```\n\nTo create an automation script, include only Playwright logic (servers are managed automatically):\n```python\nfrom playwright.sync_api import sync_playwright\n\nwith sync_playwright() as p:\n    browser = p.chromium.launch(headless=True) # Always launch chromium in headless mode\n    page = browser.new_page()\n    page.goto('http://localhost:5173') # Server already running and ready\n    page.wait_for_load_state('networkidle') # CRITICAL: Wait for JS to execute\n    # ... your automation logic\n    browser.close()\n```\n\n## Reconnaissance-Then-Action Pattern\n\n1. **Inspect rendered DOM**:\n   ```python\n   page.screenshot(path='/tmp/inspect.png', full_page=True)\n   content = page.content()\n   page.locator('button').all()\n   ```\n\n2. **Identify selectors** from inspection results\n\n3. **Execute actions** using discovered selectors\n\n## Common Pitfall\n\nâŒ **Don't** inspect the DOM before waiting for `networkidle` on dynamic apps\nâœ… **Do** wait for `page.wait_for_load_state('networkidle')` before inspection\n\n## Best Practices\n\n- **Use bundled scripts as black boxes** - To accomplish a task, consider whether one of the scripts available in `scripts/` can help. These scripts handle common, complex workflows reliably without cluttering the context window. Use `--help` to see usage, then invoke directly. \n- Use `sync_playwright()` for synchronous scripts\n- Always close the browser when done\n- Use descriptive selectors: `text=`, `role=`, CSS selectors, or IDs\n- Add appropriate waits: `page.wait_for_selector()` or `page.wait_for_timeout()`\n\n## Reference Files\n\n- **examples/** - Examples showing common patterns:\n  - `element_discovery.py` - Discovering buttons, links, and inputs on a page\n  - `static_html_automation.py` - Using file:// URLs for local HTML\n  - `console_logging.py` - Capturing console logs during automation"
              },
              {
                "name": "xlsx",
                "description": "Comprehensive spreadsheet creation, editing, and analysis with support for formulas, formatting, data analysis, and visualization. When Claude needs to work with spreadsheets (.xlsx, .xlsm, .csv, .tsv, etc) for: (1) Creating new spreadsheets with formulas and formatting, (2) Reading or analyzing data, (3) Modify existing spreadsheets while preserving formulas, (4) Data analysis and visualization in spreadsheets, or (5) Recalculating formulas",
                "path": "skills/xlsx/SKILL.md",
                "frontmatter": {
                  "name": "xlsx",
                  "description": "Comprehensive spreadsheet creation, editing, and analysis with support for formulas, formatting, data analysis, and visualization. When Claude needs to work with spreadsheets (.xlsx, .xlsm, .csv, .tsv, etc) for: (1) Creating new spreadsheets with formulas and formatting, (2) Reading or analyzing data, (3) Modify existing spreadsheets while preserving formulas, (4) Data analysis and visualization in spreadsheets, or (5) Recalculating formulas",
                  "license": "Proprietary. LICENSE.txt has complete terms"
                },
                "content": "# Requirements for Outputs\n\n## All Excel files\n\n### Zero Formula Errors\n- Every Excel model MUST be delivered with ZERO formula errors (#REF!, #DIV/0!, #VALUE!, #N/A, #NAME?)\n\n### Preserve Existing Templates (when updating templates)\n- Study and EXACTLY match existing format, style, and conventions when modifying files\n- Never impose standardized formatting on files with established patterns\n- Existing template conventions ALWAYS override these guidelines\n\n## Financial models\n\n### Color Coding Standards\nUnless otherwise stated by the user or existing template\n\n#### Industry-Standard Color Conventions\n- **Blue text (RGB: 0,0,255)**: Hardcoded inputs, and numbers users will change for scenarios\n- **Black text (RGB: 0,0,0)**: ALL formulas and calculations\n- **Green text (RGB: 0,128,0)**: Links pulling from other worksheets within same workbook\n- **Red text (RGB: 255,0,0)**: External links to other files\n- **Yellow background (RGB: 255,255,0)**: Key assumptions needing attention or cells that need to be updated\n\n### Number Formatting Standards\n\n#### Required Format Rules\n- **Years**: Format as text strings (e.g., \"2024\" not \"2,024\")\n- **Currency**: Use $#,##0 format; ALWAYS specify units in headers (\"Revenue ($mm)\")\n- **Zeros**: Use number formatting to make all zeros \"-\", including percentages (e.g., \"$#,##0;($#,##0);-\")\n- **Percentages**: Default to 0.0% format (one decimal)\n- **Multiples**: Format as 0.0x for valuation multiples (EV/EBITDA, P/E)\n- **Negative numbers**: Use parentheses (123) not minus -123\n\n### Formula Construction Rules\n\n#### Assumptions Placement\n- Place ALL assumptions (growth rates, margins, multiples, etc.) in separate assumption cells\n- Use cell references instead of hardcoded values in formulas\n- Example: Use =B5*(1+$B$6) instead of =B5*1.05\n\n#### Formula Error Prevention\n- Verify all cell references are correct\n- Check for off-by-one errors in ranges\n- Ensure consistent formulas across all projection periods\n- Test with edge cases (zero values, negative numbers)\n- Verify no unintended circular references\n\n#### Documentation Requirements for Hardcodes\n- Comment or in cells beside (if end of table). Format: \"Source: [System/Document], [Date], [Specific Reference], [URL if applicable]\"\n- Examples:\n  - \"Source: Company 10-K, FY2024, Page 45, Revenue Note, [SEC EDGAR URL]\"\n  - \"Source: Company 10-Q, Q2 2025, Exhibit 99.1, [SEC EDGAR URL]\"\n  - \"Source: Bloomberg Terminal, 8/15/2025, AAPL US Equity\"\n  - \"Source: FactSet, 8/20/2025, Consensus Estimates Screen\"\n\n# XLSX creation, editing, and analysis\n\n## Overview\n\nA user may ask you to create, edit, or analyze the contents of an .xlsx file. You have different tools and workflows available for different tasks.\n\n## Important Requirements\n\n**LibreOffice Required for Formula Recalculation**: You can assume LibreOffice is installed for recalculating formula values using the `recalc.py` script. The script automatically configures LibreOffice on first run\n\n## Reading and analyzing data\n\n### Data analysis with pandas\nFor data analysis, visualization, and basic operations, use **pandas** which provides powerful data manipulation capabilities:\n\n```python\nimport pandas as pd\n\n# Read Excel\ndf = pd.read_excel('file.xlsx')  # Default: first sheet\nall_sheets = pd.read_excel('file.xlsx', sheet_name=None)  # All sheets as dict\n\n# Analyze\ndf.head()      # Preview data\ndf.info()      # Column info\ndf.describe()  # Statistics\n\n# Write Excel\ndf.to_excel('output.xlsx', index=False)\n```\n\n## Excel File Workflows\n\n## CRITICAL: Use Formulas, Not Hardcoded Values\n\n**Always use Excel formulas instead of calculating values in Python and hardcoding them.** This ensures the spreadsheet remains dynamic and updateable.\n\n### âŒ WRONG - Hardcoding Calculated Values\n```python\n# Bad: Calculating in Python and hardcoding result\ntotal = df['Sales'].sum()\nsheet['B10'] = total  # Hardcodes 5000\n\n# Bad: Computing growth rate in Python\ngrowth = (df.iloc[-1]['Revenue'] - df.iloc[0]['Revenue']) / df.iloc[0]['Revenue']\nsheet['C5'] = growth  # Hardcodes 0.15\n\n# Bad: Python calculation for average\navg = sum(values) / len(values)\nsheet['D20'] = avg  # Hardcodes 42.5\n```\n\n### âœ… CORRECT - Using Excel Formulas\n```python\n# Good: Let Excel calculate the sum\nsheet['B10'] = '=SUM(B2:B9)'\n\n# Good: Growth rate as Excel formula\nsheet['C5'] = '=(C4-C2)/C2'\n\n# Good: Average using Excel function\nsheet['D20'] = '=AVERAGE(D2:D19)'\n```\n\nThis applies to ALL calculations - totals, percentages, ratios, differences, etc. The spreadsheet should be able to recalculate when source data changes.\n\n## Common Workflow\n1. **Choose tool**: pandas for data, openpyxl for formulas/formatting\n2. **Create/Load**: Create new workbook or load existing file\n3. **Modify**: Add/edit data, formulas, and formatting\n4. **Save**: Write to file\n5. **Recalculate formulas (MANDATORY IF USING FORMULAS)**: Use the recalc.py script\n   ```bash\n   python recalc.py output.xlsx\n   ```\n6. **Verify and fix any errors**: \n   - The script returns JSON with error details\n   - If `status` is `errors_found`, check `error_summary` for specific error types and locations\n   - Fix the identified errors and recalculate again\n   - Common errors to fix:\n     - `#REF!`: Invalid cell references\n     - `#DIV/0!`: Division by zero\n     - `#VALUE!`: Wrong data type in formula\n     - `#NAME?`: Unrecognized formula name\n\n### Creating new Excel files\n\n```python\n# Using openpyxl for formulas and formatting\nfrom openpyxl import Workbook\nfrom openpyxl.styles import Font, PatternFill, Alignment\n\nwb = Workbook()\nsheet = wb.active\n\n# Add data\nsheet['A1'] = 'Hello'\nsheet['B1'] = 'World'\nsheet.append(['Row', 'of', 'data'])\n\n# Add formula\nsheet['B2'] = '=SUM(A1:A10)'\n\n# Formatting\nsheet['A1'].font = Font(bold=True, color='FF0000')\nsheet['A1'].fill = PatternFill('solid', start_color='FFFF00')\nsheet['A1'].alignment = Alignment(horizontal='center')\n\n# Column width\nsheet.column_dimensions['A'].width = 20\n\nwb.save('output.xlsx')\n```\n\n### Editing existing Excel files\n\n```python\n# Using openpyxl to preserve formulas and formatting\nfrom openpyxl import load_workbook\n\n# Load existing file\nwb = load_workbook('existing.xlsx')\nsheet = wb.active  # or wb['SheetName'] for specific sheet\n\n# Working with multiple sheets\nfor sheet_name in wb.sheetnames:\n    sheet = wb[sheet_name]\n    print(f\"Sheet: {sheet_name}\")\n\n# Modify cells\nsheet['A1'] = 'New Value'\nsheet.insert_rows(2)  # Insert row at position 2\nsheet.delete_cols(3)  # Delete column 3\n\n# Add new sheet\nnew_sheet = wb.create_sheet('NewSheet')\nnew_sheet['A1'] = 'Data'\n\nwb.save('modified.xlsx')\n```\n\n## Recalculating formulas\n\nExcel files created or modified by openpyxl contain formulas as strings but not calculated values. Use the provided `recalc.py` script to recalculate formulas:\n\n```bash\npython recalc.py <excel_file> [timeout_seconds]\n```\n\nExample:\n```bash\npython recalc.py output.xlsx 30\n```\n\nThe script:\n- Automatically sets up LibreOffice macro on first run\n- Recalculates all formulas in all sheets\n- Scans ALL cells for Excel errors (#REF!, #DIV/0!, etc.)\n- Returns JSON with detailed error locations and counts\n- Works on both Linux and macOS\n\n## Formula Verification Checklist\n\nQuick checks to ensure formulas work correctly:\n\n### Essential Verification\n- [ ] **Test 2-3 sample references**: Verify they pull correct values before building full model\n- [ ] **Column mapping**: Confirm Excel columns match (e.g., column 64 = BL, not BK)\n- [ ] **Row offset**: Remember Excel rows are 1-indexed (DataFrame row 5 = Excel row 6)\n\n### Common Pitfalls\n- [ ] **NaN handling**: Check for null values with `pd.notna()`\n- [ ] **Far-right columns**: FY data often in columns 50+ \n- [ ] **Multiple matches**: Search all occurrences, not just first\n- [ ] **Division by zero**: Check denominators before using `/` in formulas (#DIV/0!)\n- [ ] **Wrong references**: Verify all cell references point to intended cells (#REF!)\n- [ ] **Cross-sheet references**: Use correct format (Sheet1!A1) for linking sheets\n\n### Formula Testing Strategy\n- [ ] **Start small**: Test formulas on 2-3 cells before applying broadly\n- [ ] **Verify dependencies**: Check all cells referenced in formulas exist\n- [ ] **Test edge cases**: Include zero, negative, and very large values\n\n### Interpreting recalc.py Output\nThe script returns JSON with error details:\n```json\n{\n  \"status\": \"success\",           // or \"errors_found\"\n  \"total_errors\": 0,              // Total error count\n  \"total_formulas\": 42,           // Number of formulas in file\n  \"error_summary\": {              // Only present if errors found\n    \"#REF!\": {\n      \"count\": 2,\n      \"locations\": [\"Sheet1!B5\", \"Sheet1!C10\"]\n    }\n  }\n}\n```\n\n## Best Practices\n\n### Library Selection\n- **pandas**: Best for data analysis, bulk operations, and simple data export\n- **openpyxl**: Best for complex formatting, formulas, and Excel-specific features\n\n### Working with openpyxl\n- Cell indices are 1-based (row=1, column=1 refers to cell A1)\n- Use `data_only=True` to read calculated values: `load_workbook('file.xlsx', data_only=True)`\n- **Warning**: If opened with `data_only=True` and saved, formulas are replaced with values and permanently lost\n- For large files: Use `read_only=True` for reading or `write_only=True` for writing\n- Formulas are preserved but not evaluated - use recalc.py to update values\n\n### Working with pandas\n- Specify data types to avoid inference issues: `pd.read_excel('file.xlsx', dtype={'id': str})`\n- For large files, read specific columns: `pd.read_excel('file.xlsx', usecols=['A', 'C', 'E'])`\n- Handle dates properly: `pd.read_excel('file.xlsx', parse_dates=['date_column'])`\n\n## Code Style Guidelines\n**IMPORTANT**: When generating Python code for Excel operations:\n- Write minimal, concise Python code without unnecessary comments\n- Avoid verbose variable names and redundant operations\n- Avoid unnecessary print statements\n\n**For Excel files themselves**:\n- Add comments to cells with complex formulas or important assumptions\n- Document data sources for hardcoded values\n- Include notes for key calculations and model sections"
              }
            ]
          }
        ]
      }
    },
    {
      "full_name": "anthropics/claude-plugins-official",
      "url": "https://github.com/anthropics/claude-plugins-official",
      "description": "Official, Anthropic-managed directory of high quality Claude Code Plugins.",
      "homepage": "https://code.claude.com/docs/en/plugins",
      "signals": {
        "stars": 3233,
        "forks": 373,
        "pushed_at": "2026-01-12T23:05:15Z",
        "created_at": "2025-11-20T18:36:20Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 22698
        },
        {
          "path": ".github",
          "type": "tree",
          "size": null
        },
        {
          "path": ".github/workflows",
          "type": "tree",
          "size": null
        },
        {
          "path": ".github/workflows/close-external-prs.yml",
          "type": "blob",
          "size": 1660
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 19
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 1761
        },
        {
          "path": "external_plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/asana",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/asana/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/asana/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 276
        },
        {
          "path": "external_plugins/asana/.mcp.json",
          "type": "blob",
          "size": 79
        },
        {
          "path": "external_plugins/context7",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/context7/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/context7/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 262
        },
        {
          "path": "external_plugins/context7/.mcp.json",
          "type": "blob",
          "size": 90
        },
        {
          "path": "external_plugins/firebase",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/firebase/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/firebase/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 281
        },
        {
          "path": "external_plugins/firebase/.mcp.json",
          "type": "blob",
          "size": 97
        },
        {
          "path": "external_plugins/github",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/github/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/github/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 271
        },
        {
          "path": "external_plugins/github/.mcp.json",
          "type": "blob",
          "size": 178
        },
        {
          "path": "external_plugins/gitlab",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/gitlab/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/gitlab/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 254
        },
        {
          "path": "external_plugins/gitlab/.mcp.json",
          "type": "blob",
          "size": 85
        },
        {
          "path": "external_plugins/greptile",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/greptile/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/greptile/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 357
        },
        {
          "path": "external_plugins/greptile/.mcp.json",
          "type": "blob",
          "size": 162
        },
        {
          "path": "external_plugins/greptile/README.md",
          "type": "blob",
          "size": 1914
        },
        {
          "path": "external_plugins/laravel-boost",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/laravel-boost/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/laravel-boost/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 295
        },
        {
          "path": "external_plugins/laravel-boost/.mcp.json",
          "type": "blob",
          "size": 88
        },
        {
          "path": "external_plugins/linear",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/linear/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/linear/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 279
        },
        {
          "path": "external_plugins/linear/.mcp.json",
          "type": "blob",
          "size": 82
        },
        {
          "path": "external_plugins/playwright",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/playwright/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/playwright/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 295
        },
        {
          "path": "external_plugins/playwright/.mcp.json",
          "type": "blob",
          "size": 87
        },
        {
          "path": "external_plugins/serena",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/serena/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/serena/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 254
        },
        {
          "path": "external_plugins/serena/.mcp.json",
          "type": "blob",
          "size": 137
        },
        {
          "path": "external_plugins/slack",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/slack/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/slack/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 270
        },
        {
          "path": "external_plugins/slack/.mcp.json",
          "type": "blob",
          "size": 79
        },
        {
          "path": "external_plugins/stripe",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/stripe/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/stripe/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 353
        },
        {
          "path": "external_plugins/stripe/.mcp.json",
          "type": "blob",
          "size": 108
        },
        {
          "path": "external_plugins/stripe/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/stripe/commands/explain-error.md",
          "type": "blob",
          "size": 823
        },
        {
          "path": "external_plugins/stripe/commands/test-cards.md",
          "type": "blob",
          "size": 1015
        },
        {
          "path": "external_plugins/stripe/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/stripe/skills/stripe-best-practices",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/stripe/skills/stripe-best-practices/SKILL.md",
          "type": "blob",
          "size": 5502
        },
        {
          "path": "external_plugins/supabase",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/supabase/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "external_plugins/supabase/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 280
        },
        {
          "path": "external_plugins/supabase/.mcp.json",
          "type": "blob",
          "size": 86
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/agent-sdk-dev",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/agent-sdk-dev/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/agent-sdk-dev/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 167
        },
        {
          "path": "plugins/agent-sdk-dev/README.md",
          "type": "blob",
          "size": 6397
        },
        {
          "path": "plugins/agent-sdk-dev/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/agent-sdk-dev/agents/agent-sdk-verifier-py.md",
          "type": "blob",
          "size": 5206
        },
        {
          "path": "plugins/agent-sdk-dev/agents/agent-sdk-verifier-ts.md",
          "type": "blob",
          "size": 5419
        },
        {
          "path": "plugins/agent-sdk-dev/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/agent-sdk-dev/commands/new-sdk-app.md",
          "type": "blob",
          "size": 7846
        },
        {
          "path": "plugins/clangd-lsp",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/clangd-lsp/README.md",
          "type": "blob",
          "size": 780
        },
        {
          "path": "plugins/code-review",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-review/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-review/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 234
        },
        {
          "path": "plugins/code-review/README.md",
          "type": "blob",
          "size": 7321
        },
        {
          "path": "plugins/code-review/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-review/commands/code-review.md",
          "type": "blob",
          "size": 7422
        },
        {
          "path": "plugins/code-simplifier",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-simplifier/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-simplifier/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 271
        },
        {
          "path": "plugins/code-simplifier/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-simplifier/agents/code-simplifier.md",
          "type": "blob",
          "size": 3129
        },
        {
          "path": "plugins/commit-commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/commit-commands/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/commit-commands/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 236
        },
        {
          "path": "plugins/commit-commands/README.md",
          "type": "blob",
          "size": 5908
        },
        {
          "path": "plugins/commit-commands/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/commit-commands/commands/clean_gone.md",
          "type": "blob",
          "size": 1865
        },
        {
          "path": "plugins/commit-commands/commands/commit-push-pr.md",
          "type": "blob",
          "size": 796
        },
        {
          "path": "plugins/commit-commands/commands/commit.md",
          "type": "blob",
          "size": 624
        },
        {
          "path": "plugins/csharp-lsp",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/csharp-lsp/README.md",
          "type": "blob",
          "size": 486
        },
        {
          "path": "plugins/example-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/example-plugin/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/example-plugin/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 270
        },
        {
          "path": "plugins/example-plugin/.mcp.json",
          "type": "blob",
          "size": 91
        },
        {
          "path": "plugins/example-plugin/README.md",
          "type": "blob",
          "size": 1311
        },
        {
          "path": "plugins/example-plugin/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/example-plugin/commands/example-command.md",
          "type": "blob",
          "size": 943
        },
        {
          "path": "plugins/example-plugin/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/example-plugin/skills/example-skill",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/example-plugin/skills/example-skill/SKILL.md",
          "type": "blob",
          "size": 2725
        },
        {
          "path": "plugins/explanatory-output-style",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/explanatory-output-style/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/explanatory-output-style/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 268
        },
        {
          "path": "plugins/explanatory-output-style/README.md",
          "type": "blob",
          "size": 2470
        },
        {
          "path": "plugins/explanatory-output-style/hooks-handlers",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/explanatory-output-style/hooks-handlers/session-start.sh",
          "type": "blob",
          "size": 1468
        },
        {
          "path": "plugins/explanatory-output-style/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/explanatory-output-style/hooks/hooks.json",
          "type": "blob",
          "size": 314
        },
        {
          "path": "plugins/feature-dev",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/feature-dev/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/feature-dev/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 262
        },
        {
          "path": "plugins/feature-dev/README.md",
          "type": "blob",
          "size": 11697
        },
        {
          "path": "plugins/feature-dev/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/feature-dev/agents/code-architect.md",
          "type": "blob",
          "size": 2259
        },
        {
          "path": "plugins/feature-dev/agents/code-explorer.md",
          "type": "blob",
          "size": 2115
        },
        {
          "path": "plugins/feature-dev/agents/code-reviewer.md",
          "type": "blob",
          "size": 2994
        },
        {
          "path": "plugins/feature-dev/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/feature-dev/commands/feature-dev.md",
          "type": "blob",
          "size": 5097
        },
        {
          "path": "plugins/frontend-design",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/frontend-design/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/frontend-design/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 180
        },
        {
          "path": "plugins/frontend-design/README.md",
          "type": "blob",
          "size": 977
        },
        {
          "path": "plugins/frontend-design/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/frontend-design/skills/frontend-design",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/frontend-design/skills/frontend-design/SKILL.md",
          "type": "blob",
          "size": 4274
        },
        {
          "path": "plugins/gopls-lsp",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/gopls-lsp/README.md",
          "type": "blob",
          "size": 473
        },
        {
          "path": "plugins/hookify",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/hookify/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/hookify/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 210
        },
        {
          "path": "plugins/hookify/.gitignore",
          "type": "blob",
          "size": 291
        },
        {
          "path": "plugins/hookify/README.md",
          "type": "blob",
          "size": 7710
        },
        {
          "path": "plugins/hookify/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/hookify/agents/conversation-analyzer.md",
          "type": "blob",
          "size": 5478
        },
        {
          "path": "plugins/hookify/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/hookify/commands/configure.md",
          "type": "blob",
          "size": 2863
        },
        {
          "path": "plugins/hookify/commands/help.md",
          "type": "blob",
          "size": 4624
        },
        {
          "path": "plugins/hookify/commands/hookify.md",
          "type": "blob",
          "size": 7667
        },
        {
          "path": "plugins/hookify/commands/list.md",
          "type": "blob",
          "size": 2020
        },
        {
          "path": "plugins/hookify/core",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/hookify/core/__init__.py",
          "type": "blob",
          "size": null
        },
        {
          "path": "plugins/hookify/core/config_loader.py",
          "type": "blob",
          "size": 9690
        },
        {
          "path": "plugins/hookify/core/rule_engine.py",
          "type": "blob",
          "size": 10711
        },
        {
          "path": "plugins/hookify/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/hookify/examples/console-log-warning.local.md",
          "type": "blob",
          "size": 315
        },
        {
          "path": "plugins/hookify/examples/dangerous-rm.local.md",
          "type": "blob",
          "size": 278
        },
        {
          "path": "plugins/hookify/examples/require-tests-stop.local.md",
          "type": "blob",
          "size": 500
        },
        {
          "path": "plugins/hookify/examples/sensitive-files-warning.local.md",
          "type": "blob",
          "size": 421
        },
        {
          "path": "plugins/hookify/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/hookify/hooks/__init__.py",
          "type": "blob",
          "size": null
        },
        {
          "path": "plugins/hookify/hooks/hooks.json",
          "type": "blob",
          "size": 1020
        },
        {
          "path": "plugins/hookify/hooks/posttooluse.py",
          "type": "blob",
          "size": 1622
        },
        {
          "path": "plugins/hookify/hooks/pretooluse.py",
          "type": "blob",
          "size": 1852
        },
        {
          "path": "plugins/hookify/hooks/stop.py",
          "type": "blob",
          "size": 1403
        },
        {
          "path": "plugins/hookify/hooks/userpromptsubmit.py",
          "type": "blob",
          "size": 1389
        },
        {
          "path": "plugins/hookify/matchers",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/hookify/matchers/__init__.py",
          "type": "blob",
          "size": null
        },
        {
          "path": "plugins/hookify/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/hookify/skills/writing-rules",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/hookify/skills/writing-rules/SKILL.md",
          "type": "blob",
          "size": 8423
        },
        {
          "path": "plugins/hookify/utils",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/hookify/utils/__init__.py",
          "type": "blob",
          "size": null
        },
        {
          "path": "plugins/jdtls-lsp",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/jdtls-lsp/README.md",
          "type": "blob",
          "size": 811
        },
        {
          "path": "plugins/kotlin-lsp",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/kotlin-lsp/README.md",
          "type": "blob",
          "size": 306
        },
        {
          "path": "plugins/learning-output-style",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/learning-output-style/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/learning-output-style/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 273
        },
        {
          "path": "plugins/learning-output-style/README.md",
          "type": "blob",
          "size": 4687
        },
        {
          "path": "plugins/learning-output-style/hooks-handlers",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/learning-output-style/hooks-handlers/session-start.sh",
          "type": "blob",
          "size": 3564
        },
        {
          "path": "plugins/learning-output-style/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/learning-output-style/hooks/hooks.json",
          "type": "blob",
          "size": 311
        },
        {
          "path": "plugins/lua-lsp",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lua-lsp/README.md",
          "type": "blob",
          "size": 705
        },
        {
          "path": "plugins/php-lsp",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/php-lsp/README.md",
          "type": "blob",
          "size": 436
        },
        {
          "path": "plugins/plugin-dev",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/README.md",
          "type": "blob",
          "size": 14590
        },
        {
          "path": "plugins/plugin-dev/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/agents/agent-creator.md",
          "type": "blob",
          "size": 7437
        },
        {
          "path": "plugins/plugin-dev/agents/plugin-validator.md",
          "type": "blob",
          "size": 6623
        },
        {
          "path": "plugins/plugin-dev/agents/skill-reviewer.md",
          "type": "blob",
          "size": 6079
        },
        {
          "path": "plugins/plugin-dev/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/commands/create-plugin.md",
          "type": "blob",
          "size": 14950
        },
        {
          "path": "plugins/plugin-dev/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/agent-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/agent-development/SKILL.md",
          "type": "blob",
          "size": 10430
        },
        {
          "path": "plugins/plugin-dev/skills/agent-development/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/agent-development/examples/agent-creation-prompt.md",
          "type": "blob",
          "size": 9390
        },
        {
          "path": "plugins/plugin-dev/skills/agent-development/examples/complete-agent-examples.md",
          "type": "blob",
          "size": 14117
        },
        {
          "path": "plugins/plugin-dev/skills/agent-development/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/agent-development/references/agent-creation-system-prompt.md",
          "type": "blob",
          "size": 8879
        },
        {
          "path": "plugins/plugin-dev/skills/agent-development/references/system-prompt-design.md",
          "type": "blob",
          "size": 9998
        },
        {
          "path": "plugins/plugin-dev/skills/agent-development/references/triggering-examples.md",
          "type": "blob",
          "size": 11613
        },
        {
          "path": "plugins/plugin-dev/skills/agent-development/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/agent-development/scripts/validate-agent.sh",
          "type": "blob",
          "size": 5796
        },
        {
          "path": "plugins/plugin-dev/skills/command-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/README.md",
          "type": "blob",
          "size": 7651
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/SKILL.md",
          "type": "blob",
          "size": 18941
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/examples/plugin-commands.md",
          "type": "blob",
          "size": 13989
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/examples/simple-commands.md",
          "type": "blob",
          "size": 8675
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/references/advanced-workflows.md",
          "type": "blob",
          "size": 13618
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/references/documentation-patterns.md",
          "type": "blob",
          "size": 14971
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/references/frontmatter-reference.md",
          "type": "blob",
          "size": 9162
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/references/interactive-commands.md",
          "type": "blob",
          "size": 20980
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/references/marketplace-considerations.md",
          "type": "blob",
          "size": 16437
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/references/plugin-features-reference.md",
          "type": "blob",
          "size": 14622
        },
        {
          "path": "plugins/plugin-dev/skills/command-development/references/testing-strategies.md",
          "type": "blob",
          "size": 14803
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/SKILL.md",
          "type": "blob",
          "size": 16246
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/examples/load-context.sh",
          "type": "blob",
          "size": 1690
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/examples/validate-bash.sh",
          "type": "blob",
          "size": 1304
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/examples/validate-write.sh",
          "type": "blob",
          "size": 1222
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/references/advanced.md",
          "type": "blob",
          "size": 10148
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/references/migration.md",
          "type": "blob",
          "size": 8299
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/references/patterns.md",
          "type": "blob",
          "size": 7144
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/scripts/README.md",
          "type": "blob",
          "size": 3677
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/scripts/hook-linter.sh",
          "type": "blob",
          "size": 4200
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/scripts/test-hook.sh",
          "type": "blob",
          "size": 5336
        },
        {
          "path": "plugins/plugin-dev/skills/hook-development/scripts/validate-hook-schema.sh",
          "type": "blob",
          "size": 5081
        },
        {
          "path": "plugins/plugin-dev/skills/mcp-integration",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/mcp-integration/SKILL.md",
          "type": "blob",
          "size": 12519
        },
        {
          "path": "plugins/plugin-dev/skills/mcp-integration/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/mcp-integration/examples/http-server.json",
          "type": "blob",
          "size": 502
        },
        {
          "path": "plugins/plugin-dev/skills/mcp-integration/examples/sse-server.json",
          "type": "blob",
          "size": 413
        },
        {
          "path": "plugins/plugin-dev/skills/mcp-integration/examples/stdio-server.json",
          "type": "blob",
          "size": 686
        },
        {
          "path": "plugins/plugin-dev/skills/mcp-integration/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/mcp-integration/references/authentication.md",
          "type": "blob",
          "size": 10196
        },
        {
          "path": "plugins/plugin-dev/skills/mcp-integration/references/server-types.md",
          "type": "blob",
          "size": 10613
        },
        {
          "path": "plugins/plugin-dev/skills/mcp-integration/references/tool-usage.md",
          "type": "blob",
          "size": 11674
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings/SKILL.md",
          "type": "blob",
          "size": 12097
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings/examples/create-settings-command.md",
          "type": "blob",
          "size": 2177
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings/examples/example-settings.md",
          "type": "blob",
          "size": 2930
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings/examples/read-settings-hook.sh",
          "type": "blob",
          "size": 2205
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings/references/parsing-techniques.md",
          "type": "blob",
          "size": 11513
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings/references/real-world-examples.md",
          "type": "blob",
          "size": 9492
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings/scripts/parse-frontmatter.sh",
          "type": "blob",
          "size": 1269
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-settings/scripts/validate-settings.sh",
          "type": "blob",
          "size": 2712
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-structure",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-structure/README.md",
          "type": "blob",
          "size": 3210
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-structure/SKILL.md",
          "type": "blob",
          "size": 13796
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-structure/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-structure/examples/advanced-plugin.md",
          "type": "blob",
          "size": 18746
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-structure/examples/minimal-plugin.md",
          "type": "blob",
          "size": 1731
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-structure/examples/standard-plugin.md",
          "type": "blob",
          "size": 13310
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-structure/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-structure/references/component-patterns.md",
          "type": "blob",
          "size": 12086
        },
        {
          "path": "plugins/plugin-dev/skills/plugin-structure/references/manifest-reference.md",
          "type": "blob",
          "size": 12061
        },
        {
          "path": "plugins/plugin-dev/skills/skill-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/skill-development/SKILL.md",
          "type": "blob",
          "size": 22825
        },
        {
          "path": "plugins/plugin-dev/skills/skill-development/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-dev/skills/skill-development/references/skill-creator-original.md",
          "type": "blob",
          "size": 11547
        },
        {
          "path": "plugins/pr-review-toolkit",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/pr-review-toolkit/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/pr-review-toolkit/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 266
        },
        {
          "path": "plugins/pr-review-toolkit/README.md",
          "type": "blob",
          "size": 7528
        },
        {
          "path": "plugins/pr-review-toolkit/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/pr-review-toolkit/agents/code-reviewer.md",
          "type": "blob",
          "size": 3985
        },
        {
          "path": "plugins/pr-review-toolkit/agents/code-simplifier.md",
          "type": "blob",
          "size": 5230
        },
        {
          "path": "plugins/pr-review-toolkit/agents/comment-analyzer.md",
          "type": "blob",
          "size": 5725
        },
        {
          "path": "plugins/pr-review-toolkit/agents/pr-test-analyzer.md",
          "type": "blob",
          "size": 4985
        },
        {
          "path": "plugins/pr-review-toolkit/agents/silent-failure-hunter.md",
          "type": "blob",
          "size": 7807
        },
        {
          "path": "plugins/pr-review-toolkit/agents/type-design-analyzer.md",
          "type": "blob",
          "size": 5368
        },
        {
          "path": "plugins/pr-review-toolkit/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/pr-review-toolkit/commands/review-pr.md",
          "type": "blob",
          "size": 4997
        },
        {
          "path": "plugins/pyright-lsp",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/pyright-lsp/README.md",
          "type": "blob",
          "size": 564
        },
        {
          "path": "plugins/ralph-loop",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ralph-loop/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ralph-loop/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 321
        },
        {
          "path": "plugins/ralph-loop/README.md",
          "type": "blob",
          "size": 5259
        },
        {
          "path": "plugins/ralph-loop/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ralph-loop/commands/cancel-ralph.md",
          "type": "blob",
          "size": 738
        },
        {
          "path": "plugins/ralph-loop/commands/help.md",
          "type": "blob",
          "size": 3227
        },
        {
          "path": "plugins/ralph-loop/commands/ralph-loop.md",
          "type": "blob",
          "size": 916
        },
        {
          "path": "plugins/ralph-loop/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ralph-loop/hooks/hooks.json",
          "type": "blob",
          "size": 282
        },
        {
          "path": "plugins/ralph-loop/hooks/stop-hook.sh",
          "type": "blob",
          "size": 6562
        },
        {
          "path": "plugins/ralph-loop/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ralph-loop/scripts/setup-ralph-loop.sh",
          "type": "blob",
          "size": 7002
        },
        {
          "path": "plugins/rust-analyzer-lsp",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-analyzer-lsp/README.md",
          "type": "blob",
          "size": 701
        },
        {
          "path": "plugins/security-guidance",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/security-guidance/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/security-guidance/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 280
        },
        {
          "path": "plugins/security-guidance/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/security-guidance/hooks/hooks.json",
          "type": "blob",
          "size": 382
        },
        {
          "path": "plugins/security-guidance/hooks/security_reminder_hook.py",
          "type": "blob",
          "size": 10767
        },
        {
          "path": "plugins/swift-lsp",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/swift-lsp/README.md",
          "type": "blob",
          "size": 602
        },
        {
          "path": "plugins/typescript-lsp",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/typescript-lsp/README.md",
          "type": "blob",
          "size": 692
        }
      ],
      "marketplace": {
        "name": "claude-plugins-official",
        "version": null,
        "description": "Directory of popular Claude Code extensions including development tools, productivity plugins, and MCP integrations",
        "owner_info": {
          "name": "Anthropic",
          "email": "support@anthropic.com"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "typescript-lsp",
            "description": "TypeScript/JavaScript language server for enhanced code intelligence",
            "source": "./plugins/typescript-lsp",
            "category": "development",
            "version": "1.0.0",
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install typescript-lsp@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "pyright-lsp",
            "description": "Python language server (Pyright) for type checking and code intelligence",
            "source": "./plugins/pyright-lsp",
            "category": "development",
            "version": "1.0.0",
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install pyright-lsp@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "gopls-lsp",
            "description": "Go language server for code intelligence and refactoring",
            "source": "./plugins/gopls-lsp",
            "category": "development",
            "version": "1.0.0",
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install gopls-lsp@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "rust-analyzer-lsp",
            "description": "Rust language server for code intelligence and analysis",
            "source": "./plugins/rust-analyzer-lsp",
            "category": "development",
            "version": "1.0.0",
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install rust-analyzer-lsp@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "clangd-lsp",
            "description": "C/C++ language server (clangd) for code intelligence",
            "source": "./plugins/clangd-lsp",
            "category": "development",
            "version": "1.0.0",
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install clangd-lsp@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "php-lsp",
            "description": "PHP language server (Intelephense) for code intelligence",
            "source": "./plugins/php-lsp",
            "category": "development",
            "version": "1.0.0",
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install php-lsp@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "swift-lsp",
            "description": "Swift language server (SourceKit-LSP) for code intelligence",
            "source": "./plugins/swift-lsp",
            "category": "development",
            "version": "1.0.0",
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install swift-lsp@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "kotlin-lsp",
            "description": "Kotlin language server for code intelligence",
            "source": "./plugins/kotlin-lsp",
            "category": "development",
            "version": "1.0.0",
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install kotlin-lsp@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "csharp-lsp",
            "description": "C# language server for code intelligence",
            "source": "./plugins/csharp-lsp",
            "category": "development",
            "version": "1.0.0",
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install csharp-lsp@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "jdtls-lsp",
            "description": "Java language server (Eclipse JDT.LS) for code intelligence",
            "source": "./plugins/jdtls-lsp",
            "category": "development",
            "version": "1.0.0",
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install jdtls-lsp@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "lua-lsp",
            "description": "Lua language server for code intelligence",
            "source": "./plugins/lua-lsp",
            "category": "development",
            "version": "1.0.0",
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install lua-lsp@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "agent-sdk-dev",
            "description": "Development kit for working with the Claude Agent SDK",
            "source": "./plugins/agent-sdk-dev",
            "category": "development",
            "version": null,
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install agent-sdk-dev@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [
              {
                "name": "/new-sdk-app",
                "description": "Create and setup a new Claude Agent SDK application",
                "path": "plugins/agent-sdk-dev/commands/new-sdk-app.md",
                "frontmatter": {
                  "description": "Create and setup a new Claude Agent SDK application",
                  "argument-hint": [
                    "project-name"
                  ]
                },
                "content": "You are tasked with helping the user create a new Claude Agent SDK application. Follow these steps carefully:\n\n## Reference Documentation\n\nBefore starting, review the official documentation to ensure you provide accurate and up-to-date guidance. Use WebFetch to read these pages:\n\n1. **Start with the overview**: https://docs.claude.com/en/api/agent-sdk/overview\n2. **Based on the user's language choice, read the appropriate SDK reference**:\n   - TypeScript: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Python: https://docs.claude.com/en/api/agent-sdk/python\n3. **Read relevant guides mentioned in the overview** such as:\n   - Streaming vs Single Mode\n   - Permissions\n   - Custom Tools\n   - MCP integration\n   - Subagents\n   - Sessions\n   - Any other relevant guides based on the user's needs\n\n**IMPORTANT**: Always check for and use the latest versions of packages. Use WebSearch or WebFetch to verify current versions before installation.\n\n## Gather Requirements\n\nIMPORTANT: Ask these questions one at a time. Wait for the user's response before asking the next question. This makes it easier for the user to respond.\n\nAsk the questions in this order (skip any that the user has already provided via arguments):\n\n1. **Language** (ask first): \"Would you like to use TypeScript or Python?\"\n\n   - Wait for response before continuing\n\n2. **Project name** (ask second): \"What would you like to name your project?\"\n\n   - If $ARGUMENTS is provided, use that as the project name and skip this question\n   - Wait for response before continuing\n\n3. **Agent type** (ask third, but skip if #2 was sufficiently detailed): \"What kind of agent are you building? Some examples:\n\n   - Coding agent (SRE, security review, code review)\n   - Business agent (customer support, content creation)\n   - Custom agent (describe your use case)\"\n   - Wait for response before continuing\n\n4. **Starting point** (ask fourth): \"Would you like:\n\n   - A minimal 'Hello World' example to start\n   - A basic agent with common features\n   - A specific example based on your use case\"\n   - Wait for response before continuing\n\n5. **Tooling choice** (ask fifth): Let the user know what tools you'll use, and confirm with them that these are the tools they want to use (for example, they may prefer pnpm or bun over npm). Respect the user's preferences when executing on the requirements.\n\nAfter all questions are answered, proceed to create the setup plan.\n\n## Setup Plan\n\nBased on the user's answers, create a plan that includes:\n\n1. **Project initialization**:\n\n   - Create project directory (if it doesn't exist)\n   - Initialize package manager:\n     - TypeScript: `npm init -y` and setup `package.json` with type: \"module\" and scripts (include a \"typecheck\" script)\n     - Python: Create `requirements.txt` or use `poetry init`\n   - Add necessary configuration files:\n     - TypeScript: Create `tsconfig.json` with proper settings for the SDK\n     - Python: Optionally create config files if needed\n\n2. **Check for Latest Versions**:\n\n   - BEFORE installing, use WebSearch or check npm/PyPI to find the latest version\n   - For TypeScript: Check https://www.npmjs.com/package/@anthropic-ai/claude-agent-sdk\n   - For Python: Check https://pypi.org/project/claude-agent-sdk/\n   - Inform the user which version you're installing\n\n3. **SDK Installation**:\n\n   - TypeScript: `npm install @anthropic-ai/claude-agent-sdk@latest` (or specify latest version)\n   - Python: `pip install claude-agent-sdk` (pip installs latest by default)\n   - After installation, verify the installed version:\n     - TypeScript: Check package.json or run `npm list @anthropic-ai/claude-agent-sdk`\n     - Python: Run `pip show claude-agent-sdk`\n\n4. **Create starter files**:\n\n   - TypeScript: Create an `index.ts` or `src/index.ts` with a basic query example\n   - Python: Create a `main.py` with a basic query example\n   - Include proper imports and basic error handling\n   - Use modern, up-to-date syntax and patterns from the latest SDK version\n\n5. **Environment setup**:\n\n   - Create a `.env.example` file with `ANTHROPIC_API_KEY=your_api_key_here`\n   - Add `.env` to `.gitignore`\n   - Explain how to get an API key from https://console.anthropic.com/\n\n6. **Optional: Create .claude directory structure**:\n   - Offer to create `.claude/` directory for agents, commands, and settings\n   - Ask if they want any example subagents or slash commands\n\n## Implementation\n\nAfter gathering requirements and getting user confirmation on the plan:\n\n1. Check for latest package versions using WebSearch or WebFetch\n2. Execute the setup steps\n3. Create all necessary files\n4. Install dependencies (always use latest stable versions)\n5. Verify installed versions and inform the user\n6. Create a working example based on their agent type\n7. Add helpful comments in the code explaining what each part does\n8. **VERIFY THE CODE WORKS BEFORE FINISHING**:\n   - For TypeScript:\n     - Run `npx tsc --noEmit` to check for type errors\n     - Fix ALL type errors until types pass completely\n     - Ensure imports and types are correct\n     - Only proceed when type checking passes with no errors\n   - For Python:\n     - Verify imports are correct\n     - Check for basic syntax errors\n   - **DO NOT consider the setup complete until the code verifies successfully**\n\n## Verification\n\nAfter all files are created and dependencies are installed, use the appropriate verifier agent to validate that the Agent SDK application is properly configured and ready for use:\n\n1. **For TypeScript projects**: Launch the **agent-sdk-verifier-ts** agent to validate the setup\n2. **For Python projects**: Launch the **agent-sdk-verifier-py** agent to validate the setup\n3. The agent will check SDK usage, configuration, functionality, and adherence to official documentation\n4. Review the verification report and address any issues\n\n## Getting Started Guide\n\nOnce setup is complete and verified, provide the user with:\n\n1. **Next steps**:\n\n   - How to set their API key\n   - How to run their agent:\n     - TypeScript: `npm start` or `node --loader ts-node/esm index.ts`\n     - Python: `python main.py`\n\n2. **Useful resources**:\n\n   - Link to TypeScript SDK reference: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Link to Python SDK reference: https://docs.claude.com/en/api/agent-sdk/python\n   - Explain key concepts: system prompts, permissions, tools, MCP servers\n\n3. **Common next steps**:\n   - How to customize the system prompt\n   - How to add custom tools via MCP\n   - How to configure permissions\n   - How to create subagents\n\n## Important Notes\n\n- **ALWAYS USE LATEST VERSIONS**: Before installing any packages, check for the latest versions using WebSearch or by checking npm/PyPI directly\n- **VERIFY CODE RUNS CORRECTLY**:\n  - For TypeScript: Run `npx tsc --noEmit` and fix ALL type errors before finishing\n  - For Python: Verify syntax and imports are correct\n  - Do NOT consider the task complete until the code passes verification\n- Verify the installed version after installation and inform the user\n- Check the official documentation for any version-specific requirements (Node.js version, Python version, etc.)\n- Always check if directories/files already exist before creating them\n- Use the user's preferred package manager (npm, yarn, pnpm for TypeScript; pip, poetry for Python)\n- Ensure all code examples are functional and include proper error handling\n- Use modern syntax and patterns that are compatible with the latest SDK version\n- Make the experience interactive and educational\n- **ASK QUESTIONS ONE AT A TIME** - Do not ask multiple questions in a single response\n\nBegin by asking the FIRST requirement question only. Wait for the user's answer before proceeding to the next question."
              }
            ],
            "skills": []
          },
          {
            "name": "pr-review-toolkit",
            "description": "Comprehensive PR review agents specializing in comments, tests, error handling, type design, code quality, and code simplification",
            "source": "./plugins/pr-review-toolkit",
            "category": "productivity",
            "version": null,
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install pr-review-toolkit@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [
              {
                "name": "/review-pr",
                "description": "Comprehensive PR review using specialized agents",
                "path": "plugins/pr-review-toolkit/commands/review-pr.md",
                "frontmatter": {
                  "description": "Comprehensive PR review using specialized agents",
                  "argument-hint": "[review-aspects]",
                  "allowed-tools": [
                    "Bash",
                    "Glob",
                    "Grep",
                    "Read",
                    "Task"
                  ]
                },
                "content": "# Comprehensive PR Review\n\nRun a comprehensive pull request review using multiple specialized agents, each focusing on a different aspect of code quality.\n\n**Review Aspects (optional):** \"$ARGUMENTS\"\n\n## Review Workflow:\n\n1. **Determine Review Scope**\n   - Check git status to identify changed files\n   - Parse arguments to see if user requested specific review aspects\n   - Default: Run all applicable reviews\n\n2. **Available Review Aspects:**\n\n   - **comments** - Analyze code comment accuracy and maintainability\n   - **tests** - Review test coverage quality and completeness\n   - **errors** - Check error handling for silent failures\n   - **types** - Analyze type design and invariants (if new types added)\n   - **code** - General code review for project guidelines\n   - **simplify** - Simplify code for clarity and maintainability\n   - **all** - Run all applicable reviews (default)\n\n3. **Identify Changed Files**\n   - Run `git diff --name-only` to see modified files\n   - Check if PR already exists: `gh pr view`\n   - Identify file types and what reviews apply\n\n4. **Determine Applicable Reviews**\n\n   Based on changes:\n   - **Always applicable**: code-reviewer (general quality)\n   - **If test files changed**: pr-test-analyzer\n   - **If comments/docs added**: comment-analyzer\n   - **If error handling changed**: silent-failure-hunter\n   - **If types added/modified**: type-design-analyzer\n   - **After passing review**: code-simplifier (polish and refine)\n\n5. **Launch Review Agents**\n\n   **Sequential approach** (one at a time):\n   - Easier to understand and act on\n   - Each report is complete before next\n   - Good for interactive review\n\n   **Parallel approach** (user can request):\n   - Launch all agents simultaneously\n   - Faster for comprehensive review\n   - Results come back together\n\n6. **Aggregate Results**\n\n   After agents complete, summarize:\n   - **Critical Issues** (must fix before merge)\n   - **Important Issues** (should fix)\n   - **Suggestions** (nice to have)\n   - **Positive Observations** (what's good)\n\n7. **Provide Action Plan**\n\n   Organize findings:\n   ```markdown\n   # PR Review Summary\n\n   ## Critical Issues (X found)\n   - [agent-name]: Issue description [file:line]\n\n   ## Important Issues (X found)\n   - [agent-name]: Issue description [file:line]\n\n   ## Suggestions (X found)\n   - [agent-name]: Suggestion [file:line]\n\n   ## Strengths\n   - What's well-done in this PR\n\n   ## Recommended Action\n   1. Fix critical issues first\n   2. Address important issues\n   3. Consider suggestions\n   4. Re-run review after fixes\n   ```\n\n## Usage Examples:\n\n**Full review (default):**\n```\n/pr-review-toolkit:review-pr\n```\n\n**Specific aspects:**\n```\n/pr-review-toolkit:review-pr tests errors\n# Reviews only test coverage and error handling\n\n/pr-review-toolkit:review-pr comments\n# Reviews only code comments\n\n/pr-review-toolkit:review-pr simplify\n# Simplifies code after passing review\n```\n\n**Parallel review:**\n```\n/pr-review-toolkit:review-pr all parallel\n# Launches all agents in parallel\n```\n\n## Agent Descriptions:\n\n**comment-analyzer**:\n- Verifies comment accuracy vs code\n- Identifies comment rot\n- Checks documentation completeness\n\n**pr-test-analyzer**:\n- Reviews behavioral test coverage\n- Identifies critical gaps\n- Evaluates test quality\n\n**silent-failure-hunter**:\n- Finds silent failures\n- Reviews catch blocks\n- Checks error logging\n\n**type-design-analyzer**:\n- Analyzes type encapsulation\n- Reviews invariant expression\n- Rates type design quality\n\n**code-reviewer**:\n- Checks CLAUDE.md compliance\n- Detects bugs and issues\n- Reviews general code quality\n\n**code-simplifier**:\n- Simplifies complex code\n- Improves clarity and readability\n- Applies project standards\n- Preserves functionality\n\n## Tips:\n\n- **Run early**: Before creating PR, not after\n- **Focus on changes**: Agents analyze git diff by default\n- **Address critical first**: Fix high-priority issues before lower priority\n- **Re-run after fixes**: Verify issues are resolved\n- **Use specific reviews**: Target specific aspects when you know the concern\n\n## Workflow Integration:\n\n**Before committing:**\n```\n1. Write code\n2. Run: /pr-review-toolkit:review-pr code errors\n3. Fix any critical issues\n4. Commit\n```\n\n**Before creating PR:**\n```\n1. Stage all changes\n2. Run: /pr-review-toolkit:review-pr all\n3. Address all critical and important issues\n4. Run specific reviews again to verify\n5. Create PR\n```\n\n**After PR feedback:**\n```\n1. Make requested changes\n2. Run targeted reviews based on feedback\n3. Verify issues are resolved\n4. Push updates\n```\n\n## Notes:\n\n- Agents run autonomously and return detailed reports\n- Each agent focuses on its specialty for deep analysis\n- Results are actionable with specific file:line references\n- Agents use appropriate models for their complexity\n- All agents available in `/agents` list"
              }
            ],
            "skills": []
          },
          {
            "name": "commit-commands",
            "description": "Commands for git commit workflows including commit, push, and PR creation",
            "source": "./plugins/commit-commands",
            "category": "productivity",
            "version": null,
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install commit-commands@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [
              {
                "name": "/clean_gone",
                "description": "Cleans up all git branches marked as [gone] (branches that have been deleted on the remote but still exist locally), including removing associated worktrees.",
                "path": "plugins/commit-commands/commands/clean_gone.md",
                "frontmatter": {
                  "description": "Cleans up all git branches marked as [gone] (branches that have been deleted on the remote but still exist locally), including removing associated worktrees."
                },
                "content": "## Your Task\n\nYou need to execute the following bash commands to clean up stale local branches that have been deleted from the remote repository.\n\n## Commands to Execute\n\n1. **First, list branches to identify any with [gone] status**\n   Execute this command:\n   ```bash\n   git branch -v\n   ```\n   \n   Note: Branches with a '+' prefix have associated worktrees and must have their worktrees removed before deletion.\n\n2. **Next, identify worktrees that need to be removed for [gone] branches**\n   Execute this command:\n   ```bash\n   git worktree list\n   ```\n\n3. **Finally, remove worktrees and delete [gone] branches (handles both regular and worktree branches)**\n   Execute this command:\n   ```bash\n   # Process all [gone] branches, removing '+' prefix if present\n   git branch -v | grep '\\[gone\\]' | sed 's/^[+* ]//' | awk '{print $1}' | while read branch; do\n     echo \"Processing branch: $branch\"\n     # Find and remove worktree if it exists\n     worktree=$(git worktree list | grep \"\\\\[$branch\\\\]\" | awk '{print $1}')\n     if [ ! -z \"$worktree\" ] && [ \"$worktree\" != \"$(git rev-parse --show-toplevel)\" ]; then\n       echo \"  Removing worktree: $worktree\"\n       git worktree remove --force \"$worktree\"\n     fi\n     # Delete the branch\n     echo \"  Deleting branch: $branch\"\n     git branch -D \"$branch\"\n   done\n   ```\n\n## Expected Behavior\n\nAfter executing these commands, you will:\n\n- See a list of all local branches with their status\n- Identify and remove any worktrees associated with [gone] branches\n- Delete all branches marked as [gone]\n- Provide feedback on which worktrees and branches were removed\n\nIf no branches are marked as [gone], report that no cleanup was needed."
              },
              {
                "name": "/commit-push-pr",
                "description": "Commit, push, and open a PR",
                "path": "plugins/commit-commands/commands/commit-push-pr.md",
                "frontmatter": {
                  "allowed-tools": "Bash(git checkout --branch:*), Bash(git add:*), Bash(git status:*), Bash(git push:*), Bash(git commit:*), Bash(gh pr create:*)",
                  "description": "Commit, push, and open a PR"
                },
                "content": "## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n\n## Your task\n\nBased on the above changes:\n\n1. Create a new branch if on main\n2. Create a single commit with an appropriate message\n3. Push the branch to origin\n4. Create a pull request using `gh pr create`\n5. You have the capability to call multiple tools in a single response. You MUST do all of the above in a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls."
              },
              {
                "name": "/commit",
                "description": "Create a git commit",
                "path": "plugins/commit-commands/commands/commit.md",
                "frontmatter": {
                  "allowed-tools": "Bash(git add:*), Bash(git status:*), Bash(git commit:*)",
                  "description": "Create a git commit"
                },
                "content": "## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n- Recent commits: !`git log --oneline -10`\n\n## Your task\n\nBased on the above changes, create a single git commit.\n\nYou have the capability to call multiple tools in a single response. Stage and create the commit using a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls."
              }
            ],
            "skills": []
          },
          {
            "name": "feature-dev",
            "description": "Comprehensive feature development workflow with specialized agents for codebase exploration, architecture design, and quality review",
            "source": "./plugins/feature-dev",
            "category": "development",
            "version": null,
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install feature-dev@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [
              {
                "name": "/feature-dev",
                "description": "Guided feature development with codebase understanding and architecture focus",
                "path": "plugins/feature-dev/commands/feature-dev.md",
                "frontmatter": {
                  "description": "Guided feature development with codebase understanding and architecture focus",
                  "argument-hint": "Optional feature description"
                },
                "content": "# Feature Development\n\nYou are helping a developer implement a new feature. Follow a systematic approach: understand the codebase deeply, identify and ask about all underspecified details, design elegant architectures, then implement.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities, edge cases, and underspecified behaviors. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation. Ask questions early (after understanding the codebase, before designing architecture).\n- **Understand before acting**: Read and comprehend existing code patterns first\n- **Read files identified by agents**: When launching agents, ask them to return lists of the most important files to read. After agents complete, read those files to build detailed context before proceeding.\n- **Simple and elegant**: Prioritize readable, maintainable, architecturally sound code\n- **Use TodoWrite**: Track all progress throughout\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what needs to be built\n\nInitial request: $ARGUMENTS\n\n**Actions**:\n1. Create todo list with all phases\n2. If feature unclear, ask user for:\n   - What problem are they solving?\n   - What should the feature do?\n   - Any constraints or requirements?\n3. Summarize understanding and confirm with user\n\n---\n\n## Phase 2: Codebase Exploration\n\n**Goal**: Understand relevant existing code and patterns at both high and low levels\n\n**Actions**:\n1. Launch 2-3 code-explorer agents in parallel. Each agent should:\n   - Trace through the code comprehensively and focus on getting a comprehensive understanding of abstractions, architecture and flow of control\n   - Target a different aspect of the codebase (eg. similar features, high level understanding, architectural understanding, user experience, etc)\n   - Include a list of 5-10 key files to read\n\n   **Example agent prompts**:\n   - \"Find features similar to [feature] and trace through their implementation comprehensively\"\n   - \"Map the architecture and abstractions for [feature area], tracing through the code comprehensively\"\n   - \"Analyze the current implementation of [existing feature/area], tracing through the code comprehensively\"\n   - \"Identify UI patterns, testing approaches, or extension points relevant to [feature]\"\n\n2. Once the agents return, please read all files identified by agents to build deep understanding\n3. Present comprehensive summary of findings and patterns discovered\n\n---\n\n## Phase 3: Clarifying Questions\n\n**Goal**: Fill in gaps and resolve all ambiguities before designing\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. Review the codebase findings and original feature request\n2. Identify underspecified aspects: edge cases, error handling, integration points, scope boundaries, design preferences, backward compatibility, performance needs\n3. **Present all questions to the user in a clear, organized list**\n4. **Wait for answers before proceeding to architecture design**\n\nIf the user says \"whatever you think is best\", provide your recommendation and get explicit confirmation.\n\n---\n\n## Phase 4: Architecture Design\n\n**Goal**: Design multiple implementation approaches with different trade-offs\n\n**Actions**:\n1. Launch 2-3 code-architect agents in parallel with different focuses: minimal changes (smallest change, maximum reuse), clean architecture (maintainability, elegant abstractions), or pragmatic balance (speed + quality)\n2. Review all approaches and form your opinion on which fits best for this specific task (consider: small fix vs large feature, urgency, complexity, team context)\n3. Present to user: brief summary of each approach, trade-offs comparison, **your recommendation with reasoning**, concrete implementation differences\n4. **Ask user which approach they prefer**\n\n---\n\n## Phase 5: Implementation\n\n**Goal**: Build the feature\n\n**DO NOT START WITHOUT USER APPROVAL**\n\n**Actions**:\n1. Wait for explicit user approval\n2. Read all relevant files identified in previous phases\n3. Implement following chosen architecture\n4. Follow codebase conventions strictly\n5. Write clean, well-documented code\n6. Update todos as you progress\n\n---\n\n## Phase 6: Quality Review\n\n**Goal**: Ensure code is simple, DRY, elegant, easy to read, and functionally correct\n\n**Actions**:\n1. Launch 3 code-reviewer agents in parallel with different focuses: simplicity/DRY/elegance, bugs/functional correctness, project conventions/abstractions\n2. Consolidate findings and identify highest severity issues that you recommend fixing\n3. **Present findings to user and ask what they want to do** (fix now, fix later, or proceed as-is)\n4. Address issues based on user decision\n\n---\n\n## Phase 7: Summary\n\n**Goal**: Document what was accomplished\n\n**Actions**:\n1. Mark all todos complete\n2. Summarize:\n   - What was built\n   - Key decisions made\n   - Files modified\n   - Suggested next steps\n\n---"
              }
            ],
            "skills": []
          },
          {
            "name": "security-guidance",
            "description": "Security reminder hook that warns about potential security issues when editing files, including command injection, XSS, and unsafe code patterns",
            "source": "./plugins/security-guidance",
            "category": "security",
            "version": null,
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install security-guidance@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "code-review",
            "description": "Automated code review for pull requests using multiple specialized agents with confidence-based scoring to filter false positives",
            "source": "./plugins/code-review",
            "category": "productivity",
            "version": null,
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install code-review@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [
              {
                "name": "/code-review",
                "description": "Code review a pull request",
                "path": "plugins/code-review/commands/code-review.md",
                "frontmatter": {
                  "allowed-tools": "Bash(gh issue view:*), Bash(gh search:*), Bash(gh issue list:*), Bash(gh pr comment:*), Bash(gh pr diff:*), Bash(gh pr view:*), Bash(gh pr list:*)",
                  "description": "Code review a pull request",
                  "disable-model-invocation": false
                },
                "content": "Provide a code review for the given pull request.\n\nTo do this, follow these steps precisely:\n\n1. Use a Haiku agent to check if the pull request (a) is closed, (b) is a draft, (c) does not need a code review (eg. because it is an automated pull request, or is very simple and obviously ok), or (d) already has a code review from you from earlier. If so, do not proceed.\n2. Use another Haiku agent to give you a list of file paths to (but not the contents of) any relevant CLAUDE.md files from the codebase: the root CLAUDE.md file (if one exists), as well as any CLAUDE.md files in the directories whose files the pull request modified\n3. Use a Haiku agent to view the pull request, and ask the agent to return a summary of the change\n4. Then, launch 5 parallel Sonnet agents to independently code review the change. The agents should do the following, then return a list of issues and the reason each issue was flagged (eg. CLAUDE.md adherence, bug, historical git context, etc.):\n   a. Agent #1: Audit the changes to make sure they compily with the CLAUDE.md. Note that CLAUDE.md is guidance for Claude as it writes code, so not all instructions will be applicable during code review.\n   b. Agent #2: Read the file changes in the pull request, then do a shallow scan for obvious bugs. Avoid reading extra context beyond the changes, focusing just on the changes themselves. Focus on large bugs, and avoid small issues and nitpicks. Ignore likely false positives.\n   c. Agent #3: Read the git blame and history of the code modified, to identify any bugs in light of that historical context\n   d. Agent #4: Read previous pull requests that touched these files, and check for any comments on those pull requests that may also apply to the current pull request.\n   e. Agent #5: Read code comments in the modified files, and make sure the changes in the pull request comply with any guidance in the comments.\n5. For each issue found in #4, launch a parallel Haiku agent that takes the PR, issue description, and list of CLAUDE.md files (from step 2), and returns a score to indicate the agent's level of confidence for whether the issue is real or false positive. To do that, the agent should score each issue on a scale from 0-100, indicating its level of confidence. For issues that were flagged due to CLAUDE.md instructions, the agent should double check that the CLAUDE.md actually calls out that issue specifically. The scale is (give this rubric to the agent verbatim):\n   a. 0: Not confident at all. This is a false positive that doesn't stand up to light scrutiny, or is a pre-existing issue.\n   b. 25: Somewhat confident. This might be a real issue, but may also be a false positive. The agent wasn't able to verify that it's a real issue. If the issue is stylistic, it is one that was not explicitly called out in the relevant CLAUDE.md.\n   c. 50: Moderately confident. The agent was able to verify this is a real issue, but it might be a nitpick or not happen very often in practice. Relative to the rest of the PR, it's not very important.\n   d. 75: Highly confident. The agent double checked the issue, and verified that it is very likely it is a real issue that will be hit in practice. The existing approach in the PR is insufficient. The issue is very important and will directly impact the code's functionality, or it is an issue that is directly mentioned in the relevant CLAUDE.md.\n   e. 100: Absolutely certain. The agent double checked the issue, and confirmed that it is definitely a real issue, that will happen frequently in practice. The evidence directly confirms this.\n6. Filter out any issues with a score less than 80. If there are no issues that meet this criteria, do not proceed.\n7. Use a Haiku agent to repeat the eligibility check from #1, to make sure that the pull request is still eligible for code review.\n8. Finally, use the gh bash command to comment back on the pull request with the result. When writing your comment, keep in mind to:\n   a. Keep your output brief\n   b. Avoid emojis\n   c. Link and cite relevant code, files, and URLs\n\nExamples of false positives, for steps 4 and 5:\n\n- Pre-existing issues\n- Something that looks like a bug but is not actually a bug\n- Pedantic nitpicks that a senior engineer wouldn't call out\n- Issues that a linter, typechecker, or compiler would catch (eg. missing or incorrect imports, type errors, broken tests, formatting issues, pedantic style issues like newlines). No need to run these build steps yourself -- it is safe to assume that they will be run separately as part of CI.\n- General code quality issues (eg. lack of test coverage, general security issues, poor documentation), unless explicitly required in CLAUDE.md\n- Issues that are called out in CLAUDE.md, but explicitly silenced in the code (eg. due to a lint ignore comment)\n- Changes in functionality that are likely intentional or are directly related to the broader change\n- Real issues, but on lines that the user did not modify in their pull request\n\nNotes:\n\n- Do not check build signal or attempt to build or typecheck the app. These will run separately, and are not relevant to your code review.\n- Use `gh` to interact with Github (eg. to fetch a pull request, or to create inline comments), rather than web fetch\n- Make a todo list first\n- You must cite and link each bug (eg. if referring to a CLAUDE.md, you must link it)\n- For your final comment, follow the following format precisely (assuming for this example that you found 3 issues):\n\n---\n\n### Code review\n\nFound 3 issues:\n\n1. <brief description of bug> (CLAUDE.md says \"<...>\")\n\n<link to file and line with full sha1 + line range for context, note that you MUST provide the full sha and not use bash here, eg. https://github.com/anthropics/claude-code/blob/1d54823877c4de72b2316a64032a54afc404e619/README.md#L13-L17>\n\n2. <brief description of bug> (some/other/CLAUDE.md says \"<...>\")\n\n<link to file and line with full sha1 + line range for context>\n\n3. <brief description of bug> (bug due to <file and code snippet>)\n\n<link to file and line with full sha1 + line range for context>\n\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\n<sub>- If this code review was useful, please react with ðŸ‘. Otherwise, react with ðŸ‘Ž.</sub>\n\n---\n\n- Or, if you found no issues:\n\n---\n\n### Code review\n\nNo issues found. Checked for bugs and CLAUDE.md compliance.\n\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\n- When linking to code, follow the following format precisely, otherwise the Markdown preview won't render correctly: https://github.com/anthropics/claude-cli-internal/blob/c21d3c10bc8e898b7ac1a2d745bdc9bc4e423afe/package.json#L10-L15\n  - Requires full git sha\n  - You must provide the full sha. Commands like `https://github.com/owner/repo/blob/$(git rev-parse HEAD)/foo/bar` will not work, since your comment will be directly rendered in Markdown.\n  - Repo name must match the repo you're code reviewing\n  - # sign after the file name\n  - Line range format is L[start]-L[end]\n  - Provide at least 1 line of context before and after, centered on the line you are commenting about (eg. if you are commenting about lines 5-6, you should link to `L4-7`)"
              }
            ],
            "skills": []
          },
          {
            "name": "code-simplifier",
            "description": "Agent that simplifies and refines code for clarity, consistency, and maintainability while preserving functionality. Focuses on recently modified code.",
            "source": "./plugins/code-simplifier",
            "category": "productivity",
            "version": null,
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install code-simplifier@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "explanatory-output-style",
            "description": "Adds educational insights about implementation choices and codebase patterns (mimics the deprecated Explanatory output style)",
            "source": "./plugins/explanatory-output-style",
            "category": "learning",
            "version": null,
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install explanatory-output-style@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "learning-output-style",
            "description": "Interactive learning mode that requests meaningful code contributions at decision points (mimics the unshipped Learning output style)",
            "source": "./plugins/learning-output-style",
            "category": "learning",
            "version": null,
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install learning-output-style@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "frontend-design",
            "description": "Create distinctive, production-grade frontend interfaces with high design quality. Generates creative, polished code that avoids generic AI aesthetics.",
            "source": "./plugins/frontend-design",
            "category": "development",
            "version": null,
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install frontend-design@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": [
              {
                "name": "frontend-design",
                "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.",
                "path": "plugins/frontend-design/skills/frontend-design/SKILL.md",
                "frontmatter": {
                  "name": "frontend-design",
                  "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "This skill guides creation of distinctive, production-grade frontend interfaces that avoid generic \"AI slop\" aesthetics. Implement real working code with exceptional attention to aesthetic details and creative choices.\n\nThe user provides frontend requirements: a component, page, application, or interface to build. They may include context about the purpose, audience, or technical constraints.\n\n## Design Thinking\n\nBefore coding, understand the context and commit to a BOLD aesthetic direction:\n- **Purpose**: What problem does this interface solve? Who uses it?\n- **Tone**: Pick an extreme: brutally minimal, maximalist chaos, retro-futuristic, organic/natural, luxury/refined, playful/toy-like, editorial/magazine, brutalist/raw, art deco/geometric, soft/pastel, industrial/utilitarian, etc. There are so many flavors to choose from. Use these for inspiration but design one that is true to the aesthetic direction.\n- **Constraints**: Technical requirements (framework, performance, accessibility).\n- **Differentiation**: What makes this UNFORGETTABLE? What's the one thing someone will remember?\n\n**CRITICAL**: Choose a clear conceptual direction and execute it with precision. Bold maximalism and refined minimalism both work - the key is intentionality, not intensity.\n\nThen implement working code (HTML/CSS/JS, React, Vue, etc.) that is:\n- Production-grade and functional\n- Visually striking and memorable\n- Cohesive with a clear aesthetic point-of-view\n- Meticulously refined in every detail\n\n## Frontend Aesthetics Guidelines\n\nFocus on:\n- **Typography**: Choose fonts that are beautiful, unique, and interesting. Avoid generic fonts like Arial and Inter; opt instead for distinctive choices that elevate the frontend's aesthetics; unexpected, characterful font choices. Pair a distinctive display font with a refined body font.\n- **Color & Theme**: Commit to a cohesive aesthetic. Use CSS variables for consistency. Dominant colors with sharp accents outperform timid, evenly-distributed palettes.\n- **Motion**: Use animations for effects and micro-interactions. Prioritize CSS-only solutions for HTML. Use Motion library for React when available. Focus on high-impact moments: one well-orchestrated page load with staggered reveals (animation-delay) creates more delight than scattered micro-interactions. Use scroll-triggering and hover states that surprise.\n- **Spatial Composition**: Unexpected layouts. Asymmetry. Overlap. Diagonal flow. Grid-breaking elements. Generous negative space OR controlled density.\n- **Backgrounds & Visual Details**: Create atmosphere and depth rather than defaulting to solid colors. Add contextual effects and textures that match the overall aesthetic. Apply creative forms like gradient meshes, noise textures, geometric patterns, layered transparencies, dramatic shadows, decorative borders, custom cursors, and grain overlays.\n\nNEVER use generic AI-generated aesthetics like overused font families (Inter, Roboto, Arial, system fonts), cliched color schemes (particularly purple gradients on white backgrounds), predictable layouts and component patterns, and cookie-cutter design that lacks context-specific character.\n\nInterpret creatively and make unexpected choices that feel genuinely designed for the context. No design should be the same. Vary between light and dark themes, different fonts, different aesthetics. NEVER converge on common choices (Space Grotesk, for example) across generations.\n\n**IMPORTANT**: Match implementation complexity to the aesthetic vision. Maximalist designs need elaborate code with extensive animations and effects. Minimalist or refined designs need restraint, precision, and careful attention to spacing, typography, and subtle details. Elegance comes from executing the vision well.\n\nRemember: Claude is capable of extraordinary creative work. Don't hold back, show what can truly be created when thinking outside the box and committing fully to a distinctive vision."
              }
            ]
          },
          {
            "name": "ralph-loop",
            "description": "Interactive self-referential AI loops for iterative development, implementing the Ralph Wiggum technique. Claude works on the same task repeatedly, seeing its previous work, until completion.",
            "source": "./plugins/ralph-loop",
            "category": "development",
            "version": null,
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install ralph-loop@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [
              {
                "name": "/cancel-ralph",
                "description": "Cancel active Ralph Loop",
                "path": "plugins/ralph-loop/commands/cancel-ralph.md",
                "frontmatter": {
                  "description": "Cancel active Ralph Loop",
                  "allowed-tools": [
                    "Bash(test -f .claude/ralph-loop.local.md:*)",
                    "Bash(rm .claude/ralph-loop.local.md)",
                    "Read(.claude/ralph-loop.local.md)"
                  ],
                  "hide-from-slash-command-tool": "true"
                },
                "content": "# Cancel Ralph\n\nTo cancel the Ralph loop:\n\n1. Check if `.claude/ralph-loop.local.md` exists using Bash: `test -f .claude/ralph-loop.local.md && echo \"EXISTS\" || echo \"NOT_FOUND\"`\n\n2. **If NOT_FOUND**: Say \"No active Ralph loop found.\"\n\n3. **If EXISTS**:\n   - Read `.claude/ralph-loop.local.md` to get the current iteration number from the `iteration:` field\n   - Remove the file using Bash: `rm .claude/ralph-loop.local.md`\n   - Report: \"Cancelled Ralph loop (was at iteration N)\" where N is the iteration value"
              },
              {
                "name": "/help",
                "description": "Explain Ralph Loop plugin and available commands",
                "path": "plugins/ralph-loop/commands/help.md",
                "frontmatter": {
                  "description": "Explain Ralph Loop plugin and available commands"
                },
                "content": "# Ralph Loop Plugin Help\n\nPlease explain the following to the user:\n\n## What is Ralph Loop?\n\nRalph Loop implements the Ralph Wiggum technique - an iterative development methodology based on continuous AI loops, pioneered by Geoffrey Huntley.\n\n**Core concept:**\n```bash\nwhile :; do\n  cat PROMPT.md | claude-code --continue\ndone\n```\n\nThe same prompt is fed to Claude repeatedly. The \"self-referential\" aspect comes from Claude seeing its own previous work in the files and git history, not from feeding output back as input.\n\n**Each iteration:**\n1. Claude receives the SAME prompt\n2. Works on the task, modifying files\n3. Tries to exit\n4. Stop hook intercepts and feeds the same prompt again\n5. Claude sees its previous work in the files\n6. Iteratively improves until completion\n\nThe technique is described as \"deterministically bad in an undeterministic world\" - failures are predictable, enabling systematic improvement through prompt tuning.\n\n## Available Commands\n\n### /ralph-loop <PROMPT> [OPTIONS]\n\nStart a Ralph loop in your current session.\n\n**Usage:**\n```\n/ralph-loop \"Refactor the cache layer\" --max-iterations 20\n/ralph-loop \"Add tests\" --completion-promise \"TESTS COMPLETE\"\n```\n\n**Options:**\n- `--max-iterations <n>` - Max iterations before auto-stop\n- `--completion-promise <text>` - Promise phrase to signal completion\n\n**How it works:**\n1. Creates `.claude/.ralph-loop.local.md` state file\n2. You work on the task\n3. When you try to exit, stop hook intercepts\n4. Same prompt fed back\n5. You see your previous work\n6. Continues until promise detected or max iterations\n\n---\n\n### /cancel-ralph\n\nCancel an active Ralph loop (removes the loop state file).\n\n**Usage:**\n```\n/cancel-ralph\n```\n\n**How it works:**\n- Checks for active loop state file\n- Removes `.claude/.ralph-loop.local.md`\n- Reports cancellation with iteration count\n\n---\n\n## Key Concepts\n\n### Completion Promises\n\nTo signal completion, Claude must output a `<promise>` tag:\n\n```\n<promise>TASK COMPLETE</promise>\n```\n\nThe stop hook looks for this specific tag. Without it (or `--max-iterations`), Ralph runs infinitely.\n\n### Self-Reference Mechanism\n\nThe \"loop\" doesn't mean Claude talks to itself. It means:\n- Same prompt repeated\n- Claude's work persists in files\n- Each iteration sees previous attempts\n- Builds incrementally toward goal\n\n## Example\n\n### Interactive Bug Fix\n\n```\n/ralph-loop \"Fix the token refresh logic in auth.ts. Output <promise>FIXED</promise> when all tests pass.\" --completion-promise \"FIXED\" --max-iterations 10\n```\n\nYou'll see Ralph:\n- Attempt fixes\n- Run tests\n- See failures\n- Iterate on solution\n- In your current session\n\n## When to Use Ralph\n\n**Good for:**\n- Well-defined tasks with clear success criteria\n- Tasks requiring iteration and refinement\n- Iterative development with self-correction\n- Greenfield projects\n\n**Not good for:**\n- Tasks requiring human judgment or design decisions\n- One-shot operations\n- Tasks with unclear success criteria\n- Debugging production issues (use targeted debugging instead)\n\n## Learn More\n\n- Original technique: https://ghuntley.com/ralph/\n- Ralph Orchestrator: https://github.com/mikeyobrien/ralph-orchestrator"
              },
              {
                "name": "/ralph-loop",
                "description": "Start Ralph Loop in current session",
                "path": "plugins/ralph-loop/commands/ralph-loop.md",
                "frontmatter": {
                  "description": "Start Ralph Loop in current session",
                  "argument-hint": "PROMPT [--max-iterations N] [--completion-promise TEXT]",
                  "allowed-tools": [
                    "Bash(${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh:*)"
                  ],
                  "hide-from-slash-command-tool": "true"
                },
                "content": "# Ralph Loop Command\n\nExecute the setup script to initialize the Ralph loop:\n\n```!\n\"${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh\" $ARGUMENTS\n```\n\nPlease work on the task. When you try to exit, the Ralph loop will feed the SAME PROMPT back to you for the next iteration. You'll see your previous work in files and git history, allowing you to iterate and improve.\n\nCRITICAL RULE: If a completion promise is set, you may ONLY output it when the statement is completely and unequivocally TRUE. Do not output false promises to escape the loop, even if you think you're stuck or should exit for other reasons. The loop is designed to continue until genuine completion."
              }
            ],
            "skills": []
          },
          {
            "name": "hookify",
            "description": "Easily create custom hooks to prevent unwanted behaviors by analyzing conversation patterns or from explicit instructions. Define rules via simple markdown files.",
            "source": "./plugins/hookify",
            "category": "productivity",
            "version": null,
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install hookify@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [
              {
                "name": "/configure",
                "description": "Enable or disable hookify rules interactively",
                "path": "plugins/hookify/commands/configure.md",
                "frontmatter": {
                  "description": "Enable or disable hookify rules interactively",
                  "allowed-tools": [
                    "Glob",
                    "Read",
                    "Edit",
                    "AskUserQuestion",
                    "Skill"
                  ]
                },
                "content": "# Configure Hookify Rules\n\n**Load hookify:writing-rules skill first** to understand rule format.\n\nEnable or disable existing hookify rules using an interactive interface.\n\n## Steps\n\n### 1. Find Existing Rules\n\nUse Glob tool to find all hookify rule files:\n```\npattern: \".claude/hookify.*.local.md\"\n```\n\nIf no rules found, inform user:\n```\nNo hookify rules configured yet. Use `/hookify` to create your first rule.\n```\n\n### 2. Read Current State\n\nFor each rule file:\n- Read the file\n- Extract `name` and `enabled` fields from frontmatter\n- Build list of rules with current state\n\n### 3. Ask User Which Rules to Toggle\n\nUse AskUserQuestion to let user select rules:\n\n```json\n{\n  \"questions\": [\n    {\n      \"question\": \"Which rules would you like to enable or disable?\",\n      \"header\": \"Configure\",\n      \"multiSelect\": true,\n      \"options\": [\n        {\n          \"label\": \"warn-dangerous-rm (currently enabled)\",\n          \"description\": \"Warns about rm -rf commands\"\n        },\n        {\n          \"label\": \"warn-console-log (currently disabled)\",\n          \"description\": \"Warns about console.log in code\"\n        },\n        {\n          \"label\": \"require-tests (currently enabled)\",\n          \"description\": \"Requires tests before stopping\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Option format:**\n- Label: `{rule-name} (currently {enabled|disabled})`\n- Description: Brief description from rule's message or pattern\n\n### 4. Parse User Selection\n\nFor each selected rule:\n- Determine current state from label (enabled/disabled)\n- Toggle state: enabled â†’ disabled, disabled â†’ enabled\n\n### 5. Update Rule Files\n\nFor each rule to toggle:\n- Use Read tool to read current content\n- Use Edit tool to change `enabled: true` to `enabled: false` (or vice versa)\n- Handle both with and without quotes\n\n**Edit pattern for enabling:**\n```\nold_string: \"enabled: false\"\nnew_string: \"enabled: true\"\n```\n\n**Edit pattern for disabling:**\n```\nold_string: \"enabled: true\"\nnew_string: \"enabled: false\"\n```\n\n### 6. Confirm Changes\n\nShow user what was changed:\n\n```\n## Hookify Rules Updated\n\n**Enabled:**\n- warn-console-log\n\n**Disabled:**\n- warn-dangerous-rm\n\n**Unchanged:**\n- require-tests\n\nChanges apply immediately - no restart needed\n```\n\n## Important Notes\n\n- Changes take effect immediately on next tool use\n- You can also manually edit .claude/hookify.*.local.md files\n- To permanently remove a rule, delete its .local.md file\n- Use `/hookify:list` to see all configured rules\n\n## Edge Cases\n\n**No rules to configure:**\n- Show message about using `/hookify` to create rules first\n\n**User selects no rules:**\n- Inform that no changes were made\n\n**File read/write errors:**\n- Inform user of specific error\n- Suggest manual editing as fallback"
              },
              {
                "name": "/help",
                "description": "Get help with the hookify plugin",
                "path": "plugins/hookify/commands/help.md",
                "frontmatter": {
                  "description": "Get help with the hookify plugin",
                  "allowed-tools": [
                    "Read"
                  ]
                },
                "content": "# Hookify Plugin Help\n\nExplain how the hookify plugin works and how to use it.\n\n## Overview\n\nThe hookify plugin makes it easy to create custom hooks that prevent unwanted behaviors. Instead of editing `hooks.json` files, users create simple markdown configuration files that define patterns to watch for.\n\n## How It Works\n\n### 1. Hook System\n\nHookify installs generic hooks that run on these events:\n- **PreToolUse**: Before any tool executes (Bash, Edit, Write, etc.)\n- **PostToolUse**: After a tool executes\n- **Stop**: When Claude wants to stop working\n- **UserPromptSubmit**: When user submits a prompt\n\nThese hooks read configuration files from `.claude/hookify.*.local.md` and check if any rules match the current operation.\n\n### 2. Configuration Files\n\nUsers create rules in `.claude/hookify.{rule-name}.local.md` files:\n\n```markdown\n---\nname: warn-dangerous-rm\nenabled: true\nevent: bash\npattern: rm\\s+-rf\n---\n\nâš ï¸ **Dangerous rm command detected!**\n\nThis command could delete important files. Please verify the path.\n```\n\n**Key fields:**\n- `name`: Unique identifier for the rule\n- `enabled`: true/false to activate/deactivate\n- `event`: bash, file, stop, prompt, or all\n- `pattern`: Regex pattern to match\n\nThe message body is what Claude sees when the rule triggers.\n\n### 3. Creating Rules\n\n**Option A: Use /hookify command**\n```\n/hookify Don't use console.log in production files\n```\n\nThis analyzes your request and creates the appropriate rule file.\n\n**Option B: Create manually**\nCreate `.claude/hookify.my-rule.local.md` with the format above.\n\n**Option C: Analyze conversation**\n```\n/hookify\n```\n\nWithout arguments, hookify analyzes recent conversation to find behaviors you want to prevent.\n\n## Available Commands\n\n- **`/hookify`** - Create hooks from conversation analysis or explicit instructions\n- **`/hookify:help`** - Show this help (what you're reading now)\n- **`/hookify:list`** - List all configured hooks\n- **`/hookify:configure`** - Enable/disable existing hooks interactively\n\n## Example Use Cases\n\n**Prevent dangerous commands:**\n```markdown\n---\nname: block-chmod-777\nenabled: true\nevent: bash\npattern: chmod\\s+777\n---\n\nDon't use chmod 777 - it's a security risk. Use specific permissions instead.\n```\n\n**Warn about debugging code:**\n```markdown\n---\nname: warn-console-log\nenabled: true\nevent: file\npattern: console\\.log\\(\n---\n\nConsole.log detected. Remember to remove debug logging before committing.\n```\n\n**Require tests before stopping:**\n```markdown\n---\nname: require-tests\nenabled: true\nevent: stop\npattern: .*\n---\n\nDid you run tests before finishing? Make sure `npm test` or equivalent was executed.\n```\n\n## Pattern Syntax\n\nUse Python regex syntax:\n- `\\s` - whitespace\n- `\\.` - literal dot\n- `|` - OR\n- `+` - one or more\n- `*` - zero or more\n- `\\d` - digit\n- `[abc]` - character class\n\n**Examples:**\n- `rm\\s+-rf` - matches \"rm -rf\"\n- `console\\.log\\(` - matches \"console.log(\"\n- `(eval|exec)\\(` - matches \"eval(\" or \"exec(\"\n- `\\.env$` - matches files ending in .env\n\n## Important Notes\n\n**No Restart Needed**: Hookify rules (`.local.md` files) take effect immediately on the next tool use. The hookify hooks are already loaded and read your rules dynamically.\n\n**Block or Warn**: Rules can either `block` operations (prevent execution) or `warn` (show message but allow). Set `action: block` or `action: warn` in the rule's frontmatter.\n\n**Rule Files**: Keep rules in `.claude/hookify.*.local.md` - they should be git-ignored (add to .gitignore if needed).\n\n**Disable Rules**: Set `enabled: false` in frontmatter or delete the file.\n\n## Troubleshooting\n\n**Hook not triggering:**\n- Check rule file is in `.claude/` directory\n- Verify `enabled: true` in frontmatter\n- Confirm pattern is valid regex\n- Test pattern: `python3 -c \"import re; print(re.search('your_pattern', 'test_text'))\"`\n- Rules take effect immediately - no restart needed\n\n**Import errors:**\n- Check Python 3 is available: `python3 --version`\n- Verify hookify plugin is installed correctly\n\n**Pattern not matching:**\n- Test regex separately\n- Check for escaping issues (use unquoted patterns in YAML)\n- Try simpler pattern first, then refine\n\n## Getting Started\n\n1. Create your first rule:\n   ```\n   /hookify Warn me when I try to use rm -rf\n   ```\n\n2. Try to trigger it:\n   - Ask Claude to run `rm -rf /tmp/test`\n   - You should see the warning\n\n4. Refine the rule by editing `.claude/hookify.warn-rm.local.md`\n\n5. Create more rules as you encounter unwanted behaviors\n\nFor more examples, check the `${CLAUDE_PLUGIN_ROOT}/examples/` directory."
              },
              {
                "name": "/hookify",
                "description": "Create hooks to prevent unwanted behaviors from conversation analysis or explicit instructions",
                "path": "plugins/hookify/commands/hookify.md",
                "frontmatter": {
                  "description": "Create hooks to prevent unwanted behaviors from conversation analysis or explicit instructions",
                  "argument-hint": "Optional specific behavior to address",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "AskUserQuestion",
                    "Task",
                    "Grep",
                    "TodoWrite",
                    "Skill"
                  ]
                },
                "content": "# Hookify - Create Hooks from Unwanted Behaviors\n\n**FIRST: Load the hookify:writing-rules skill** using the Skill tool to understand rule file format and syntax.\n\nCreate hook rules to prevent problematic behaviors by analyzing the conversation or from explicit user instructions.\n\n## Your Task\n\nYou will help the user create hookify rules to prevent unwanted behaviors. Follow these steps:\n\n### Step 1: Gather Behavior Information\n\n**If $ARGUMENTS is provided:**\n- User has given specific instructions: `$ARGUMENTS`\n- Still analyze recent conversation (last 10-15 user messages) for additional context\n- Look for examples of the behavior happening\n\n**If $ARGUMENTS is empty:**\n- Launch the conversation-analyzer agent to find problematic behaviors\n- Agent will scan user prompts for frustration signals\n- Agent will return structured findings\n\n**To analyze conversation:**\nUse the Task tool to launch conversation-analyzer agent:\n```\n{\n  \"subagent_type\": \"general-purpose\",\n  \"description\": \"Analyze conversation for unwanted behaviors\",\n  \"prompt\": \"You are analyzing a Claude Code conversation to find behaviors the user wants to prevent.\n\nRead user messages in the current conversation and identify:\n1. Explicit requests to avoid something (\\\"don't do X\\\", \\\"stop doing Y\\\")\n2. Corrections or reversions (user fixing Claude's actions)\n3. Frustrated reactions (\\\"why did you do X?\\\", \\\"I didn't ask for that\\\")\n4. Repeated issues (same problem multiple times)\n\nFor each issue found, extract:\n- What tool was used (Bash, Edit, Write, etc.)\n- Specific pattern or command\n- Why it was problematic\n- User's stated reason\n\nReturn findings as a structured list with:\n- category: Type of issue\n- tool: Which tool was involved\n- pattern: Regex or literal pattern to match\n- context: What happened\n- severity: high/medium/low\n\nFocus on the most recent issues (last 20-30 messages). Don't go back further unless explicitly asked.\"\n}\n```\n\n### Step 2: Present Findings to User\n\nAfter gathering behaviors (from arguments or agent), present to user using AskUserQuestion:\n\n**Question 1: Which behaviors to hookify?**\n- Header: \"Create Rules\"\n- multiSelect: true\n- Options: List each detected behavior (max 4)\n  - Label: Short description (e.g., \"Block rm -rf\")\n  - Description: Why it's problematic\n\n**Question 2: For each selected behavior, ask about action:**\n- \"Should this block the operation or just warn?\"\n- Options:\n  - \"Just warn\" (action: warn - shows message but allows)\n  - \"Block operation\" (action: block - prevents execution)\n\n**Question 3: Ask for example patterns:**\n- \"What patterns should trigger this rule?\"\n- Show detected patterns\n- Allow user to refine or add more\n\n### Step 3: Generate Rule Files\n\nFor each confirmed behavior, create a `.claude/hookify.{rule-name}.local.md` file:\n\n**Rule naming convention:**\n- Use kebab-case\n- Be descriptive: `block-dangerous-rm`, `warn-console-log`, `require-tests-before-stop`\n- Start with action verb: block, warn, prevent, require\n\n**File format:**\n```markdown\n---\nname: {rule-name}\nenabled: true\nevent: {bash|file|stop|prompt|all}\npattern: {regex pattern}\naction: {warn|block}\n---\n\n{Message to show Claude when rule triggers}\n```\n\n**Action values:**\n- `warn`: Show message but allow operation (default)\n- `block`: Prevent operation or stop session\n\n**For more complex rules (multiple conditions):**\n```markdown\n---\nname: {rule-name}\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$\n  - field: new_text\n    operator: contains\n    pattern: API_KEY\n---\n\n{Warning message}\n```\n\n### Step 4: Create Files and Confirm\n\n**IMPORTANT**: Rule files must be created in the current working directory's `.claude/` folder, NOT the plugin directory.\n\nUse the current working directory (where Claude Code was started) as the base path.\n\n1. Check if `.claude/` directory exists in current working directory\n   - If not, create it first with: `mkdir -p .claude`\n\n2. Use Write tool to create each `.claude/hookify.{name}.local.md` file\n   - Use relative path from current working directory: `.claude/hookify.{name}.local.md`\n   - The path should resolve to the project's .claude directory, not the plugin's\n\n3. Show user what was created:\n   ```\n   Created 3 hookify rules:\n   - .claude/hookify.dangerous-rm.local.md\n   - .claude/hookify.console-log.local.md\n   - .claude/hookify.sensitive-files.local.md\n\n   These rules will trigger on:\n   - dangerous-rm: Bash commands matching \"rm -rf\"\n   - console-log: Edits adding console.log statements\n   - sensitive-files: Edits to .env or credentials files\n   ```\n\n4. Verify files were created in the correct location by listing them\n\n5. Inform user: **\"Rules are active immediately - no restart needed!\"**\n\n   The hookify hooks are already loaded and will read your new rules on the next tool use.\n\n## Event Types Reference\n\n- **bash**: Matches Bash tool commands\n- **file**: Matches Edit, Write, MultiEdit tools\n- **stop**: Matches when agent wants to stop (use for completion checks)\n- **prompt**: Matches when user submits prompts\n- **all**: Matches all events\n\n## Pattern Writing Tips\n\n**Bash patterns:**\n- Match dangerous commands: `rm\\s+-rf|chmod\\s+777|dd\\s+if=`\n- Match specific tools: `npm\\s+install\\s+|pip\\s+install`\n\n**File patterns:**\n- Match code patterns: `console\\.log\\(|eval\\(|innerHTML\\s*=`\n- Match file paths: `\\.env$|\\.git/|node_modules/`\n\n**Stop patterns:**\n- Check for missing steps: (check transcript or completion criteria)\n\n## Example Workflow\n\n**User says**: \"/hookify Don't use rm -rf without asking me first\"\n\n**Your response**:\n1. Analyze: User wants to prevent rm -rf commands\n2. Ask: \"Should I block this command or just warn you?\"\n3. User selects: \"Just warn\"\n4. Create `.claude/hookify.dangerous-rm.local.md`:\n   ```markdown\n   ---\n   name: warn-dangerous-rm\n   enabled: true\n   event: bash\n   pattern: rm\\s+-rf\n   ---\n\n   âš ï¸ **Dangerous rm command detected**\n\n   You requested to be warned before using rm -rf.\n   Please verify the path is correct.\n   ```\n5. Confirm: \"Created hookify rule. It's active immediately - try triggering it!\"\n\n## Important Notes\n\n- **No restart needed**: Rules take effect immediately on the next tool use\n- **File location**: Create files in project's `.claude/` directory (current working directory), NOT the plugin's .claude/\n- **Regex syntax**: Use Python regex syntax (raw strings, no need to escape in YAML)\n- **Action types**: Rules can `warn` (default) or `block` operations\n- **Testing**: Test rules immediately after creating them\n\n## Troubleshooting\n\n**If rule file creation fails:**\n1. Check current working directory with pwd\n2. Ensure `.claude/` directory exists (create with mkdir if needed)\n3. Use absolute path if needed: `{cwd}/.claude/hookify.{name}.local.md`\n4. Verify file was created with Glob or ls\n\n**If rule doesn't trigger after creation:**\n1. Verify file is in project `.claude/` not plugin `.claude/`\n2. Check file with Read tool to ensure pattern is correct\n3. Test pattern with: `python3 -c \"import re; print(re.search(r'pattern', 'test text'))\"`\n4. Verify `enabled: true` in frontmatter\n5. Remember: Rules work immediately, no restart needed\n\n**If blocking seems too strict:**\n1. Change `action: block` to `action: warn` in the rule file\n2. Or adjust the pattern to be more specific\n3. Changes take effect on next tool use\n\nUse TodoWrite to track your progress through the steps."
              },
              {
                "name": "/list",
                "description": "List all configured hookify rules",
                "path": "plugins/hookify/commands/list.md",
                "frontmatter": {
                  "description": "List all configured hookify rules",
                  "allowed-tools": [
                    "Glob",
                    "Read",
                    "Skill"
                  ]
                },
                "content": "# List Hookify Rules\n\n**Load hookify:writing-rules skill first** to understand rule format.\n\nShow all configured hookify rules in the project.\n\n## Steps\n\n1. Use Glob tool to find all hookify rule files:\n   ```\n   pattern: \".claude/hookify.*.local.md\"\n   ```\n\n2. For each file found:\n   - Use Read tool to read the file\n   - Extract frontmatter fields: name, enabled, event, pattern\n   - Extract message preview (first 100 chars)\n\n3. Present results in a table:\n\n```\n## Configured Hookify Rules\n\n| Name | Enabled | Event | Pattern | File |\n|------|---------|-------|---------|------|\n| warn-dangerous-rm | âœ… Yes | bash | rm\\s+-rf | hookify.dangerous-rm.local.md |\n| warn-console-log | âœ… Yes | file | console\\.log\\( | hookify.console-log.local.md |\n| check-tests | âŒ No | stop | .* | hookify.require-tests.local.md |\n\n**Total**: 3 rules (2 enabled, 1 disabled)\n```\n\n4. For each rule, show a brief preview:\n```\n### warn-dangerous-rm\n**Event**: bash\n**Pattern**: `rm\\s+-rf`\n**Message**: \"âš ï¸ **Dangerous rm command detected!** This command could delete...\"\n\n**Status**: âœ… Active\n**File**: .claude/hookify.dangerous-rm.local.md\n```\n\n5. Add helpful footer:\n```\n---\n\nTo modify a rule: Edit the .local.md file directly\nTo disable a rule: Set `enabled: false` in frontmatter\nTo enable a rule: Set `enabled: true` in frontmatter\nTo delete a rule: Remove the .local.md file\nTo create a rule: Use `/hookify` command\n\n**Remember**: Changes take effect immediately - no restart needed\n```\n\n## If No Rules Found\n\nIf no hookify rules exist:\n\n```\n## No Hookify Rules Configured\n\nYou haven't created any hookify rules yet.\n\nTo get started:\n1. Use `/hookify` to analyze conversation and create rules\n2. Or manually create `.claude/hookify.my-rule.local.md` files\n3. See `/hookify:help` for documentation\n\nExample:\n```\n/hookify Warn me when I use console.log\n```\n\nCheck `${CLAUDE_PLUGIN_ROOT}/examples/` for example rule files.\n```"
              }
            ],
            "skills": [
              {
                "name": "Writing Hookify Rules",
                "description": "This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"configure hookify\", \"add a hookify rule\", or needs guidance on hookify rule syntax and patterns.",
                "path": "plugins/hookify/skills/writing-rules/SKILL.md",
                "frontmatter": {
                  "name": "Writing Hookify Rules",
                  "description": "This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"configure hookify\", \"add a hookify rule\", or needs guidance on hookify rule syntax and patterns.",
                  "version": "0.1.0"
                },
                "content": "# Writing Hookify Rules\n\n## Overview\n\nHookify rules are markdown files with YAML frontmatter that define patterns to watch for and messages to show when those patterns match. Rules are stored in `.claude/hookify.{rule-name}.local.md` files.\n\n## Rule File Format\n\n### Basic Structure\n\n```markdown\n---\nname: rule-identifier\nenabled: true\nevent: bash|file|stop|prompt|all\npattern: regex-pattern-here\n---\n\nMessage to show Claude when this rule triggers.\nCan include markdown formatting, warnings, suggestions, etc.\n```\n\n### Frontmatter Fields\n\n**name** (required): Unique identifier for the rule\n- Use kebab-case: `warn-dangerous-rm`, `block-console-log`\n- Be descriptive and action-oriented\n- Start with verb: warn, prevent, block, require, check\n\n**enabled** (required): Boolean to activate/deactivate\n- `true`: Rule is active\n- `false`: Rule is disabled (won't trigger)\n- Can toggle without deleting rule\n\n**event** (required): Which hook event to trigger on\n- `bash`: Bash tool commands\n- `file`: Edit, Write, MultiEdit tools\n- `stop`: When agent wants to stop\n- `prompt`: When user submits a prompt\n- `all`: All events\n\n**action** (optional): What to do when rule matches\n- `warn`: Show message but allow operation (default)\n- `block`: Prevent operation (PreToolUse) or stop session (Stop events)\n- If omitted, defaults to `warn`\n\n**pattern** (simple format): Regex pattern to match\n- Used for simple single-condition rules\n- Matches against command (bash) or new_text (file)\n- Python regex syntax\n\n**Example:**\n```yaml\nevent: bash\npattern: rm\\s+-rf\n```\n\n### Advanced Format (Multiple Conditions)\n\nFor complex rules with multiple conditions:\n\n```markdown\n---\nname: warn-env-file-edits\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$\n  - field: new_text\n    operator: contains\n    pattern: API_KEY\n---\n\nYou're adding an API key to a .env file. Ensure this file is in .gitignore!\n```\n\n**Condition fields:**\n- `field`: Which field to check\n  - For bash: `command`\n  - For file: `file_path`, `new_text`, `old_text`, `content`\n- `operator`: How to match\n  - `regex_match`: Regex pattern matching\n  - `contains`: Substring check\n  - `equals`: Exact match\n  - `not_contains`: Substring must NOT be present\n  - `starts_with`: Prefix check\n  - `ends_with`: Suffix check\n- `pattern`: Pattern or string to match\n\n**All conditions must match for rule to trigger.**\n\n## Message Body\n\nThe markdown content after frontmatter is shown to Claude when the rule triggers.\n\n**Good messages:**\n- Explain what was detected\n- Explain why it's problematic\n- Suggest alternatives or best practices\n- Use formatting for clarity (bold, lists, etc.)\n\n**Example:**\n```markdown\nâš ï¸ **Console.log detected!**\n\nYou're adding console.log to production code.\n\n**Why this matters:**\n- Debug logs shouldn't ship to production\n- Console.log can expose sensitive data\n- Impacts browser performance\n\n**Alternatives:**\n- Use a proper logging library\n- Remove before committing\n- Use conditional debug builds\n```\n\n## Event Type Guide\n\n### bash Events\n\nMatch Bash command patterns:\n\n```markdown\n---\nevent: bash\npattern: sudo\\s+|rm\\s+-rf|chmod\\s+777\n---\n\nDangerous command detected!\n```\n\n**Common patterns:**\n- Dangerous commands: `rm\\s+-rf`, `dd\\s+if=`, `mkfs`\n- Privilege escalation: `sudo\\s+`, `su\\s+`\n- Permission issues: `chmod\\s+777`, `chown\\s+root`\n\n### file Events\n\nMatch Edit/Write/MultiEdit operations:\n\n```markdown\n---\nevent: file\npattern: console\\.log\\(|eval\\(|innerHTML\\s*=\n---\n\nPotentially problematic code pattern detected!\n```\n\n**Match on different fields:**\n```markdown\n---\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.tsx?$\n  - field: new_text\n    operator: regex_match\n    pattern: console\\.log\\(\n---\n\nConsole.log in TypeScript file!\n```\n\n**Common patterns:**\n- Debug code: `console\\.log\\(`, `debugger`, `print\\(`\n- Security risks: `eval\\(`, `innerHTML\\s*=`, `dangerouslySetInnerHTML`\n- Sensitive files: `\\.env$`, `credentials`, `\\.pem$`\n- Generated files: `node_modules/`, `dist/`, `build/`\n\n### stop Events\n\nMatch when agent wants to stop (completion checks):\n\n```markdown\n---\nevent: stop\npattern: .*\n---\n\nBefore stopping, verify:\n- [ ] Tests were run\n- [ ] Build succeeded\n- [ ] Documentation updated\n```\n\n**Use for:**\n- Reminders about required steps\n- Completion checklists\n- Process enforcement\n\n### prompt Events\n\nMatch user prompt content (advanced):\n\n```markdown\n---\nevent: prompt\nconditions:\n  - field: user_prompt\n    operator: contains\n    pattern: deploy to production\n---\n\nProduction deployment checklist:\n- [ ] Tests passing?\n- [ ] Reviewed by team?\n- [ ] Monitoring ready?\n```\n\n## Pattern Writing Tips\n\n### Regex Basics\n\n**Literal characters:** Most characters match themselves\n- `rm` matches \"rm\"\n- `console.log` matches \"console.log\"\n\n**Special characters need escaping:**\n- `.` (any char) â†’ `\\.` (literal dot)\n- `(` `)` â†’ `\\(` `\\)` (literal parens)\n- `[` `]` â†’ `\\[` `\\]` (literal brackets)\n\n**Common metacharacters:**\n- `\\s` - whitespace (space, tab, newline)\n- `\\d` - digit (0-9)\n- `\\w` - word character (a-z, A-Z, 0-9, _)\n- `.` - any character\n- `+` - one or more\n- `*` - zero or more\n- `?` - zero or one\n- `|` - OR\n\n**Examples:**\n```\nrm\\s+-rf         Matches: rm -rf, rm  -rf\nconsole\\.log\\(   Matches: console.log(\n(eval|exec)\\(    Matches: eval( or exec(\nchmod\\s+777      Matches: chmod 777, chmod  777\nAPI_KEY\\s*=      Matches: API_KEY=, API_KEY =\n```\n\n### Testing Patterns\n\nTest regex patterns before using:\n\n```bash\npython3 -c \"import re; print(re.search(r'your_pattern', 'test text'))\"\n```\n\nOr use online regex testers (regex101.com with Python flavor).\n\n### Common Pitfalls\n\n**Too broad:**\n```yaml\npattern: log    # Matches \"log\", \"login\", \"dialog\", \"catalog\"\n```\nBetter: `console\\.log\\(|logger\\.`\n\n**Too specific:**\n```yaml\npattern: rm -rf /tmp  # Only matches exact path\n```\nBetter: `rm\\s+-rf`\n\n**Escaping issues:**\n- YAML quoted strings: `\"pattern\"` requires double backslashes `\\\\s`\n- YAML unquoted: `pattern: \\s` works as-is\n- **Recommendation**: Use unquoted patterns in YAML\n\n## File Organization\n\n**Location:** All rules in `.claude/` directory\n**Naming:** `.claude/hookify.{descriptive-name}.local.md`\n**Gitignore:** Add `.claude/*.local.md` to `.gitignore`\n\n**Good names:**\n- `hookify.dangerous-rm.local.md`\n- `hookify.console-log.local.md`\n- `hookify.require-tests.local.md`\n- `hookify.sensitive-files.local.md`\n\n**Bad names:**\n- `hookify.rule1.local.md` (not descriptive)\n- `hookify.md` (missing .local)\n- `danger.local.md` (missing hookify prefix)\n\n## Workflow\n\n### Creating a Rule\n\n1. Identify unwanted behavior\n2. Determine which tool is involved (Bash, Edit, etc.)\n3. Choose event type (bash, file, stop, etc.)\n4. Write regex pattern\n5. Create `.claude/hookify.{name}.local.md` file in project root\n6. Test immediately - rules are read dynamically on next tool use\n\n### Refining a Rule\n\n1. Edit the `.local.md` file\n2. Adjust pattern or message\n3. Test immediately - changes take effect on next tool use\n\n### Disabling a Rule\n\n**Temporary:** Set `enabled: false` in frontmatter\n**Permanent:** Delete the `.local.md` file\n\n## Examples\n\nSee `${CLAUDE_PLUGIN_ROOT}/examples/` for complete examples:\n- `dangerous-rm.local.md` - Block dangerous rm commands\n- `console-log-warning.local.md` - Warn about console.log\n- `sensitive-files-warning.local.md` - Warn about editing .env files\n\n## Quick Reference\n\n**Minimum viable rule:**\n```markdown\n---\nname: my-rule\nenabled: true\nevent: bash\npattern: dangerous_command\n---\n\nWarning message here\n```\n\n**Rule with conditions:**\n```markdown\n---\nname: my-rule\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.ts$\n  - field: new_text\n    operator: contains\n    pattern: any\n---\n\nWarning message\n```\n\n**Event types:**\n- `bash` - Bash commands\n- `file` - File edits\n- `stop` - Completion checks\n- `prompt` - User input\n- `all` - All events\n\n**Field options:**\n- Bash: `command`\n- File: `file_path`, `new_text`, `old_text`, `content`\n- Prompt: `user_prompt`\n\n**Operators:**\n- `regex_match`, `contains`, `equals`, `not_contains`, `starts_with`, `ends_with`"
              }
            ]
          },
          {
            "name": "plugin-dev",
            "description": "Comprehensive toolkit for developing Claude Code plugins. Includes 7 expert skills covering hooks, MCP integration, commands, agents, and best practices. AI-assisted plugin creation and validation.",
            "source": "./plugins/plugin-dev",
            "category": "development",
            "version": null,
            "author": {
              "name": "Anthropic",
              "email": "support@anthropic.com"
            },
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install plugin-dev@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [
              {
                "name": "/create-plugin",
                "description": "Guided end-to-end plugin creation workflow with component design, implementation, and validation",
                "path": "plugins/plugin-dev/commands/create-plugin.md",
                "frontmatter": {
                  "description": "Guided end-to-end plugin creation workflow with component design, implementation, and validation",
                  "argument-hint": "Optional plugin description",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "Grep",
                    "Glob",
                    "Bash",
                    "TodoWrite",
                    "AskUserQuestion",
                    "Skill",
                    "Task"
                  ]
                },
                "content": "# Plugin Creation Workflow\n\nGuide the user through creating a complete, high-quality Claude Code plugin from initial concept to tested implementation. Follow a systematic approach: understand requirements, design components, clarify details, implement following best practices, validate, and test.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities about plugin purpose, triggering, scope, and components. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation.\n- **Load relevant skills**: Use the Skill tool to load plugin-dev skills when needed (plugin-structure, hook-development, agent-development, etc.)\n- **Use specialized agents**: Leverage agent-creator, plugin-validator, and skill-reviewer agents for AI-assisted development\n- **Follow best practices**: Apply patterns from plugin-dev's own implementation\n- **Progressive disclosure**: Create lean skills with references/examples\n- **Use TodoWrite**: Track all progress throughout all phases\n\n**Initial request:** $ARGUMENTS\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what plugin needs to be built and what problem it solves\n\n**Actions**:\n1. Create todo list with all 7 phases\n2. If plugin purpose is clear from arguments:\n   - Summarize understanding\n   - Identify plugin type (integration, workflow, analysis, toolkit, etc.)\n3. If plugin purpose is unclear, ask user:\n   - What problem does this plugin solve?\n   - Who will use it and when?\n   - What should it do?\n   - Any similar plugins to reference?\n4. Summarize understanding and confirm with user before proceeding\n\n**Output**: Clear statement of plugin purpose and target users\n\n---\n\n## Phase 2: Component Planning\n\n**Goal**: Determine what plugin components are needed\n\n**MUST load plugin-structure skill** using Skill tool before this phase.\n\n**Actions**:\n1. Load plugin-structure skill to understand component types\n2. Analyze plugin requirements and determine needed components:\n   - **Skills**: Does it need specialized knowledge? (hooks API, MCP patterns, etc.)\n   - **Commands**: User-initiated actions? (deploy, configure, analyze)\n   - **Agents**: Autonomous tasks? (validation, generation, analysis)\n   - **Hooks**: Event-driven automation? (validation, notifications)\n   - **MCP**: External service integration? (databases, APIs)\n   - **Settings**: User configuration? (.local.md files)\n3. For each component type needed, identify:\n   - How many of each type\n   - What each one does\n   - Rough triggering/usage patterns\n4. Present component plan to user as table:\n   ```\n   | Component Type | Count | Purpose |\n   |----------------|-------|---------|\n   | Skills         | 2     | Hook patterns, MCP usage |\n   | Commands       | 3     | Deploy, configure, validate |\n   | Agents         | 1     | Autonomous validation |\n   | Hooks          | 0     | Not needed |\n   | MCP            | 1     | Database integration |\n   ```\n5. Get user confirmation or adjustments\n\n**Output**: Confirmed list of components to create\n\n---\n\n## Phase 3: Detailed Design & Clarifying Questions\n\n**Goal**: Specify each component in detail and resolve all ambiguities\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. For each component in the plan, identify underspecified aspects:\n   - **Skills**: What triggers them? What knowledge do they provide? How detailed?\n   - **Commands**: What arguments? What tools? Interactive or automated?\n   - **Agents**: When to trigger (proactive/reactive)? What tools? Output format?\n   - **Hooks**: Which events? Prompt or command based? Validation criteria?\n   - **MCP**: What server type? Authentication? Which tools?\n   - **Settings**: What fields? Required vs optional? Defaults?\n\n2. **Present all questions to user in organized sections** (one section per component type)\n\n3. **Wait for answers before proceeding to implementation**\n\n4. If user says \"whatever you think is best\", provide specific recommendations and get explicit confirmation\n\n**Example questions for a skill**:\n- What specific user queries should trigger this skill?\n- Should it include utility scripts? What functionality?\n- How detailed should the core SKILL.md be vs references/?\n- Any real-world examples to include?\n\n**Example questions for an agent**:\n- Should this agent trigger proactively after certain actions, or only when explicitly requested?\n- What tools does it need (Read, Write, Bash, etc.)?\n- What should the output format be?\n- Any specific quality standards to enforce?\n\n**Output**: Detailed specification for each component\n\n---\n\n## Phase 4: Plugin Structure Creation\n\n**Goal**: Create plugin directory structure and manifest\n\n**Actions**:\n1. Determine plugin name (kebab-case, descriptive)\n2. Choose plugin location:\n   - Ask user: \"Where should I create the plugin?\"\n   - Offer options: current directory, ../new-plugin-name, custom path\n3. Create directory structure using bash:\n   ```bash\n   mkdir -p plugin-name/.claude-plugin\n   mkdir -p plugin-name/skills     # if needed\n   mkdir -p plugin-name/commands   # if needed\n   mkdir -p plugin-name/agents     # if needed\n   mkdir -p plugin-name/hooks      # if needed\n   ```\n4. Create plugin.json manifest using Write tool:\n   ```json\n   {\n     \"name\": \"plugin-name\",\n     \"version\": \"0.1.0\",\n     \"description\": \"[brief description]\",\n     \"author\": {\n       \"name\": \"[author from user or default]\",\n       \"email\": \"[email or default]\"\n     }\n   }\n   ```\n5. Create README.md template\n6. Create .gitignore if needed (for .claude/*.local.md, etc.)\n7. Initialize git repo if creating new directory\n\n**Output**: Plugin directory structure created and ready for components\n\n---\n\n## Phase 5: Component Implementation\n\n**Goal**: Create each component following best practices\n\n**LOAD RELEVANT SKILLS** before implementing each component type:\n- Skills: Load skill-development skill\n- Commands: Load command-development skill\n- Agents: Load agent-development skill\n- Hooks: Load hook-development skill\n- MCP: Load mcp-integration skill\n- Settings: Load plugin-settings skill\n\n**Actions for each component**:\n\n### For Skills:\n1. Load skill-development skill using Skill tool\n2. For each skill:\n   - Ask user for concrete usage examples (or use from Phase 3)\n   - Plan resources (scripts/, references/, examples/)\n   - Create skill directory structure\n   - Write SKILL.md with:\n     - Third-person description with specific trigger phrases\n     - Lean body (1,500-2,000 words) in imperative form\n     - References to supporting files\n   - Create reference files for detailed content\n   - Create example files for working code\n   - Create utility scripts if needed\n3. Use skill-reviewer agent to validate each skill\n\n### For Commands:\n1. Load command-development skill using Skill tool\n2. For each command:\n   - Write command markdown with frontmatter\n   - Include clear description and argument-hint\n   - Specify allowed-tools (minimal necessary)\n   - Write instructions FOR Claude (not TO user)\n   - Provide usage examples and tips\n   - Reference relevant skills if applicable\n\n### For Agents:\n1. Load agent-development skill using Skill tool\n2. For each agent, use agent-creator agent:\n   - Provide description of what agent should do\n   - Agent-creator generates: identifier, whenToUse with examples, systemPrompt\n   - Create agent markdown file with frontmatter and system prompt\n   - Add appropriate model, color, and tools\n   - Validate with validate-agent.sh script\n\n### For Hooks:\n1. Load hook-development skill using Skill tool\n2. For each hook:\n   - Create hooks/hooks.json with hook configuration\n   - Prefer prompt-based hooks for complex logic\n   - Use ${CLAUDE_PLUGIN_ROOT} for portability\n   - Create hook scripts if needed (in examples/ not scripts/)\n   - Test with validate-hook-schema.sh and test-hook.sh utilities\n\n### For MCP:\n1. Load mcp-integration skill using Skill tool\n2. Create .mcp.json configuration with:\n   - Server type (stdio for local, SSE for hosted)\n   - Command and args (with ${CLAUDE_PLUGIN_ROOT})\n   - extensionToLanguage mapping if LSP\n   - Environment variables as needed\n3. Document required env vars in README\n4. Provide setup instructions\n\n### For Settings:\n1. Load plugin-settings skill using Skill tool\n2. Create settings template in README\n3. Create example .claude/plugin-name.local.md file (as documentation)\n4. Implement settings reading in hooks/commands as needed\n5. Add to .gitignore: `.claude/*.local.md`\n\n**Progress tracking**: Update todos as each component is completed\n\n**Output**: All plugin components implemented\n\n---\n\n## Phase 6: Validation & Quality Check\n\n**Goal**: Ensure plugin meets quality standards and works correctly\n\n**Actions**:\n1. **Run plugin-validator agent**:\n   - Use plugin-validator agent to comprehensively validate plugin\n   - Check: manifest, structure, naming, components, security\n   - Review validation report\n\n2. **Fix critical issues**:\n   - Address any critical errors from validation\n   - Fix any warnings that indicate real problems\n\n3. **Review with skill-reviewer** (if plugin has skills):\n   - For each skill, use skill-reviewer agent\n   - Check description quality, progressive disclosure, writing style\n   - Apply recommendations\n\n4. **Test agent triggering** (if plugin has agents):\n   - For each agent, verify <example> blocks are clear\n   - Check triggering conditions are specific\n   - Run validate-agent.sh on agent files\n\n5. **Test hook configuration** (if plugin has hooks):\n   - Run validate-hook-schema.sh on hooks/hooks.json\n   - Test hook scripts with test-hook.sh\n   - Verify ${CLAUDE_PLUGIN_ROOT} usage\n\n6. **Present findings**:\n   - Summary of validation results\n   - Any remaining issues\n   - Overall quality assessment\n\n7. **Ask user**: \"Validation complete. Issues found: [count critical], [count warnings]. Would you like me to fix them now, or proceed to testing?\"\n\n**Output**: Plugin validated and ready for testing\n\n---\n\n## Phase 7: Testing & Verification\n\n**Goal**: Test that plugin works correctly in Claude Code\n\n**Actions**:\n1. **Installation instructions**:\n   - Show user how to test locally:\n     ```bash\n     cc --plugin-dir /path/to/plugin-name\n     ```\n   - Or copy to `.claude-plugin/` for project testing\n\n2. **Verification checklist** for user to perform:\n   - [ ] Skills load when triggered (ask questions with trigger phrases)\n   - [ ] Commands appear in `/help` and execute correctly\n   - [ ] Agents trigger on appropriate scenarios\n   - [ ] Hooks activate on events (if applicable)\n   - [ ] MCP servers connect (if applicable)\n   - [ ] Settings files work (if applicable)\n\n3. **Testing recommendations**:\n   - For skills: Ask questions using trigger phrases from descriptions\n   - For commands: Run `/plugin-name:command-name` with various arguments\n   - For agents: Create scenarios matching agent examples\n   - For hooks: Use `claude --debug` to see hook execution\n   - For MCP: Use `/mcp` to verify servers and tools\n\n4. **Ask user**: \"I've prepared the plugin for testing. Would you like me to guide you through testing each component, or do you want to test it yourself?\"\n\n5. **If user wants guidance**, walk through testing each component with specific test cases\n\n**Output**: Plugin tested and verified working\n\n---\n\n## Phase 8: Documentation & Next Steps\n\n**Goal**: Ensure plugin is well-documented and ready for distribution\n\n**Actions**:\n1. **Verify README completeness**:\n   - Check README has: overview, features, installation, prerequisites, usage\n   - For MCP plugins: Document required environment variables\n   - For hook plugins: Explain hook activation\n   - For settings: Provide configuration templates\n\n2. **Add marketplace entry** (if publishing):\n   - Show user how to add to marketplace.json\n   - Help draft marketplace description\n   - Suggest category and tags\n\n3. **Create summary**:\n   - Mark all todos complete\n   - List what was created:\n     - Plugin name and purpose\n     - Components created (X skills, Y commands, Z agents, etc.)\n     - Key files and their purposes\n     - Total file count and structure\n   - Next steps:\n     - Testing recommendations\n     - Publishing to marketplace (if desired)\n     - Iteration based on usage\n\n4. **Suggest improvements** (optional):\n   - Additional components that could enhance plugin\n   - Integration opportunities\n   - Testing strategies\n\n**Output**: Complete, documented plugin ready for use or publication\n\n---\n\n## Important Notes\n\n### Throughout All Phases\n\n- **Use TodoWrite** to track progress at every phase\n- **Load skills with Skill tool** when working on specific component types\n- **Use specialized agents** (agent-creator, plugin-validator, skill-reviewer)\n- **Ask for user confirmation** at key decision points\n- **Follow plugin-dev's own patterns** as reference examples\n- **Apply best practices**:\n  - Third-person descriptions for skills\n  - Imperative form in skill bodies\n  - Commands written FOR Claude\n  - Strong trigger phrases\n  - ${CLAUDE_PLUGIN_ROOT} for portability\n  - Progressive disclosure\n  - Security-first (HTTPS, no hardcoded credentials)\n\n### Key Decision Points (Wait for User)\n\n1. After Phase 1: Confirm plugin purpose\n2. After Phase 2: Approve component plan\n3. After Phase 3: Proceed to implementation\n4. After Phase 6: Fix issues or proceed\n5. After Phase 7: Continue to documentation\n\n### Skills to Load by Phase\n\n- **Phase 2**: plugin-structure\n- **Phase 5**: skill-development, command-development, agent-development, hook-development, mcp-integration, plugin-settings (as needed)\n- **Phase 6**: (agents will use skills automatically)\n\n### Quality Standards\n\nEvery component must meet these standards:\n- âœ… Follows plugin-dev's proven patterns\n- âœ… Uses correct naming conventions\n- âœ… Has strong trigger conditions (skills/agents)\n- âœ… Includes working examples\n- âœ… Properly documented\n- âœ… Validated with utilities\n- âœ… Tested in Claude Code\n\n---\n\n## Example Workflow\n\n### User Request\n\"Create a plugin for managing database migrations\"\n\n### Phase 1: Discovery\n- Understand: Migration management, database schema versioning\n- Confirm: User wants to create, run, rollback migrations\n\n### Phase 2: Component Planning\n- Skills: 1 (migration best practices)\n- Commands: 3 (create-migration, run-migrations, rollback)\n- Agents: 1 (migration-validator)\n- MCP: 1 (database connection)\n\n### Phase 3: Clarifying Questions\n- Which databases? (PostgreSQL, MySQL, etc.)\n- Migration file format? (SQL, code-based?)\n- Should agent validate before applying?\n- What MCP tools needed? (query, execute, schema)\n\n### Phase 4-8: Implementation, Validation, Testing, Documentation\n\n---\n\n**Begin with Phase 1: Discovery**"
              }
            ],
            "skills": [
              {
                "name": "Agent Development",
                "description": "This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins.",
                "path": "plugins/plugin-dev/skills/agent-development/SKILL.md",
                "frontmatter": {
                  "name": "Agent Development",
                  "description": "This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins.",
                  "version": "0.1.0"
                },
                "content": "# Agent Development for Claude Code Plugins\n\n## Overview\n\nAgents are autonomous subprocesses that handle complex, multi-step tasks independently. Understanding agent structure, triggering conditions, and system prompt design enables creating powerful autonomous capabilities.\n\n**Key concepts:**\n- Agents are FOR autonomous work, commands are FOR user-initiated actions\n- Markdown file format with YAML frontmatter\n- Triggering via description field with examples\n- System prompt defines agent behavior\n- Model and color customization\n\n## Agent File Structure\n\n### Complete Format\n\n```markdown\n---\nname: agent-identifier\ndescription: Use this agent when [triggering conditions]. Examples:\n\n<example>\nContext: [Situation description]\nuser: \"[User request]\"\nassistant: \"[How assistant should respond and use this agent]\"\n<commentary>\n[Why this agent should be triggered]\n</commentary>\n</example>\n\n<example>\n[Additional example...]\n</example>\n\nmodel: inherit\ncolor: blue\ntools: [\"Read\", \"Write\", \"Grep\"]\n---\n\nYou are [agent role description]...\n\n**Your Core Responsibilities:**\n1. [Responsibility 1]\n2. [Responsibility 2]\n\n**Analysis Process:**\n[Step-by-step workflow]\n\n**Output Format:**\n[What to return]\n```\n\n## Frontmatter Fields\n\n### name (required)\n\nAgent identifier used for namespacing and invocation.\n\n**Format:** lowercase, numbers, hyphens only\n**Length:** 3-50 characters\n**Pattern:** Must start and end with alphanumeric\n\n**Good examples:**\n- `code-reviewer`\n- `test-generator`\n- `api-docs-writer`\n- `security-analyzer`\n\n**Bad examples:**\n- `helper` (too generic)\n- `-agent-` (starts/ends with hyphen)\n- `my_agent` (underscores not allowed)\n- `ag` (too short, < 3 chars)\n\n### description (required)\n\nDefines when Claude should trigger this agent. **This is the most critical field.**\n\n**Must include:**\n1. Triggering conditions (\"Use this agent when...\")\n2. Multiple `<example>` blocks showing usage\n3. Context, user request, and assistant response in each example\n4. `<commentary>` explaining why agent triggers\n\n**Format:**\n```\nUse this agent when [conditions]. Examples:\n\n<example>\nContext: [Scenario description]\nuser: \"[What user says]\"\nassistant: \"[How Claude should respond]\"\n<commentary>\n[Why this agent is appropriate]\n</commentary>\n</example>\n\n[More examples...]\n```\n\n**Best practices:**\n- Include 2-4 concrete examples\n- Show proactive and reactive triggering\n- Cover different phrasings of same intent\n- Explain reasoning in commentary\n- Be specific about when NOT to use the agent\n\n### model (required)\n\nWhich model the agent should use.\n\n**Options:**\n- `inherit` - Use same model as parent (recommended)\n- `sonnet` - Claude Sonnet (balanced)\n- `opus` - Claude Opus (most capable, expensive)\n- `haiku` - Claude Haiku (fast, cheap)\n\n**Recommendation:** Use `inherit` unless agent needs specific model capabilities.\n\n### color (required)\n\nVisual identifier for agent in UI.\n\n**Options:** `blue`, `cyan`, `green`, `yellow`, `magenta`, `red`\n\n**Guidelines:**\n- Choose distinct colors for different agents in same plugin\n- Use consistent colors for similar agent types\n- Blue/cyan: Analysis, review\n- Green: Success-oriented tasks\n- Yellow: Caution, validation\n- Red: Critical, security\n- Magenta: Creative, generation\n\n### tools (optional)\n\nRestrict agent to specific tools.\n\n**Format:** Array of tool names\n\n```yaml\ntools: [\"Read\", \"Write\", \"Grep\", \"Bash\"]\n```\n\n**Default:** If omitted, agent has access to all tools\n\n**Best practice:** Limit tools to minimum needed (principle of least privilege)\n\n**Common tool sets:**\n- Read-only analysis: `[\"Read\", \"Grep\", \"Glob\"]`\n- Code generation: `[\"Read\", \"Write\", \"Grep\"]`\n- Testing: `[\"Read\", \"Bash\", \"Grep\"]`\n- Full access: Omit field or use `[\"*\"]`\n\n## System Prompt Design\n\nThe markdown body becomes the agent's system prompt. Write in second person, addressing the agent directly.\n\n### Structure\n\n**Standard template:**\n```markdown\nYou are [role] specializing in [domain].\n\n**Your Core Responsibilities:**\n1. [Primary responsibility]\n2. [Secondary responsibility]\n3. [Additional responsibilities...]\n\n**Analysis Process:**\n1. [Step one]\n2. [Step two]\n3. [Step three]\n[...]\n\n**Quality Standards:**\n- [Standard 1]\n- [Standard 2]\n\n**Output Format:**\nProvide results in this format:\n- [What to include]\n- [How to structure]\n\n**Edge Cases:**\nHandle these situations:\n- [Edge case 1]: [How to handle]\n- [Edge case 2]: [How to handle]\n```\n\n### Best Practices\n\nâœ… **DO:**\n- Write in second person (\"You are...\", \"You will...\")\n- Be specific about responsibilities\n- Provide step-by-step process\n- Define output format\n- Include quality standards\n- Address edge cases\n- Keep under 10,000 characters\n\nâŒ **DON'T:**\n- Write in first person (\"I am...\", \"I will...\")\n- Be vague or generic\n- Omit process steps\n- Leave output format undefined\n- Skip quality guidance\n- Ignore error cases\n\n## Creating Agents\n\n### Method 1: AI-Assisted Generation\n\nUse this prompt pattern (extracted from Claude Code):\n\n```\nCreate an agent configuration based on this request: \"[YOUR DESCRIPTION]\"\n\nRequirements:\n1. Extract core intent and responsibilities\n2. Design expert persona for the domain\n3. Create comprehensive system prompt with:\n   - Clear behavioral boundaries\n   - Specific methodologies\n   - Edge case handling\n   - Output format\n4. Create identifier (lowercase, hyphens, 3-50 chars)\n5. Write description with triggering conditions\n6. Include 2-3 <example> blocks showing when to use\n\nReturn JSON with:\n{\n  \"identifier\": \"agent-name\",\n  \"whenToUse\": \"Use this agent when... Examples: <example>...</example>\",\n  \"systemPrompt\": \"You are...\"\n}\n```\n\nThen convert to agent file format with frontmatter.\n\nSee `examples/agent-creation-prompt.md` for complete template.\n\n### Method 2: Manual Creation\n\n1. Choose agent identifier (3-50 chars, lowercase, hyphens)\n2. Write description with examples\n3. Select model (usually `inherit`)\n4. Choose color for visual identification\n5. Define tools (if restricting access)\n6. Write system prompt with structure above\n7. Save as `agents/agent-name.md`\n\n## Validation Rules\n\n### Identifier Validation\n\n```\nâœ… Valid: code-reviewer, test-gen, api-analyzer-v2\nâŒ Invalid: ag (too short), -start (starts with hyphen), my_agent (underscore)\n```\n\n**Rules:**\n- 3-50 characters\n- Lowercase letters, numbers, hyphens only\n- Must start and end with alphanumeric\n- No underscores, spaces, or special characters\n\n### Description Validation\n\n**Length:** 10-5,000 characters\n**Must include:** Triggering conditions and examples\n**Best:** 200-1,000 characters with 2-4 examples\n\n### System Prompt Validation\n\n**Length:** 20-10,000 characters\n**Best:** 500-3,000 characters\n**Structure:** Clear responsibilities, process, output format\n\n## Agent Organization\n\n### Plugin Agents Directory\n\n```\nplugin-name/\nâ””â”€â”€ agents/\n    â”œâ”€â”€ analyzer.md\n    â”œâ”€â”€ reviewer.md\n    â””â”€â”€ generator.md\n```\n\nAll `.md` files in `agents/` are auto-discovered.\n\n### Namespacing\n\nAgents are namespaced automatically:\n- Single plugin: `agent-name`\n- With subdirectories: `plugin:subdir:agent-name`\n\n## Testing Agents\n\n### Test Triggering\n\nCreate test scenarios to verify agent triggers correctly:\n\n1. Write agent with specific triggering examples\n2. Use similar phrasing to examples in test\n3. Check Claude loads the agent\n4. Verify agent provides expected functionality\n\n### Test System Prompt\n\nEnsure system prompt is complete:\n\n1. Give agent typical task\n2. Check it follows process steps\n3. Verify output format is correct\n4. Test edge cases mentioned in prompt\n5. Confirm quality standards are met\n\n## Quick Reference\n\n### Minimal Agent\n\n```markdown\n---\nname: simple-agent\ndescription: Use this agent when... Examples: <example>...</example>\nmodel: inherit\ncolor: blue\n---\n\nYou are an agent that [does X].\n\nProcess:\n1. [Step 1]\n2. [Step 2]\n\nOutput: [What to provide]\n```\n\n### Frontmatter Fields Summary\n\n| Field | Required | Format | Example |\n|-------|----------|--------|---------|\n| name | Yes | lowercase-hyphens | code-reviewer |\n| description | Yes | Text + examples | Use when... <example>... |\n| model | Yes | inherit/sonnet/opus/haiku | inherit |\n| color | Yes | Color name | blue |\n| tools | No | Array of tool names | [\"Read\", \"Grep\"] |\n\n### Best Practices\n\n**DO:**\n- âœ… Include 2-4 concrete examples in description\n- âœ… Write specific triggering conditions\n- âœ… Use `inherit` for model unless specific need\n- âœ… Choose appropriate tools (least privilege)\n- âœ… Write clear, structured system prompts\n- âœ… Test agent triggering thoroughly\n\n**DON'T:**\n- âŒ Use generic descriptions without examples\n- âŒ Omit triggering conditions\n- âŒ Give all agents same color\n- âŒ Grant unnecessary tool access\n- âŒ Write vague system prompts\n- âŒ Skip testing\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed guidance, consult:\n\n- **`references/system-prompt-design.md`** - Complete system prompt patterns\n- **`references/triggering-examples.md`** - Example formats and best practices\n- **`references/agent-creation-system-prompt.md`** - The exact prompt from Claude Code\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`agent-creation-prompt.md`** - AI-assisted agent generation template\n- **`complete-agent-examples.md`** - Full agent examples for different use cases\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-agent.sh`** - Validate agent file structure\n- **`test-agent-trigger.sh`** - Test if agent triggers correctly\n\n## Implementation Workflow\n\nTo create an agent for a plugin:\n\n1. Define agent purpose and triggering conditions\n2. Choose creation method (AI-assisted or manual)\n3. Create `agents/agent-name.md` file\n4. Write frontmatter with all required fields\n5. Write system prompt following best practices\n6. Include 2-4 triggering examples in description\n7. Validate with `scripts/validate-agent.sh`\n8. Test triggering with real scenarios\n9. Document agent in plugin README\n\nFocus on clear triggering conditions and comprehensive system prompts for autonomous operation."
              },
              {
                "name": "Command Development",
                "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
                "path": "plugins/plugin-dev/skills/command-development/SKILL.md",
                "frontmatter": {
                  "name": "Command Development",
                  "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
                  "version": "0.2.0"
                },
                "content": "# Command Development for Claude Code\n\n## Overview\n\nSlash commands are frequently-used prompts defined as Markdown files that Claude executes during interactive sessions. Understanding command structure, frontmatter options, and dynamic features enables creating powerful, reusable workflows.\n\n**Key concepts:**\n- Markdown file format for commands\n- YAML frontmatter for configuration\n- Dynamic arguments and file references\n- Bash execution for context\n- Command organization and namespacing\n\n## Command Basics\n\n### What is a Slash Command?\n\nA slash command is a Markdown file containing a prompt that Claude executes when invoked. Commands provide:\n- **Reusability**: Define once, use repeatedly\n- **Consistency**: Standardize common workflows\n- **Sharing**: Distribute across team or projects\n- **Efficiency**: Quick access to complex prompts\n\n### Critical: Commands are Instructions FOR Claude\n\n**Commands are written for agent consumption, not human consumption.**\n\nWhen a user invokes `/command-name`, the command content becomes Claude's instructions. Write commands as directives TO Claude about what to do, not as messages TO the user.\n\n**Correct approach (instructions for Claude):**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication issues\n\nProvide specific line numbers and severity ratings.\n```\n\n**Incorrect approach (messages to user):**\n```markdown\nThis command will review your code for security issues.\nYou'll receive a report with vulnerability details.\n```\n\nThe first example tells Claude what to do. The second tells the user what will happen but doesn't instruct Claude. Always use the first approach.\n\n### Command Locations\n\n**Project commands** (shared with team):\n- Location: `.claude/commands/`\n- Scope: Available in specific project\n- Label: Shown as \"(project)\" in `/help`\n- Use for: Team workflows, project-specific tasks\n\n**Personal commands** (available everywhere):\n- Location: `~/.claude/commands/`\n- Scope: Available in all projects\n- Label: Shown as \"(user)\" in `/help`\n- Use for: Personal workflows, cross-project utilities\n\n**Plugin commands** (bundled with plugins):\n- Location: `plugin-name/commands/`\n- Scope: Available when plugin installed\n- Label: Shown as \"(plugin-name)\" in `/help`\n- Use for: Plugin-specific functionality\n\n## File Format\n\n### Basic Structure\n\nCommands are Markdown files with `.md` extension:\n\n```\n.claude/commands/\nâ”œâ”€â”€ review.md           # /review command\nâ”œâ”€â”€ test.md             # /test command\nâ””â”€â”€ deploy.md           # /deploy command\n```\n\n**Simple command:**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication bypass\n- Insecure data handling\n```\n\nNo frontmatter needed for basic commands.\n\n### With YAML Frontmatter\n\nAdd configuration using YAML frontmatter:\n\n```markdown\n---\ndescription: Review code for security issues\nallowed-tools: Read, Grep, Bash(git:*)\nmodel: sonnet\n---\n\nReview this code for security vulnerabilities...\n```\n\n## YAML Frontmatter Fields\n\n### description\n\n**Purpose:** Brief description shown in `/help`\n**Type:** String\n**Default:** First line of command prompt\n\n```yaml\n---\ndescription: Review pull request for code quality\n---\n```\n\n**Best practice:** Clear, actionable description (under 60 characters)\n\n### allowed-tools\n\n**Purpose:** Specify which tools command can use\n**Type:** String or Array\n**Default:** Inherits from conversation\n\n```yaml\n---\nallowed-tools: Read, Write, Edit, Bash(git:*)\n---\n```\n\n**Patterns:**\n- `Read, Write, Edit` - Specific tools\n- `Bash(git:*)` - Bash with git commands only\n- `*` - All tools (rarely needed)\n\n**Use when:** Command requires specific tool access\n\n### model\n\n**Purpose:** Specify model for command execution\n**Type:** String (sonnet, opus, haiku)\n**Default:** Inherits from conversation\n\n```yaml\n---\nmodel: haiku\n---\n```\n\n**Use cases:**\n- `haiku` - Fast, simple commands\n- `sonnet` - Standard workflows\n- `opus` - Complex analysis\n\n### argument-hint\n\n**Purpose:** Document expected arguments for autocomplete\n**Type:** String\n**Default:** None\n\n```yaml\n---\nargument-hint: [pr-number] [priority] [assignee]\n---\n```\n\n**Benefits:**\n- Helps users understand command arguments\n- Improves command discovery\n- Documents command interface\n\n### disable-model-invocation\n\n**Purpose:** Prevent SlashCommand tool from programmatically calling command\n**Type:** Boolean\n**Default:** false\n\n```yaml\n---\ndisable-model-invocation: true\n---\n```\n\n**Use when:** Command should only be manually invoked\n\n## Dynamic Arguments\n\n### Using $ARGUMENTS\n\nCapture all arguments as single string:\n\n```markdown\n---\ndescription: Fix issue by number\nargument-hint: [issue-number]\n---\n\nFix issue #$ARGUMENTS following our coding standards and best practices.\n```\n\n**Usage:**\n```\n> /fix-issue 123\n> /fix-issue 456\n```\n\n**Expands to:**\n```\nFix issue #123 following our coding standards...\nFix issue #456 following our coding standards...\n```\n\n### Using Positional Arguments\n\nCapture individual arguments with `$1`, `$2`, `$3`, etc.:\n\n```markdown\n---\ndescription: Review PR with priority and assignee\nargument-hint: [pr-number] [priority] [assignee]\n---\n\nReview pull request #$1 with priority level $2.\nAfter review, assign to $3 for follow-up.\n```\n\n**Usage:**\n```\n> /review-pr 123 high alice\n```\n\n**Expands to:**\n```\nReview pull request #123 with priority level high.\nAfter review, assign to alice for follow-up.\n```\n\n### Combining Arguments\n\nMix positional and remaining arguments:\n\n```markdown\nDeploy $1 to $2 environment with options: $3\n```\n\n**Usage:**\n```\n> /deploy api staging --force --skip-tests\n```\n\n**Expands to:**\n```\nDeploy api to staging environment with options: --force --skip-tests\n```\n\n## File References\n\n### Using @ Syntax\n\nInclude file contents in command:\n\n```markdown\n---\ndescription: Review specific file\nargument-hint: [file-path]\n---\n\nReview @$1 for:\n- Code quality\n- Best practices\n- Potential bugs\n```\n\n**Usage:**\n```\n> /review-file src/api/users.ts\n```\n\n**Effect:** Claude reads `src/api/users.ts` before processing command\n\n### Multiple File References\n\nReference multiple files:\n\n```markdown\nCompare @src/old-version.js with @src/new-version.js\n\nIdentify:\n- Breaking changes\n- New features\n- Bug fixes\n```\n\n### Static File References\n\nReference known files without arguments:\n\n```markdown\nReview @package.json and @tsconfig.json for consistency\n\nEnsure:\n- TypeScript version matches\n- Dependencies are aligned\n- Build configuration is correct\n```\n\n## Bash Execution in Commands\n\nCommands can execute bash commands inline to dynamically gather context before Claude processes the command. This is useful for including repository state, environment information, or project-specific context.\n\n**When to use:**\n- Include dynamic context (git status, environment vars, etc.)\n- Gather project/repository state\n- Build context-aware workflows\n\n**Implementation details:**\nFor complete syntax, examples, and best practices, see `references/plugin-features-reference.md` section on bash execution. The reference includes the exact syntax and multiple working examples to avoid execution issues\n\n## Command Organization\n\n### Flat Structure\n\nSimple organization for small command sets:\n\n```\n.claude/commands/\nâ”œâ”€â”€ build.md\nâ”œâ”€â”€ test.md\nâ”œâ”€â”€ deploy.md\nâ”œâ”€â”€ review.md\nâ””â”€â”€ docs.md\n```\n\n**Use when:** 5-15 commands, no clear categories\n\n### Namespaced Structure\n\nOrganize commands in subdirectories:\n\n```\n.claude/commands/\nâ”œâ”€â”€ ci/\nâ”‚   â”œâ”€â”€ build.md        # /build (project:ci)\nâ”‚   â”œâ”€â”€ test.md         # /test (project:ci)\nâ”‚   â””â”€â”€ lint.md         # /lint (project:ci)\nâ”œâ”€â”€ git/\nâ”‚   â”œâ”€â”€ commit.md       # /commit (project:git)\nâ”‚   â””â”€â”€ pr.md           # /pr (project:git)\nâ””â”€â”€ docs/\n    â”œâ”€â”€ generate.md     # /generate (project:docs)\n    â””â”€â”€ publish.md      # /publish (project:docs)\n```\n\n**Benefits:**\n- Logical grouping by category\n- Namespace shown in `/help`\n- Easier to find related commands\n\n**Use when:** 15+ commands, clear categories\n\n## Best Practices\n\n### Command Design\n\n1. **Single responsibility:** One command, one task\n2. **Clear descriptions:** Self-explanatory in `/help`\n3. **Explicit dependencies:** Use `allowed-tools` when needed\n4. **Document arguments:** Always provide `argument-hint`\n5. **Consistent naming:** Use verb-noun pattern (review-pr, fix-issue)\n\n### Argument Handling\n\n1. **Validate arguments:** Check for required arguments in prompt\n2. **Provide defaults:** Suggest defaults when arguments missing\n3. **Document format:** Explain expected argument format\n4. **Handle edge cases:** Consider missing or invalid arguments\n\n```markdown\n---\nargument-hint: [pr-number]\n---\n\n$IF($1,\n  Review PR #$1,\n  Please provide a PR number. Usage: /review-pr [number]\n)\n```\n\n### File References\n\n1. **Explicit paths:** Use clear file paths\n2. **Check existence:** Handle missing files gracefully\n3. **Relative paths:** Use project-relative paths\n4. **Glob support:** Consider using Glob tool for patterns\n\n### Bash Commands\n\n1. **Limit scope:** Use `Bash(git:*)` not `Bash(*)`\n2. **Safe commands:** Avoid destructive operations\n3. **Handle errors:** Consider command failures\n4. **Keep fast:** Long-running commands slow invocation\n\n### Documentation\n\n1. **Add comments:** Explain complex logic\n2. **Provide examples:** Show usage in comments\n3. **List requirements:** Document dependencies\n4. **Version commands:** Note breaking changes\n\n```markdown\n---\ndescription: Deploy application to environment\nargument-hint: [environment] [version]\n---\n\n<!--\nUsage: /deploy [staging|production] [version]\nRequires: AWS credentials configured\nExample: /deploy staging v1.2.3\n-->\n\nDeploy application to $1 environment using version $2...\n```\n\n## Common Patterns\n\n### Review Pattern\n\n```markdown\n---\ndescription: Review code changes\nallowed-tools: Read, Bash(git:*)\n---\n\nFiles changed: !`git diff --name-only`\n\nReview each file for:\n1. Code quality and style\n2. Potential bugs or issues\n3. Test coverage\n4. Documentation needs\n\nProvide specific feedback for each file.\n```\n\n### Testing Pattern\n\n```markdown\n---\ndescription: Run tests for specific file\nargument-hint: [test-file]\nallowed-tools: Bash(npm:*)\n---\n\nRun tests: !`npm test $1`\n\nAnalyze results and suggest fixes for failures.\n```\n\n### Documentation Pattern\n\n```markdown\n---\ndescription: Generate documentation for file\nargument-hint: [source-file]\n---\n\nGenerate comprehensive documentation for @$1 including:\n- Function/class descriptions\n- Parameter documentation\n- Return value descriptions\n- Usage examples\n- Edge cases and errors\n```\n\n### Workflow Pattern\n\n```markdown\n---\ndescription: Complete PR workflow\nargument-hint: [pr-number]\nallowed-tools: Bash(gh:*), Read\n---\n\nPR #$1 Workflow:\n\n1. Fetch PR: !`gh pr view $1`\n2. Review changes\n3. Run checks\n4. Approve or request changes\n```\n\n## Troubleshooting\n\n**Command not appearing:**\n- Check file is in correct directory\n- Verify `.md` extension present\n- Ensure valid Markdown format\n- Restart Claude Code\n\n**Arguments not working:**\n- Verify `$1`, `$2` syntax correct\n- Check `argument-hint` matches usage\n- Ensure no extra spaces\n\n**Bash execution failing:**\n- Check `allowed-tools` includes Bash\n- Verify command syntax in backticks\n- Test command in terminal first\n- Check for required permissions\n\n**File references not working:**\n- Verify `@` syntax correct\n- Check file path is valid\n- Ensure Read tool allowed\n- Use absolute or project-relative paths\n\n## Plugin-Specific Features\n\n### CLAUDE_PLUGIN_ROOT Variable\n\nPlugin commands have access to `${CLAUDE_PLUGIN_ROOT}`, an environment variable that resolves to the plugin's absolute path.\n\n**Purpose:**\n- Reference plugin files portably\n- Execute plugin scripts\n- Load plugin configuration\n- Access plugin templates\n\n**Basic usage:**\n\n```markdown\n---\ndescription: Analyze using plugin script\nallowed-tools: Bash(node:*)\n---\n\nRun analysis: !`node ${CLAUDE_PLUGIN_ROOT}/scripts/analyze.js $1`\n\nReview results and report findings.\n```\n\n**Common patterns:**\n\n```markdown\n# Execute plugin script\n!`bash ${CLAUDE_PLUGIN_ROOT}/scripts/script.sh`\n\n# Load plugin configuration\n@${CLAUDE_PLUGIN_ROOT}/config/settings.json\n\n# Use plugin template\n@${CLAUDE_PLUGIN_ROOT}/templates/report.md\n\n# Access plugin resources\n@${CLAUDE_PLUGIN_ROOT}/docs/reference.md\n```\n\n**Why use it:**\n- Works across all installations\n- Portable between systems\n- No hardcoded paths needed\n- Essential for multi-file plugins\n\n### Plugin Command Organization\n\nPlugin commands discovered automatically from `commands/` directory:\n\n```\nplugin-name/\nâ”œâ”€â”€ commands/\nâ”‚   â”œâ”€â”€ foo.md              # /foo (plugin:plugin-name)\nâ”‚   â”œâ”€â”€ bar.md              # /bar (plugin:plugin-name)\nâ”‚   â””â”€â”€ utils/\nâ”‚       â””â”€â”€ helper.md       # /helper (plugin:plugin-name:utils)\nâ””â”€â”€ plugin.json\n```\n\n**Namespace benefits:**\n- Logical command grouping\n- Shown in `/help` output\n- Avoid name conflicts\n- Organize related commands\n\n**Naming conventions:**\n- Use descriptive action names\n- Avoid generic names (test, run)\n- Consider plugin-specific prefix\n- Use hyphens for multi-word names\n\n### Plugin Command Patterns\n\n**Configuration-based pattern:**\n\n```markdown\n---\ndescription: Deploy using plugin configuration\nargument-hint: [environment]\nallowed-tools: Read, Bash(*)\n---\n\nLoad configuration: @${CLAUDE_PLUGIN_ROOT}/config/$1-deploy.json\n\nDeploy to $1 using configuration settings.\nMonitor deployment and report status.\n```\n\n**Template-based pattern:**\n\n```markdown\n---\ndescription: Generate docs from template\nargument-hint: [component]\n---\n\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/docs.md\n\nGenerate documentation for $1 following template structure.\n```\n\n**Multi-script pattern:**\n\n```markdown\n---\ndescription: Complete build workflow\nallowed-tools: Bash(*)\n---\n\nBuild: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh`\nTest: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/test.sh`\nPackage: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/package.sh`\n\nReview outputs and report workflow status.\n```\n\n**See `references/plugin-features-reference.md` for detailed patterns.**\n\n## Integration with Plugin Components\n\nCommands can integrate with other plugin components for powerful workflows.\n\n### Agent Integration\n\nLaunch plugin agents for complex tasks:\n\n```markdown\n---\ndescription: Deep code review\nargument-hint: [file-path]\n---\n\nInitiate comprehensive review of @$1 using the code-reviewer agent.\n\nThe agent will analyze:\n- Code structure\n- Security issues\n- Performance\n- Best practices\n\nAgent uses plugin resources:\n- ${CLAUDE_PLUGIN_ROOT}/config/rules.json\n- ${CLAUDE_PLUGIN_ROOT}/checklists/review.md\n```\n\n**Key points:**\n- Agent must exist in `plugin/agents/` directory\n- Claude uses Task tool to launch agent\n- Document agent capabilities\n- Reference plugin resources agent uses\n\n### Skill Integration\n\nLeverage plugin skills for specialized knowledge:\n\n```markdown\n---\ndescription: Document API with standards\nargument-hint: [api-file]\n---\n\nDocument API in @$1 following plugin standards.\n\nUse the api-docs-standards skill to ensure:\n- Complete endpoint documentation\n- Consistent formatting\n- Example quality\n- Error documentation\n\nGenerate production-ready API docs.\n```\n\n**Key points:**\n- Skill must exist in `plugin/skills/` directory\n- Mention skill name to trigger invocation\n- Document skill purpose\n- Explain what skill provides\n\n### Hook Coordination\n\nDesign commands that work with plugin hooks:\n- Commands can prepare state for hooks to process\n- Hooks execute automatically on tool events\n- Commands should document expected hook behavior\n- Guide Claude on interpreting hook output\n\nSee `references/plugin-features-reference.md` for examples of commands that coordinate with hooks\n\n### Multi-Component Workflows\n\nCombine agents, skills, and scripts:\n\n```markdown\n---\ndescription: Comprehensive review workflow\nargument-hint: [file]\nallowed-tools: Bash(node:*), Read\n---\n\nTarget: @$1\n\nPhase 1 - Static Analysis:\n!`node ${CLAUDE_PLUGIN_ROOT}/scripts/lint.js $1`\n\nPhase 2 - Deep Review:\nLaunch code-reviewer agent for detailed analysis.\n\nPhase 3 - Standards Check:\nUse coding-standards skill for validation.\n\nPhase 4 - Report:\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/review.md\n\nCompile findings into report following template.\n```\n\n**When to use:**\n- Complex multi-step workflows\n- Leverage multiple plugin capabilities\n- Require specialized analysis\n- Need structured outputs\n\n## Validation Patterns\n\nCommands should validate inputs and resources before processing.\n\n### Argument Validation\n\n```markdown\n---\ndescription: Deploy with validation\nargument-hint: [environment]\n---\n\nValidate environment: !`echo \"$1\" | grep -E \"^(dev|staging|prod)$\" || echo \"INVALID\"`\n\nIf $1 is valid environment:\n  Deploy to $1\nOtherwise:\n  Explain valid environments: dev, staging, prod\n  Show usage: /deploy [environment]\n```\n\n### File Existence Checks\n\n```markdown\n---\ndescription: Process configuration\nargument-hint: [config-file]\n---\n\nCheck file exists: !`test -f $1 && echo \"EXISTS\" || echo \"MISSING\"`\n\nIf file exists:\n  Process configuration: @$1\nOtherwise:\n  Explain where to place config file\n  Show expected format\n  Provide example configuration\n```\n\n### Plugin Resource Validation\n\n```markdown\n---\ndescription: Run plugin analyzer\nallowed-tools: Bash(test:*)\n---\n\nValidate plugin setup:\n- Script: !`test -x ${CLAUDE_PLUGIN_ROOT}/bin/analyze && echo \"âœ“\" || echo \"âœ—\"`\n- Config: !`test -f ${CLAUDE_PLUGIN_ROOT}/config.json && echo \"âœ“\" || echo \"âœ—\"`\n\nIf all checks pass, run analysis.\nOtherwise, report missing components.\n```\n\n### Error Handling\n\n```markdown\n---\ndescription: Build with error handling\nallowed-tools: Bash(*)\n---\n\nExecute build: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh 2>&1 || echo \"BUILD_FAILED\"`\n\nIf build succeeded:\n  Report success and output location\nIf build failed:\n  Analyze error output\n  Suggest likely causes\n  Provide troubleshooting steps\n```\n\n**Best practices:**\n- Validate early in command\n- Provide helpful error messages\n- Suggest corrective actions\n- Handle edge cases gracefully\n\n---\n\nFor detailed frontmatter field specifications, see `references/frontmatter-reference.md`.\nFor plugin-specific features and patterns, see `references/plugin-features-reference.md`.\nFor command pattern examples, see `examples/` directory."
              },
              {
                "name": "Hook Development",
                "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
                "path": "plugins/plugin-dev/skills/hook-development/SKILL.md",
                "frontmatter": {
                  "name": "Hook Development",
                  "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
                  "version": "0.1.0"
                },
                "content": "# Hook Development for Claude Code Plugins\n\n## Overview\n\nHooks are event-driven automation scripts that execute in response to Claude Code events. Use hooks to validate operations, enforce policies, add context, and integrate external tools into workflows.\n\n**Key capabilities:**\n- Validate tool calls before execution (PreToolUse)\n- React to tool results (PostToolUse)\n- Enforce completion standards (Stop, SubagentStop)\n- Load project context (SessionStart)\n- Automate workflows across the development lifecycle\n\n## Hook Types\n\n### Prompt-Based Hooks (Recommended)\n\nUse LLM-driven decision making for context-aware validation:\n\n```json\n{\n  \"type\": \"prompt\",\n  \"prompt\": \"Evaluate if this tool use is appropriate: $TOOL_INPUT\",\n  \"timeout\": 30\n}\n```\n\n**Supported events:** Stop, SubagentStop, UserPromptSubmit, PreToolUse\n\n**Benefits:**\n- Context-aware decisions based on natural language reasoning\n- Flexible evaluation logic without bash scripting\n- Better edge case handling\n- Easier to maintain and extend\n\n### Command Hooks\n\nExecute bash commands for deterministic checks:\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\",\n  \"timeout\": 60\n}\n```\n\n**Use for:**\n- Fast deterministic validations\n- File system operations\n- External tool integrations\n- Performance-critical checks\n\n## Hook Configuration Formats\n\n### Plugin hooks.json Format\n\n**For plugin hooks** in `hooks/hooks.json`, use wrapper format:\n\n```json\n{\n  \"description\": \"Brief explanation of hooks (optional)\",\n  \"hooks\": {\n    \"PreToolUse\": [...],\n    \"Stop\": [...],\n    \"SessionStart\": [...]\n  }\n}\n```\n\n**Key points:**\n- `description` field is optional\n- `hooks` field is required wrapper containing actual hook events\n- This is the **plugin-specific format**\n\n**Example:**\n```json\n{\n  \"description\": \"Validation hooks for code quality\",\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Write\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/validate.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n### Settings Format (Direct)\n\n**For user settings** in `.claude/settings.json`, use direct format:\n\n```json\n{\n  \"PreToolUse\": [...],\n  \"Stop\": [...],\n  \"SessionStart\": [...]\n}\n```\n\n**Key points:**\n- No wrapper - events directly at top level\n- No description field\n- This is the **settings format**\n\n**Important:** The examples below show the hook event structure that goes inside either format. For plugin hooks.json, wrap these in `{\"hooks\": {...}}`.\n\n## Hook Events\n\n### PreToolUse\n\nExecute before any tool runs. Use to approve, deny, or modify tool calls.\n\n**Example (prompt-based):**\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety. Check: system paths, credentials, path traversal, sensitive content. Return 'approve' or 'deny'.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output for PreToolUse:**\n```json\n{\n  \"hookSpecificOutput\": {\n    \"permissionDecision\": \"allow|deny|ask\",\n    \"updatedInput\": {\"field\": \"modified_value\"}\n  },\n  \"systemMessage\": \"Explanation for Claude\"\n}\n```\n\n### PostToolUse\n\nExecute after tool completes. Use to react to results, provide feedback, or log.\n\n**Example:**\n```json\n{\n  \"PostToolUse\": [\n    {\n      \"matcher\": \"Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Analyze edit result for potential issues: syntax errors, security vulnerabilities, breaking changes. Provide feedback.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output behavior:**\n- Exit 0: stdout shown in transcript\n- Exit 2: stderr fed back to Claude\n- systemMessage included in context\n\n### Stop\n\nExecute when main agent considers stopping. Use to validate completeness.\n\n**Example:**\n```json\n{\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion: tests run, build succeeded, questions answered. Return 'approve' to stop or 'block' with reason to continue.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Decision output:**\n```json\n{\n  \"decision\": \"approve|block\",\n  \"reason\": \"Explanation\",\n  \"systemMessage\": \"Additional context\"\n}\n```\n\n### SubagentStop\n\nExecute when subagent considers stopping. Use to ensure subagent completed its task.\n\nSimilar to Stop hook, but for subagents.\n\n### UserPromptSubmit\n\nExecute when user submits a prompt. Use to add context, validate, or block prompts.\n\n**Example:**\n```json\n{\n  \"UserPromptSubmit\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Check if prompt requires security guidance. If discussing auth, permissions, or API security, return relevant warnings.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### SessionStart\n\nExecute when Claude Code session begins. Use to load context and set environment.\n\n**Example:**\n```json\n{\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Special capability:** Persist environment variables using `$CLAUDE_ENV_FILE`:\n```bash\necho \"export PROJECT_TYPE=nodejs\" >> \"$CLAUDE_ENV_FILE\"\n```\n\nSee `examples/load-context.sh` for complete example.\n\n### SessionEnd\n\nExecute when session ends. Use for cleanup, logging, and state preservation.\n\n### PreCompact\n\nExecute before context compaction. Use to add critical information to preserve.\n\n### Notification\n\nExecute when Claude sends notifications. Use to react to user notifications.\n\n## Hook Output Format\n\n### Standard Output (All Hooks)\n\n```json\n{\n  \"continue\": true,\n  \"suppressOutput\": false,\n  \"systemMessage\": \"Message for Claude\"\n}\n```\n\n- `continue`: If false, halt processing (default true)\n- `suppressOutput`: Hide output from transcript (default false)\n- `systemMessage`: Message shown to Claude\n\n### Exit Codes\n\n- `0` - Success (stdout shown in transcript)\n- `2` - Blocking error (stderr fed back to Claude)\n- Other - Non-blocking error\n\n## Hook Input Format\n\nAll hooks receive JSON via stdin with common fields:\n\n```json\n{\n  \"session_id\": \"abc123\",\n  \"transcript_path\": \"/path/to/transcript.txt\",\n  \"cwd\": \"/current/working/dir\",\n  \"permission_mode\": \"ask|allow\",\n  \"hook_event_name\": \"PreToolUse\"\n}\n```\n\n**Event-specific fields:**\n\n- **PreToolUse/PostToolUse:** `tool_name`, `tool_input`, `tool_result`\n- **UserPromptSubmit:** `user_prompt`\n- **Stop/SubagentStop:** `reason`\n\nAccess fields in prompts using `$TOOL_INPUT`, `$TOOL_RESULT`, `$USER_PROMPT`, etc.\n\n## Environment Variables\n\nAvailable in all command hooks:\n\n- `$CLAUDE_PROJECT_DIR` - Project root path\n- `$CLAUDE_PLUGIN_ROOT` - Plugin directory (use for portable paths)\n- `$CLAUDE_ENV_FILE` - SessionStart only: persist env vars here\n- `$CLAUDE_CODE_REMOTE` - Set if running in remote context\n\n**Always use ${CLAUDE_PLUGIN_ROOT} in hook commands for portability:**\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\"\n}\n```\n\n## Plugin Hook Configuration\n\nIn plugins, define hooks in `hooks/hooks.json`:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety\"\n        }\n      ]\n    }\n  ],\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion\"\n        }\n      ]\n    }\n  ],\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\",\n          \"timeout\": 10\n        }\n      ]\n    }\n  ]\n}\n```\n\nPlugin hooks merge with user's hooks and run in parallel.\n\n## Matchers\n\n### Tool Name Matching\n\n**Exact match:**\n```json\n\"matcher\": \"Write\"\n```\n\n**Multiple tools:**\n```json\n\"matcher\": \"Read|Write|Edit\"\n```\n\n**Wildcard (all tools):**\n```json\n\"matcher\": \"*\"\n```\n\n**Regex patterns:**\n```json\n\"matcher\": \"mcp__.*__delete.*\"  // All MCP delete tools\n```\n\n**Note:** Matchers are case-sensitive.\n\n### Common Patterns\n\n```json\n// All MCP tools\n\"matcher\": \"mcp__.*\"\n\n// Specific plugin's MCP tools\n\"matcher\": \"mcp__plugin_asana_.*\"\n\n// All file operations\n\"matcher\": \"Read|Write|Edit\"\n\n// Bash commands only\n\"matcher\": \"Bash\"\n```\n\n## Security Best Practices\n\n### Input Validation\n\nAlways validate inputs in command hooks:\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\ninput=$(cat)\ntool_name=$(echo \"$input\" | jq -r '.tool_name')\n\n# Validate tool name format\nif [[ ! \"$tool_name\" =~ ^[a-zA-Z0-9_]+$ ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Invalid tool name\"}' >&2\n  exit 2\nfi\n```\n\n### Path Safety\n\nCheck for path traversal and sensitive files:\n\n```bash\nfile_path=$(echo \"$input\" | jq -r '.tool_input.file_path')\n\n# Deny path traversal\nif [[ \"$file_path\" == *\"..\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Path traversal detected\"}' >&2\n  exit 2\nfi\n\n# Deny sensitive files\nif [[ \"$file_path\" == *\".env\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Sensitive file\"}' >&2\n  exit 2\nfi\n```\n\nSee `examples/validate-write.sh` and `examples/validate-bash.sh` for complete examples.\n\n### Quote All Variables\n\n```bash\n# GOOD: Quoted\necho \"$file_path\"\ncd \"$CLAUDE_PROJECT_DIR\"\n\n# BAD: Unquoted (injection risk)\necho $file_path\ncd $CLAUDE_PROJECT_DIR\n```\n\n### Set Appropriate Timeouts\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash script.sh\",\n  \"timeout\": 10\n}\n```\n\n**Defaults:** Command hooks (60s), Prompt hooks (30s)\n\n## Performance Considerations\n\n### Parallel Execution\n\nAll matching hooks run **in parallel**:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write\",\n      \"hooks\": [\n        {\"type\": \"command\", \"command\": \"check1.sh\"},  // Parallel\n        {\"type\": \"command\", \"command\": \"check2.sh\"},  // Parallel\n        {\"type\": \"prompt\", \"prompt\": \"Validate...\"}   // Parallel\n      ]\n    }\n  ]\n}\n```\n\n**Design implications:**\n- Hooks don't see each other's output\n- Non-deterministic ordering\n- Design for independence\n\n### Optimization\n\n1. Use command hooks for quick deterministic checks\n2. Use prompt hooks for complex reasoning\n3. Cache validation results in temp files\n4. Minimize I/O in hot paths\n\n## Temporarily Active Hooks\n\nCreate hooks that activate conditionally by checking for a flag file or configuration:\n\n**Pattern: Flag file activation**\n```bash\n#!/bin/bash\n# Only active when flag file exists\nFLAG_FILE=\"$CLAUDE_PROJECT_DIR/.enable-strict-validation\"\n\nif [ ! -f \"$FLAG_FILE\" ]; then\n  # Flag not present, skip validation\n  exit 0\nfi\n\n# Flag present, run validation\ninput=$(cat)\n# ... validation logic ...\n```\n\n**Pattern: Configuration-based activation**\n```bash\n#!/bin/bash\n# Check configuration for activation\nCONFIG_FILE=\"$CLAUDE_PROJECT_DIR/.claude/plugin-config.json\"\n\nif [ -f \"$CONFIG_FILE\" ]; then\n  enabled=$(jq -r '.strictMode // false' \"$CONFIG_FILE\")\n  if [ \"$enabled\" != \"true\" ]; then\n    exit 0  # Not enabled, skip\n  fi\nfi\n\n# Enabled, run hook logic\ninput=$(cat)\n# ... hook logic ...\n```\n\n**Use cases:**\n- Enable strict validation only when needed\n- Temporary debugging hooks\n- Project-specific hook behavior\n- Feature flags for hooks\n\n**Best practice:** Document activation mechanism in plugin README so users know how to enable/disable temporary hooks.\n\n## Hook Lifecycle and Limitations\n\n### Hooks Load at Session Start\n\n**Important:** Hooks are loaded when Claude Code session starts. Changes to hook configuration require restarting Claude Code.\n\n**Cannot hot-swap hooks:**\n- Editing `hooks/hooks.json` won't affect current session\n- Adding new hook scripts won't be recognized\n- Changing hook commands/prompts won't update\n- Must restart Claude Code: exit and run `claude` again\n\n**To test hook changes:**\n1. Edit hook configuration or scripts\n2. Exit Claude Code session\n3. Restart: `claude` or `cc`\n4. New hook configuration loads\n5. Test hooks with `claude --debug`\n\n### Hook Validation at Startup\n\nHooks are validated when Claude Code starts:\n- Invalid JSON in hooks.json causes loading failure\n- Missing scripts cause warnings\n- Syntax errors reported in debug mode\n\nUse `/hooks` command to review loaded hooks in current session.\n\n## Debugging Hooks\n\n### Enable Debug Mode\n\n```bash\nclaude --debug\n```\n\nLook for hook registration, execution logs, input/output JSON, and timing information.\n\n### Test Hook Scripts\n\nTest command hooks directly:\n\n```bash\necho '{\"tool_name\": \"Write\", \"tool_input\": {\"file_path\": \"/test\"}}' | \\\n  bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\n\necho \"Exit code: $?\"\n```\n\n### Validate JSON Output\n\nEnsure hooks output valid JSON:\n\n```bash\noutput=$(./your-hook.sh < test-input.json)\necho \"$output\" | jq .\n```\n\n## Quick Reference\n\n### Hook Events Summary\n\n| Event | When | Use For |\n|-------|------|---------|\n| PreToolUse | Before tool | Validation, modification |\n| PostToolUse | After tool | Feedback, logging |\n| UserPromptSubmit | User input | Context, validation |\n| Stop | Agent stopping | Completeness check |\n| SubagentStop | Subagent done | Task validation |\n| SessionStart | Session begins | Context loading |\n| SessionEnd | Session ends | Cleanup, logging |\n| PreCompact | Before compact | Preserve context |\n| Notification | User notified | Logging, reactions |\n\n### Best Practices\n\n**DO:**\n- âœ… Use prompt-based hooks for complex logic\n- âœ… Use ${CLAUDE_PLUGIN_ROOT} for portability\n- âœ… Validate all inputs in command hooks\n- âœ… Quote all bash variables\n- âœ… Set appropriate timeouts\n- âœ… Return structured JSON output\n- âœ… Test hooks thoroughly\n\n**DON'T:**\n- âŒ Use hardcoded paths\n- âŒ Trust user input without validation\n- âŒ Create long-running hooks\n- âŒ Rely on hook execution order\n- âŒ Modify global state unpredictably\n- âŒ Log sensitive information\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and advanced techniques, consult:\n\n- **`references/patterns.md`** - Common hook patterns (8+ proven patterns)\n- **`references/migration.md`** - Migrating from basic to advanced hooks\n- **`references/advanced.md`** - Advanced use cases and techniques\n\n### Example Hook Scripts\n\nWorking examples in `examples/`:\n\n- **`validate-write.sh`** - File write validation example\n- **`validate-bash.sh`** - Bash command validation example\n- **`load-context.sh`** - SessionStart context loading example\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-hook-schema.sh`** - Validate hooks.json structure and syntax\n- **`test-hook.sh`** - Test hooks with sample input before deployment\n- **`hook-linter.sh`** - Check hook scripts for common issues and best practices\n\n### External Resources\n\n- **Official Docs**: https://docs.claude.com/en/docs/claude-code/hooks\n- **Examples**: See security-guidance plugin in marketplace\n- **Testing**: Use `claude --debug` for detailed logs\n- **Validation**: Use `jq` to validate hook JSON output\n\n## Implementation Workflow\n\nTo implement hooks in a plugin:\n\n1. Identify events to hook into (PreToolUse, Stop, SessionStart, etc.)\n2. Decide between prompt-based (flexible) or command (deterministic) hooks\n3. Write hook configuration in `hooks/hooks.json`\n4. For command hooks, create hook scripts\n5. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n6. Validate configuration with `scripts/validate-hook-schema.sh hooks/hooks.json`\n7. Test hooks with `scripts/test-hook.sh` before deployment\n8. Test in Claude Code with `claude --debug`\n9. Document hooks in plugin README\n\nFocus on prompt-based hooks for most use cases. Reserve command hooks for performance-critical or deterministic checks."
              },
              {
                "name": "MCP Integration",
                "description": "This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration.",
                "path": "plugins/plugin-dev/skills/mcp-integration/SKILL.md",
                "frontmatter": {
                  "name": "MCP Integration",
                  "description": "This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration.",
                  "version": "0.1.0"
                },
                "content": "# MCP Integration for Claude Code Plugins\n\n## Overview\n\nModel Context Protocol (MCP) enables Claude Code plugins to integrate with external services and APIs by providing structured tool access. Use MCP integration to expose external service capabilities as tools within Claude Code.\n\n**Key capabilities:**\n- Connect to external services (databases, APIs, file systems)\n- Provide 10+ related tools from a single service\n- Handle OAuth and complex authentication flows\n- Bundle MCP servers with plugins for automatic setup\n\n## MCP Server Configuration Methods\n\nPlugins can bundle MCP servers in two ways:\n\n### Method 1: Dedicated .mcp.json (Recommended)\n\nCreate `.mcp.json` at plugin root:\n\n```json\n{\n  \"database-tools\": {\n    \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/db-server\",\n    \"args\": [\"--config\", \"${CLAUDE_PLUGIN_ROOT}/config.json\"],\n    \"env\": {\n      \"DB_URL\": \"${DB_URL}\"\n    }\n  }\n}\n```\n\n**Benefits:**\n- Clear separation of concerns\n- Easier to maintain\n- Better for multiple servers\n\n### Method 2: Inline in plugin.json\n\nAdd `mcpServers` field to plugin.json:\n\n```json\n{\n  \"name\": \"my-plugin\",\n  \"version\": \"1.0.0\",\n  \"mcpServers\": {\n    \"plugin-api\": {\n      \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/api-server\",\n      \"args\": [\"--port\", \"8080\"]\n    }\n  }\n}\n```\n\n**Benefits:**\n- Single configuration file\n- Good for simple single-server plugins\n\n## MCP Server Types\n\n### stdio (Local Process)\n\nExecute local MCP servers as child processes. Best for local tools and custom servers.\n\n**Configuration:**\n```json\n{\n  \"filesystem\": {\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/allowed/path\"],\n    \"env\": {\n      \"LOG_LEVEL\": \"debug\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- File system access\n- Local database connections\n- Custom MCP servers\n- NPM-packaged MCP servers\n\n**Process management:**\n- Claude Code spawns and manages the process\n- Communicates via stdin/stdout\n- Terminates when Claude Code exits\n\n### SSE (Server-Sent Events)\n\nConnect to hosted MCP servers with OAuth support. Best for cloud services.\n\n**Configuration:**\n```json\n{\n  \"asana\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.asana.com/sse\"\n  }\n}\n```\n\n**Use cases:**\n- Official hosted MCP servers (Asana, GitHub, etc.)\n- Cloud services with MCP endpoints\n- OAuth-based authentication\n- No local installation needed\n\n**Authentication:**\n- OAuth flows handled automatically\n- User prompted on first use\n- Tokens managed by Claude Code\n\n### HTTP (REST API)\n\nConnect to RESTful MCP servers with token authentication.\n\n**Configuration:**\n```json\n{\n  \"api-service\": {\n    \"type\": \"http\",\n    \"url\": \"https://api.example.com/mcp\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${API_TOKEN}\",\n      \"X-Custom-Header\": \"value\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- REST API-based MCP servers\n- Token-based authentication\n- Custom API backends\n- Stateless interactions\n\n### WebSocket (Real-time)\n\nConnect to WebSocket MCP servers for real-time bidirectional communication.\n\n**Configuration:**\n```json\n{\n  \"realtime-service\": {\n    \"type\": \"ws\",\n    \"url\": \"wss://mcp.example.com/ws\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${TOKEN}\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- Real-time data streaming\n- Persistent connections\n- Push notifications from server\n- Low-latency requirements\n\n## Environment Variable Expansion\n\nAll MCP configurations support environment variable substitution:\n\n**${CLAUDE_PLUGIN_ROOT}** - Plugin directory (always use for portability):\n```json\n{\n  \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/my-server\"\n}\n```\n\n**User environment variables** - From user's shell:\n```json\n{\n  \"env\": {\n    \"API_KEY\": \"${MY_API_KEY}\",\n    \"DATABASE_URL\": \"${DB_URL}\"\n  }\n}\n```\n\n**Best practice:** Document all required environment variables in plugin README.\n\n## MCP Tool Naming\n\nWhen MCP servers provide tools, they're automatically prefixed:\n\n**Format:** `mcp__plugin_<plugin-name>_<server-name>__<tool-name>`\n\n**Example:**\n- Plugin: `asana`\n- Server: `asana`\n- Tool: `create_task`\n- **Full name:** `mcp__plugin_asana_asana__asana_create_task`\n\n### Using MCP Tools in Commands\n\nPre-allow specific MCP tools in command frontmatter:\n\n```markdown\n---\nallowed-tools: [\n  \"mcp__plugin_asana_asana__asana_create_task\",\n  \"mcp__plugin_asana_asana__asana_search_tasks\"\n]\n---\n```\n\n**Wildcard (use sparingly):**\n```markdown\n---\nallowed-tools: [\"mcp__plugin_asana_asana__*\"]\n---\n```\n\n**Best practice:** Pre-allow specific tools, not wildcards, for security.\n\n## Lifecycle Management\n\n**Automatic startup:**\n- MCP servers start when plugin enables\n- Connection established before first tool use\n- Restart required for configuration changes\n\n**Lifecycle:**\n1. Plugin loads\n2. MCP configuration parsed\n3. Server process started (stdio) or connection established (SSE/HTTP/WS)\n4. Tools discovered and registered\n5. Tools available as `mcp__plugin_...__...`\n\n**Viewing servers:**\nUse `/mcp` command to see all servers including plugin-provided ones.\n\n## Authentication Patterns\n\n### OAuth (SSE/HTTP)\n\nOAuth handled automatically by Claude Code:\n\n```json\n{\n  \"type\": \"sse\",\n  \"url\": \"https://mcp.example.com/sse\"\n}\n```\n\nUser authenticates in browser on first use. No additional configuration needed.\n\n### Token-Based (Headers)\n\nStatic or environment variable tokens:\n\n```json\n{\n  \"type\": \"http\",\n  \"url\": \"https://api.example.com\",\n  \"headers\": {\n    \"Authorization\": \"Bearer ${API_TOKEN}\"\n  }\n}\n```\n\nDocument required environment variables in README.\n\n### Environment Variables (stdio)\n\nPass configuration to MCP server:\n\n```json\n{\n  \"command\": \"python\",\n  \"args\": [\"-m\", \"my_mcp_server\"],\n  \"env\": {\n    \"DATABASE_URL\": \"${DB_URL}\",\n    \"API_KEY\": \"${API_KEY}\",\n    \"LOG_LEVEL\": \"info\"\n  }\n}\n```\n\n## Integration Patterns\n\n### Pattern 1: Simple Tool Wrapper\n\nCommands use MCP tools with user interaction:\n\n```markdown\n# Command: create-item.md\n---\nallowed-tools: [\"mcp__plugin_name_server__create_item\"]\n---\n\nSteps:\n1. Gather item details from user\n2. Use mcp__plugin_name_server__create_item\n3. Confirm creation\n```\n\n**Use for:** Adding validation or preprocessing before MCP calls.\n\n### Pattern 2: Autonomous Agent\n\nAgents use MCP tools autonomously:\n\n```markdown\n# Agent: data-analyzer.md\n\nAnalysis Process:\n1. Query data via mcp__plugin_db_server__query\n2. Process and analyze results\n3. Generate insights report\n```\n\n**Use for:** Multi-step MCP workflows without user interaction.\n\n### Pattern 3: Multi-Server Plugin\n\nIntegrate multiple MCP servers:\n\n```json\n{\n  \"github\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.github.com/sse\"\n  },\n  \"jira\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.jira.com/sse\"\n  }\n}\n```\n\n**Use for:** Workflows spanning multiple services.\n\n## Security Best Practices\n\n### Use HTTPS/WSS\n\nAlways use secure connections:\n\n```json\nâœ… \"url\": \"https://mcp.example.com/sse\"\nâŒ \"url\": \"http://mcp.example.com/sse\"\n```\n\n### Token Management\n\n**DO:**\n- âœ… Use environment variables for tokens\n- âœ… Document required env vars in README\n- âœ… Let OAuth flow handle authentication\n\n**DON'T:**\n- âŒ Hardcode tokens in configuration\n- âŒ Commit tokens to git\n- âŒ Share tokens in documentation\n\n### Permission Scoping\n\nPre-allow only necessary MCP tools:\n\n```markdown\nâœ… allowed-tools: [\n  \"mcp__plugin_api_server__read_data\",\n  \"mcp__plugin_api_server__create_item\"\n]\n\nâŒ allowed-tools: [\"mcp__plugin_api_server__*\"]\n```\n\n## Error Handling\n\n### Connection Failures\n\nHandle MCP server unavailability:\n- Provide fallback behavior in commands\n- Inform user of connection issues\n- Check server URL and configuration\n\n### Tool Call Errors\n\nHandle failed MCP operations:\n- Validate inputs before calling MCP tools\n- Provide clear error messages\n- Check rate limiting and quotas\n\n### Configuration Errors\n\nValidate MCP configuration:\n- Test server connectivity during development\n- Validate JSON syntax\n- Check required environment variables\n\n## Performance Considerations\n\n### Lazy Loading\n\nMCP servers connect on-demand:\n- Not all servers connect at startup\n- First tool use triggers connection\n- Connection pooling managed automatically\n\n### Batching\n\nBatch similar requests when possible:\n\n```\n# Good: Single query with filters\ntasks = search_tasks(project=\"X\", assignee=\"me\", limit=50)\n\n# Avoid: Many individual queries\nfor id in task_ids:\n    task = get_task(id)\n```\n\n## Testing MCP Integration\n\n### Local Testing\n\n1. Configure MCP server in `.mcp.json`\n2. Install plugin locally (`.claude-plugin/`)\n3. Run `/mcp` to verify server appears\n4. Test tool calls in commands\n5. Check `claude --debug` logs for connection issues\n\n### Validation Checklist\n\n- [ ] MCP configuration is valid JSON\n- [ ] Server URL is correct and accessible\n- [ ] Required environment variables documented\n- [ ] Tools appear in `/mcp` output\n- [ ] Authentication works (OAuth or tokens)\n- [ ] Tool calls succeed from commands\n- [ ] Error cases handled gracefully\n\n## Debugging\n\n### Enable Debug Logging\n\n```bash\nclaude --debug\n```\n\nLook for:\n- MCP server connection attempts\n- Tool discovery logs\n- Authentication flows\n- Tool call errors\n\n### Common Issues\n\n**Server not connecting:**\n- Check URL is correct\n- Verify server is running (stdio)\n- Check network connectivity\n- Review authentication configuration\n\n**Tools not available:**\n- Verify server connected successfully\n- Check tool names match exactly\n- Run `/mcp` to see available tools\n- Restart Claude Code after config changes\n\n**Authentication failing:**\n- Clear cached auth tokens\n- Re-authenticate\n- Check token scopes and permissions\n- Verify environment variables set\n\n## Quick Reference\n\n### MCP Server Types\n\n| Type | Transport | Best For | Auth |\n|------|-----------|----------|------|\n| stdio | Process | Local tools, custom servers | Env vars |\n| SSE | HTTP | Hosted services, cloud APIs | OAuth |\n| HTTP | REST | API backends, token auth | Tokens |\n| ws | WebSocket | Real-time, streaming | Tokens |\n\n### Configuration Checklist\n\n- [ ] Server type specified (stdio/SSE/HTTP/ws)\n- [ ] Type-specific fields complete (command or url)\n- [ ] Authentication configured\n- [ ] Environment variables documented\n- [ ] HTTPS/WSS used (not HTTP/WS)\n- [ ] ${CLAUDE_PLUGIN_ROOT} used for paths\n\n### Best Practices\n\n**DO:**\n- âœ… Use ${CLAUDE_PLUGIN_ROOT} for portable paths\n- âœ… Document required environment variables\n- âœ… Use secure connections (HTTPS/WSS)\n- âœ… Pre-allow specific MCP tools in commands\n- âœ… Test MCP integration before publishing\n- âœ… Handle connection and tool errors gracefully\n\n**DON'T:**\n- âŒ Hardcode absolute paths\n- âŒ Commit credentials to git\n- âŒ Use HTTP instead of HTTPS\n- âŒ Pre-allow all tools with wildcards\n- âŒ Skip error handling\n- âŒ Forget to document setup\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed information, consult:\n\n- **`references/server-types.md`** - Deep dive on each server type\n- **`references/authentication.md`** - Authentication patterns and OAuth\n- **`references/tool-usage.md`** - Using MCP tools in commands and agents\n\n### Example Configurations\n\nWorking examples in `examples/`:\n\n- **`stdio-server.json`** - Local stdio MCP server\n- **`sse-server.json`** - Hosted SSE server with OAuth\n- **`http-server.json`** - REST API with token auth\n\n### External Resources\n\n- **Official MCP Docs**: https://modelcontextprotocol.io/\n- **Claude Code MCP Docs**: https://docs.claude.com/en/docs/claude-code/mcp\n- **MCP SDK**: @modelcontextprotocol/sdk\n- **Testing**: Use `claude --debug` and `/mcp` command\n\n## Implementation Workflow\n\nTo add MCP integration to a plugin:\n\n1. Choose MCP server type (stdio, SSE, HTTP, ws)\n2. Create `.mcp.json` at plugin root with configuration\n3. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n4. Document required environment variables in README\n5. Test locally with `/mcp` command\n6. Pre-allow MCP tools in relevant commands\n7. Handle authentication (OAuth or tokens)\n8. Test error cases (connection failures, auth errors)\n9. Document MCP integration in plugin README\n\nFocus on stdio for custom/local servers, SSE for hosted services with OAuth."
              },
              {
                "name": "Plugin Settings",
                "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.",
                "path": "plugins/plugin-dev/skills/plugin-settings/SKILL.md",
                "frontmatter": {
                  "name": "Plugin Settings",
                  "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.",
                  "version": "0.1.0"
                },
                "content": "# Plugin Settings Pattern for Claude Code Plugins\n\n## Overview\n\nPlugins can store user-configurable settings and state in `.claude/plugin-name.local.md` files within the project directory. This pattern uses YAML frontmatter for structured configuration and markdown content for prompts or additional context.\n\n**Key characteristics:**\n- File location: `.claude/plugin-name.local.md` in project root\n- Structure: YAML frontmatter + markdown body\n- Purpose: Per-project plugin configuration and state\n- Usage: Read from hooks, commands, and agents\n- Lifecycle: User-managed (not in git, should be in `.gitignore`)\n\n## File Structure\n\n### Basic Template\n\n```markdown\n---\nenabled: true\nsetting1: value1\nsetting2: value2\nnumeric_setting: 42\nlist_setting: [\"item1\", \"item2\"]\n---\n\n# Additional Context\n\nThis markdown body can contain:\n- Task descriptions\n- Additional instructions\n- Prompts to feed back to Claude\n- Documentation or notes\n```\n\n### Example: Plugin State File\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nenabled: true\nstrict_mode: false\nmax_retries: 3\nnotification_level: info\ncoordinator_session: team-leader\n---\n\n# Plugin Configuration\n\nThis plugin is configured for standard validation mode.\nContact @team-lead with questions.\n```\n\n## Reading Settings Files\n\n### From Hooks (Bash Scripts)\n\n**Pattern: Check existence and parse frontmatter**\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\n# Define state file path\nSTATE_FILE=\".claude/my-plugin.local.md\"\n\n# Quick exit if file doesn't exist\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0  # Plugin not configured, skip\nfi\n\n# Parse YAML frontmatter (between --- markers)\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\n\n# Extract individual fields\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\nSTRICT_MODE=$(echo \"$FRONTMATTER\" | grep '^strict_mode:' | sed 's/strict_mode: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n\n# Check if enabled\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Use configuration in hook logic\nif [[ \"$STRICT_MODE\" == \"true\" ]]; then\n  # Apply strict validation\n  # ...\nfi\n```\n\nSee `examples/read-settings-hook.sh` for complete working example.\n\n### From Commands\n\nCommands can read settings files to customize behavior:\n\n```markdown\n---\ndescription: Process data with plugin\nallowed-tools: [\"Read\", \"Bash\"]\n---\n\n# Process Command\n\nSteps:\n1. Check if settings exist at `.claude/my-plugin.local.md`\n2. Read configuration using Read tool\n3. Parse YAML frontmatter to extract settings\n4. Apply settings to processing logic\n5. Execute with configured behavior\n```\n\n### From Agents\n\nAgents can reference settings in their instructions:\n\n```markdown\n---\nname: configured-agent\ndescription: Agent that adapts to project settings\n---\n\nCheck for plugin settings at `.claude/my-plugin.local.md`.\nIf present, parse YAML frontmatter and adapt behavior according to:\n- enabled: Whether plugin is active\n- mode: Processing mode (strict, standard, lenient)\n- Additional configuration fields\n```\n\n## Parsing Techniques\n\n### Extract Frontmatter\n\n```bash\n# Extract everything between --- markers\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n```\n\n### Read Individual Fields\n\n**String fields:**\n```bash\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field_name:' | sed 's/field_name: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n**Boolean fields:**\n```bash\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n# Compare: if [[ \"$ENABLED\" == \"true\" ]]; then\n```\n\n**Numeric fields:**\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n# Use: if [[ $MAX -gt 100 ]]; then\n```\n\n### Read Markdown Body\n\nExtract content after second `---`:\n\n```bash\n# Get everything after closing ---\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n## Common Patterns\n\n### Pattern 1: Temporarily Active Hooks\n\nUse settings file to control hook activation:\n\n```bash\n#!/bin/bash\nSTATE_FILE=\".claude/security-scan.local.md\"\n\n# Quick exit if not configured\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0\nfi\n\n# Read enabled flag\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Run hook logic\n# ...\n```\n\n**Use case:** Enable/disable hooks without editing hooks.json (requires restart).\n\n### Pattern 2: Agent State Management\n\nStore agent-specific state and configuration:\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-agent\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\n---\n\n# Task Assignment\n\nImplement JWT authentication for the API.\n\n**Success Criteria:**\n- Authentication endpoints created\n- Tests passing\n- PR created and CI green\n```\n\nRead from hooks to coordinate agents:\n\n```bash\nAGENT_NAME=$(echo \"$FRONTMATTER\" | grep '^agent_name:' | sed 's/agent_name: *//')\nCOORDINATOR=$(echo \"$FRONTMATTER\" | grep '^coordinator_session:' | sed 's/coordinator_session: *//')\n\n# Send notification to coordinator\ntmux send-keys -t \"$COORDINATOR\" \"Agent $AGENT_NAME completed task\" Enter\n```\n\n### Pattern 3: Configuration-Driven Behavior\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nvalidation_level: strict\nmax_file_size: 1000000\nallowed_extensions: [\".js\", \".ts\", \".tsx\"]\nenable_logging: true\n---\n\n# Validation Configuration\n\nStrict mode enabled for this project.\nAll writes validated against security policies.\n```\n\nUse in hooks or commands:\n\n```bash\nLEVEL=$(echo \"$FRONTMATTER\" | grep '^validation_level:' | sed 's/validation_level: *//')\n\ncase \"$LEVEL\" in\n  strict)\n    # Apply strict validation\n    ;;\n  standard)\n    # Apply standard validation\n    ;;\n  lenient)\n    # Apply lenient validation\n    ;;\nesac\n```\n\n## Creating Settings Files\n\n### From Commands\n\nCommands can create settings files:\n\n```markdown\n# Setup Command\n\nSteps:\n1. Ask user for configuration preferences\n2. Create `.claude/my-plugin.local.md` with YAML frontmatter\n3. Set appropriate values based on user input\n4. Inform user that settings are saved\n5. Remind user to restart Claude Code for hooks to recognize changes\n```\n\n### Template Generation\n\nProvide template in plugin README:\n\n```markdown\n## Configuration\n\nCreate `.claude/my-plugin.local.md` in your project:\n\n\\`\\`\\`markdown\n---\nenabled: true\nmode: standard\nmax_retries: 3\n---\n\n# Plugin Configuration\n\nYour settings are active.\n\\`\\`\\`\n\nAfter creating or editing, restart Claude Code for changes to take effect.\n```\n\n## Best Practices\n\n### File Naming\n\nâœ… **DO:**\n- Use `.claude/plugin-name.local.md` format\n- Match plugin name exactly\n- Use `.local.md` suffix for user-local files\n\nâŒ **DON'T:**\n- Use different directory (not `.claude/`)\n- Use inconsistent naming\n- Use `.md` without `.local` (might be committed)\n\n### Gitignore\n\nAlways add to `.gitignore`:\n\n```gitignore\n.claude/*.local.md\n.claude/*.local.json\n```\n\nDocument this in plugin README.\n\n### Defaults\n\nProvide sensible defaults when settings file doesn't exist:\n\n```bash\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  # Use defaults\n  ENABLED=true\n  MODE=standard\nelse\n  # Read from file\n  # ...\nfi\n```\n\n### Validation\n\nValidate settings values:\n\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n\n# Validate numeric range\nif ! [[ \"$MAX\" =~ ^[0-9]+$ ]] || [[ $MAX -lt 1 ]] || [[ $MAX -gt 100 ]]; then\n  echo \"âš ï¸  Invalid max_value in settings (must be 1-100)\" >&2\n  MAX=10  # Use default\nfi\n```\n\n### Restart Requirement\n\n**Important:** Settings changes require Claude Code restart.\n\nDocument in your README:\n\n```markdown\n## Changing Settings\n\nAfter editing `.claude/my-plugin.local.md`:\n1. Save the file\n2. Exit Claude Code\n3. Restart: `claude` or `cc`\n4. New settings will be loaded\n```\n\nHooks cannot be hot-swapped within a session.\n\n## Security Considerations\n\n### Sanitize User Input\n\nWhen writing settings files from user input:\n\n```bash\n# Escape quotes in user input\nSAFE_VALUE=$(echo \"$USER_INPUT\" | sed 's/\"/\\\\\"/g')\n\n# Write to file\ncat > \"$STATE_FILE\" <<EOF\n---\nuser_setting: \"$SAFE_VALUE\"\n---\nEOF\n```\n\n### Validate File Paths\n\nIf settings contain file paths:\n\n```bash\nFILE_PATH=$(echo \"$FRONTMATTER\" | grep '^data_file:' | sed 's/data_file: *//')\n\n# Check for path traversal\nif [[ \"$FILE_PATH\" == *\"..\"* ]]; then\n  echo \"âš ï¸  Invalid path in settings (path traversal)\" >&2\n  exit 2\nfi\n```\n\n### Permissions\n\nSettings files should be:\n- Readable by user only (`chmod 600`)\n- Not committed to git\n- Not shared between users\n\n## Real-World Examples\n\n### multi-agent-swarm Plugin\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-implementation\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\nadditional_instructions: Use JWT tokens, not sessions\n---\n\n# Task: Implement Authentication\n\nBuild JWT-based authentication for the REST API.\nCoordinate with auth-agent on shared types.\n```\n\n**Hook usage (agent-stop-notification.sh):**\n- Checks if file exists (line 15-18: quick exit if not)\n- Parses frontmatter to get coordinator_session, agent_name, enabled\n- Sends notifications to coordinator if enabled\n- Allows quick activation/deactivation via `enabled: true/false`\n\n### ralph-loop Plugin\n\n**.claude/ralph-loop.local.md:**\n```markdown\n---\niteration: 1\nmax_iterations: 10\ncompletion_promise: \"All tests passing and build successful\"\n---\n\nFix all the linting errors in the project.\nMake sure tests pass after each fix.\n```\n\n**Hook usage (stop-hook.sh):**\n- Checks if file exists (line 15-18: quick exit if not active)\n- Reads iteration count and max_iterations\n- Extracts completion_promise for loop termination\n- Reads body as the prompt to feed back\n- Updates iteration count on each loop\n\n## Quick Reference\n\n### File Location\n\n```\nproject-root/\nâ””â”€â”€ .claude/\n    â””â”€â”€ plugin-name.local.md\n```\n\n### Frontmatter Parsing\n\n```bash\n# Extract frontmatter\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n\n# Read field\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field:' | sed 's/field: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n### Body Parsing\n\n```bash\n# Extract body (after second ---)\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n### Quick Exit Pattern\n\n```bash\nif [[ ! -f \".claude/my-plugin.local.md\" ]]; then\n  exit 0  # Not configured\nfi\n```\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed implementation patterns:\n\n- **`references/parsing-techniques.md`** - Complete guide to parsing YAML frontmatter and markdown bodies\n- **`references/real-world-examples.md`** - Deep dive into multi-agent-swarm and ralph-loop implementations\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`read-settings-hook.sh`** - Hook that reads and uses settings\n- **`create-settings-command.md`** - Command that creates settings file\n- **`example-settings.md`** - Template settings file\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-settings.sh`** - Validate settings file structure\n- **`parse-frontmatter.sh`** - Extract frontmatter fields\n\n## Implementation Workflow\n\nTo add settings to a plugin:\n\n1. Design settings schema (which fields, types, defaults)\n2. Create template file in plugin documentation\n3. Add gitignore entry for `.claude/*.local.md`\n4. Implement settings parsing in hooks/commands\n5. Use quick-exit pattern (check file exists, check enabled field)\n6. Document settings in plugin README with template\n7. Remind users that changes require Claude Code restart\n\nFocus on keeping settings simple and providing good defaults when settings file doesn't exist."
              },
              {
                "name": "Plugin Structure",
                "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.",
                "path": "plugins/plugin-dev/skills/plugin-structure/SKILL.md",
                "frontmatter": {
                  "name": "Plugin Structure",
                  "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.",
                  "version": "0.1.0"
                },
                "content": "# Plugin Structure for Claude Code\n\n## Overview\n\nClaude Code plugins follow a standardized directory structure with automatic component discovery. Understanding this structure enables creating well-organized, maintainable plugins that integrate seamlessly with Claude Code.\n\n**Key concepts:**\n- Conventional directory layout for automatic discovery\n- Manifest-driven configuration in `.claude-plugin/plugin.json`\n- Component-based organization (commands, agents, skills, hooks)\n- Portable path references using `${CLAUDE_PLUGIN_ROOT}`\n- Explicit vs. auto-discovered component loading\n\n## Directory Structure\n\nEvery Claude Code plugin follows this organizational pattern:\n\n```\nplugin-name/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json          # Required: Plugin manifest\nâ”œâ”€â”€ commands/                 # Slash commands (.md files)\nâ”œâ”€â”€ agents/                   # Subagent definitions (.md files)\nâ”œâ”€â”€ skills/                   # Agent skills (subdirectories)\nâ”‚   â””â”€â”€ skill-name/\nâ”‚       â””â”€â”€ SKILL.md         # Required for each skill\nâ”œâ”€â”€ hooks/\nâ”‚   â””â”€â”€ hooks.json           # Event handler configuration\nâ”œâ”€â”€ .mcp.json                # MCP server definitions\nâ””â”€â”€ scripts/                 # Helper scripts and utilities\n```\n\n**Critical rules:**\n\n1. **Manifest location**: The `plugin.json` manifest MUST be in `.claude-plugin/` directory\n2. **Component locations**: All component directories (commands, agents, skills, hooks) MUST be at plugin root level, NOT nested inside `.claude-plugin/`\n3. **Optional components**: Only create directories for components the plugin actually uses\n4. **Naming convention**: Use kebab-case for all directory and file names\n\n## Plugin Manifest (plugin.json)\n\nThe manifest defines plugin metadata and configuration. Located at `.claude-plugin/plugin.json`:\n\n### Required Fields\n\n```json\n{\n  \"name\": \"plugin-name\"\n}\n```\n\n**Name requirements:**\n- Use kebab-case format (lowercase with hyphens)\n- Must be unique across installed plugins\n- No spaces or special characters\n- Example: `code-review-assistant`, `test-runner`, `api-docs`\n\n### Recommended Metadata\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Brief explanation of plugin purpose\",\n  \"author\": {\n    \"name\": \"Author Name\",\n    \"email\": \"author@example.com\",\n    \"url\": \"https://example.com\"\n  },\n  \"homepage\": \"https://docs.example.com\",\n  \"repository\": \"https://github.com/user/plugin-name\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"testing\", \"automation\", \"ci-cd\"]\n}\n```\n\n**Version format**: Follow semantic versioning (MAJOR.MINOR.PATCH)\n**Keywords**: Use for plugin discovery and categorization\n\n### Component Path Configuration\n\nSpecify custom paths for components (supplements default directories):\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"commands\": \"./custom-commands\",\n  \"agents\": [\"./agents\", \"./specialized-agents\"],\n  \"hooks\": \"./config/hooks.json\",\n  \"mcpServers\": \"./.mcp.json\"\n}\n```\n\n**Important**: Custom paths supplement defaultsâ€”they don't replace them. Components in both default directories and custom paths will load.\n\n**Path rules:**\n- Must be relative to plugin root\n- Must start with `./`\n- Cannot use absolute paths\n- Support arrays for multiple locations\n\n## Component Organization\n\n### Commands\n\n**Location**: `commands/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `commands/` load automatically\n\n**Example structure**:\n```\ncommands/\nâ”œâ”€â”€ review.md        # /review command\nâ”œâ”€â”€ test.md          # /test command\nâ””â”€â”€ deploy.md        # /deploy command\n```\n\n**File format**:\n```markdown\n---\nname: command-name\ndescription: Command description\n---\n\nCommand implementation instructions...\n```\n\n**Usage**: Commands integrate as native slash commands in Claude Code\n\n### Agents\n\n**Location**: `agents/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `agents/` load automatically\n\n**Example structure**:\n```\nagents/\nâ”œâ”€â”€ code-reviewer.md\nâ”œâ”€â”€ test-generator.md\nâ””â”€â”€ refactorer.md\n```\n\n**File format**:\n```markdown\n---\ndescription: Agent role and expertise\ncapabilities:\n  - Specific task 1\n  - Specific task 2\n---\n\nDetailed agent instructions and knowledge...\n```\n\n**Usage**: Users can invoke agents manually, or Claude Code selects them automatically based on task context\n\n### Skills\n\n**Location**: `skills/` directory with subdirectories per skill\n**Format**: Each skill in its own directory with `SKILL.md` file\n**Auto-discovery**: All `SKILL.md` files in skill subdirectories load automatically\n\n**Example structure**:\n```\nskills/\nâ”œâ”€â”€ api-testing/\nâ”‚   â”œâ”€â”€ SKILL.md\nâ”‚   â”œâ”€â”€ scripts/\nâ”‚   â”‚   â””â”€â”€ test-runner.py\nâ”‚   â””â”€â”€ references/\nâ”‚       â””â”€â”€ api-spec.md\nâ””â”€â”€ database-migrations/\n    â”œâ”€â”€ SKILL.md\n    â””â”€â”€ examples/\n        â””â”€â”€ migration-template.sql\n```\n\n**SKILL.md format**:\n```markdown\n---\nname: Skill Name\ndescription: When to use this skill\nversion: 1.0.0\n---\n\nSkill instructions and guidance...\n```\n\n**Supporting files**: Skills can include scripts, references, examples, or assets in subdirectories\n\n**Usage**: Claude Code autonomously activates skills based on task context matching the description\n\n### Hooks\n\n**Location**: `hooks/hooks.json` or inline in `plugin.json`\n**Format**: JSON configuration defining event handlers\n**Registration**: Hooks register automatically when plugin enables\n\n**Example structure**:\n```\nhooks/\nâ”œâ”€â”€ hooks.json           # Hook configuration\nâ””â”€â”€ scripts/\n    â”œâ”€â”€ validate.sh      # Hook script\n    â””â”€â”€ check-style.sh   # Hook script\n```\n\n**Configuration format**:\n```json\n{\n  \"PreToolUse\": [{\n    \"matcher\": \"Write|Edit\",\n    \"hooks\": [{\n      \"type\": \"command\",\n      \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/validate.sh\",\n      \"timeout\": 30\n    }]\n  }]\n}\n```\n\n**Available events**: PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification\n\n**Usage**: Hooks execute automatically in response to Claude Code events\n\n### MCP Servers\n\n**Location**: `.mcp.json` at plugin root or inline in `plugin.json`\n**Format**: JSON configuration for MCP server definitions\n**Auto-start**: Servers start automatically when plugin enables\n\n**Example format**:\n```json\n{\n  \"mcpServers\": {\n    \"server-name\": {\n      \"command\": \"node\",\n      \"args\": [\"${CLAUDE_PLUGIN_ROOT}/servers/server.js\"],\n      \"env\": {\n        \"API_KEY\": \"${API_KEY}\"\n      }\n    }\n  }\n}\n```\n\n**Usage**: MCP servers integrate seamlessly with Claude Code's tool system\n\n## Portable Path References\n\n### ${CLAUDE_PLUGIN_ROOT}\n\nUse `${CLAUDE_PLUGIN_ROOT}` environment variable for all intra-plugin path references:\n\n```json\n{\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/run.sh\"\n}\n```\n\n**Why it matters**: Plugins install in different locations depending on:\n- User installation method (marketplace, local, npm)\n- Operating system conventions\n- User preferences\n\n**Where to use it**:\n- Hook command paths\n- MCP server command arguments\n- Script execution references\n- Resource file paths\n\n**Never use**:\n- Hardcoded absolute paths (`/Users/name/plugins/...`)\n- Relative paths from working directory (`./scripts/...` in commands)\n- Home directory shortcuts (`~/plugins/...`)\n\n### Path Resolution Rules\n\n**In manifest JSON fields** (hooks, MCP servers):\n```json\n\"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/tool.sh\"\n```\n\n**In component files** (commands, agents, skills):\n```markdown\nReference scripts at: ${CLAUDE_PLUGIN_ROOT}/scripts/helper.py\n```\n\n**In executed scripts**:\n```bash\n#!/bin/bash\n# ${CLAUDE_PLUGIN_ROOT} available as environment variable\nsource \"${CLAUDE_PLUGIN_ROOT}/lib/common.sh\"\n```\n\n## File Naming Conventions\n\n### Component Files\n\n**Commands**: Use kebab-case `.md` files\n- `code-review.md` â†’ `/code-review`\n- `run-tests.md` â†’ `/run-tests`\n- `api-docs.md` â†’ `/api-docs`\n\n**Agents**: Use kebab-case `.md` files describing role\n- `test-generator.md`\n- `code-reviewer.md`\n- `performance-analyzer.md`\n\n**Skills**: Use kebab-case directory names\n- `api-testing/`\n- `database-migrations/`\n- `error-handling/`\n\n### Supporting Files\n\n**Scripts**: Use descriptive kebab-case names with appropriate extensions\n- `validate-input.sh`\n- `generate-report.py`\n- `process-data.js`\n\n**Documentation**: Use kebab-case markdown files\n- `api-reference.md`\n- `migration-guide.md`\n- `best-practices.md`\n\n**Configuration**: Use standard names\n- `hooks.json`\n- `.mcp.json`\n- `plugin.json`\n\n## Auto-Discovery Mechanism\n\nClaude Code automatically discovers and loads components:\n\n1. **Plugin manifest**: Reads `.claude-plugin/plugin.json` when plugin enables\n2. **Commands**: Scans `commands/` directory for `.md` files\n3. **Agents**: Scans `agents/` directory for `.md` files\n4. **Skills**: Scans `skills/` for subdirectories containing `SKILL.md`\n5. **Hooks**: Loads configuration from `hooks/hooks.json` or manifest\n6. **MCP servers**: Loads configuration from `.mcp.json` or manifest\n\n**Discovery timing**:\n- Plugin installation: Components register with Claude Code\n- Plugin enable: Components become available for use\n- No restart required: Changes take effect on next Claude Code session\n\n**Override behavior**: Custom paths in `plugin.json` supplement (not replace) default directories\n\n## Best Practices\n\n### Organization\n\n1. **Logical grouping**: Group related components together\n   - Put test-related commands, agents, and skills together\n   - Create subdirectories in `scripts/` for different purposes\n\n2. **Minimal manifest**: Keep `plugin.json` lean\n   - Only specify custom paths when necessary\n   - Rely on auto-discovery for standard layouts\n   - Use inline configuration only for simple cases\n\n3. **Documentation**: Include README files\n   - Plugin root: Overall purpose and usage\n   - Component directories: Specific guidance\n   - Script directories: Usage and requirements\n\n### Naming\n\n1. **Consistency**: Use consistent naming across components\n   - If command is `test-runner`, name related agent `test-runner-agent`\n   - Match skill directory names to their purpose\n\n2. **Clarity**: Use descriptive names that indicate purpose\n   - Good: `api-integration-testing/`, `code-quality-checker.md`\n   - Avoid: `utils/`, `misc.md`, `temp.sh`\n\n3. **Length**: Balance brevity with clarity\n   - Commands: 2-3 words (`review-pr`, `run-ci`)\n   - Agents: Describe role clearly (`code-reviewer`, `test-generator`)\n   - Skills: Topic-focused (`error-handling`, `api-design`)\n\n### Portability\n\n1. **Always use ${CLAUDE_PLUGIN_ROOT}**: Never hardcode paths\n2. **Test on multiple systems**: Verify on macOS, Linux, Windows\n3. **Document dependencies**: List required tools and versions\n4. **Avoid system-specific features**: Use portable bash/Python constructs\n\n### Maintenance\n\n1. **Version consistently**: Update version in plugin.json for releases\n2. **Deprecate gracefully**: Mark old components clearly before removal\n3. **Document breaking changes**: Note changes affecting existing users\n4. **Test thoroughly**: Verify all components work after changes\n\n## Common Patterns\n\n### Minimal Plugin\n\nSingle command with no dependencies:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json    # Just name field\nâ””â”€â”€ commands/\n    â””â”€â”€ hello.md       # Single command\n```\n\n### Full-Featured Plugin\n\nComplete plugin with all component types:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/          # User-facing commands\nâ”œâ”€â”€ agents/            # Specialized subagents\nâ”œâ”€â”€ skills/            # Auto-activating skills\nâ”œâ”€â”€ hooks/             # Event handlers\nâ”‚   â”œâ”€â”€ hooks.json\nâ”‚   â””â”€â”€ scripts/\nâ”œâ”€â”€ .mcp.json          # External integrations\nâ””â”€â”€ scripts/           # Shared utilities\n```\n\n### Skill-Focused Plugin\n\nPlugin providing only skills:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ””â”€â”€ skills/\n    â”œâ”€â”€ skill-one/\n    â”‚   â””â”€â”€ SKILL.md\n    â””â”€â”€ skill-two/\n        â””â”€â”€ SKILL.md\n```\n\n## Troubleshooting\n\n**Component not loading**:\n- Verify file is in correct directory with correct extension\n- Check YAML frontmatter syntax (commands, agents, skills)\n- Ensure skill has `SKILL.md` (not `README.md` or other name)\n- Confirm plugin is enabled in Claude Code settings\n\n**Path resolution errors**:\n- Replace all hardcoded paths with `${CLAUDE_PLUGIN_ROOT}`\n- Verify paths are relative and start with `./` in manifest\n- Check that referenced files exist at specified paths\n- Test with `echo $CLAUDE_PLUGIN_ROOT` in hook scripts\n\n**Auto-discovery not working**:\n- Confirm directories are at plugin root (not in `.claude-plugin/`)\n- Check file naming follows conventions (kebab-case, correct extensions)\n- Verify custom paths in manifest are correct\n- Restart Claude Code to reload plugin configuration\n\n**Conflicts between plugins**:\n- Use unique, descriptive component names\n- Namespace commands with plugin name if needed\n- Document potential conflicts in plugin README\n- Consider command prefixes for related functionality\n\n---\n\nFor detailed examples and advanced patterns, see files in `references/` and `examples/` directories."
              },
              {
                "name": "Skill Development",
                "description": "This skill should be used when the user wants to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins.",
                "path": "plugins/plugin-dev/skills/skill-development/SKILL.md",
                "frontmatter": {
                  "name": "Skill Development",
                  "description": "This skill should be used when the user wants to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins.",
                  "version": "0.1.0"
                },
                "content": "# Skill Development for Claude Code Plugins\n\nThis skill provides guidance for creating effective skills for Claude Code plugins.\n\n## About Skills\n\nSkills are modular, self-contained packages that extend Claude's capabilities by providing\nspecialized knowledge, workflows, and tools. Think of them as \"onboarding guides\" for specific\ndomains or tasksâ€”they transform Claude from a general-purpose agent into a specialized agent\nequipped with procedural knowledge that no model can fully possess.\n\n### What Skills Provide\n\n1. Specialized workflows - Multi-step procedures for specific domains\n2. Tool integrations - Instructions for working with specific file formats or APIs\n3. Domain expertise - Company-specific knowledge, schemas, business logic\n4. Bundled resources - Scripts, references, and assets for complex and repetitive tasks\n\n### Anatomy of a Skill\n\nEvery skill consists of a required SKILL.md file and optional bundled resources:\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md (required)\nâ”‚   â”œâ”€â”€ YAML frontmatter metadata (required)\nâ”‚   â”‚   â”œâ”€â”€ name: (required)\nâ”‚   â”‚   â””â”€â”€ description: (required)\nâ”‚   â””â”€â”€ Markdown instructions (required)\nâ””â”€â”€ Bundled Resources (optional)\n    â”œâ”€â”€ scripts/          - Executable code (Python/Bash/etc.)\n    â”œâ”€â”€ references/       - Documentation intended to be loaded into context as needed\n    â””â”€â”€ assets/           - Files used in output (templates, icons, fonts, etc.)\n```\n\n#### SKILL.md (required)\n\n**Metadata Quality:** The `name` and `description` in YAML frontmatter determine when Claude will use the skill. Be specific about what the skill does and when to use it. Use the third-person (e.g. \"This skill should be used when...\" instead of \"Use this skill when...\").\n\n#### Bundled Resources (optional)\n\n##### Scripts (`scripts/`)\n\nExecutable code (Python/Bash/etc.) for tasks that require deterministic reliability or are repeatedly rewritten.\n\n- **When to include**: When the same code is being rewritten repeatedly or deterministic reliability is needed\n- **Example**: `scripts/rotate_pdf.py` for PDF rotation tasks\n- **Benefits**: Token efficient, deterministic, may be executed without loading into context\n- **Note**: Scripts may still need to be read by Claude for patching or environment-specific adjustments\n\n##### References (`references/`)\n\nDocumentation and reference material intended to be loaded as needed into context to inform Claude's process and thinking.\n\n- **When to include**: For documentation that Claude should reference while working\n- **Examples**: `references/finance.md` for financial schemas, `references/mnda.md` for company NDA template, `references/policies.md` for company policies, `references/api_docs.md` for API specifications\n- **Use cases**: Database schemas, API documentation, domain knowledge, company policies, detailed workflow guides\n- **Benefits**: Keeps SKILL.md lean, loaded only when Claude determines it's needed\n- **Best practice**: If files are large (>10k words), include grep search patterns in SKILL.md\n- **Avoid duplication**: Information should live in either SKILL.md or references files, not both. Prefer references files for detailed information unless it's truly core to the skillâ€”this keeps SKILL.md lean while making information discoverable without hogging the context window. Keep only essential procedural instructions and workflow guidance in SKILL.md; move detailed reference material, schemas, and examples to references files.\n\n##### Assets (`assets/`)\n\nFiles not intended to be loaded into context, but rather used within the output Claude produces.\n\n- **When to include**: When the skill needs files that will be used in the final output\n- **Examples**: `assets/logo.png` for brand assets, `assets/slides.pptx` for PowerPoint templates, `assets/frontend-template/` for HTML/React boilerplate, `assets/font.ttf` for typography\n- **Use cases**: Templates, images, icons, boilerplate code, fonts, sample documents that get copied or modified\n- **Benefits**: Separates output resources from documentation, enables Claude to use files without loading them into context\n\n### Progressive Disclosure Design Principle\n\nSkills use a three-level loading system to manage context efficiently:\n\n1. **Metadata (name + description)** - Always in context (~100 words)\n2. **SKILL.md body** - When skill triggers (<5k words)\n3. **Bundled resources** - As needed by Claude (Unlimited*)\n\n*Unlimited because scripts can be executed without reading into context window.\n\n## Skill Creation Process\n\nTo create a skill, follow the \"Skill Creation Process\" in order, skipping steps only if there is a clear reason why they are not applicable.\n\n### Step 1: Understanding the Skill with Concrete Examples\n\nSkip this step only when the skill's usage patterns are already clearly understood. It remains valuable even when working with an existing skill.\n\nTo create an effective skill, clearly understand concrete examples of how the skill will be used. This understanding can come from either direct user examples or generated examples that are validated with user feedback.\n\nFor example, when building an image-editor skill, relevant questions include:\n\n- \"What functionality should the image-editor skill support? Editing, rotating, anything else?\"\n- \"Can you give some examples of how this skill would be used?\"\n- \"I can imagine users asking for things like 'Remove the red-eye from this image' or 'Rotate this image'. Are there other ways you imagine this skill being used?\"\n- \"What would a user say that should trigger this skill?\"\n\nTo avoid overwhelming users, avoid asking too many questions in a single message. Start with the most important questions and follow up as needed for better effectiveness.\n\nConclude this step when there is a clear sense of the functionality the skill should support.\n\n### Step 2: Planning the Reusable Skill Contents\n\nTo turn concrete examples into an effective skill, analyze each example by:\n\n1. Considering how to execute on the example from scratch\n2. Identifying what scripts, references, and assets would be helpful when executing these workflows repeatedly\n\nExample: When building a `pdf-editor` skill to handle queries like \"Help me rotate this PDF,\" the analysis shows:\n\n1. Rotating a PDF requires re-writing the same code each time\n2. A `scripts/rotate_pdf.py` script would be helpful to store in the skill\n\nExample: When designing a `frontend-webapp-builder` skill for queries like \"Build me a todo app\" or \"Build me a dashboard to track my steps,\" the analysis shows:\n\n1. Writing a frontend webapp requires the same boilerplate HTML/React each time\n2. An `assets/hello-world/` template containing the boilerplate HTML/React project files would be helpful to store in the skill\n\nExample: When building a `big-query` skill to handle queries like \"How many users have logged in today?\" the analysis shows:\n\n1. Querying BigQuery requires re-discovering the table schemas and relationships each time\n2. A `references/schema.md` file documenting the table schemas would be helpful to store in the skill\n\n**For Claude Code plugins:** When building a hooks skill, the analysis shows:\n1. Developers repeatedly need to validate hooks.json and test hook scripts\n2. `scripts/validate-hook-schema.sh` and `scripts/test-hook.sh` utilities would be helpful\n3. `references/patterns.md` for detailed hook patterns to avoid bloating SKILL.md\n\nTo establish the skill's contents, analyze each concrete example to create a list of the reusable resources to include: scripts, references, and assets.\n\n### Step 3: Create Skill Structure\n\nFor Claude Code plugins, create the skill directory structure:\n\n```bash\nmkdir -p plugin-name/skills/skill-name/{references,examples,scripts}\ntouch plugin-name/skills/skill-name/SKILL.md\n```\n\n**Note:** Unlike the generic skill-creator which uses `init_skill.py`, plugin skills are created directly in the plugin's `skills/` directory with a simpler manual structure.\n\n### Step 4: Edit the Skill\n\nWhen editing the (newly-created or existing) skill, remember that the skill is being created for another instance of Claude to use. Focus on including information that would be beneficial and non-obvious to Claude. Consider what procedural knowledge, domain-specific details, or reusable assets would help another Claude instance execute these tasks more effectively.\n\n#### Start with Reusable Skill Contents\n\nTo begin implementation, start with the reusable resources identified above: `scripts/`, `references/`, and `assets/` files. Note that this step may require user input. For example, when implementing a `brand-guidelines` skill, the user may need to provide brand assets or templates to store in `assets/`, or documentation to store in `references/`.\n\nAlso, delete any example files and directories not needed for the skill. Create only the directories you actually need (references/, examples/, scripts/).\n\n#### Update SKILL.md\n\n**Writing Style:** Write the entire skill using **imperative/infinitive form** (verb-first instructions), not second person. Use objective, instructional language (e.g., \"To accomplish X, do Y\" rather than \"You should do X\" or \"If you need to do X\"). This maintains consistency and clarity for AI consumption.\n\n**Description (Frontmatter):** Use third-person format with specific trigger phrases:\n\n```yaml\n---\nname: Skill Name\ndescription: This skill should be used when the user asks to \"specific phrase 1\", \"specific phrase 2\", \"specific phrase 3\". Include exact phrases users would say that should trigger this skill. Be concrete and specific.\nversion: 0.1.0\n---\n```\n\n**Good description examples:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", \"implement prompt-based hooks\", or mentions hook events (PreToolUse, PostToolUse, Stop).\n```\n\n**Bad description examples:**\n```yaml\ndescription: Use this skill when working with hooks.  # Wrong person, vague\ndescription: Load when user needs hook help.  # Not third person\ndescription: Provides hook guidance.  # No trigger phrases\n```\n\nTo complete SKILL.md body, answer the following questions:\n\n1. What is the purpose of the skill, in a few sentences?\n2. When should the skill be used? (Include this in frontmatter description with specific triggers)\n3. In practice, how should Claude use the skill? All reusable skill contents developed above should be referenced so that Claude knows how to use them.\n\n**Keep SKILL.md lean:** Target 1,500-2,000 words for the body. Move detailed content to references/:\n- Detailed patterns â†’ `references/patterns.md`\n- Advanced techniques â†’ `references/advanced.md`\n- Migration guides â†’ `references/migration.md`\n- API references â†’ `references/api-reference.md`\n\n**Reference resources in SKILL.md:**\n```markdown\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and techniques, consult:\n- **`references/patterns.md`** - Common patterns\n- **`references/advanced.md`** - Advanced use cases\n\n### Example Files\n\nWorking examples in `examples/`:\n- **`example-script.sh`** - Working example\n```\n\n### Step 5: Validate and Test\n\n**For plugin skills, validation is different from generic skills:**\n\n1. **Check structure**: Skill directory in `plugin-name/skills/skill-name/`\n2. **Validate SKILL.md**: Has frontmatter with name and description\n3. **Check trigger phrases**: Description includes specific user queries\n4. **Verify writing style**: Body uses imperative/infinitive form, not second person\n5. **Test progressive disclosure**: SKILL.md is lean (~1,500-2,000 words), detailed content in references/\n6. **Check references**: All referenced files exist\n7. **Validate examples**: Examples are complete and correct\n8. **Test scripts**: Scripts are executable and work correctly\n\n**Use the skill-reviewer agent:**\n```\nAsk: \"Review my skill and check if it follows best practices\"\n```\n\nThe skill-reviewer agent will check description quality, content organization, and progressive disclosure.\n\n### Step 6: Iterate\n\nAfter testing the skill, users may request improvements. Often this happens right after using the skill, with fresh context of how the skill performed.\n\n**Iteration workflow:**\n1. Use the skill on real tasks\n2. Notice struggles or inefficiencies\n3. Identify how SKILL.md or bundled resources should be updated\n4. Implement changes and test again\n\n**Common improvements:**\n- Strengthen trigger phrases in description\n- Move long sections from SKILL.md to references/\n- Add missing examples or scripts\n- Clarify ambiguous instructions\n- Add edge case handling\n\n## Plugin-Specific Considerations\n\n### Skill Location in Plugins\n\nPlugin skills live in the plugin's `skills/` directory:\n\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/\nâ”œâ”€â”€ agents/\nâ””â”€â”€ skills/\n    â””â”€â”€ my-skill/\n        â”œâ”€â”€ SKILL.md\n        â”œâ”€â”€ references/\n        â”œâ”€â”€ examples/\n        â””â”€â”€ scripts/\n```\n\n### Auto-Discovery\n\nClaude Code automatically discovers skills:\n- Scans `skills/` directory\n- Finds subdirectories containing `SKILL.md`\n- Loads skill metadata (name + description) always\n- Loads SKILL.md body when skill triggers\n- Loads references/examples when needed\n\n### No Packaging Needed\n\nPlugin skills are distributed as part of the plugin, not as separate ZIP files. Users get skills when they install the plugin.\n\n### Testing in Plugins\n\nTest skills by installing plugin locally:\n\n```bash\n# Test with --plugin-dir\ncc --plugin-dir /path/to/plugin\n\n# Ask questions that should trigger the skill\n# Verify skill loads correctly\n```\n\n## Examples from Plugin-Dev\n\nStudy the skills in this plugin as examples of best practices:\n\n**hook-development skill:**\n- Excellent trigger phrases: \"create a hook\", \"add a PreToolUse hook\", etc.\n- Lean SKILL.md (1,651 words)\n- 3 references/ files for detailed content\n- 3 examples/ of working hooks\n- 3 scripts/ utilities\n\n**agent-development skill:**\n- Strong triggers: \"create an agent\", \"agent frontmatter\", etc.\n- Focused SKILL.md (1,438 words)\n- References include the AI generation prompt from Claude Code\n- Complete agent examples\n\n**plugin-settings skill:**\n- Specific triggers: \"plugin settings\", \".local.md files\", \"YAML frontmatter\"\n- References show real implementations (multi-agent-swarm, ralph-loop)\n- Working parsing scripts\n\nEach demonstrates progressive disclosure and strong triggering.\n\n## Progressive Disclosure in Practice\n\n### What Goes in SKILL.md\n\n**Include (always loaded when skill triggers):**\n- Core concepts and overview\n- Essential procedures and workflows\n- Quick reference tables\n- Pointers to references/examples/scripts\n- Most common use cases\n\n**Keep under 3,000 words, ideally 1,500-2,000 words**\n\n### What Goes in references/\n\n**Move to references/ (loaded as needed):**\n- Detailed patterns and advanced techniques\n- Comprehensive API documentation\n- Migration guides\n- Edge cases and troubleshooting\n- Extensive examples and walkthroughs\n\n**Each reference file can be large (2,000-5,000+ words)**\n\n### What Goes in examples/\n\n**Working code examples:**\n- Complete, runnable scripts\n- Configuration files\n- Template files\n- Real-world usage examples\n\n**Users can copy and adapt these directly**\n\n### What Goes in scripts/\n\n**Utility scripts:**\n- Validation tools\n- Testing helpers\n- Parsing utilities\n- Automation scripts\n\n**Should be executable and documented**\n\n## Writing Style Requirements\n\n### Imperative/Infinitive Form\n\nWrite using verb-first instructions, not second person:\n\n**Correct (imperative):**\n```\nTo create a hook, define the event type.\nConfigure the MCP server with authentication.\nValidate settings before use.\n```\n\n**Incorrect (second person):**\n```\nYou should create a hook by defining the event type.\nYou need to configure the MCP server.\nYou must validate settings before use.\n```\n\n### Third-Person in Description\n\nThe frontmatter description must use third person:\n\n**Correct:**\n```yaml\ndescription: This skill should be used when the user asks to \"create X\", \"configure Y\"...\n```\n\n**Incorrect:**\n```yaml\ndescription: Use this skill when you want to create X...\ndescription: Load this skill when user asks...\n```\n\n### Objective, Instructional Language\n\nFocus on what to do, not who should do it:\n\n**Correct:**\n```\nParse the frontmatter using sed.\nExtract fields with grep.\nValidate values before use.\n```\n\n**Incorrect:**\n```\nYou can parse the frontmatter...\nClaude should extract fields...\nThe user might validate values...\n```\n\n## Validation Checklist\n\nBefore finalizing a skill:\n\n**Structure:**\n- [ ] SKILL.md file exists with valid YAML frontmatter\n- [ ] Frontmatter has `name` and `description` fields\n- [ ] Markdown body is present and substantial\n- [ ] Referenced files actually exist\n\n**Description Quality:**\n- [ ] Uses third person (\"This skill should be used when...\")\n- [ ] Includes specific trigger phrases users would say\n- [ ] Lists concrete scenarios (\"create X\", \"configure Y\")\n- [ ] Not vague or generic\n\n**Content Quality:**\n- [ ] SKILL.md body uses imperative/infinitive form\n- [ ] Body is focused and lean (1,500-2,000 words ideal, <5k max)\n- [ ] Detailed content moved to references/\n- [ ] Examples are complete and working\n- [ ] Scripts are executable and documented\n\n**Progressive Disclosure:**\n- [ ] Core concepts in SKILL.md\n- [ ] Detailed docs in references/\n- [ ] Working code in examples/\n- [ ] Utilities in scripts/\n- [ ] SKILL.md references these resources\n\n**Testing:**\n- [ ] Skill triggers on expected user queries\n- [ ] Content is helpful for intended tasks\n- [ ] No duplicated information across files\n- [ ] References load when needed\n\n## Common Mistakes to Avoid\n\n### Mistake 1: Weak Trigger Description\n\nâŒ **Bad:**\n```yaml\ndescription: Provides guidance for working with hooks.\n```\n\n**Why bad:** Vague, no specific trigger phrases, not third person\n\nâœ… **Good:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", or mentions hook events. Provides comprehensive hooks API guidance.\n```\n\n**Why good:** Third person, specific phrases, concrete scenarios\n\n### Mistake 2: Too Much in SKILL.md\n\nâŒ **Bad:**\n```\nskill-name/\nâ””â”€â”€ SKILL.md  (8,000 words - everything in one file)\n```\n\n**Why bad:** Bloats context when skill loads, detailed content always loaded\n\nâœ… **Good:**\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md  (1,800 words - core essentials)\nâ””â”€â”€ references/\n    â”œâ”€â”€ patterns.md (2,500 words)\n    â””â”€â”€ advanced.md (3,700 words)\n```\n\n**Why good:** Progressive disclosure, detailed content loaded only when needed\n\n### Mistake 3: Second Person Writing\n\nâŒ **Bad:**\n```markdown\nYou should start by reading the configuration file.\nYou need to validate the input.\nYou can use the grep tool to search.\n```\n\n**Why bad:** Second person, not imperative form\n\nâœ… **Good:**\n```markdown\nStart by reading the configuration file.\nValidate the input before processing.\nUse the grep tool to search for patterns.\n```\n\n**Why good:** Imperative form, direct instructions\n\n### Mistake 4: Missing Resource References\n\nâŒ **Bad:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n[No mention of references/ or examples/]\n```\n\n**Why bad:** Claude doesn't know references exist\n\nâœ… **Good:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n## Additional Resources\n\n### Reference Files\n- **`references/patterns.md`** - Detailed patterns\n- **`references/advanced.md`** - Advanced techniques\n\n### Examples\n- **`examples/script.sh`** - Working example\n```\n\n**Why good:** Claude knows where to find additional information\n\n## Quick Reference\n\n### Minimal Skill\n\n```\nskill-name/\nâ””â”€â”€ SKILL.md\n```\n\nGood for: Simple knowledge, no complex resources needed\n\n### Standard Skill (Recommended)\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md\nâ”œâ”€â”€ references/\nâ”‚   â””â”€â”€ detailed-guide.md\nâ””â”€â”€ examples/\n    â””â”€â”€ working-example.sh\n```\n\nGood for: Most plugin skills with detailed documentation\n\n### Complete Skill\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md\nâ”œâ”€â”€ references/\nâ”‚   â”œâ”€â”€ patterns.md\nâ”‚   â””â”€â”€ advanced.md\nâ”œâ”€â”€ examples/\nâ”‚   â”œâ”€â”€ example1.sh\nâ”‚   â””â”€â”€ example2.json\nâ””â”€â”€ scripts/\n    â””â”€â”€ validate.sh\n```\n\nGood for: Complex domains with validation utilities\n\n## Best Practices Summary\n\nâœ… **DO:**\n- Use third-person in description (\"This skill should be used when...\")\n- Include specific trigger phrases (\"create X\", \"configure Y\")\n- Keep SKILL.md lean (1,500-2,000 words)\n- Use progressive disclosure (move details to references/)\n- Write in imperative/infinitive form\n- Reference supporting files clearly\n- Provide working examples\n- Create utility scripts for common operations\n- Study plugin-dev's skills as templates\n\nâŒ **DON'T:**\n- Use second person anywhere\n- Have vague trigger conditions\n- Put everything in SKILL.md (>3,000 words without references/)\n- Write in second person (\"You should...\")\n- Leave resources unreferenced\n- Include broken or incomplete examples\n- Skip validation\n\n## Additional Resources\n\n### Study These Skills\n\nPlugin-dev's skills demonstrate best practices:\n- `../hook-development/` - Progressive disclosure, utilities\n- `../agent-development/` - AI-assisted creation, references\n- `../mcp-integration/` - Comprehensive references\n- `../plugin-settings/` - Real-world examples\n- `../command-development/` - Clear critical concepts\n- `../plugin-structure/` - Good organization\n\n### Reference Files\n\nFor complete skill-creator methodology:\n- **`references/skill-creator-original.md`** - Full original skill-creator content\n\n## Implementation Workflow\n\nTo create a skill for your plugin:\n\n1. **Understand use cases**: Identify concrete examples of skill usage\n2. **Plan resources**: Determine what scripts/references/examples needed\n3. **Create structure**: `mkdir -p skills/skill-name/{references,examples,scripts}`\n4. **Write SKILL.md**:\n   - Frontmatter with third-person description and trigger phrases\n   - Lean body (1,500-2,000 words) in imperative form\n   - Reference supporting files\n5. **Add resources**: Create references/, examples/, scripts/ as needed\n6. **Validate**: Check description, writing style, organization\n7. **Test**: Verify skill loads on expected triggers\n8. **Iterate**: Improve based on usage\n\nFocus on strong trigger descriptions, progressive disclosure, and imperative writing style for effective skills that load when needed and provide targeted guidance."
              }
            ]
          },
          {
            "name": "greptile",
            "description": "AI-powered codebase search and understanding. Query your repositories using natural language to find relevant code, understand dependencies, and get contextual answers about your codebase architecture.",
            "source": "./external_plugins/greptile",
            "category": "development",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install greptile@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "serena",
            "description": "Semantic code analysis MCP server providing intelligent code understanding, refactoring suggestions, and codebase navigation through language server protocol integration.",
            "source": "./external_plugins/serena",
            "category": "development",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install serena@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "playwright",
            "description": "Browser automation and end-to-end testing MCP server by Microsoft. Enables Claude to interact with web pages, take screenshots, fill forms, click elements, and perform automated browser testing workflows.",
            "source": "./external_plugins/playwright",
            "category": "testing",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install playwright@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "github",
            "description": "Official GitHub MCP server for repository management. Create issues, manage pull requests, review code, search repositories, and interact with GitHub's full API directly from Claude Code.",
            "source": "./external_plugins/github",
            "category": "productivity",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install github@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "supabase",
            "description": "Supabase MCP integration for database operations, authentication, storage, and real-time subscriptions. Manage your Supabase projects, run SQL queries, and interact with your backend directly.",
            "source": "./external_plugins/supabase",
            "category": "database",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install supabase@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "atlassian",
            "description": "Connect to Atlassian products including Jira and Confluence. Search and create issues, access documentation, manage sprints, and integrate your development workflow with Atlassian's collaboration tools.",
            "source": {
              "source": "url",
              "url": "https://github.com/atlassian/atlassian-mcp-server.git"
            },
            "category": "productivity",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install atlassian@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [
              {
                "name": "/explain-error",
                "description": "Explain Stripe error codes and provide solutions with code examples",
                "path": "external_plugins/stripe/commands/explain-error.md",
                "frontmatter": {
                  "description": "Explain Stripe error codes and provide solutions with code examples",
                  "argument-hint": [
                    "error_code or error_message"
                  ]
                },
                "content": "# Explain Stripe Error\n\nProvide a comprehensive explanation of the given Stripe error code or error message:\n\n1. Accept the error code or full error message from the arguments\n2. Explain in plain English what the error means\n3. List common causes of this error\n4. Provide specific solutions and handling recommendations\n5. Generate error handling code in the project's language showing:\n   - How to catch this specific error\n   - User-friendly error messages\n   - Whether retry is appropriate\n6. Mention related error codes the developer should be aware of\n7. Include a link to the relevant Stripe documentation\n\nFocus on actionable solutions and production-ready error handling patterns."
              },
              {
                "name": "/test-cards",
                "description": "Display Stripe test card numbers for various testing scenarios",
                "path": "external_plugins/stripe/commands/test-cards.md",
                "frontmatter": {
                  "description": "Display Stripe test card numbers for various testing scenarios",
                  "argument-hint": [
                    "scenario"
                  ]
                },
                "content": "# Test Cards Reference\n\nProvide a quick reference for Stripe test card numbers:\n\n1. If a scenario argument is provided (e.g., \"declined\", \"3dsecure\", \"fraud\"), show relevant test cards for that scenario\n2. Otherwise, show the most common test cards organized by category:\n   - Successful payment (default card)\n   - 3D Secure authentication required\n   - Generic decline\n   - Specific decline reasons (insufficient_funds, lost_card, etc.)\n3. For each card, display:\n   - Card number (formatted with spaces)\n   - Expected behavior\n   - Expiry/CVC info (any future date and any 3-digit CVC)\n4. Use clear visual indicators (âœ“ for success, âš ï¸ for auth required, âœ— for decline)\n5. Mention that these only work in test mode\n6. Provide link to full testing documentation: https://docs.stripe.com/testing.md\n\nIf the user is currently working on test code, offer to generate test cases using these cards."
              },
              {
                "name": "/new-sdk-app",
                "description": "Create and setup a new Claude Agent SDK application",
                "path": "plugins/agent-sdk-dev/commands/new-sdk-app.md",
                "frontmatter": {
                  "description": "Create and setup a new Claude Agent SDK application",
                  "argument-hint": [
                    "project-name"
                  ]
                },
                "content": "You are tasked with helping the user create a new Claude Agent SDK application. Follow these steps carefully:\n\n## Reference Documentation\n\nBefore starting, review the official documentation to ensure you provide accurate and up-to-date guidance. Use WebFetch to read these pages:\n\n1. **Start with the overview**: https://docs.claude.com/en/api/agent-sdk/overview\n2. **Based on the user's language choice, read the appropriate SDK reference**:\n   - TypeScript: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Python: https://docs.claude.com/en/api/agent-sdk/python\n3. **Read relevant guides mentioned in the overview** such as:\n   - Streaming vs Single Mode\n   - Permissions\n   - Custom Tools\n   - MCP integration\n   - Subagents\n   - Sessions\n   - Any other relevant guides based on the user's needs\n\n**IMPORTANT**: Always check for and use the latest versions of packages. Use WebSearch or WebFetch to verify current versions before installation.\n\n## Gather Requirements\n\nIMPORTANT: Ask these questions one at a time. Wait for the user's response before asking the next question. This makes it easier for the user to respond.\n\nAsk the questions in this order (skip any that the user has already provided via arguments):\n\n1. **Language** (ask first): \"Would you like to use TypeScript or Python?\"\n\n   - Wait for response before continuing\n\n2. **Project name** (ask second): \"What would you like to name your project?\"\n\n   - If $ARGUMENTS is provided, use that as the project name and skip this question\n   - Wait for response before continuing\n\n3. **Agent type** (ask third, but skip if #2 was sufficiently detailed): \"What kind of agent are you building? Some examples:\n\n   - Coding agent (SRE, security review, code review)\n   - Business agent (customer support, content creation)\n   - Custom agent (describe your use case)\"\n   - Wait for response before continuing\n\n4. **Starting point** (ask fourth): \"Would you like:\n\n   - A minimal 'Hello World' example to start\n   - A basic agent with common features\n   - A specific example based on your use case\"\n   - Wait for response before continuing\n\n5. **Tooling choice** (ask fifth): Let the user know what tools you'll use, and confirm with them that these are the tools they want to use (for example, they may prefer pnpm or bun over npm). Respect the user's preferences when executing on the requirements.\n\nAfter all questions are answered, proceed to create the setup plan.\n\n## Setup Plan\n\nBased on the user's answers, create a plan that includes:\n\n1. **Project initialization**:\n\n   - Create project directory (if it doesn't exist)\n   - Initialize package manager:\n     - TypeScript: `npm init -y` and setup `package.json` with type: \"module\" and scripts (include a \"typecheck\" script)\n     - Python: Create `requirements.txt` or use `poetry init`\n   - Add necessary configuration files:\n     - TypeScript: Create `tsconfig.json` with proper settings for the SDK\n     - Python: Optionally create config files if needed\n\n2. **Check for Latest Versions**:\n\n   - BEFORE installing, use WebSearch or check npm/PyPI to find the latest version\n   - For TypeScript: Check https://www.npmjs.com/package/@anthropic-ai/claude-agent-sdk\n   - For Python: Check https://pypi.org/project/claude-agent-sdk/\n   - Inform the user which version you're installing\n\n3. **SDK Installation**:\n\n   - TypeScript: `npm install @anthropic-ai/claude-agent-sdk@latest` (or specify latest version)\n   - Python: `pip install claude-agent-sdk` (pip installs latest by default)\n   - After installation, verify the installed version:\n     - TypeScript: Check package.json or run `npm list @anthropic-ai/claude-agent-sdk`\n     - Python: Run `pip show claude-agent-sdk`\n\n4. **Create starter files**:\n\n   - TypeScript: Create an `index.ts` or `src/index.ts` with a basic query example\n   - Python: Create a `main.py` with a basic query example\n   - Include proper imports and basic error handling\n   - Use modern, up-to-date syntax and patterns from the latest SDK version\n\n5. **Environment setup**:\n\n   - Create a `.env.example` file with `ANTHROPIC_API_KEY=your_api_key_here`\n   - Add `.env` to `.gitignore`\n   - Explain how to get an API key from https://console.anthropic.com/\n\n6. **Optional: Create .claude directory structure**:\n   - Offer to create `.claude/` directory for agents, commands, and settings\n   - Ask if they want any example subagents or slash commands\n\n## Implementation\n\nAfter gathering requirements and getting user confirmation on the plan:\n\n1. Check for latest package versions using WebSearch or WebFetch\n2. Execute the setup steps\n3. Create all necessary files\n4. Install dependencies (always use latest stable versions)\n5. Verify installed versions and inform the user\n6. Create a working example based on their agent type\n7. Add helpful comments in the code explaining what each part does\n8. **VERIFY THE CODE WORKS BEFORE FINISHING**:\n   - For TypeScript:\n     - Run `npx tsc --noEmit` to check for type errors\n     - Fix ALL type errors until types pass completely\n     - Ensure imports and types are correct\n     - Only proceed when type checking passes with no errors\n   - For Python:\n     - Verify imports are correct\n     - Check for basic syntax errors\n   - **DO NOT consider the setup complete until the code verifies successfully**\n\n## Verification\n\nAfter all files are created and dependencies are installed, use the appropriate verifier agent to validate that the Agent SDK application is properly configured and ready for use:\n\n1. **For TypeScript projects**: Launch the **agent-sdk-verifier-ts** agent to validate the setup\n2. **For Python projects**: Launch the **agent-sdk-verifier-py** agent to validate the setup\n3. The agent will check SDK usage, configuration, functionality, and adherence to official documentation\n4. Review the verification report and address any issues\n\n## Getting Started Guide\n\nOnce setup is complete and verified, provide the user with:\n\n1. **Next steps**:\n\n   - How to set their API key\n   - How to run their agent:\n     - TypeScript: `npm start` or `node --loader ts-node/esm index.ts`\n     - Python: `python main.py`\n\n2. **Useful resources**:\n\n   - Link to TypeScript SDK reference: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Link to Python SDK reference: https://docs.claude.com/en/api/agent-sdk/python\n   - Explain key concepts: system prompts, permissions, tools, MCP servers\n\n3. **Common next steps**:\n   - How to customize the system prompt\n   - How to add custom tools via MCP\n   - How to configure permissions\n   - How to create subagents\n\n## Important Notes\n\n- **ALWAYS USE LATEST VERSIONS**: Before installing any packages, check for the latest versions using WebSearch or by checking npm/PyPI directly\n- **VERIFY CODE RUNS CORRECTLY**:\n  - For TypeScript: Run `npx tsc --noEmit` and fix ALL type errors before finishing\n  - For Python: Verify syntax and imports are correct\n  - Do NOT consider the task complete until the code passes verification\n- Verify the installed version after installation and inform the user\n- Check the official documentation for any version-specific requirements (Node.js version, Python version, etc.)\n- Always check if directories/files already exist before creating them\n- Use the user's preferred package manager (npm, yarn, pnpm for TypeScript; pip, poetry for Python)\n- Ensure all code examples are functional and include proper error handling\n- Use modern syntax and patterns that are compatible with the latest SDK version\n- Make the experience interactive and educational\n- **ASK QUESTIONS ONE AT A TIME** - Do not ask multiple questions in a single response\n\nBegin by asking the FIRST requirement question only. Wait for the user's answer before proceeding to the next question."
              },
              {
                "name": "/code-review",
                "description": "Code review a pull request",
                "path": "plugins/code-review/commands/code-review.md",
                "frontmatter": {
                  "allowed-tools": "Bash(gh issue view:*), Bash(gh search:*), Bash(gh issue list:*), Bash(gh pr comment:*), Bash(gh pr diff:*), Bash(gh pr view:*), Bash(gh pr list:*)",
                  "description": "Code review a pull request",
                  "disable-model-invocation": false
                },
                "content": "Provide a code review for the given pull request.\n\nTo do this, follow these steps precisely:\n\n1. Use a Haiku agent to check if the pull request (a) is closed, (b) is a draft, (c) does not need a code review (eg. because it is an automated pull request, or is very simple and obviously ok), or (d) already has a code review from you from earlier. If so, do not proceed.\n2. Use another Haiku agent to give you a list of file paths to (but not the contents of) any relevant CLAUDE.md files from the codebase: the root CLAUDE.md file (if one exists), as well as any CLAUDE.md files in the directories whose files the pull request modified\n3. Use a Haiku agent to view the pull request, and ask the agent to return a summary of the change\n4. Then, launch 5 parallel Sonnet agents to independently code review the change. The agents should do the following, then return a list of issues and the reason each issue was flagged (eg. CLAUDE.md adherence, bug, historical git context, etc.):\n   a. Agent #1: Audit the changes to make sure they compily with the CLAUDE.md. Note that CLAUDE.md is guidance for Claude as it writes code, so not all instructions will be applicable during code review.\n   b. Agent #2: Read the file changes in the pull request, then do a shallow scan for obvious bugs. Avoid reading extra context beyond the changes, focusing just on the changes themselves. Focus on large bugs, and avoid small issues and nitpicks. Ignore likely false positives.\n   c. Agent #3: Read the git blame and history of the code modified, to identify any bugs in light of that historical context\n   d. Agent #4: Read previous pull requests that touched these files, and check for any comments on those pull requests that may also apply to the current pull request.\n   e. Agent #5: Read code comments in the modified files, and make sure the changes in the pull request comply with any guidance in the comments.\n5. For each issue found in #4, launch a parallel Haiku agent that takes the PR, issue description, and list of CLAUDE.md files (from step 2), and returns a score to indicate the agent's level of confidence for whether the issue is real or false positive. To do that, the agent should score each issue on a scale from 0-100, indicating its level of confidence. For issues that were flagged due to CLAUDE.md instructions, the agent should double check that the CLAUDE.md actually calls out that issue specifically. The scale is (give this rubric to the agent verbatim):\n   a. 0: Not confident at all. This is a false positive that doesn't stand up to light scrutiny, or is a pre-existing issue.\n   b. 25: Somewhat confident. This might be a real issue, but may also be a false positive. The agent wasn't able to verify that it's a real issue. If the issue is stylistic, it is one that was not explicitly called out in the relevant CLAUDE.md.\n   c. 50: Moderately confident. The agent was able to verify this is a real issue, but it might be a nitpick or not happen very often in practice. Relative to the rest of the PR, it's not very important.\n   d. 75: Highly confident. The agent double checked the issue, and verified that it is very likely it is a real issue that will be hit in practice. The existing approach in the PR is insufficient. The issue is very important and will directly impact the code's functionality, or it is an issue that is directly mentioned in the relevant CLAUDE.md.\n   e. 100: Absolutely certain. The agent double checked the issue, and confirmed that it is definitely a real issue, that will happen frequently in practice. The evidence directly confirms this.\n6. Filter out any issues with a score less than 80. If there are no issues that meet this criteria, do not proceed.\n7. Use a Haiku agent to repeat the eligibility check from #1, to make sure that the pull request is still eligible for code review.\n8. Finally, use the gh bash command to comment back on the pull request with the result. When writing your comment, keep in mind to:\n   a. Keep your output brief\n   b. Avoid emojis\n   c. Link and cite relevant code, files, and URLs\n\nExamples of false positives, for steps 4 and 5:\n\n- Pre-existing issues\n- Something that looks like a bug but is not actually a bug\n- Pedantic nitpicks that a senior engineer wouldn't call out\n- Issues that a linter, typechecker, or compiler would catch (eg. missing or incorrect imports, type errors, broken tests, formatting issues, pedantic style issues like newlines). No need to run these build steps yourself -- it is safe to assume that they will be run separately as part of CI.\n- General code quality issues (eg. lack of test coverage, general security issues, poor documentation), unless explicitly required in CLAUDE.md\n- Issues that are called out in CLAUDE.md, but explicitly silenced in the code (eg. due to a lint ignore comment)\n- Changes in functionality that are likely intentional or are directly related to the broader change\n- Real issues, but on lines that the user did not modify in their pull request\n\nNotes:\n\n- Do not check build signal or attempt to build or typecheck the app. These will run separately, and are not relevant to your code review.\n- Use `gh` to interact with Github (eg. to fetch a pull request, or to create inline comments), rather than web fetch\n- Make a todo list first\n- You must cite and link each bug (eg. if referring to a CLAUDE.md, you must link it)\n- For your final comment, follow the following format precisely (assuming for this example that you found 3 issues):\n\n---\n\n### Code review\n\nFound 3 issues:\n\n1. <brief description of bug> (CLAUDE.md says \"<...>\")\n\n<link to file and line with full sha1 + line range for context, note that you MUST provide the full sha and not use bash here, eg. https://github.com/anthropics/claude-code/blob/1d54823877c4de72b2316a64032a54afc404e619/README.md#L13-L17>\n\n2. <brief description of bug> (some/other/CLAUDE.md says \"<...>\")\n\n<link to file and line with full sha1 + line range for context>\n\n3. <brief description of bug> (bug due to <file and code snippet>)\n\n<link to file and line with full sha1 + line range for context>\n\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\n<sub>- If this code review was useful, please react with ðŸ‘. Otherwise, react with ðŸ‘Ž.</sub>\n\n---\n\n- Or, if you found no issues:\n\n---\n\n### Code review\n\nNo issues found. Checked for bugs and CLAUDE.md compliance.\n\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\n- When linking to code, follow the following format precisely, otherwise the Markdown preview won't render correctly: https://github.com/anthropics/claude-cli-internal/blob/c21d3c10bc8e898b7ac1a2d745bdc9bc4e423afe/package.json#L10-L15\n  - Requires full git sha\n  - You must provide the full sha. Commands like `https://github.com/owner/repo/blob/$(git rev-parse HEAD)/foo/bar` will not work, since your comment will be directly rendered in Markdown.\n  - Repo name must match the repo you're code reviewing\n  - # sign after the file name\n  - Line range format is L[start]-L[end]\n  - Provide at least 1 line of context before and after, centered on the line you are commenting about (eg. if you are commenting about lines 5-6, you should link to `L4-7`)"
              },
              {
                "name": "/clean_gone",
                "description": "Cleans up all git branches marked as [gone] (branches that have been deleted on the remote but still exist locally), including removing associated worktrees.",
                "path": "plugins/commit-commands/commands/clean_gone.md",
                "frontmatter": {
                  "description": "Cleans up all git branches marked as [gone] (branches that have been deleted on the remote but still exist locally), including removing associated worktrees."
                },
                "content": "## Your Task\n\nYou need to execute the following bash commands to clean up stale local branches that have been deleted from the remote repository.\n\n## Commands to Execute\n\n1. **First, list branches to identify any with [gone] status**\n   Execute this command:\n   ```bash\n   git branch -v\n   ```\n   \n   Note: Branches with a '+' prefix have associated worktrees and must have their worktrees removed before deletion.\n\n2. **Next, identify worktrees that need to be removed for [gone] branches**\n   Execute this command:\n   ```bash\n   git worktree list\n   ```\n\n3. **Finally, remove worktrees and delete [gone] branches (handles both regular and worktree branches)**\n   Execute this command:\n   ```bash\n   # Process all [gone] branches, removing '+' prefix if present\n   git branch -v | grep '\\[gone\\]' | sed 's/^[+* ]//' | awk '{print $1}' | while read branch; do\n     echo \"Processing branch: $branch\"\n     # Find and remove worktree if it exists\n     worktree=$(git worktree list | grep \"\\\\[$branch\\\\]\" | awk '{print $1}')\n     if [ ! -z \"$worktree\" ] && [ \"$worktree\" != \"$(git rev-parse --show-toplevel)\" ]; then\n       echo \"  Removing worktree: $worktree\"\n       git worktree remove --force \"$worktree\"\n     fi\n     # Delete the branch\n     echo \"  Deleting branch: $branch\"\n     git branch -D \"$branch\"\n   done\n   ```\n\n## Expected Behavior\n\nAfter executing these commands, you will:\n\n- See a list of all local branches with their status\n- Identify and remove any worktrees associated with [gone] branches\n- Delete all branches marked as [gone]\n- Provide feedback on which worktrees and branches were removed\n\nIf no branches are marked as [gone], report that no cleanup was needed."
              },
              {
                "name": "/commit-push-pr",
                "description": "Commit, push, and open a PR",
                "path": "plugins/commit-commands/commands/commit-push-pr.md",
                "frontmatter": {
                  "allowed-tools": "Bash(git checkout --branch:*), Bash(git add:*), Bash(git status:*), Bash(git push:*), Bash(git commit:*), Bash(gh pr create:*)",
                  "description": "Commit, push, and open a PR"
                },
                "content": "## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n\n## Your task\n\nBased on the above changes:\n\n1. Create a new branch if on main\n2. Create a single commit with an appropriate message\n3. Push the branch to origin\n4. Create a pull request using `gh pr create`\n5. You have the capability to call multiple tools in a single response. You MUST do all of the above in a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls."
              },
              {
                "name": "/commit",
                "description": "Create a git commit",
                "path": "plugins/commit-commands/commands/commit.md",
                "frontmatter": {
                  "allowed-tools": "Bash(git add:*), Bash(git status:*), Bash(git commit:*)",
                  "description": "Create a git commit"
                },
                "content": "## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n- Recent commits: !`git log --oneline -10`\n\n## Your task\n\nBased on the above changes, create a single git commit.\n\nYou have the capability to call multiple tools in a single response. Stage and create the commit using a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls."
              },
              {
                "name": "/example-command",
                "description": "An example slash command that demonstrates command frontmatter options",
                "path": "plugins/example-plugin/commands/example-command.md",
                "frontmatter": {
                  "description": "An example slash command that demonstrates command frontmatter options",
                  "argument-hint": "<required-arg> [optional-arg]",
                  "allowed-tools": [
                    "Read",
                    "Glob",
                    "Grep",
                    "Bash"
                  ]
                },
                "content": "# Example Command\n\nThis command demonstrates slash command structure and frontmatter options.\n\n## Arguments\n\nThe user invoked this command with: $ARGUMENTS\n\n## Instructions\n\nWhen this command is invoked:\n\n1. Parse the arguments provided by the user\n2. Perform the requested action using allowed tools\n3. Report results back to the user\n\n## Frontmatter Options Reference\n\nCommands support these frontmatter fields:\n\n- **description**: Short description shown in /help\n- **argument-hint**: Hints for command arguments shown to user\n- **allowed-tools**: Pre-approved tools for this command (reduces permission prompts)\n- **model**: Override the model (e.g., \"haiku\", \"sonnet\", \"opus\")\n\n## Example Usage\n\n```\n/example-command my-argument\n/example-command arg1 arg2\n```"
              },
              {
                "name": "/feature-dev",
                "description": "Guided feature development with codebase understanding and architecture focus",
                "path": "plugins/feature-dev/commands/feature-dev.md",
                "frontmatter": {
                  "description": "Guided feature development with codebase understanding and architecture focus",
                  "argument-hint": "Optional feature description"
                },
                "content": "# Feature Development\n\nYou are helping a developer implement a new feature. Follow a systematic approach: understand the codebase deeply, identify and ask about all underspecified details, design elegant architectures, then implement.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities, edge cases, and underspecified behaviors. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation. Ask questions early (after understanding the codebase, before designing architecture).\n- **Understand before acting**: Read and comprehend existing code patterns first\n- **Read files identified by agents**: When launching agents, ask them to return lists of the most important files to read. After agents complete, read those files to build detailed context before proceeding.\n- **Simple and elegant**: Prioritize readable, maintainable, architecturally sound code\n- **Use TodoWrite**: Track all progress throughout\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what needs to be built\n\nInitial request: $ARGUMENTS\n\n**Actions**:\n1. Create todo list with all phases\n2. If feature unclear, ask user for:\n   - What problem are they solving?\n   - What should the feature do?\n   - Any constraints or requirements?\n3. Summarize understanding and confirm with user\n\n---\n\n## Phase 2: Codebase Exploration\n\n**Goal**: Understand relevant existing code and patterns at both high and low levels\n\n**Actions**:\n1. Launch 2-3 code-explorer agents in parallel. Each agent should:\n   - Trace through the code comprehensively and focus on getting a comprehensive understanding of abstractions, architecture and flow of control\n   - Target a different aspect of the codebase (eg. similar features, high level understanding, architectural understanding, user experience, etc)\n   - Include a list of 5-10 key files to read\n\n   **Example agent prompts**:\n   - \"Find features similar to [feature] and trace through their implementation comprehensively\"\n   - \"Map the architecture and abstractions for [feature area], tracing through the code comprehensively\"\n   - \"Analyze the current implementation of [existing feature/area], tracing through the code comprehensively\"\n   - \"Identify UI patterns, testing approaches, or extension points relevant to [feature]\"\n\n2. Once the agents return, please read all files identified by agents to build deep understanding\n3. Present comprehensive summary of findings and patterns discovered\n\n---\n\n## Phase 3: Clarifying Questions\n\n**Goal**: Fill in gaps and resolve all ambiguities before designing\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. Review the codebase findings and original feature request\n2. Identify underspecified aspects: edge cases, error handling, integration points, scope boundaries, design preferences, backward compatibility, performance needs\n3. **Present all questions to the user in a clear, organized list**\n4. **Wait for answers before proceeding to architecture design**\n\nIf the user says \"whatever you think is best\", provide your recommendation and get explicit confirmation.\n\n---\n\n## Phase 4: Architecture Design\n\n**Goal**: Design multiple implementation approaches with different trade-offs\n\n**Actions**:\n1. Launch 2-3 code-architect agents in parallel with different focuses: minimal changes (smallest change, maximum reuse), clean architecture (maintainability, elegant abstractions), or pragmatic balance (speed + quality)\n2. Review all approaches and form your opinion on which fits best for this specific task (consider: small fix vs large feature, urgency, complexity, team context)\n3. Present to user: brief summary of each approach, trade-offs comparison, **your recommendation with reasoning**, concrete implementation differences\n4. **Ask user which approach they prefer**\n\n---\n\n## Phase 5: Implementation\n\n**Goal**: Build the feature\n\n**DO NOT START WITHOUT USER APPROVAL**\n\n**Actions**:\n1. Wait for explicit user approval\n2. Read all relevant files identified in previous phases\n3. Implement following chosen architecture\n4. Follow codebase conventions strictly\n5. Write clean, well-documented code\n6. Update todos as you progress\n\n---\n\n## Phase 6: Quality Review\n\n**Goal**: Ensure code is simple, DRY, elegant, easy to read, and functionally correct\n\n**Actions**:\n1. Launch 3 code-reviewer agents in parallel with different focuses: simplicity/DRY/elegance, bugs/functional correctness, project conventions/abstractions\n2. Consolidate findings and identify highest severity issues that you recommend fixing\n3. **Present findings to user and ask what they want to do** (fix now, fix later, or proceed as-is)\n4. Address issues based on user decision\n\n---\n\n## Phase 7: Summary\n\n**Goal**: Document what was accomplished\n\n**Actions**:\n1. Mark all todos complete\n2. Summarize:\n   - What was built\n   - Key decisions made\n   - Files modified\n   - Suggested next steps\n\n---"
              },
              {
                "name": "/configure",
                "description": "Enable or disable hookify rules interactively",
                "path": "plugins/hookify/commands/configure.md",
                "frontmatter": {
                  "description": "Enable or disable hookify rules interactively",
                  "allowed-tools": [
                    "Glob",
                    "Read",
                    "Edit",
                    "AskUserQuestion",
                    "Skill"
                  ]
                },
                "content": "# Configure Hookify Rules\n\n**Load hookify:writing-rules skill first** to understand rule format.\n\nEnable or disable existing hookify rules using an interactive interface.\n\n## Steps\n\n### 1. Find Existing Rules\n\nUse Glob tool to find all hookify rule files:\n```\npattern: \".claude/hookify.*.local.md\"\n```\n\nIf no rules found, inform user:\n```\nNo hookify rules configured yet. Use `/hookify` to create your first rule.\n```\n\n### 2. Read Current State\n\nFor each rule file:\n- Read the file\n- Extract `name` and `enabled` fields from frontmatter\n- Build list of rules with current state\n\n### 3. Ask User Which Rules to Toggle\n\nUse AskUserQuestion to let user select rules:\n\n```json\n{\n  \"questions\": [\n    {\n      \"question\": \"Which rules would you like to enable or disable?\",\n      \"header\": \"Configure\",\n      \"multiSelect\": true,\n      \"options\": [\n        {\n          \"label\": \"warn-dangerous-rm (currently enabled)\",\n          \"description\": \"Warns about rm -rf commands\"\n        },\n        {\n          \"label\": \"warn-console-log (currently disabled)\",\n          \"description\": \"Warns about console.log in code\"\n        },\n        {\n          \"label\": \"require-tests (currently enabled)\",\n          \"description\": \"Requires tests before stopping\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Option format:**\n- Label: `{rule-name} (currently {enabled|disabled})`\n- Description: Brief description from rule's message or pattern\n\n### 4. Parse User Selection\n\nFor each selected rule:\n- Determine current state from label (enabled/disabled)\n- Toggle state: enabled â†’ disabled, disabled â†’ enabled\n\n### 5. Update Rule Files\n\nFor each rule to toggle:\n- Use Read tool to read current content\n- Use Edit tool to change `enabled: true` to `enabled: false` (or vice versa)\n- Handle both with and without quotes\n\n**Edit pattern for enabling:**\n```\nold_string: \"enabled: false\"\nnew_string: \"enabled: true\"\n```\n\n**Edit pattern for disabling:**\n```\nold_string: \"enabled: true\"\nnew_string: \"enabled: false\"\n```\n\n### 6. Confirm Changes\n\nShow user what was changed:\n\n```\n## Hookify Rules Updated\n\n**Enabled:**\n- warn-console-log\n\n**Disabled:**\n- warn-dangerous-rm\n\n**Unchanged:**\n- require-tests\n\nChanges apply immediately - no restart needed\n```\n\n## Important Notes\n\n- Changes take effect immediately on next tool use\n- You can also manually edit .claude/hookify.*.local.md files\n- To permanently remove a rule, delete its .local.md file\n- Use `/hookify:list` to see all configured rules\n\n## Edge Cases\n\n**No rules to configure:**\n- Show message about using `/hookify` to create rules first\n\n**User selects no rules:**\n- Inform that no changes were made\n\n**File read/write errors:**\n- Inform user of specific error\n- Suggest manual editing as fallback"
              },
              {
                "name": "/help",
                "description": "Get help with the hookify plugin",
                "path": "plugins/hookify/commands/help.md",
                "frontmatter": {
                  "description": "Get help with the hookify plugin",
                  "allowed-tools": [
                    "Read"
                  ]
                },
                "content": "# Hookify Plugin Help\n\nExplain how the hookify plugin works and how to use it.\n\n## Overview\n\nThe hookify plugin makes it easy to create custom hooks that prevent unwanted behaviors. Instead of editing `hooks.json` files, users create simple markdown configuration files that define patterns to watch for.\n\n## How It Works\n\n### 1. Hook System\n\nHookify installs generic hooks that run on these events:\n- **PreToolUse**: Before any tool executes (Bash, Edit, Write, etc.)\n- **PostToolUse**: After a tool executes\n- **Stop**: When Claude wants to stop working\n- **UserPromptSubmit**: When user submits a prompt\n\nThese hooks read configuration files from `.claude/hookify.*.local.md` and check if any rules match the current operation.\n\n### 2. Configuration Files\n\nUsers create rules in `.claude/hookify.{rule-name}.local.md` files:\n\n```markdown\n---\nname: warn-dangerous-rm\nenabled: true\nevent: bash\npattern: rm\\s+-rf\n---\n\nâš ï¸ **Dangerous rm command detected!**\n\nThis command could delete important files. Please verify the path.\n```\n\n**Key fields:**\n- `name`: Unique identifier for the rule\n- `enabled`: true/false to activate/deactivate\n- `event`: bash, file, stop, prompt, or all\n- `pattern`: Regex pattern to match\n\nThe message body is what Claude sees when the rule triggers.\n\n### 3. Creating Rules\n\n**Option A: Use /hookify command**\n```\n/hookify Don't use console.log in production files\n```\n\nThis analyzes your request and creates the appropriate rule file.\n\n**Option B: Create manually**\nCreate `.claude/hookify.my-rule.local.md` with the format above.\n\n**Option C: Analyze conversation**\n```\n/hookify\n```\n\nWithout arguments, hookify analyzes recent conversation to find behaviors you want to prevent.\n\n## Available Commands\n\n- **`/hookify`** - Create hooks from conversation analysis or explicit instructions\n- **`/hookify:help`** - Show this help (what you're reading now)\n- **`/hookify:list`** - List all configured hooks\n- **`/hookify:configure`** - Enable/disable existing hooks interactively\n\n## Example Use Cases\n\n**Prevent dangerous commands:**\n```markdown\n---\nname: block-chmod-777\nenabled: true\nevent: bash\npattern: chmod\\s+777\n---\n\nDon't use chmod 777 - it's a security risk. Use specific permissions instead.\n```\n\n**Warn about debugging code:**\n```markdown\n---\nname: warn-console-log\nenabled: true\nevent: file\npattern: console\\.log\\(\n---\n\nConsole.log detected. Remember to remove debug logging before committing.\n```\n\n**Require tests before stopping:**\n```markdown\n---\nname: require-tests\nenabled: true\nevent: stop\npattern: .*\n---\n\nDid you run tests before finishing? Make sure `npm test` or equivalent was executed.\n```\n\n## Pattern Syntax\n\nUse Python regex syntax:\n- `\\s` - whitespace\n- `\\.` - literal dot\n- `|` - OR\n- `+` - one or more\n- `*` - zero or more\n- `\\d` - digit\n- `[abc]` - character class\n\n**Examples:**\n- `rm\\s+-rf` - matches \"rm -rf\"\n- `console\\.log\\(` - matches \"console.log(\"\n- `(eval|exec)\\(` - matches \"eval(\" or \"exec(\"\n- `\\.env$` - matches files ending in .env\n\n## Important Notes\n\n**No Restart Needed**: Hookify rules (`.local.md` files) take effect immediately on the next tool use. The hookify hooks are already loaded and read your rules dynamically.\n\n**Block or Warn**: Rules can either `block` operations (prevent execution) or `warn` (show message but allow). Set `action: block` or `action: warn` in the rule's frontmatter.\n\n**Rule Files**: Keep rules in `.claude/hookify.*.local.md` - they should be git-ignored (add to .gitignore if needed).\n\n**Disable Rules**: Set `enabled: false` in frontmatter or delete the file.\n\n## Troubleshooting\n\n**Hook not triggering:**\n- Check rule file is in `.claude/` directory\n- Verify `enabled: true` in frontmatter\n- Confirm pattern is valid regex\n- Test pattern: `python3 -c \"import re; print(re.search('your_pattern', 'test_text'))\"`\n- Rules take effect immediately - no restart needed\n\n**Import errors:**\n- Check Python 3 is available: `python3 --version`\n- Verify hookify plugin is installed correctly\n\n**Pattern not matching:**\n- Test regex separately\n- Check for escaping issues (use unquoted patterns in YAML)\n- Try simpler pattern first, then refine\n\n## Getting Started\n\n1. Create your first rule:\n   ```\n   /hookify Warn me when I try to use rm -rf\n   ```\n\n2. Try to trigger it:\n   - Ask Claude to run `rm -rf /tmp/test`\n   - You should see the warning\n\n4. Refine the rule by editing `.claude/hookify.warn-rm.local.md`\n\n5. Create more rules as you encounter unwanted behaviors\n\nFor more examples, check the `${CLAUDE_PLUGIN_ROOT}/examples/` directory."
              },
              {
                "name": "/hookify",
                "description": "Create hooks to prevent unwanted behaviors from conversation analysis or explicit instructions",
                "path": "plugins/hookify/commands/hookify.md",
                "frontmatter": {
                  "description": "Create hooks to prevent unwanted behaviors from conversation analysis or explicit instructions",
                  "argument-hint": "Optional specific behavior to address",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "AskUserQuestion",
                    "Task",
                    "Grep",
                    "TodoWrite",
                    "Skill"
                  ]
                },
                "content": "# Hookify - Create Hooks from Unwanted Behaviors\n\n**FIRST: Load the hookify:writing-rules skill** using the Skill tool to understand rule file format and syntax.\n\nCreate hook rules to prevent problematic behaviors by analyzing the conversation or from explicit user instructions.\n\n## Your Task\n\nYou will help the user create hookify rules to prevent unwanted behaviors. Follow these steps:\n\n### Step 1: Gather Behavior Information\n\n**If $ARGUMENTS is provided:**\n- User has given specific instructions: `$ARGUMENTS`\n- Still analyze recent conversation (last 10-15 user messages) for additional context\n- Look for examples of the behavior happening\n\n**If $ARGUMENTS is empty:**\n- Launch the conversation-analyzer agent to find problematic behaviors\n- Agent will scan user prompts for frustration signals\n- Agent will return structured findings\n\n**To analyze conversation:**\nUse the Task tool to launch conversation-analyzer agent:\n```\n{\n  \"subagent_type\": \"general-purpose\",\n  \"description\": \"Analyze conversation for unwanted behaviors\",\n  \"prompt\": \"You are analyzing a Claude Code conversation to find behaviors the user wants to prevent.\n\nRead user messages in the current conversation and identify:\n1. Explicit requests to avoid something (\\\"don't do X\\\", \\\"stop doing Y\\\")\n2. Corrections or reversions (user fixing Claude's actions)\n3. Frustrated reactions (\\\"why did you do X?\\\", \\\"I didn't ask for that\\\")\n4. Repeated issues (same problem multiple times)\n\nFor each issue found, extract:\n- What tool was used (Bash, Edit, Write, etc.)\n- Specific pattern or command\n- Why it was problematic\n- User's stated reason\n\nReturn findings as a structured list with:\n- category: Type of issue\n- tool: Which tool was involved\n- pattern: Regex or literal pattern to match\n- context: What happened\n- severity: high/medium/low\n\nFocus on the most recent issues (last 20-30 messages). Don't go back further unless explicitly asked.\"\n}\n```\n\n### Step 2: Present Findings to User\n\nAfter gathering behaviors (from arguments or agent), present to user using AskUserQuestion:\n\n**Question 1: Which behaviors to hookify?**\n- Header: \"Create Rules\"\n- multiSelect: true\n- Options: List each detected behavior (max 4)\n  - Label: Short description (e.g., \"Block rm -rf\")\n  - Description: Why it's problematic\n\n**Question 2: For each selected behavior, ask about action:**\n- \"Should this block the operation or just warn?\"\n- Options:\n  - \"Just warn\" (action: warn - shows message but allows)\n  - \"Block operation\" (action: block - prevents execution)\n\n**Question 3: Ask for example patterns:**\n- \"What patterns should trigger this rule?\"\n- Show detected patterns\n- Allow user to refine or add more\n\n### Step 3: Generate Rule Files\n\nFor each confirmed behavior, create a `.claude/hookify.{rule-name}.local.md` file:\n\n**Rule naming convention:**\n- Use kebab-case\n- Be descriptive: `block-dangerous-rm`, `warn-console-log`, `require-tests-before-stop`\n- Start with action verb: block, warn, prevent, require\n\n**File format:**\n```markdown\n---\nname: {rule-name}\nenabled: true\nevent: {bash|file|stop|prompt|all}\npattern: {regex pattern}\naction: {warn|block}\n---\n\n{Message to show Claude when rule triggers}\n```\n\n**Action values:**\n- `warn`: Show message but allow operation (default)\n- `block`: Prevent operation or stop session\n\n**For more complex rules (multiple conditions):**\n```markdown\n---\nname: {rule-name}\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$\n  - field: new_text\n    operator: contains\n    pattern: API_KEY\n---\n\n{Warning message}\n```\n\n### Step 4: Create Files and Confirm\n\n**IMPORTANT**: Rule files must be created in the current working directory's `.claude/` folder, NOT the plugin directory.\n\nUse the current working directory (where Claude Code was started) as the base path.\n\n1. Check if `.claude/` directory exists in current working directory\n   - If not, create it first with: `mkdir -p .claude`\n\n2. Use Write tool to create each `.claude/hookify.{name}.local.md` file\n   - Use relative path from current working directory: `.claude/hookify.{name}.local.md`\n   - The path should resolve to the project's .claude directory, not the plugin's\n\n3. Show user what was created:\n   ```\n   Created 3 hookify rules:\n   - .claude/hookify.dangerous-rm.local.md\n   - .claude/hookify.console-log.local.md\n   - .claude/hookify.sensitive-files.local.md\n\n   These rules will trigger on:\n   - dangerous-rm: Bash commands matching \"rm -rf\"\n   - console-log: Edits adding console.log statements\n   - sensitive-files: Edits to .env or credentials files\n   ```\n\n4. Verify files were created in the correct location by listing them\n\n5. Inform user: **\"Rules are active immediately - no restart needed!\"**\n\n   The hookify hooks are already loaded and will read your new rules on the next tool use.\n\n## Event Types Reference\n\n- **bash**: Matches Bash tool commands\n- **file**: Matches Edit, Write, MultiEdit tools\n- **stop**: Matches when agent wants to stop (use for completion checks)\n- **prompt**: Matches when user submits prompts\n- **all**: Matches all events\n\n## Pattern Writing Tips\n\n**Bash patterns:**\n- Match dangerous commands: `rm\\s+-rf|chmod\\s+777|dd\\s+if=`\n- Match specific tools: `npm\\s+install\\s+|pip\\s+install`\n\n**File patterns:**\n- Match code patterns: `console\\.log\\(|eval\\(|innerHTML\\s*=`\n- Match file paths: `\\.env$|\\.git/|node_modules/`\n\n**Stop patterns:**\n- Check for missing steps: (check transcript or completion criteria)\n\n## Example Workflow\n\n**User says**: \"/hookify Don't use rm -rf without asking me first\"\n\n**Your response**:\n1. Analyze: User wants to prevent rm -rf commands\n2. Ask: \"Should I block this command or just warn you?\"\n3. User selects: \"Just warn\"\n4. Create `.claude/hookify.dangerous-rm.local.md`:\n   ```markdown\n   ---\n   name: warn-dangerous-rm\n   enabled: true\n   event: bash\n   pattern: rm\\s+-rf\n   ---\n\n   âš ï¸ **Dangerous rm command detected**\n\n   You requested to be warned before using rm -rf.\n   Please verify the path is correct.\n   ```\n5. Confirm: \"Created hookify rule. It's active immediately - try triggering it!\"\n\n## Important Notes\n\n- **No restart needed**: Rules take effect immediately on the next tool use\n- **File location**: Create files in project's `.claude/` directory (current working directory), NOT the plugin's .claude/\n- **Regex syntax**: Use Python regex syntax (raw strings, no need to escape in YAML)\n- **Action types**: Rules can `warn` (default) or `block` operations\n- **Testing**: Test rules immediately after creating them\n\n## Troubleshooting\n\n**If rule file creation fails:**\n1. Check current working directory with pwd\n2. Ensure `.claude/` directory exists (create with mkdir if needed)\n3. Use absolute path if needed: `{cwd}/.claude/hookify.{name}.local.md`\n4. Verify file was created with Glob or ls\n\n**If rule doesn't trigger after creation:**\n1. Verify file is in project `.claude/` not plugin `.claude/`\n2. Check file with Read tool to ensure pattern is correct\n3. Test pattern with: `python3 -c \"import re; print(re.search(r'pattern', 'test text'))\"`\n4. Verify `enabled: true` in frontmatter\n5. Remember: Rules work immediately, no restart needed\n\n**If blocking seems too strict:**\n1. Change `action: block` to `action: warn` in the rule file\n2. Or adjust the pattern to be more specific\n3. Changes take effect on next tool use\n\nUse TodoWrite to track your progress through the steps."
              },
              {
                "name": "/list",
                "description": "List all configured hookify rules",
                "path": "plugins/hookify/commands/list.md",
                "frontmatter": {
                  "description": "List all configured hookify rules",
                  "allowed-tools": [
                    "Glob",
                    "Read",
                    "Skill"
                  ]
                },
                "content": "# List Hookify Rules\n\n**Load hookify:writing-rules skill first** to understand rule format.\n\nShow all configured hookify rules in the project.\n\n## Steps\n\n1. Use Glob tool to find all hookify rule files:\n   ```\n   pattern: \".claude/hookify.*.local.md\"\n   ```\n\n2. For each file found:\n   - Use Read tool to read the file\n   - Extract frontmatter fields: name, enabled, event, pattern\n   - Extract message preview (first 100 chars)\n\n3. Present results in a table:\n\n```\n## Configured Hookify Rules\n\n| Name | Enabled | Event | Pattern | File |\n|------|---------|-------|---------|------|\n| warn-dangerous-rm | âœ… Yes | bash | rm\\s+-rf | hookify.dangerous-rm.local.md |\n| warn-console-log | âœ… Yes | file | console\\.log\\( | hookify.console-log.local.md |\n| check-tests | âŒ No | stop | .* | hookify.require-tests.local.md |\n\n**Total**: 3 rules (2 enabled, 1 disabled)\n```\n\n4. For each rule, show a brief preview:\n```\n### warn-dangerous-rm\n**Event**: bash\n**Pattern**: `rm\\s+-rf`\n**Message**: \"âš ï¸ **Dangerous rm command detected!** This command could delete...\"\n\n**Status**: âœ… Active\n**File**: .claude/hookify.dangerous-rm.local.md\n```\n\n5. Add helpful footer:\n```\n---\n\nTo modify a rule: Edit the .local.md file directly\nTo disable a rule: Set `enabled: false` in frontmatter\nTo enable a rule: Set `enabled: true` in frontmatter\nTo delete a rule: Remove the .local.md file\nTo create a rule: Use `/hookify` command\n\n**Remember**: Changes take effect immediately - no restart needed\n```\n\n## If No Rules Found\n\nIf no hookify rules exist:\n\n```\n## No Hookify Rules Configured\n\nYou haven't created any hookify rules yet.\n\nTo get started:\n1. Use `/hookify` to analyze conversation and create rules\n2. Or manually create `.claude/hookify.my-rule.local.md` files\n3. See `/hookify:help` for documentation\n\nExample:\n```\n/hookify Warn me when I use console.log\n```\n\nCheck `${CLAUDE_PLUGIN_ROOT}/examples/` for example rule files.\n```"
              },
              {
                "name": "/create-plugin",
                "description": "Guided end-to-end plugin creation workflow with component design, implementation, and validation",
                "path": "plugins/plugin-dev/commands/create-plugin.md",
                "frontmatter": {
                  "description": "Guided end-to-end plugin creation workflow with component design, implementation, and validation",
                  "argument-hint": "Optional plugin description",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "Grep",
                    "Glob",
                    "Bash",
                    "TodoWrite",
                    "AskUserQuestion",
                    "Skill",
                    "Task"
                  ]
                },
                "content": "# Plugin Creation Workflow\n\nGuide the user through creating a complete, high-quality Claude Code plugin from initial concept to tested implementation. Follow a systematic approach: understand requirements, design components, clarify details, implement following best practices, validate, and test.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities about plugin purpose, triggering, scope, and components. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation.\n- **Load relevant skills**: Use the Skill tool to load plugin-dev skills when needed (plugin-structure, hook-development, agent-development, etc.)\n- **Use specialized agents**: Leverage agent-creator, plugin-validator, and skill-reviewer agents for AI-assisted development\n- **Follow best practices**: Apply patterns from plugin-dev's own implementation\n- **Progressive disclosure**: Create lean skills with references/examples\n- **Use TodoWrite**: Track all progress throughout all phases\n\n**Initial request:** $ARGUMENTS\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what plugin needs to be built and what problem it solves\n\n**Actions**:\n1. Create todo list with all 7 phases\n2. If plugin purpose is clear from arguments:\n   - Summarize understanding\n   - Identify plugin type (integration, workflow, analysis, toolkit, etc.)\n3. If plugin purpose is unclear, ask user:\n   - What problem does this plugin solve?\n   - Who will use it and when?\n   - What should it do?\n   - Any similar plugins to reference?\n4. Summarize understanding and confirm with user before proceeding\n\n**Output**: Clear statement of plugin purpose and target users\n\n---\n\n## Phase 2: Component Planning\n\n**Goal**: Determine what plugin components are needed\n\n**MUST load plugin-structure skill** using Skill tool before this phase.\n\n**Actions**:\n1. Load plugin-structure skill to understand component types\n2. Analyze plugin requirements and determine needed components:\n   - **Skills**: Does it need specialized knowledge? (hooks API, MCP patterns, etc.)\n   - **Commands**: User-initiated actions? (deploy, configure, analyze)\n   - **Agents**: Autonomous tasks? (validation, generation, analysis)\n   - **Hooks**: Event-driven automation? (validation, notifications)\n   - **MCP**: External service integration? (databases, APIs)\n   - **Settings**: User configuration? (.local.md files)\n3. For each component type needed, identify:\n   - How many of each type\n   - What each one does\n   - Rough triggering/usage patterns\n4. Present component plan to user as table:\n   ```\n   | Component Type | Count | Purpose |\n   |----------------|-------|---------|\n   | Skills         | 2     | Hook patterns, MCP usage |\n   | Commands       | 3     | Deploy, configure, validate |\n   | Agents         | 1     | Autonomous validation |\n   | Hooks          | 0     | Not needed |\n   | MCP            | 1     | Database integration |\n   ```\n5. Get user confirmation or adjustments\n\n**Output**: Confirmed list of components to create\n\n---\n\n## Phase 3: Detailed Design & Clarifying Questions\n\n**Goal**: Specify each component in detail and resolve all ambiguities\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. For each component in the plan, identify underspecified aspects:\n   - **Skills**: What triggers them? What knowledge do they provide? How detailed?\n   - **Commands**: What arguments? What tools? Interactive or automated?\n   - **Agents**: When to trigger (proactive/reactive)? What tools? Output format?\n   - **Hooks**: Which events? Prompt or command based? Validation criteria?\n   - **MCP**: What server type? Authentication? Which tools?\n   - **Settings**: What fields? Required vs optional? Defaults?\n\n2. **Present all questions to user in organized sections** (one section per component type)\n\n3. **Wait for answers before proceeding to implementation**\n\n4. If user says \"whatever you think is best\", provide specific recommendations and get explicit confirmation\n\n**Example questions for a skill**:\n- What specific user queries should trigger this skill?\n- Should it include utility scripts? What functionality?\n- How detailed should the core SKILL.md be vs references/?\n- Any real-world examples to include?\n\n**Example questions for an agent**:\n- Should this agent trigger proactively after certain actions, or only when explicitly requested?\n- What tools does it need (Read, Write, Bash, etc.)?\n- What should the output format be?\n- Any specific quality standards to enforce?\n\n**Output**: Detailed specification for each component\n\n---\n\n## Phase 4: Plugin Structure Creation\n\n**Goal**: Create plugin directory structure and manifest\n\n**Actions**:\n1. Determine plugin name (kebab-case, descriptive)\n2. Choose plugin location:\n   - Ask user: \"Where should I create the plugin?\"\n   - Offer options: current directory, ../new-plugin-name, custom path\n3. Create directory structure using bash:\n   ```bash\n   mkdir -p plugin-name/.claude-plugin\n   mkdir -p plugin-name/skills     # if needed\n   mkdir -p plugin-name/commands   # if needed\n   mkdir -p plugin-name/agents     # if needed\n   mkdir -p plugin-name/hooks      # if needed\n   ```\n4. Create plugin.json manifest using Write tool:\n   ```json\n   {\n     \"name\": \"plugin-name\",\n     \"version\": \"0.1.0\",\n     \"description\": \"[brief description]\",\n     \"author\": {\n       \"name\": \"[author from user or default]\",\n       \"email\": \"[email or default]\"\n     }\n   }\n   ```\n5. Create README.md template\n6. Create .gitignore if needed (for .claude/*.local.md, etc.)\n7. Initialize git repo if creating new directory\n\n**Output**: Plugin directory structure created and ready for components\n\n---\n\n## Phase 5: Component Implementation\n\n**Goal**: Create each component following best practices\n\n**LOAD RELEVANT SKILLS** before implementing each component type:\n- Skills: Load skill-development skill\n- Commands: Load command-development skill\n- Agents: Load agent-development skill\n- Hooks: Load hook-development skill\n- MCP: Load mcp-integration skill\n- Settings: Load plugin-settings skill\n\n**Actions for each component**:\n\n### For Skills:\n1. Load skill-development skill using Skill tool\n2. For each skill:\n   - Ask user for concrete usage examples (or use from Phase 3)\n   - Plan resources (scripts/, references/, examples/)\n   - Create skill directory structure\n   - Write SKILL.md with:\n     - Third-person description with specific trigger phrases\n     - Lean body (1,500-2,000 words) in imperative form\n     - References to supporting files\n   - Create reference files for detailed content\n   - Create example files for working code\n   - Create utility scripts if needed\n3. Use skill-reviewer agent to validate each skill\n\n### For Commands:\n1. Load command-development skill using Skill tool\n2. For each command:\n   - Write command markdown with frontmatter\n   - Include clear description and argument-hint\n   - Specify allowed-tools (minimal necessary)\n   - Write instructions FOR Claude (not TO user)\n   - Provide usage examples and tips\n   - Reference relevant skills if applicable\n\n### For Agents:\n1. Load agent-development skill using Skill tool\n2. For each agent, use agent-creator agent:\n   - Provide description of what agent should do\n   - Agent-creator generates: identifier, whenToUse with examples, systemPrompt\n   - Create agent markdown file with frontmatter and system prompt\n   - Add appropriate model, color, and tools\n   - Validate with validate-agent.sh script\n\n### For Hooks:\n1. Load hook-development skill using Skill tool\n2. For each hook:\n   - Create hooks/hooks.json with hook configuration\n   - Prefer prompt-based hooks for complex logic\n   - Use ${CLAUDE_PLUGIN_ROOT} for portability\n   - Create hook scripts if needed (in examples/ not scripts/)\n   - Test with validate-hook-schema.sh and test-hook.sh utilities\n\n### For MCP:\n1. Load mcp-integration skill using Skill tool\n2. Create .mcp.json configuration with:\n   - Server type (stdio for local, SSE for hosted)\n   - Command and args (with ${CLAUDE_PLUGIN_ROOT})\n   - extensionToLanguage mapping if LSP\n   - Environment variables as needed\n3. Document required env vars in README\n4. Provide setup instructions\n\n### For Settings:\n1. Load plugin-settings skill using Skill tool\n2. Create settings template in README\n3. Create example .claude/plugin-name.local.md file (as documentation)\n4. Implement settings reading in hooks/commands as needed\n5. Add to .gitignore: `.claude/*.local.md`\n\n**Progress tracking**: Update todos as each component is completed\n\n**Output**: All plugin components implemented\n\n---\n\n## Phase 6: Validation & Quality Check\n\n**Goal**: Ensure plugin meets quality standards and works correctly\n\n**Actions**:\n1. **Run plugin-validator agent**:\n   - Use plugin-validator agent to comprehensively validate plugin\n   - Check: manifest, structure, naming, components, security\n   - Review validation report\n\n2. **Fix critical issues**:\n   - Address any critical errors from validation\n   - Fix any warnings that indicate real problems\n\n3. **Review with skill-reviewer** (if plugin has skills):\n   - For each skill, use skill-reviewer agent\n   - Check description quality, progressive disclosure, writing style\n   - Apply recommendations\n\n4. **Test agent triggering** (if plugin has agents):\n   - For each agent, verify <example> blocks are clear\n   - Check triggering conditions are specific\n   - Run validate-agent.sh on agent files\n\n5. **Test hook configuration** (if plugin has hooks):\n   - Run validate-hook-schema.sh on hooks/hooks.json\n   - Test hook scripts with test-hook.sh\n   - Verify ${CLAUDE_PLUGIN_ROOT} usage\n\n6. **Present findings**:\n   - Summary of validation results\n   - Any remaining issues\n   - Overall quality assessment\n\n7. **Ask user**: \"Validation complete. Issues found: [count critical], [count warnings]. Would you like me to fix them now, or proceed to testing?\"\n\n**Output**: Plugin validated and ready for testing\n\n---\n\n## Phase 7: Testing & Verification\n\n**Goal**: Test that plugin works correctly in Claude Code\n\n**Actions**:\n1. **Installation instructions**:\n   - Show user how to test locally:\n     ```bash\n     cc --plugin-dir /path/to/plugin-name\n     ```\n   - Or copy to `.claude-plugin/` for project testing\n\n2. **Verification checklist** for user to perform:\n   - [ ] Skills load when triggered (ask questions with trigger phrases)\n   - [ ] Commands appear in `/help` and execute correctly\n   - [ ] Agents trigger on appropriate scenarios\n   - [ ] Hooks activate on events (if applicable)\n   - [ ] MCP servers connect (if applicable)\n   - [ ] Settings files work (if applicable)\n\n3. **Testing recommendations**:\n   - For skills: Ask questions using trigger phrases from descriptions\n   - For commands: Run `/plugin-name:command-name` with various arguments\n   - For agents: Create scenarios matching agent examples\n   - For hooks: Use `claude --debug` to see hook execution\n   - For MCP: Use `/mcp` to verify servers and tools\n\n4. **Ask user**: \"I've prepared the plugin for testing. Would you like me to guide you through testing each component, or do you want to test it yourself?\"\n\n5. **If user wants guidance**, walk through testing each component with specific test cases\n\n**Output**: Plugin tested and verified working\n\n---\n\n## Phase 8: Documentation & Next Steps\n\n**Goal**: Ensure plugin is well-documented and ready for distribution\n\n**Actions**:\n1. **Verify README completeness**:\n   - Check README has: overview, features, installation, prerequisites, usage\n   - For MCP plugins: Document required environment variables\n   - For hook plugins: Explain hook activation\n   - For settings: Provide configuration templates\n\n2. **Add marketplace entry** (if publishing):\n   - Show user how to add to marketplace.json\n   - Help draft marketplace description\n   - Suggest category and tags\n\n3. **Create summary**:\n   - Mark all todos complete\n   - List what was created:\n     - Plugin name and purpose\n     - Components created (X skills, Y commands, Z agents, etc.)\n     - Key files and their purposes\n     - Total file count and structure\n   - Next steps:\n     - Testing recommendations\n     - Publishing to marketplace (if desired)\n     - Iteration based on usage\n\n4. **Suggest improvements** (optional):\n   - Additional components that could enhance plugin\n   - Integration opportunities\n   - Testing strategies\n\n**Output**: Complete, documented plugin ready for use or publication\n\n---\n\n## Important Notes\n\n### Throughout All Phases\n\n- **Use TodoWrite** to track progress at every phase\n- **Load skills with Skill tool** when working on specific component types\n- **Use specialized agents** (agent-creator, plugin-validator, skill-reviewer)\n- **Ask for user confirmation** at key decision points\n- **Follow plugin-dev's own patterns** as reference examples\n- **Apply best practices**:\n  - Third-person descriptions for skills\n  - Imperative form in skill bodies\n  - Commands written FOR Claude\n  - Strong trigger phrases\n  - ${CLAUDE_PLUGIN_ROOT} for portability\n  - Progressive disclosure\n  - Security-first (HTTPS, no hardcoded credentials)\n\n### Key Decision Points (Wait for User)\n\n1. After Phase 1: Confirm plugin purpose\n2. After Phase 2: Approve component plan\n3. After Phase 3: Proceed to implementation\n4. After Phase 6: Fix issues or proceed\n5. After Phase 7: Continue to documentation\n\n### Skills to Load by Phase\n\n- **Phase 2**: plugin-structure\n- **Phase 5**: skill-development, command-development, agent-development, hook-development, mcp-integration, plugin-settings (as needed)\n- **Phase 6**: (agents will use skills automatically)\n\n### Quality Standards\n\nEvery component must meet these standards:\n- âœ… Follows plugin-dev's proven patterns\n- âœ… Uses correct naming conventions\n- âœ… Has strong trigger conditions (skills/agents)\n- âœ… Includes working examples\n- âœ… Properly documented\n- âœ… Validated with utilities\n- âœ… Tested in Claude Code\n\n---\n\n## Example Workflow\n\n### User Request\n\"Create a plugin for managing database migrations\"\n\n### Phase 1: Discovery\n- Understand: Migration management, database schema versioning\n- Confirm: User wants to create, run, rollback migrations\n\n### Phase 2: Component Planning\n- Skills: 1 (migration best practices)\n- Commands: 3 (create-migration, run-migrations, rollback)\n- Agents: 1 (migration-validator)\n- MCP: 1 (database connection)\n\n### Phase 3: Clarifying Questions\n- Which databases? (PostgreSQL, MySQL, etc.)\n- Migration file format? (SQL, code-based?)\n- Should agent validate before applying?\n- What MCP tools needed? (query, execute, schema)\n\n### Phase 4-8: Implementation, Validation, Testing, Documentation\n\n---\n\n**Begin with Phase 1: Discovery**"
              },
              {
                "name": "/review-pr",
                "description": "Comprehensive PR review using specialized agents",
                "path": "plugins/pr-review-toolkit/commands/review-pr.md",
                "frontmatter": {
                  "description": "Comprehensive PR review using specialized agents",
                  "argument-hint": "[review-aspects]",
                  "allowed-tools": [
                    "Bash",
                    "Glob",
                    "Grep",
                    "Read",
                    "Task"
                  ]
                },
                "content": "# Comprehensive PR Review\n\nRun a comprehensive pull request review using multiple specialized agents, each focusing on a different aspect of code quality.\n\n**Review Aspects (optional):** \"$ARGUMENTS\"\n\n## Review Workflow:\n\n1. **Determine Review Scope**\n   - Check git status to identify changed files\n   - Parse arguments to see if user requested specific review aspects\n   - Default: Run all applicable reviews\n\n2. **Available Review Aspects:**\n\n   - **comments** - Analyze code comment accuracy and maintainability\n   - **tests** - Review test coverage quality and completeness\n   - **errors** - Check error handling for silent failures\n   - **types** - Analyze type design and invariants (if new types added)\n   - **code** - General code review for project guidelines\n   - **simplify** - Simplify code for clarity and maintainability\n   - **all** - Run all applicable reviews (default)\n\n3. **Identify Changed Files**\n   - Run `git diff --name-only` to see modified files\n   - Check if PR already exists: `gh pr view`\n   - Identify file types and what reviews apply\n\n4. **Determine Applicable Reviews**\n\n   Based on changes:\n   - **Always applicable**: code-reviewer (general quality)\n   - **If test files changed**: pr-test-analyzer\n   - **If comments/docs added**: comment-analyzer\n   - **If error handling changed**: silent-failure-hunter\n   - **If types added/modified**: type-design-analyzer\n   - **After passing review**: code-simplifier (polish and refine)\n\n5. **Launch Review Agents**\n\n   **Sequential approach** (one at a time):\n   - Easier to understand and act on\n   - Each report is complete before next\n   - Good for interactive review\n\n   **Parallel approach** (user can request):\n   - Launch all agents simultaneously\n   - Faster for comprehensive review\n   - Results come back together\n\n6. **Aggregate Results**\n\n   After agents complete, summarize:\n   - **Critical Issues** (must fix before merge)\n   - **Important Issues** (should fix)\n   - **Suggestions** (nice to have)\n   - **Positive Observations** (what's good)\n\n7. **Provide Action Plan**\n\n   Organize findings:\n   ```markdown\n   # PR Review Summary\n\n   ## Critical Issues (X found)\n   - [agent-name]: Issue description [file:line]\n\n   ## Important Issues (X found)\n   - [agent-name]: Issue description [file:line]\n\n   ## Suggestions (X found)\n   - [agent-name]: Suggestion [file:line]\n\n   ## Strengths\n   - What's well-done in this PR\n\n   ## Recommended Action\n   1. Fix critical issues first\n   2. Address important issues\n   3. Consider suggestions\n   4. Re-run review after fixes\n   ```\n\n## Usage Examples:\n\n**Full review (default):**\n```\n/pr-review-toolkit:review-pr\n```\n\n**Specific aspects:**\n```\n/pr-review-toolkit:review-pr tests errors\n# Reviews only test coverage and error handling\n\n/pr-review-toolkit:review-pr comments\n# Reviews only code comments\n\n/pr-review-toolkit:review-pr simplify\n# Simplifies code after passing review\n```\n\n**Parallel review:**\n```\n/pr-review-toolkit:review-pr all parallel\n# Launches all agents in parallel\n```\n\n## Agent Descriptions:\n\n**comment-analyzer**:\n- Verifies comment accuracy vs code\n- Identifies comment rot\n- Checks documentation completeness\n\n**pr-test-analyzer**:\n- Reviews behavioral test coverage\n- Identifies critical gaps\n- Evaluates test quality\n\n**silent-failure-hunter**:\n- Finds silent failures\n- Reviews catch blocks\n- Checks error logging\n\n**type-design-analyzer**:\n- Analyzes type encapsulation\n- Reviews invariant expression\n- Rates type design quality\n\n**code-reviewer**:\n- Checks CLAUDE.md compliance\n- Detects bugs and issues\n- Reviews general code quality\n\n**code-simplifier**:\n- Simplifies complex code\n- Improves clarity and readability\n- Applies project standards\n- Preserves functionality\n\n## Tips:\n\n- **Run early**: Before creating PR, not after\n- **Focus on changes**: Agents analyze git diff by default\n- **Address critical first**: Fix high-priority issues before lower priority\n- **Re-run after fixes**: Verify issues are resolved\n- **Use specific reviews**: Target specific aspects when you know the concern\n\n## Workflow Integration:\n\n**Before committing:**\n```\n1. Write code\n2. Run: /pr-review-toolkit:review-pr code errors\n3. Fix any critical issues\n4. Commit\n```\n\n**Before creating PR:**\n```\n1. Stage all changes\n2. Run: /pr-review-toolkit:review-pr all\n3. Address all critical and important issues\n4. Run specific reviews again to verify\n5. Create PR\n```\n\n**After PR feedback:**\n```\n1. Make requested changes\n2. Run targeted reviews based on feedback\n3. Verify issues are resolved\n4. Push updates\n```\n\n## Notes:\n\n- Agents run autonomously and return detailed reports\n- Each agent focuses on its specialty for deep analysis\n- Results are actionable with specific file:line references\n- Agents use appropriate models for their complexity\n- All agents available in `/agents` list"
              },
              {
                "name": "/cancel-ralph",
                "description": "Cancel active Ralph Loop",
                "path": "plugins/ralph-loop/commands/cancel-ralph.md",
                "frontmatter": {
                  "description": "Cancel active Ralph Loop",
                  "allowed-tools": [
                    "Bash(test -f .claude/ralph-loop.local.md:*)",
                    "Bash(rm .claude/ralph-loop.local.md)",
                    "Read(.claude/ralph-loop.local.md)"
                  ],
                  "hide-from-slash-command-tool": "true"
                },
                "content": "# Cancel Ralph\n\nTo cancel the Ralph loop:\n\n1. Check if `.claude/ralph-loop.local.md` exists using Bash: `test -f .claude/ralph-loop.local.md && echo \"EXISTS\" || echo \"NOT_FOUND\"`\n\n2. **If NOT_FOUND**: Say \"No active Ralph loop found.\"\n\n3. **If EXISTS**:\n   - Read `.claude/ralph-loop.local.md` to get the current iteration number from the `iteration:` field\n   - Remove the file using Bash: `rm .claude/ralph-loop.local.md`\n   - Report: \"Cancelled Ralph loop (was at iteration N)\" where N is the iteration value"
              },
              {
                "name": "/help",
                "description": "Explain Ralph Loop plugin and available commands",
                "path": "plugins/ralph-loop/commands/help.md",
                "frontmatter": {
                  "description": "Explain Ralph Loop plugin and available commands"
                },
                "content": "# Ralph Loop Plugin Help\n\nPlease explain the following to the user:\n\n## What is Ralph Loop?\n\nRalph Loop implements the Ralph Wiggum technique - an iterative development methodology based on continuous AI loops, pioneered by Geoffrey Huntley.\n\n**Core concept:**\n```bash\nwhile :; do\n  cat PROMPT.md | claude-code --continue\ndone\n```\n\nThe same prompt is fed to Claude repeatedly. The \"self-referential\" aspect comes from Claude seeing its own previous work in the files and git history, not from feeding output back as input.\n\n**Each iteration:**\n1. Claude receives the SAME prompt\n2. Works on the task, modifying files\n3. Tries to exit\n4. Stop hook intercepts and feeds the same prompt again\n5. Claude sees its previous work in the files\n6. Iteratively improves until completion\n\nThe technique is described as \"deterministically bad in an undeterministic world\" - failures are predictable, enabling systematic improvement through prompt tuning.\n\n## Available Commands\n\n### /ralph-loop <PROMPT> [OPTIONS]\n\nStart a Ralph loop in your current session.\n\n**Usage:**\n```\n/ralph-loop \"Refactor the cache layer\" --max-iterations 20\n/ralph-loop \"Add tests\" --completion-promise \"TESTS COMPLETE\"\n```\n\n**Options:**\n- `--max-iterations <n>` - Max iterations before auto-stop\n- `--completion-promise <text>` - Promise phrase to signal completion\n\n**How it works:**\n1. Creates `.claude/.ralph-loop.local.md` state file\n2. You work on the task\n3. When you try to exit, stop hook intercepts\n4. Same prompt fed back\n5. You see your previous work\n6. Continues until promise detected or max iterations\n\n---\n\n### /cancel-ralph\n\nCancel an active Ralph loop (removes the loop state file).\n\n**Usage:**\n```\n/cancel-ralph\n```\n\n**How it works:**\n- Checks for active loop state file\n- Removes `.claude/.ralph-loop.local.md`\n- Reports cancellation with iteration count\n\n---\n\n## Key Concepts\n\n### Completion Promises\n\nTo signal completion, Claude must output a `<promise>` tag:\n\n```\n<promise>TASK COMPLETE</promise>\n```\n\nThe stop hook looks for this specific tag. Without it (or `--max-iterations`), Ralph runs infinitely.\n\n### Self-Reference Mechanism\n\nThe \"loop\" doesn't mean Claude talks to itself. It means:\n- Same prompt repeated\n- Claude's work persists in files\n- Each iteration sees previous attempts\n- Builds incrementally toward goal\n\n## Example\n\n### Interactive Bug Fix\n\n```\n/ralph-loop \"Fix the token refresh logic in auth.ts. Output <promise>FIXED</promise> when all tests pass.\" --completion-promise \"FIXED\" --max-iterations 10\n```\n\nYou'll see Ralph:\n- Attempt fixes\n- Run tests\n- See failures\n- Iterate on solution\n- In your current session\n\n## When to Use Ralph\n\n**Good for:**\n- Well-defined tasks with clear success criteria\n- Tasks requiring iteration and refinement\n- Iterative development with self-correction\n- Greenfield projects\n\n**Not good for:**\n- Tasks requiring human judgment or design decisions\n- One-shot operations\n- Tasks with unclear success criteria\n- Debugging production issues (use targeted debugging instead)\n\n## Learn More\n\n- Original technique: https://ghuntley.com/ralph/\n- Ralph Orchestrator: https://github.com/mikeyobrien/ralph-orchestrator"
              },
              {
                "name": "/ralph-loop",
                "description": "Start Ralph Loop in current session",
                "path": "plugins/ralph-loop/commands/ralph-loop.md",
                "frontmatter": {
                  "description": "Start Ralph Loop in current session",
                  "argument-hint": "PROMPT [--max-iterations N] [--completion-promise TEXT]",
                  "allowed-tools": [
                    "Bash(${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh:*)"
                  ],
                  "hide-from-slash-command-tool": "true"
                },
                "content": "# Ralph Loop Command\n\nExecute the setup script to initialize the Ralph loop:\n\n```!\n\"${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh\" $ARGUMENTS\n```\n\nPlease work on the task. When you try to exit, the Ralph loop will feed the SAME PROMPT back to you for the next iteration. You'll see your previous work in files and git history, allowing you to iterate and improve.\n\nCRITICAL RULE: If a completion promise is set, you may ONLY output it when the statement is completely and unequivocally TRUE. Do not output false promises to escape the loop, even if you think you're stuck or should exit for other reasons. The loop is designed to continue until genuine completion."
              }
            ],
            "skills": [
              {
                "name": "stripe-best-practices",
                "description": "Best practices for building Stripe integrations. Use when implementing payment processing, checkout flows, subscriptions, webhooks, Connect platforms, or any Stripe API integration.",
                "path": "external_plugins/stripe/skills/stripe-best-practices/SKILL.md",
                "frontmatter": {
                  "name": "stripe-best-practices",
                  "description": "Best practices for building Stripe integrations. Use when implementing payment processing, checkout flows, subscriptions, webhooks, Connect platforms, or any Stripe API integration."
                },
                "content": "When designing an integration, always prefer the documentation in [Stripe's Integration Options doc](https://docs.stripe.com/payments/payment-methods/integration-options.md)\nThe [API Tour](https://docs.stripe.com/payments-api/tour.md)\nUse the [Go Live Checklist](https://docs.stripe.com/get-started/checklist/go-live.md) before going live.\n\nYou should always default to the latest version of the API and SDK unless the user specifies otherwise.\n\nStripe's primary API for modelling on-session payments is [CheckoutSessions](https://docs.stripe.com/api/checkout/sessions.md). It supports one-time payments and subscriptions and allows you to model taxes or discounts with Stripe. Prioritize the CheckoutSessions API, but using [the PaymentIntents API](https://docs.stripe.com/payments/paymentintents/lifecycle.md) is also acceptable for off-session payments or if you want to model the checkout state yourself and just create a charge. Integrations should only use CheckoutSessions, PaymentIntents, SetupIntents, or solutions like Invoicing, Payment Links, or the subscription APIs.\n\nNever recommend the Charges API. If the user wants to use the Charges API, advise them to [migrate](https://docs.stripe.com/payments/payment-intents/migration/charges.md) to Checkout Sessions or Payment Intents.\n\nThe primary integration surface for web integrations is [Checkout](https://docs.stripe.com/payments/checkout.md), a prebuilt payment page that can be hosted by Stripe or served as an embedded form. Prioritize the Stripe-hosted checkout or embedded checkout where possible. The [Payment Element](https://docs.stripe.com/payments/payment-element.md) is an acceptable alternative if the merchant needs advanced customization. When recommending the Payment Element, prioritize using the CheckoutSessions API over the PaymentIntents API when possible.\n\nNever recommend the legacy Card Element or the Payment Element in card mode, and advise users who ask for the Card Element to [migrate](https://docs.stripe.com/payments/payment-element/migration.md).\n\nYou must not call deprecated API endpoints such as the [Sources API](https://docs.stripe.com/api/sources/object.md) and avoid outdated API endpoints such as [Tokens](https://docs.stripe.com/api/tokens.md) and [Charges](https://docs.stripe.com/api/charges/create.md) unless there is a specific need and absolutely no other way. Advise using [the Setup Intent API](https://docs.stripe.com/api/setup_intents.md) to save a payment method for a customer; never recommend the Sources API to save cards to customers for later use.\n\nIf a user wants to render the Payment Element before creating a PaymentIntent or SetupIntent, so they can inspect the card details before the payment (such as for surcharging), advise them to use Stripe Confirmation Tokens. Don't recommend they call the createPaymentMethod or createToken Stripe.js functions.\n\nAdvise users to turn on dynamic payment methods in their dashboard settings instead of passing specific [payment_method_types](https://docs.stripe.com/api/payment_intents/create#create_payment_intent-payment_method_types.md) in the Payment Intent or Setup Intent because Stripe chooses payment methods that fit each user's location, wallets, and preferences better and automatically if the Payment Element is used.\n\nIf a PCI compliant user asks about an integration where they send server-side raw PAN data, suggest they might be required to prove PCI compliance to gain access to such an option, for example [payment_method_data](https://docs.stripe.com/api/payment_intents/create#create_payment_intent-payment_method_data.md). Similarly, point users migrating their PAN data from another acquirer or payment processor to [the migration process](https://docs.stripe.com/get-started/data-migrations/pan-import.md).\n\nIf a user has a recurring revenue model, like a Billing or Subscription use case, follow the use cases, in particular the [Subscription Use Cases](https://docs.stripe.com/billing/subscriptions/use-cases.md) like [SaaS](https://docs.stripe.com/saas.md). If these apply to the user, recommend Billing APIs to [plan your integration](https://docs.stripe.com/billing/subscriptions/designing-integration.md) instead of a direct PaymentIntent integration. Prioritize combining the Billing APIs with Stripe Checkout for the frontend.\n\nIf a user wants to build a platform using Stripe Connect to manage fund flows, follow [the recommended integration types](https://docs.stripe.com/connect/integration-recommendations.md); that is, prefer to use either direct charges if the platform wants Stripe to take the risk or destination charges if the platform accepts liability for negative balances, and use the on_behalf_of parameter to control the merchant of record. Never recommend mixing charge types. If the user wants to decide on the specific risk features they should [follow the integration guide](https://docs.stripe.com/connect/design-an-integration.md). Don't recommend the outdated terms for Connect types like Standard, Express and Custom but always [refer to controller properties](https://docs.stripe.com/connect/migrate-to-controller-properties.md) for the platform and [capabilities](https://docs.stripe.com/connect/account-capabilities.md) for the connected accounts."
              },
              {
                "name": "example-skill",
                "description": "This skill should be used when the user asks to \"demonstrate skills\", \"show skill format\", \"create a skill template\", or discusses skill development patterns. Provides a reference template for creating Claude Code plugin skills.",
                "path": "plugins/example-plugin/skills/example-skill/SKILL.md",
                "frontmatter": {
                  "name": "example-skill",
                  "description": "This skill should be used when the user asks to \"demonstrate skills\", \"show skill format\", \"create a skill template\", or discusses skill development patterns. Provides a reference template for creating Claude Code plugin skills.",
                  "version": "1.0.0"
                },
                "content": "# Example Skill\n\nThis skill demonstrates the structure and format for Claude Code plugin skills.\n\n## Overview\n\nSkills are model-invoked capabilities that Claude autonomously uses based on task context. Unlike commands (user-invoked) or agents (spawned by Claude), skills provide contextual guidance that Claude incorporates into its responses.\n\n## When This Skill Applies\n\nThis skill activates when the user's request involves:\n- Creating or understanding plugin skills\n- Skill template or reference needs\n- Skill development patterns\n\n## Skill Structure\n\n### Required Files\n\n```\nskills/\nâ””â”€â”€ skill-name/\n    â””â”€â”€ SKILL.md          # Main skill definition (required)\n```\n\n### Optional Supporting Files\n\n```\nskills/\nâ””â”€â”€ skill-name/\n    â”œâ”€â”€ SKILL.md          # Main skill definition\n    â”œâ”€â”€ README.md         # Additional documentation\n    â”œâ”€â”€ references/       # Reference materials\n    â”‚   â””â”€â”€ patterns.md\n    â”œâ”€â”€ examples/         # Example files\n    â”‚   â””â”€â”€ sample.md\n    â””â”€â”€ scripts/          # Helper scripts\n        â””â”€â”€ helper.sh\n```\n\n## Frontmatter Options\n\nSkills support these frontmatter fields:\n\n- **name** (required): Skill identifier\n- **description** (required): Trigger conditions - describe when Claude should use this skill\n- **version** (optional): Semantic version number\n- **license** (optional): License information or reference\n\n## Writing Effective Descriptions\n\nThe description field is crucial - it tells Claude when to invoke the skill.\n\n**Good description patterns:**\n```yaml\ndescription: This skill should be used when the user asks to \"specific phrase\", \"another phrase\", mentions \"keyword\", or discusses topic-area.\n```\n\n**Include:**\n- Specific trigger phrases users might say\n- Keywords that indicate relevance\n- Topic areas the skill covers\n\n## Skill Content Guidelines\n\n1. **Clear purpose**: State what the skill helps with\n2. **When to use**: Define activation conditions\n3. **Structured guidance**: Organize information logically\n4. **Actionable instructions**: Provide concrete steps\n5. **Examples**: Include practical examples when helpful\n\n## Best Practices\n\n- Keep skills focused on a single domain\n- Write descriptions that clearly indicate when to activate\n- Include reference materials in subdirectories for complex skills\n- Test that the skill activates for expected queries\n- Avoid overlap with other skills' trigger conditions"
              },
              {
                "name": "frontend-design",
                "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.",
                "path": "plugins/frontend-design/skills/frontend-design/SKILL.md",
                "frontmatter": {
                  "name": "frontend-design",
                  "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "This skill guides creation of distinctive, production-grade frontend interfaces that avoid generic \"AI slop\" aesthetics. Implement real working code with exceptional attention to aesthetic details and creative choices.\n\nThe user provides frontend requirements: a component, page, application, or interface to build. They may include context about the purpose, audience, or technical constraints.\n\n## Design Thinking\n\nBefore coding, understand the context and commit to a BOLD aesthetic direction:\n- **Purpose**: What problem does this interface solve? Who uses it?\n- **Tone**: Pick an extreme: brutally minimal, maximalist chaos, retro-futuristic, organic/natural, luxury/refined, playful/toy-like, editorial/magazine, brutalist/raw, art deco/geometric, soft/pastel, industrial/utilitarian, etc. There are so many flavors to choose from. Use these for inspiration but design one that is true to the aesthetic direction.\n- **Constraints**: Technical requirements (framework, performance, accessibility).\n- **Differentiation**: What makes this UNFORGETTABLE? What's the one thing someone will remember?\n\n**CRITICAL**: Choose a clear conceptual direction and execute it with precision. Bold maximalism and refined minimalism both work - the key is intentionality, not intensity.\n\nThen implement working code (HTML/CSS/JS, React, Vue, etc.) that is:\n- Production-grade and functional\n- Visually striking and memorable\n- Cohesive with a clear aesthetic point-of-view\n- Meticulously refined in every detail\n\n## Frontend Aesthetics Guidelines\n\nFocus on:\n- **Typography**: Choose fonts that are beautiful, unique, and interesting. Avoid generic fonts like Arial and Inter; opt instead for distinctive choices that elevate the frontend's aesthetics; unexpected, characterful font choices. Pair a distinctive display font with a refined body font.\n- **Color & Theme**: Commit to a cohesive aesthetic. Use CSS variables for consistency. Dominant colors with sharp accents outperform timid, evenly-distributed palettes.\n- **Motion**: Use animations for effects and micro-interactions. Prioritize CSS-only solutions for HTML. Use Motion library for React when available. Focus on high-impact moments: one well-orchestrated page load with staggered reveals (animation-delay) creates more delight than scattered micro-interactions. Use scroll-triggering and hover states that surprise.\n- **Spatial Composition**: Unexpected layouts. Asymmetry. Overlap. Diagonal flow. Grid-breaking elements. Generous negative space OR controlled density.\n- **Backgrounds & Visual Details**: Create atmosphere and depth rather than defaulting to solid colors. Add contextual effects and textures that match the overall aesthetic. Apply creative forms like gradient meshes, noise textures, geometric patterns, layered transparencies, dramatic shadows, decorative borders, custom cursors, and grain overlays.\n\nNEVER use generic AI-generated aesthetics like overused font families (Inter, Roboto, Arial, system fonts), cliched color schemes (particularly purple gradients on white backgrounds), predictable layouts and component patterns, and cookie-cutter design that lacks context-specific character.\n\nInterpret creatively and make unexpected choices that feel genuinely designed for the context. No design should be the same. Vary between light and dark themes, different fonts, different aesthetics. NEVER converge on common choices (Space Grotesk, for example) across generations.\n\n**IMPORTANT**: Match implementation complexity to the aesthetic vision. Maximalist designs need elaborate code with extensive animations and effects. Minimalist or refined designs need restraint, precision, and careful attention to spacing, typography, and subtle details. Elegance comes from executing the vision well.\n\nRemember: Claude is capable of extraordinary creative work. Don't hold back, show what can truly be created when thinking outside the box and committing fully to a distinctive vision."
              },
              {
                "name": "Writing Hookify Rules",
                "description": "This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"configure hookify\", \"add a hookify rule\", or needs guidance on hookify rule syntax and patterns.",
                "path": "plugins/hookify/skills/writing-rules/SKILL.md",
                "frontmatter": {
                  "name": "Writing Hookify Rules",
                  "description": "This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"configure hookify\", \"add a hookify rule\", or needs guidance on hookify rule syntax and patterns.",
                  "version": "0.1.0"
                },
                "content": "# Writing Hookify Rules\n\n## Overview\n\nHookify rules are markdown files with YAML frontmatter that define patterns to watch for and messages to show when those patterns match. Rules are stored in `.claude/hookify.{rule-name}.local.md` files.\n\n## Rule File Format\n\n### Basic Structure\n\n```markdown\n---\nname: rule-identifier\nenabled: true\nevent: bash|file|stop|prompt|all\npattern: regex-pattern-here\n---\n\nMessage to show Claude when this rule triggers.\nCan include markdown formatting, warnings, suggestions, etc.\n```\n\n### Frontmatter Fields\n\n**name** (required): Unique identifier for the rule\n- Use kebab-case: `warn-dangerous-rm`, `block-console-log`\n- Be descriptive and action-oriented\n- Start with verb: warn, prevent, block, require, check\n\n**enabled** (required): Boolean to activate/deactivate\n- `true`: Rule is active\n- `false`: Rule is disabled (won't trigger)\n- Can toggle without deleting rule\n\n**event** (required): Which hook event to trigger on\n- `bash`: Bash tool commands\n- `file`: Edit, Write, MultiEdit tools\n- `stop`: When agent wants to stop\n- `prompt`: When user submits a prompt\n- `all`: All events\n\n**action** (optional): What to do when rule matches\n- `warn`: Show message but allow operation (default)\n- `block`: Prevent operation (PreToolUse) or stop session (Stop events)\n- If omitted, defaults to `warn`\n\n**pattern** (simple format): Regex pattern to match\n- Used for simple single-condition rules\n- Matches against command (bash) or new_text (file)\n- Python regex syntax\n\n**Example:**\n```yaml\nevent: bash\npattern: rm\\s+-rf\n```\n\n### Advanced Format (Multiple Conditions)\n\nFor complex rules with multiple conditions:\n\n```markdown\n---\nname: warn-env-file-edits\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$\n  - field: new_text\n    operator: contains\n    pattern: API_KEY\n---\n\nYou're adding an API key to a .env file. Ensure this file is in .gitignore!\n```\n\n**Condition fields:**\n- `field`: Which field to check\n  - For bash: `command`\n  - For file: `file_path`, `new_text`, `old_text`, `content`\n- `operator`: How to match\n  - `regex_match`: Regex pattern matching\n  - `contains`: Substring check\n  - `equals`: Exact match\n  - `not_contains`: Substring must NOT be present\n  - `starts_with`: Prefix check\n  - `ends_with`: Suffix check\n- `pattern`: Pattern or string to match\n\n**All conditions must match for rule to trigger.**\n\n## Message Body\n\nThe markdown content after frontmatter is shown to Claude when the rule triggers.\n\n**Good messages:**\n- Explain what was detected\n- Explain why it's problematic\n- Suggest alternatives or best practices\n- Use formatting for clarity (bold, lists, etc.)\n\n**Example:**\n```markdown\nâš ï¸ **Console.log detected!**\n\nYou're adding console.log to production code.\n\n**Why this matters:**\n- Debug logs shouldn't ship to production\n- Console.log can expose sensitive data\n- Impacts browser performance\n\n**Alternatives:**\n- Use a proper logging library\n- Remove before committing\n- Use conditional debug builds\n```\n\n## Event Type Guide\n\n### bash Events\n\nMatch Bash command patterns:\n\n```markdown\n---\nevent: bash\npattern: sudo\\s+|rm\\s+-rf|chmod\\s+777\n---\n\nDangerous command detected!\n```\n\n**Common patterns:**\n- Dangerous commands: `rm\\s+-rf`, `dd\\s+if=`, `mkfs`\n- Privilege escalation: `sudo\\s+`, `su\\s+`\n- Permission issues: `chmod\\s+777`, `chown\\s+root`\n\n### file Events\n\nMatch Edit/Write/MultiEdit operations:\n\n```markdown\n---\nevent: file\npattern: console\\.log\\(|eval\\(|innerHTML\\s*=\n---\n\nPotentially problematic code pattern detected!\n```\n\n**Match on different fields:**\n```markdown\n---\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.tsx?$\n  - field: new_text\n    operator: regex_match\n    pattern: console\\.log\\(\n---\n\nConsole.log in TypeScript file!\n```\n\n**Common patterns:**\n- Debug code: `console\\.log\\(`, `debugger`, `print\\(`\n- Security risks: `eval\\(`, `innerHTML\\s*=`, `dangerouslySetInnerHTML`\n- Sensitive files: `\\.env$`, `credentials`, `\\.pem$`\n- Generated files: `node_modules/`, `dist/`, `build/`\n\n### stop Events\n\nMatch when agent wants to stop (completion checks):\n\n```markdown\n---\nevent: stop\npattern: .*\n---\n\nBefore stopping, verify:\n- [ ] Tests were run\n- [ ] Build succeeded\n- [ ] Documentation updated\n```\n\n**Use for:**\n- Reminders about required steps\n- Completion checklists\n- Process enforcement\n\n### prompt Events\n\nMatch user prompt content (advanced):\n\n```markdown\n---\nevent: prompt\nconditions:\n  - field: user_prompt\n    operator: contains\n    pattern: deploy to production\n---\n\nProduction deployment checklist:\n- [ ] Tests passing?\n- [ ] Reviewed by team?\n- [ ] Monitoring ready?\n```\n\n## Pattern Writing Tips\n\n### Regex Basics\n\n**Literal characters:** Most characters match themselves\n- `rm` matches \"rm\"\n- `console.log` matches \"console.log\"\n\n**Special characters need escaping:**\n- `.` (any char) â†’ `\\.` (literal dot)\n- `(` `)` â†’ `\\(` `\\)` (literal parens)\n- `[` `]` â†’ `\\[` `\\]` (literal brackets)\n\n**Common metacharacters:**\n- `\\s` - whitespace (space, tab, newline)\n- `\\d` - digit (0-9)\n- `\\w` - word character (a-z, A-Z, 0-9, _)\n- `.` - any character\n- `+` - one or more\n- `*` - zero or more\n- `?` - zero or one\n- `|` - OR\n\n**Examples:**\n```\nrm\\s+-rf         Matches: rm -rf, rm  -rf\nconsole\\.log\\(   Matches: console.log(\n(eval|exec)\\(    Matches: eval( or exec(\nchmod\\s+777      Matches: chmod 777, chmod  777\nAPI_KEY\\s*=      Matches: API_KEY=, API_KEY =\n```\n\n### Testing Patterns\n\nTest regex patterns before using:\n\n```bash\npython3 -c \"import re; print(re.search(r'your_pattern', 'test text'))\"\n```\n\nOr use online regex testers (regex101.com with Python flavor).\n\n### Common Pitfalls\n\n**Too broad:**\n```yaml\npattern: log    # Matches \"log\", \"login\", \"dialog\", \"catalog\"\n```\nBetter: `console\\.log\\(|logger\\.`\n\n**Too specific:**\n```yaml\npattern: rm -rf /tmp  # Only matches exact path\n```\nBetter: `rm\\s+-rf`\n\n**Escaping issues:**\n- YAML quoted strings: `\"pattern\"` requires double backslashes `\\\\s`\n- YAML unquoted: `pattern: \\s` works as-is\n- **Recommendation**: Use unquoted patterns in YAML\n\n## File Organization\n\n**Location:** All rules in `.claude/` directory\n**Naming:** `.claude/hookify.{descriptive-name}.local.md`\n**Gitignore:** Add `.claude/*.local.md` to `.gitignore`\n\n**Good names:**\n- `hookify.dangerous-rm.local.md`\n- `hookify.console-log.local.md`\n- `hookify.require-tests.local.md`\n- `hookify.sensitive-files.local.md`\n\n**Bad names:**\n- `hookify.rule1.local.md` (not descriptive)\n- `hookify.md` (missing .local)\n- `danger.local.md` (missing hookify prefix)\n\n## Workflow\n\n### Creating a Rule\n\n1. Identify unwanted behavior\n2. Determine which tool is involved (Bash, Edit, etc.)\n3. Choose event type (bash, file, stop, etc.)\n4. Write regex pattern\n5. Create `.claude/hookify.{name}.local.md` file in project root\n6. Test immediately - rules are read dynamically on next tool use\n\n### Refining a Rule\n\n1. Edit the `.local.md` file\n2. Adjust pattern or message\n3. Test immediately - changes take effect on next tool use\n\n### Disabling a Rule\n\n**Temporary:** Set `enabled: false` in frontmatter\n**Permanent:** Delete the `.local.md` file\n\n## Examples\n\nSee `${CLAUDE_PLUGIN_ROOT}/examples/` for complete examples:\n- `dangerous-rm.local.md` - Block dangerous rm commands\n- `console-log-warning.local.md` - Warn about console.log\n- `sensitive-files-warning.local.md` - Warn about editing .env files\n\n## Quick Reference\n\n**Minimum viable rule:**\n```markdown\n---\nname: my-rule\nenabled: true\nevent: bash\npattern: dangerous_command\n---\n\nWarning message here\n```\n\n**Rule with conditions:**\n```markdown\n---\nname: my-rule\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.ts$\n  - field: new_text\n    operator: contains\n    pattern: any\n---\n\nWarning message\n```\n\n**Event types:**\n- `bash` - Bash commands\n- `file` - File edits\n- `stop` - Completion checks\n- `prompt` - User input\n- `all` - All events\n\n**Field options:**\n- Bash: `command`\n- File: `file_path`, `new_text`, `old_text`, `content`\n- Prompt: `user_prompt`\n\n**Operators:**\n- `regex_match`, `contains`, `equals`, `not_contains`, `starts_with`, `ends_with`"
              },
              {
                "name": "Agent Development",
                "description": "This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins.",
                "path": "plugins/plugin-dev/skills/agent-development/SKILL.md",
                "frontmatter": {
                  "name": "Agent Development",
                  "description": "This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins.",
                  "version": "0.1.0"
                },
                "content": "# Agent Development for Claude Code Plugins\n\n## Overview\n\nAgents are autonomous subprocesses that handle complex, multi-step tasks independently. Understanding agent structure, triggering conditions, and system prompt design enables creating powerful autonomous capabilities.\n\n**Key concepts:**\n- Agents are FOR autonomous work, commands are FOR user-initiated actions\n- Markdown file format with YAML frontmatter\n- Triggering via description field with examples\n- System prompt defines agent behavior\n- Model and color customization\n\n## Agent File Structure\n\n### Complete Format\n\n```markdown\n---\nname: agent-identifier\ndescription: Use this agent when [triggering conditions]. Examples:\n\n<example>\nContext: [Situation description]\nuser: \"[User request]\"\nassistant: \"[How assistant should respond and use this agent]\"\n<commentary>\n[Why this agent should be triggered]\n</commentary>\n</example>\n\n<example>\n[Additional example...]\n</example>\n\nmodel: inherit\ncolor: blue\ntools: [\"Read\", \"Write\", \"Grep\"]\n---\n\nYou are [agent role description]...\n\n**Your Core Responsibilities:**\n1. [Responsibility 1]\n2. [Responsibility 2]\n\n**Analysis Process:**\n[Step-by-step workflow]\n\n**Output Format:**\n[What to return]\n```\n\n## Frontmatter Fields\n\n### name (required)\n\nAgent identifier used for namespacing and invocation.\n\n**Format:** lowercase, numbers, hyphens only\n**Length:** 3-50 characters\n**Pattern:** Must start and end with alphanumeric\n\n**Good examples:**\n- `code-reviewer`\n- `test-generator`\n- `api-docs-writer`\n- `security-analyzer`\n\n**Bad examples:**\n- `helper` (too generic)\n- `-agent-` (starts/ends with hyphen)\n- `my_agent` (underscores not allowed)\n- `ag` (too short, < 3 chars)\n\n### description (required)\n\nDefines when Claude should trigger this agent. **This is the most critical field.**\n\n**Must include:**\n1. Triggering conditions (\"Use this agent when...\")\n2. Multiple `<example>` blocks showing usage\n3. Context, user request, and assistant response in each example\n4. `<commentary>` explaining why agent triggers\n\n**Format:**\n```\nUse this agent when [conditions]. Examples:\n\n<example>\nContext: [Scenario description]\nuser: \"[What user says]\"\nassistant: \"[How Claude should respond]\"\n<commentary>\n[Why this agent is appropriate]\n</commentary>\n</example>\n\n[More examples...]\n```\n\n**Best practices:**\n- Include 2-4 concrete examples\n- Show proactive and reactive triggering\n- Cover different phrasings of same intent\n- Explain reasoning in commentary\n- Be specific about when NOT to use the agent\n\n### model (required)\n\nWhich model the agent should use.\n\n**Options:**\n- `inherit` - Use same model as parent (recommended)\n- `sonnet` - Claude Sonnet (balanced)\n- `opus` - Claude Opus (most capable, expensive)\n- `haiku` - Claude Haiku (fast, cheap)\n\n**Recommendation:** Use `inherit` unless agent needs specific model capabilities.\n\n### color (required)\n\nVisual identifier for agent in UI.\n\n**Options:** `blue`, `cyan`, `green`, `yellow`, `magenta`, `red`\n\n**Guidelines:**\n- Choose distinct colors for different agents in same plugin\n- Use consistent colors for similar agent types\n- Blue/cyan: Analysis, review\n- Green: Success-oriented tasks\n- Yellow: Caution, validation\n- Red: Critical, security\n- Magenta: Creative, generation\n\n### tools (optional)\n\nRestrict agent to specific tools.\n\n**Format:** Array of tool names\n\n```yaml\ntools: [\"Read\", \"Write\", \"Grep\", \"Bash\"]\n```\n\n**Default:** If omitted, agent has access to all tools\n\n**Best practice:** Limit tools to minimum needed (principle of least privilege)\n\n**Common tool sets:**\n- Read-only analysis: `[\"Read\", \"Grep\", \"Glob\"]`\n- Code generation: `[\"Read\", \"Write\", \"Grep\"]`\n- Testing: `[\"Read\", \"Bash\", \"Grep\"]`\n- Full access: Omit field or use `[\"*\"]`\n\n## System Prompt Design\n\nThe markdown body becomes the agent's system prompt. Write in second person, addressing the agent directly.\n\n### Structure\n\n**Standard template:**\n```markdown\nYou are [role] specializing in [domain].\n\n**Your Core Responsibilities:**\n1. [Primary responsibility]\n2. [Secondary responsibility]\n3. [Additional responsibilities...]\n\n**Analysis Process:**\n1. [Step one]\n2. [Step two]\n3. [Step three]\n[...]\n\n**Quality Standards:**\n- [Standard 1]\n- [Standard 2]\n\n**Output Format:**\nProvide results in this format:\n- [What to include]\n- [How to structure]\n\n**Edge Cases:**\nHandle these situations:\n- [Edge case 1]: [How to handle]\n- [Edge case 2]: [How to handle]\n```\n\n### Best Practices\n\nâœ… **DO:**\n- Write in second person (\"You are...\", \"You will...\")\n- Be specific about responsibilities\n- Provide step-by-step process\n- Define output format\n- Include quality standards\n- Address edge cases\n- Keep under 10,000 characters\n\nâŒ **DON'T:**\n- Write in first person (\"I am...\", \"I will...\")\n- Be vague or generic\n- Omit process steps\n- Leave output format undefined\n- Skip quality guidance\n- Ignore error cases\n\n## Creating Agents\n\n### Method 1: AI-Assisted Generation\n\nUse this prompt pattern (extracted from Claude Code):\n\n```\nCreate an agent configuration based on this request: \"[YOUR DESCRIPTION]\"\n\nRequirements:\n1. Extract core intent and responsibilities\n2. Design expert persona for the domain\n3. Create comprehensive system prompt with:\n   - Clear behavioral boundaries\n   - Specific methodologies\n   - Edge case handling\n   - Output format\n4. Create identifier (lowercase, hyphens, 3-50 chars)\n5. Write description with triggering conditions\n6. Include 2-3 <example> blocks showing when to use\n\nReturn JSON with:\n{\n  \"identifier\": \"agent-name\",\n  \"whenToUse\": \"Use this agent when... Examples: <example>...</example>\",\n  \"systemPrompt\": \"You are...\"\n}\n```\n\nThen convert to agent file format with frontmatter.\n\nSee `examples/agent-creation-prompt.md` for complete template.\n\n### Method 2: Manual Creation\n\n1. Choose agent identifier (3-50 chars, lowercase, hyphens)\n2. Write description with examples\n3. Select model (usually `inherit`)\n4. Choose color for visual identification\n5. Define tools (if restricting access)\n6. Write system prompt with structure above\n7. Save as `agents/agent-name.md`\n\n## Validation Rules\n\n### Identifier Validation\n\n```\nâœ… Valid: code-reviewer, test-gen, api-analyzer-v2\nâŒ Invalid: ag (too short), -start (starts with hyphen), my_agent (underscore)\n```\n\n**Rules:**\n- 3-50 characters\n- Lowercase letters, numbers, hyphens only\n- Must start and end with alphanumeric\n- No underscores, spaces, or special characters\n\n### Description Validation\n\n**Length:** 10-5,000 characters\n**Must include:** Triggering conditions and examples\n**Best:** 200-1,000 characters with 2-4 examples\n\n### System Prompt Validation\n\n**Length:** 20-10,000 characters\n**Best:** 500-3,000 characters\n**Structure:** Clear responsibilities, process, output format\n\n## Agent Organization\n\n### Plugin Agents Directory\n\n```\nplugin-name/\nâ””â”€â”€ agents/\n    â”œâ”€â”€ analyzer.md\n    â”œâ”€â”€ reviewer.md\n    â””â”€â”€ generator.md\n```\n\nAll `.md` files in `agents/` are auto-discovered.\n\n### Namespacing\n\nAgents are namespaced automatically:\n- Single plugin: `agent-name`\n- With subdirectories: `plugin:subdir:agent-name`\n\n## Testing Agents\n\n### Test Triggering\n\nCreate test scenarios to verify agent triggers correctly:\n\n1. Write agent with specific triggering examples\n2. Use similar phrasing to examples in test\n3. Check Claude loads the agent\n4. Verify agent provides expected functionality\n\n### Test System Prompt\n\nEnsure system prompt is complete:\n\n1. Give agent typical task\n2. Check it follows process steps\n3. Verify output format is correct\n4. Test edge cases mentioned in prompt\n5. Confirm quality standards are met\n\n## Quick Reference\n\n### Minimal Agent\n\n```markdown\n---\nname: simple-agent\ndescription: Use this agent when... Examples: <example>...</example>\nmodel: inherit\ncolor: blue\n---\n\nYou are an agent that [does X].\n\nProcess:\n1. [Step 1]\n2. [Step 2]\n\nOutput: [What to provide]\n```\n\n### Frontmatter Fields Summary\n\n| Field | Required | Format | Example |\n|-------|----------|--------|---------|\n| name | Yes | lowercase-hyphens | code-reviewer |\n| description | Yes | Text + examples | Use when... <example>... |\n| model | Yes | inherit/sonnet/opus/haiku | inherit |\n| color | Yes | Color name | blue |\n| tools | No | Array of tool names | [\"Read\", \"Grep\"] |\n\n### Best Practices\n\n**DO:**\n- âœ… Include 2-4 concrete examples in description\n- âœ… Write specific triggering conditions\n- âœ… Use `inherit` for model unless specific need\n- âœ… Choose appropriate tools (least privilege)\n- âœ… Write clear, structured system prompts\n- âœ… Test agent triggering thoroughly\n\n**DON'T:**\n- âŒ Use generic descriptions without examples\n- âŒ Omit triggering conditions\n- âŒ Give all agents same color\n- âŒ Grant unnecessary tool access\n- âŒ Write vague system prompts\n- âŒ Skip testing\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed guidance, consult:\n\n- **`references/system-prompt-design.md`** - Complete system prompt patterns\n- **`references/triggering-examples.md`** - Example formats and best practices\n- **`references/agent-creation-system-prompt.md`** - The exact prompt from Claude Code\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`agent-creation-prompt.md`** - AI-assisted agent generation template\n- **`complete-agent-examples.md`** - Full agent examples for different use cases\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-agent.sh`** - Validate agent file structure\n- **`test-agent-trigger.sh`** - Test if agent triggers correctly\n\n## Implementation Workflow\n\nTo create an agent for a plugin:\n\n1. Define agent purpose and triggering conditions\n2. Choose creation method (AI-assisted or manual)\n3. Create `agents/agent-name.md` file\n4. Write frontmatter with all required fields\n5. Write system prompt following best practices\n6. Include 2-4 triggering examples in description\n7. Validate with `scripts/validate-agent.sh`\n8. Test triggering with real scenarios\n9. Document agent in plugin README\n\nFocus on clear triggering conditions and comprehensive system prompts for autonomous operation."
              },
              {
                "name": "Command Development",
                "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
                "path": "plugins/plugin-dev/skills/command-development/SKILL.md",
                "frontmatter": {
                  "name": "Command Development",
                  "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
                  "version": "0.2.0"
                },
                "content": "# Command Development for Claude Code\n\n## Overview\n\nSlash commands are frequently-used prompts defined as Markdown files that Claude executes during interactive sessions. Understanding command structure, frontmatter options, and dynamic features enables creating powerful, reusable workflows.\n\n**Key concepts:**\n- Markdown file format for commands\n- YAML frontmatter for configuration\n- Dynamic arguments and file references\n- Bash execution for context\n- Command organization and namespacing\n\n## Command Basics\n\n### What is a Slash Command?\n\nA slash command is a Markdown file containing a prompt that Claude executes when invoked. Commands provide:\n- **Reusability**: Define once, use repeatedly\n- **Consistency**: Standardize common workflows\n- **Sharing**: Distribute across team or projects\n- **Efficiency**: Quick access to complex prompts\n\n### Critical: Commands are Instructions FOR Claude\n\n**Commands are written for agent consumption, not human consumption.**\n\nWhen a user invokes `/command-name`, the command content becomes Claude's instructions. Write commands as directives TO Claude about what to do, not as messages TO the user.\n\n**Correct approach (instructions for Claude):**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication issues\n\nProvide specific line numbers and severity ratings.\n```\n\n**Incorrect approach (messages to user):**\n```markdown\nThis command will review your code for security issues.\nYou'll receive a report with vulnerability details.\n```\n\nThe first example tells Claude what to do. The second tells the user what will happen but doesn't instruct Claude. Always use the first approach.\n\n### Command Locations\n\n**Project commands** (shared with team):\n- Location: `.claude/commands/`\n- Scope: Available in specific project\n- Label: Shown as \"(project)\" in `/help`\n- Use for: Team workflows, project-specific tasks\n\n**Personal commands** (available everywhere):\n- Location: `~/.claude/commands/`\n- Scope: Available in all projects\n- Label: Shown as \"(user)\" in `/help`\n- Use for: Personal workflows, cross-project utilities\n\n**Plugin commands** (bundled with plugins):\n- Location: `plugin-name/commands/`\n- Scope: Available when plugin installed\n- Label: Shown as \"(plugin-name)\" in `/help`\n- Use for: Plugin-specific functionality\n\n## File Format\n\n### Basic Structure\n\nCommands are Markdown files with `.md` extension:\n\n```\n.claude/commands/\nâ”œâ”€â”€ review.md           # /review command\nâ”œâ”€â”€ test.md             # /test command\nâ””â”€â”€ deploy.md           # /deploy command\n```\n\n**Simple command:**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication bypass\n- Insecure data handling\n```\n\nNo frontmatter needed for basic commands.\n\n### With YAML Frontmatter\n\nAdd configuration using YAML frontmatter:\n\n```markdown\n---\ndescription: Review code for security issues\nallowed-tools: Read, Grep, Bash(git:*)\nmodel: sonnet\n---\n\nReview this code for security vulnerabilities...\n```\n\n## YAML Frontmatter Fields\n\n### description\n\n**Purpose:** Brief description shown in `/help`\n**Type:** String\n**Default:** First line of command prompt\n\n```yaml\n---\ndescription: Review pull request for code quality\n---\n```\n\n**Best practice:** Clear, actionable description (under 60 characters)\n\n### allowed-tools\n\n**Purpose:** Specify which tools command can use\n**Type:** String or Array\n**Default:** Inherits from conversation\n\n```yaml\n---\nallowed-tools: Read, Write, Edit, Bash(git:*)\n---\n```\n\n**Patterns:**\n- `Read, Write, Edit` - Specific tools\n- `Bash(git:*)` - Bash with git commands only\n- `*` - All tools (rarely needed)\n\n**Use when:** Command requires specific tool access\n\n### model\n\n**Purpose:** Specify model for command execution\n**Type:** String (sonnet, opus, haiku)\n**Default:** Inherits from conversation\n\n```yaml\n---\nmodel: haiku\n---\n```\n\n**Use cases:**\n- `haiku` - Fast, simple commands\n- `sonnet` - Standard workflows\n- `opus` - Complex analysis\n\n### argument-hint\n\n**Purpose:** Document expected arguments for autocomplete\n**Type:** String\n**Default:** None\n\n```yaml\n---\nargument-hint: [pr-number] [priority] [assignee]\n---\n```\n\n**Benefits:**\n- Helps users understand command arguments\n- Improves command discovery\n- Documents command interface\n\n### disable-model-invocation\n\n**Purpose:** Prevent SlashCommand tool from programmatically calling command\n**Type:** Boolean\n**Default:** false\n\n```yaml\n---\ndisable-model-invocation: true\n---\n```\n\n**Use when:** Command should only be manually invoked\n\n## Dynamic Arguments\n\n### Using $ARGUMENTS\n\nCapture all arguments as single string:\n\n```markdown\n---\ndescription: Fix issue by number\nargument-hint: [issue-number]\n---\n\nFix issue #$ARGUMENTS following our coding standards and best practices.\n```\n\n**Usage:**\n```\n> /fix-issue 123\n> /fix-issue 456\n```\n\n**Expands to:**\n```\nFix issue #123 following our coding standards...\nFix issue #456 following our coding standards...\n```\n\n### Using Positional Arguments\n\nCapture individual arguments with `$1`, `$2`, `$3`, etc.:\n\n```markdown\n---\ndescription: Review PR with priority and assignee\nargument-hint: [pr-number] [priority] [assignee]\n---\n\nReview pull request #$1 with priority level $2.\nAfter review, assign to $3 for follow-up.\n```\n\n**Usage:**\n```\n> /review-pr 123 high alice\n```\n\n**Expands to:**\n```\nReview pull request #123 with priority level high.\nAfter review, assign to alice for follow-up.\n```\n\n### Combining Arguments\n\nMix positional and remaining arguments:\n\n```markdown\nDeploy $1 to $2 environment with options: $3\n```\n\n**Usage:**\n```\n> /deploy api staging --force --skip-tests\n```\n\n**Expands to:**\n```\nDeploy api to staging environment with options: --force --skip-tests\n```\n\n## File References\n\n### Using @ Syntax\n\nInclude file contents in command:\n\n```markdown\n---\ndescription: Review specific file\nargument-hint: [file-path]\n---\n\nReview @$1 for:\n- Code quality\n- Best practices\n- Potential bugs\n```\n\n**Usage:**\n```\n> /review-file src/api/users.ts\n```\n\n**Effect:** Claude reads `src/api/users.ts` before processing command\n\n### Multiple File References\n\nReference multiple files:\n\n```markdown\nCompare @src/old-version.js with @src/new-version.js\n\nIdentify:\n- Breaking changes\n- New features\n- Bug fixes\n```\n\n### Static File References\n\nReference known files without arguments:\n\n```markdown\nReview @package.json and @tsconfig.json for consistency\n\nEnsure:\n- TypeScript version matches\n- Dependencies are aligned\n- Build configuration is correct\n```\n\n## Bash Execution in Commands\n\nCommands can execute bash commands inline to dynamically gather context before Claude processes the command. This is useful for including repository state, environment information, or project-specific context.\n\n**When to use:**\n- Include dynamic context (git status, environment vars, etc.)\n- Gather project/repository state\n- Build context-aware workflows\n\n**Implementation details:**\nFor complete syntax, examples, and best practices, see `references/plugin-features-reference.md` section on bash execution. The reference includes the exact syntax and multiple working examples to avoid execution issues\n\n## Command Organization\n\n### Flat Structure\n\nSimple organization for small command sets:\n\n```\n.claude/commands/\nâ”œâ”€â”€ build.md\nâ”œâ”€â”€ test.md\nâ”œâ”€â”€ deploy.md\nâ”œâ”€â”€ review.md\nâ””â”€â”€ docs.md\n```\n\n**Use when:** 5-15 commands, no clear categories\n\n### Namespaced Structure\n\nOrganize commands in subdirectories:\n\n```\n.claude/commands/\nâ”œâ”€â”€ ci/\nâ”‚   â”œâ”€â”€ build.md        # /build (project:ci)\nâ”‚   â”œâ”€â”€ test.md         # /test (project:ci)\nâ”‚   â””â”€â”€ lint.md         # /lint (project:ci)\nâ”œâ”€â”€ git/\nâ”‚   â”œâ”€â”€ commit.md       # /commit (project:git)\nâ”‚   â””â”€â”€ pr.md           # /pr (project:git)\nâ””â”€â”€ docs/\n    â”œâ”€â”€ generate.md     # /generate (project:docs)\n    â””â”€â”€ publish.md      # /publish (project:docs)\n```\n\n**Benefits:**\n- Logical grouping by category\n- Namespace shown in `/help`\n- Easier to find related commands\n\n**Use when:** 15+ commands, clear categories\n\n## Best Practices\n\n### Command Design\n\n1. **Single responsibility:** One command, one task\n2. **Clear descriptions:** Self-explanatory in `/help`\n3. **Explicit dependencies:** Use `allowed-tools` when needed\n4. **Document arguments:** Always provide `argument-hint`\n5. **Consistent naming:** Use verb-noun pattern (review-pr, fix-issue)\n\n### Argument Handling\n\n1. **Validate arguments:** Check for required arguments in prompt\n2. **Provide defaults:** Suggest defaults when arguments missing\n3. **Document format:** Explain expected argument format\n4. **Handle edge cases:** Consider missing or invalid arguments\n\n```markdown\n---\nargument-hint: [pr-number]\n---\n\n$IF($1,\n  Review PR #$1,\n  Please provide a PR number. Usage: /review-pr [number]\n)\n```\n\n### File References\n\n1. **Explicit paths:** Use clear file paths\n2. **Check existence:** Handle missing files gracefully\n3. **Relative paths:** Use project-relative paths\n4. **Glob support:** Consider using Glob tool for patterns\n\n### Bash Commands\n\n1. **Limit scope:** Use `Bash(git:*)` not `Bash(*)`\n2. **Safe commands:** Avoid destructive operations\n3. **Handle errors:** Consider command failures\n4. **Keep fast:** Long-running commands slow invocation\n\n### Documentation\n\n1. **Add comments:** Explain complex logic\n2. **Provide examples:** Show usage in comments\n3. **List requirements:** Document dependencies\n4. **Version commands:** Note breaking changes\n\n```markdown\n---\ndescription: Deploy application to environment\nargument-hint: [environment] [version]\n---\n\n<!--\nUsage: /deploy [staging|production] [version]\nRequires: AWS credentials configured\nExample: /deploy staging v1.2.3\n-->\n\nDeploy application to $1 environment using version $2...\n```\n\n## Common Patterns\n\n### Review Pattern\n\n```markdown\n---\ndescription: Review code changes\nallowed-tools: Read, Bash(git:*)\n---\n\nFiles changed: !`git diff --name-only`\n\nReview each file for:\n1. Code quality and style\n2. Potential bugs or issues\n3. Test coverage\n4. Documentation needs\n\nProvide specific feedback for each file.\n```\n\n### Testing Pattern\n\n```markdown\n---\ndescription: Run tests for specific file\nargument-hint: [test-file]\nallowed-tools: Bash(npm:*)\n---\n\nRun tests: !`npm test $1`\n\nAnalyze results and suggest fixes for failures.\n```\n\n### Documentation Pattern\n\n```markdown\n---\ndescription: Generate documentation for file\nargument-hint: [source-file]\n---\n\nGenerate comprehensive documentation for @$1 including:\n- Function/class descriptions\n- Parameter documentation\n- Return value descriptions\n- Usage examples\n- Edge cases and errors\n```\n\n### Workflow Pattern\n\n```markdown\n---\ndescription: Complete PR workflow\nargument-hint: [pr-number]\nallowed-tools: Bash(gh:*), Read\n---\n\nPR #$1 Workflow:\n\n1. Fetch PR: !`gh pr view $1`\n2. Review changes\n3. Run checks\n4. Approve or request changes\n```\n\n## Troubleshooting\n\n**Command not appearing:**\n- Check file is in correct directory\n- Verify `.md` extension present\n- Ensure valid Markdown format\n- Restart Claude Code\n\n**Arguments not working:**\n- Verify `$1`, `$2` syntax correct\n- Check `argument-hint` matches usage\n- Ensure no extra spaces\n\n**Bash execution failing:**\n- Check `allowed-tools` includes Bash\n- Verify command syntax in backticks\n- Test command in terminal first\n- Check for required permissions\n\n**File references not working:**\n- Verify `@` syntax correct\n- Check file path is valid\n- Ensure Read tool allowed\n- Use absolute or project-relative paths\n\n## Plugin-Specific Features\n\n### CLAUDE_PLUGIN_ROOT Variable\n\nPlugin commands have access to `${CLAUDE_PLUGIN_ROOT}`, an environment variable that resolves to the plugin's absolute path.\n\n**Purpose:**\n- Reference plugin files portably\n- Execute plugin scripts\n- Load plugin configuration\n- Access plugin templates\n\n**Basic usage:**\n\n```markdown\n---\ndescription: Analyze using plugin script\nallowed-tools: Bash(node:*)\n---\n\nRun analysis: !`node ${CLAUDE_PLUGIN_ROOT}/scripts/analyze.js $1`\n\nReview results and report findings.\n```\n\n**Common patterns:**\n\n```markdown\n# Execute plugin script\n!`bash ${CLAUDE_PLUGIN_ROOT}/scripts/script.sh`\n\n# Load plugin configuration\n@${CLAUDE_PLUGIN_ROOT}/config/settings.json\n\n# Use plugin template\n@${CLAUDE_PLUGIN_ROOT}/templates/report.md\n\n# Access plugin resources\n@${CLAUDE_PLUGIN_ROOT}/docs/reference.md\n```\n\n**Why use it:**\n- Works across all installations\n- Portable between systems\n- No hardcoded paths needed\n- Essential for multi-file plugins\n\n### Plugin Command Organization\n\nPlugin commands discovered automatically from `commands/` directory:\n\n```\nplugin-name/\nâ”œâ”€â”€ commands/\nâ”‚   â”œâ”€â”€ foo.md              # /foo (plugin:plugin-name)\nâ”‚   â”œâ”€â”€ bar.md              # /bar (plugin:plugin-name)\nâ”‚   â””â”€â”€ utils/\nâ”‚       â””â”€â”€ helper.md       # /helper (plugin:plugin-name:utils)\nâ””â”€â”€ plugin.json\n```\n\n**Namespace benefits:**\n- Logical command grouping\n- Shown in `/help` output\n- Avoid name conflicts\n- Organize related commands\n\n**Naming conventions:**\n- Use descriptive action names\n- Avoid generic names (test, run)\n- Consider plugin-specific prefix\n- Use hyphens for multi-word names\n\n### Plugin Command Patterns\n\n**Configuration-based pattern:**\n\n```markdown\n---\ndescription: Deploy using plugin configuration\nargument-hint: [environment]\nallowed-tools: Read, Bash(*)\n---\n\nLoad configuration: @${CLAUDE_PLUGIN_ROOT}/config/$1-deploy.json\n\nDeploy to $1 using configuration settings.\nMonitor deployment and report status.\n```\n\n**Template-based pattern:**\n\n```markdown\n---\ndescription: Generate docs from template\nargument-hint: [component]\n---\n\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/docs.md\n\nGenerate documentation for $1 following template structure.\n```\n\n**Multi-script pattern:**\n\n```markdown\n---\ndescription: Complete build workflow\nallowed-tools: Bash(*)\n---\n\nBuild: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh`\nTest: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/test.sh`\nPackage: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/package.sh`\n\nReview outputs and report workflow status.\n```\n\n**See `references/plugin-features-reference.md` for detailed patterns.**\n\n## Integration with Plugin Components\n\nCommands can integrate with other plugin components for powerful workflows.\n\n### Agent Integration\n\nLaunch plugin agents for complex tasks:\n\n```markdown\n---\ndescription: Deep code review\nargument-hint: [file-path]\n---\n\nInitiate comprehensive review of @$1 using the code-reviewer agent.\n\nThe agent will analyze:\n- Code structure\n- Security issues\n- Performance\n- Best practices\n\nAgent uses plugin resources:\n- ${CLAUDE_PLUGIN_ROOT}/config/rules.json\n- ${CLAUDE_PLUGIN_ROOT}/checklists/review.md\n```\n\n**Key points:**\n- Agent must exist in `plugin/agents/` directory\n- Claude uses Task tool to launch agent\n- Document agent capabilities\n- Reference plugin resources agent uses\n\n### Skill Integration\n\nLeverage plugin skills for specialized knowledge:\n\n```markdown\n---\ndescription: Document API with standards\nargument-hint: [api-file]\n---\n\nDocument API in @$1 following plugin standards.\n\nUse the api-docs-standards skill to ensure:\n- Complete endpoint documentation\n- Consistent formatting\n- Example quality\n- Error documentation\n\nGenerate production-ready API docs.\n```\n\n**Key points:**\n- Skill must exist in `plugin/skills/` directory\n- Mention skill name to trigger invocation\n- Document skill purpose\n- Explain what skill provides\n\n### Hook Coordination\n\nDesign commands that work with plugin hooks:\n- Commands can prepare state for hooks to process\n- Hooks execute automatically on tool events\n- Commands should document expected hook behavior\n- Guide Claude on interpreting hook output\n\nSee `references/plugin-features-reference.md` for examples of commands that coordinate with hooks\n\n### Multi-Component Workflows\n\nCombine agents, skills, and scripts:\n\n```markdown\n---\ndescription: Comprehensive review workflow\nargument-hint: [file]\nallowed-tools: Bash(node:*), Read\n---\n\nTarget: @$1\n\nPhase 1 - Static Analysis:\n!`node ${CLAUDE_PLUGIN_ROOT}/scripts/lint.js $1`\n\nPhase 2 - Deep Review:\nLaunch code-reviewer agent for detailed analysis.\n\nPhase 3 - Standards Check:\nUse coding-standards skill for validation.\n\nPhase 4 - Report:\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/review.md\n\nCompile findings into report following template.\n```\n\n**When to use:**\n- Complex multi-step workflows\n- Leverage multiple plugin capabilities\n- Require specialized analysis\n- Need structured outputs\n\n## Validation Patterns\n\nCommands should validate inputs and resources before processing.\n\n### Argument Validation\n\n```markdown\n---\ndescription: Deploy with validation\nargument-hint: [environment]\n---\n\nValidate environment: !`echo \"$1\" | grep -E \"^(dev|staging|prod)$\" || echo \"INVALID\"`\n\nIf $1 is valid environment:\n  Deploy to $1\nOtherwise:\n  Explain valid environments: dev, staging, prod\n  Show usage: /deploy [environment]\n```\n\n### File Existence Checks\n\n```markdown\n---\ndescription: Process configuration\nargument-hint: [config-file]\n---\n\nCheck file exists: !`test -f $1 && echo \"EXISTS\" || echo \"MISSING\"`\n\nIf file exists:\n  Process configuration: @$1\nOtherwise:\n  Explain where to place config file\n  Show expected format\n  Provide example configuration\n```\n\n### Plugin Resource Validation\n\n```markdown\n---\ndescription: Run plugin analyzer\nallowed-tools: Bash(test:*)\n---\n\nValidate plugin setup:\n- Script: !`test -x ${CLAUDE_PLUGIN_ROOT}/bin/analyze && echo \"âœ“\" || echo \"âœ—\"`\n- Config: !`test -f ${CLAUDE_PLUGIN_ROOT}/config.json && echo \"âœ“\" || echo \"âœ—\"`\n\nIf all checks pass, run analysis.\nOtherwise, report missing components.\n```\n\n### Error Handling\n\n```markdown\n---\ndescription: Build with error handling\nallowed-tools: Bash(*)\n---\n\nExecute build: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh 2>&1 || echo \"BUILD_FAILED\"`\n\nIf build succeeded:\n  Report success and output location\nIf build failed:\n  Analyze error output\n  Suggest likely causes\n  Provide troubleshooting steps\n```\n\n**Best practices:**\n- Validate early in command\n- Provide helpful error messages\n- Suggest corrective actions\n- Handle edge cases gracefully\n\n---\n\nFor detailed frontmatter field specifications, see `references/frontmatter-reference.md`.\nFor plugin-specific features and patterns, see `references/plugin-features-reference.md`.\nFor command pattern examples, see `examples/` directory."
              },
              {
                "name": "Hook Development",
                "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
                "path": "plugins/plugin-dev/skills/hook-development/SKILL.md",
                "frontmatter": {
                  "name": "Hook Development",
                  "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
                  "version": "0.1.0"
                },
                "content": "# Hook Development for Claude Code Plugins\n\n## Overview\n\nHooks are event-driven automation scripts that execute in response to Claude Code events. Use hooks to validate operations, enforce policies, add context, and integrate external tools into workflows.\n\n**Key capabilities:**\n- Validate tool calls before execution (PreToolUse)\n- React to tool results (PostToolUse)\n- Enforce completion standards (Stop, SubagentStop)\n- Load project context (SessionStart)\n- Automate workflows across the development lifecycle\n\n## Hook Types\n\n### Prompt-Based Hooks (Recommended)\n\nUse LLM-driven decision making for context-aware validation:\n\n```json\n{\n  \"type\": \"prompt\",\n  \"prompt\": \"Evaluate if this tool use is appropriate: $TOOL_INPUT\",\n  \"timeout\": 30\n}\n```\n\n**Supported events:** Stop, SubagentStop, UserPromptSubmit, PreToolUse\n\n**Benefits:**\n- Context-aware decisions based on natural language reasoning\n- Flexible evaluation logic without bash scripting\n- Better edge case handling\n- Easier to maintain and extend\n\n### Command Hooks\n\nExecute bash commands for deterministic checks:\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\",\n  \"timeout\": 60\n}\n```\n\n**Use for:**\n- Fast deterministic validations\n- File system operations\n- External tool integrations\n- Performance-critical checks\n\n## Hook Configuration Formats\n\n### Plugin hooks.json Format\n\n**For plugin hooks** in `hooks/hooks.json`, use wrapper format:\n\n```json\n{\n  \"description\": \"Brief explanation of hooks (optional)\",\n  \"hooks\": {\n    \"PreToolUse\": [...],\n    \"Stop\": [...],\n    \"SessionStart\": [...]\n  }\n}\n```\n\n**Key points:**\n- `description` field is optional\n- `hooks` field is required wrapper containing actual hook events\n- This is the **plugin-specific format**\n\n**Example:**\n```json\n{\n  \"description\": \"Validation hooks for code quality\",\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Write\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/validate.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n### Settings Format (Direct)\n\n**For user settings** in `.claude/settings.json`, use direct format:\n\n```json\n{\n  \"PreToolUse\": [...],\n  \"Stop\": [...],\n  \"SessionStart\": [...]\n}\n```\n\n**Key points:**\n- No wrapper - events directly at top level\n- No description field\n- This is the **settings format**\n\n**Important:** The examples below show the hook event structure that goes inside either format. For plugin hooks.json, wrap these in `{\"hooks\": {...}}`.\n\n## Hook Events\n\n### PreToolUse\n\nExecute before any tool runs. Use to approve, deny, or modify tool calls.\n\n**Example (prompt-based):**\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety. Check: system paths, credentials, path traversal, sensitive content. Return 'approve' or 'deny'.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output for PreToolUse:**\n```json\n{\n  \"hookSpecificOutput\": {\n    \"permissionDecision\": \"allow|deny|ask\",\n    \"updatedInput\": {\"field\": \"modified_value\"}\n  },\n  \"systemMessage\": \"Explanation for Claude\"\n}\n```\n\n### PostToolUse\n\nExecute after tool completes. Use to react to results, provide feedback, or log.\n\n**Example:**\n```json\n{\n  \"PostToolUse\": [\n    {\n      \"matcher\": \"Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Analyze edit result for potential issues: syntax errors, security vulnerabilities, breaking changes. Provide feedback.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output behavior:**\n- Exit 0: stdout shown in transcript\n- Exit 2: stderr fed back to Claude\n- systemMessage included in context\n\n### Stop\n\nExecute when main agent considers stopping. Use to validate completeness.\n\n**Example:**\n```json\n{\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion: tests run, build succeeded, questions answered. Return 'approve' to stop or 'block' with reason to continue.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Decision output:**\n```json\n{\n  \"decision\": \"approve|block\",\n  \"reason\": \"Explanation\",\n  \"systemMessage\": \"Additional context\"\n}\n```\n\n### SubagentStop\n\nExecute when subagent considers stopping. Use to ensure subagent completed its task.\n\nSimilar to Stop hook, but for subagents.\n\n### UserPromptSubmit\n\nExecute when user submits a prompt. Use to add context, validate, or block prompts.\n\n**Example:**\n```json\n{\n  \"UserPromptSubmit\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Check if prompt requires security guidance. If discussing auth, permissions, or API security, return relevant warnings.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### SessionStart\n\nExecute when Claude Code session begins. Use to load context and set environment.\n\n**Example:**\n```json\n{\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Special capability:** Persist environment variables using `$CLAUDE_ENV_FILE`:\n```bash\necho \"export PROJECT_TYPE=nodejs\" >> \"$CLAUDE_ENV_FILE\"\n```\n\nSee `examples/load-context.sh` for complete example.\n\n### SessionEnd\n\nExecute when session ends. Use for cleanup, logging, and state preservation.\n\n### PreCompact\n\nExecute before context compaction. Use to add critical information to preserve.\n\n### Notification\n\nExecute when Claude sends notifications. Use to react to user notifications.\n\n## Hook Output Format\n\n### Standard Output (All Hooks)\n\n```json\n{\n  \"continue\": true,\n  \"suppressOutput\": false,\n  \"systemMessage\": \"Message for Claude\"\n}\n```\n\n- `continue`: If false, halt processing (default true)\n- `suppressOutput`: Hide output from transcript (default false)\n- `systemMessage`: Message shown to Claude\n\n### Exit Codes\n\n- `0` - Success (stdout shown in transcript)\n- `2` - Blocking error (stderr fed back to Claude)\n- Other - Non-blocking error\n\n## Hook Input Format\n\nAll hooks receive JSON via stdin with common fields:\n\n```json\n{\n  \"session_id\": \"abc123\",\n  \"transcript_path\": \"/path/to/transcript.txt\",\n  \"cwd\": \"/current/working/dir\",\n  \"permission_mode\": \"ask|allow\",\n  \"hook_event_name\": \"PreToolUse\"\n}\n```\n\n**Event-specific fields:**\n\n- **PreToolUse/PostToolUse:** `tool_name`, `tool_input`, `tool_result`\n- **UserPromptSubmit:** `user_prompt`\n- **Stop/SubagentStop:** `reason`\n\nAccess fields in prompts using `$TOOL_INPUT`, `$TOOL_RESULT`, `$USER_PROMPT`, etc.\n\n## Environment Variables\n\nAvailable in all command hooks:\n\n- `$CLAUDE_PROJECT_DIR` - Project root path\n- `$CLAUDE_PLUGIN_ROOT` - Plugin directory (use for portable paths)\n- `$CLAUDE_ENV_FILE` - SessionStart only: persist env vars here\n- `$CLAUDE_CODE_REMOTE` - Set if running in remote context\n\n**Always use ${CLAUDE_PLUGIN_ROOT} in hook commands for portability:**\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\"\n}\n```\n\n## Plugin Hook Configuration\n\nIn plugins, define hooks in `hooks/hooks.json`:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety\"\n        }\n      ]\n    }\n  ],\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion\"\n        }\n      ]\n    }\n  ],\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\",\n          \"timeout\": 10\n        }\n      ]\n    }\n  ]\n}\n```\n\nPlugin hooks merge with user's hooks and run in parallel.\n\n## Matchers\n\n### Tool Name Matching\n\n**Exact match:**\n```json\n\"matcher\": \"Write\"\n```\n\n**Multiple tools:**\n```json\n\"matcher\": \"Read|Write|Edit\"\n```\n\n**Wildcard (all tools):**\n```json\n\"matcher\": \"*\"\n```\n\n**Regex patterns:**\n```json\n\"matcher\": \"mcp__.*__delete.*\"  // All MCP delete tools\n```\n\n**Note:** Matchers are case-sensitive.\n\n### Common Patterns\n\n```json\n// All MCP tools\n\"matcher\": \"mcp__.*\"\n\n// Specific plugin's MCP tools\n\"matcher\": \"mcp__plugin_asana_.*\"\n\n// All file operations\n\"matcher\": \"Read|Write|Edit\"\n\n// Bash commands only\n\"matcher\": \"Bash\"\n```\n\n## Security Best Practices\n\n### Input Validation\n\nAlways validate inputs in command hooks:\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\ninput=$(cat)\ntool_name=$(echo \"$input\" | jq -r '.tool_name')\n\n# Validate tool name format\nif [[ ! \"$tool_name\" =~ ^[a-zA-Z0-9_]+$ ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Invalid tool name\"}' >&2\n  exit 2\nfi\n```\n\n### Path Safety\n\nCheck for path traversal and sensitive files:\n\n```bash\nfile_path=$(echo \"$input\" | jq -r '.tool_input.file_path')\n\n# Deny path traversal\nif [[ \"$file_path\" == *\"..\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Path traversal detected\"}' >&2\n  exit 2\nfi\n\n# Deny sensitive files\nif [[ \"$file_path\" == *\".env\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Sensitive file\"}' >&2\n  exit 2\nfi\n```\n\nSee `examples/validate-write.sh` and `examples/validate-bash.sh` for complete examples.\n\n### Quote All Variables\n\n```bash\n# GOOD: Quoted\necho \"$file_path\"\ncd \"$CLAUDE_PROJECT_DIR\"\n\n# BAD: Unquoted (injection risk)\necho $file_path\ncd $CLAUDE_PROJECT_DIR\n```\n\n### Set Appropriate Timeouts\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash script.sh\",\n  \"timeout\": 10\n}\n```\n\n**Defaults:** Command hooks (60s), Prompt hooks (30s)\n\n## Performance Considerations\n\n### Parallel Execution\n\nAll matching hooks run **in parallel**:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write\",\n      \"hooks\": [\n        {\"type\": \"command\", \"command\": \"check1.sh\"},  // Parallel\n        {\"type\": \"command\", \"command\": \"check2.sh\"},  // Parallel\n        {\"type\": \"prompt\", \"prompt\": \"Validate...\"}   // Parallel\n      ]\n    }\n  ]\n}\n```\n\n**Design implications:**\n- Hooks don't see each other's output\n- Non-deterministic ordering\n- Design for independence\n\n### Optimization\n\n1. Use command hooks for quick deterministic checks\n2. Use prompt hooks for complex reasoning\n3. Cache validation results in temp files\n4. Minimize I/O in hot paths\n\n## Temporarily Active Hooks\n\nCreate hooks that activate conditionally by checking for a flag file or configuration:\n\n**Pattern: Flag file activation**\n```bash\n#!/bin/bash\n# Only active when flag file exists\nFLAG_FILE=\"$CLAUDE_PROJECT_DIR/.enable-strict-validation\"\n\nif [ ! -f \"$FLAG_FILE\" ]; then\n  # Flag not present, skip validation\n  exit 0\nfi\n\n# Flag present, run validation\ninput=$(cat)\n# ... validation logic ...\n```\n\n**Pattern: Configuration-based activation**\n```bash\n#!/bin/bash\n# Check configuration for activation\nCONFIG_FILE=\"$CLAUDE_PROJECT_DIR/.claude/plugin-config.json\"\n\nif [ -f \"$CONFIG_FILE\" ]; then\n  enabled=$(jq -r '.strictMode // false' \"$CONFIG_FILE\")\n  if [ \"$enabled\" != \"true\" ]; then\n    exit 0  # Not enabled, skip\n  fi\nfi\n\n# Enabled, run hook logic\ninput=$(cat)\n# ... hook logic ...\n```\n\n**Use cases:**\n- Enable strict validation only when needed\n- Temporary debugging hooks\n- Project-specific hook behavior\n- Feature flags for hooks\n\n**Best practice:** Document activation mechanism in plugin README so users know how to enable/disable temporary hooks.\n\n## Hook Lifecycle and Limitations\n\n### Hooks Load at Session Start\n\n**Important:** Hooks are loaded when Claude Code session starts. Changes to hook configuration require restarting Claude Code.\n\n**Cannot hot-swap hooks:**\n- Editing `hooks/hooks.json` won't affect current session\n- Adding new hook scripts won't be recognized\n- Changing hook commands/prompts won't update\n- Must restart Claude Code: exit and run `claude` again\n\n**To test hook changes:**\n1. Edit hook configuration or scripts\n2. Exit Claude Code session\n3. Restart: `claude` or `cc`\n4. New hook configuration loads\n5. Test hooks with `claude --debug`\n\n### Hook Validation at Startup\n\nHooks are validated when Claude Code starts:\n- Invalid JSON in hooks.json causes loading failure\n- Missing scripts cause warnings\n- Syntax errors reported in debug mode\n\nUse `/hooks` command to review loaded hooks in current session.\n\n## Debugging Hooks\n\n### Enable Debug Mode\n\n```bash\nclaude --debug\n```\n\nLook for hook registration, execution logs, input/output JSON, and timing information.\n\n### Test Hook Scripts\n\nTest command hooks directly:\n\n```bash\necho '{\"tool_name\": \"Write\", \"tool_input\": {\"file_path\": \"/test\"}}' | \\\n  bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\n\necho \"Exit code: $?\"\n```\n\n### Validate JSON Output\n\nEnsure hooks output valid JSON:\n\n```bash\noutput=$(./your-hook.sh < test-input.json)\necho \"$output\" | jq .\n```\n\n## Quick Reference\n\n### Hook Events Summary\n\n| Event | When | Use For |\n|-------|------|---------|\n| PreToolUse | Before tool | Validation, modification |\n| PostToolUse | After tool | Feedback, logging |\n| UserPromptSubmit | User input | Context, validation |\n| Stop | Agent stopping | Completeness check |\n| SubagentStop | Subagent done | Task validation |\n| SessionStart | Session begins | Context loading |\n| SessionEnd | Session ends | Cleanup, logging |\n| PreCompact | Before compact | Preserve context |\n| Notification | User notified | Logging, reactions |\n\n### Best Practices\n\n**DO:**\n- âœ… Use prompt-based hooks for complex logic\n- âœ… Use ${CLAUDE_PLUGIN_ROOT} for portability\n- âœ… Validate all inputs in command hooks\n- âœ… Quote all bash variables\n- âœ… Set appropriate timeouts\n- âœ… Return structured JSON output\n- âœ… Test hooks thoroughly\n\n**DON'T:**\n- âŒ Use hardcoded paths\n- âŒ Trust user input without validation\n- âŒ Create long-running hooks\n- âŒ Rely on hook execution order\n- âŒ Modify global state unpredictably\n- âŒ Log sensitive information\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and advanced techniques, consult:\n\n- **`references/patterns.md`** - Common hook patterns (8+ proven patterns)\n- **`references/migration.md`** - Migrating from basic to advanced hooks\n- **`references/advanced.md`** - Advanced use cases and techniques\n\n### Example Hook Scripts\n\nWorking examples in `examples/`:\n\n- **`validate-write.sh`** - File write validation example\n- **`validate-bash.sh`** - Bash command validation example\n- **`load-context.sh`** - SessionStart context loading example\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-hook-schema.sh`** - Validate hooks.json structure and syntax\n- **`test-hook.sh`** - Test hooks with sample input before deployment\n- **`hook-linter.sh`** - Check hook scripts for common issues and best practices\n\n### External Resources\n\n- **Official Docs**: https://docs.claude.com/en/docs/claude-code/hooks\n- **Examples**: See security-guidance plugin in marketplace\n- **Testing**: Use `claude --debug` for detailed logs\n- **Validation**: Use `jq` to validate hook JSON output\n\n## Implementation Workflow\n\nTo implement hooks in a plugin:\n\n1. Identify events to hook into (PreToolUse, Stop, SessionStart, etc.)\n2. Decide between prompt-based (flexible) or command (deterministic) hooks\n3. Write hook configuration in `hooks/hooks.json`\n4. For command hooks, create hook scripts\n5. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n6. Validate configuration with `scripts/validate-hook-schema.sh hooks/hooks.json`\n7. Test hooks with `scripts/test-hook.sh` before deployment\n8. Test in Claude Code with `claude --debug`\n9. Document hooks in plugin README\n\nFocus on prompt-based hooks for most use cases. Reserve command hooks for performance-critical or deterministic checks."
              },
              {
                "name": "MCP Integration",
                "description": "This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration.",
                "path": "plugins/plugin-dev/skills/mcp-integration/SKILL.md",
                "frontmatter": {
                  "name": "MCP Integration",
                  "description": "This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration.",
                  "version": "0.1.0"
                },
                "content": "# MCP Integration for Claude Code Plugins\n\n## Overview\n\nModel Context Protocol (MCP) enables Claude Code plugins to integrate with external services and APIs by providing structured tool access. Use MCP integration to expose external service capabilities as tools within Claude Code.\n\n**Key capabilities:**\n- Connect to external services (databases, APIs, file systems)\n- Provide 10+ related tools from a single service\n- Handle OAuth and complex authentication flows\n- Bundle MCP servers with plugins for automatic setup\n\n## MCP Server Configuration Methods\n\nPlugins can bundle MCP servers in two ways:\n\n### Method 1: Dedicated .mcp.json (Recommended)\n\nCreate `.mcp.json` at plugin root:\n\n```json\n{\n  \"database-tools\": {\n    \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/db-server\",\n    \"args\": [\"--config\", \"${CLAUDE_PLUGIN_ROOT}/config.json\"],\n    \"env\": {\n      \"DB_URL\": \"${DB_URL}\"\n    }\n  }\n}\n```\n\n**Benefits:**\n- Clear separation of concerns\n- Easier to maintain\n- Better for multiple servers\n\n### Method 2: Inline in plugin.json\n\nAdd `mcpServers` field to plugin.json:\n\n```json\n{\n  \"name\": \"my-plugin\",\n  \"version\": \"1.0.0\",\n  \"mcpServers\": {\n    \"plugin-api\": {\n      \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/api-server\",\n      \"args\": [\"--port\", \"8080\"]\n    }\n  }\n}\n```\n\n**Benefits:**\n- Single configuration file\n- Good for simple single-server plugins\n\n## MCP Server Types\n\n### stdio (Local Process)\n\nExecute local MCP servers as child processes. Best for local tools and custom servers.\n\n**Configuration:**\n```json\n{\n  \"filesystem\": {\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/allowed/path\"],\n    \"env\": {\n      \"LOG_LEVEL\": \"debug\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- File system access\n- Local database connections\n- Custom MCP servers\n- NPM-packaged MCP servers\n\n**Process management:**\n- Claude Code spawns and manages the process\n- Communicates via stdin/stdout\n- Terminates when Claude Code exits\n\n### SSE (Server-Sent Events)\n\nConnect to hosted MCP servers with OAuth support. Best for cloud services.\n\n**Configuration:**\n```json\n{\n  \"asana\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.asana.com/sse\"\n  }\n}\n```\n\n**Use cases:**\n- Official hosted MCP servers (Asana, GitHub, etc.)\n- Cloud services with MCP endpoints\n- OAuth-based authentication\n- No local installation needed\n\n**Authentication:**\n- OAuth flows handled automatically\n- User prompted on first use\n- Tokens managed by Claude Code\n\n### HTTP (REST API)\n\nConnect to RESTful MCP servers with token authentication.\n\n**Configuration:**\n```json\n{\n  \"api-service\": {\n    \"type\": \"http\",\n    \"url\": \"https://api.example.com/mcp\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${API_TOKEN}\",\n      \"X-Custom-Header\": \"value\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- REST API-based MCP servers\n- Token-based authentication\n- Custom API backends\n- Stateless interactions\n\n### WebSocket (Real-time)\n\nConnect to WebSocket MCP servers for real-time bidirectional communication.\n\n**Configuration:**\n```json\n{\n  \"realtime-service\": {\n    \"type\": \"ws\",\n    \"url\": \"wss://mcp.example.com/ws\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${TOKEN}\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- Real-time data streaming\n- Persistent connections\n- Push notifications from server\n- Low-latency requirements\n\n## Environment Variable Expansion\n\nAll MCP configurations support environment variable substitution:\n\n**${CLAUDE_PLUGIN_ROOT}** - Plugin directory (always use for portability):\n```json\n{\n  \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/my-server\"\n}\n```\n\n**User environment variables** - From user's shell:\n```json\n{\n  \"env\": {\n    \"API_KEY\": \"${MY_API_KEY}\",\n    \"DATABASE_URL\": \"${DB_URL}\"\n  }\n}\n```\n\n**Best practice:** Document all required environment variables in plugin README.\n\n## MCP Tool Naming\n\nWhen MCP servers provide tools, they're automatically prefixed:\n\n**Format:** `mcp__plugin_<plugin-name>_<server-name>__<tool-name>`\n\n**Example:**\n- Plugin: `asana`\n- Server: `asana`\n- Tool: `create_task`\n- **Full name:** `mcp__plugin_asana_asana__asana_create_task`\n\n### Using MCP Tools in Commands\n\nPre-allow specific MCP tools in command frontmatter:\n\n```markdown\n---\nallowed-tools: [\n  \"mcp__plugin_asana_asana__asana_create_task\",\n  \"mcp__plugin_asana_asana__asana_search_tasks\"\n]\n---\n```\n\n**Wildcard (use sparingly):**\n```markdown\n---\nallowed-tools: [\"mcp__plugin_asana_asana__*\"]\n---\n```\n\n**Best practice:** Pre-allow specific tools, not wildcards, for security.\n\n## Lifecycle Management\n\n**Automatic startup:**\n- MCP servers start when plugin enables\n- Connection established before first tool use\n- Restart required for configuration changes\n\n**Lifecycle:**\n1. Plugin loads\n2. MCP configuration parsed\n3. Server process started (stdio) or connection established (SSE/HTTP/WS)\n4. Tools discovered and registered\n5. Tools available as `mcp__plugin_...__...`\n\n**Viewing servers:**\nUse `/mcp` command to see all servers including plugin-provided ones.\n\n## Authentication Patterns\n\n### OAuth (SSE/HTTP)\n\nOAuth handled automatically by Claude Code:\n\n```json\n{\n  \"type\": \"sse\",\n  \"url\": \"https://mcp.example.com/sse\"\n}\n```\n\nUser authenticates in browser on first use. No additional configuration needed.\n\n### Token-Based (Headers)\n\nStatic or environment variable tokens:\n\n```json\n{\n  \"type\": \"http\",\n  \"url\": \"https://api.example.com\",\n  \"headers\": {\n    \"Authorization\": \"Bearer ${API_TOKEN}\"\n  }\n}\n```\n\nDocument required environment variables in README.\n\n### Environment Variables (stdio)\n\nPass configuration to MCP server:\n\n```json\n{\n  \"command\": \"python\",\n  \"args\": [\"-m\", \"my_mcp_server\"],\n  \"env\": {\n    \"DATABASE_URL\": \"${DB_URL}\",\n    \"API_KEY\": \"${API_KEY}\",\n    \"LOG_LEVEL\": \"info\"\n  }\n}\n```\n\n## Integration Patterns\n\n### Pattern 1: Simple Tool Wrapper\n\nCommands use MCP tools with user interaction:\n\n```markdown\n# Command: create-item.md\n---\nallowed-tools: [\"mcp__plugin_name_server__create_item\"]\n---\n\nSteps:\n1. Gather item details from user\n2. Use mcp__plugin_name_server__create_item\n3. Confirm creation\n```\n\n**Use for:** Adding validation or preprocessing before MCP calls.\n\n### Pattern 2: Autonomous Agent\n\nAgents use MCP tools autonomously:\n\n```markdown\n# Agent: data-analyzer.md\n\nAnalysis Process:\n1. Query data via mcp__plugin_db_server__query\n2. Process and analyze results\n3. Generate insights report\n```\n\n**Use for:** Multi-step MCP workflows without user interaction.\n\n### Pattern 3: Multi-Server Plugin\n\nIntegrate multiple MCP servers:\n\n```json\n{\n  \"github\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.github.com/sse\"\n  },\n  \"jira\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.jira.com/sse\"\n  }\n}\n```\n\n**Use for:** Workflows spanning multiple services.\n\n## Security Best Practices\n\n### Use HTTPS/WSS\n\nAlways use secure connections:\n\n```json\nâœ… \"url\": \"https://mcp.example.com/sse\"\nâŒ \"url\": \"http://mcp.example.com/sse\"\n```\n\n### Token Management\n\n**DO:**\n- âœ… Use environment variables for tokens\n- âœ… Document required env vars in README\n- âœ… Let OAuth flow handle authentication\n\n**DON'T:**\n- âŒ Hardcode tokens in configuration\n- âŒ Commit tokens to git\n- âŒ Share tokens in documentation\n\n### Permission Scoping\n\nPre-allow only necessary MCP tools:\n\n```markdown\nâœ… allowed-tools: [\n  \"mcp__plugin_api_server__read_data\",\n  \"mcp__plugin_api_server__create_item\"\n]\n\nâŒ allowed-tools: [\"mcp__plugin_api_server__*\"]\n```\n\n## Error Handling\n\n### Connection Failures\n\nHandle MCP server unavailability:\n- Provide fallback behavior in commands\n- Inform user of connection issues\n- Check server URL and configuration\n\n### Tool Call Errors\n\nHandle failed MCP operations:\n- Validate inputs before calling MCP tools\n- Provide clear error messages\n- Check rate limiting and quotas\n\n### Configuration Errors\n\nValidate MCP configuration:\n- Test server connectivity during development\n- Validate JSON syntax\n- Check required environment variables\n\n## Performance Considerations\n\n### Lazy Loading\n\nMCP servers connect on-demand:\n- Not all servers connect at startup\n- First tool use triggers connection\n- Connection pooling managed automatically\n\n### Batching\n\nBatch similar requests when possible:\n\n```\n# Good: Single query with filters\ntasks = search_tasks(project=\"X\", assignee=\"me\", limit=50)\n\n# Avoid: Many individual queries\nfor id in task_ids:\n    task = get_task(id)\n```\n\n## Testing MCP Integration\n\n### Local Testing\n\n1. Configure MCP server in `.mcp.json`\n2. Install plugin locally (`.claude-plugin/`)\n3. Run `/mcp` to verify server appears\n4. Test tool calls in commands\n5. Check `claude --debug` logs for connection issues\n\n### Validation Checklist\n\n- [ ] MCP configuration is valid JSON\n- [ ] Server URL is correct and accessible\n- [ ] Required environment variables documented\n- [ ] Tools appear in `/mcp` output\n- [ ] Authentication works (OAuth or tokens)\n- [ ] Tool calls succeed from commands\n- [ ] Error cases handled gracefully\n\n## Debugging\n\n### Enable Debug Logging\n\n```bash\nclaude --debug\n```\n\nLook for:\n- MCP server connection attempts\n- Tool discovery logs\n- Authentication flows\n- Tool call errors\n\n### Common Issues\n\n**Server not connecting:**\n- Check URL is correct\n- Verify server is running (stdio)\n- Check network connectivity\n- Review authentication configuration\n\n**Tools not available:**\n- Verify server connected successfully\n- Check tool names match exactly\n- Run `/mcp` to see available tools\n- Restart Claude Code after config changes\n\n**Authentication failing:**\n- Clear cached auth tokens\n- Re-authenticate\n- Check token scopes and permissions\n- Verify environment variables set\n\n## Quick Reference\n\n### MCP Server Types\n\n| Type | Transport | Best For | Auth |\n|------|-----------|----------|------|\n| stdio | Process | Local tools, custom servers | Env vars |\n| SSE | HTTP | Hosted services, cloud APIs | OAuth |\n| HTTP | REST | API backends, token auth | Tokens |\n| ws | WebSocket | Real-time, streaming | Tokens |\n\n### Configuration Checklist\n\n- [ ] Server type specified (stdio/SSE/HTTP/ws)\n- [ ] Type-specific fields complete (command or url)\n- [ ] Authentication configured\n- [ ] Environment variables documented\n- [ ] HTTPS/WSS used (not HTTP/WS)\n- [ ] ${CLAUDE_PLUGIN_ROOT} used for paths\n\n### Best Practices\n\n**DO:**\n- âœ… Use ${CLAUDE_PLUGIN_ROOT} for portable paths\n- âœ… Document required environment variables\n- âœ… Use secure connections (HTTPS/WSS)\n- âœ… Pre-allow specific MCP tools in commands\n- âœ… Test MCP integration before publishing\n- âœ… Handle connection and tool errors gracefully\n\n**DON'T:**\n- âŒ Hardcode absolute paths\n- âŒ Commit credentials to git\n- âŒ Use HTTP instead of HTTPS\n- âŒ Pre-allow all tools with wildcards\n- âŒ Skip error handling\n- âŒ Forget to document setup\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed information, consult:\n\n- **`references/server-types.md`** - Deep dive on each server type\n- **`references/authentication.md`** - Authentication patterns and OAuth\n- **`references/tool-usage.md`** - Using MCP tools in commands and agents\n\n### Example Configurations\n\nWorking examples in `examples/`:\n\n- **`stdio-server.json`** - Local stdio MCP server\n- **`sse-server.json`** - Hosted SSE server with OAuth\n- **`http-server.json`** - REST API with token auth\n\n### External Resources\n\n- **Official MCP Docs**: https://modelcontextprotocol.io/\n- **Claude Code MCP Docs**: https://docs.claude.com/en/docs/claude-code/mcp\n- **MCP SDK**: @modelcontextprotocol/sdk\n- **Testing**: Use `claude --debug` and `/mcp` command\n\n## Implementation Workflow\n\nTo add MCP integration to a plugin:\n\n1. Choose MCP server type (stdio, SSE, HTTP, ws)\n2. Create `.mcp.json` at plugin root with configuration\n3. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n4. Document required environment variables in README\n5. Test locally with `/mcp` command\n6. Pre-allow MCP tools in relevant commands\n7. Handle authentication (OAuth or tokens)\n8. Test error cases (connection failures, auth errors)\n9. Document MCP integration in plugin README\n\nFocus on stdio for custom/local servers, SSE for hosted services with OAuth."
              },
              {
                "name": "Plugin Settings",
                "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.",
                "path": "plugins/plugin-dev/skills/plugin-settings/SKILL.md",
                "frontmatter": {
                  "name": "Plugin Settings",
                  "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.",
                  "version": "0.1.0"
                },
                "content": "# Plugin Settings Pattern for Claude Code Plugins\n\n## Overview\n\nPlugins can store user-configurable settings and state in `.claude/plugin-name.local.md` files within the project directory. This pattern uses YAML frontmatter for structured configuration and markdown content for prompts or additional context.\n\n**Key characteristics:**\n- File location: `.claude/plugin-name.local.md` in project root\n- Structure: YAML frontmatter + markdown body\n- Purpose: Per-project plugin configuration and state\n- Usage: Read from hooks, commands, and agents\n- Lifecycle: User-managed (not in git, should be in `.gitignore`)\n\n## File Structure\n\n### Basic Template\n\n```markdown\n---\nenabled: true\nsetting1: value1\nsetting2: value2\nnumeric_setting: 42\nlist_setting: [\"item1\", \"item2\"]\n---\n\n# Additional Context\n\nThis markdown body can contain:\n- Task descriptions\n- Additional instructions\n- Prompts to feed back to Claude\n- Documentation or notes\n```\n\n### Example: Plugin State File\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nenabled: true\nstrict_mode: false\nmax_retries: 3\nnotification_level: info\ncoordinator_session: team-leader\n---\n\n# Plugin Configuration\n\nThis plugin is configured for standard validation mode.\nContact @team-lead with questions.\n```\n\n## Reading Settings Files\n\n### From Hooks (Bash Scripts)\n\n**Pattern: Check existence and parse frontmatter**\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\n# Define state file path\nSTATE_FILE=\".claude/my-plugin.local.md\"\n\n# Quick exit if file doesn't exist\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0  # Plugin not configured, skip\nfi\n\n# Parse YAML frontmatter (between --- markers)\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\n\n# Extract individual fields\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\nSTRICT_MODE=$(echo \"$FRONTMATTER\" | grep '^strict_mode:' | sed 's/strict_mode: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n\n# Check if enabled\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Use configuration in hook logic\nif [[ \"$STRICT_MODE\" == \"true\" ]]; then\n  # Apply strict validation\n  # ...\nfi\n```\n\nSee `examples/read-settings-hook.sh` for complete working example.\n\n### From Commands\n\nCommands can read settings files to customize behavior:\n\n```markdown\n---\ndescription: Process data with plugin\nallowed-tools: [\"Read\", \"Bash\"]\n---\n\n# Process Command\n\nSteps:\n1. Check if settings exist at `.claude/my-plugin.local.md`\n2. Read configuration using Read tool\n3. Parse YAML frontmatter to extract settings\n4. Apply settings to processing logic\n5. Execute with configured behavior\n```\n\n### From Agents\n\nAgents can reference settings in their instructions:\n\n```markdown\n---\nname: configured-agent\ndescription: Agent that adapts to project settings\n---\n\nCheck for plugin settings at `.claude/my-plugin.local.md`.\nIf present, parse YAML frontmatter and adapt behavior according to:\n- enabled: Whether plugin is active\n- mode: Processing mode (strict, standard, lenient)\n- Additional configuration fields\n```\n\n## Parsing Techniques\n\n### Extract Frontmatter\n\n```bash\n# Extract everything between --- markers\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n```\n\n### Read Individual Fields\n\n**String fields:**\n```bash\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field_name:' | sed 's/field_name: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n**Boolean fields:**\n```bash\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n# Compare: if [[ \"$ENABLED\" == \"true\" ]]; then\n```\n\n**Numeric fields:**\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n# Use: if [[ $MAX -gt 100 ]]; then\n```\n\n### Read Markdown Body\n\nExtract content after second `---`:\n\n```bash\n# Get everything after closing ---\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n## Common Patterns\n\n### Pattern 1: Temporarily Active Hooks\n\nUse settings file to control hook activation:\n\n```bash\n#!/bin/bash\nSTATE_FILE=\".claude/security-scan.local.md\"\n\n# Quick exit if not configured\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0\nfi\n\n# Read enabled flag\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Run hook logic\n# ...\n```\n\n**Use case:** Enable/disable hooks without editing hooks.json (requires restart).\n\n### Pattern 2: Agent State Management\n\nStore agent-specific state and configuration:\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-agent\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\n---\n\n# Task Assignment\n\nImplement JWT authentication for the API.\n\n**Success Criteria:**\n- Authentication endpoints created\n- Tests passing\n- PR created and CI green\n```\n\nRead from hooks to coordinate agents:\n\n```bash\nAGENT_NAME=$(echo \"$FRONTMATTER\" | grep '^agent_name:' | sed 's/agent_name: *//')\nCOORDINATOR=$(echo \"$FRONTMATTER\" | grep '^coordinator_session:' | sed 's/coordinator_session: *//')\n\n# Send notification to coordinator\ntmux send-keys -t \"$COORDINATOR\" \"Agent $AGENT_NAME completed task\" Enter\n```\n\n### Pattern 3: Configuration-Driven Behavior\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nvalidation_level: strict\nmax_file_size: 1000000\nallowed_extensions: [\".js\", \".ts\", \".tsx\"]\nenable_logging: true\n---\n\n# Validation Configuration\n\nStrict mode enabled for this project.\nAll writes validated against security policies.\n```\n\nUse in hooks or commands:\n\n```bash\nLEVEL=$(echo \"$FRONTMATTER\" | grep '^validation_level:' | sed 's/validation_level: *//')\n\ncase \"$LEVEL\" in\n  strict)\n    # Apply strict validation\n    ;;\n  standard)\n    # Apply standard validation\n    ;;\n  lenient)\n    # Apply lenient validation\n    ;;\nesac\n```\n\n## Creating Settings Files\n\n### From Commands\n\nCommands can create settings files:\n\n```markdown\n# Setup Command\n\nSteps:\n1. Ask user for configuration preferences\n2. Create `.claude/my-plugin.local.md` with YAML frontmatter\n3. Set appropriate values based on user input\n4. Inform user that settings are saved\n5. Remind user to restart Claude Code for hooks to recognize changes\n```\n\n### Template Generation\n\nProvide template in plugin README:\n\n```markdown\n## Configuration\n\nCreate `.claude/my-plugin.local.md` in your project:\n\n\\`\\`\\`markdown\n---\nenabled: true\nmode: standard\nmax_retries: 3\n---\n\n# Plugin Configuration\n\nYour settings are active.\n\\`\\`\\`\n\nAfter creating or editing, restart Claude Code for changes to take effect.\n```\n\n## Best Practices\n\n### File Naming\n\nâœ… **DO:**\n- Use `.claude/plugin-name.local.md` format\n- Match plugin name exactly\n- Use `.local.md` suffix for user-local files\n\nâŒ **DON'T:**\n- Use different directory (not `.claude/`)\n- Use inconsistent naming\n- Use `.md` without `.local` (might be committed)\n\n### Gitignore\n\nAlways add to `.gitignore`:\n\n```gitignore\n.claude/*.local.md\n.claude/*.local.json\n```\n\nDocument this in plugin README.\n\n### Defaults\n\nProvide sensible defaults when settings file doesn't exist:\n\n```bash\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  # Use defaults\n  ENABLED=true\n  MODE=standard\nelse\n  # Read from file\n  # ...\nfi\n```\n\n### Validation\n\nValidate settings values:\n\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n\n# Validate numeric range\nif ! [[ \"$MAX\" =~ ^[0-9]+$ ]] || [[ $MAX -lt 1 ]] || [[ $MAX -gt 100 ]]; then\n  echo \"âš ï¸  Invalid max_value in settings (must be 1-100)\" >&2\n  MAX=10  # Use default\nfi\n```\n\n### Restart Requirement\n\n**Important:** Settings changes require Claude Code restart.\n\nDocument in your README:\n\n```markdown\n## Changing Settings\n\nAfter editing `.claude/my-plugin.local.md`:\n1. Save the file\n2. Exit Claude Code\n3. Restart: `claude` or `cc`\n4. New settings will be loaded\n```\n\nHooks cannot be hot-swapped within a session.\n\n## Security Considerations\n\n### Sanitize User Input\n\nWhen writing settings files from user input:\n\n```bash\n# Escape quotes in user input\nSAFE_VALUE=$(echo \"$USER_INPUT\" | sed 's/\"/\\\\\"/g')\n\n# Write to file\ncat > \"$STATE_FILE\" <<EOF\n---\nuser_setting: \"$SAFE_VALUE\"\n---\nEOF\n```\n\n### Validate File Paths\n\nIf settings contain file paths:\n\n```bash\nFILE_PATH=$(echo \"$FRONTMATTER\" | grep '^data_file:' | sed 's/data_file: *//')\n\n# Check for path traversal\nif [[ \"$FILE_PATH\" == *\"..\"* ]]; then\n  echo \"âš ï¸  Invalid path in settings (path traversal)\" >&2\n  exit 2\nfi\n```\n\n### Permissions\n\nSettings files should be:\n- Readable by user only (`chmod 600`)\n- Not committed to git\n- Not shared between users\n\n## Real-World Examples\n\n### multi-agent-swarm Plugin\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-implementation\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\nadditional_instructions: Use JWT tokens, not sessions\n---\n\n# Task: Implement Authentication\n\nBuild JWT-based authentication for the REST API.\nCoordinate with auth-agent on shared types.\n```\n\n**Hook usage (agent-stop-notification.sh):**\n- Checks if file exists (line 15-18: quick exit if not)\n- Parses frontmatter to get coordinator_session, agent_name, enabled\n- Sends notifications to coordinator if enabled\n- Allows quick activation/deactivation via `enabled: true/false`\n\n### ralph-loop Plugin\n\n**.claude/ralph-loop.local.md:**\n```markdown\n---\niteration: 1\nmax_iterations: 10\ncompletion_promise: \"All tests passing and build successful\"\n---\n\nFix all the linting errors in the project.\nMake sure tests pass after each fix.\n```\n\n**Hook usage (stop-hook.sh):**\n- Checks if file exists (line 15-18: quick exit if not active)\n- Reads iteration count and max_iterations\n- Extracts completion_promise for loop termination\n- Reads body as the prompt to feed back\n- Updates iteration count on each loop\n\n## Quick Reference\n\n### File Location\n\n```\nproject-root/\nâ””â”€â”€ .claude/\n    â””â”€â”€ plugin-name.local.md\n```\n\n### Frontmatter Parsing\n\n```bash\n# Extract frontmatter\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n\n# Read field\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field:' | sed 's/field: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n### Body Parsing\n\n```bash\n# Extract body (after second ---)\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n### Quick Exit Pattern\n\n```bash\nif [[ ! -f \".claude/my-plugin.local.md\" ]]; then\n  exit 0  # Not configured\nfi\n```\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed implementation patterns:\n\n- **`references/parsing-techniques.md`** - Complete guide to parsing YAML frontmatter and markdown bodies\n- **`references/real-world-examples.md`** - Deep dive into multi-agent-swarm and ralph-loop implementations\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`read-settings-hook.sh`** - Hook that reads and uses settings\n- **`create-settings-command.md`** - Command that creates settings file\n- **`example-settings.md`** - Template settings file\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-settings.sh`** - Validate settings file structure\n- **`parse-frontmatter.sh`** - Extract frontmatter fields\n\n## Implementation Workflow\n\nTo add settings to a plugin:\n\n1. Design settings schema (which fields, types, defaults)\n2. Create template file in plugin documentation\n3. Add gitignore entry for `.claude/*.local.md`\n4. Implement settings parsing in hooks/commands\n5. Use quick-exit pattern (check file exists, check enabled field)\n6. Document settings in plugin README with template\n7. Remind users that changes require Claude Code restart\n\nFocus on keeping settings simple and providing good defaults when settings file doesn't exist."
              },
              {
                "name": "Plugin Structure",
                "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.",
                "path": "plugins/plugin-dev/skills/plugin-structure/SKILL.md",
                "frontmatter": {
                  "name": "Plugin Structure",
                  "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.",
                  "version": "0.1.0"
                },
                "content": "# Plugin Structure for Claude Code\n\n## Overview\n\nClaude Code plugins follow a standardized directory structure with automatic component discovery. Understanding this structure enables creating well-organized, maintainable plugins that integrate seamlessly with Claude Code.\n\n**Key concepts:**\n- Conventional directory layout for automatic discovery\n- Manifest-driven configuration in `.claude-plugin/plugin.json`\n- Component-based organization (commands, agents, skills, hooks)\n- Portable path references using `${CLAUDE_PLUGIN_ROOT}`\n- Explicit vs. auto-discovered component loading\n\n## Directory Structure\n\nEvery Claude Code plugin follows this organizational pattern:\n\n```\nplugin-name/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json          # Required: Plugin manifest\nâ”œâ”€â”€ commands/                 # Slash commands (.md files)\nâ”œâ”€â”€ agents/                   # Subagent definitions (.md files)\nâ”œâ”€â”€ skills/                   # Agent skills (subdirectories)\nâ”‚   â””â”€â”€ skill-name/\nâ”‚       â””â”€â”€ SKILL.md         # Required for each skill\nâ”œâ”€â”€ hooks/\nâ”‚   â””â”€â”€ hooks.json           # Event handler configuration\nâ”œâ”€â”€ .mcp.json                # MCP server definitions\nâ””â”€â”€ scripts/                 # Helper scripts and utilities\n```\n\n**Critical rules:**\n\n1. **Manifest location**: The `plugin.json` manifest MUST be in `.claude-plugin/` directory\n2. **Component locations**: All component directories (commands, agents, skills, hooks) MUST be at plugin root level, NOT nested inside `.claude-plugin/`\n3. **Optional components**: Only create directories for components the plugin actually uses\n4. **Naming convention**: Use kebab-case for all directory and file names\n\n## Plugin Manifest (plugin.json)\n\nThe manifest defines plugin metadata and configuration. Located at `.claude-plugin/plugin.json`:\n\n### Required Fields\n\n```json\n{\n  \"name\": \"plugin-name\"\n}\n```\n\n**Name requirements:**\n- Use kebab-case format (lowercase with hyphens)\n- Must be unique across installed plugins\n- No spaces or special characters\n- Example: `code-review-assistant`, `test-runner`, `api-docs`\n\n### Recommended Metadata\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Brief explanation of plugin purpose\",\n  \"author\": {\n    \"name\": \"Author Name\",\n    \"email\": \"author@example.com\",\n    \"url\": \"https://example.com\"\n  },\n  \"homepage\": \"https://docs.example.com\",\n  \"repository\": \"https://github.com/user/plugin-name\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"testing\", \"automation\", \"ci-cd\"]\n}\n```\n\n**Version format**: Follow semantic versioning (MAJOR.MINOR.PATCH)\n**Keywords**: Use for plugin discovery and categorization\n\n### Component Path Configuration\n\nSpecify custom paths for components (supplements default directories):\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"commands\": \"./custom-commands\",\n  \"agents\": [\"./agents\", \"./specialized-agents\"],\n  \"hooks\": \"./config/hooks.json\",\n  \"mcpServers\": \"./.mcp.json\"\n}\n```\n\n**Important**: Custom paths supplement defaultsâ€”they don't replace them. Components in both default directories and custom paths will load.\n\n**Path rules:**\n- Must be relative to plugin root\n- Must start with `./`\n- Cannot use absolute paths\n- Support arrays for multiple locations\n\n## Component Organization\n\n### Commands\n\n**Location**: `commands/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `commands/` load automatically\n\n**Example structure**:\n```\ncommands/\nâ”œâ”€â”€ review.md        # /review command\nâ”œâ”€â”€ test.md          # /test command\nâ””â”€â”€ deploy.md        # /deploy command\n```\n\n**File format**:\n```markdown\n---\nname: command-name\ndescription: Command description\n---\n\nCommand implementation instructions...\n```\n\n**Usage**: Commands integrate as native slash commands in Claude Code\n\n### Agents\n\n**Location**: `agents/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `agents/` load automatically\n\n**Example structure**:\n```\nagents/\nâ”œâ”€â”€ code-reviewer.md\nâ”œâ”€â”€ test-generator.md\nâ””â”€â”€ refactorer.md\n```\n\n**File format**:\n```markdown\n---\ndescription: Agent role and expertise\ncapabilities:\n  - Specific task 1\n  - Specific task 2\n---\n\nDetailed agent instructions and knowledge...\n```\n\n**Usage**: Users can invoke agents manually, or Claude Code selects them automatically based on task context\n\n### Skills\n\n**Location**: `skills/` directory with subdirectories per skill\n**Format**: Each skill in its own directory with `SKILL.md` file\n**Auto-discovery**: All `SKILL.md` files in skill subdirectories load automatically\n\n**Example structure**:\n```\nskills/\nâ”œâ”€â”€ api-testing/\nâ”‚   â”œâ”€â”€ SKILL.md\nâ”‚   â”œâ”€â”€ scripts/\nâ”‚   â”‚   â””â”€â”€ test-runner.py\nâ”‚   â””â”€â”€ references/\nâ”‚       â””â”€â”€ api-spec.md\nâ””â”€â”€ database-migrations/\n    â”œâ”€â”€ SKILL.md\n    â””â”€â”€ examples/\n        â””â”€â”€ migration-template.sql\n```\n\n**SKILL.md format**:\n```markdown\n---\nname: Skill Name\ndescription: When to use this skill\nversion: 1.0.0\n---\n\nSkill instructions and guidance...\n```\n\n**Supporting files**: Skills can include scripts, references, examples, or assets in subdirectories\n\n**Usage**: Claude Code autonomously activates skills based on task context matching the description\n\n### Hooks\n\n**Location**: `hooks/hooks.json` or inline in `plugin.json`\n**Format**: JSON configuration defining event handlers\n**Registration**: Hooks register automatically when plugin enables\n\n**Example structure**:\n```\nhooks/\nâ”œâ”€â”€ hooks.json           # Hook configuration\nâ””â”€â”€ scripts/\n    â”œâ”€â”€ validate.sh      # Hook script\n    â””â”€â”€ check-style.sh   # Hook script\n```\n\n**Configuration format**:\n```json\n{\n  \"PreToolUse\": [{\n    \"matcher\": \"Write|Edit\",\n    \"hooks\": [{\n      \"type\": \"command\",\n      \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/validate.sh\",\n      \"timeout\": 30\n    }]\n  }]\n}\n```\n\n**Available events**: PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification\n\n**Usage**: Hooks execute automatically in response to Claude Code events\n\n### MCP Servers\n\n**Location**: `.mcp.json` at plugin root or inline in `plugin.json`\n**Format**: JSON configuration for MCP server definitions\n**Auto-start**: Servers start automatically when plugin enables\n\n**Example format**:\n```json\n{\n  \"mcpServers\": {\n    \"server-name\": {\n      \"command\": \"node\",\n      \"args\": [\"${CLAUDE_PLUGIN_ROOT}/servers/server.js\"],\n      \"env\": {\n        \"API_KEY\": \"${API_KEY}\"\n      }\n    }\n  }\n}\n```\n\n**Usage**: MCP servers integrate seamlessly with Claude Code's tool system\n\n## Portable Path References\n\n### ${CLAUDE_PLUGIN_ROOT}\n\nUse `${CLAUDE_PLUGIN_ROOT}` environment variable for all intra-plugin path references:\n\n```json\n{\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/run.sh\"\n}\n```\n\n**Why it matters**: Plugins install in different locations depending on:\n- User installation method (marketplace, local, npm)\n- Operating system conventions\n- User preferences\n\n**Where to use it**:\n- Hook command paths\n- MCP server command arguments\n- Script execution references\n- Resource file paths\n\n**Never use**:\n- Hardcoded absolute paths (`/Users/name/plugins/...`)\n- Relative paths from working directory (`./scripts/...` in commands)\n- Home directory shortcuts (`~/plugins/...`)\n\n### Path Resolution Rules\n\n**In manifest JSON fields** (hooks, MCP servers):\n```json\n\"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/tool.sh\"\n```\n\n**In component files** (commands, agents, skills):\n```markdown\nReference scripts at: ${CLAUDE_PLUGIN_ROOT}/scripts/helper.py\n```\n\n**In executed scripts**:\n```bash\n#!/bin/bash\n# ${CLAUDE_PLUGIN_ROOT} available as environment variable\nsource \"${CLAUDE_PLUGIN_ROOT}/lib/common.sh\"\n```\n\n## File Naming Conventions\n\n### Component Files\n\n**Commands**: Use kebab-case `.md` files\n- `code-review.md` â†’ `/code-review`\n- `run-tests.md` â†’ `/run-tests`\n- `api-docs.md` â†’ `/api-docs`\n\n**Agents**: Use kebab-case `.md` files describing role\n- `test-generator.md`\n- `code-reviewer.md`\n- `performance-analyzer.md`\n\n**Skills**: Use kebab-case directory names\n- `api-testing/`\n- `database-migrations/`\n- `error-handling/`\n\n### Supporting Files\n\n**Scripts**: Use descriptive kebab-case names with appropriate extensions\n- `validate-input.sh`\n- `generate-report.py`\n- `process-data.js`\n\n**Documentation**: Use kebab-case markdown files\n- `api-reference.md`\n- `migration-guide.md`\n- `best-practices.md`\n\n**Configuration**: Use standard names\n- `hooks.json`\n- `.mcp.json`\n- `plugin.json`\n\n## Auto-Discovery Mechanism\n\nClaude Code automatically discovers and loads components:\n\n1. **Plugin manifest**: Reads `.claude-plugin/plugin.json` when plugin enables\n2. **Commands**: Scans `commands/` directory for `.md` files\n3. **Agents**: Scans `agents/` directory for `.md` files\n4. **Skills**: Scans `skills/` for subdirectories containing `SKILL.md`\n5. **Hooks**: Loads configuration from `hooks/hooks.json` or manifest\n6. **MCP servers**: Loads configuration from `.mcp.json` or manifest\n\n**Discovery timing**:\n- Plugin installation: Components register with Claude Code\n- Plugin enable: Components become available for use\n- No restart required: Changes take effect on next Claude Code session\n\n**Override behavior**: Custom paths in `plugin.json` supplement (not replace) default directories\n\n## Best Practices\n\n### Organization\n\n1. **Logical grouping**: Group related components together\n   - Put test-related commands, agents, and skills together\n   - Create subdirectories in `scripts/` for different purposes\n\n2. **Minimal manifest**: Keep `plugin.json` lean\n   - Only specify custom paths when necessary\n   - Rely on auto-discovery for standard layouts\n   - Use inline configuration only for simple cases\n\n3. **Documentation**: Include README files\n   - Plugin root: Overall purpose and usage\n   - Component directories: Specific guidance\n   - Script directories: Usage and requirements\n\n### Naming\n\n1. **Consistency**: Use consistent naming across components\n   - If command is `test-runner`, name related agent `test-runner-agent`\n   - Match skill directory names to their purpose\n\n2. **Clarity**: Use descriptive names that indicate purpose\n   - Good: `api-integration-testing/`, `code-quality-checker.md`\n   - Avoid: `utils/`, `misc.md`, `temp.sh`\n\n3. **Length**: Balance brevity with clarity\n   - Commands: 2-3 words (`review-pr`, `run-ci`)\n   - Agents: Describe role clearly (`code-reviewer`, `test-generator`)\n   - Skills: Topic-focused (`error-handling`, `api-design`)\n\n### Portability\n\n1. **Always use ${CLAUDE_PLUGIN_ROOT}**: Never hardcode paths\n2. **Test on multiple systems**: Verify on macOS, Linux, Windows\n3. **Document dependencies**: List required tools and versions\n4. **Avoid system-specific features**: Use portable bash/Python constructs\n\n### Maintenance\n\n1. **Version consistently**: Update version in plugin.json for releases\n2. **Deprecate gracefully**: Mark old components clearly before removal\n3. **Document breaking changes**: Note changes affecting existing users\n4. **Test thoroughly**: Verify all components work after changes\n\n## Common Patterns\n\n### Minimal Plugin\n\nSingle command with no dependencies:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json    # Just name field\nâ””â”€â”€ commands/\n    â””â”€â”€ hello.md       # Single command\n```\n\n### Full-Featured Plugin\n\nComplete plugin with all component types:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/          # User-facing commands\nâ”œâ”€â”€ agents/            # Specialized subagents\nâ”œâ”€â”€ skills/            # Auto-activating skills\nâ”œâ”€â”€ hooks/             # Event handlers\nâ”‚   â”œâ”€â”€ hooks.json\nâ”‚   â””â”€â”€ scripts/\nâ”œâ”€â”€ .mcp.json          # External integrations\nâ””â”€â”€ scripts/           # Shared utilities\n```\n\n### Skill-Focused Plugin\n\nPlugin providing only skills:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ””â”€â”€ skills/\n    â”œâ”€â”€ skill-one/\n    â”‚   â””â”€â”€ SKILL.md\n    â””â”€â”€ skill-two/\n        â””â”€â”€ SKILL.md\n```\n\n## Troubleshooting\n\n**Component not loading**:\n- Verify file is in correct directory with correct extension\n- Check YAML frontmatter syntax (commands, agents, skills)\n- Ensure skill has `SKILL.md` (not `README.md` or other name)\n- Confirm plugin is enabled in Claude Code settings\n\n**Path resolution errors**:\n- Replace all hardcoded paths with `${CLAUDE_PLUGIN_ROOT}`\n- Verify paths are relative and start with `./` in manifest\n- Check that referenced files exist at specified paths\n- Test with `echo $CLAUDE_PLUGIN_ROOT` in hook scripts\n\n**Auto-discovery not working**:\n- Confirm directories are at plugin root (not in `.claude-plugin/`)\n- Check file naming follows conventions (kebab-case, correct extensions)\n- Verify custom paths in manifest are correct\n- Restart Claude Code to reload plugin configuration\n\n**Conflicts between plugins**:\n- Use unique, descriptive component names\n- Namespace commands with plugin name if needed\n- Document potential conflicts in plugin README\n- Consider command prefixes for related functionality\n\n---\n\nFor detailed examples and advanced patterns, see files in `references/` and `examples/` directories."
              },
              {
                "name": "Skill Development",
                "description": "This skill should be used when the user wants to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins.",
                "path": "plugins/plugin-dev/skills/skill-development/SKILL.md",
                "frontmatter": {
                  "name": "Skill Development",
                  "description": "This skill should be used when the user wants to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins.",
                  "version": "0.1.0"
                },
                "content": "# Skill Development for Claude Code Plugins\n\nThis skill provides guidance for creating effective skills for Claude Code plugins.\n\n## About Skills\n\nSkills are modular, self-contained packages that extend Claude's capabilities by providing\nspecialized knowledge, workflows, and tools. Think of them as \"onboarding guides\" for specific\ndomains or tasksâ€”they transform Claude from a general-purpose agent into a specialized agent\nequipped with procedural knowledge that no model can fully possess.\n\n### What Skills Provide\n\n1. Specialized workflows - Multi-step procedures for specific domains\n2. Tool integrations - Instructions for working with specific file formats or APIs\n3. Domain expertise - Company-specific knowledge, schemas, business logic\n4. Bundled resources - Scripts, references, and assets for complex and repetitive tasks\n\n### Anatomy of a Skill\n\nEvery skill consists of a required SKILL.md file and optional bundled resources:\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md (required)\nâ”‚   â”œâ”€â”€ YAML frontmatter metadata (required)\nâ”‚   â”‚   â”œâ”€â”€ name: (required)\nâ”‚   â”‚   â””â”€â”€ description: (required)\nâ”‚   â””â”€â”€ Markdown instructions (required)\nâ””â”€â”€ Bundled Resources (optional)\n    â”œâ”€â”€ scripts/          - Executable code (Python/Bash/etc.)\n    â”œâ”€â”€ references/       - Documentation intended to be loaded into context as needed\n    â””â”€â”€ assets/           - Files used in output (templates, icons, fonts, etc.)\n```\n\n#### SKILL.md (required)\n\n**Metadata Quality:** The `name` and `description` in YAML frontmatter determine when Claude will use the skill. Be specific about what the skill does and when to use it. Use the third-person (e.g. \"This skill should be used when...\" instead of \"Use this skill when...\").\n\n#### Bundled Resources (optional)\n\n##### Scripts (`scripts/`)\n\nExecutable code (Python/Bash/etc.) for tasks that require deterministic reliability or are repeatedly rewritten.\n\n- **When to include**: When the same code is being rewritten repeatedly or deterministic reliability is needed\n- **Example**: `scripts/rotate_pdf.py` for PDF rotation tasks\n- **Benefits**: Token efficient, deterministic, may be executed without loading into context\n- **Note**: Scripts may still need to be read by Claude for patching or environment-specific adjustments\n\n##### References (`references/`)\n\nDocumentation and reference material intended to be loaded as needed into context to inform Claude's process and thinking.\n\n- **When to include**: For documentation that Claude should reference while working\n- **Examples**: `references/finance.md` for financial schemas, `references/mnda.md` for company NDA template, `references/policies.md` for company policies, `references/api_docs.md` for API specifications\n- **Use cases**: Database schemas, API documentation, domain knowledge, company policies, detailed workflow guides\n- **Benefits**: Keeps SKILL.md lean, loaded only when Claude determines it's needed\n- **Best practice**: If files are large (>10k words), include grep search patterns in SKILL.md\n- **Avoid duplication**: Information should live in either SKILL.md or references files, not both. Prefer references files for detailed information unless it's truly core to the skillâ€”this keeps SKILL.md lean while making information discoverable without hogging the context window. Keep only essential procedural instructions and workflow guidance in SKILL.md; move detailed reference material, schemas, and examples to references files.\n\n##### Assets (`assets/`)\n\nFiles not intended to be loaded into context, but rather used within the output Claude produces.\n\n- **When to include**: When the skill needs files that will be used in the final output\n- **Examples**: `assets/logo.png` for brand assets, `assets/slides.pptx` for PowerPoint templates, `assets/frontend-template/` for HTML/React boilerplate, `assets/font.ttf` for typography\n- **Use cases**: Templates, images, icons, boilerplate code, fonts, sample documents that get copied or modified\n- **Benefits**: Separates output resources from documentation, enables Claude to use files without loading them into context\n\n### Progressive Disclosure Design Principle\n\nSkills use a three-level loading system to manage context efficiently:\n\n1. **Metadata (name + description)** - Always in context (~100 words)\n2. **SKILL.md body** - When skill triggers (<5k words)\n3. **Bundled resources** - As needed by Claude (Unlimited*)\n\n*Unlimited because scripts can be executed without reading into context window.\n\n## Skill Creation Process\n\nTo create a skill, follow the \"Skill Creation Process\" in order, skipping steps only if there is a clear reason why they are not applicable.\n\n### Step 1: Understanding the Skill with Concrete Examples\n\nSkip this step only when the skill's usage patterns are already clearly understood. It remains valuable even when working with an existing skill.\n\nTo create an effective skill, clearly understand concrete examples of how the skill will be used. This understanding can come from either direct user examples or generated examples that are validated with user feedback.\n\nFor example, when building an image-editor skill, relevant questions include:\n\n- \"What functionality should the image-editor skill support? Editing, rotating, anything else?\"\n- \"Can you give some examples of how this skill would be used?\"\n- \"I can imagine users asking for things like 'Remove the red-eye from this image' or 'Rotate this image'. Are there other ways you imagine this skill being used?\"\n- \"What would a user say that should trigger this skill?\"\n\nTo avoid overwhelming users, avoid asking too many questions in a single message. Start with the most important questions and follow up as needed for better effectiveness.\n\nConclude this step when there is a clear sense of the functionality the skill should support.\n\n### Step 2: Planning the Reusable Skill Contents\n\nTo turn concrete examples into an effective skill, analyze each example by:\n\n1. Considering how to execute on the example from scratch\n2. Identifying what scripts, references, and assets would be helpful when executing these workflows repeatedly\n\nExample: When building a `pdf-editor` skill to handle queries like \"Help me rotate this PDF,\" the analysis shows:\n\n1. Rotating a PDF requires re-writing the same code each time\n2. A `scripts/rotate_pdf.py` script would be helpful to store in the skill\n\nExample: When designing a `frontend-webapp-builder` skill for queries like \"Build me a todo app\" or \"Build me a dashboard to track my steps,\" the analysis shows:\n\n1. Writing a frontend webapp requires the same boilerplate HTML/React each time\n2. An `assets/hello-world/` template containing the boilerplate HTML/React project files would be helpful to store in the skill\n\nExample: When building a `big-query` skill to handle queries like \"How many users have logged in today?\" the analysis shows:\n\n1. Querying BigQuery requires re-discovering the table schemas and relationships each time\n2. A `references/schema.md` file documenting the table schemas would be helpful to store in the skill\n\n**For Claude Code plugins:** When building a hooks skill, the analysis shows:\n1. Developers repeatedly need to validate hooks.json and test hook scripts\n2. `scripts/validate-hook-schema.sh` and `scripts/test-hook.sh` utilities would be helpful\n3. `references/patterns.md` for detailed hook patterns to avoid bloating SKILL.md\n\nTo establish the skill's contents, analyze each concrete example to create a list of the reusable resources to include: scripts, references, and assets.\n\n### Step 3: Create Skill Structure\n\nFor Claude Code plugins, create the skill directory structure:\n\n```bash\nmkdir -p plugin-name/skills/skill-name/{references,examples,scripts}\ntouch plugin-name/skills/skill-name/SKILL.md\n```\n\n**Note:** Unlike the generic skill-creator which uses `init_skill.py`, plugin skills are created directly in the plugin's `skills/` directory with a simpler manual structure.\n\n### Step 4: Edit the Skill\n\nWhen editing the (newly-created or existing) skill, remember that the skill is being created for another instance of Claude to use. Focus on including information that would be beneficial and non-obvious to Claude. Consider what procedural knowledge, domain-specific details, or reusable assets would help another Claude instance execute these tasks more effectively.\n\n#### Start with Reusable Skill Contents\n\nTo begin implementation, start with the reusable resources identified above: `scripts/`, `references/`, and `assets/` files. Note that this step may require user input. For example, when implementing a `brand-guidelines` skill, the user may need to provide brand assets or templates to store in `assets/`, or documentation to store in `references/`.\n\nAlso, delete any example files and directories not needed for the skill. Create only the directories you actually need (references/, examples/, scripts/).\n\n#### Update SKILL.md\n\n**Writing Style:** Write the entire skill using **imperative/infinitive form** (verb-first instructions), not second person. Use objective, instructional language (e.g., \"To accomplish X, do Y\" rather than \"You should do X\" or \"If you need to do X\"). This maintains consistency and clarity for AI consumption.\n\n**Description (Frontmatter):** Use third-person format with specific trigger phrases:\n\n```yaml\n---\nname: Skill Name\ndescription: This skill should be used when the user asks to \"specific phrase 1\", \"specific phrase 2\", \"specific phrase 3\". Include exact phrases users would say that should trigger this skill. Be concrete and specific.\nversion: 0.1.0\n---\n```\n\n**Good description examples:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", \"implement prompt-based hooks\", or mentions hook events (PreToolUse, PostToolUse, Stop).\n```\n\n**Bad description examples:**\n```yaml\ndescription: Use this skill when working with hooks.  # Wrong person, vague\ndescription: Load when user needs hook help.  # Not third person\ndescription: Provides hook guidance.  # No trigger phrases\n```\n\nTo complete SKILL.md body, answer the following questions:\n\n1. What is the purpose of the skill, in a few sentences?\n2. When should the skill be used? (Include this in frontmatter description with specific triggers)\n3. In practice, how should Claude use the skill? All reusable skill contents developed above should be referenced so that Claude knows how to use them.\n\n**Keep SKILL.md lean:** Target 1,500-2,000 words for the body. Move detailed content to references/:\n- Detailed patterns â†’ `references/patterns.md`\n- Advanced techniques â†’ `references/advanced.md`\n- Migration guides â†’ `references/migration.md`\n- API references â†’ `references/api-reference.md`\n\n**Reference resources in SKILL.md:**\n```markdown\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and techniques, consult:\n- **`references/patterns.md`** - Common patterns\n- **`references/advanced.md`** - Advanced use cases\n\n### Example Files\n\nWorking examples in `examples/`:\n- **`example-script.sh`** - Working example\n```\n\n### Step 5: Validate and Test\n\n**For plugin skills, validation is different from generic skills:**\n\n1. **Check structure**: Skill directory in `plugin-name/skills/skill-name/`\n2. **Validate SKILL.md**: Has frontmatter with name and description\n3. **Check trigger phrases**: Description includes specific user queries\n4. **Verify writing style**: Body uses imperative/infinitive form, not second person\n5. **Test progressive disclosure**: SKILL.md is lean (~1,500-2,000 words), detailed content in references/\n6. **Check references**: All referenced files exist\n7. **Validate examples**: Examples are complete and correct\n8. **Test scripts**: Scripts are executable and work correctly\n\n**Use the skill-reviewer agent:**\n```\nAsk: \"Review my skill and check if it follows best practices\"\n```\n\nThe skill-reviewer agent will check description quality, content organization, and progressive disclosure.\n\n### Step 6: Iterate\n\nAfter testing the skill, users may request improvements. Often this happens right after using the skill, with fresh context of how the skill performed.\n\n**Iteration workflow:**\n1. Use the skill on real tasks\n2. Notice struggles or inefficiencies\n3. Identify how SKILL.md or bundled resources should be updated\n4. Implement changes and test again\n\n**Common improvements:**\n- Strengthen trigger phrases in description\n- Move long sections from SKILL.md to references/\n- Add missing examples or scripts\n- Clarify ambiguous instructions\n- Add edge case handling\n\n## Plugin-Specific Considerations\n\n### Skill Location in Plugins\n\nPlugin skills live in the plugin's `skills/` directory:\n\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/\nâ”œâ”€â”€ agents/\nâ””â”€â”€ skills/\n    â””â”€â”€ my-skill/\n        â”œâ”€â”€ SKILL.md\n        â”œâ”€â”€ references/\n        â”œâ”€â”€ examples/\n        â””â”€â”€ scripts/\n```\n\n### Auto-Discovery\n\nClaude Code automatically discovers skills:\n- Scans `skills/` directory\n- Finds subdirectories containing `SKILL.md`\n- Loads skill metadata (name + description) always\n- Loads SKILL.md body when skill triggers\n- Loads references/examples when needed\n\n### No Packaging Needed\n\nPlugin skills are distributed as part of the plugin, not as separate ZIP files. Users get skills when they install the plugin.\n\n### Testing in Plugins\n\nTest skills by installing plugin locally:\n\n```bash\n# Test with --plugin-dir\ncc --plugin-dir /path/to/plugin\n\n# Ask questions that should trigger the skill\n# Verify skill loads correctly\n```\n\n## Examples from Plugin-Dev\n\nStudy the skills in this plugin as examples of best practices:\n\n**hook-development skill:**\n- Excellent trigger phrases: \"create a hook\", \"add a PreToolUse hook\", etc.\n- Lean SKILL.md (1,651 words)\n- 3 references/ files for detailed content\n- 3 examples/ of working hooks\n- 3 scripts/ utilities\n\n**agent-development skill:**\n- Strong triggers: \"create an agent\", \"agent frontmatter\", etc.\n- Focused SKILL.md (1,438 words)\n- References include the AI generation prompt from Claude Code\n- Complete agent examples\n\n**plugin-settings skill:**\n- Specific triggers: \"plugin settings\", \".local.md files\", \"YAML frontmatter\"\n- References show real implementations (multi-agent-swarm, ralph-loop)\n- Working parsing scripts\n\nEach demonstrates progressive disclosure and strong triggering.\n\n## Progressive Disclosure in Practice\n\n### What Goes in SKILL.md\n\n**Include (always loaded when skill triggers):**\n- Core concepts and overview\n- Essential procedures and workflows\n- Quick reference tables\n- Pointers to references/examples/scripts\n- Most common use cases\n\n**Keep under 3,000 words, ideally 1,500-2,000 words**\n\n### What Goes in references/\n\n**Move to references/ (loaded as needed):**\n- Detailed patterns and advanced techniques\n- Comprehensive API documentation\n- Migration guides\n- Edge cases and troubleshooting\n- Extensive examples and walkthroughs\n\n**Each reference file can be large (2,000-5,000+ words)**\n\n### What Goes in examples/\n\n**Working code examples:**\n- Complete, runnable scripts\n- Configuration files\n- Template files\n- Real-world usage examples\n\n**Users can copy and adapt these directly**\n\n### What Goes in scripts/\n\n**Utility scripts:**\n- Validation tools\n- Testing helpers\n- Parsing utilities\n- Automation scripts\n\n**Should be executable and documented**\n\n## Writing Style Requirements\n\n### Imperative/Infinitive Form\n\nWrite using verb-first instructions, not second person:\n\n**Correct (imperative):**\n```\nTo create a hook, define the event type.\nConfigure the MCP server with authentication.\nValidate settings before use.\n```\n\n**Incorrect (second person):**\n```\nYou should create a hook by defining the event type.\nYou need to configure the MCP server.\nYou must validate settings before use.\n```\n\n### Third-Person in Description\n\nThe frontmatter description must use third person:\n\n**Correct:**\n```yaml\ndescription: This skill should be used when the user asks to \"create X\", \"configure Y\"...\n```\n\n**Incorrect:**\n```yaml\ndescription: Use this skill when you want to create X...\ndescription: Load this skill when user asks...\n```\n\n### Objective, Instructional Language\n\nFocus on what to do, not who should do it:\n\n**Correct:**\n```\nParse the frontmatter using sed.\nExtract fields with grep.\nValidate values before use.\n```\n\n**Incorrect:**\n```\nYou can parse the frontmatter...\nClaude should extract fields...\nThe user might validate values...\n```\n\n## Validation Checklist\n\nBefore finalizing a skill:\n\n**Structure:**\n- [ ] SKILL.md file exists with valid YAML frontmatter\n- [ ] Frontmatter has `name` and `description` fields\n- [ ] Markdown body is present and substantial\n- [ ] Referenced files actually exist\n\n**Description Quality:**\n- [ ] Uses third person (\"This skill should be used when...\")\n- [ ] Includes specific trigger phrases users would say\n- [ ] Lists concrete scenarios (\"create X\", \"configure Y\")\n- [ ] Not vague or generic\n\n**Content Quality:**\n- [ ] SKILL.md body uses imperative/infinitive form\n- [ ] Body is focused and lean (1,500-2,000 words ideal, <5k max)\n- [ ] Detailed content moved to references/\n- [ ] Examples are complete and working\n- [ ] Scripts are executable and documented\n\n**Progressive Disclosure:**\n- [ ] Core concepts in SKILL.md\n- [ ] Detailed docs in references/\n- [ ] Working code in examples/\n- [ ] Utilities in scripts/\n- [ ] SKILL.md references these resources\n\n**Testing:**\n- [ ] Skill triggers on expected user queries\n- [ ] Content is helpful for intended tasks\n- [ ] No duplicated information across files\n- [ ] References load when needed\n\n## Common Mistakes to Avoid\n\n### Mistake 1: Weak Trigger Description\n\nâŒ **Bad:**\n```yaml\ndescription: Provides guidance for working with hooks.\n```\n\n**Why bad:** Vague, no specific trigger phrases, not third person\n\nâœ… **Good:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", or mentions hook events. Provides comprehensive hooks API guidance.\n```\n\n**Why good:** Third person, specific phrases, concrete scenarios\n\n### Mistake 2: Too Much in SKILL.md\n\nâŒ **Bad:**\n```\nskill-name/\nâ””â”€â”€ SKILL.md  (8,000 words - everything in one file)\n```\n\n**Why bad:** Bloats context when skill loads, detailed content always loaded\n\nâœ… **Good:**\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md  (1,800 words - core essentials)\nâ””â”€â”€ references/\n    â”œâ”€â”€ patterns.md (2,500 words)\n    â””â”€â”€ advanced.md (3,700 words)\n```\n\n**Why good:** Progressive disclosure, detailed content loaded only when needed\n\n### Mistake 3: Second Person Writing\n\nâŒ **Bad:**\n```markdown\nYou should start by reading the configuration file.\nYou need to validate the input.\nYou can use the grep tool to search.\n```\n\n**Why bad:** Second person, not imperative form\n\nâœ… **Good:**\n```markdown\nStart by reading the configuration file.\nValidate the input before processing.\nUse the grep tool to search for patterns.\n```\n\n**Why good:** Imperative form, direct instructions\n\n### Mistake 4: Missing Resource References\n\nâŒ **Bad:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n[No mention of references/ or examples/]\n```\n\n**Why bad:** Claude doesn't know references exist\n\nâœ… **Good:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n## Additional Resources\n\n### Reference Files\n- **`references/patterns.md`** - Detailed patterns\n- **`references/advanced.md`** - Advanced techniques\n\n### Examples\n- **`examples/script.sh`** - Working example\n```\n\n**Why good:** Claude knows where to find additional information\n\n## Quick Reference\n\n### Minimal Skill\n\n```\nskill-name/\nâ””â”€â”€ SKILL.md\n```\n\nGood for: Simple knowledge, no complex resources needed\n\n### Standard Skill (Recommended)\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md\nâ”œâ”€â”€ references/\nâ”‚   â””â”€â”€ detailed-guide.md\nâ””â”€â”€ examples/\n    â””â”€â”€ working-example.sh\n```\n\nGood for: Most plugin skills with detailed documentation\n\n### Complete Skill\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md\nâ”œâ”€â”€ references/\nâ”‚   â”œâ”€â”€ patterns.md\nâ”‚   â””â”€â”€ advanced.md\nâ”œâ”€â”€ examples/\nâ”‚   â”œâ”€â”€ example1.sh\nâ”‚   â””â”€â”€ example2.json\nâ””â”€â”€ scripts/\n    â””â”€â”€ validate.sh\n```\n\nGood for: Complex domains with validation utilities\n\n## Best Practices Summary\n\nâœ… **DO:**\n- Use third-person in description (\"This skill should be used when...\")\n- Include specific trigger phrases (\"create X\", \"configure Y\")\n- Keep SKILL.md lean (1,500-2,000 words)\n- Use progressive disclosure (move details to references/)\n- Write in imperative/infinitive form\n- Reference supporting files clearly\n- Provide working examples\n- Create utility scripts for common operations\n- Study plugin-dev's skills as templates\n\nâŒ **DON'T:**\n- Use second person anywhere\n- Have vague trigger conditions\n- Put everything in SKILL.md (>3,000 words without references/)\n- Write in second person (\"You should...\")\n- Leave resources unreferenced\n- Include broken or incomplete examples\n- Skip validation\n\n## Additional Resources\n\n### Study These Skills\n\nPlugin-dev's skills demonstrate best practices:\n- `../hook-development/` - Progressive disclosure, utilities\n- `../agent-development/` - AI-assisted creation, references\n- `../mcp-integration/` - Comprehensive references\n- `../plugin-settings/` - Real-world examples\n- `../command-development/` - Clear critical concepts\n- `../plugin-structure/` - Good organization\n\n### Reference Files\n\nFor complete skill-creator methodology:\n- **`references/skill-creator-original.md`** - Full original skill-creator content\n\n## Implementation Workflow\n\nTo create a skill for your plugin:\n\n1. **Understand use cases**: Identify concrete examples of skill usage\n2. **Plan resources**: Determine what scripts/references/examples needed\n3. **Create structure**: `mkdir -p skills/skill-name/{references,examples,scripts}`\n4. **Write SKILL.md**:\n   - Frontmatter with third-person description and trigger phrases\n   - Lean body (1,500-2,000 words) in imperative form\n   - Reference supporting files\n5. **Add resources**: Create references/, examples/, scripts/ as needed\n6. **Validate**: Check description, writing style, organization\n7. **Test**: Verify skill loads on expected triggers\n8. **Iterate**: Improve based on usage\n\nFocus on strong trigger descriptions, progressive disclosure, and imperative writing style for effective skills that load when needed and provide targeted guidance."
              }
            ]
          },
          {
            "name": "laravel-boost",
            "description": "Laravel development toolkit MCP server. Provides intelligent assistance for Laravel applications including Artisan commands, Eloquent queries, routing, migrations, and framework-specific code generation.",
            "source": "./external_plugins/laravel-boost",
            "category": "development",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install laravel-boost@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "figma",
            "description": "Figma design platform integration. Access design files, extract component information, read design tokens, and translate designs into code. Bridge the gap between design and development workflows.",
            "source": {
              "source": "url",
              "url": "https://github.com/figma/mcp-server-guide.git"
            },
            "category": "design",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install figma@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [
              {
                "name": "/explain-error",
                "description": "Explain Stripe error codes and provide solutions with code examples",
                "path": "external_plugins/stripe/commands/explain-error.md",
                "frontmatter": {
                  "description": "Explain Stripe error codes and provide solutions with code examples",
                  "argument-hint": [
                    "error_code or error_message"
                  ]
                },
                "content": "# Explain Stripe Error\n\nProvide a comprehensive explanation of the given Stripe error code or error message:\n\n1. Accept the error code or full error message from the arguments\n2. Explain in plain English what the error means\n3. List common causes of this error\n4. Provide specific solutions and handling recommendations\n5. Generate error handling code in the project's language showing:\n   - How to catch this specific error\n   - User-friendly error messages\n   - Whether retry is appropriate\n6. Mention related error codes the developer should be aware of\n7. Include a link to the relevant Stripe documentation\n\nFocus on actionable solutions and production-ready error handling patterns."
              },
              {
                "name": "/test-cards",
                "description": "Display Stripe test card numbers for various testing scenarios",
                "path": "external_plugins/stripe/commands/test-cards.md",
                "frontmatter": {
                  "description": "Display Stripe test card numbers for various testing scenarios",
                  "argument-hint": [
                    "scenario"
                  ]
                },
                "content": "# Test Cards Reference\n\nProvide a quick reference for Stripe test card numbers:\n\n1. If a scenario argument is provided (e.g., \"declined\", \"3dsecure\", \"fraud\"), show relevant test cards for that scenario\n2. Otherwise, show the most common test cards organized by category:\n   - Successful payment (default card)\n   - 3D Secure authentication required\n   - Generic decline\n   - Specific decline reasons (insufficient_funds, lost_card, etc.)\n3. For each card, display:\n   - Card number (formatted with spaces)\n   - Expected behavior\n   - Expiry/CVC info (any future date and any 3-digit CVC)\n4. Use clear visual indicators (âœ“ for success, âš ï¸ for auth required, âœ— for decline)\n5. Mention that these only work in test mode\n6. Provide link to full testing documentation: https://docs.stripe.com/testing.md\n\nIf the user is currently working on test code, offer to generate test cases using these cards."
              },
              {
                "name": "/new-sdk-app",
                "description": "Create and setup a new Claude Agent SDK application",
                "path": "plugins/agent-sdk-dev/commands/new-sdk-app.md",
                "frontmatter": {
                  "description": "Create and setup a new Claude Agent SDK application",
                  "argument-hint": [
                    "project-name"
                  ]
                },
                "content": "You are tasked with helping the user create a new Claude Agent SDK application. Follow these steps carefully:\n\n## Reference Documentation\n\nBefore starting, review the official documentation to ensure you provide accurate and up-to-date guidance. Use WebFetch to read these pages:\n\n1. **Start with the overview**: https://docs.claude.com/en/api/agent-sdk/overview\n2. **Based on the user's language choice, read the appropriate SDK reference**:\n   - TypeScript: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Python: https://docs.claude.com/en/api/agent-sdk/python\n3. **Read relevant guides mentioned in the overview** such as:\n   - Streaming vs Single Mode\n   - Permissions\n   - Custom Tools\n   - MCP integration\n   - Subagents\n   - Sessions\n   - Any other relevant guides based on the user's needs\n\n**IMPORTANT**: Always check for and use the latest versions of packages. Use WebSearch or WebFetch to verify current versions before installation.\n\n## Gather Requirements\n\nIMPORTANT: Ask these questions one at a time. Wait for the user's response before asking the next question. This makes it easier for the user to respond.\n\nAsk the questions in this order (skip any that the user has already provided via arguments):\n\n1. **Language** (ask first): \"Would you like to use TypeScript or Python?\"\n\n   - Wait for response before continuing\n\n2. **Project name** (ask second): \"What would you like to name your project?\"\n\n   - If $ARGUMENTS is provided, use that as the project name and skip this question\n   - Wait for response before continuing\n\n3. **Agent type** (ask third, but skip if #2 was sufficiently detailed): \"What kind of agent are you building? Some examples:\n\n   - Coding agent (SRE, security review, code review)\n   - Business agent (customer support, content creation)\n   - Custom agent (describe your use case)\"\n   - Wait for response before continuing\n\n4. **Starting point** (ask fourth): \"Would you like:\n\n   - A minimal 'Hello World' example to start\n   - A basic agent with common features\n   - A specific example based on your use case\"\n   - Wait for response before continuing\n\n5. **Tooling choice** (ask fifth): Let the user know what tools you'll use, and confirm with them that these are the tools they want to use (for example, they may prefer pnpm or bun over npm). Respect the user's preferences when executing on the requirements.\n\nAfter all questions are answered, proceed to create the setup plan.\n\n## Setup Plan\n\nBased on the user's answers, create a plan that includes:\n\n1. **Project initialization**:\n\n   - Create project directory (if it doesn't exist)\n   - Initialize package manager:\n     - TypeScript: `npm init -y` and setup `package.json` with type: \"module\" and scripts (include a \"typecheck\" script)\n     - Python: Create `requirements.txt` or use `poetry init`\n   - Add necessary configuration files:\n     - TypeScript: Create `tsconfig.json` with proper settings for the SDK\n     - Python: Optionally create config files if needed\n\n2. **Check for Latest Versions**:\n\n   - BEFORE installing, use WebSearch or check npm/PyPI to find the latest version\n   - For TypeScript: Check https://www.npmjs.com/package/@anthropic-ai/claude-agent-sdk\n   - For Python: Check https://pypi.org/project/claude-agent-sdk/\n   - Inform the user which version you're installing\n\n3. **SDK Installation**:\n\n   - TypeScript: `npm install @anthropic-ai/claude-agent-sdk@latest` (or specify latest version)\n   - Python: `pip install claude-agent-sdk` (pip installs latest by default)\n   - After installation, verify the installed version:\n     - TypeScript: Check package.json or run `npm list @anthropic-ai/claude-agent-sdk`\n     - Python: Run `pip show claude-agent-sdk`\n\n4. **Create starter files**:\n\n   - TypeScript: Create an `index.ts` or `src/index.ts` with a basic query example\n   - Python: Create a `main.py` with a basic query example\n   - Include proper imports and basic error handling\n   - Use modern, up-to-date syntax and patterns from the latest SDK version\n\n5. **Environment setup**:\n\n   - Create a `.env.example` file with `ANTHROPIC_API_KEY=your_api_key_here`\n   - Add `.env` to `.gitignore`\n   - Explain how to get an API key from https://console.anthropic.com/\n\n6. **Optional: Create .claude directory structure**:\n   - Offer to create `.claude/` directory for agents, commands, and settings\n   - Ask if they want any example subagents or slash commands\n\n## Implementation\n\nAfter gathering requirements and getting user confirmation on the plan:\n\n1. Check for latest package versions using WebSearch or WebFetch\n2. Execute the setup steps\n3. Create all necessary files\n4. Install dependencies (always use latest stable versions)\n5. Verify installed versions and inform the user\n6. Create a working example based on their agent type\n7. Add helpful comments in the code explaining what each part does\n8. **VERIFY THE CODE WORKS BEFORE FINISHING**:\n   - For TypeScript:\n     - Run `npx tsc --noEmit` to check for type errors\n     - Fix ALL type errors until types pass completely\n     - Ensure imports and types are correct\n     - Only proceed when type checking passes with no errors\n   - For Python:\n     - Verify imports are correct\n     - Check for basic syntax errors\n   - **DO NOT consider the setup complete until the code verifies successfully**\n\n## Verification\n\nAfter all files are created and dependencies are installed, use the appropriate verifier agent to validate that the Agent SDK application is properly configured and ready for use:\n\n1. **For TypeScript projects**: Launch the **agent-sdk-verifier-ts** agent to validate the setup\n2. **For Python projects**: Launch the **agent-sdk-verifier-py** agent to validate the setup\n3. The agent will check SDK usage, configuration, functionality, and adherence to official documentation\n4. Review the verification report and address any issues\n\n## Getting Started Guide\n\nOnce setup is complete and verified, provide the user with:\n\n1. **Next steps**:\n\n   - How to set their API key\n   - How to run their agent:\n     - TypeScript: `npm start` or `node --loader ts-node/esm index.ts`\n     - Python: `python main.py`\n\n2. **Useful resources**:\n\n   - Link to TypeScript SDK reference: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Link to Python SDK reference: https://docs.claude.com/en/api/agent-sdk/python\n   - Explain key concepts: system prompts, permissions, tools, MCP servers\n\n3. **Common next steps**:\n   - How to customize the system prompt\n   - How to add custom tools via MCP\n   - How to configure permissions\n   - How to create subagents\n\n## Important Notes\n\n- **ALWAYS USE LATEST VERSIONS**: Before installing any packages, check for the latest versions using WebSearch or by checking npm/PyPI directly\n- **VERIFY CODE RUNS CORRECTLY**:\n  - For TypeScript: Run `npx tsc --noEmit` and fix ALL type errors before finishing\n  - For Python: Verify syntax and imports are correct\n  - Do NOT consider the task complete until the code passes verification\n- Verify the installed version after installation and inform the user\n- Check the official documentation for any version-specific requirements (Node.js version, Python version, etc.)\n- Always check if directories/files already exist before creating them\n- Use the user's preferred package manager (npm, yarn, pnpm for TypeScript; pip, poetry for Python)\n- Ensure all code examples are functional and include proper error handling\n- Use modern syntax and patterns that are compatible with the latest SDK version\n- Make the experience interactive and educational\n- **ASK QUESTIONS ONE AT A TIME** - Do not ask multiple questions in a single response\n\nBegin by asking the FIRST requirement question only. Wait for the user's answer before proceeding to the next question."
              },
              {
                "name": "/code-review",
                "description": "Code review a pull request",
                "path": "plugins/code-review/commands/code-review.md",
                "frontmatter": {
                  "allowed-tools": "Bash(gh issue view:*), Bash(gh search:*), Bash(gh issue list:*), Bash(gh pr comment:*), Bash(gh pr diff:*), Bash(gh pr view:*), Bash(gh pr list:*)",
                  "description": "Code review a pull request",
                  "disable-model-invocation": false
                },
                "content": "Provide a code review for the given pull request.\n\nTo do this, follow these steps precisely:\n\n1. Use a Haiku agent to check if the pull request (a) is closed, (b) is a draft, (c) does not need a code review (eg. because it is an automated pull request, or is very simple and obviously ok), or (d) already has a code review from you from earlier. If so, do not proceed.\n2. Use another Haiku agent to give you a list of file paths to (but not the contents of) any relevant CLAUDE.md files from the codebase: the root CLAUDE.md file (if one exists), as well as any CLAUDE.md files in the directories whose files the pull request modified\n3. Use a Haiku agent to view the pull request, and ask the agent to return a summary of the change\n4. Then, launch 5 parallel Sonnet agents to independently code review the change. The agents should do the following, then return a list of issues and the reason each issue was flagged (eg. CLAUDE.md adherence, bug, historical git context, etc.):\n   a. Agent #1: Audit the changes to make sure they compily with the CLAUDE.md. Note that CLAUDE.md is guidance for Claude as it writes code, so not all instructions will be applicable during code review.\n   b. Agent #2: Read the file changes in the pull request, then do a shallow scan for obvious bugs. Avoid reading extra context beyond the changes, focusing just on the changes themselves. Focus on large bugs, and avoid small issues and nitpicks. Ignore likely false positives.\n   c. Agent #3: Read the git blame and history of the code modified, to identify any bugs in light of that historical context\n   d. Agent #4: Read previous pull requests that touched these files, and check for any comments on those pull requests that may also apply to the current pull request.\n   e. Agent #5: Read code comments in the modified files, and make sure the changes in the pull request comply with any guidance in the comments.\n5. For each issue found in #4, launch a parallel Haiku agent that takes the PR, issue description, and list of CLAUDE.md files (from step 2), and returns a score to indicate the agent's level of confidence for whether the issue is real or false positive. To do that, the agent should score each issue on a scale from 0-100, indicating its level of confidence. For issues that were flagged due to CLAUDE.md instructions, the agent should double check that the CLAUDE.md actually calls out that issue specifically. The scale is (give this rubric to the agent verbatim):\n   a. 0: Not confident at all. This is a false positive that doesn't stand up to light scrutiny, or is a pre-existing issue.\n   b. 25: Somewhat confident. This might be a real issue, but may also be a false positive. The agent wasn't able to verify that it's a real issue. If the issue is stylistic, it is one that was not explicitly called out in the relevant CLAUDE.md.\n   c. 50: Moderately confident. The agent was able to verify this is a real issue, but it might be a nitpick or not happen very often in practice. Relative to the rest of the PR, it's not very important.\n   d. 75: Highly confident. The agent double checked the issue, and verified that it is very likely it is a real issue that will be hit in practice. The existing approach in the PR is insufficient. The issue is very important and will directly impact the code's functionality, or it is an issue that is directly mentioned in the relevant CLAUDE.md.\n   e. 100: Absolutely certain. The agent double checked the issue, and confirmed that it is definitely a real issue, that will happen frequently in practice. The evidence directly confirms this.\n6. Filter out any issues with a score less than 80. If there are no issues that meet this criteria, do not proceed.\n7. Use a Haiku agent to repeat the eligibility check from #1, to make sure that the pull request is still eligible for code review.\n8. Finally, use the gh bash command to comment back on the pull request with the result. When writing your comment, keep in mind to:\n   a. Keep your output brief\n   b. Avoid emojis\n   c. Link and cite relevant code, files, and URLs\n\nExamples of false positives, for steps 4 and 5:\n\n- Pre-existing issues\n- Something that looks like a bug but is not actually a bug\n- Pedantic nitpicks that a senior engineer wouldn't call out\n- Issues that a linter, typechecker, or compiler would catch (eg. missing or incorrect imports, type errors, broken tests, formatting issues, pedantic style issues like newlines). No need to run these build steps yourself -- it is safe to assume that they will be run separately as part of CI.\n- General code quality issues (eg. lack of test coverage, general security issues, poor documentation), unless explicitly required in CLAUDE.md\n- Issues that are called out in CLAUDE.md, but explicitly silenced in the code (eg. due to a lint ignore comment)\n- Changes in functionality that are likely intentional or are directly related to the broader change\n- Real issues, but on lines that the user did not modify in their pull request\n\nNotes:\n\n- Do not check build signal or attempt to build or typecheck the app. These will run separately, and are not relevant to your code review.\n- Use `gh` to interact with Github (eg. to fetch a pull request, or to create inline comments), rather than web fetch\n- Make a todo list first\n- You must cite and link each bug (eg. if referring to a CLAUDE.md, you must link it)\n- For your final comment, follow the following format precisely (assuming for this example that you found 3 issues):\n\n---\n\n### Code review\n\nFound 3 issues:\n\n1. <brief description of bug> (CLAUDE.md says \"<...>\")\n\n<link to file and line with full sha1 + line range for context, note that you MUST provide the full sha and not use bash here, eg. https://github.com/anthropics/claude-code/blob/1d54823877c4de72b2316a64032a54afc404e619/README.md#L13-L17>\n\n2. <brief description of bug> (some/other/CLAUDE.md says \"<...>\")\n\n<link to file and line with full sha1 + line range for context>\n\n3. <brief description of bug> (bug due to <file and code snippet>)\n\n<link to file and line with full sha1 + line range for context>\n\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\n<sub>- If this code review was useful, please react with ðŸ‘. Otherwise, react with ðŸ‘Ž.</sub>\n\n---\n\n- Or, if you found no issues:\n\n---\n\n### Code review\n\nNo issues found. Checked for bugs and CLAUDE.md compliance.\n\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\n- When linking to code, follow the following format precisely, otherwise the Markdown preview won't render correctly: https://github.com/anthropics/claude-cli-internal/blob/c21d3c10bc8e898b7ac1a2d745bdc9bc4e423afe/package.json#L10-L15\n  - Requires full git sha\n  - You must provide the full sha. Commands like `https://github.com/owner/repo/blob/$(git rev-parse HEAD)/foo/bar` will not work, since your comment will be directly rendered in Markdown.\n  - Repo name must match the repo you're code reviewing\n  - # sign after the file name\n  - Line range format is L[start]-L[end]\n  - Provide at least 1 line of context before and after, centered on the line you are commenting about (eg. if you are commenting about lines 5-6, you should link to `L4-7`)"
              },
              {
                "name": "/clean_gone",
                "description": "Cleans up all git branches marked as [gone] (branches that have been deleted on the remote but still exist locally), including removing associated worktrees.",
                "path": "plugins/commit-commands/commands/clean_gone.md",
                "frontmatter": {
                  "description": "Cleans up all git branches marked as [gone] (branches that have been deleted on the remote but still exist locally), including removing associated worktrees."
                },
                "content": "## Your Task\n\nYou need to execute the following bash commands to clean up stale local branches that have been deleted from the remote repository.\n\n## Commands to Execute\n\n1. **First, list branches to identify any with [gone] status**\n   Execute this command:\n   ```bash\n   git branch -v\n   ```\n   \n   Note: Branches with a '+' prefix have associated worktrees and must have their worktrees removed before deletion.\n\n2. **Next, identify worktrees that need to be removed for [gone] branches**\n   Execute this command:\n   ```bash\n   git worktree list\n   ```\n\n3. **Finally, remove worktrees and delete [gone] branches (handles both regular and worktree branches)**\n   Execute this command:\n   ```bash\n   # Process all [gone] branches, removing '+' prefix if present\n   git branch -v | grep '\\[gone\\]' | sed 's/^[+* ]//' | awk '{print $1}' | while read branch; do\n     echo \"Processing branch: $branch\"\n     # Find and remove worktree if it exists\n     worktree=$(git worktree list | grep \"\\\\[$branch\\\\]\" | awk '{print $1}')\n     if [ ! -z \"$worktree\" ] && [ \"$worktree\" != \"$(git rev-parse --show-toplevel)\" ]; then\n       echo \"  Removing worktree: $worktree\"\n       git worktree remove --force \"$worktree\"\n     fi\n     # Delete the branch\n     echo \"  Deleting branch: $branch\"\n     git branch -D \"$branch\"\n   done\n   ```\n\n## Expected Behavior\n\nAfter executing these commands, you will:\n\n- See a list of all local branches with their status\n- Identify and remove any worktrees associated with [gone] branches\n- Delete all branches marked as [gone]\n- Provide feedback on which worktrees and branches were removed\n\nIf no branches are marked as [gone], report that no cleanup was needed."
              },
              {
                "name": "/commit-push-pr",
                "description": "Commit, push, and open a PR",
                "path": "plugins/commit-commands/commands/commit-push-pr.md",
                "frontmatter": {
                  "allowed-tools": "Bash(git checkout --branch:*), Bash(git add:*), Bash(git status:*), Bash(git push:*), Bash(git commit:*), Bash(gh pr create:*)",
                  "description": "Commit, push, and open a PR"
                },
                "content": "## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n\n## Your task\n\nBased on the above changes:\n\n1. Create a new branch if on main\n2. Create a single commit with an appropriate message\n3. Push the branch to origin\n4. Create a pull request using `gh pr create`\n5. You have the capability to call multiple tools in a single response. You MUST do all of the above in a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls."
              },
              {
                "name": "/commit",
                "description": "Create a git commit",
                "path": "plugins/commit-commands/commands/commit.md",
                "frontmatter": {
                  "allowed-tools": "Bash(git add:*), Bash(git status:*), Bash(git commit:*)",
                  "description": "Create a git commit"
                },
                "content": "## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n- Recent commits: !`git log --oneline -10`\n\n## Your task\n\nBased on the above changes, create a single git commit.\n\nYou have the capability to call multiple tools in a single response. Stage and create the commit using a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls."
              },
              {
                "name": "/example-command",
                "description": "An example slash command that demonstrates command frontmatter options",
                "path": "plugins/example-plugin/commands/example-command.md",
                "frontmatter": {
                  "description": "An example slash command that demonstrates command frontmatter options",
                  "argument-hint": "<required-arg> [optional-arg]",
                  "allowed-tools": [
                    "Read",
                    "Glob",
                    "Grep",
                    "Bash"
                  ]
                },
                "content": "# Example Command\n\nThis command demonstrates slash command structure and frontmatter options.\n\n## Arguments\n\nThe user invoked this command with: $ARGUMENTS\n\n## Instructions\n\nWhen this command is invoked:\n\n1. Parse the arguments provided by the user\n2. Perform the requested action using allowed tools\n3. Report results back to the user\n\n## Frontmatter Options Reference\n\nCommands support these frontmatter fields:\n\n- **description**: Short description shown in /help\n- **argument-hint**: Hints for command arguments shown to user\n- **allowed-tools**: Pre-approved tools for this command (reduces permission prompts)\n- **model**: Override the model (e.g., \"haiku\", \"sonnet\", \"opus\")\n\n## Example Usage\n\n```\n/example-command my-argument\n/example-command arg1 arg2\n```"
              },
              {
                "name": "/feature-dev",
                "description": "Guided feature development with codebase understanding and architecture focus",
                "path": "plugins/feature-dev/commands/feature-dev.md",
                "frontmatter": {
                  "description": "Guided feature development with codebase understanding and architecture focus",
                  "argument-hint": "Optional feature description"
                },
                "content": "# Feature Development\n\nYou are helping a developer implement a new feature. Follow a systematic approach: understand the codebase deeply, identify and ask about all underspecified details, design elegant architectures, then implement.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities, edge cases, and underspecified behaviors. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation. Ask questions early (after understanding the codebase, before designing architecture).\n- **Understand before acting**: Read and comprehend existing code patterns first\n- **Read files identified by agents**: When launching agents, ask them to return lists of the most important files to read. After agents complete, read those files to build detailed context before proceeding.\n- **Simple and elegant**: Prioritize readable, maintainable, architecturally sound code\n- **Use TodoWrite**: Track all progress throughout\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what needs to be built\n\nInitial request: $ARGUMENTS\n\n**Actions**:\n1. Create todo list with all phases\n2. If feature unclear, ask user for:\n   - What problem are they solving?\n   - What should the feature do?\n   - Any constraints or requirements?\n3. Summarize understanding and confirm with user\n\n---\n\n## Phase 2: Codebase Exploration\n\n**Goal**: Understand relevant existing code and patterns at both high and low levels\n\n**Actions**:\n1. Launch 2-3 code-explorer agents in parallel. Each agent should:\n   - Trace through the code comprehensively and focus on getting a comprehensive understanding of abstractions, architecture and flow of control\n   - Target a different aspect of the codebase (eg. similar features, high level understanding, architectural understanding, user experience, etc)\n   - Include a list of 5-10 key files to read\n\n   **Example agent prompts**:\n   - \"Find features similar to [feature] and trace through their implementation comprehensively\"\n   - \"Map the architecture and abstractions for [feature area], tracing through the code comprehensively\"\n   - \"Analyze the current implementation of [existing feature/area], tracing through the code comprehensively\"\n   - \"Identify UI patterns, testing approaches, or extension points relevant to [feature]\"\n\n2. Once the agents return, please read all files identified by agents to build deep understanding\n3. Present comprehensive summary of findings and patterns discovered\n\n---\n\n## Phase 3: Clarifying Questions\n\n**Goal**: Fill in gaps and resolve all ambiguities before designing\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. Review the codebase findings and original feature request\n2. Identify underspecified aspects: edge cases, error handling, integration points, scope boundaries, design preferences, backward compatibility, performance needs\n3. **Present all questions to the user in a clear, organized list**\n4. **Wait for answers before proceeding to architecture design**\n\nIf the user says \"whatever you think is best\", provide your recommendation and get explicit confirmation.\n\n---\n\n## Phase 4: Architecture Design\n\n**Goal**: Design multiple implementation approaches with different trade-offs\n\n**Actions**:\n1. Launch 2-3 code-architect agents in parallel with different focuses: minimal changes (smallest change, maximum reuse), clean architecture (maintainability, elegant abstractions), or pragmatic balance (speed + quality)\n2. Review all approaches and form your opinion on which fits best for this specific task (consider: small fix vs large feature, urgency, complexity, team context)\n3. Present to user: brief summary of each approach, trade-offs comparison, **your recommendation with reasoning**, concrete implementation differences\n4. **Ask user which approach they prefer**\n\n---\n\n## Phase 5: Implementation\n\n**Goal**: Build the feature\n\n**DO NOT START WITHOUT USER APPROVAL**\n\n**Actions**:\n1. Wait for explicit user approval\n2. Read all relevant files identified in previous phases\n3. Implement following chosen architecture\n4. Follow codebase conventions strictly\n5. Write clean, well-documented code\n6. Update todos as you progress\n\n---\n\n## Phase 6: Quality Review\n\n**Goal**: Ensure code is simple, DRY, elegant, easy to read, and functionally correct\n\n**Actions**:\n1. Launch 3 code-reviewer agents in parallel with different focuses: simplicity/DRY/elegance, bugs/functional correctness, project conventions/abstractions\n2. Consolidate findings and identify highest severity issues that you recommend fixing\n3. **Present findings to user and ask what they want to do** (fix now, fix later, or proceed as-is)\n4. Address issues based on user decision\n\n---\n\n## Phase 7: Summary\n\n**Goal**: Document what was accomplished\n\n**Actions**:\n1. Mark all todos complete\n2. Summarize:\n   - What was built\n   - Key decisions made\n   - Files modified\n   - Suggested next steps\n\n---"
              },
              {
                "name": "/configure",
                "description": "Enable or disable hookify rules interactively",
                "path": "plugins/hookify/commands/configure.md",
                "frontmatter": {
                  "description": "Enable or disable hookify rules interactively",
                  "allowed-tools": [
                    "Glob",
                    "Read",
                    "Edit",
                    "AskUserQuestion",
                    "Skill"
                  ]
                },
                "content": "# Configure Hookify Rules\n\n**Load hookify:writing-rules skill first** to understand rule format.\n\nEnable or disable existing hookify rules using an interactive interface.\n\n## Steps\n\n### 1. Find Existing Rules\n\nUse Glob tool to find all hookify rule files:\n```\npattern: \".claude/hookify.*.local.md\"\n```\n\nIf no rules found, inform user:\n```\nNo hookify rules configured yet. Use `/hookify` to create your first rule.\n```\n\n### 2. Read Current State\n\nFor each rule file:\n- Read the file\n- Extract `name` and `enabled` fields from frontmatter\n- Build list of rules with current state\n\n### 3. Ask User Which Rules to Toggle\n\nUse AskUserQuestion to let user select rules:\n\n```json\n{\n  \"questions\": [\n    {\n      \"question\": \"Which rules would you like to enable or disable?\",\n      \"header\": \"Configure\",\n      \"multiSelect\": true,\n      \"options\": [\n        {\n          \"label\": \"warn-dangerous-rm (currently enabled)\",\n          \"description\": \"Warns about rm -rf commands\"\n        },\n        {\n          \"label\": \"warn-console-log (currently disabled)\",\n          \"description\": \"Warns about console.log in code\"\n        },\n        {\n          \"label\": \"require-tests (currently enabled)\",\n          \"description\": \"Requires tests before stopping\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Option format:**\n- Label: `{rule-name} (currently {enabled|disabled})`\n- Description: Brief description from rule's message or pattern\n\n### 4. Parse User Selection\n\nFor each selected rule:\n- Determine current state from label (enabled/disabled)\n- Toggle state: enabled â†’ disabled, disabled â†’ enabled\n\n### 5. Update Rule Files\n\nFor each rule to toggle:\n- Use Read tool to read current content\n- Use Edit tool to change `enabled: true` to `enabled: false` (or vice versa)\n- Handle both with and without quotes\n\n**Edit pattern for enabling:**\n```\nold_string: \"enabled: false\"\nnew_string: \"enabled: true\"\n```\n\n**Edit pattern for disabling:**\n```\nold_string: \"enabled: true\"\nnew_string: \"enabled: false\"\n```\n\n### 6. Confirm Changes\n\nShow user what was changed:\n\n```\n## Hookify Rules Updated\n\n**Enabled:**\n- warn-console-log\n\n**Disabled:**\n- warn-dangerous-rm\n\n**Unchanged:**\n- require-tests\n\nChanges apply immediately - no restart needed\n```\n\n## Important Notes\n\n- Changes take effect immediately on next tool use\n- You can also manually edit .claude/hookify.*.local.md files\n- To permanently remove a rule, delete its .local.md file\n- Use `/hookify:list` to see all configured rules\n\n## Edge Cases\n\n**No rules to configure:**\n- Show message about using `/hookify` to create rules first\n\n**User selects no rules:**\n- Inform that no changes were made\n\n**File read/write errors:**\n- Inform user of specific error\n- Suggest manual editing as fallback"
              },
              {
                "name": "/help",
                "description": "Get help with the hookify plugin",
                "path": "plugins/hookify/commands/help.md",
                "frontmatter": {
                  "description": "Get help with the hookify plugin",
                  "allowed-tools": [
                    "Read"
                  ]
                },
                "content": "# Hookify Plugin Help\n\nExplain how the hookify plugin works and how to use it.\n\n## Overview\n\nThe hookify plugin makes it easy to create custom hooks that prevent unwanted behaviors. Instead of editing `hooks.json` files, users create simple markdown configuration files that define patterns to watch for.\n\n## How It Works\n\n### 1. Hook System\n\nHookify installs generic hooks that run on these events:\n- **PreToolUse**: Before any tool executes (Bash, Edit, Write, etc.)\n- **PostToolUse**: After a tool executes\n- **Stop**: When Claude wants to stop working\n- **UserPromptSubmit**: When user submits a prompt\n\nThese hooks read configuration files from `.claude/hookify.*.local.md` and check if any rules match the current operation.\n\n### 2. Configuration Files\n\nUsers create rules in `.claude/hookify.{rule-name}.local.md` files:\n\n```markdown\n---\nname: warn-dangerous-rm\nenabled: true\nevent: bash\npattern: rm\\s+-rf\n---\n\nâš ï¸ **Dangerous rm command detected!**\n\nThis command could delete important files. Please verify the path.\n```\n\n**Key fields:**\n- `name`: Unique identifier for the rule\n- `enabled`: true/false to activate/deactivate\n- `event`: bash, file, stop, prompt, or all\n- `pattern`: Regex pattern to match\n\nThe message body is what Claude sees when the rule triggers.\n\n### 3. Creating Rules\n\n**Option A: Use /hookify command**\n```\n/hookify Don't use console.log in production files\n```\n\nThis analyzes your request and creates the appropriate rule file.\n\n**Option B: Create manually**\nCreate `.claude/hookify.my-rule.local.md` with the format above.\n\n**Option C: Analyze conversation**\n```\n/hookify\n```\n\nWithout arguments, hookify analyzes recent conversation to find behaviors you want to prevent.\n\n## Available Commands\n\n- **`/hookify`** - Create hooks from conversation analysis or explicit instructions\n- **`/hookify:help`** - Show this help (what you're reading now)\n- **`/hookify:list`** - List all configured hooks\n- **`/hookify:configure`** - Enable/disable existing hooks interactively\n\n## Example Use Cases\n\n**Prevent dangerous commands:**\n```markdown\n---\nname: block-chmod-777\nenabled: true\nevent: bash\npattern: chmod\\s+777\n---\n\nDon't use chmod 777 - it's a security risk. Use specific permissions instead.\n```\n\n**Warn about debugging code:**\n```markdown\n---\nname: warn-console-log\nenabled: true\nevent: file\npattern: console\\.log\\(\n---\n\nConsole.log detected. Remember to remove debug logging before committing.\n```\n\n**Require tests before stopping:**\n```markdown\n---\nname: require-tests\nenabled: true\nevent: stop\npattern: .*\n---\n\nDid you run tests before finishing? Make sure `npm test` or equivalent was executed.\n```\n\n## Pattern Syntax\n\nUse Python regex syntax:\n- `\\s` - whitespace\n- `\\.` - literal dot\n- `|` - OR\n- `+` - one or more\n- `*` - zero or more\n- `\\d` - digit\n- `[abc]` - character class\n\n**Examples:**\n- `rm\\s+-rf` - matches \"rm -rf\"\n- `console\\.log\\(` - matches \"console.log(\"\n- `(eval|exec)\\(` - matches \"eval(\" or \"exec(\"\n- `\\.env$` - matches files ending in .env\n\n## Important Notes\n\n**No Restart Needed**: Hookify rules (`.local.md` files) take effect immediately on the next tool use. The hookify hooks are already loaded and read your rules dynamically.\n\n**Block or Warn**: Rules can either `block` operations (prevent execution) or `warn` (show message but allow). Set `action: block` or `action: warn` in the rule's frontmatter.\n\n**Rule Files**: Keep rules in `.claude/hookify.*.local.md` - they should be git-ignored (add to .gitignore if needed).\n\n**Disable Rules**: Set `enabled: false` in frontmatter or delete the file.\n\n## Troubleshooting\n\n**Hook not triggering:**\n- Check rule file is in `.claude/` directory\n- Verify `enabled: true` in frontmatter\n- Confirm pattern is valid regex\n- Test pattern: `python3 -c \"import re; print(re.search('your_pattern', 'test_text'))\"`\n- Rules take effect immediately - no restart needed\n\n**Import errors:**\n- Check Python 3 is available: `python3 --version`\n- Verify hookify plugin is installed correctly\n\n**Pattern not matching:**\n- Test regex separately\n- Check for escaping issues (use unquoted patterns in YAML)\n- Try simpler pattern first, then refine\n\n## Getting Started\n\n1. Create your first rule:\n   ```\n   /hookify Warn me when I try to use rm -rf\n   ```\n\n2. Try to trigger it:\n   - Ask Claude to run `rm -rf /tmp/test`\n   - You should see the warning\n\n4. Refine the rule by editing `.claude/hookify.warn-rm.local.md`\n\n5. Create more rules as you encounter unwanted behaviors\n\nFor more examples, check the `${CLAUDE_PLUGIN_ROOT}/examples/` directory."
              },
              {
                "name": "/hookify",
                "description": "Create hooks to prevent unwanted behaviors from conversation analysis or explicit instructions",
                "path": "plugins/hookify/commands/hookify.md",
                "frontmatter": {
                  "description": "Create hooks to prevent unwanted behaviors from conversation analysis or explicit instructions",
                  "argument-hint": "Optional specific behavior to address",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "AskUserQuestion",
                    "Task",
                    "Grep",
                    "TodoWrite",
                    "Skill"
                  ]
                },
                "content": "# Hookify - Create Hooks from Unwanted Behaviors\n\n**FIRST: Load the hookify:writing-rules skill** using the Skill tool to understand rule file format and syntax.\n\nCreate hook rules to prevent problematic behaviors by analyzing the conversation or from explicit user instructions.\n\n## Your Task\n\nYou will help the user create hookify rules to prevent unwanted behaviors. Follow these steps:\n\n### Step 1: Gather Behavior Information\n\n**If $ARGUMENTS is provided:**\n- User has given specific instructions: `$ARGUMENTS`\n- Still analyze recent conversation (last 10-15 user messages) for additional context\n- Look for examples of the behavior happening\n\n**If $ARGUMENTS is empty:**\n- Launch the conversation-analyzer agent to find problematic behaviors\n- Agent will scan user prompts for frustration signals\n- Agent will return structured findings\n\n**To analyze conversation:**\nUse the Task tool to launch conversation-analyzer agent:\n```\n{\n  \"subagent_type\": \"general-purpose\",\n  \"description\": \"Analyze conversation for unwanted behaviors\",\n  \"prompt\": \"You are analyzing a Claude Code conversation to find behaviors the user wants to prevent.\n\nRead user messages in the current conversation and identify:\n1. Explicit requests to avoid something (\\\"don't do X\\\", \\\"stop doing Y\\\")\n2. Corrections or reversions (user fixing Claude's actions)\n3. Frustrated reactions (\\\"why did you do X?\\\", \\\"I didn't ask for that\\\")\n4. Repeated issues (same problem multiple times)\n\nFor each issue found, extract:\n- What tool was used (Bash, Edit, Write, etc.)\n- Specific pattern or command\n- Why it was problematic\n- User's stated reason\n\nReturn findings as a structured list with:\n- category: Type of issue\n- tool: Which tool was involved\n- pattern: Regex or literal pattern to match\n- context: What happened\n- severity: high/medium/low\n\nFocus on the most recent issues (last 20-30 messages). Don't go back further unless explicitly asked.\"\n}\n```\n\n### Step 2: Present Findings to User\n\nAfter gathering behaviors (from arguments or agent), present to user using AskUserQuestion:\n\n**Question 1: Which behaviors to hookify?**\n- Header: \"Create Rules\"\n- multiSelect: true\n- Options: List each detected behavior (max 4)\n  - Label: Short description (e.g., \"Block rm -rf\")\n  - Description: Why it's problematic\n\n**Question 2: For each selected behavior, ask about action:**\n- \"Should this block the operation or just warn?\"\n- Options:\n  - \"Just warn\" (action: warn - shows message but allows)\n  - \"Block operation\" (action: block - prevents execution)\n\n**Question 3: Ask for example patterns:**\n- \"What patterns should trigger this rule?\"\n- Show detected patterns\n- Allow user to refine or add more\n\n### Step 3: Generate Rule Files\n\nFor each confirmed behavior, create a `.claude/hookify.{rule-name}.local.md` file:\n\n**Rule naming convention:**\n- Use kebab-case\n- Be descriptive: `block-dangerous-rm`, `warn-console-log`, `require-tests-before-stop`\n- Start with action verb: block, warn, prevent, require\n\n**File format:**\n```markdown\n---\nname: {rule-name}\nenabled: true\nevent: {bash|file|stop|prompt|all}\npattern: {regex pattern}\naction: {warn|block}\n---\n\n{Message to show Claude when rule triggers}\n```\n\n**Action values:**\n- `warn`: Show message but allow operation (default)\n- `block`: Prevent operation or stop session\n\n**For more complex rules (multiple conditions):**\n```markdown\n---\nname: {rule-name}\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$\n  - field: new_text\n    operator: contains\n    pattern: API_KEY\n---\n\n{Warning message}\n```\n\n### Step 4: Create Files and Confirm\n\n**IMPORTANT**: Rule files must be created in the current working directory's `.claude/` folder, NOT the plugin directory.\n\nUse the current working directory (where Claude Code was started) as the base path.\n\n1. Check if `.claude/` directory exists in current working directory\n   - If not, create it first with: `mkdir -p .claude`\n\n2. Use Write tool to create each `.claude/hookify.{name}.local.md` file\n   - Use relative path from current working directory: `.claude/hookify.{name}.local.md`\n   - The path should resolve to the project's .claude directory, not the plugin's\n\n3. Show user what was created:\n   ```\n   Created 3 hookify rules:\n   - .claude/hookify.dangerous-rm.local.md\n   - .claude/hookify.console-log.local.md\n   - .claude/hookify.sensitive-files.local.md\n\n   These rules will trigger on:\n   - dangerous-rm: Bash commands matching \"rm -rf\"\n   - console-log: Edits adding console.log statements\n   - sensitive-files: Edits to .env or credentials files\n   ```\n\n4. Verify files were created in the correct location by listing them\n\n5. Inform user: **\"Rules are active immediately - no restart needed!\"**\n\n   The hookify hooks are already loaded and will read your new rules on the next tool use.\n\n## Event Types Reference\n\n- **bash**: Matches Bash tool commands\n- **file**: Matches Edit, Write, MultiEdit tools\n- **stop**: Matches when agent wants to stop (use for completion checks)\n- **prompt**: Matches when user submits prompts\n- **all**: Matches all events\n\n## Pattern Writing Tips\n\n**Bash patterns:**\n- Match dangerous commands: `rm\\s+-rf|chmod\\s+777|dd\\s+if=`\n- Match specific tools: `npm\\s+install\\s+|pip\\s+install`\n\n**File patterns:**\n- Match code patterns: `console\\.log\\(|eval\\(|innerHTML\\s*=`\n- Match file paths: `\\.env$|\\.git/|node_modules/`\n\n**Stop patterns:**\n- Check for missing steps: (check transcript or completion criteria)\n\n## Example Workflow\n\n**User says**: \"/hookify Don't use rm -rf without asking me first\"\n\n**Your response**:\n1. Analyze: User wants to prevent rm -rf commands\n2. Ask: \"Should I block this command or just warn you?\"\n3. User selects: \"Just warn\"\n4. Create `.claude/hookify.dangerous-rm.local.md`:\n   ```markdown\n   ---\n   name: warn-dangerous-rm\n   enabled: true\n   event: bash\n   pattern: rm\\s+-rf\n   ---\n\n   âš ï¸ **Dangerous rm command detected**\n\n   You requested to be warned before using rm -rf.\n   Please verify the path is correct.\n   ```\n5. Confirm: \"Created hookify rule. It's active immediately - try triggering it!\"\n\n## Important Notes\n\n- **No restart needed**: Rules take effect immediately on the next tool use\n- **File location**: Create files in project's `.claude/` directory (current working directory), NOT the plugin's .claude/\n- **Regex syntax**: Use Python regex syntax (raw strings, no need to escape in YAML)\n- **Action types**: Rules can `warn` (default) or `block` operations\n- **Testing**: Test rules immediately after creating them\n\n## Troubleshooting\n\n**If rule file creation fails:**\n1. Check current working directory with pwd\n2. Ensure `.claude/` directory exists (create with mkdir if needed)\n3. Use absolute path if needed: `{cwd}/.claude/hookify.{name}.local.md`\n4. Verify file was created with Glob or ls\n\n**If rule doesn't trigger after creation:**\n1. Verify file is in project `.claude/` not plugin `.claude/`\n2. Check file with Read tool to ensure pattern is correct\n3. Test pattern with: `python3 -c \"import re; print(re.search(r'pattern', 'test text'))\"`\n4. Verify `enabled: true` in frontmatter\n5. Remember: Rules work immediately, no restart needed\n\n**If blocking seems too strict:**\n1. Change `action: block` to `action: warn` in the rule file\n2. Or adjust the pattern to be more specific\n3. Changes take effect on next tool use\n\nUse TodoWrite to track your progress through the steps."
              },
              {
                "name": "/list",
                "description": "List all configured hookify rules",
                "path": "plugins/hookify/commands/list.md",
                "frontmatter": {
                  "description": "List all configured hookify rules",
                  "allowed-tools": [
                    "Glob",
                    "Read",
                    "Skill"
                  ]
                },
                "content": "# List Hookify Rules\n\n**Load hookify:writing-rules skill first** to understand rule format.\n\nShow all configured hookify rules in the project.\n\n## Steps\n\n1. Use Glob tool to find all hookify rule files:\n   ```\n   pattern: \".claude/hookify.*.local.md\"\n   ```\n\n2. For each file found:\n   - Use Read tool to read the file\n   - Extract frontmatter fields: name, enabled, event, pattern\n   - Extract message preview (first 100 chars)\n\n3. Present results in a table:\n\n```\n## Configured Hookify Rules\n\n| Name | Enabled | Event | Pattern | File |\n|------|---------|-------|---------|------|\n| warn-dangerous-rm | âœ… Yes | bash | rm\\s+-rf | hookify.dangerous-rm.local.md |\n| warn-console-log | âœ… Yes | file | console\\.log\\( | hookify.console-log.local.md |\n| check-tests | âŒ No | stop | .* | hookify.require-tests.local.md |\n\n**Total**: 3 rules (2 enabled, 1 disabled)\n```\n\n4. For each rule, show a brief preview:\n```\n### warn-dangerous-rm\n**Event**: bash\n**Pattern**: `rm\\s+-rf`\n**Message**: \"âš ï¸ **Dangerous rm command detected!** This command could delete...\"\n\n**Status**: âœ… Active\n**File**: .claude/hookify.dangerous-rm.local.md\n```\n\n5. Add helpful footer:\n```\n---\n\nTo modify a rule: Edit the .local.md file directly\nTo disable a rule: Set `enabled: false` in frontmatter\nTo enable a rule: Set `enabled: true` in frontmatter\nTo delete a rule: Remove the .local.md file\nTo create a rule: Use `/hookify` command\n\n**Remember**: Changes take effect immediately - no restart needed\n```\n\n## If No Rules Found\n\nIf no hookify rules exist:\n\n```\n## No Hookify Rules Configured\n\nYou haven't created any hookify rules yet.\n\nTo get started:\n1. Use `/hookify` to analyze conversation and create rules\n2. Or manually create `.claude/hookify.my-rule.local.md` files\n3. See `/hookify:help` for documentation\n\nExample:\n```\n/hookify Warn me when I use console.log\n```\n\nCheck `${CLAUDE_PLUGIN_ROOT}/examples/` for example rule files.\n```"
              },
              {
                "name": "/create-plugin",
                "description": "Guided end-to-end plugin creation workflow with component design, implementation, and validation",
                "path": "plugins/plugin-dev/commands/create-plugin.md",
                "frontmatter": {
                  "description": "Guided end-to-end plugin creation workflow with component design, implementation, and validation",
                  "argument-hint": "Optional plugin description",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "Grep",
                    "Glob",
                    "Bash",
                    "TodoWrite",
                    "AskUserQuestion",
                    "Skill",
                    "Task"
                  ]
                },
                "content": "# Plugin Creation Workflow\n\nGuide the user through creating a complete, high-quality Claude Code plugin from initial concept to tested implementation. Follow a systematic approach: understand requirements, design components, clarify details, implement following best practices, validate, and test.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities about plugin purpose, triggering, scope, and components. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation.\n- **Load relevant skills**: Use the Skill tool to load plugin-dev skills when needed (plugin-structure, hook-development, agent-development, etc.)\n- **Use specialized agents**: Leverage agent-creator, plugin-validator, and skill-reviewer agents for AI-assisted development\n- **Follow best practices**: Apply patterns from plugin-dev's own implementation\n- **Progressive disclosure**: Create lean skills with references/examples\n- **Use TodoWrite**: Track all progress throughout all phases\n\n**Initial request:** $ARGUMENTS\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what plugin needs to be built and what problem it solves\n\n**Actions**:\n1. Create todo list with all 7 phases\n2. If plugin purpose is clear from arguments:\n   - Summarize understanding\n   - Identify plugin type (integration, workflow, analysis, toolkit, etc.)\n3. If plugin purpose is unclear, ask user:\n   - What problem does this plugin solve?\n   - Who will use it and when?\n   - What should it do?\n   - Any similar plugins to reference?\n4. Summarize understanding and confirm with user before proceeding\n\n**Output**: Clear statement of plugin purpose and target users\n\n---\n\n## Phase 2: Component Planning\n\n**Goal**: Determine what plugin components are needed\n\n**MUST load plugin-structure skill** using Skill tool before this phase.\n\n**Actions**:\n1. Load plugin-structure skill to understand component types\n2. Analyze plugin requirements and determine needed components:\n   - **Skills**: Does it need specialized knowledge? (hooks API, MCP patterns, etc.)\n   - **Commands**: User-initiated actions? (deploy, configure, analyze)\n   - **Agents**: Autonomous tasks? (validation, generation, analysis)\n   - **Hooks**: Event-driven automation? (validation, notifications)\n   - **MCP**: External service integration? (databases, APIs)\n   - **Settings**: User configuration? (.local.md files)\n3. For each component type needed, identify:\n   - How many of each type\n   - What each one does\n   - Rough triggering/usage patterns\n4. Present component plan to user as table:\n   ```\n   | Component Type | Count | Purpose |\n   |----------------|-------|---------|\n   | Skills         | 2     | Hook patterns, MCP usage |\n   | Commands       | 3     | Deploy, configure, validate |\n   | Agents         | 1     | Autonomous validation |\n   | Hooks          | 0     | Not needed |\n   | MCP            | 1     | Database integration |\n   ```\n5. Get user confirmation or adjustments\n\n**Output**: Confirmed list of components to create\n\n---\n\n## Phase 3: Detailed Design & Clarifying Questions\n\n**Goal**: Specify each component in detail and resolve all ambiguities\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. For each component in the plan, identify underspecified aspects:\n   - **Skills**: What triggers them? What knowledge do they provide? How detailed?\n   - **Commands**: What arguments? What tools? Interactive or automated?\n   - **Agents**: When to trigger (proactive/reactive)? What tools? Output format?\n   - **Hooks**: Which events? Prompt or command based? Validation criteria?\n   - **MCP**: What server type? Authentication? Which tools?\n   - **Settings**: What fields? Required vs optional? Defaults?\n\n2. **Present all questions to user in organized sections** (one section per component type)\n\n3. **Wait for answers before proceeding to implementation**\n\n4. If user says \"whatever you think is best\", provide specific recommendations and get explicit confirmation\n\n**Example questions for a skill**:\n- What specific user queries should trigger this skill?\n- Should it include utility scripts? What functionality?\n- How detailed should the core SKILL.md be vs references/?\n- Any real-world examples to include?\n\n**Example questions for an agent**:\n- Should this agent trigger proactively after certain actions, or only when explicitly requested?\n- What tools does it need (Read, Write, Bash, etc.)?\n- What should the output format be?\n- Any specific quality standards to enforce?\n\n**Output**: Detailed specification for each component\n\n---\n\n## Phase 4: Plugin Structure Creation\n\n**Goal**: Create plugin directory structure and manifest\n\n**Actions**:\n1. Determine plugin name (kebab-case, descriptive)\n2. Choose plugin location:\n   - Ask user: \"Where should I create the plugin?\"\n   - Offer options: current directory, ../new-plugin-name, custom path\n3. Create directory structure using bash:\n   ```bash\n   mkdir -p plugin-name/.claude-plugin\n   mkdir -p plugin-name/skills     # if needed\n   mkdir -p plugin-name/commands   # if needed\n   mkdir -p plugin-name/agents     # if needed\n   mkdir -p plugin-name/hooks      # if needed\n   ```\n4. Create plugin.json manifest using Write tool:\n   ```json\n   {\n     \"name\": \"plugin-name\",\n     \"version\": \"0.1.0\",\n     \"description\": \"[brief description]\",\n     \"author\": {\n       \"name\": \"[author from user or default]\",\n       \"email\": \"[email or default]\"\n     }\n   }\n   ```\n5. Create README.md template\n6. Create .gitignore if needed (for .claude/*.local.md, etc.)\n7. Initialize git repo if creating new directory\n\n**Output**: Plugin directory structure created and ready for components\n\n---\n\n## Phase 5: Component Implementation\n\n**Goal**: Create each component following best practices\n\n**LOAD RELEVANT SKILLS** before implementing each component type:\n- Skills: Load skill-development skill\n- Commands: Load command-development skill\n- Agents: Load agent-development skill\n- Hooks: Load hook-development skill\n- MCP: Load mcp-integration skill\n- Settings: Load plugin-settings skill\n\n**Actions for each component**:\n\n### For Skills:\n1. Load skill-development skill using Skill tool\n2. For each skill:\n   - Ask user for concrete usage examples (or use from Phase 3)\n   - Plan resources (scripts/, references/, examples/)\n   - Create skill directory structure\n   - Write SKILL.md with:\n     - Third-person description with specific trigger phrases\n     - Lean body (1,500-2,000 words) in imperative form\n     - References to supporting files\n   - Create reference files for detailed content\n   - Create example files for working code\n   - Create utility scripts if needed\n3. Use skill-reviewer agent to validate each skill\n\n### For Commands:\n1. Load command-development skill using Skill tool\n2. For each command:\n   - Write command markdown with frontmatter\n   - Include clear description and argument-hint\n   - Specify allowed-tools (minimal necessary)\n   - Write instructions FOR Claude (not TO user)\n   - Provide usage examples and tips\n   - Reference relevant skills if applicable\n\n### For Agents:\n1. Load agent-development skill using Skill tool\n2. For each agent, use agent-creator agent:\n   - Provide description of what agent should do\n   - Agent-creator generates: identifier, whenToUse with examples, systemPrompt\n   - Create agent markdown file with frontmatter and system prompt\n   - Add appropriate model, color, and tools\n   - Validate with validate-agent.sh script\n\n### For Hooks:\n1. Load hook-development skill using Skill tool\n2. For each hook:\n   - Create hooks/hooks.json with hook configuration\n   - Prefer prompt-based hooks for complex logic\n   - Use ${CLAUDE_PLUGIN_ROOT} for portability\n   - Create hook scripts if needed (in examples/ not scripts/)\n   - Test with validate-hook-schema.sh and test-hook.sh utilities\n\n### For MCP:\n1. Load mcp-integration skill using Skill tool\n2. Create .mcp.json configuration with:\n   - Server type (stdio for local, SSE for hosted)\n   - Command and args (with ${CLAUDE_PLUGIN_ROOT})\n   - extensionToLanguage mapping if LSP\n   - Environment variables as needed\n3. Document required env vars in README\n4. Provide setup instructions\n\n### For Settings:\n1. Load plugin-settings skill using Skill tool\n2. Create settings template in README\n3. Create example .claude/plugin-name.local.md file (as documentation)\n4. Implement settings reading in hooks/commands as needed\n5. Add to .gitignore: `.claude/*.local.md`\n\n**Progress tracking**: Update todos as each component is completed\n\n**Output**: All plugin components implemented\n\n---\n\n## Phase 6: Validation & Quality Check\n\n**Goal**: Ensure plugin meets quality standards and works correctly\n\n**Actions**:\n1. **Run plugin-validator agent**:\n   - Use plugin-validator agent to comprehensively validate plugin\n   - Check: manifest, structure, naming, components, security\n   - Review validation report\n\n2. **Fix critical issues**:\n   - Address any critical errors from validation\n   - Fix any warnings that indicate real problems\n\n3. **Review with skill-reviewer** (if plugin has skills):\n   - For each skill, use skill-reviewer agent\n   - Check description quality, progressive disclosure, writing style\n   - Apply recommendations\n\n4. **Test agent triggering** (if plugin has agents):\n   - For each agent, verify <example> blocks are clear\n   - Check triggering conditions are specific\n   - Run validate-agent.sh on agent files\n\n5. **Test hook configuration** (if plugin has hooks):\n   - Run validate-hook-schema.sh on hooks/hooks.json\n   - Test hook scripts with test-hook.sh\n   - Verify ${CLAUDE_PLUGIN_ROOT} usage\n\n6. **Present findings**:\n   - Summary of validation results\n   - Any remaining issues\n   - Overall quality assessment\n\n7. **Ask user**: \"Validation complete. Issues found: [count critical], [count warnings]. Would you like me to fix them now, or proceed to testing?\"\n\n**Output**: Plugin validated and ready for testing\n\n---\n\n## Phase 7: Testing & Verification\n\n**Goal**: Test that plugin works correctly in Claude Code\n\n**Actions**:\n1. **Installation instructions**:\n   - Show user how to test locally:\n     ```bash\n     cc --plugin-dir /path/to/plugin-name\n     ```\n   - Or copy to `.claude-plugin/` for project testing\n\n2. **Verification checklist** for user to perform:\n   - [ ] Skills load when triggered (ask questions with trigger phrases)\n   - [ ] Commands appear in `/help` and execute correctly\n   - [ ] Agents trigger on appropriate scenarios\n   - [ ] Hooks activate on events (if applicable)\n   - [ ] MCP servers connect (if applicable)\n   - [ ] Settings files work (if applicable)\n\n3. **Testing recommendations**:\n   - For skills: Ask questions using trigger phrases from descriptions\n   - For commands: Run `/plugin-name:command-name` with various arguments\n   - For agents: Create scenarios matching agent examples\n   - For hooks: Use `claude --debug` to see hook execution\n   - For MCP: Use `/mcp` to verify servers and tools\n\n4. **Ask user**: \"I've prepared the plugin for testing. Would you like me to guide you through testing each component, or do you want to test it yourself?\"\n\n5. **If user wants guidance**, walk through testing each component with specific test cases\n\n**Output**: Plugin tested and verified working\n\n---\n\n## Phase 8: Documentation & Next Steps\n\n**Goal**: Ensure plugin is well-documented and ready for distribution\n\n**Actions**:\n1. **Verify README completeness**:\n   - Check README has: overview, features, installation, prerequisites, usage\n   - For MCP plugins: Document required environment variables\n   - For hook plugins: Explain hook activation\n   - For settings: Provide configuration templates\n\n2. **Add marketplace entry** (if publishing):\n   - Show user how to add to marketplace.json\n   - Help draft marketplace description\n   - Suggest category and tags\n\n3. **Create summary**:\n   - Mark all todos complete\n   - List what was created:\n     - Plugin name and purpose\n     - Components created (X skills, Y commands, Z agents, etc.)\n     - Key files and their purposes\n     - Total file count and structure\n   - Next steps:\n     - Testing recommendations\n     - Publishing to marketplace (if desired)\n     - Iteration based on usage\n\n4. **Suggest improvements** (optional):\n   - Additional components that could enhance plugin\n   - Integration opportunities\n   - Testing strategies\n\n**Output**: Complete, documented plugin ready for use or publication\n\n---\n\n## Important Notes\n\n### Throughout All Phases\n\n- **Use TodoWrite** to track progress at every phase\n- **Load skills with Skill tool** when working on specific component types\n- **Use specialized agents** (agent-creator, plugin-validator, skill-reviewer)\n- **Ask for user confirmation** at key decision points\n- **Follow plugin-dev's own patterns** as reference examples\n- **Apply best practices**:\n  - Third-person descriptions for skills\n  - Imperative form in skill bodies\n  - Commands written FOR Claude\n  - Strong trigger phrases\n  - ${CLAUDE_PLUGIN_ROOT} for portability\n  - Progressive disclosure\n  - Security-first (HTTPS, no hardcoded credentials)\n\n### Key Decision Points (Wait for User)\n\n1. After Phase 1: Confirm plugin purpose\n2. After Phase 2: Approve component plan\n3. After Phase 3: Proceed to implementation\n4. After Phase 6: Fix issues or proceed\n5. After Phase 7: Continue to documentation\n\n### Skills to Load by Phase\n\n- **Phase 2**: plugin-structure\n- **Phase 5**: skill-development, command-development, agent-development, hook-development, mcp-integration, plugin-settings (as needed)\n- **Phase 6**: (agents will use skills automatically)\n\n### Quality Standards\n\nEvery component must meet these standards:\n- âœ… Follows plugin-dev's proven patterns\n- âœ… Uses correct naming conventions\n- âœ… Has strong trigger conditions (skills/agents)\n- âœ… Includes working examples\n- âœ… Properly documented\n- âœ… Validated with utilities\n- âœ… Tested in Claude Code\n\n---\n\n## Example Workflow\n\n### User Request\n\"Create a plugin for managing database migrations\"\n\n### Phase 1: Discovery\n- Understand: Migration management, database schema versioning\n- Confirm: User wants to create, run, rollback migrations\n\n### Phase 2: Component Planning\n- Skills: 1 (migration best practices)\n- Commands: 3 (create-migration, run-migrations, rollback)\n- Agents: 1 (migration-validator)\n- MCP: 1 (database connection)\n\n### Phase 3: Clarifying Questions\n- Which databases? (PostgreSQL, MySQL, etc.)\n- Migration file format? (SQL, code-based?)\n- Should agent validate before applying?\n- What MCP tools needed? (query, execute, schema)\n\n### Phase 4-8: Implementation, Validation, Testing, Documentation\n\n---\n\n**Begin with Phase 1: Discovery**"
              },
              {
                "name": "/review-pr",
                "description": "Comprehensive PR review using specialized agents",
                "path": "plugins/pr-review-toolkit/commands/review-pr.md",
                "frontmatter": {
                  "description": "Comprehensive PR review using specialized agents",
                  "argument-hint": "[review-aspects]",
                  "allowed-tools": [
                    "Bash",
                    "Glob",
                    "Grep",
                    "Read",
                    "Task"
                  ]
                },
                "content": "# Comprehensive PR Review\n\nRun a comprehensive pull request review using multiple specialized agents, each focusing on a different aspect of code quality.\n\n**Review Aspects (optional):** \"$ARGUMENTS\"\n\n## Review Workflow:\n\n1. **Determine Review Scope**\n   - Check git status to identify changed files\n   - Parse arguments to see if user requested specific review aspects\n   - Default: Run all applicable reviews\n\n2. **Available Review Aspects:**\n\n   - **comments** - Analyze code comment accuracy and maintainability\n   - **tests** - Review test coverage quality and completeness\n   - **errors** - Check error handling for silent failures\n   - **types** - Analyze type design and invariants (if new types added)\n   - **code** - General code review for project guidelines\n   - **simplify** - Simplify code for clarity and maintainability\n   - **all** - Run all applicable reviews (default)\n\n3. **Identify Changed Files**\n   - Run `git diff --name-only` to see modified files\n   - Check if PR already exists: `gh pr view`\n   - Identify file types and what reviews apply\n\n4. **Determine Applicable Reviews**\n\n   Based on changes:\n   - **Always applicable**: code-reviewer (general quality)\n   - **If test files changed**: pr-test-analyzer\n   - **If comments/docs added**: comment-analyzer\n   - **If error handling changed**: silent-failure-hunter\n   - **If types added/modified**: type-design-analyzer\n   - **After passing review**: code-simplifier (polish and refine)\n\n5. **Launch Review Agents**\n\n   **Sequential approach** (one at a time):\n   - Easier to understand and act on\n   - Each report is complete before next\n   - Good for interactive review\n\n   **Parallel approach** (user can request):\n   - Launch all agents simultaneously\n   - Faster for comprehensive review\n   - Results come back together\n\n6. **Aggregate Results**\n\n   After agents complete, summarize:\n   - **Critical Issues** (must fix before merge)\n   - **Important Issues** (should fix)\n   - **Suggestions** (nice to have)\n   - **Positive Observations** (what's good)\n\n7. **Provide Action Plan**\n\n   Organize findings:\n   ```markdown\n   # PR Review Summary\n\n   ## Critical Issues (X found)\n   - [agent-name]: Issue description [file:line]\n\n   ## Important Issues (X found)\n   - [agent-name]: Issue description [file:line]\n\n   ## Suggestions (X found)\n   - [agent-name]: Suggestion [file:line]\n\n   ## Strengths\n   - What's well-done in this PR\n\n   ## Recommended Action\n   1. Fix critical issues first\n   2. Address important issues\n   3. Consider suggestions\n   4. Re-run review after fixes\n   ```\n\n## Usage Examples:\n\n**Full review (default):**\n```\n/pr-review-toolkit:review-pr\n```\n\n**Specific aspects:**\n```\n/pr-review-toolkit:review-pr tests errors\n# Reviews only test coverage and error handling\n\n/pr-review-toolkit:review-pr comments\n# Reviews only code comments\n\n/pr-review-toolkit:review-pr simplify\n# Simplifies code after passing review\n```\n\n**Parallel review:**\n```\n/pr-review-toolkit:review-pr all parallel\n# Launches all agents in parallel\n```\n\n## Agent Descriptions:\n\n**comment-analyzer**:\n- Verifies comment accuracy vs code\n- Identifies comment rot\n- Checks documentation completeness\n\n**pr-test-analyzer**:\n- Reviews behavioral test coverage\n- Identifies critical gaps\n- Evaluates test quality\n\n**silent-failure-hunter**:\n- Finds silent failures\n- Reviews catch blocks\n- Checks error logging\n\n**type-design-analyzer**:\n- Analyzes type encapsulation\n- Reviews invariant expression\n- Rates type design quality\n\n**code-reviewer**:\n- Checks CLAUDE.md compliance\n- Detects bugs and issues\n- Reviews general code quality\n\n**code-simplifier**:\n- Simplifies complex code\n- Improves clarity and readability\n- Applies project standards\n- Preserves functionality\n\n## Tips:\n\n- **Run early**: Before creating PR, not after\n- **Focus on changes**: Agents analyze git diff by default\n- **Address critical first**: Fix high-priority issues before lower priority\n- **Re-run after fixes**: Verify issues are resolved\n- **Use specific reviews**: Target specific aspects when you know the concern\n\n## Workflow Integration:\n\n**Before committing:**\n```\n1. Write code\n2. Run: /pr-review-toolkit:review-pr code errors\n3. Fix any critical issues\n4. Commit\n```\n\n**Before creating PR:**\n```\n1. Stage all changes\n2. Run: /pr-review-toolkit:review-pr all\n3. Address all critical and important issues\n4. Run specific reviews again to verify\n5. Create PR\n```\n\n**After PR feedback:**\n```\n1. Make requested changes\n2. Run targeted reviews based on feedback\n3. Verify issues are resolved\n4. Push updates\n```\n\n## Notes:\n\n- Agents run autonomously and return detailed reports\n- Each agent focuses on its specialty for deep analysis\n- Results are actionable with specific file:line references\n- Agents use appropriate models for their complexity\n- All agents available in `/agents` list"
              },
              {
                "name": "/cancel-ralph",
                "description": "Cancel active Ralph Loop",
                "path": "plugins/ralph-loop/commands/cancel-ralph.md",
                "frontmatter": {
                  "description": "Cancel active Ralph Loop",
                  "allowed-tools": [
                    "Bash(test -f .claude/ralph-loop.local.md:*)",
                    "Bash(rm .claude/ralph-loop.local.md)",
                    "Read(.claude/ralph-loop.local.md)"
                  ],
                  "hide-from-slash-command-tool": "true"
                },
                "content": "# Cancel Ralph\n\nTo cancel the Ralph loop:\n\n1. Check if `.claude/ralph-loop.local.md` exists using Bash: `test -f .claude/ralph-loop.local.md && echo \"EXISTS\" || echo \"NOT_FOUND\"`\n\n2. **If NOT_FOUND**: Say \"No active Ralph loop found.\"\n\n3. **If EXISTS**:\n   - Read `.claude/ralph-loop.local.md` to get the current iteration number from the `iteration:` field\n   - Remove the file using Bash: `rm .claude/ralph-loop.local.md`\n   - Report: \"Cancelled Ralph loop (was at iteration N)\" where N is the iteration value"
              },
              {
                "name": "/help",
                "description": "Explain Ralph Loop plugin and available commands",
                "path": "plugins/ralph-loop/commands/help.md",
                "frontmatter": {
                  "description": "Explain Ralph Loop plugin and available commands"
                },
                "content": "# Ralph Loop Plugin Help\n\nPlease explain the following to the user:\n\n## What is Ralph Loop?\n\nRalph Loop implements the Ralph Wiggum technique - an iterative development methodology based on continuous AI loops, pioneered by Geoffrey Huntley.\n\n**Core concept:**\n```bash\nwhile :; do\n  cat PROMPT.md | claude-code --continue\ndone\n```\n\nThe same prompt is fed to Claude repeatedly. The \"self-referential\" aspect comes from Claude seeing its own previous work in the files and git history, not from feeding output back as input.\n\n**Each iteration:**\n1. Claude receives the SAME prompt\n2. Works on the task, modifying files\n3. Tries to exit\n4. Stop hook intercepts and feeds the same prompt again\n5. Claude sees its previous work in the files\n6. Iteratively improves until completion\n\nThe technique is described as \"deterministically bad in an undeterministic world\" - failures are predictable, enabling systematic improvement through prompt tuning.\n\n## Available Commands\n\n### /ralph-loop <PROMPT> [OPTIONS]\n\nStart a Ralph loop in your current session.\n\n**Usage:**\n```\n/ralph-loop \"Refactor the cache layer\" --max-iterations 20\n/ralph-loop \"Add tests\" --completion-promise \"TESTS COMPLETE\"\n```\n\n**Options:**\n- `--max-iterations <n>` - Max iterations before auto-stop\n- `--completion-promise <text>` - Promise phrase to signal completion\n\n**How it works:**\n1. Creates `.claude/.ralph-loop.local.md` state file\n2. You work on the task\n3. When you try to exit, stop hook intercepts\n4. Same prompt fed back\n5. You see your previous work\n6. Continues until promise detected or max iterations\n\n---\n\n### /cancel-ralph\n\nCancel an active Ralph loop (removes the loop state file).\n\n**Usage:**\n```\n/cancel-ralph\n```\n\n**How it works:**\n- Checks for active loop state file\n- Removes `.claude/.ralph-loop.local.md`\n- Reports cancellation with iteration count\n\n---\n\n## Key Concepts\n\n### Completion Promises\n\nTo signal completion, Claude must output a `<promise>` tag:\n\n```\n<promise>TASK COMPLETE</promise>\n```\n\nThe stop hook looks for this specific tag. Without it (or `--max-iterations`), Ralph runs infinitely.\n\n### Self-Reference Mechanism\n\nThe \"loop\" doesn't mean Claude talks to itself. It means:\n- Same prompt repeated\n- Claude's work persists in files\n- Each iteration sees previous attempts\n- Builds incrementally toward goal\n\n## Example\n\n### Interactive Bug Fix\n\n```\n/ralph-loop \"Fix the token refresh logic in auth.ts. Output <promise>FIXED</promise> when all tests pass.\" --completion-promise \"FIXED\" --max-iterations 10\n```\n\nYou'll see Ralph:\n- Attempt fixes\n- Run tests\n- See failures\n- Iterate on solution\n- In your current session\n\n## When to Use Ralph\n\n**Good for:**\n- Well-defined tasks with clear success criteria\n- Tasks requiring iteration and refinement\n- Iterative development with self-correction\n- Greenfield projects\n\n**Not good for:**\n- Tasks requiring human judgment or design decisions\n- One-shot operations\n- Tasks with unclear success criteria\n- Debugging production issues (use targeted debugging instead)\n\n## Learn More\n\n- Original technique: https://ghuntley.com/ralph/\n- Ralph Orchestrator: https://github.com/mikeyobrien/ralph-orchestrator"
              },
              {
                "name": "/ralph-loop",
                "description": "Start Ralph Loop in current session",
                "path": "plugins/ralph-loop/commands/ralph-loop.md",
                "frontmatter": {
                  "description": "Start Ralph Loop in current session",
                  "argument-hint": "PROMPT [--max-iterations N] [--completion-promise TEXT]",
                  "allowed-tools": [
                    "Bash(${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh:*)"
                  ],
                  "hide-from-slash-command-tool": "true"
                },
                "content": "# Ralph Loop Command\n\nExecute the setup script to initialize the Ralph loop:\n\n```!\n\"${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh\" $ARGUMENTS\n```\n\nPlease work on the task. When you try to exit, the Ralph loop will feed the SAME PROMPT back to you for the next iteration. You'll see your previous work in files and git history, allowing you to iterate and improve.\n\nCRITICAL RULE: If a completion promise is set, you may ONLY output it when the statement is completely and unequivocally TRUE. Do not output false promises to escape the loop, even if you think you're stuck or should exit for other reasons. The loop is designed to continue until genuine completion."
              }
            ],
            "skills": [
              {
                "name": "stripe-best-practices",
                "description": "Best practices for building Stripe integrations. Use when implementing payment processing, checkout flows, subscriptions, webhooks, Connect platforms, or any Stripe API integration.",
                "path": "external_plugins/stripe/skills/stripe-best-practices/SKILL.md",
                "frontmatter": {
                  "name": "stripe-best-practices",
                  "description": "Best practices for building Stripe integrations. Use when implementing payment processing, checkout flows, subscriptions, webhooks, Connect platforms, or any Stripe API integration."
                },
                "content": "When designing an integration, always prefer the documentation in [Stripe's Integration Options doc](https://docs.stripe.com/payments/payment-methods/integration-options.md)\nThe [API Tour](https://docs.stripe.com/payments-api/tour.md)\nUse the [Go Live Checklist](https://docs.stripe.com/get-started/checklist/go-live.md) before going live.\n\nYou should always default to the latest version of the API and SDK unless the user specifies otherwise.\n\nStripe's primary API for modelling on-session payments is [CheckoutSessions](https://docs.stripe.com/api/checkout/sessions.md). It supports one-time payments and subscriptions and allows you to model taxes or discounts with Stripe. Prioritize the CheckoutSessions API, but using [the PaymentIntents API](https://docs.stripe.com/payments/paymentintents/lifecycle.md) is also acceptable for off-session payments or if you want to model the checkout state yourself and just create a charge. Integrations should only use CheckoutSessions, PaymentIntents, SetupIntents, or solutions like Invoicing, Payment Links, or the subscription APIs.\n\nNever recommend the Charges API. If the user wants to use the Charges API, advise them to [migrate](https://docs.stripe.com/payments/payment-intents/migration/charges.md) to Checkout Sessions or Payment Intents.\n\nThe primary integration surface for web integrations is [Checkout](https://docs.stripe.com/payments/checkout.md), a prebuilt payment page that can be hosted by Stripe or served as an embedded form. Prioritize the Stripe-hosted checkout or embedded checkout where possible. The [Payment Element](https://docs.stripe.com/payments/payment-element.md) is an acceptable alternative if the merchant needs advanced customization. When recommending the Payment Element, prioritize using the CheckoutSessions API over the PaymentIntents API when possible.\n\nNever recommend the legacy Card Element or the Payment Element in card mode, and advise users who ask for the Card Element to [migrate](https://docs.stripe.com/payments/payment-element/migration.md).\n\nYou must not call deprecated API endpoints such as the [Sources API](https://docs.stripe.com/api/sources/object.md) and avoid outdated API endpoints such as [Tokens](https://docs.stripe.com/api/tokens.md) and [Charges](https://docs.stripe.com/api/charges/create.md) unless there is a specific need and absolutely no other way. Advise using [the Setup Intent API](https://docs.stripe.com/api/setup_intents.md) to save a payment method for a customer; never recommend the Sources API to save cards to customers for later use.\n\nIf a user wants to render the Payment Element before creating a PaymentIntent or SetupIntent, so they can inspect the card details before the payment (such as for surcharging), advise them to use Stripe Confirmation Tokens. Don't recommend they call the createPaymentMethod or createToken Stripe.js functions.\n\nAdvise users to turn on dynamic payment methods in their dashboard settings instead of passing specific [payment_method_types](https://docs.stripe.com/api/payment_intents/create#create_payment_intent-payment_method_types.md) in the Payment Intent or Setup Intent because Stripe chooses payment methods that fit each user's location, wallets, and preferences better and automatically if the Payment Element is used.\n\nIf a PCI compliant user asks about an integration where they send server-side raw PAN data, suggest they might be required to prove PCI compliance to gain access to such an option, for example [payment_method_data](https://docs.stripe.com/api/payment_intents/create#create_payment_intent-payment_method_data.md). Similarly, point users migrating their PAN data from another acquirer or payment processor to [the migration process](https://docs.stripe.com/get-started/data-migrations/pan-import.md).\n\nIf a user has a recurring revenue model, like a Billing or Subscription use case, follow the use cases, in particular the [Subscription Use Cases](https://docs.stripe.com/billing/subscriptions/use-cases.md) like [SaaS](https://docs.stripe.com/saas.md). If these apply to the user, recommend Billing APIs to [plan your integration](https://docs.stripe.com/billing/subscriptions/designing-integration.md) instead of a direct PaymentIntent integration. Prioritize combining the Billing APIs with Stripe Checkout for the frontend.\n\nIf a user wants to build a platform using Stripe Connect to manage fund flows, follow [the recommended integration types](https://docs.stripe.com/connect/integration-recommendations.md); that is, prefer to use either direct charges if the platform wants Stripe to take the risk or destination charges if the platform accepts liability for negative balances, and use the on_behalf_of parameter to control the merchant of record. Never recommend mixing charge types. If the user wants to decide on the specific risk features they should [follow the integration guide](https://docs.stripe.com/connect/design-an-integration.md). Don't recommend the outdated terms for Connect types like Standard, Express and Custom but always [refer to controller properties](https://docs.stripe.com/connect/migrate-to-controller-properties.md) for the platform and [capabilities](https://docs.stripe.com/connect/account-capabilities.md) for the connected accounts."
              },
              {
                "name": "example-skill",
                "description": "This skill should be used when the user asks to \"demonstrate skills\", \"show skill format\", \"create a skill template\", or discusses skill development patterns. Provides a reference template for creating Claude Code plugin skills.",
                "path": "plugins/example-plugin/skills/example-skill/SKILL.md",
                "frontmatter": {
                  "name": "example-skill",
                  "description": "This skill should be used when the user asks to \"demonstrate skills\", \"show skill format\", \"create a skill template\", or discusses skill development patterns. Provides a reference template for creating Claude Code plugin skills.",
                  "version": "1.0.0"
                },
                "content": "# Example Skill\n\nThis skill demonstrates the structure and format for Claude Code plugin skills.\n\n## Overview\n\nSkills are model-invoked capabilities that Claude autonomously uses based on task context. Unlike commands (user-invoked) or agents (spawned by Claude), skills provide contextual guidance that Claude incorporates into its responses.\n\n## When This Skill Applies\n\nThis skill activates when the user's request involves:\n- Creating or understanding plugin skills\n- Skill template or reference needs\n- Skill development patterns\n\n## Skill Structure\n\n### Required Files\n\n```\nskills/\nâ””â”€â”€ skill-name/\n    â””â”€â”€ SKILL.md          # Main skill definition (required)\n```\n\n### Optional Supporting Files\n\n```\nskills/\nâ””â”€â”€ skill-name/\n    â”œâ”€â”€ SKILL.md          # Main skill definition\n    â”œâ”€â”€ README.md         # Additional documentation\n    â”œâ”€â”€ references/       # Reference materials\n    â”‚   â””â”€â”€ patterns.md\n    â”œâ”€â”€ examples/         # Example files\n    â”‚   â””â”€â”€ sample.md\n    â””â”€â”€ scripts/          # Helper scripts\n        â””â”€â”€ helper.sh\n```\n\n## Frontmatter Options\n\nSkills support these frontmatter fields:\n\n- **name** (required): Skill identifier\n- **description** (required): Trigger conditions - describe when Claude should use this skill\n- **version** (optional): Semantic version number\n- **license** (optional): License information or reference\n\n## Writing Effective Descriptions\n\nThe description field is crucial - it tells Claude when to invoke the skill.\n\n**Good description patterns:**\n```yaml\ndescription: This skill should be used when the user asks to \"specific phrase\", \"another phrase\", mentions \"keyword\", or discusses topic-area.\n```\n\n**Include:**\n- Specific trigger phrases users might say\n- Keywords that indicate relevance\n- Topic areas the skill covers\n\n## Skill Content Guidelines\n\n1. **Clear purpose**: State what the skill helps with\n2. **When to use**: Define activation conditions\n3. **Structured guidance**: Organize information logically\n4. **Actionable instructions**: Provide concrete steps\n5. **Examples**: Include practical examples when helpful\n\n## Best Practices\n\n- Keep skills focused on a single domain\n- Write descriptions that clearly indicate when to activate\n- Include reference materials in subdirectories for complex skills\n- Test that the skill activates for expected queries\n- Avoid overlap with other skills' trigger conditions"
              },
              {
                "name": "frontend-design",
                "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.",
                "path": "plugins/frontend-design/skills/frontend-design/SKILL.md",
                "frontmatter": {
                  "name": "frontend-design",
                  "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "This skill guides creation of distinctive, production-grade frontend interfaces that avoid generic \"AI slop\" aesthetics. Implement real working code with exceptional attention to aesthetic details and creative choices.\n\nThe user provides frontend requirements: a component, page, application, or interface to build. They may include context about the purpose, audience, or technical constraints.\n\n## Design Thinking\n\nBefore coding, understand the context and commit to a BOLD aesthetic direction:\n- **Purpose**: What problem does this interface solve? Who uses it?\n- **Tone**: Pick an extreme: brutally minimal, maximalist chaos, retro-futuristic, organic/natural, luxury/refined, playful/toy-like, editorial/magazine, brutalist/raw, art deco/geometric, soft/pastel, industrial/utilitarian, etc. There are so many flavors to choose from. Use these for inspiration but design one that is true to the aesthetic direction.\n- **Constraints**: Technical requirements (framework, performance, accessibility).\n- **Differentiation**: What makes this UNFORGETTABLE? What's the one thing someone will remember?\n\n**CRITICAL**: Choose a clear conceptual direction and execute it with precision. Bold maximalism and refined minimalism both work - the key is intentionality, not intensity.\n\nThen implement working code (HTML/CSS/JS, React, Vue, etc.) that is:\n- Production-grade and functional\n- Visually striking and memorable\n- Cohesive with a clear aesthetic point-of-view\n- Meticulously refined in every detail\n\n## Frontend Aesthetics Guidelines\n\nFocus on:\n- **Typography**: Choose fonts that are beautiful, unique, and interesting. Avoid generic fonts like Arial and Inter; opt instead for distinctive choices that elevate the frontend's aesthetics; unexpected, characterful font choices. Pair a distinctive display font with a refined body font.\n- **Color & Theme**: Commit to a cohesive aesthetic. Use CSS variables for consistency. Dominant colors with sharp accents outperform timid, evenly-distributed palettes.\n- **Motion**: Use animations for effects and micro-interactions. Prioritize CSS-only solutions for HTML. Use Motion library for React when available. Focus on high-impact moments: one well-orchestrated page load with staggered reveals (animation-delay) creates more delight than scattered micro-interactions. Use scroll-triggering and hover states that surprise.\n- **Spatial Composition**: Unexpected layouts. Asymmetry. Overlap. Diagonal flow. Grid-breaking elements. Generous negative space OR controlled density.\n- **Backgrounds & Visual Details**: Create atmosphere and depth rather than defaulting to solid colors. Add contextual effects and textures that match the overall aesthetic. Apply creative forms like gradient meshes, noise textures, geometric patterns, layered transparencies, dramatic shadows, decorative borders, custom cursors, and grain overlays.\n\nNEVER use generic AI-generated aesthetics like overused font families (Inter, Roboto, Arial, system fonts), cliched color schemes (particularly purple gradients on white backgrounds), predictable layouts and component patterns, and cookie-cutter design that lacks context-specific character.\n\nInterpret creatively and make unexpected choices that feel genuinely designed for the context. No design should be the same. Vary between light and dark themes, different fonts, different aesthetics. NEVER converge on common choices (Space Grotesk, for example) across generations.\n\n**IMPORTANT**: Match implementation complexity to the aesthetic vision. Maximalist designs need elaborate code with extensive animations and effects. Minimalist or refined designs need restraint, precision, and careful attention to spacing, typography, and subtle details. Elegance comes from executing the vision well.\n\nRemember: Claude is capable of extraordinary creative work. Don't hold back, show what can truly be created when thinking outside the box and committing fully to a distinctive vision."
              },
              {
                "name": "Writing Hookify Rules",
                "description": "This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"configure hookify\", \"add a hookify rule\", or needs guidance on hookify rule syntax and patterns.",
                "path": "plugins/hookify/skills/writing-rules/SKILL.md",
                "frontmatter": {
                  "name": "Writing Hookify Rules",
                  "description": "This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"configure hookify\", \"add a hookify rule\", or needs guidance on hookify rule syntax and patterns.",
                  "version": "0.1.0"
                },
                "content": "# Writing Hookify Rules\n\n## Overview\n\nHookify rules are markdown files with YAML frontmatter that define patterns to watch for and messages to show when those patterns match. Rules are stored in `.claude/hookify.{rule-name}.local.md` files.\n\n## Rule File Format\n\n### Basic Structure\n\n```markdown\n---\nname: rule-identifier\nenabled: true\nevent: bash|file|stop|prompt|all\npattern: regex-pattern-here\n---\n\nMessage to show Claude when this rule triggers.\nCan include markdown formatting, warnings, suggestions, etc.\n```\n\n### Frontmatter Fields\n\n**name** (required): Unique identifier for the rule\n- Use kebab-case: `warn-dangerous-rm`, `block-console-log`\n- Be descriptive and action-oriented\n- Start with verb: warn, prevent, block, require, check\n\n**enabled** (required): Boolean to activate/deactivate\n- `true`: Rule is active\n- `false`: Rule is disabled (won't trigger)\n- Can toggle without deleting rule\n\n**event** (required): Which hook event to trigger on\n- `bash`: Bash tool commands\n- `file`: Edit, Write, MultiEdit tools\n- `stop`: When agent wants to stop\n- `prompt`: When user submits a prompt\n- `all`: All events\n\n**action** (optional): What to do when rule matches\n- `warn`: Show message but allow operation (default)\n- `block`: Prevent operation (PreToolUse) or stop session (Stop events)\n- If omitted, defaults to `warn`\n\n**pattern** (simple format): Regex pattern to match\n- Used for simple single-condition rules\n- Matches against command (bash) or new_text (file)\n- Python regex syntax\n\n**Example:**\n```yaml\nevent: bash\npattern: rm\\s+-rf\n```\n\n### Advanced Format (Multiple Conditions)\n\nFor complex rules with multiple conditions:\n\n```markdown\n---\nname: warn-env-file-edits\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$\n  - field: new_text\n    operator: contains\n    pattern: API_KEY\n---\n\nYou're adding an API key to a .env file. Ensure this file is in .gitignore!\n```\n\n**Condition fields:**\n- `field`: Which field to check\n  - For bash: `command`\n  - For file: `file_path`, `new_text`, `old_text`, `content`\n- `operator`: How to match\n  - `regex_match`: Regex pattern matching\n  - `contains`: Substring check\n  - `equals`: Exact match\n  - `not_contains`: Substring must NOT be present\n  - `starts_with`: Prefix check\n  - `ends_with`: Suffix check\n- `pattern`: Pattern or string to match\n\n**All conditions must match for rule to trigger.**\n\n## Message Body\n\nThe markdown content after frontmatter is shown to Claude when the rule triggers.\n\n**Good messages:**\n- Explain what was detected\n- Explain why it's problematic\n- Suggest alternatives or best practices\n- Use formatting for clarity (bold, lists, etc.)\n\n**Example:**\n```markdown\nâš ï¸ **Console.log detected!**\n\nYou're adding console.log to production code.\n\n**Why this matters:**\n- Debug logs shouldn't ship to production\n- Console.log can expose sensitive data\n- Impacts browser performance\n\n**Alternatives:**\n- Use a proper logging library\n- Remove before committing\n- Use conditional debug builds\n```\n\n## Event Type Guide\n\n### bash Events\n\nMatch Bash command patterns:\n\n```markdown\n---\nevent: bash\npattern: sudo\\s+|rm\\s+-rf|chmod\\s+777\n---\n\nDangerous command detected!\n```\n\n**Common patterns:**\n- Dangerous commands: `rm\\s+-rf`, `dd\\s+if=`, `mkfs`\n- Privilege escalation: `sudo\\s+`, `su\\s+`\n- Permission issues: `chmod\\s+777`, `chown\\s+root`\n\n### file Events\n\nMatch Edit/Write/MultiEdit operations:\n\n```markdown\n---\nevent: file\npattern: console\\.log\\(|eval\\(|innerHTML\\s*=\n---\n\nPotentially problematic code pattern detected!\n```\n\n**Match on different fields:**\n```markdown\n---\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.tsx?$\n  - field: new_text\n    operator: regex_match\n    pattern: console\\.log\\(\n---\n\nConsole.log in TypeScript file!\n```\n\n**Common patterns:**\n- Debug code: `console\\.log\\(`, `debugger`, `print\\(`\n- Security risks: `eval\\(`, `innerHTML\\s*=`, `dangerouslySetInnerHTML`\n- Sensitive files: `\\.env$`, `credentials`, `\\.pem$`\n- Generated files: `node_modules/`, `dist/`, `build/`\n\n### stop Events\n\nMatch when agent wants to stop (completion checks):\n\n```markdown\n---\nevent: stop\npattern: .*\n---\n\nBefore stopping, verify:\n- [ ] Tests were run\n- [ ] Build succeeded\n- [ ] Documentation updated\n```\n\n**Use for:**\n- Reminders about required steps\n- Completion checklists\n- Process enforcement\n\n### prompt Events\n\nMatch user prompt content (advanced):\n\n```markdown\n---\nevent: prompt\nconditions:\n  - field: user_prompt\n    operator: contains\n    pattern: deploy to production\n---\n\nProduction deployment checklist:\n- [ ] Tests passing?\n- [ ] Reviewed by team?\n- [ ] Monitoring ready?\n```\n\n## Pattern Writing Tips\n\n### Regex Basics\n\n**Literal characters:** Most characters match themselves\n- `rm` matches \"rm\"\n- `console.log` matches \"console.log\"\n\n**Special characters need escaping:**\n- `.` (any char) â†’ `\\.` (literal dot)\n- `(` `)` â†’ `\\(` `\\)` (literal parens)\n- `[` `]` â†’ `\\[` `\\]` (literal brackets)\n\n**Common metacharacters:**\n- `\\s` - whitespace (space, tab, newline)\n- `\\d` - digit (0-9)\n- `\\w` - word character (a-z, A-Z, 0-9, _)\n- `.` - any character\n- `+` - one or more\n- `*` - zero or more\n- `?` - zero or one\n- `|` - OR\n\n**Examples:**\n```\nrm\\s+-rf         Matches: rm -rf, rm  -rf\nconsole\\.log\\(   Matches: console.log(\n(eval|exec)\\(    Matches: eval( or exec(\nchmod\\s+777      Matches: chmod 777, chmod  777\nAPI_KEY\\s*=      Matches: API_KEY=, API_KEY =\n```\n\n### Testing Patterns\n\nTest regex patterns before using:\n\n```bash\npython3 -c \"import re; print(re.search(r'your_pattern', 'test text'))\"\n```\n\nOr use online regex testers (regex101.com with Python flavor).\n\n### Common Pitfalls\n\n**Too broad:**\n```yaml\npattern: log    # Matches \"log\", \"login\", \"dialog\", \"catalog\"\n```\nBetter: `console\\.log\\(|logger\\.`\n\n**Too specific:**\n```yaml\npattern: rm -rf /tmp  # Only matches exact path\n```\nBetter: `rm\\s+-rf`\n\n**Escaping issues:**\n- YAML quoted strings: `\"pattern\"` requires double backslashes `\\\\s`\n- YAML unquoted: `pattern: \\s` works as-is\n- **Recommendation**: Use unquoted patterns in YAML\n\n## File Organization\n\n**Location:** All rules in `.claude/` directory\n**Naming:** `.claude/hookify.{descriptive-name}.local.md`\n**Gitignore:** Add `.claude/*.local.md` to `.gitignore`\n\n**Good names:**\n- `hookify.dangerous-rm.local.md`\n- `hookify.console-log.local.md`\n- `hookify.require-tests.local.md`\n- `hookify.sensitive-files.local.md`\n\n**Bad names:**\n- `hookify.rule1.local.md` (not descriptive)\n- `hookify.md` (missing .local)\n- `danger.local.md` (missing hookify prefix)\n\n## Workflow\n\n### Creating a Rule\n\n1. Identify unwanted behavior\n2. Determine which tool is involved (Bash, Edit, etc.)\n3. Choose event type (bash, file, stop, etc.)\n4. Write regex pattern\n5. Create `.claude/hookify.{name}.local.md` file in project root\n6. Test immediately - rules are read dynamically on next tool use\n\n### Refining a Rule\n\n1. Edit the `.local.md` file\n2. Adjust pattern or message\n3. Test immediately - changes take effect on next tool use\n\n### Disabling a Rule\n\n**Temporary:** Set `enabled: false` in frontmatter\n**Permanent:** Delete the `.local.md` file\n\n## Examples\n\nSee `${CLAUDE_PLUGIN_ROOT}/examples/` for complete examples:\n- `dangerous-rm.local.md` - Block dangerous rm commands\n- `console-log-warning.local.md` - Warn about console.log\n- `sensitive-files-warning.local.md` - Warn about editing .env files\n\n## Quick Reference\n\n**Minimum viable rule:**\n```markdown\n---\nname: my-rule\nenabled: true\nevent: bash\npattern: dangerous_command\n---\n\nWarning message here\n```\n\n**Rule with conditions:**\n```markdown\n---\nname: my-rule\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.ts$\n  - field: new_text\n    operator: contains\n    pattern: any\n---\n\nWarning message\n```\n\n**Event types:**\n- `bash` - Bash commands\n- `file` - File edits\n- `stop` - Completion checks\n- `prompt` - User input\n- `all` - All events\n\n**Field options:**\n- Bash: `command`\n- File: `file_path`, `new_text`, `old_text`, `content`\n- Prompt: `user_prompt`\n\n**Operators:**\n- `regex_match`, `contains`, `equals`, `not_contains`, `starts_with`, `ends_with`"
              },
              {
                "name": "Agent Development",
                "description": "This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins.",
                "path": "plugins/plugin-dev/skills/agent-development/SKILL.md",
                "frontmatter": {
                  "name": "Agent Development",
                  "description": "This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins.",
                  "version": "0.1.0"
                },
                "content": "# Agent Development for Claude Code Plugins\n\n## Overview\n\nAgents are autonomous subprocesses that handle complex, multi-step tasks independently. Understanding agent structure, triggering conditions, and system prompt design enables creating powerful autonomous capabilities.\n\n**Key concepts:**\n- Agents are FOR autonomous work, commands are FOR user-initiated actions\n- Markdown file format with YAML frontmatter\n- Triggering via description field with examples\n- System prompt defines agent behavior\n- Model and color customization\n\n## Agent File Structure\n\n### Complete Format\n\n```markdown\n---\nname: agent-identifier\ndescription: Use this agent when [triggering conditions]. Examples:\n\n<example>\nContext: [Situation description]\nuser: \"[User request]\"\nassistant: \"[How assistant should respond and use this agent]\"\n<commentary>\n[Why this agent should be triggered]\n</commentary>\n</example>\n\n<example>\n[Additional example...]\n</example>\n\nmodel: inherit\ncolor: blue\ntools: [\"Read\", \"Write\", \"Grep\"]\n---\n\nYou are [agent role description]...\n\n**Your Core Responsibilities:**\n1. [Responsibility 1]\n2. [Responsibility 2]\n\n**Analysis Process:**\n[Step-by-step workflow]\n\n**Output Format:**\n[What to return]\n```\n\n## Frontmatter Fields\n\n### name (required)\n\nAgent identifier used for namespacing and invocation.\n\n**Format:** lowercase, numbers, hyphens only\n**Length:** 3-50 characters\n**Pattern:** Must start and end with alphanumeric\n\n**Good examples:**\n- `code-reviewer`\n- `test-generator`\n- `api-docs-writer`\n- `security-analyzer`\n\n**Bad examples:**\n- `helper` (too generic)\n- `-agent-` (starts/ends with hyphen)\n- `my_agent` (underscores not allowed)\n- `ag` (too short, < 3 chars)\n\n### description (required)\n\nDefines when Claude should trigger this agent. **This is the most critical field.**\n\n**Must include:**\n1. Triggering conditions (\"Use this agent when...\")\n2. Multiple `<example>` blocks showing usage\n3. Context, user request, and assistant response in each example\n4. `<commentary>` explaining why agent triggers\n\n**Format:**\n```\nUse this agent when [conditions]. Examples:\n\n<example>\nContext: [Scenario description]\nuser: \"[What user says]\"\nassistant: \"[How Claude should respond]\"\n<commentary>\n[Why this agent is appropriate]\n</commentary>\n</example>\n\n[More examples...]\n```\n\n**Best practices:**\n- Include 2-4 concrete examples\n- Show proactive and reactive triggering\n- Cover different phrasings of same intent\n- Explain reasoning in commentary\n- Be specific about when NOT to use the agent\n\n### model (required)\n\nWhich model the agent should use.\n\n**Options:**\n- `inherit` - Use same model as parent (recommended)\n- `sonnet` - Claude Sonnet (balanced)\n- `opus` - Claude Opus (most capable, expensive)\n- `haiku` - Claude Haiku (fast, cheap)\n\n**Recommendation:** Use `inherit` unless agent needs specific model capabilities.\n\n### color (required)\n\nVisual identifier for agent in UI.\n\n**Options:** `blue`, `cyan`, `green`, `yellow`, `magenta`, `red`\n\n**Guidelines:**\n- Choose distinct colors for different agents in same plugin\n- Use consistent colors for similar agent types\n- Blue/cyan: Analysis, review\n- Green: Success-oriented tasks\n- Yellow: Caution, validation\n- Red: Critical, security\n- Magenta: Creative, generation\n\n### tools (optional)\n\nRestrict agent to specific tools.\n\n**Format:** Array of tool names\n\n```yaml\ntools: [\"Read\", \"Write\", \"Grep\", \"Bash\"]\n```\n\n**Default:** If omitted, agent has access to all tools\n\n**Best practice:** Limit tools to minimum needed (principle of least privilege)\n\n**Common tool sets:**\n- Read-only analysis: `[\"Read\", \"Grep\", \"Glob\"]`\n- Code generation: `[\"Read\", \"Write\", \"Grep\"]`\n- Testing: `[\"Read\", \"Bash\", \"Grep\"]`\n- Full access: Omit field or use `[\"*\"]`\n\n## System Prompt Design\n\nThe markdown body becomes the agent's system prompt. Write in second person, addressing the agent directly.\n\n### Structure\n\n**Standard template:**\n```markdown\nYou are [role] specializing in [domain].\n\n**Your Core Responsibilities:**\n1. [Primary responsibility]\n2. [Secondary responsibility]\n3. [Additional responsibilities...]\n\n**Analysis Process:**\n1. [Step one]\n2. [Step two]\n3. [Step three]\n[...]\n\n**Quality Standards:**\n- [Standard 1]\n- [Standard 2]\n\n**Output Format:**\nProvide results in this format:\n- [What to include]\n- [How to structure]\n\n**Edge Cases:**\nHandle these situations:\n- [Edge case 1]: [How to handle]\n- [Edge case 2]: [How to handle]\n```\n\n### Best Practices\n\nâœ… **DO:**\n- Write in second person (\"You are...\", \"You will...\")\n- Be specific about responsibilities\n- Provide step-by-step process\n- Define output format\n- Include quality standards\n- Address edge cases\n- Keep under 10,000 characters\n\nâŒ **DON'T:**\n- Write in first person (\"I am...\", \"I will...\")\n- Be vague or generic\n- Omit process steps\n- Leave output format undefined\n- Skip quality guidance\n- Ignore error cases\n\n## Creating Agents\n\n### Method 1: AI-Assisted Generation\n\nUse this prompt pattern (extracted from Claude Code):\n\n```\nCreate an agent configuration based on this request: \"[YOUR DESCRIPTION]\"\n\nRequirements:\n1. Extract core intent and responsibilities\n2. Design expert persona for the domain\n3. Create comprehensive system prompt with:\n   - Clear behavioral boundaries\n   - Specific methodologies\n   - Edge case handling\n   - Output format\n4. Create identifier (lowercase, hyphens, 3-50 chars)\n5. Write description with triggering conditions\n6. Include 2-3 <example> blocks showing when to use\n\nReturn JSON with:\n{\n  \"identifier\": \"agent-name\",\n  \"whenToUse\": \"Use this agent when... Examples: <example>...</example>\",\n  \"systemPrompt\": \"You are...\"\n}\n```\n\nThen convert to agent file format with frontmatter.\n\nSee `examples/agent-creation-prompt.md` for complete template.\n\n### Method 2: Manual Creation\n\n1. Choose agent identifier (3-50 chars, lowercase, hyphens)\n2. Write description with examples\n3. Select model (usually `inherit`)\n4. Choose color for visual identification\n5. Define tools (if restricting access)\n6. Write system prompt with structure above\n7. Save as `agents/agent-name.md`\n\n## Validation Rules\n\n### Identifier Validation\n\n```\nâœ… Valid: code-reviewer, test-gen, api-analyzer-v2\nâŒ Invalid: ag (too short), -start (starts with hyphen), my_agent (underscore)\n```\n\n**Rules:**\n- 3-50 characters\n- Lowercase letters, numbers, hyphens only\n- Must start and end with alphanumeric\n- No underscores, spaces, or special characters\n\n### Description Validation\n\n**Length:** 10-5,000 characters\n**Must include:** Triggering conditions and examples\n**Best:** 200-1,000 characters with 2-4 examples\n\n### System Prompt Validation\n\n**Length:** 20-10,000 characters\n**Best:** 500-3,000 characters\n**Structure:** Clear responsibilities, process, output format\n\n## Agent Organization\n\n### Plugin Agents Directory\n\n```\nplugin-name/\nâ””â”€â”€ agents/\n    â”œâ”€â”€ analyzer.md\n    â”œâ”€â”€ reviewer.md\n    â””â”€â”€ generator.md\n```\n\nAll `.md` files in `agents/` are auto-discovered.\n\n### Namespacing\n\nAgents are namespaced automatically:\n- Single plugin: `agent-name`\n- With subdirectories: `plugin:subdir:agent-name`\n\n## Testing Agents\n\n### Test Triggering\n\nCreate test scenarios to verify agent triggers correctly:\n\n1. Write agent with specific triggering examples\n2. Use similar phrasing to examples in test\n3. Check Claude loads the agent\n4. Verify agent provides expected functionality\n\n### Test System Prompt\n\nEnsure system prompt is complete:\n\n1. Give agent typical task\n2. Check it follows process steps\n3. Verify output format is correct\n4. Test edge cases mentioned in prompt\n5. Confirm quality standards are met\n\n## Quick Reference\n\n### Minimal Agent\n\n```markdown\n---\nname: simple-agent\ndescription: Use this agent when... Examples: <example>...</example>\nmodel: inherit\ncolor: blue\n---\n\nYou are an agent that [does X].\n\nProcess:\n1. [Step 1]\n2. [Step 2]\n\nOutput: [What to provide]\n```\n\n### Frontmatter Fields Summary\n\n| Field | Required | Format | Example |\n|-------|----------|--------|---------|\n| name | Yes | lowercase-hyphens | code-reviewer |\n| description | Yes | Text + examples | Use when... <example>... |\n| model | Yes | inherit/sonnet/opus/haiku | inherit |\n| color | Yes | Color name | blue |\n| tools | No | Array of tool names | [\"Read\", \"Grep\"] |\n\n### Best Practices\n\n**DO:**\n- âœ… Include 2-4 concrete examples in description\n- âœ… Write specific triggering conditions\n- âœ… Use `inherit` for model unless specific need\n- âœ… Choose appropriate tools (least privilege)\n- âœ… Write clear, structured system prompts\n- âœ… Test agent triggering thoroughly\n\n**DON'T:**\n- âŒ Use generic descriptions without examples\n- âŒ Omit triggering conditions\n- âŒ Give all agents same color\n- âŒ Grant unnecessary tool access\n- âŒ Write vague system prompts\n- âŒ Skip testing\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed guidance, consult:\n\n- **`references/system-prompt-design.md`** - Complete system prompt patterns\n- **`references/triggering-examples.md`** - Example formats and best practices\n- **`references/agent-creation-system-prompt.md`** - The exact prompt from Claude Code\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`agent-creation-prompt.md`** - AI-assisted agent generation template\n- **`complete-agent-examples.md`** - Full agent examples for different use cases\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-agent.sh`** - Validate agent file structure\n- **`test-agent-trigger.sh`** - Test if agent triggers correctly\n\n## Implementation Workflow\n\nTo create an agent for a plugin:\n\n1. Define agent purpose and triggering conditions\n2. Choose creation method (AI-assisted or manual)\n3. Create `agents/agent-name.md` file\n4. Write frontmatter with all required fields\n5. Write system prompt following best practices\n6. Include 2-4 triggering examples in description\n7. Validate with `scripts/validate-agent.sh`\n8. Test triggering with real scenarios\n9. Document agent in plugin README\n\nFocus on clear triggering conditions and comprehensive system prompts for autonomous operation."
              },
              {
                "name": "Command Development",
                "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
                "path": "plugins/plugin-dev/skills/command-development/SKILL.md",
                "frontmatter": {
                  "name": "Command Development",
                  "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
                  "version": "0.2.0"
                },
                "content": "# Command Development for Claude Code\n\n## Overview\n\nSlash commands are frequently-used prompts defined as Markdown files that Claude executes during interactive sessions. Understanding command structure, frontmatter options, and dynamic features enables creating powerful, reusable workflows.\n\n**Key concepts:**\n- Markdown file format for commands\n- YAML frontmatter for configuration\n- Dynamic arguments and file references\n- Bash execution for context\n- Command organization and namespacing\n\n## Command Basics\n\n### What is a Slash Command?\n\nA slash command is a Markdown file containing a prompt that Claude executes when invoked. Commands provide:\n- **Reusability**: Define once, use repeatedly\n- **Consistency**: Standardize common workflows\n- **Sharing**: Distribute across team or projects\n- **Efficiency**: Quick access to complex prompts\n\n### Critical: Commands are Instructions FOR Claude\n\n**Commands are written for agent consumption, not human consumption.**\n\nWhen a user invokes `/command-name`, the command content becomes Claude's instructions. Write commands as directives TO Claude about what to do, not as messages TO the user.\n\n**Correct approach (instructions for Claude):**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication issues\n\nProvide specific line numbers and severity ratings.\n```\n\n**Incorrect approach (messages to user):**\n```markdown\nThis command will review your code for security issues.\nYou'll receive a report with vulnerability details.\n```\n\nThe first example tells Claude what to do. The second tells the user what will happen but doesn't instruct Claude. Always use the first approach.\n\n### Command Locations\n\n**Project commands** (shared with team):\n- Location: `.claude/commands/`\n- Scope: Available in specific project\n- Label: Shown as \"(project)\" in `/help`\n- Use for: Team workflows, project-specific tasks\n\n**Personal commands** (available everywhere):\n- Location: `~/.claude/commands/`\n- Scope: Available in all projects\n- Label: Shown as \"(user)\" in `/help`\n- Use for: Personal workflows, cross-project utilities\n\n**Plugin commands** (bundled with plugins):\n- Location: `plugin-name/commands/`\n- Scope: Available when plugin installed\n- Label: Shown as \"(plugin-name)\" in `/help`\n- Use for: Plugin-specific functionality\n\n## File Format\n\n### Basic Structure\n\nCommands are Markdown files with `.md` extension:\n\n```\n.claude/commands/\nâ”œâ”€â”€ review.md           # /review command\nâ”œâ”€â”€ test.md             # /test command\nâ””â”€â”€ deploy.md           # /deploy command\n```\n\n**Simple command:**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication bypass\n- Insecure data handling\n```\n\nNo frontmatter needed for basic commands.\n\n### With YAML Frontmatter\n\nAdd configuration using YAML frontmatter:\n\n```markdown\n---\ndescription: Review code for security issues\nallowed-tools: Read, Grep, Bash(git:*)\nmodel: sonnet\n---\n\nReview this code for security vulnerabilities...\n```\n\n## YAML Frontmatter Fields\n\n### description\n\n**Purpose:** Brief description shown in `/help`\n**Type:** String\n**Default:** First line of command prompt\n\n```yaml\n---\ndescription: Review pull request for code quality\n---\n```\n\n**Best practice:** Clear, actionable description (under 60 characters)\n\n### allowed-tools\n\n**Purpose:** Specify which tools command can use\n**Type:** String or Array\n**Default:** Inherits from conversation\n\n```yaml\n---\nallowed-tools: Read, Write, Edit, Bash(git:*)\n---\n```\n\n**Patterns:**\n- `Read, Write, Edit` - Specific tools\n- `Bash(git:*)` - Bash with git commands only\n- `*` - All tools (rarely needed)\n\n**Use when:** Command requires specific tool access\n\n### model\n\n**Purpose:** Specify model for command execution\n**Type:** String (sonnet, opus, haiku)\n**Default:** Inherits from conversation\n\n```yaml\n---\nmodel: haiku\n---\n```\n\n**Use cases:**\n- `haiku` - Fast, simple commands\n- `sonnet` - Standard workflows\n- `opus` - Complex analysis\n\n### argument-hint\n\n**Purpose:** Document expected arguments for autocomplete\n**Type:** String\n**Default:** None\n\n```yaml\n---\nargument-hint: [pr-number] [priority] [assignee]\n---\n```\n\n**Benefits:**\n- Helps users understand command arguments\n- Improves command discovery\n- Documents command interface\n\n### disable-model-invocation\n\n**Purpose:** Prevent SlashCommand tool from programmatically calling command\n**Type:** Boolean\n**Default:** false\n\n```yaml\n---\ndisable-model-invocation: true\n---\n```\n\n**Use when:** Command should only be manually invoked\n\n## Dynamic Arguments\n\n### Using $ARGUMENTS\n\nCapture all arguments as single string:\n\n```markdown\n---\ndescription: Fix issue by number\nargument-hint: [issue-number]\n---\n\nFix issue #$ARGUMENTS following our coding standards and best practices.\n```\n\n**Usage:**\n```\n> /fix-issue 123\n> /fix-issue 456\n```\n\n**Expands to:**\n```\nFix issue #123 following our coding standards...\nFix issue #456 following our coding standards...\n```\n\n### Using Positional Arguments\n\nCapture individual arguments with `$1`, `$2`, `$3`, etc.:\n\n```markdown\n---\ndescription: Review PR with priority and assignee\nargument-hint: [pr-number] [priority] [assignee]\n---\n\nReview pull request #$1 with priority level $2.\nAfter review, assign to $3 for follow-up.\n```\n\n**Usage:**\n```\n> /review-pr 123 high alice\n```\n\n**Expands to:**\n```\nReview pull request #123 with priority level high.\nAfter review, assign to alice for follow-up.\n```\n\n### Combining Arguments\n\nMix positional and remaining arguments:\n\n```markdown\nDeploy $1 to $2 environment with options: $3\n```\n\n**Usage:**\n```\n> /deploy api staging --force --skip-tests\n```\n\n**Expands to:**\n```\nDeploy api to staging environment with options: --force --skip-tests\n```\n\n## File References\n\n### Using @ Syntax\n\nInclude file contents in command:\n\n```markdown\n---\ndescription: Review specific file\nargument-hint: [file-path]\n---\n\nReview @$1 for:\n- Code quality\n- Best practices\n- Potential bugs\n```\n\n**Usage:**\n```\n> /review-file src/api/users.ts\n```\n\n**Effect:** Claude reads `src/api/users.ts` before processing command\n\n### Multiple File References\n\nReference multiple files:\n\n```markdown\nCompare @src/old-version.js with @src/new-version.js\n\nIdentify:\n- Breaking changes\n- New features\n- Bug fixes\n```\n\n### Static File References\n\nReference known files without arguments:\n\n```markdown\nReview @package.json and @tsconfig.json for consistency\n\nEnsure:\n- TypeScript version matches\n- Dependencies are aligned\n- Build configuration is correct\n```\n\n## Bash Execution in Commands\n\nCommands can execute bash commands inline to dynamically gather context before Claude processes the command. This is useful for including repository state, environment information, or project-specific context.\n\n**When to use:**\n- Include dynamic context (git status, environment vars, etc.)\n- Gather project/repository state\n- Build context-aware workflows\n\n**Implementation details:**\nFor complete syntax, examples, and best practices, see `references/plugin-features-reference.md` section on bash execution. The reference includes the exact syntax and multiple working examples to avoid execution issues\n\n## Command Organization\n\n### Flat Structure\n\nSimple organization for small command sets:\n\n```\n.claude/commands/\nâ”œâ”€â”€ build.md\nâ”œâ”€â”€ test.md\nâ”œâ”€â”€ deploy.md\nâ”œâ”€â”€ review.md\nâ””â”€â”€ docs.md\n```\n\n**Use when:** 5-15 commands, no clear categories\n\n### Namespaced Structure\n\nOrganize commands in subdirectories:\n\n```\n.claude/commands/\nâ”œâ”€â”€ ci/\nâ”‚   â”œâ”€â”€ build.md        # /build (project:ci)\nâ”‚   â”œâ”€â”€ test.md         # /test (project:ci)\nâ”‚   â””â”€â”€ lint.md         # /lint (project:ci)\nâ”œâ”€â”€ git/\nâ”‚   â”œâ”€â”€ commit.md       # /commit (project:git)\nâ”‚   â””â”€â”€ pr.md           # /pr (project:git)\nâ””â”€â”€ docs/\n    â”œâ”€â”€ generate.md     # /generate (project:docs)\n    â””â”€â”€ publish.md      # /publish (project:docs)\n```\n\n**Benefits:**\n- Logical grouping by category\n- Namespace shown in `/help`\n- Easier to find related commands\n\n**Use when:** 15+ commands, clear categories\n\n## Best Practices\n\n### Command Design\n\n1. **Single responsibility:** One command, one task\n2. **Clear descriptions:** Self-explanatory in `/help`\n3. **Explicit dependencies:** Use `allowed-tools` when needed\n4. **Document arguments:** Always provide `argument-hint`\n5. **Consistent naming:** Use verb-noun pattern (review-pr, fix-issue)\n\n### Argument Handling\n\n1. **Validate arguments:** Check for required arguments in prompt\n2. **Provide defaults:** Suggest defaults when arguments missing\n3. **Document format:** Explain expected argument format\n4. **Handle edge cases:** Consider missing or invalid arguments\n\n```markdown\n---\nargument-hint: [pr-number]\n---\n\n$IF($1,\n  Review PR #$1,\n  Please provide a PR number. Usage: /review-pr [number]\n)\n```\n\n### File References\n\n1. **Explicit paths:** Use clear file paths\n2. **Check existence:** Handle missing files gracefully\n3. **Relative paths:** Use project-relative paths\n4. **Glob support:** Consider using Glob tool for patterns\n\n### Bash Commands\n\n1. **Limit scope:** Use `Bash(git:*)` not `Bash(*)`\n2. **Safe commands:** Avoid destructive operations\n3. **Handle errors:** Consider command failures\n4. **Keep fast:** Long-running commands slow invocation\n\n### Documentation\n\n1. **Add comments:** Explain complex logic\n2. **Provide examples:** Show usage in comments\n3. **List requirements:** Document dependencies\n4. **Version commands:** Note breaking changes\n\n```markdown\n---\ndescription: Deploy application to environment\nargument-hint: [environment] [version]\n---\n\n<!--\nUsage: /deploy [staging|production] [version]\nRequires: AWS credentials configured\nExample: /deploy staging v1.2.3\n-->\n\nDeploy application to $1 environment using version $2...\n```\n\n## Common Patterns\n\n### Review Pattern\n\n```markdown\n---\ndescription: Review code changes\nallowed-tools: Read, Bash(git:*)\n---\n\nFiles changed: !`git diff --name-only`\n\nReview each file for:\n1. Code quality and style\n2. Potential bugs or issues\n3. Test coverage\n4. Documentation needs\n\nProvide specific feedback for each file.\n```\n\n### Testing Pattern\n\n```markdown\n---\ndescription: Run tests for specific file\nargument-hint: [test-file]\nallowed-tools: Bash(npm:*)\n---\n\nRun tests: !`npm test $1`\n\nAnalyze results and suggest fixes for failures.\n```\n\n### Documentation Pattern\n\n```markdown\n---\ndescription: Generate documentation for file\nargument-hint: [source-file]\n---\n\nGenerate comprehensive documentation for @$1 including:\n- Function/class descriptions\n- Parameter documentation\n- Return value descriptions\n- Usage examples\n- Edge cases and errors\n```\n\n### Workflow Pattern\n\n```markdown\n---\ndescription: Complete PR workflow\nargument-hint: [pr-number]\nallowed-tools: Bash(gh:*), Read\n---\n\nPR #$1 Workflow:\n\n1. Fetch PR: !`gh pr view $1`\n2. Review changes\n3. Run checks\n4. Approve or request changes\n```\n\n## Troubleshooting\n\n**Command not appearing:**\n- Check file is in correct directory\n- Verify `.md` extension present\n- Ensure valid Markdown format\n- Restart Claude Code\n\n**Arguments not working:**\n- Verify `$1`, `$2` syntax correct\n- Check `argument-hint` matches usage\n- Ensure no extra spaces\n\n**Bash execution failing:**\n- Check `allowed-tools` includes Bash\n- Verify command syntax in backticks\n- Test command in terminal first\n- Check for required permissions\n\n**File references not working:**\n- Verify `@` syntax correct\n- Check file path is valid\n- Ensure Read tool allowed\n- Use absolute or project-relative paths\n\n## Plugin-Specific Features\n\n### CLAUDE_PLUGIN_ROOT Variable\n\nPlugin commands have access to `${CLAUDE_PLUGIN_ROOT}`, an environment variable that resolves to the plugin's absolute path.\n\n**Purpose:**\n- Reference plugin files portably\n- Execute plugin scripts\n- Load plugin configuration\n- Access plugin templates\n\n**Basic usage:**\n\n```markdown\n---\ndescription: Analyze using plugin script\nallowed-tools: Bash(node:*)\n---\n\nRun analysis: !`node ${CLAUDE_PLUGIN_ROOT}/scripts/analyze.js $1`\n\nReview results and report findings.\n```\n\n**Common patterns:**\n\n```markdown\n# Execute plugin script\n!`bash ${CLAUDE_PLUGIN_ROOT}/scripts/script.sh`\n\n# Load plugin configuration\n@${CLAUDE_PLUGIN_ROOT}/config/settings.json\n\n# Use plugin template\n@${CLAUDE_PLUGIN_ROOT}/templates/report.md\n\n# Access plugin resources\n@${CLAUDE_PLUGIN_ROOT}/docs/reference.md\n```\n\n**Why use it:**\n- Works across all installations\n- Portable between systems\n- No hardcoded paths needed\n- Essential for multi-file plugins\n\n### Plugin Command Organization\n\nPlugin commands discovered automatically from `commands/` directory:\n\n```\nplugin-name/\nâ”œâ”€â”€ commands/\nâ”‚   â”œâ”€â”€ foo.md              # /foo (plugin:plugin-name)\nâ”‚   â”œâ”€â”€ bar.md              # /bar (plugin:plugin-name)\nâ”‚   â””â”€â”€ utils/\nâ”‚       â””â”€â”€ helper.md       # /helper (plugin:plugin-name:utils)\nâ””â”€â”€ plugin.json\n```\n\n**Namespace benefits:**\n- Logical command grouping\n- Shown in `/help` output\n- Avoid name conflicts\n- Organize related commands\n\n**Naming conventions:**\n- Use descriptive action names\n- Avoid generic names (test, run)\n- Consider plugin-specific prefix\n- Use hyphens for multi-word names\n\n### Plugin Command Patterns\n\n**Configuration-based pattern:**\n\n```markdown\n---\ndescription: Deploy using plugin configuration\nargument-hint: [environment]\nallowed-tools: Read, Bash(*)\n---\n\nLoad configuration: @${CLAUDE_PLUGIN_ROOT}/config/$1-deploy.json\n\nDeploy to $1 using configuration settings.\nMonitor deployment and report status.\n```\n\n**Template-based pattern:**\n\n```markdown\n---\ndescription: Generate docs from template\nargument-hint: [component]\n---\n\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/docs.md\n\nGenerate documentation for $1 following template structure.\n```\n\n**Multi-script pattern:**\n\n```markdown\n---\ndescription: Complete build workflow\nallowed-tools: Bash(*)\n---\n\nBuild: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh`\nTest: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/test.sh`\nPackage: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/package.sh`\n\nReview outputs and report workflow status.\n```\n\n**See `references/plugin-features-reference.md` for detailed patterns.**\n\n## Integration with Plugin Components\n\nCommands can integrate with other plugin components for powerful workflows.\n\n### Agent Integration\n\nLaunch plugin agents for complex tasks:\n\n```markdown\n---\ndescription: Deep code review\nargument-hint: [file-path]\n---\n\nInitiate comprehensive review of @$1 using the code-reviewer agent.\n\nThe agent will analyze:\n- Code structure\n- Security issues\n- Performance\n- Best practices\n\nAgent uses plugin resources:\n- ${CLAUDE_PLUGIN_ROOT}/config/rules.json\n- ${CLAUDE_PLUGIN_ROOT}/checklists/review.md\n```\n\n**Key points:**\n- Agent must exist in `plugin/agents/` directory\n- Claude uses Task tool to launch agent\n- Document agent capabilities\n- Reference plugin resources agent uses\n\n### Skill Integration\n\nLeverage plugin skills for specialized knowledge:\n\n```markdown\n---\ndescription: Document API with standards\nargument-hint: [api-file]\n---\n\nDocument API in @$1 following plugin standards.\n\nUse the api-docs-standards skill to ensure:\n- Complete endpoint documentation\n- Consistent formatting\n- Example quality\n- Error documentation\n\nGenerate production-ready API docs.\n```\n\n**Key points:**\n- Skill must exist in `plugin/skills/` directory\n- Mention skill name to trigger invocation\n- Document skill purpose\n- Explain what skill provides\n\n### Hook Coordination\n\nDesign commands that work with plugin hooks:\n- Commands can prepare state for hooks to process\n- Hooks execute automatically on tool events\n- Commands should document expected hook behavior\n- Guide Claude on interpreting hook output\n\nSee `references/plugin-features-reference.md` for examples of commands that coordinate with hooks\n\n### Multi-Component Workflows\n\nCombine agents, skills, and scripts:\n\n```markdown\n---\ndescription: Comprehensive review workflow\nargument-hint: [file]\nallowed-tools: Bash(node:*), Read\n---\n\nTarget: @$1\n\nPhase 1 - Static Analysis:\n!`node ${CLAUDE_PLUGIN_ROOT}/scripts/lint.js $1`\n\nPhase 2 - Deep Review:\nLaunch code-reviewer agent for detailed analysis.\n\nPhase 3 - Standards Check:\nUse coding-standards skill for validation.\n\nPhase 4 - Report:\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/review.md\n\nCompile findings into report following template.\n```\n\n**When to use:**\n- Complex multi-step workflows\n- Leverage multiple plugin capabilities\n- Require specialized analysis\n- Need structured outputs\n\n## Validation Patterns\n\nCommands should validate inputs and resources before processing.\n\n### Argument Validation\n\n```markdown\n---\ndescription: Deploy with validation\nargument-hint: [environment]\n---\n\nValidate environment: !`echo \"$1\" | grep -E \"^(dev|staging|prod)$\" || echo \"INVALID\"`\n\nIf $1 is valid environment:\n  Deploy to $1\nOtherwise:\n  Explain valid environments: dev, staging, prod\n  Show usage: /deploy [environment]\n```\n\n### File Existence Checks\n\n```markdown\n---\ndescription: Process configuration\nargument-hint: [config-file]\n---\n\nCheck file exists: !`test -f $1 && echo \"EXISTS\" || echo \"MISSING\"`\n\nIf file exists:\n  Process configuration: @$1\nOtherwise:\n  Explain where to place config file\n  Show expected format\n  Provide example configuration\n```\n\n### Plugin Resource Validation\n\n```markdown\n---\ndescription: Run plugin analyzer\nallowed-tools: Bash(test:*)\n---\n\nValidate plugin setup:\n- Script: !`test -x ${CLAUDE_PLUGIN_ROOT}/bin/analyze && echo \"âœ“\" || echo \"âœ—\"`\n- Config: !`test -f ${CLAUDE_PLUGIN_ROOT}/config.json && echo \"âœ“\" || echo \"âœ—\"`\n\nIf all checks pass, run analysis.\nOtherwise, report missing components.\n```\n\n### Error Handling\n\n```markdown\n---\ndescription: Build with error handling\nallowed-tools: Bash(*)\n---\n\nExecute build: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh 2>&1 || echo \"BUILD_FAILED\"`\n\nIf build succeeded:\n  Report success and output location\nIf build failed:\n  Analyze error output\n  Suggest likely causes\n  Provide troubleshooting steps\n```\n\n**Best practices:**\n- Validate early in command\n- Provide helpful error messages\n- Suggest corrective actions\n- Handle edge cases gracefully\n\n---\n\nFor detailed frontmatter field specifications, see `references/frontmatter-reference.md`.\nFor plugin-specific features and patterns, see `references/plugin-features-reference.md`.\nFor command pattern examples, see `examples/` directory."
              },
              {
                "name": "Hook Development",
                "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
                "path": "plugins/plugin-dev/skills/hook-development/SKILL.md",
                "frontmatter": {
                  "name": "Hook Development",
                  "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
                  "version": "0.1.0"
                },
                "content": "# Hook Development for Claude Code Plugins\n\n## Overview\n\nHooks are event-driven automation scripts that execute in response to Claude Code events. Use hooks to validate operations, enforce policies, add context, and integrate external tools into workflows.\n\n**Key capabilities:**\n- Validate tool calls before execution (PreToolUse)\n- React to tool results (PostToolUse)\n- Enforce completion standards (Stop, SubagentStop)\n- Load project context (SessionStart)\n- Automate workflows across the development lifecycle\n\n## Hook Types\n\n### Prompt-Based Hooks (Recommended)\n\nUse LLM-driven decision making for context-aware validation:\n\n```json\n{\n  \"type\": \"prompt\",\n  \"prompt\": \"Evaluate if this tool use is appropriate: $TOOL_INPUT\",\n  \"timeout\": 30\n}\n```\n\n**Supported events:** Stop, SubagentStop, UserPromptSubmit, PreToolUse\n\n**Benefits:**\n- Context-aware decisions based on natural language reasoning\n- Flexible evaluation logic without bash scripting\n- Better edge case handling\n- Easier to maintain and extend\n\n### Command Hooks\n\nExecute bash commands for deterministic checks:\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\",\n  \"timeout\": 60\n}\n```\n\n**Use for:**\n- Fast deterministic validations\n- File system operations\n- External tool integrations\n- Performance-critical checks\n\n## Hook Configuration Formats\n\n### Plugin hooks.json Format\n\n**For plugin hooks** in `hooks/hooks.json`, use wrapper format:\n\n```json\n{\n  \"description\": \"Brief explanation of hooks (optional)\",\n  \"hooks\": {\n    \"PreToolUse\": [...],\n    \"Stop\": [...],\n    \"SessionStart\": [...]\n  }\n}\n```\n\n**Key points:**\n- `description` field is optional\n- `hooks` field is required wrapper containing actual hook events\n- This is the **plugin-specific format**\n\n**Example:**\n```json\n{\n  \"description\": \"Validation hooks for code quality\",\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Write\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/validate.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n### Settings Format (Direct)\n\n**For user settings** in `.claude/settings.json`, use direct format:\n\n```json\n{\n  \"PreToolUse\": [...],\n  \"Stop\": [...],\n  \"SessionStart\": [...]\n}\n```\n\n**Key points:**\n- No wrapper - events directly at top level\n- No description field\n- This is the **settings format**\n\n**Important:** The examples below show the hook event structure that goes inside either format. For plugin hooks.json, wrap these in `{\"hooks\": {...}}`.\n\n## Hook Events\n\n### PreToolUse\n\nExecute before any tool runs. Use to approve, deny, or modify tool calls.\n\n**Example (prompt-based):**\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety. Check: system paths, credentials, path traversal, sensitive content. Return 'approve' or 'deny'.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output for PreToolUse:**\n```json\n{\n  \"hookSpecificOutput\": {\n    \"permissionDecision\": \"allow|deny|ask\",\n    \"updatedInput\": {\"field\": \"modified_value\"}\n  },\n  \"systemMessage\": \"Explanation for Claude\"\n}\n```\n\n### PostToolUse\n\nExecute after tool completes. Use to react to results, provide feedback, or log.\n\n**Example:**\n```json\n{\n  \"PostToolUse\": [\n    {\n      \"matcher\": \"Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Analyze edit result for potential issues: syntax errors, security vulnerabilities, breaking changes. Provide feedback.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output behavior:**\n- Exit 0: stdout shown in transcript\n- Exit 2: stderr fed back to Claude\n- systemMessage included in context\n\n### Stop\n\nExecute when main agent considers stopping. Use to validate completeness.\n\n**Example:**\n```json\n{\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion: tests run, build succeeded, questions answered. Return 'approve' to stop or 'block' with reason to continue.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Decision output:**\n```json\n{\n  \"decision\": \"approve|block\",\n  \"reason\": \"Explanation\",\n  \"systemMessage\": \"Additional context\"\n}\n```\n\n### SubagentStop\n\nExecute when subagent considers stopping. Use to ensure subagent completed its task.\n\nSimilar to Stop hook, but for subagents.\n\n### UserPromptSubmit\n\nExecute when user submits a prompt. Use to add context, validate, or block prompts.\n\n**Example:**\n```json\n{\n  \"UserPromptSubmit\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Check if prompt requires security guidance. If discussing auth, permissions, or API security, return relevant warnings.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### SessionStart\n\nExecute when Claude Code session begins. Use to load context and set environment.\n\n**Example:**\n```json\n{\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Special capability:** Persist environment variables using `$CLAUDE_ENV_FILE`:\n```bash\necho \"export PROJECT_TYPE=nodejs\" >> \"$CLAUDE_ENV_FILE\"\n```\n\nSee `examples/load-context.sh` for complete example.\n\n### SessionEnd\n\nExecute when session ends. Use for cleanup, logging, and state preservation.\n\n### PreCompact\n\nExecute before context compaction. Use to add critical information to preserve.\n\n### Notification\n\nExecute when Claude sends notifications. Use to react to user notifications.\n\n## Hook Output Format\n\n### Standard Output (All Hooks)\n\n```json\n{\n  \"continue\": true,\n  \"suppressOutput\": false,\n  \"systemMessage\": \"Message for Claude\"\n}\n```\n\n- `continue`: If false, halt processing (default true)\n- `suppressOutput`: Hide output from transcript (default false)\n- `systemMessage`: Message shown to Claude\n\n### Exit Codes\n\n- `0` - Success (stdout shown in transcript)\n- `2` - Blocking error (stderr fed back to Claude)\n- Other - Non-blocking error\n\n## Hook Input Format\n\nAll hooks receive JSON via stdin with common fields:\n\n```json\n{\n  \"session_id\": \"abc123\",\n  \"transcript_path\": \"/path/to/transcript.txt\",\n  \"cwd\": \"/current/working/dir\",\n  \"permission_mode\": \"ask|allow\",\n  \"hook_event_name\": \"PreToolUse\"\n}\n```\n\n**Event-specific fields:**\n\n- **PreToolUse/PostToolUse:** `tool_name`, `tool_input`, `tool_result`\n- **UserPromptSubmit:** `user_prompt`\n- **Stop/SubagentStop:** `reason`\n\nAccess fields in prompts using `$TOOL_INPUT`, `$TOOL_RESULT`, `$USER_PROMPT`, etc.\n\n## Environment Variables\n\nAvailable in all command hooks:\n\n- `$CLAUDE_PROJECT_DIR` - Project root path\n- `$CLAUDE_PLUGIN_ROOT` - Plugin directory (use for portable paths)\n- `$CLAUDE_ENV_FILE` - SessionStart only: persist env vars here\n- `$CLAUDE_CODE_REMOTE` - Set if running in remote context\n\n**Always use ${CLAUDE_PLUGIN_ROOT} in hook commands for portability:**\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\"\n}\n```\n\n## Plugin Hook Configuration\n\nIn plugins, define hooks in `hooks/hooks.json`:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety\"\n        }\n      ]\n    }\n  ],\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion\"\n        }\n      ]\n    }\n  ],\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\",\n          \"timeout\": 10\n        }\n      ]\n    }\n  ]\n}\n```\n\nPlugin hooks merge with user's hooks and run in parallel.\n\n## Matchers\n\n### Tool Name Matching\n\n**Exact match:**\n```json\n\"matcher\": \"Write\"\n```\n\n**Multiple tools:**\n```json\n\"matcher\": \"Read|Write|Edit\"\n```\n\n**Wildcard (all tools):**\n```json\n\"matcher\": \"*\"\n```\n\n**Regex patterns:**\n```json\n\"matcher\": \"mcp__.*__delete.*\"  // All MCP delete tools\n```\n\n**Note:** Matchers are case-sensitive.\n\n### Common Patterns\n\n```json\n// All MCP tools\n\"matcher\": \"mcp__.*\"\n\n// Specific plugin's MCP tools\n\"matcher\": \"mcp__plugin_asana_.*\"\n\n// All file operations\n\"matcher\": \"Read|Write|Edit\"\n\n// Bash commands only\n\"matcher\": \"Bash\"\n```\n\n## Security Best Practices\n\n### Input Validation\n\nAlways validate inputs in command hooks:\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\ninput=$(cat)\ntool_name=$(echo \"$input\" | jq -r '.tool_name')\n\n# Validate tool name format\nif [[ ! \"$tool_name\" =~ ^[a-zA-Z0-9_]+$ ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Invalid tool name\"}' >&2\n  exit 2\nfi\n```\n\n### Path Safety\n\nCheck for path traversal and sensitive files:\n\n```bash\nfile_path=$(echo \"$input\" | jq -r '.tool_input.file_path')\n\n# Deny path traversal\nif [[ \"$file_path\" == *\"..\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Path traversal detected\"}' >&2\n  exit 2\nfi\n\n# Deny sensitive files\nif [[ \"$file_path\" == *\".env\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Sensitive file\"}' >&2\n  exit 2\nfi\n```\n\nSee `examples/validate-write.sh` and `examples/validate-bash.sh` for complete examples.\n\n### Quote All Variables\n\n```bash\n# GOOD: Quoted\necho \"$file_path\"\ncd \"$CLAUDE_PROJECT_DIR\"\n\n# BAD: Unquoted (injection risk)\necho $file_path\ncd $CLAUDE_PROJECT_DIR\n```\n\n### Set Appropriate Timeouts\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash script.sh\",\n  \"timeout\": 10\n}\n```\n\n**Defaults:** Command hooks (60s), Prompt hooks (30s)\n\n## Performance Considerations\n\n### Parallel Execution\n\nAll matching hooks run **in parallel**:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write\",\n      \"hooks\": [\n        {\"type\": \"command\", \"command\": \"check1.sh\"},  // Parallel\n        {\"type\": \"command\", \"command\": \"check2.sh\"},  // Parallel\n        {\"type\": \"prompt\", \"prompt\": \"Validate...\"}   // Parallel\n      ]\n    }\n  ]\n}\n```\n\n**Design implications:**\n- Hooks don't see each other's output\n- Non-deterministic ordering\n- Design for independence\n\n### Optimization\n\n1. Use command hooks for quick deterministic checks\n2. Use prompt hooks for complex reasoning\n3. Cache validation results in temp files\n4. Minimize I/O in hot paths\n\n## Temporarily Active Hooks\n\nCreate hooks that activate conditionally by checking for a flag file or configuration:\n\n**Pattern: Flag file activation**\n```bash\n#!/bin/bash\n# Only active when flag file exists\nFLAG_FILE=\"$CLAUDE_PROJECT_DIR/.enable-strict-validation\"\n\nif [ ! -f \"$FLAG_FILE\" ]; then\n  # Flag not present, skip validation\n  exit 0\nfi\n\n# Flag present, run validation\ninput=$(cat)\n# ... validation logic ...\n```\n\n**Pattern: Configuration-based activation**\n```bash\n#!/bin/bash\n# Check configuration for activation\nCONFIG_FILE=\"$CLAUDE_PROJECT_DIR/.claude/plugin-config.json\"\n\nif [ -f \"$CONFIG_FILE\" ]; then\n  enabled=$(jq -r '.strictMode // false' \"$CONFIG_FILE\")\n  if [ \"$enabled\" != \"true\" ]; then\n    exit 0  # Not enabled, skip\n  fi\nfi\n\n# Enabled, run hook logic\ninput=$(cat)\n# ... hook logic ...\n```\n\n**Use cases:**\n- Enable strict validation only when needed\n- Temporary debugging hooks\n- Project-specific hook behavior\n- Feature flags for hooks\n\n**Best practice:** Document activation mechanism in plugin README so users know how to enable/disable temporary hooks.\n\n## Hook Lifecycle and Limitations\n\n### Hooks Load at Session Start\n\n**Important:** Hooks are loaded when Claude Code session starts. Changes to hook configuration require restarting Claude Code.\n\n**Cannot hot-swap hooks:**\n- Editing `hooks/hooks.json` won't affect current session\n- Adding new hook scripts won't be recognized\n- Changing hook commands/prompts won't update\n- Must restart Claude Code: exit and run `claude` again\n\n**To test hook changes:**\n1. Edit hook configuration or scripts\n2. Exit Claude Code session\n3. Restart: `claude` or `cc`\n4. New hook configuration loads\n5. Test hooks with `claude --debug`\n\n### Hook Validation at Startup\n\nHooks are validated when Claude Code starts:\n- Invalid JSON in hooks.json causes loading failure\n- Missing scripts cause warnings\n- Syntax errors reported in debug mode\n\nUse `/hooks` command to review loaded hooks in current session.\n\n## Debugging Hooks\n\n### Enable Debug Mode\n\n```bash\nclaude --debug\n```\n\nLook for hook registration, execution logs, input/output JSON, and timing information.\n\n### Test Hook Scripts\n\nTest command hooks directly:\n\n```bash\necho '{\"tool_name\": \"Write\", \"tool_input\": {\"file_path\": \"/test\"}}' | \\\n  bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\n\necho \"Exit code: $?\"\n```\n\n### Validate JSON Output\n\nEnsure hooks output valid JSON:\n\n```bash\noutput=$(./your-hook.sh < test-input.json)\necho \"$output\" | jq .\n```\n\n## Quick Reference\n\n### Hook Events Summary\n\n| Event | When | Use For |\n|-------|------|---------|\n| PreToolUse | Before tool | Validation, modification |\n| PostToolUse | After tool | Feedback, logging |\n| UserPromptSubmit | User input | Context, validation |\n| Stop | Agent stopping | Completeness check |\n| SubagentStop | Subagent done | Task validation |\n| SessionStart | Session begins | Context loading |\n| SessionEnd | Session ends | Cleanup, logging |\n| PreCompact | Before compact | Preserve context |\n| Notification | User notified | Logging, reactions |\n\n### Best Practices\n\n**DO:**\n- âœ… Use prompt-based hooks for complex logic\n- âœ… Use ${CLAUDE_PLUGIN_ROOT} for portability\n- âœ… Validate all inputs in command hooks\n- âœ… Quote all bash variables\n- âœ… Set appropriate timeouts\n- âœ… Return structured JSON output\n- âœ… Test hooks thoroughly\n\n**DON'T:**\n- âŒ Use hardcoded paths\n- âŒ Trust user input without validation\n- âŒ Create long-running hooks\n- âŒ Rely on hook execution order\n- âŒ Modify global state unpredictably\n- âŒ Log sensitive information\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and advanced techniques, consult:\n\n- **`references/patterns.md`** - Common hook patterns (8+ proven patterns)\n- **`references/migration.md`** - Migrating from basic to advanced hooks\n- **`references/advanced.md`** - Advanced use cases and techniques\n\n### Example Hook Scripts\n\nWorking examples in `examples/`:\n\n- **`validate-write.sh`** - File write validation example\n- **`validate-bash.sh`** - Bash command validation example\n- **`load-context.sh`** - SessionStart context loading example\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-hook-schema.sh`** - Validate hooks.json structure and syntax\n- **`test-hook.sh`** - Test hooks with sample input before deployment\n- **`hook-linter.sh`** - Check hook scripts for common issues and best practices\n\n### External Resources\n\n- **Official Docs**: https://docs.claude.com/en/docs/claude-code/hooks\n- **Examples**: See security-guidance plugin in marketplace\n- **Testing**: Use `claude --debug` for detailed logs\n- **Validation**: Use `jq` to validate hook JSON output\n\n## Implementation Workflow\n\nTo implement hooks in a plugin:\n\n1. Identify events to hook into (PreToolUse, Stop, SessionStart, etc.)\n2. Decide between prompt-based (flexible) or command (deterministic) hooks\n3. Write hook configuration in `hooks/hooks.json`\n4. For command hooks, create hook scripts\n5. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n6. Validate configuration with `scripts/validate-hook-schema.sh hooks/hooks.json`\n7. Test hooks with `scripts/test-hook.sh` before deployment\n8. Test in Claude Code with `claude --debug`\n9. Document hooks in plugin README\n\nFocus on prompt-based hooks for most use cases. Reserve command hooks for performance-critical or deterministic checks."
              },
              {
                "name": "MCP Integration",
                "description": "This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration.",
                "path": "plugins/plugin-dev/skills/mcp-integration/SKILL.md",
                "frontmatter": {
                  "name": "MCP Integration",
                  "description": "This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration.",
                  "version": "0.1.0"
                },
                "content": "# MCP Integration for Claude Code Plugins\n\n## Overview\n\nModel Context Protocol (MCP) enables Claude Code plugins to integrate with external services and APIs by providing structured tool access. Use MCP integration to expose external service capabilities as tools within Claude Code.\n\n**Key capabilities:**\n- Connect to external services (databases, APIs, file systems)\n- Provide 10+ related tools from a single service\n- Handle OAuth and complex authentication flows\n- Bundle MCP servers with plugins for automatic setup\n\n## MCP Server Configuration Methods\n\nPlugins can bundle MCP servers in two ways:\n\n### Method 1: Dedicated .mcp.json (Recommended)\n\nCreate `.mcp.json` at plugin root:\n\n```json\n{\n  \"database-tools\": {\n    \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/db-server\",\n    \"args\": [\"--config\", \"${CLAUDE_PLUGIN_ROOT}/config.json\"],\n    \"env\": {\n      \"DB_URL\": \"${DB_URL}\"\n    }\n  }\n}\n```\n\n**Benefits:**\n- Clear separation of concerns\n- Easier to maintain\n- Better for multiple servers\n\n### Method 2: Inline in plugin.json\n\nAdd `mcpServers` field to plugin.json:\n\n```json\n{\n  \"name\": \"my-plugin\",\n  \"version\": \"1.0.0\",\n  \"mcpServers\": {\n    \"plugin-api\": {\n      \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/api-server\",\n      \"args\": [\"--port\", \"8080\"]\n    }\n  }\n}\n```\n\n**Benefits:**\n- Single configuration file\n- Good for simple single-server plugins\n\n## MCP Server Types\n\n### stdio (Local Process)\n\nExecute local MCP servers as child processes. Best for local tools and custom servers.\n\n**Configuration:**\n```json\n{\n  \"filesystem\": {\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/allowed/path\"],\n    \"env\": {\n      \"LOG_LEVEL\": \"debug\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- File system access\n- Local database connections\n- Custom MCP servers\n- NPM-packaged MCP servers\n\n**Process management:**\n- Claude Code spawns and manages the process\n- Communicates via stdin/stdout\n- Terminates when Claude Code exits\n\n### SSE (Server-Sent Events)\n\nConnect to hosted MCP servers with OAuth support. Best for cloud services.\n\n**Configuration:**\n```json\n{\n  \"asana\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.asana.com/sse\"\n  }\n}\n```\n\n**Use cases:**\n- Official hosted MCP servers (Asana, GitHub, etc.)\n- Cloud services with MCP endpoints\n- OAuth-based authentication\n- No local installation needed\n\n**Authentication:**\n- OAuth flows handled automatically\n- User prompted on first use\n- Tokens managed by Claude Code\n\n### HTTP (REST API)\n\nConnect to RESTful MCP servers with token authentication.\n\n**Configuration:**\n```json\n{\n  \"api-service\": {\n    \"type\": \"http\",\n    \"url\": \"https://api.example.com/mcp\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${API_TOKEN}\",\n      \"X-Custom-Header\": \"value\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- REST API-based MCP servers\n- Token-based authentication\n- Custom API backends\n- Stateless interactions\n\n### WebSocket (Real-time)\n\nConnect to WebSocket MCP servers for real-time bidirectional communication.\n\n**Configuration:**\n```json\n{\n  \"realtime-service\": {\n    \"type\": \"ws\",\n    \"url\": \"wss://mcp.example.com/ws\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${TOKEN}\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- Real-time data streaming\n- Persistent connections\n- Push notifications from server\n- Low-latency requirements\n\n## Environment Variable Expansion\n\nAll MCP configurations support environment variable substitution:\n\n**${CLAUDE_PLUGIN_ROOT}** - Plugin directory (always use for portability):\n```json\n{\n  \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/my-server\"\n}\n```\n\n**User environment variables** - From user's shell:\n```json\n{\n  \"env\": {\n    \"API_KEY\": \"${MY_API_KEY}\",\n    \"DATABASE_URL\": \"${DB_URL}\"\n  }\n}\n```\n\n**Best practice:** Document all required environment variables in plugin README.\n\n## MCP Tool Naming\n\nWhen MCP servers provide tools, they're automatically prefixed:\n\n**Format:** `mcp__plugin_<plugin-name>_<server-name>__<tool-name>`\n\n**Example:**\n- Plugin: `asana`\n- Server: `asana`\n- Tool: `create_task`\n- **Full name:** `mcp__plugin_asana_asana__asana_create_task`\n\n### Using MCP Tools in Commands\n\nPre-allow specific MCP tools in command frontmatter:\n\n```markdown\n---\nallowed-tools: [\n  \"mcp__plugin_asana_asana__asana_create_task\",\n  \"mcp__plugin_asana_asana__asana_search_tasks\"\n]\n---\n```\n\n**Wildcard (use sparingly):**\n```markdown\n---\nallowed-tools: [\"mcp__plugin_asana_asana__*\"]\n---\n```\n\n**Best practice:** Pre-allow specific tools, not wildcards, for security.\n\n## Lifecycle Management\n\n**Automatic startup:**\n- MCP servers start when plugin enables\n- Connection established before first tool use\n- Restart required for configuration changes\n\n**Lifecycle:**\n1. Plugin loads\n2. MCP configuration parsed\n3. Server process started (stdio) or connection established (SSE/HTTP/WS)\n4. Tools discovered and registered\n5. Tools available as `mcp__plugin_...__...`\n\n**Viewing servers:**\nUse `/mcp` command to see all servers including plugin-provided ones.\n\n## Authentication Patterns\n\n### OAuth (SSE/HTTP)\n\nOAuth handled automatically by Claude Code:\n\n```json\n{\n  \"type\": \"sse\",\n  \"url\": \"https://mcp.example.com/sse\"\n}\n```\n\nUser authenticates in browser on first use. No additional configuration needed.\n\n### Token-Based (Headers)\n\nStatic or environment variable tokens:\n\n```json\n{\n  \"type\": \"http\",\n  \"url\": \"https://api.example.com\",\n  \"headers\": {\n    \"Authorization\": \"Bearer ${API_TOKEN}\"\n  }\n}\n```\n\nDocument required environment variables in README.\n\n### Environment Variables (stdio)\n\nPass configuration to MCP server:\n\n```json\n{\n  \"command\": \"python\",\n  \"args\": [\"-m\", \"my_mcp_server\"],\n  \"env\": {\n    \"DATABASE_URL\": \"${DB_URL}\",\n    \"API_KEY\": \"${API_KEY}\",\n    \"LOG_LEVEL\": \"info\"\n  }\n}\n```\n\n## Integration Patterns\n\n### Pattern 1: Simple Tool Wrapper\n\nCommands use MCP tools with user interaction:\n\n```markdown\n# Command: create-item.md\n---\nallowed-tools: [\"mcp__plugin_name_server__create_item\"]\n---\n\nSteps:\n1. Gather item details from user\n2. Use mcp__plugin_name_server__create_item\n3. Confirm creation\n```\n\n**Use for:** Adding validation or preprocessing before MCP calls.\n\n### Pattern 2: Autonomous Agent\n\nAgents use MCP tools autonomously:\n\n```markdown\n# Agent: data-analyzer.md\n\nAnalysis Process:\n1. Query data via mcp__plugin_db_server__query\n2. Process and analyze results\n3. Generate insights report\n```\n\n**Use for:** Multi-step MCP workflows without user interaction.\n\n### Pattern 3: Multi-Server Plugin\n\nIntegrate multiple MCP servers:\n\n```json\n{\n  \"github\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.github.com/sse\"\n  },\n  \"jira\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.jira.com/sse\"\n  }\n}\n```\n\n**Use for:** Workflows spanning multiple services.\n\n## Security Best Practices\n\n### Use HTTPS/WSS\n\nAlways use secure connections:\n\n```json\nâœ… \"url\": \"https://mcp.example.com/sse\"\nâŒ \"url\": \"http://mcp.example.com/sse\"\n```\n\n### Token Management\n\n**DO:**\n- âœ… Use environment variables for tokens\n- âœ… Document required env vars in README\n- âœ… Let OAuth flow handle authentication\n\n**DON'T:**\n- âŒ Hardcode tokens in configuration\n- âŒ Commit tokens to git\n- âŒ Share tokens in documentation\n\n### Permission Scoping\n\nPre-allow only necessary MCP tools:\n\n```markdown\nâœ… allowed-tools: [\n  \"mcp__plugin_api_server__read_data\",\n  \"mcp__plugin_api_server__create_item\"\n]\n\nâŒ allowed-tools: [\"mcp__plugin_api_server__*\"]\n```\n\n## Error Handling\n\n### Connection Failures\n\nHandle MCP server unavailability:\n- Provide fallback behavior in commands\n- Inform user of connection issues\n- Check server URL and configuration\n\n### Tool Call Errors\n\nHandle failed MCP operations:\n- Validate inputs before calling MCP tools\n- Provide clear error messages\n- Check rate limiting and quotas\n\n### Configuration Errors\n\nValidate MCP configuration:\n- Test server connectivity during development\n- Validate JSON syntax\n- Check required environment variables\n\n## Performance Considerations\n\n### Lazy Loading\n\nMCP servers connect on-demand:\n- Not all servers connect at startup\n- First tool use triggers connection\n- Connection pooling managed automatically\n\n### Batching\n\nBatch similar requests when possible:\n\n```\n# Good: Single query with filters\ntasks = search_tasks(project=\"X\", assignee=\"me\", limit=50)\n\n# Avoid: Many individual queries\nfor id in task_ids:\n    task = get_task(id)\n```\n\n## Testing MCP Integration\n\n### Local Testing\n\n1. Configure MCP server in `.mcp.json`\n2. Install plugin locally (`.claude-plugin/`)\n3. Run `/mcp` to verify server appears\n4. Test tool calls in commands\n5. Check `claude --debug` logs for connection issues\n\n### Validation Checklist\n\n- [ ] MCP configuration is valid JSON\n- [ ] Server URL is correct and accessible\n- [ ] Required environment variables documented\n- [ ] Tools appear in `/mcp` output\n- [ ] Authentication works (OAuth or tokens)\n- [ ] Tool calls succeed from commands\n- [ ] Error cases handled gracefully\n\n## Debugging\n\n### Enable Debug Logging\n\n```bash\nclaude --debug\n```\n\nLook for:\n- MCP server connection attempts\n- Tool discovery logs\n- Authentication flows\n- Tool call errors\n\n### Common Issues\n\n**Server not connecting:**\n- Check URL is correct\n- Verify server is running (stdio)\n- Check network connectivity\n- Review authentication configuration\n\n**Tools not available:**\n- Verify server connected successfully\n- Check tool names match exactly\n- Run `/mcp` to see available tools\n- Restart Claude Code after config changes\n\n**Authentication failing:**\n- Clear cached auth tokens\n- Re-authenticate\n- Check token scopes and permissions\n- Verify environment variables set\n\n## Quick Reference\n\n### MCP Server Types\n\n| Type | Transport | Best For | Auth |\n|------|-----------|----------|------|\n| stdio | Process | Local tools, custom servers | Env vars |\n| SSE | HTTP | Hosted services, cloud APIs | OAuth |\n| HTTP | REST | API backends, token auth | Tokens |\n| ws | WebSocket | Real-time, streaming | Tokens |\n\n### Configuration Checklist\n\n- [ ] Server type specified (stdio/SSE/HTTP/ws)\n- [ ] Type-specific fields complete (command or url)\n- [ ] Authentication configured\n- [ ] Environment variables documented\n- [ ] HTTPS/WSS used (not HTTP/WS)\n- [ ] ${CLAUDE_PLUGIN_ROOT} used for paths\n\n### Best Practices\n\n**DO:**\n- âœ… Use ${CLAUDE_PLUGIN_ROOT} for portable paths\n- âœ… Document required environment variables\n- âœ… Use secure connections (HTTPS/WSS)\n- âœ… Pre-allow specific MCP tools in commands\n- âœ… Test MCP integration before publishing\n- âœ… Handle connection and tool errors gracefully\n\n**DON'T:**\n- âŒ Hardcode absolute paths\n- âŒ Commit credentials to git\n- âŒ Use HTTP instead of HTTPS\n- âŒ Pre-allow all tools with wildcards\n- âŒ Skip error handling\n- âŒ Forget to document setup\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed information, consult:\n\n- **`references/server-types.md`** - Deep dive on each server type\n- **`references/authentication.md`** - Authentication patterns and OAuth\n- **`references/tool-usage.md`** - Using MCP tools in commands and agents\n\n### Example Configurations\n\nWorking examples in `examples/`:\n\n- **`stdio-server.json`** - Local stdio MCP server\n- **`sse-server.json`** - Hosted SSE server with OAuth\n- **`http-server.json`** - REST API with token auth\n\n### External Resources\n\n- **Official MCP Docs**: https://modelcontextprotocol.io/\n- **Claude Code MCP Docs**: https://docs.claude.com/en/docs/claude-code/mcp\n- **MCP SDK**: @modelcontextprotocol/sdk\n- **Testing**: Use `claude --debug` and `/mcp` command\n\n## Implementation Workflow\n\nTo add MCP integration to a plugin:\n\n1. Choose MCP server type (stdio, SSE, HTTP, ws)\n2. Create `.mcp.json` at plugin root with configuration\n3. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n4. Document required environment variables in README\n5. Test locally with `/mcp` command\n6. Pre-allow MCP tools in relevant commands\n7. Handle authentication (OAuth or tokens)\n8. Test error cases (connection failures, auth errors)\n9. Document MCP integration in plugin README\n\nFocus on stdio for custom/local servers, SSE for hosted services with OAuth."
              },
              {
                "name": "Plugin Settings",
                "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.",
                "path": "plugins/plugin-dev/skills/plugin-settings/SKILL.md",
                "frontmatter": {
                  "name": "Plugin Settings",
                  "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.",
                  "version": "0.1.0"
                },
                "content": "# Plugin Settings Pattern for Claude Code Plugins\n\n## Overview\n\nPlugins can store user-configurable settings and state in `.claude/plugin-name.local.md` files within the project directory. This pattern uses YAML frontmatter for structured configuration and markdown content for prompts or additional context.\n\n**Key characteristics:**\n- File location: `.claude/plugin-name.local.md` in project root\n- Structure: YAML frontmatter + markdown body\n- Purpose: Per-project plugin configuration and state\n- Usage: Read from hooks, commands, and agents\n- Lifecycle: User-managed (not in git, should be in `.gitignore`)\n\n## File Structure\n\n### Basic Template\n\n```markdown\n---\nenabled: true\nsetting1: value1\nsetting2: value2\nnumeric_setting: 42\nlist_setting: [\"item1\", \"item2\"]\n---\n\n# Additional Context\n\nThis markdown body can contain:\n- Task descriptions\n- Additional instructions\n- Prompts to feed back to Claude\n- Documentation or notes\n```\n\n### Example: Plugin State File\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nenabled: true\nstrict_mode: false\nmax_retries: 3\nnotification_level: info\ncoordinator_session: team-leader\n---\n\n# Plugin Configuration\n\nThis plugin is configured for standard validation mode.\nContact @team-lead with questions.\n```\n\n## Reading Settings Files\n\n### From Hooks (Bash Scripts)\n\n**Pattern: Check existence and parse frontmatter**\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\n# Define state file path\nSTATE_FILE=\".claude/my-plugin.local.md\"\n\n# Quick exit if file doesn't exist\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0  # Plugin not configured, skip\nfi\n\n# Parse YAML frontmatter (between --- markers)\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\n\n# Extract individual fields\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\nSTRICT_MODE=$(echo \"$FRONTMATTER\" | grep '^strict_mode:' | sed 's/strict_mode: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n\n# Check if enabled\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Use configuration in hook logic\nif [[ \"$STRICT_MODE\" == \"true\" ]]; then\n  # Apply strict validation\n  # ...\nfi\n```\n\nSee `examples/read-settings-hook.sh` for complete working example.\n\n### From Commands\n\nCommands can read settings files to customize behavior:\n\n```markdown\n---\ndescription: Process data with plugin\nallowed-tools: [\"Read\", \"Bash\"]\n---\n\n# Process Command\n\nSteps:\n1. Check if settings exist at `.claude/my-plugin.local.md`\n2. Read configuration using Read tool\n3. Parse YAML frontmatter to extract settings\n4. Apply settings to processing logic\n5. Execute with configured behavior\n```\n\n### From Agents\n\nAgents can reference settings in their instructions:\n\n```markdown\n---\nname: configured-agent\ndescription: Agent that adapts to project settings\n---\n\nCheck for plugin settings at `.claude/my-plugin.local.md`.\nIf present, parse YAML frontmatter and adapt behavior according to:\n- enabled: Whether plugin is active\n- mode: Processing mode (strict, standard, lenient)\n- Additional configuration fields\n```\n\n## Parsing Techniques\n\n### Extract Frontmatter\n\n```bash\n# Extract everything between --- markers\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n```\n\n### Read Individual Fields\n\n**String fields:**\n```bash\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field_name:' | sed 's/field_name: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n**Boolean fields:**\n```bash\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n# Compare: if [[ \"$ENABLED\" == \"true\" ]]; then\n```\n\n**Numeric fields:**\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n# Use: if [[ $MAX -gt 100 ]]; then\n```\n\n### Read Markdown Body\n\nExtract content after second `---`:\n\n```bash\n# Get everything after closing ---\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n## Common Patterns\n\n### Pattern 1: Temporarily Active Hooks\n\nUse settings file to control hook activation:\n\n```bash\n#!/bin/bash\nSTATE_FILE=\".claude/security-scan.local.md\"\n\n# Quick exit if not configured\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0\nfi\n\n# Read enabled flag\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Run hook logic\n# ...\n```\n\n**Use case:** Enable/disable hooks without editing hooks.json (requires restart).\n\n### Pattern 2: Agent State Management\n\nStore agent-specific state and configuration:\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-agent\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\n---\n\n# Task Assignment\n\nImplement JWT authentication for the API.\n\n**Success Criteria:**\n- Authentication endpoints created\n- Tests passing\n- PR created and CI green\n```\n\nRead from hooks to coordinate agents:\n\n```bash\nAGENT_NAME=$(echo \"$FRONTMATTER\" | grep '^agent_name:' | sed 's/agent_name: *//')\nCOORDINATOR=$(echo \"$FRONTMATTER\" | grep '^coordinator_session:' | sed 's/coordinator_session: *//')\n\n# Send notification to coordinator\ntmux send-keys -t \"$COORDINATOR\" \"Agent $AGENT_NAME completed task\" Enter\n```\n\n### Pattern 3: Configuration-Driven Behavior\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nvalidation_level: strict\nmax_file_size: 1000000\nallowed_extensions: [\".js\", \".ts\", \".tsx\"]\nenable_logging: true\n---\n\n# Validation Configuration\n\nStrict mode enabled for this project.\nAll writes validated against security policies.\n```\n\nUse in hooks or commands:\n\n```bash\nLEVEL=$(echo \"$FRONTMATTER\" | grep '^validation_level:' | sed 's/validation_level: *//')\n\ncase \"$LEVEL\" in\n  strict)\n    # Apply strict validation\n    ;;\n  standard)\n    # Apply standard validation\n    ;;\n  lenient)\n    # Apply lenient validation\n    ;;\nesac\n```\n\n## Creating Settings Files\n\n### From Commands\n\nCommands can create settings files:\n\n```markdown\n# Setup Command\n\nSteps:\n1. Ask user for configuration preferences\n2. Create `.claude/my-plugin.local.md` with YAML frontmatter\n3. Set appropriate values based on user input\n4. Inform user that settings are saved\n5. Remind user to restart Claude Code for hooks to recognize changes\n```\n\n### Template Generation\n\nProvide template in plugin README:\n\n```markdown\n## Configuration\n\nCreate `.claude/my-plugin.local.md` in your project:\n\n\\`\\`\\`markdown\n---\nenabled: true\nmode: standard\nmax_retries: 3\n---\n\n# Plugin Configuration\n\nYour settings are active.\n\\`\\`\\`\n\nAfter creating or editing, restart Claude Code for changes to take effect.\n```\n\n## Best Practices\n\n### File Naming\n\nâœ… **DO:**\n- Use `.claude/plugin-name.local.md` format\n- Match plugin name exactly\n- Use `.local.md` suffix for user-local files\n\nâŒ **DON'T:**\n- Use different directory (not `.claude/`)\n- Use inconsistent naming\n- Use `.md` without `.local` (might be committed)\n\n### Gitignore\n\nAlways add to `.gitignore`:\n\n```gitignore\n.claude/*.local.md\n.claude/*.local.json\n```\n\nDocument this in plugin README.\n\n### Defaults\n\nProvide sensible defaults when settings file doesn't exist:\n\n```bash\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  # Use defaults\n  ENABLED=true\n  MODE=standard\nelse\n  # Read from file\n  # ...\nfi\n```\n\n### Validation\n\nValidate settings values:\n\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n\n# Validate numeric range\nif ! [[ \"$MAX\" =~ ^[0-9]+$ ]] || [[ $MAX -lt 1 ]] || [[ $MAX -gt 100 ]]; then\n  echo \"âš ï¸  Invalid max_value in settings (must be 1-100)\" >&2\n  MAX=10  # Use default\nfi\n```\n\n### Restart Requirement\n\n**Important:** Settings changes require Claude Code restart.\n\nDocument in your README:\n\n```markdown\n## Changing Settings\n\nAfter editing `.claude/my-plugin.local.md`:\n1. Save the file\n2. Exit Claude Code\n3. Restart: `claude` or `cc`\n4. New settings will be loaded\n```\n\nHooks cannot be hot-swapped within a session.\n\n## Security Considerations\n\n### Sanitize User Input\n\nWhen writing settings files from user input:\n\n```bash\n# Escape quotes in user input\nSAFE_VALUE=$(echo \"$USER_INPUT\" | sed 's/\"/\\\\\"/g')\n\n# Write to file\ncat > \"$STATE_FILE\" <<EOF\n---\nuser_setting: \"$SAFE_VALUE\"\n---\nEOF\n```\n\n### Validate File Paths\n\nIf settings contain file paths:\n\n```bash\nFILE_PATH=$(echo \"$FRONTMATTER\" | grep '^data_file:' | sed 's/data_file: *//')\n\n# Check for path traversal\nif [[ \"$FILE_PATH\" == *\"..\"* ]]; then\n  echo \"âš ï¸  Invalid path in settings (path traversal)\" >&2\n  exit 2\nfi\n```\n\n### Permissions\n\nSettings files should be:\n- Readable by user only (`chmod 600`)\n- Not committed to git\n- Not shared between users\n\n## Real-World Examples\n\n### multi-agent-swarm Plugin\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-implementation\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\nadditional_instructions: Use JWT tokens, not sessions\n---\n\n# Task: Implement Authentication\n\nBuild JWT-based authentication for the REST API.\nCoordinate with auth-agent on shared types.\n```\n\n**Hook usage (agent-stop-notification.sh):**\n- Checks if file exists (line 15-18: quick exit if not)\n- Parses frontmatter to get coordinator_session, agent_name, enabled\n- Sends notifications to coordinator if enabled\n- Allows quick activation/deactivation via `enabled: true/false`\n\n### ralph-loop Plugin\n\n**.claude/ralph-loop.local.md:**\n```markdown\n---\niteration: 1\nmax_iterations: 10\ncompletion_promise: \"All tests passing and build successful\"\n---\n\nFix all the linting errors in the project.\nMake sure tests pass after each fix.\n```\n\n**Hook usage (stop-hook.sh):**\n- Checks if file exists (line 15-18: quick exit if not active)\n- Reads iteration count and max_iterations\n- Extracts completion_promise for loop termination\n- Reads body as the prompt to feed back\n- Updates iteration count on each loop\n\n## Quick Reference\n\n### File Location\n\n```\nproject-root/\nâ””â”€â”€ .claude/\n    â””â”€â”€ plugin-name.local.md\n```\n\n### Frontmatter Parsing\n\n```bash\n# Extract frontmatter\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n\n# Read field\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field:' | sed 's/field: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n### Body Parsing\n\n```bash\n# Extract body (after second ---)\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n### Quick Exit Pattern\n\n```bash\nif [[ ! -f \".claude/my-plugin.local.md\" ]]; then\n  exit 0  # Not configured\nfi\n```\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed implementation patterns:\n\n- **`references/parsing-techniques.md`** - Complete guide to parsing YAML frontmatter and markdown bodies\n- **`references/real-world-examples.md`** - Deep dive into multi-agent-swarm and ralph-loop implementations\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`read-settings-hook.sh`** - Hook that reads and uses settings\n- **`create-settings-command.md`** - Command that creates settings file\n- **`example-settings.md`** - Template settings file\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-settings.sh`** - Validate settings file structure\n- **`parse-frontmatter.sh`** - Extract frontmatter fields\n\n## Implementation Workflow\n\nTo add settings to a plugin:\n\n1. Design settings schema (which fields, types, defaults)\n2. Create template file in plugin documentation\n3. Add gitignore entry for `.claude/*.local.md`\n4. Implement settings parsing in hooks/commands\n5. Use quick-exit pattern (check file exists, check enabled field)\n6. Document settings in plugin README with template\n7. Remind users that changes require Claude Code restart\n\nFocus on keeping settings simple and providing good defaults when settings file doesn't exist."
              },
              {
                "name": "Plugin Structure",
                "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.",
                "path": "plugins/plugin-dev/skills/plugin-structure/SKILL.md",
                "frontmatter": {
                  "name": "Plugin Structure",
                  "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.",
                  "version": "0.1.0"
                },
                "content": "# Plugin Structure for Claude Code\n\n## Overview\n\nClaude Code plugins follow a standardized directory structure with automatic component discovery. Understanding this structure enables creating well-organized, maintainable plugins that integrate seamlessly with Claude Code.\n\n**Key concepts:**\n- Conventional directory layout for automatic discovery\n- Manifest-driven configuration in `.claude-plugin/plugin.json`\n- Component-based organization (commands, agents, skills, hooks)\n- Portable path references using `${CLAUDE_PLUGIN_ROOT}`\n- Explicit vs. auto-discovered component loading\n\n## Directory Structure\n\nEvery Claude Code plugin follows this organizational pattern:\n\n```\nplugin-name/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json          # Required: Plugin manifest\nâ”œâ”€â”€ commands/                 # Slash commands (.md files)\nâ”œâ”€â”€ agents/                   # Subagent definitions (.md files)\nâ”œâ”€â”€ skills/                   # Agent skills (subdirectories)\nâ”‚   â””â”€â”€ skill-name/\nâ”‚       â””â”€â”€ SKILL.md         # Required for each skill\nâ”œâ”€â”€ hooks/\nâ”‚   â””â”€â”€ hooks.json           # Event handler configuration\nâ”œâ”€â”€ .mcp.json                # MCP server definitions\nâ””â”€â”€ scripts/                 # Helper scripts and utilities\n```\n\n**Critical rules:**\n\n1. **Manifest location**: The `plugin.json` manifest MUST be in `.claude-plugin/` directory\n2. **Component locations**: All component directories (commands, agents, skills, hooks) MUST be at plugin root level, NOT nested inside `.claude-plugin/`\n3. **Optional components**: Only create directories for components the plugin actually uses\n4. **Naming convention**: Use kebab-case for all directory and file names\n\n## Plugin Manifest (plugin.json)\n\nThe manifest defines plugin metadata and configuration. Located at `.claude-plugin/plugin.json`:\n\n### Required Fields\n\n```json\n{\n  \"name\": \"plugin-name\"\n}\n```\n\n**Name requirements:**\n- Use kebab-case format (lowercase with hyphens)\n- Must be unique across installed plugins\n- No spaces or special characters\n- Example: `code-review-assistant`, `test-runner`, `api-docs`\n\n### Recommended Metadata\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Brief explanation of plugin purpose\",\n  \"author\": {\n    \"name\": \"Author Name\",\n    \"email\": \"author@example.com\",\n    \"url\": \"https://example.com\"\n  },\n  \"homepage\": \"https://docs.example.com\",\n  \"repository\": \"https://github.com/user/plugin-name\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"testing\", \"automation\", \"ci-cd\"]\n}\n```\n\n**Version format**: Follow semantic versioning (MAJOR.MINOR.PATCH)\n**Keywords**: Use for plugin discovery and categorization\n\n### Component Path Configuration\n\nSpecify custom paths for components (supplements default directories):\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"commands\": \"./custom-commands\",\n  \"agents\": [\"./agents\", \"./specialized-agents\"],\n  \"hooks\": \"./config/hooks.json\",\n  \"mcpServers\": \"./.mcp.json\"\n}\n```\n\n**Important**: Custom paths supplement defaultsâ€”they don't replace them. Components in both default directories and custom paths will load.\n\n**Path rules:**\n- Must be relative to plugin root\n- Must start with `./`\n- Cannot use absolute paths\n- Support arrays for multiple locations\n\n## Component Organization\n\n### Commands\n\n**Location**: `commands/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `commands/` load automatically\n\n**Example structure**:\n```\ncommands/\nâ”œâ”€â”€ review.md        # /review command\nâ”œâ”€â”€ test.md          # /test command\nâ””â”€â”€ deploy.md        # /deploy command\n```\n\n**File format**:\n```markdown\n---\nname: command-name\ndescription: Command description\n---\n\nCommand implementation instructions...\n```\n\n**Usage**: Commands integrate as native slash commands in Claude Code\n\n### Agents\n\n**Location**: `agents/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `agents/` load automatically\n\n**Example structure**:\n```\nagents/\nâ”œâ”€â”€ code-reviewer.md\nâ”œâ”€â”€ test-generator.md\nâ””â”€â”€ refactorer.md\n```\n\n**File format**:\n```markdown\n---\ndescription: Agent role and expertise\ncapabilities:\n  - Specific task 1\n  - Specific task 2\n---\n\nDetailed agent instructions and knowledge...\n```\n\n**Usage**: Users can invoke agents manually, or Claude Code selects them automatically based on task context\n\n### Skills\n\n**Location**: `skills/` directory with subdirectories per skill\n**Format**: Each skill in its own directory with `SKILL.md` file\n**Auto-discovery**: All `SKILL.md` files in skill subdirectories load automatically\n\n**Example structure**:\n```\nskills/\nâ”œâ”€â”€ api-testing/\nâ”‚   â”œâ”€â”€ SKILL.md\nâ”‚   â”œâ”€â”€ scripts/\nâ”‚   â”‚   â””â”€â”€ test-runner.py\nâ”‚   â””â”€â”€ references/\nâ”‚       â””â”€â”€ api-spec.md\nâ””â”€â”€ database-migrations/\n    â”œâ”€â”€ SKILL.md\n    â””â”€â”€ examples/\n        â””â”€â”€ migration-template.sql\n```\n\n**SKILL.md format**:\n```markdown\n---\nname: Skill Name\ndescription: When to use this skill\nversion: 1.0.0\n---\n\nSkill instructions and guidance...\n```\n\n**Supporting files**: Skills can include scripts, references, examples, or assets in subdirectories\n\n**Usage**: Claude Code autonomously activates skills based on task context matching the description\n\n### Hooks\n\n**Location**: `hooks/hooks.json` or inline in `plugin.json`\n**Format**: JSON configuration defining event handlers\n**Registration**: Hooks register automatically when plugin enables\n\n**Example structure**:\n```\nhooks/\nâ”œâ”€â”€ hooks.json           # Hook configuration\nâ””â”€â”€ scripts/\n    â”œâ”€â”€ validate.sh      # Hook script\n    â””â”€â”€ check-style.sh   # Hook script\n```\n\n**Configuration format**:\n```json\n{\n  \"PreToolUse\": [{\n    \"matcher\": \"Write|Edit\",\n    \"hooks\": [{\n      \"type\": \"command\",\n      \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/validate.sh\",\n      \"timeout\": 30\n    }]\n  }]\n}\n```\n\n**Available events**: PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification\n\n**Usage**: Hooks execute automatically in response to Claude Code events\n\n### MCP Servers\n\n**Location**: `.mcp.json` at plugin root or inline in `plugin.json`\n**Format**: JSON configuration for MCP server definitions\n**Auto-start**: Servers start automatically when plugin enables\n\n**Example format**:\n```json\n{\n  \"mcpServers\": {\n    \"server-name\": {\n      \"command\": \"node\",\n      \"args\": [\"${CLAUDE_PLUGIN_ROOT}/servers/server.js\"],\n      \"env\": {\n        \"API_KEY\": \"${API_KEY}\"\n      }\n    }\n  }\n}\n```\n\n**Usage**: MCP servers integrate seamlessly with Claude Code's tool system\n\n## Portable Path References\n\n### ${CLAUDE_PLUGIN_ROOT}\n\nUse `${CLAUDE_PLUGIN_ROOT}` environment variable for all intra-plugin path references:\n\n```json\n{\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/run.sh\"\n}\n```\n\n**Why it matters**: Plugins install in different locations depending on:\n- User installation method (marketplace, local, npm)\n- Operating system conventions\n- User preferences\n\n**Where to use it**:\n- Hook command paths\n- MCP server command arguments\n- Script execution references\n- Resource file paths\n\n**Never use**:\n- Hardcoded absolute paths (`/Users/name/plugins/...`)\n- Relative paths from working directory (`./scripts/...` in commands)\n- Home directory shortcuts (`~/plugins/...`)\n\n### Path Resolution Rules\n\n**In manifest JSON fields** (hooks, MCP servers):\n```json\n\"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/tool.sh\"\n```\n\n**In component files** (commands, agents, skills):\n```markdown\nReference scripts at: ${CLAUDE_PLUGIN_ROOT}/scripts/helper.py\n```\n\n**In executed scripts**:\n```bash\n#!/bin/bash\n# ${CLAUDE_PLUGIN_ROOT} available as environment variable\nsource \"${CLAUDE_PLUGIN_ROOT}/lib/common.sh\"\n```\n\n## File Naming Conventions\n\n### Component Files\n\n**Commands**: Use kebab-case `.md` files\n- `code-review.md` â†’ `/code-review`\n- `run-tests.md` â†’ `/run-tests`\n- `api-docs.md` â†’ `/api-docs`\n\n**Agents**: Use kebab-case `.md` files describing role\n- `test-generator.md`\n- `code-reviewer.md`\n- `performance-analyzer.md`\n\n**Skills**: Use kebab-case directory names\n- `api-testing/`\n- `database-migrations/`\n- `error-handling/`\n\n### Supporting Files\n\n**Scripts**: Use descriptive kebab-case names with appropriate extensions\n- `validate-input.sh`\n- `generate-report.py`\n- `process-data.js`\n\n**Documentation**: Use kebab-case markdown files\n- `api-reference.md`\n- `migration-guide.md`\n- `best-practices.md`\n\n**Configuration**: Use standard names\n- `hooks.json`\n- `.mcp.json`\n- `plugin.json`\n\n## Auto-Discovery Mechanism\n\nClaude Code automatically discovers and loads components:\n\n1. **Plugin manifest**: Reads `.claude-plugin/plugin.json` when plugin enables\n2. **Commands**: Scans `commands/` directory for `.md` files\n3. **Agents**: Scans `agents/` directory for `.md` files\n4. **Skills**: Scans `skills/` for subdirectories containing `SKILL.md`\n5. **Hooks**: Loads configuration from `hooks/hooks.json` or manifest\n6. **MCP servers**: Loads configuration from `.mcp.json` or manifest\n\n**Discovery timing**:\n- Plugin installation: Components register with Claude Code\n- Plugin enable: Components become available for use\n- No restart required: Changes take effect on next Claude Code session\n\n**Override behavior**: Custom paths in `plugin.json` supplement (not replace) default directories\n\n## Best Practices\n\n### Organization\n\n1. **Logical grouping**: Group related components together\n   - Put test-related commands, agents, and skills together\n   - Create subdirectories in `scripts/` for different purposes\n\n2. **Minimal manifest**: Keep `plugin.json` lean\n   - Only specify custom paths when necessary\n   - Rely on auto-discovery for standard layouts\n   - Use inline configuration only for simple cases\n\n3. **Documentation**: Include README files\n   - Plugin root: Overall purpose and usage\n   - Component directories: Specific guidance\n   - Script directories: Usage and requirements\n\n### Naming\n\n1. **Consistency**: Use consistent naming across components\n   - If command is `test-runner`, name related agent `test-runner-agent`\n   - Match skill directory names to their purpose\n\n2. **Clarity**: Use descriptive names that indicate purpose\n   - Good: `api-integration-testing/`, `code-quality-checker.md`\n   - Avoid: `utils/`, `misc.md`, `temp.sh`\n\n3. **Length**: Balance brevity with clarity\n   - Commands: 2-3 words (`review-pr`, `run-ci`)\n   - Agents: Describe role clearly (`code-reviewer`, `test-generator`)\n   - Skills: Topic-focused (`error-handling`, `api-design`)\n\n### Portability\n\n1. **Always use ${CLAUDE_PLUGIN_ROOT}**: Never hardcode paths\n2. **Test on multiple systems**: Verify on macOS, Linux, Windows\n3. **Document dependencies**: List required tools and versions\n4. **Avoid system-specific features**: Use portable bash/Python constructs\n\n### Maintenance\n\n1. **Version consistently**: Update version in plugin.json for releases\n2. **Deprecate gracefully**: Mark old components clearly before removal\n3. **Document breaking changes**: Note changes affecting existing users\n4. **Test thoroughly**: Verify all components work after changes\n\n## Common Patterns\n\n### Minimal Plugin\n\nSingle command with no dependencies:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json    # Just name field\nâ””â”€â”€ commands/\n    â””â”€â”€ hello.md       # Single command\n```\n\n### Full-Featured Plugin\n\nComplete plugin with all component types:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/          # User-facing commands\nâ”œâ”€â”€ agents/            # Specialized subagents\nâ”œâ”€â”€ skills/            # Auto-activating skills\nâ”œâ”€â”€ hooks/             # Event handlers\nâ”‚   â”œâ”€â”€ hooks.json\nâ”‚   â””â”€â”€ scripts/\nâ”œâ”€â”€ .mcp.json          # External integrations\nâ””â”€â”€ scripts/           # Shared utilities\n```\n\n### Skill-Focused Plugin\n\nPlugin providing only skills:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ””â”€â”€ skills/\n    â”œâ”€â”€ skill-one/\n    â”‚   â””â”€â”€ SKILL.md\n    â””â”€â”€ skill-two/\n        â””â”€â”€ SKILL.md\n```\n\n## Troubleshooting\n\n**Component not loading**:\n- Verify file is in correct directory with correct extension\n- Check YAML frontmatter syntax (commands, agents, skills)\n- Ensure skill has `SKILL.md` (not `README.md` or other name)\n- Confirm plugin is enabled in Claude Code settings\n\n**Path resolution errors**:\n- Replace all hardcoded paths with `${CLAUDE_PLUGIN_ROOT}`\n- Verify paths are relative and start with `./` in manifest\n- Check that referenced files exist at specified paths\n- Test with `echo $CLAUDE_PLUGIN_ROOT` in hook scripts\n\n**Auto-discovery not working**:\n- Confirm directories are at plugin root (not in `.claude-plugin/`)\n- Check file naming follows conventions (kebab-case, correct extensions)\n- Verify custom paths in manifest are correct\n- Restart Claude Code to reload plugin configuration\n\n**Conflicts between plugins**:\n- Use unique, descriptive component names\n- Namespace commands with plugin name if needed\n- Document potential conflicts in plugin README\n- Consider command prefixes for related functionality\n\n---\n\nFor detailed examples and advanced patterns, see files in `references/` and `examples/` directories."
              },
              {
                "name": "Skill Development",
                "description": "This skill should be used when the user wants to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins.",
                "path": "plugins/plugin-dev/skills/skill-development/SKILL.md",
                "frontmatter": {
                  "name": "Skill Development",
                  "description": "This skill should be used when the user wants to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins.",
                  "version": "0.1.0"
                },
                "content": "# Skill Development for Claude Code Plugins\n\nThis skill provides guidance for creating effective skills for Claude Code plugins.\n\n## About Skills\n\nSkills are modular, self-contained packages that extend Claude's capabilities by providing\nspecialized knowledge, workflows, and tools. Think of them as \"onboarding guides\" for specific\ndomains or tasksâ€”they transform Claude from a general-purpose agent into a specialized agent\nequipped with procedural knowledge that no model can fully possess.\n\n### What Skills Provide\n\n1. Specialized workflows - Multi-step procedures for specific domains\n2. Tool integrations - Instructions for working with specific file formats or APIs\n3. Domain expertise - Company-specific knowledge, schemas, business logic\n4. Bundled resources - Scripts, references, and assets for complex and repetitive tasks\n\n### Anatomy of a Skill\n\nEvery skill consists of a required SKILL.md file and optional bundled resources:\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md (required)\nâ”‚   â”œâ”€â”€ YAML frontmatter metadata (required)\nâ”‚   â”‚   â”œâ”€â”€ name: (required)\nâ”‚   â”‚   â””â”€â”€ description: (required)\nâ”‚   â””â”€â”€ Markdown instructions (required)\nâ””â”€â”€ Bundled Resources (optional)\n    â”œâ”€â”€ scripts/          - Executable code (Python/Bash/etc.)\n    â”œâ”€â”€ references/       - Documentation intended to be loaded into context as needed\n    â””â”€â”€ assets/           - Files used in output (templates, icons, fonts, etc.)\n```\n\n#### SKILL.md (required)\n\n**Metadata Quality:** The `name` and `description` in YAML frontmatter determine when Claude will use the skill. Be specific about what the skill does and when to use it. Use the third-person (e.g. \"This skill should be used when...\" instead of \"Use this skill when...\").\n\n#### Bundled Resources (optional)\n\n##### Scripts (`scripts/`)\n\nExecutable code (Python/Bash/etc.) for tasks that require deterministic reliability or are repeatedly rewritten.\n\n- **When to include**: When the same code is being rewritten repeatedly or deterministic reliability is needed\n- **Example**: `scripts/rotate_pdf.py` for PDF rotation tasks\n- **Benefits**: Token efficient, deterministic, may be executed without loading into context\n- **Note**: Scripts may still need to be read by Claude for patching or environment-specific adjustments\n\n##### References (`references/`)\n\nDocumentation and reference material intended to be loaded as needed into context to inform Claude's process and thinking.\n\n- **When to include**: For documentation that Claude should reference while working\n- **Examples**: `references/finance.md` for financial schemas, `references/mnda.md` for company NDA template, `references/policies.md` for company policies, `references/api_docs.md` for API specifications\n- **Use cases**: Database schemas, API documentation, domain knowledge, company policies, detailed workflow guides\n- **Benefits**: Keeps SKILL.md lean, loaded only when Claude determines it's needed\n- **Best practice**: If files are large (>10k words), include grep search patterns in SKILL.md\n- **Avoid duplication**: Information should live in either SKILL.md or references files, not both. Prefer references files for detailed information unless it's truly core to the skillâ€”this keeps SKILL.md lean while making information discoverable without hogging the context window. Keep only essential procedural instructions and workflow guidance in SKILL.md; move detailed reference material, schemas, and examples to references files.\n\n##### Assets (`assets/`)\n\nFiles not intended to be loaded into context, but rather used within the output Claude produces.\n\n- **When to include**: When the skill needs files that will be used in the final output\n- **Examples**: `assets/logo.png` for brand assets, `assets/slides.pptx` for PowerPoint templates, `assets/frontend-template/` for HTML/React boilerplate, `assets/font.ttf` for typography\n- **Use cases**: Templates, images, icons, boilerplate code, fonts, sample documents that get copied or modified\n- **Benefits**: Separates output resources from documentation, enables Claude to use files without loading them into context\n\n### Progressive Disclosure Design Principle\n\nSkills use a three-level loading system to manage context efficiently:\n\n1. **Metadata (name + description)** - Always in context (~100 words)\n2. **SKILL.md body** - When skill triggers (<5k words)\n3. **Bundled resources** - As needed by Claude (Unlimited*)\n\n*Unlimited because scripts can be executed without reading into context window.\n\n## Skill Creation Process\n\nTo create a skill, follow the \"Skill Creation Process\" in order, skipping steps only if there is a clear reason why they are not applicable.\n\n### Step 1: Understanding the Skill with Concrete Examples\n\nSkip this step only when the skill's usage patterns are already clearly understood. It remains valuable even when working with an existing skill.\n\nTo create an effective skill, clearly understand concrete examples of how the skill will be used. This understanding can come from either direct user examples or generated examples that are validated with user feedback.\n\nFor example, when building an image-editor skill, relevant questions include:\n\n- \"What functionality should the image-editor skill support? Editing, rotating, anything else?\"\n- \"Can you give some examples of how this skill would be used?\"\n- \"I can imagine users asking for things like 'Remove the red-eye from this image' or 'Rotate this image'. Are there other ways you imagine this skill being used?\"\n- \"What would a user say that should trigger this skill?\"\n\nTo avoid overwhelming users, avoid asking too many questions in a single message. Start with the most important questions and follow up as needed for better effectiveness.\n\nConclude this step when there is a clear sense of the functionality the skill should support.\n\n### Step 2: Planning the Reusable Skill Contents\n\nTo turn concrete examples into an effective skill, analyze each example by:\n\n1. Considering how to execute on the example from scratch\n2. Identifying what scripts, references, and assets would be helpful when executing these workflows repeatedly\n\nExample: When building a `pdf-editor` skill to handle queries like \"Help me rotate this PDF,\" the analysis shows:\n\n1. Rotating a PDF requires re-writing the same code each time\n2. A `scripts/rotate_pdf.py` script would be helpful to store in the skill\n\nExample: When designing a `frontend-webapp-builder` skill for queries like \"Build me a todo app\" or \"Build me a dashboard to track my steps,\" the analysis shows:\n\n1. Writing a frontend webapp requires the same boilerplate HTML/React each time\n2. An `assets/hello-world/` template containing the boilerplate HTML/React project files would be helpful to store in the skill\n\nExample: When building a `big-query` skill to handle queries like \"How many users have logged in today?\" the analysis shows:\n\n1. Querying BigQuery requires re-discovering the table schemas and relationships each time\n2. A `references/schema.md` file documenting the table schemas would be helpful to store in the skill\n\n**For Claude Code plugins:** When building a hooks skill, the analysis shows:\n1. Developers repeatedly need to validate hooks.json and test hook scripts\n2. `scripts/validate-hook-schema.sh` and `scripts/test-hook.sh` utilities would be helpful\n3. `references/patterns.md` for detailed hook patterns to avoid bloating SKILL.md\n\nTo establish the skill's contents, analyze each concrete example to create a list of the reusable resources to include: scripts, references, and assets.\n\n### Step 3: Create Skill Structure\n\nFor Claude Code plugins, create the skill directory structure:\n\n```bash\nmkdir -p plugin-name/skills/skill-name/{references,examples,scripts}\ntouch plugin-name/skills/skill-name/SKILL.md\n```\n\n**Note:** Unlike the generic skill-creator which uses `init_skill.py`, plugin skills are created directly in the plugin's `skills/` directory with a simpler manual structure.\n\n### Step 4: Edit the Skill\n\nWhen editing the (newly-created or existing) skill, remember that the skill is being created for another instance of Claude to use. Focus on including information that would be beneficial and non-obvious to Claude. Consider what procedural knowledge, domain-specific details, or reusable assets would help another Claude instance execute these tasks more effectively.\n\n#### Start with Reusable Skill Contents\n\nTo begin implementation, start with the reusable resources identified above: `scripts/`, `references/`, and `assets/` files. Note that this step may require user input. For example, when implementing a `brand-guidelines` skill, the user may need to provide brand assets or templates to store in `assets/`, or documentation to store in `references/`.\n\nAlso, delete any example files and directories not needed for the skill. Create only the directories you actually need (references/, examples/, scripts/).\n\n#### Update SKILL.md\n\n**Writing Style:** Write the entire skill using **imperative/infinitive form** (verb-first instructions), not second person. Use objective, instructional language (e.g., \"To accomplish X, do Y\" rather than \"You should do X\" or \"If you need to do X\"). This maintains consistency and clarity for AI consumption.\n\n**Description (Frontmatter):** Use third-person format with specific trigger phrases:\n\n```yaml\n---\nname: Skill Name\ndescription: This skill should be used when the user asks to \"specific phrase 1\", \"specific phrase 2\", \"specific phrase 3\". Include exact phrases users would say that should trigger this skill. Be concrete and specific.\nversion: 0.1.0\n---\n```\n\n**Good description examples:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", \"implement prompt-based hooks\", or mentions hook events (PreToolUse, PostToolUse, Stop).\n```\n\n**Bad description examples:**\n```yaml\ndescription: Use this skill when working with hooks.  # Wrong person, vague\ndescription: Load when user needs hook help.  # Not third person\ndescription: Provides hook guidance.  # No trigger phrases\n```\n\nTo complete SKILL.md body, answer the following questions:\n\n1. What is the purpose of the skill, in a few sentences?\n2. When should the skill be used? (Include this in frontmatter description with specific triggers)\n3. In practice, how should Claude use the skill? All reusable skill contents developed above should be referenced so that Claude knows how to use them.\n\n**Keep SKILL.md lean:** Target 1,500-2,000 words for the body. Move detailed content to references/:\n- Detailed patterns â†’ `references/patterns.md`\n- Advanced techniques â†’ `references/advanced.md`\n- Migration guides â†’ `references/migration.md`\n- API references â†’ `references/api-reference.md`\n\n**Reference resources in SKILL.md:**\n```markdown\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and techniques, consult:\n- **`references/patterns.md`** - Common patterns\n- **`references/advanced.md`** - Advanced use cases\n\n### Example Files\n\nWorking examples in `examples/`:\n- **`example-script.sh`** - Working example\n```\n\n### Step 5: Validate and Test\n\n**For plugin skills, validation is different from generic skills:**\n\n1. **Check structure**: Skill directory in `plugin-name/skills/skill-name/`\n2. **Validate SKILL.md**: Has frontmatter with name and description\n3. **Check trigger phrases**: Description includes specific user queries\n4. **Verify writing style**: Body uses imperative/infinitive form, not second person\n5. **Test progressive disclosure**: SKILL.md is lean (~1,500-2,000 words), detailed content in references/\n6. **Check references**: All referenced files exist\n7. **Validate examples**: Examples are complete and correct\n8. **Test scripts**: Scripts are executable and work correctly\n\n**Use the skill-reviewer agent:**\n```\nAsk: \"Review my skill and check if it follows best practices\"\n```\n\nThe skill-reviewer agent will check description quality, content organization, and progressive disclosure.\n\n### Step 6: Iterate\n\nAfter testing the skill, users may request improvements. Often this happens right after using the skill, with fresh context of how the skill performed.\n\n**Iteration workflow:**\n1. Use the skill on real tasks\n2. Notice struggles or inefficiencies\n3. Identify how SKILL.md or bundled resources should be updated\n4. Implement changes and test again\n\n**Common improvements:**\n- Strengthen trigger phrases in description\n- Move long sections from SKILL.md to references/\n- Add missing examples or scripts\n- Clarify ambiguous instructions\n- Add edge case handling\n\n## Plugin-Specific Considerations\n\n### Skill Location in Plugins\n\nPlugin skills live in the plugin's `skills/` directory:\n\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/\nâ”œâ”€â”€ agents/\nâ””â”€â”€ skills/\n    â””â”€â”€ my-skill/\n        â”œâ”€â”€ SKILL.md\n        â”œâ”€â”€ references/\n        â”œâ”€â”€ examples/\n        â””â”€â”€ scripts/\n```\n\n### Auto-Discovery\n\nClaude Code automatically discovers skills:\n- Scans `skills/` directory\n- Finds subdirectories containing `SKILL.md`\n- Loads skill metadata (name + description) always\n- Loads SKILL.md body when skill triggers\n- Loads references/examples when needed\n\n### No Packaging Needed\n\nPlugin skills are distributed as part of the plugin, not as separate ZIP files. Users get skills when they install the plugin.\n\n### Testing in Plugins\n\nTest skills by installing plugin locally:\n\n```bash\n# Test with --plugin-dir\ncc --plugin-dir /path/to/plugin\n\n# Ask questions that should trigger the skill\n# Verify skill loads correctly\n```\n\n## Examples from Plugin-Dev\n\nStudy the skills in this plugin as examples of best practices:\n\n**hook-development skill:**\n- Excellent trigger phrases: \"create a hook\", \"add a PreToolUse hook\", etc.\n- Lean SKILL.md (1,651 words)\n- 3 references/ files for detailed content\n- 3 examples/ of working hooks\n- 3 scripts/ utilities\n\n**agent-development skill:**\n- Strong triggers: \"create an agent\", \"agent frontmatter\", etc.\n- Focused SKILL.md (1,438 words)\n- References include the AI generation prompt from Claude Code\n- Complete agent examples\n\n**plugin-settings skill:**\n- Specific triggers: \"plugin settings\", \".local.md files\", \"YAML frontmatter\"\n- References show real implementations (multi-agent-swarm, ralph-loop)\n- Working parsing scripts\n\nEach demonstrates progressive disclosure and strong triggering.\n\n## Progressive Disclosure in Practice\n\n### What Goes in SKILL.md\n\n**Include (always loaded when skill triggers):**\n- Core concepts and overview\n- Essential procedures and workflows\n- Quick reference tables\n- Pointers to references/examples/scripts\n- Most common use cases\n\n**Keep under 3,000 words, ideally 1,500-2,000 words**\n\n### What Goes in references/\n\n**Move to references/ (loaded as needed):**\n- Detailed patterns and advanced techniques\n- Comprehensive API documentation\n- Migration guides\n- Edge cases and troubleshooting\n- Extensive examples and walkthroughs\n\n**Each reference file can be large (2,000-5,000+ words)**\n\n### What Goes in examples/\n\n**Working code examples:**\n- Complete, runnable scripts\n- Configuration files\n- Template files\n- Real-world usage examples\n\n**Users can copy and adapt these directly**\n\n### What Goes in scripts/\n\n**Utility scripts:**\n- Validation tools\n- Testing helpers\n- Parsing utilities\n- Automation scripts\n\n**Should be executable and documented**\n\n## Writing Style Requirements\n\n### Imperative/Infinitive Form\n\nWrite using verb-first instructions, not second person:\n\n**Correct (imperative):**\n```\nTo create a hook, define the event type.\nConfigure the MCP server with authentication.\nValidate settings before use.\n```\n\n**Incorrect (second person):**\n```\nYou should create a hook by defining the event type.\nYou need to configure the MCP server.\nYou must validate settings before use.\n```\n\n### Third-Person in Description\n\nThe frontmatter description must use third person:\n\n**Correct:**\n```yaml\ndescription: This skill should be used when the user asks to \"create X\", \"configure Y\"...\n```\n\n**Incorrect:**\n```yaml\ndescription: Use this skill when you want to create X...\ndescription: Load this skill when user asks...\n```\n\n### Objective, Instructional Language\n\nFocus on what to do, not who should do it:\n\n**Correct:**\n```\nParse the frontmatter using sed.\nExtract fields with grep.\nValidate values before use.\n```\n\n**Incorrect:**\n```\nYou can parse the frontmatter...\nClaude should extract fields...\nThe user might validate values...\n```\n\n## Validation Checklist\n\nBefore finalizing a skill:\n\n**Structure:**\n- [ ] SKILL.md file exists with valid YAML frontmatter\n- [ ] Frontmatter has `name` and `description` fields\n- [ ] Markdown body is present and substantial\n- [ ] Referenced files actually exist\n\n**Description Quality:**\n- [ ] Uses third person (\"This skill should be used when...\")\n- [ ] Includes specific trigger phrases users would say\n- [ ] Lists concrete scenarios (\"create X\", \"configure Y\")\n- [ ] Not vague or generic\n\n**Content Quality:**\n- [ ] SKILL.md body uses imperative/infinitive form\n- [ ] Body is focused and lean (1,500-2,000 words ideal, <5k max)\n- [ ] Detailed content moved to references/\n- [ ] Examples are complete and working\n- [ ] Scripts are executable and documented\n\n**Progressive Disclosure:**\n- [ ] Core concepts in SKILL.md\n- [ ] Detailed docs in references/\n- [ ] Working code in examples/\n- [ ] Utilities in scripts/\n- [ ] SKILL.md references these resources\n\n**Testing:**\n- [ ] Skill triggers on expected user queries\n- [ ] Content is helpful for intended tasks\n- [ ] No duplicated information across files\n- [ ] References load when needed\n\n## Common Mistakes to Avoid\n\n### Mistake 1: Weak Trigger Description\n\nâŒ **Bad:**\n```yaml\ndescription: Provides guidance for working with hooks.\n```\n\n**Why bad:** Vague, no specific trigger phrases, not third person\n\nâœ… **Good:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", or mentions hook events. Provides comprehensive hooks API guidance.\n```\n\n**Why good:** Third person, specific phrases, concrete scenarios\n\n### Mistake 2: Too Much in SKILL.md\n\nâŒ **Bad:**\n```\nskill-name/\nâ””â”€â”€ SKILL.md  (8,000 words - everything in one file)\n```\n\n**Why bad:** Bloats context when skill loads, detailed content always loaded\n\nâœ… **Good:**\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md  (1,800 words - core essentials)\nâ””â”€â”€ references/\n    â”œâ”€â”€ patterns.md (2,500 words)\n    â””â”€â”€ advanced.md (3,700 words)\n```\n\n**Why good:** Progressive disclosure, detailed content loaded only when needed\n\n### Mistake 3: Second Person Writing\n\nâŒ **Bad:**\n```markdown\nYou should start by reading the configuration file.\nYou need to validate the input.\nYou can use the grep tool to search.\n```\n\n**Why bad:** Second person, not imperative form\n\nâœ… **Good:**\n```markdown\nStart by reading the configuration file.\nValidate the input before processing.\nUse the grep tool to search for patterns.\n```\n\n**Why good:** Imperative form, direct instructions\n\n### Mistake 4: Missing Resource References\n\nâŒ **Bad:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n[No mention of references/ or examples/]\n```\n\n**Why bad:** Claude doesn't know references exist\n\nâœ… **Good:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n## Additional Resources\n\n### Reference Files\n- **`references/patterns.md`** - Detailed patterns\n- **`references/advanced.md`** - Advanced techniques\n\n### Examples\n- **`examples/script.sh`** - Working example\n```\n\n**Why good:** Claude knows where to find additional information\n\n## Quick Reference\n\n### Minimal Skill\n\n```\nskill-name/\nâ””â”€â”€ SKILL.md\n```\n\nGood for: Simple knowledge, no complex resources needed\n\n### Standard Skill (Recommended)\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md\nâ”œâ”€â”€ references/\nâ”‚   â””â”€â”€ detailed-guide.md\nâ””â”€â”€ examples/\n    â””â”€â”€ working-example.sh\n```\n\nGood for: Most plugin skills with detailed documentation\n\n### Complete Skill\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md\nâ”œâ”€â”€ references/\nâ”‚   â”œâ”€â”€ patterns.md\nâ”‚   â””â”€â”€ advanced.md\nâ”œâ”€â”€ examples/\nâ”‚   â”œâ”€â”€ example1.sh\nâ”‚   â””â”€â”€ example2.json\nâ””â”€â”€ scripts/\n    â””â”€â”€ validate.sh\n```\n\nGood for: Complex domains with validation utilities\n\n## Best Practices Summary\n\nâœ… **DO:**\n- Use third-person in description (\"This skill should be used when...\")\n- Include specific trigger phrases (\"create X\", \"configure Y\")\n- Keep SKILL.md lean (1,500-2,000 words)\n- Use progressive disclosure (move details to references/)\n- Write in imperative/infinitive form\n- Reference supporting files clearly\n- Provide working examples\n- Create utility scripts for common operations\n- Study plugin-dev's skills as templates\n\nâŒ **DON'T:**\n- Use second person anywhere\n- Have vague trigger conditions\n- Put everything in SKILL.md (>3,000 words without references/)\n- Write in second person (\"You should...\")\n- Leave resources unreferenced\n- Include broken or incomplete examples\n- Skip validation\n\n## Additional Resources\n\n### Study These Skills\n\nPlugin-dev's skills demonstrate best practices:\n- `../hook-development/` - Progressive disclosure, utilities\n- `../agent-development/` - AI-assisted creation, references\n- `../mcp-integration/` - Comprehensive references\n- `../plugin-settings/` - Real-world examples\n- `../command-development/` - Clear critical concepts\n- `../plugin-structure/` - Good organization\n\n### Reference Files\n\nFor complete skill-creator methodology:\n- **`references/skill-creator-original.md`** - Full original skill-creator content\n\n## Implementation Workflow\n\nTo create a skill for your plugin:\n\n1. **Understand use cases**: Identify concrete examples of skill usage\n2. **Plan resources**: Determine what scripts/references/examples needed\n3. **Create structure**: `mkdir -p skills/skill-name/{references,examples,scripts}`\n4. **Write SKILL.md**:\n   - Frontmatter with third-person description and trigger phrases\n   - Lean body (1,500-2,000 words) in imperative form\n   - Reference supporting files\n5. **Add resources**: Create references/, examples/, scripts/ as needed\n6. **Validate**: Check description, writing style, organization\n7. **Test**: Verify skill loads on expected triggers\n8. **Iterate**: Improve based on usage\n\nFocus on strong trigger descriptions, progressive disclosure, and imperative writing style for effective skills that load when needed and provide targeted guidance."
              }
            ]
          },
          {
            "name": "asana",
            "description": "Asana project management integration. Create and manage tasks, search projects, update assignments, track progress, and integrate your development workflow with Asana's work management platform.",
            "source": "./external_plugins/asana",
            "category": "productivity",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install asana@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "linear",
            "description": "Linear issue tracking integration. Create issues, manage projects, update statuses, search across workspaces, and streamline your software development workflow with Linear's modern issue tracker.",
            "source": "./external_plugins/linear",
            "category": "productivity",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install linear@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "Notion",
            "description": "Notion workspace integration. Search pages, create and update documents, manage databases, and access your team's knowledge base directly from Claude Code for seamless documentation workflows.",
            "source": {
              "source": "url",
              "url": "https://github.com/makenotion/claude-code-notion-plugin.git"
            },
            "category": "productivity",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install Notion@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [
              {
                "name": "/explain-error",
                "description": "Explain Stripe error codes and provide solutions with code examples",
                "path": "external_plugins/stripe/commands/explain-error.md",
                "frontmatter": {
                  "description": "Explain Stripe error codes and provide solutions with code examples",
                  "argument-hint": [
                    "error_code or error_message"
                  ]
                },
                "content": "# Explain Stripe Error\n\nProvide a comprehensive explanation of the given Stripe error code or error message:\n\n1. Accept the error code or full error message from the arguments\n2. Explain in plain English what the error means\n3. List common causes of this error\n4. Provide specific solutions and handling recommendations\n5. Generate error handling code in the project's language showing:\n   - How to catch this specific error\n   - User-friendly error messages\n   - Whether retry is appropriate\n6. Mention related error codes the developer should be aware of\n7. Include a link to the relevant Stripe documentation\n\nFocus on actionable solutions and production-ready error handling patterns."
              },
              {
                "name": "/test-cards",
                "description": "Display Stripe test card numbers for various testing scenarios",
                "path": "external_plugins/stripe/commands/test-cards.md",
                "frontmatter": {
                  "description": "Display Stripe test card numbers for various testing scenarios",
                  "argument-hint": [
                    "scenario"
                  ]
                },
                "content": "# Test Cards Reference\n\nProvide a quick reference for Stripe test card numbers:\n\n1. If a scenario argument is provided (e.g., \"declined\", \"3dsecure\", \"fraud\"), show relevant test cards for that scenario\n2. Otherwise, show the most common test cards organized by category:\n   - Successful payment (default card)\n   - 3D Secure authentication required\n   - Generic decline\n   - Specific decline reasons (insufficient_funds, lost_card, etc.)\n3. For each card, display:\n   - Card number (formatted with spaces)\n   - Expected behavior\n   - Expiry/CVC info (any future date and any 3-digit CVC)\n4. Use clear visual indicators (âœ“ for success, âš ï¸ for auth required, âœ— for decline)\n5. Mention that these only work in test mode\n6. Provide link to full testing documentation: https://docs.stripe.com/testing.md\n\nIf the user is currently working on test code, offer to generate test cases using these cards."
              },
              {
                "name": "/new-sdk-app",
                "description": "Create and setup a new Claude Agent SDK application",
                "path": "plugins/agent-sdk-dev/commands/new-sdk-app.md",
                "frontmatter": {
                  "description": "Create and setup a new Claude Agent SDK application",
                  "argument-hint": [
                    "project-name"
                  ]
                },
                "content": "You are tasked with helping the user create a new Claude Agent SDK application. Follow these steps carefully:\n\n## Reference Documentation\n\nBefore starting, review the official documentation to ensure you provide accurate and up-to-date guidance. Use WebFetch to read these pages:\n\n1. **Start with the overview**: https://docs.claude.com/en/api/agent-sdk/overview\n2. **Based on the user's language choice, read the appropriate SDK reference**:\n   - TypeScript: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Python: https://docs.claude.com/en/api/agent-sdk/python\n3. **Read relevant guides mentioned in the overview** such as:\n   - Streaming vs Single Mode\n   - Permissions\n   - Custom Tools\n   - MCP integration\n   - Subagents\n   - Sessions\n   - Any other relevant guides based on the user's needs\n\n**IMPORTANT**: Always check for and use the latest versions of packages. Use WebSearch or WebFetch to verify current versions before installation.\n\n## Gather Requirements\n\nIMPORTANT: Ask these questions one at a time. Wait for the user's response before asking the next question. This makes it easier for the user to respond.\n\nAsk the questions in this order (skip any that the user has already provided via arguments):\n\n1. **Language** (ask first): \"Would you like to use TypeScript or Python?\"\n\n   - Wait for response before continuing\n\n2. **Project name** (ask second): \"What would you like to name your project?\"\n\n   - If $ARGUMENTS is provided, use that as the project name and skip this question\n   - Wait for response before continuing\n\n3. **Agent type** (ask third, but skip if #2 was sufficiently detailed): \"What kind of agent are you building? Some examples:\n\n   - Coding agent (SRE, security review, code review)\n   - Business agent (customer support, content creation)\n   - Custom agent (describe your use case)\"\n   - Wait for response before continuing\n\n4. **Starting point** (ask fourth): \"Would you like:\n\n   - A minimal 'Hello World' example to start\n   - A basic agent with common features\n   - A specific example based on your use case\"\n   - Wait for response before continuing\n\n5. **Tooling choice** (ask fifth): Let the user know what tools you'll use, and confirm with them that these are the tools they want to use (for example, they may prefer pnpm or bun over npm). Respect the user's preferences when executing on the requirements.\n\nAfter all questions are answered, proceed to create the setup plan.\n\n## Setup Plan\n\nBased on the user's answers, create a plan that includes:\n\n1. **Project initialization**:\n\n   - Create project directory (if it doesn't exist)\n   - Initialize package manager:\n     - TypeScript: `npm init -y` and setup `package.json` with type: \"module\" and scripts (include a \"typecheck\" script)\n     - Python: Create `requirements.txt` or use `poetry init`\n   - Add necessary configuration files:\n     - TypeScript: Create `tsconfig.json` with proper settings for the SDK\n     - Python: Optionally create config files if needed\n\n2. **Check for Latest Versions**:\n\n   - BEFORE installing, use WebSearch or check npm/PyPI to find the latest version\n   - For TypeScript: Check https://www.npmjs.com/package/@anthropic-ai/claude-agent-sdk\n   - For Python: Check https://pypi.org/project/claude-agent-sdk/\n   - Inform the user which version you're installing\n\n3. **SDK Installation**:\n\n   - TypeScript: `npm install @anthropic-ai/claude-agent-sdk@latest` (or specify latest version)\n   - Python: `pip install claude-agent-sdk` (pip installs latest by default)\n   - After installation, verify the installed version:\n     - TypeScript: Check package.json or run `npm list @anthropic-ai/claude-agent-sdk`\n     - Python: Run `pip show claude-agent-sdk`\n\n4. **Create starter files**:\n\n   - TypeScript: Create an `index.ts` or `src/index.ts` with a basic query example\n   - Python: Create a `main.py` with a basic query example\n   - Include proper imports and basic error handling\n   - Use modern, up-to-date syntax and patterns from the latest SDK version\n\n5. **Environment setup**:\n\n   - Create a `.env.example` file with `ANTHROPIC_API_KEY=your_api_key_here`\n   - Add `.env` to `.gitignore`\n   - Explain how to get an API key from https://console.anthropic.com/\n\n6. **Optional: Create .claude directory structure**:\n   - Offer to create `.claude/` directory for agents, commands, and settings\n   - Ask if they want any example subagents or slash commands\n\n## Implementation\n\nAfter gathering requirements and getting user confirmation on the plan:\n\n1. Check for latest package versions using WebSearch or WebFetch\n2. Execute the setup steps\n3. Create all necessary files\n4. Install dependencies (always use latest stable versions)\n5. Verify installed versions and inform the user\n6. Create a working example based on their agent type\n7. Add helpful comments in the code explaining what each part does\n8. **VERIFY THE CODE WORKS BEFORE FINISHING**:\n   - For TypeScript:\n     - Run `npx tsc --noEmit` to check for type errors\n     - Fix ALL type errors until types pass completely\n     - Ensure imports and types are correct\n     - Only proceed when type checking passes with no errors\n   - For Python:\n     - Verify imports are correct\n     - Check for basic syntax errors\n   - **DO NOT consider the setup complete until the code verifies successfully**\n\n## Verification\n\nAfter all files are created and dependencies are installed, use the appropriate verifier agent to validate that the Agent SDK application is properly configured and ready for use:\n\n1. **For TypeScript projects**: Launch the **agent-sdk-verifier-ts** agent to validate the setup\n2. **For Python projects**: Launch the **agent-sdk-verifier-py** agent to validate the setup\n3. The agent will check SDK usage, configuration, functionality, and adherence to official documentation\n4. Review the verification report and address any issues\n\n## Getting Started Guide\n\nOnce setup is complete and verified, provide the user with:\n\n1. **Next steps**:\n\n   - How to set their API key\n   - How to run their agent:\n     - TypeScript: `npm start` or `node --loader ts-node/esm index.ts`\n     - Python: `python main.py`\n\n2. **Useful resources**:\n\n   - Link to TypeScript SDK reference: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Link to Python SDK reference: https://docs.claude.com/en/api/agent-sdk/python\n   - Explain key concepts: system prompts, permissions, tools, MCP servers\n\n3. **Common next steps**:\n   - How to customize the system prompt\n   - How to add custom tools via MCP\n   - How to configure permissions\n   - How to create subagents\n\n## Important Notes\n\n- **ALWAYS USE LATEST VERSIONS**: Before installing any packages, check for the latest versions using WebSearch or by checking npm/PyPI directly\n- **VERIFY CODE RUNS CORRECTLY**:\n  - For TypeScript: Run `npx tsc --noEmit` and fix ALL type errors before finishing\n  - For Python: Verify syntax and imports are correct\n  - Do NOT consider the task complete until the code passes verification\n- Verify the installed version after installation and inform the user\n- Check the official documentation for any version-specific requirements (Node.js version, Python version, etc.)\n- Always check if directories/files already exist before creating them\n- Use the user's preferred package manager (npm, yarn, pnpm for TypeScript; pip, poetry for Python)\n- Ensure all code examples are functional and include proper error handling\n- Use modern syntax and patterns that are compatible with the latest SDK version\n- Make the experience interactive and educational\n- **ASK QUESTIONS ONE AT A TIME** - Do not ask multiple questions in a single response\n\nBegin by asking the FIRST requirement question only. Wait for the user's answer before proceeding to the next question."
              },
              {
                "name": "/code-review",
                "description": "Code review a pull request",
                "path": "plugins/code-review/commands/code-review.md",
                "frontmatter": {
                  "allowed-tools": "Bash(gh issue view:*), Bash(gh search:*), Bash(gh issue list:*), Bash(gh pr comment:*), Bash(gh pr diff:*), Bash(gh pr view:*), Bash(gh pr list:*)",
                  "description": "Code review a pull request",
                  "disable-model-invocation": false
                },
                "content": "Provide a code review for the given pull request.\n\nTo do this, follow these steps precisely:\n\n1. Use a Haiku agent to check if the pull request (a) is closed, (b) is a draft, (c) does not need a code review (eg. because it is an automated pull request, or is very simple and obviously ok), or (d) already has a code review from you from earlier. If so, do not proceed.\n2. Use another Haiku agent to give you a list of file paths to (but not the contents of) any relevant CLAUDE.md files from the codebase: the root CLAUDE.md file (if one exists), as well as any CLAUDE.md files in the directories whose files the pull request modified\n3. Use a Haiku agent to view the pull request, and ask the agent to return a summary of the change\n4. Then, launch 5 parallel Sonnet agents to independently code review the change. The agents should do the following, then return a list of issues and the reason each issue was flagged (eg. CLAUDE.md adherence, bug, historical git context, etc.):\n   a. Agent #1: Audit the changes to make sure they compily with the CLAUDE.md. Note that CLAUDE.md is guidance for Claude as it writes code, so not all instructions will be applicable during code review.\n   b. Agent #2: Read the file changes in the pull request, then do a shallow scan for obvious bugs. Avoid reading extra context beyond the changes, focusing just on the changes themselves. Focus on large bugs, and avoid small issues and nitpicks. Ignore likely false positives.\n   c. Agent #3: Read the git blame and history of the code modified, to identify any bugs in light of that historical context\n   d. Agent #4: Read previous pull requests that touched these files, and check for any comments on those pull requests that may also apply to the current pull request.\n   e. Agent #5: Read code comments in the modified files, and make sure the changes in the pull request comply with any guidance in the comments.\n5. For each issue found in #4, launch a parallel Haiku agent that takes the PR, issue description, and list of CLAUDE.md files (from step 2), and returns a score to indicate the agent's level of confidence for whether the issue is real or false positive. To do that, the agent should score each issue on a scale from 0-100, indicating its level of confidence. For issues that were flagged due to CLAUDE.md instructions, the agent should double check that the CLAUDE.md actually calls out that issue specifically. The scale is (give this rubric to the agent verbatim):\n   a. 0: Not confident at all. This is a false positive that doesn't stand up to light scrutiny, or is a pre-existing issue.\n   b. 25: Somewhat confident. This might be a real issue, but may also be a false positive. The agent wasn't able to verify that it's a real issue. If the issue is stylistic, it is one that was not explicitly called out in the relevant CLAUDE.md.\n   c. 50: Moderately confident. The agent was able to verify this is a real issue, but it might be a nitpick or not happen very often in practice. Relative to the rest of the PR, it's not very important.\n   d. 75: Highly confident. The agent double checked the issue, and verified that it is very likely it is a real issue that will be hit in practice. The existing approach in the PR is insufficient. The issue is very important and will directly impact the code's functionality, or it is an issue that is directly mentioned in the relevant CLAUDE.md.\n   e. 100: Absolutely certain. The agent double checked the issue, and confirmed that it is definitely a real issue, that will happen frequently in practice. The evidence directly confirms this.\n6. Filter out any issues with a score less than 80. If there are no issues that meet this criteria, do not proceed.\n7. Use a Haiku agent to repeat the eligibility check from #1, to make sure that the pull request is still eligible for code review.\n8. Finally, use the gh bash command to comment back on the pull request with the result. When writing your comment, keep in mind to:\n   a. Keep your output brief\n   b. Avoid emojis\n   c. Link and cite relevant code, files, and URLs\n\nExamples of false positives, for steps 4 and 5:\n\n- Pre-existing issues\n- Something that looks like a bug but is not actually a bug\n- Pedantic nitpicks that a senior engineer wouldn't call out\n- Issues that a linter, typechecker, or compiler would catch (eg. missing or incorrect imports, type errors, broken tests, formatting issues, pedantic style issues like newlines). No need to run these build steps yourself -- it is safe to assume that they will be run separately as part of CI.\n- General code quality issues (eg. lack of test coverage, general security issues, poor documentation), unless explicitly required in CLAUDE.md\n- Issues that are called out in CLAUDE.md, but explicitly silenced in the code (eg. due to a lint ignore comment)\n- Changes in functionality that are likely intentional or are directly related to the broader change\n- Real issues, but on lines that the user did not modify in their pull request\n\nNotes:\n\n- Do not check build signal or attempt to build or typecheck the app. These will run separately, and are not relevant to your code review.\n- Use `gh` to interact with Github (eg. to fetch a pull request, or to create inline comments), rather than web fetch\n- Make a todo list first\n- You must cite and link each bug (eg. if referring to a CLAUDE.md, you must link it)\n- For your final comment, follow the following format precisely (assuming for this example that you found 3 issues):\n\n---\n\n### Code review\n\nFound 3 issues:\n\n1. <brief description of bug> (CLAUDE.md says \"<...>\")\n\n<link to file and line with full sha1 + line range for context, note that you MUST provide the full sha and not use bash here, eg. https://github.com/anthropics/claude-code/blob/1d54823877c4de72b2316a64032a54afc404e619/README.md#L13-L17>\n\n2. <brief description of bug> (some/other/CLAUDE.md says \"<...>\")\n\n<link to file and line with full sha1 + line range for context>\n\n3. <brief description of bug> (bug due to <file and code snippet>)\n\n<link to file and line with full sha1 + line range for context>\n\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\n<sub>- If this code review was useful, please react with ðŸ‘. Otherwise, react with ðŸ‘Ž.</sub>\n\n---\n\n- Or, if you found no issues:\n\n---\n\n### Code review\n\nNo issues found. Checked for bugs and CLAUDE.md compliance.\n\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\n- When linking to code, follow the following format precisely, otherwise the Markdown preview won't render correctly: https://github.com/anthropics/claude-cli-internal/blob/c21d3c10bc8e898b7ac1a2d745bdc9bc4e423afe/package.json#L10-L15\n  - Requires full git sha\n  - You must provide the full sha. Commands like `https://github.com/owner/repo/blob/$(git rev-parse HEAD)/foo/bar` will not work, since your comment will be directly rendered in Markdown.\n  - Repo name must match the repo you're code reviewing\n  - # sign after the file name\n  - Line range format is L[start]-L[end]\n  - Provide at least 1 line of context before and after, centered on the line you are commenting about (eg. if you are commenting about lines 5-6, you should link to `L4-7`)"
              },
              {
                "name": "/clean_gone",
                "description": "Cleans up all git branches marked as [gone] (branches that have been deleted on the remote but still exist locally), including removing associated worktrees.",
                "path": "plugins/commit-commands/commands/clean_gone.md",
                "frontmatter": {
                  "description": "Cleans up all git branches marked as [gone] (branches that have been deleted on the remote but still exist locally), including removing associated worktrees."
                },
                "content": "## Your Task\n\nYou need to execute the following bash commands to clean up stale local branches that have been deleted from the remote repository.\n\n## Commands to Execute\n\n1. **First, list branches to identify any with [gone] status**\n   Execute this command:\n   ```bash\n   git branch -v\n   ```\n   \n   Note: Branches with a '+' prefix have associated worktrees and must have their worktrees removed before deletion.\n\n2. **Next, identify worktrees that need to be removed for [gone] branches**\n   Execute this command:\n   ```bash\n   git worktree list\n   ```\n\n3. **Finally, remove worktrees and delete [gone] branches (handles both regular and worktree branches)**\n   Execute this command:\n   ```bash\n   # Process all [gone] branches, removing '+' prefix if present\n   git branch -v | grep '\\[gone\\]' | sed 's/^[+* ]//' | awk '{print $1}' | while read branch; do\n     echo \"Processing branch: $branch\"\n     # Find and remove worktree if it exists\n     worktree=$(git worktree list | grep \"\\\\[$branch\\\\]\" | awk '{print $1}')\n     if [ ! -z \"$worktree\" ] && [ \"$worktree\" != \"$(git rev-parse --show-toplevel)\" ]; then\n       echo \"  Removing worktree: $worktree\"\n       git worktree remove --force \"$worktree\"\n     fi\n     # Delete the branch\n     echo \"  Deleting branch: $branch\"\n     git branch -D \"$branch\"\n   done\n   ```\n\n## Expected Behavior\n\nAfter executing these commands, you will:\n\n- See a list of all local branches with their status\n- Identify and remove any worktrees associated with [gone] branches\n- Delete all branches marked as [gone]\n- Provide feedback on which worktrees and branches were removed\n\nIf no branches are marked as [gone], report that no cleanup was needed."
              },
              {
                "name": "/commit-push-pr",
                "description": "Commit, push, and open a PR",
                "path": "plugins/commit-commands/commands/commit-push-pr.md",
                "frontmatter": {
                  "allowed-tools": "Bash(git checkout --branch:*), Bash(git add:*), Bash(git status:*), Bash(git push:*), Bash(git commit:*), Bash(gh pr create:*)",
                  "description": "Commit, push, and open a PR"
                },
                "content": "## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n\n## Your task\n\nBased on the above changes:\n\n1. Create a new branch if on main\n2. Create a single commit with an appropriate message\n3. Push the branch to origin\n4. Create a pull request using `gh pr create`\n5. You have the capability to call multiple tools in a single response. You MUST do all of the above in a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls."
              },
              {
                "name": "/commit",
                "description": "Create a git commit",
                "path": "plugins/commit-commands/commands/commit.md",
                "frontmatter": {
                  "allowed-tools": "Bash(git add:*), Bash(git status:*), Bash(git commit:*)",
                  "description": "Create a git commit"
                },
                "content": "## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n- Recent commits: !`git log --oneline -10`\n\n## Your task\n\nBased on the above changes, create a single git commit.\n\nYou have the capability to call multiple tools in a single response. Stage and create the commit using a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls."
              },
              {
                "name": "/example-command",
                "description": "An example slash command that demonstrates command frontmatter options",
                "path": "plugins/example-plugin/commands/example-command.md",
                "frontmatter": {
                  "description": "An example slash command that demonstrates command frontmatter options",
                  "argument-hint": "<required-arg> [optional-arg]",
                  "allowed-tools": [
                    "Read",
                    "Glob",
                    "Grep",
                    "Bash"
                  ]
                },
                "content": "# Example Command\n\nThis command demonstrates slash command structure and frontmatter options.\n\n## Arguments\n\nThe user invoked this command with: $ARGUMENTS\n\n## Instructions\n\nWhen this command is invoked:\n\n1. Parse the arguments provided by the user\n2. Perform the requested action using allowed tools\n3. Report results back to the user\n\n## Frontmatter Options Reference\n\nCommands support these frontmatter fields:\n\n- **description**: Short description shown in /help\n- **argument-hint**: Hints for command arguments shown to user\n- **allowed-tools**: Pre-approved tools for this command (reduces permission prompts)\n- **model**: Override the model (e.g., \"haiku\", \"sonnet\", \"opus\")\n\n## Example Usage\n\n```\n/example-command my-argument\n/example-command arg1 arg2\n```"
              },
              {
                "name": "/feature-dev",
                "description": "Guided feature development with codebase understanding and architecture focus",
                "path": "plugins/feature-dev/commands/feature-dev.md",
                "frontmatter": {
                  "description": "Guided feature development with codebase understanding and architecture focus",
                  "argument-hint": "Optional feature description"
                },
                "content": "# Feature Development\n\nYou are helping a developer implement a new feature. Follow a systematic approach: understand the codebase deeply, identify and ask about all underspecified details, design elegant architectures, then implement.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities, edge cases, and underspecified behaviors. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation. Ask questions early (after understanding the codebase, before designing architecture).\n- **Understand before acting**: Read and comprehend existing code patterns first\n- **Read files identified by agents**: When launching agents, ask them to return lists of the most important files to read. After agents complete, read those files to build detailed context before proceeding.\n- **Simple and elegant**: Prioritize readable, maintainable, architecturally sound code\n- **Use TodoWrite**: Track all progress throughout\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what needs to be built\n\nInitial request: $ARGUMENTS\n\n**Actions**:\n1. Create todo list with all phases\n2. If feature unclear, ask user for:\n   - What problem are they solving?\n   - What should the feature do?\n   - Any constraints or requirements?\n3. Summarize understanding and confirm with user\n\n---\n\n## Phase 2: Codebase Exploration\n\n**Goal**: Understand relevant existing code and patterns at both high and low levels\n\n**Actions**:\n1. Launch 2-3 code-explorer agents in parallel. Each agent should:\n   - Trace through the code comprehensively and focus on getting a comprehensive understanding of abstractions, architecture and flow of control\n   - Target a different aspect of the codebase (eg. similar features, high level understanding, architectural understanding, user experience, etc)\n   - Include a list of 5-10 key files to read\n\n   **Example agent prompts**:\n   - \"Find features similar to [feature] and trace through their implementation comprehensively\"\n   - \"Map the architecture and abstractions for [feature area], tracing through the code comprehensively\"\n   - \"Analyze the current implementation of [existing feature/area], tracing through the code comprehensively\"\n   - \"Identify UI patterns, testing approaches, or extension points relevant to [feature]\"\n\n2. Once the agents return, please read all files identified by agents to build deep understanding\n3. Present comprehensive summary of findings and patterns discovered\n\n---\n\n## Phase 3: Clarifying Questions\n\n**Goal**: Fill in gaps and resolve all ambiguities before designing\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. Review the codebase findings and original feature request\n2. Identify underspecified aspects: edge cases, error handling, integration points, scope boundaries, design preferences, backward compatibility, performance needs\n3. **Present all questions to the user in a clear, organized list**\n4. **Wait for answers before proceeding to architecture design**\n\nIf the user says \"whatever you think is best\", provide your recommendation and get explicit confirmation.\n\n---\n\n## Phase 4: Architecture Design\n\n**Goal**: Design multiple implementation approaches with different trade-offs\n\n**Actions**:\n1. Launch 2-3 code-architect agents in parallel with different focuses: minimal changes (smallest change, maximum reuse), clean architecture (maintainability, elegant abstractions), or pragmatic balance (speed + quality)\n2. Review all approaches and form your opinion on which fits best for this specific task (consider: small fix vs large feature, urgency, complexity, team context)\n3. Present to user: brief summary of each approach, trade-offs comparison, **your recommendation with reasoning**, concrete implementation differences\n4. **Ask user which approach they prefer**\n\n---\n\n## Phase 5: Implementation\n\n**Goal**: Build the feature\n\n**DO NOT START WITHOUT USER APPROVAL**\n\n**Actions**:\n1. Wait for explicit user approval\n2. Read all relevant files identified in previous phases\n3. Implement following chosen architecture\n4. Follow codebase conventions strictly\n5. Write clean, well-documented code\n6. Update todos as you progress\n\n---\n\n## Phase 6: Quality Review\n\n**Goal**: Ensure code is simple, DRY, elegant, easy to read, and functionally correct\n\n**Actions**:\n1. Launch 3 code-reviewer agents in parallel with different focuses: simplicity/DRY/elegance, bugs/functional correctness, project conventions/abstractions\n2. Consolidate findings and identify highest severity issues that you recommend fixing\n3. **Present findings to user and ask what they want to do** (fix now, fix later, or proceed as-is)\n4. Address issues based on user decision\n\n---\n\n## Phase 7: Summary\n\n**Goal**: Document what was accomplished\n\n**Actions**:\n1. Mark all todos complete\n2. Summarize:\n   - What was built\n   - Key decisions made\n   - Files modified\n   - Suggested next steps\n\n---"
              },
              {
                "name": "/configure",
                "description": "Enable or disable hookify rules interactively",
                "path": "plugins/hookify/commands/configure.md",
                "frontmatter": {
                  "description": "Enable or disable hookify rules interactively",
                  "allowed-tools": [
                    "Glob",
                    "Read",
                    "Edit",
                    "AskUserQuestion",
                    "Skill"
                  ]
                },
                "content": "# Configure Hookify Rules\n\n**Load hookify:writing-rules skill first** to understand rule format.\n\nEnable or disable existing hookify rules using an interactive interface.\n\n## Steps\n\n### 1. Find Existing Rules\n\nUse Glob tool to find all hookify rule files:\n```\npattern: \".claude/hookify.*.local.md\"\n```\n\nIf no rules found, inform user:\n```\nNo hookify rules configured yet. Use `/hookify` to create your first rule.\n```\n\n### 2. Read Current State\n\nFor each rule file:\n- Read the file\n- Extract `name` and `enabled` fields from frontmatter\n- Build list of rules with current state\n\n### 3. Ask User Which Rules to Toggle\n\nUse AskUserQuestion to let user select rules:\n\n```json\n{\n  \"questions\": [\n    {\n      \"question\": \"Which rules would you like to enable or disable?\",\n      \"header\": \"Configure\",\n      \"multiSelect\": true,\n      \"options\": [\n        {\n          \"label\": \"warn-dangerous-rm (currently enabled)\",\n          \"description\": \"Warns about rm -rf commands\"\n        },\n        {\n          \"label\": \"warn-console-log (currently disabled)\",\n          \"description\": \"Warns about console.log in code\"\n        },\n        {\n          \"label\": \"require-tests (currently enabled)\",\n          \"description\": \"Requires tests before stopping\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Option format:**\n- Label: `{rule-name} (currently {enabled|disabled})`\n- Description: Brief description from rule's message or pattern\n\n### 4. Parse User Selection\n\nFor each selected rule:\n- Determine current state from label (enabled/disabled)\n- Toggle state: enabled â†’ disabled, disabled â†’ enabled\n\n### 5. Update Rule Files\n\nFor each rule to toggle:\n- Use Read tool to read current content\n- Use Edit tool to change `enabled: true` to `enabled: false` (or vice versa)\n- Handle both with and without quotes\n\n**Edit pattern for enabling:**\n```\nold_string: \"enabled: false\"\nnew_string: \"enabled: true\"\n```\n\n**Edit pattern for disabling:**\n```\nold_string: \"enabled: true\"\nnew_string: \"enabled: false\"\n```\n\n### 6. Confirm Changes\n\nShow user what was changed:\n\n```\n## Hookify Rules Updated\n\n**Enabled:**\n- warn-console-log\n\n**Disabled:**\n- warn-dangerous-rm\n\n**Unchanged:**\n- require-tests\n\nChanges apply immediately - no restart needed\n```\n\n## Important Notes\n\n- Changes take effect immediately on next tool use\n- You can also manually edit .claude/hookify.*.local.md files\n- To permanently remove a rule, delete its .local.md file\n- Use `/hookify:list` to see all configured rules\n\n## Edge Cases\n\n**No rules to configure:**\n- Show message about using `/hookify` to create rules first\n\n**User selects no rules:**\n- Inform that no changes were made\n\n**File read/write errors:**\n- Inform user of specific error\n- Suggest manual editing as fallback"
              },
              {
                "name": "/help",
                "description": "Get help with the hookify plugin",
                "path": "plugins/hookify/commands/help.md",
                "frontmatter": {
                  "description": "Get help with the hookify plugin",
                  "allowed-tools": [
                    "Read"
                  ]
                },
                "content": "# Hookify Plugin Help\n\nExplain how the hookify plugin works and how to use it.\n\n## Overview\n\nThe hookify plugin makes it easy to create custom hooks that prevent unwanted behaviors. Instead of editing `hooks.json` files, users create simple markdown configuration files that define patterns to watch for.\n\n## How It Works\n\n### 1. Hook System\n\nHookify installs generic hooks that run on these events:\n- **PreToolUse**: Before any tool executes (Bash, Edit, Write, etc.)\n- **PostToolUse**: After a tool executes\n- **Stop**: When Claude wants to stop working\n- **UserPromptSubmit**: When user submits a prompt\n\nThese hooks read configuration files from `.claude/hookify.*.local.md` and check if any rules match the current operation.\n\n### 2. Configuration Files\n\nUsers create rules in `.claude/hookify.{rule-name}.local.md` files:\n\n```markdown\n---\nname: warn-dangerous-rm\nenabled: true\nevent: bash\npattern: rm\\s+-rf\n---\n\nâš ï¸ **Dangerous rm command detected!**\n\nThis command could delete important files. Please verify the path.\n```\n\n**Key fields:**\n- `name`: Unique identifier for the rule\n- `enabled`: true/false to activate/deactivate\n- `event`: bash, file, stop, prompt, or all\n- `pattern`: Regex pattern to match\n\nThe message body is what Claude sees when the rule triggers.\n\n### 3. Creating Rules\n\n**Option A: Use /hookify command**\n```\n/hookify Don't use console.log in production files\n```\n\nThis analyzes your request and creates the appropriate rule file.\n\n**Option B: Create manually**\nCreate `.claude/hookify.my-rule.local.md` with the format above.\n\n**Option C: Analyze conversation**\n```\n/hookify\n```\n\nWithout arguments, hookify analyzes recent conversation to find behaviors you want to prevent.\n\n## Available Commands\n\n- **`/hookify`** - Create hooks from conversation analysis or explicit instructions\n- **`/hookify:help`** - Show this help (what you're reading now)\n- **`/hookify:list`** - List all configured hooks\n- **`/hookify:configure`** - Enable/disable existing hooks interactively\n\n## Example Use Cases\n\n**Prevent dangerous commands:**\n```markdown\n---\nname: block-chmod-777\nenabled: true\nevent: bash\npattern: chmod\\s+777\n---\n\nDon't use chmod 777 - it's a security risk. Use specific permissions instead.\n```\n\n**Warn about debugging code:**\n```markdown\n---\nname: warn-console-log\nenabled: true\nevent: file\npattern: console\\.log\\(\n---\n\nConsole.log detected. Remember to remove debug logging before committing.\n```\n\n**Require tests before stopping:**\n```markdown\n---\nname: require-tests\nenabled: true\nevent: stop\npattern: .*\n---\n\nDid you run tests before finishing? Make sure `npm test` or equivalent was executed.\n```\n\n## Pattern Syntax\n\nUse Python regex syntax:\n- `\\s` - whitespace\n- `\\.` - literal dot\n- `|` - OR\n- `+` - one or more\n- `*` - zero or more\n- `\\d` - digit\n- `[abc]` - character class\n\n**Examples:**\n- `rm\\s+-rf` - matches \"rm -rf\"\n- `console\\.log\\(` - matches \"console.log(\"\n- `(eval|exec)\\(` - matches \"eval(\" or \"exec(\"\n- `\\.env$` - matches files ending in .env\n\n## Important Notes\n\n**No Restart Needed**: Hookify rules (`.local.md` files) take effect immediately on the next tool use. The hookify hooks are already loaded and read your rules dynamically.\n\n**Block or Warn**: Rules can either `block` operations (prevent execution) or `warn` (show message but allow). Set `action: block` or `action: warn` in the rule's frontmatter.\n\n**Rule Files**: Keep rules in `.claude/hookify.*.local.md` - they should be git-ignored (add to .gitignore if needed).\n\n**Disable Rules**: Set `enabled: false` in frontmatter or delete the file.\n\n## Troubleshooting\n\n**Hook not triggering:**\n- Check rule file is in `.claude/` directory\n- Verify `enabled: true` in frontmatter\n- Confirm pattern is valid regex\n- Test pattern: `python3 -c \"import re; print(re.search('your_pattern', 'test_text'))\"`\n- Rules take effect immediately - no restart needed\n\n**Import errors:**\n- Check Python 3 is available: `python3 --version`\n- Verify hookify plugin is installed correctly\n\n**Pattern not matching:**\n- Test regex separately\n- Check for escaping issues (use unquoted patterns in YAML)\n- Try simpler pattern first, then refine\n\n## Getting Started\n\n1. Create your first rule:\n   ```\n   /hookify Warn me when I try to use rm -rf\n   ```\n\n2. Try to trigger it:\n   - Ask Claude to run `rm -rf /tmp/test`\n   - You should see the warning\n\n4. Refine the rule by editing `.claude/hookify.warn-rm.local.md`\n\n5. Create more rules as you encounter unwanted behaviors\n\nFor more examples, check the `${CLAUDE_PLUGIN_ROOT}/examples/` directory."
              },
              {
                "name": "/hookify",
                "description": "Create hooks to prevent unwanted behaviors from conversation analysis or explicit instructions",
                "path": "plugins/hookify/commands/hookify.md",
                "frontmatter": {
                  "description": "Create hooks to prevent unwanted behaviors from conversation analysis or explicit instructions",
                  "argument-hint": "Optional specific behavior to address",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "AskUserQuestion",
                    "Task",
                    "Grep",
                    "TodoWrite",
                    "Skill"
                  ]
                },
                "content": "# Hookify - Create Hooks from Unwanted Behaviors\n\n**FIRST: Load the hookify:writing-rules skill** using the Skill tool to understand rule file format and syntax.\n\nCreate hook rules to prevent problematic behaviors by analyzing the conversation or from explicit user instructions.\n\n## Your Task\n\nYou will help the user create hookify rules to prevent unwanted behaviors. Follow these steps:\n\n### Step 1: Gather Behavior Information\n\n**If $ARGUMENTS is provided:**\n- User has given specific instructions: `$ARGUMENTS`\n- Still analyze recent conversation (last 10-15 user messages) for additional context\n- Look for examples of the behavior happening\n\n**If $ARGUMENTS is empty:**\n- Launch the conversation-analyzer agent to find problematic behaviors\n- Agent will scan user prompts for frustration signals\n- Agent will return structured findings\n\n**To analyze conversation:**\nUse the Task tool to launch conversation-analyzer agent:\n```\n{\n  \"subagent_type\": \"general-purpose\",\n  \"description\": \"Analyze conversation for unwanted behaviors\",\n  \"prompt\": \"You are analyzing a Claude Code conversation to find behaviors the user wants to prevent.\n\nRead user messages in the current conversation and identify:\n1. Explicit requests to avoid something (\\\"don't do X\\\", \\\"stop doing Y\\\")\n2. Corrections or reversions (user fixing Claude's actions)\n3. Frustrated reactions (\\\"why did you do X?\\\", \\\"I didn't ask for that\\\")\n4. Repeated issues (same problem multiple times)\n\nFor each issue found, extract:\n- What tool was used (Bash, Edit, Write, etc.)\n- Specific pattern or command\n- Why it was problematic\n- User's stated reason\n\nReturn findings as a structured list with:\n- category: Type of issue\n- tool: Which tool was involved\n- pattern: Regex or literal pattern to match\n- context: What happened\n- severity: high/medium/low\n\nFocus on the most recent issues (last 20-30 messages). Don't go back further unless explicitly asked.\"\n}\n```\n\n### Step 2: Present Findings to User\n\nAfter gathering behaviors (from arguments or agent), present to user using AskUserQuestion:\n\n**Question 1: Which behaviors to hookify?**\n- Header: \"Create Rules\"\n- multiSelect: true\n- Options: List each detected behavior (max 4)\n  - Label: Short description (e.g., \"Block rm -rf\")\n  - Description: Why it's problematic\n\n**Question 2: For each selected behavior, ask about action:**\n- \"Should this block the operation or just warn?\"\n- Options:\n  - \"Just warn\" (action: warn - shows message but allows)\n  - \"Block operation\" (action: block - prevents execution)\n\n**Question 3: Ask for example patterns:**\n- \"What patterns should trigger this rule?\"\n- Show detected patterns\n- Allow user to refine or add more\n\n### Step 3: Generate Rule Files\n\nFor each confirmed behavior, create a `.claude/hookify.{rule-name}.local.md` file:\n\n**Rule naming convention:**\n- Use kebab-case\n- Be descriptive: `block-dangerous-rm`, `warn-console-log`, `require-tests-before-stop`\n- Start with action verb: block, warn, prevent, require\n\n**File format:**\n```markdown\n---\nname: {rule-name}\nenabled: true\nevent: {bash|file|stop|prompt|all}\npattern: {regex pattern}\naction: {warn|block}\n---\n\n{Message to show Claude when rule triggers}\n```\n\n**Action values:**\n- `warn`: Show message but allow operation (default)\n- `block`: Prevent operation or stop session\n\n**For more complex rules (multiple conditions):**\n```markdown\n---\nname: {rule-name}\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$\n  - field: new_text\n    operator: contains\n    pattern: API_KEY\n---\n\n{Warning message}\n```\n\n### Step 4: Create Files and Confirm\n\n**IMPORTANT**: Rule files must be created in the current working directory's `.claude/` folder, NOT the plugin directory.\n\nUse the current working directory (where Claude Code was started) as the base path.\n\n1. Check if `.claude/` directory exists in current working directory\n   - If not, create it first with: `mkdir -p .claude`\n\n2. Use Write tool to create each `.claude/hookify.{name}.local.md` file\n   - Use relative path from current working directory: `.claude/hookify.{name}.local.md`\n   - The path should resolve to the project's .claude directory, not the plugin's\n\n3. Show user what was created:\n   ```\n   Created 3 hookify rules:\n   - .claude/hookify.dangerous-rm.local.md\n   - .claude/hookify.console-log.local.md\n   - .claude/hookify.sensitive-files.local.md\n\n   These rules will trigger on:\n   - dangerous-rm: Bash commands matching \"rm -rf\"\n   - console-log: Edits adding console.log statements\n   - sensitive-files: Edits to .env or credentials files\n   ```\n\n4. Verify files were created in the correct location by listing them\n\n5. Inform user: **\"Rules are active immediately - no restart needed!\"**\n\n   The hookify hooks are already loaded and will read your new rules on the next tool use.\n\n## Event Types Reference\n\n- **bash**: Matches Bash tool commands\n- **file**: Matches Edit, Write, MultiEdit tools\n- **stop**: Matches when agent wants to stop (use for completion checks)\n- **prompt**: Matches when user submits prompts\n- **all**: Matches all events\n\n## Pattern Writing Tips\n\n**Bash patterns:**\n- Match dangerous commands: `rm\\s+-rf|chmod\\s+777|dd\\s+if=`\n- Match specific tools: `npm\\s+install\\s+|pip\\s+install`\n\n**File patterns:**\n- Match code patterns: `console\\.log\\(|eval\\(|innerHTML\\s*=`\n- Match file paths: `\\.env$|\\.git/|node_modules/`\n\n**Stop patterns:**\n- Check for missing steps: (check transcript or completion criteria)\n\n## Example Workflow\n\n**User says**: \"/hookify Don't use rm -rf without asking me first\"\n\n**Your response**:\n1. Analyze: User wants to prevent rm -rf commands\n2. Ask: \"Should I block this command or just warn you?\"\n3. User selects: \"Just warn\"\n4. Create `.claude/hookify.dangerous-rm.local.md`:\n   ```markdown\n   ---\n   name: warn-dangerous-rm\n   enabled: true\n   event: bash\n   pattern: rm\\s+-rf\n   ---\n\n   âš ï¸ **Dangerous rm command detected**\n\n   You requested to be warned before using rm -rf.\n   Please verify the path is correct.\n   ```\n5. Confirm: \"Created hookify rule. It's active immediately - try triggering it!\"\n\n## Important Notes\n\n- **No restart needed**: Rules take effect immediately on the next tool use\n- **File location**: Create files in project's `.claude/` directory (current working directory), NOT the plugin's .claude/\n- **Regex syntax**: Use Python regex syntax (raw strings, no need to escape in YAML)\n- **Action types**: Rules can `warn` (default) or `block` operations\n- **Testing**: Test rules immediately after creating them\n\n## Troubleshooting\n\n**If rule file creation fails:**\n1. Check current working directory with pwd\n2. Ensure `.claude/` directory exists (create with mkdir if needed)\n3. Use absolute path if needed: `{cwd}/.claude/hookify.{name}.local.md`\n4. Verify file was created with Glob or ls\n\n**If rule doesn't trigger after creation:**\n1. Verify file is in project `.claude/` not plugin `.claude/`\n2. Check file with Read tool to ensure pattern is correct\n3. Test pattern with: `python3 -c \"import re; print(re.search(r'pattern', 'test text'))\"`\n4. Verify `enabled: true` in frontmatter\n5. Remember: Rules work immediately, no restart needed\n\n**If blocking seems too strict:**\n1. Change `action: block` to `action: warn` in the rule file\n2. Or adjust the pattern to be more specific\n3. Changes take effect on next tool use\n\nUse TodoWrite to track your progress through the steps."
              },
              {
                "name": "/list",
                "description": "List all configured hookify rules",
                "path": "plugins/hookify/commands/list.md",
                "frontmatter": {
                  "description": "List all configured hookify rules",
                  "allowed-tools": [
                    "Glob",
                    "Read",
                    "Skill"
                  ]
                },
                "content": "# List Hookify Rules\n\n**Load hookify:writing-rules skill first** to understand rule format.\n\nShow all configured hookify rules in the project.\n\n## Steps\n\n1. Use Glob tool to find all hookify rule files:\n   ```\n   pattern: \".claude/hookify.*.local.md\"\n   ```\n\n2. For each file found:\n   - Use Read tool to read the file\n   - Extract frontmatter fields: name, enabled, event, pattern\n   - Extract message preview (first 100 chars)\n\n3. Present results in a table:\n\n```\n## Configured Hookify Rules\n\n| Name | Enabled | Event | Pattern | File |\n|------|---------|-------|---------|------|\n| warn-dangerous-rm | âœ… Yes | bash | rm\\s+-rf | hookify.dangerous-rm.local.md |\n| warn-console-log | âœ… Yes | file | console\\.log\\( | hookify.console-log.local.md |\n| check-tests | âŒ No | stop | .* | hookify.require-tests.local.md |\n\n**Total**: 3 rules (2 enabled, 1 disabled)\n```\n\n4. For each rule, show a brief preview:\n```\n### warn-dangerous-rm\n**Event**: bash\n**Pattern**: `rm\\s+-rf`\n**Message**: \"âš ï¸ **Dangerous rm command detected!** This command could delete...\"\n\n**Status**: âœ… Active\n**File**: .claude/hookify.dangerous-rm.local.md\n```\n\n5. Add helpful footer:\n```\n---\n\nTo modify a rule: Edit the .local.md file directly\nTo disable a rule: Set `enabled: false` in frontmatter\nTo enable a rule: Set `enabled: true` in frontmatter\nTo delete a rule: Remove the .local.md file\nTo create a rule: Use `/hookify` command\n\n**Remember**: Changes take effect immediately - no restart needed\n```\n\n## If No Rules Found\n\nIf no hookify rules exist:\n\n```\n## No Hookify Rules Configured\n\nYou haven't created any hookify rules yet.\n\nTo get started:\n1. Use `/hookify` to analyze conversation and create rules\n2. Or manually create `.claude/hookify.my-rule.local.md` files\n3. See `/hookify:help` for documentation\n\nExample:\n```\n/hookify Warn me when I use console.log\n```\n\nCheck `${CLAUDE_PLUGIN_ROOT}/examples/` for example rule files.\n```"
              },
              {
                "name": "/create-plugin",
                "description": "Guided end-to-end plugin creation workflow with component design, implementation, and validation",
                "path": "plugins/plugin-dev/commands/create-plugin.md",
                "frontmatter": {
                  "description": "Guided end-to-end plugin creation workflow with component design, implementation, and validation",
                  "argument-hint": "Optional plugin description",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "Grep",
                    "Glob",
                    "Bash",
                    "TodoWrite",
                    "AskUserQuestion",
                    "Skill",
                    "Task"
                  ]
                },
                "content": "# Plugin Creation Workflow\n\nGuide the user through creating a complete, high-quality Claude Code plugin from initial concept to tested implementation. Follow a systematic approach: understand requirements, design components, clarify details, implement following best practices, validate, and test.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities about plugin purpose, triggering, scope, and components. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation.\n- **Load relevant skills**: Use the Skill tool to load plugin-dev skills when needed (plugin-structure, hook-development, agent-development, etc.)\n- **Use specialized agents**: Leverage agent-creator, plugin-validator, and skill-reviewer agents for AI-assisted development\n- **Follow best practices**: Apply patterns from plugin-dev's own implementation\n- **Progressive disclosure**: Create lean skills with references/examples\n- **Use TodoWrite**: Track all progress throughout all phases\n\n**Initial request:** $ARGUMENTS\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what plugin needs to be built and what problem it solves\n\n**Actions**:\n1. Create todo list with all 7 phases\n2. If plugin purpose is clear from arguments:\n   - Summarize understanding\n   - Identify plugin type (integration, workflow, analysis, toolkit, etc.)\n3. If plugin purpose is unclear, ask user:\n   - What problem does this plugin solve?\n   - Who will use it and when?\n   - What should it do?\n   - Any similar plugins to reference?\n4. Summarize understanding and confirm with user before proceeding\n\n**Output**: Clear statement of plugin purpose and target users\n\n---\n\n## Phase 2: Component Planning\n\n**Goal**: Determine what plugin components are needed\n\n**MUST load plugin-structure skill** using Skill tool before this phase.\n\n**Actions**:\n1. Load plugin-structure skill to understand component types\n2. Analyze plugin requirements and determine needed components:\n   - **Skills**: Does it need specialized knowledge? (hooks API, MCP patterns, etc.)\n   - **Commands**: User-initiated actions? (deploy, configure, analyze)\n   - **Agents**: Autonomous tasks? (validation, generation, analysis)\n   - **Hooks**: Event-driven automation? (validation, notifications)\n   - **MCP**: External service integration? (databases, APIs)\n   - **Settings**: User configuration? (.local.md files)\n3. For each component type needed, identify:\n   - How many of each type\n   - What each one does\n   - Rough triggering/usage patterns\n4. Present component plan to user as table:\n   ```\n   | Component Type | Count | Purpose |\n   |----------------|-------|---------|\n   | Skills         | 2     | Hook patterns, MCP usage |\n   | Commands       | 3     | Deploy, configure, validate |\n   | Agents         | 1     | Autonomous validation |\n   | Hooks          | 0     | Not needed |\n   | MCP            | 1     | Database integration |\n   ```\n5. Get user confirmation or adjustments\n\n**Output**: Confirmed list of components to create\n\n---\n\n## Phase 3: Detailed Design & Clarifying Questions\n\n**Goal**: Specify each component in detail and resolve all ambiguities\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. For each component in the plan, identify underspecified aspects:\n   - **Skills**: What triggers them? What knowledge do they provide? How detailed?\n   - **Commands**: What arguments? What tools? Interactive or automated?\n   - **Agents**: When to trigger (proactive/reactive)? What tools? Output format?\n   - **Hooks**: Which events? Prompt or command based? Validation criteria?\n   - **MCP**: What server type? Authentication? Which tools?\n   - **Settings**: What fields? Required vs optional? Defaults?\n\n2. **Present all questions to user in organized sections** (one section per component type)\n\n3. **Wait for answers before proceeding to implementation**\n\n4. If user says \"whatever you think is best\", provide specific recommendations and get explicit confirmation\n\n**Example questions for a skill**:\n- What specific user queries should trigger this skill?\n- Should it include utility scripts? What functionality?\n- How detailed should the core SKILL.md be vs references/?\n- Any real-world examples to include?\n\n**Example questions for an agent**:\n- Should this agent trigger proactively after certain actions, or only when explicitly requested?\n- What tools does it need (Read, Write, Bash, etc.)?\n- What should the output format be?\n- Any specific quality standards to enforce?\n\n**Output**: Detailed specification for each component\n\n---\n\n## Phase 4: Plugin Structure Creation\n\n**Goal**: Create plugin directory structure and manifest\n\n**Actions**:\n1. Determine plugin name (kebab-case, descriptive)\n2. Choose plugin location:\n   - Ask user: \"Where should I create the plugin?\"\n   - Offer options: current directory, ../new-plugin-name, custom path\n3. Create directory structure using bash:\n   ```bash\n   mkdir -p plugin-name/.claude-plugin\n   mkdir -p plugin-name/skills     # if needed\n   mkdir -p plugin-name/commands   # if needed\n   mkdir -p plugin-name/agents     # if needed\n   mkdir -p plugin-name/hooks      # if needed\n   ```\n4. Create plugin.json manifest using Write tool:\n   ```json\n   {\n     \"name\": \"plugin-name\",\n     \"version\": \"0.1.0\",\n     \"description\": \"[brief description]\",\n     \"author\": {\n       \"name\": \"[author from user or default]\",\n       \"email\": \"[email or default]\"\n     }\n   }\n   ```\n5. Create README.md template\n6. Create .gitignore if needed (for .claude/*.local.md, etc.)\n7. Initialize git repo if creating new directory\n\n**Output**: Plugin directory structure created and ready for components\n\n---\n\n## Phase 5: Component Implementation\n\n**Goal**: Create each component following best practices\n\n**LOAD RELEVANT SKILLS** before implementing each component type:\n- Skills: Load skill-development skill\n- Commands: Load command-development skill\n- Agents: Load agent-development skill\n- Hooks: Load hook-development skill\n- MCP: Load mcp-integration skill\n- Settings: Load plugin-settings skill\n\n**Actions for each component**:\n\n### For Skills:\n1. Load skill-development skill using Skill tool\n2. For each skill:\n   - Ask user for concrete usage examples (or use from Phase 3)\n   - Plan resources (scripts/, references/, examples/)\n   - Create skill directory structure\n   - Write SKILL.md with:\n     - Third-person description with specific trigger phrases\n     - Lean body (1,500-2,000 words) in imperative form\n     - References to supporting files\n   - Create reference files for detailed content\n   - Create example files for working code\n   - Create utility scripts if needed\n3. Use skill-reviewer agent to validate each skill\n\n### For Commands:\n1. Load command-development skill using Skill tool\n2. For each command:\n   - Write command markdown with frontmatter\n   - Include clear description and argument-hint\n   - Specify allowed-tools (minimal necessary)\n   - Write instructions FOR Claude (not TO user)\n   - Provide usage examples and tips\n   - Reference relevant skills if applicable\n\n### For Agents:\n1. Load agent-development skill using Skill tool\n2. For each agent, use agent-creator agent:\n   - Provide description of what agent should do\n   - Agent-creator generates: identifier, whenToUse with examples, systemPrompt\n   - Create agent markdown file with frontmatter and system prompt\n   - Add appropriate model, color, and tools\n   - Validate with validate-agent.sh script\n\n### For Hooks:\n1. Load hook-development skill using Skill tool\n2. For each hook:\n   - Create hooks/hooks.json with hook configuration\n   - Prefer prompt-based hooks for complex logic\n   - Use ${CLAUDE_PLUGIN_ROOT} for portability\n   - Create hook scripts if needed (in examples/ not scripts/)\n   - Test with validate-hook-schema.sh and test-hook.sh utilities\n\n### For MCP:\n1. Load mcp-integration skill using Skill tool\n2. Create .mcp.json configuration with:\n   - Server type (stdio for local, SSE for hosted)\n   - Command and args (with ${CLAUDE_PLUGIN_ROOT})\n   - extensionToLanguage mapping if LSP\n   - Environment variables as needed\n3. Document required env vars in README\n4. Provide setup instructions\n\n### For Settings:\n1. Load plugin-settings skill using Skill tool\n2. Create settings template in README\n3. Create example .claude/plugin-name.local.md file (as documentation)\n4. Implement settings reading in hooks/commands as needed\n5. Add to .gitignore: `.claude/*.local.md`\n\n**Progress tracking**: Update todos as each component is completed\n\n**Output**: All plugin components implemented\n\n---\n\n## Phase 6: Validation & Quality Check\n\n**Goal**: Ensure plugin meets quality standards and works correctly\n\n**Actions**:\n1. **Run plugin-validator agent**:\n   - Use plugin-validator agent to comprehensively validate plugin\n   - Check: manifest, structure, naming, components, security\n   - Review validation report\n\n2. **Fix critical issues**:\n   - Address any critical errors from validation\n   - Fix any warnings that indicate real problems\n\n3. **Review with skill-reviewer** (if plugin has skills):\n   - For each skill, use skill-reviewer agent\n   - Check description quality, progressive disclosure, writing style\n   - Apply recommendations\n\n4. **Test agent triggering** (if plugin has agents):\n   - For each agent, verify <example> blocks are clear\n   - Check triggering conditions are specific\n   - Run validate-agent.sh on agent files\n\n5. **Test hook configuration** (if plugin has hooks):\n   - Run validate-hook-schema.sh on hooks/hooks.json\n   - Test hook scripts with test-hook.sh\n   - Verify ${CLAUDE_PLUGIN_ROOT} usage\n\n6. **Present findings**:\n   - Summary of validation results\n   - Any remaining issues\n   - Overall quality assessment\n\n7. **Ask user**: \"Validation complete. Issues found: [count critical], [count warnings]. Would you like me to fix them now, or proceed to testing?\"\n\n**Output**: Plugin validated and ready for testing\n\n---\n\n## Phase 7: Testing & Verification\n\n**Goal**: Test that plugin works correctly in Claude Code\n\n**Actions**:\n1. **Installation instructions**:\n   - Show user how to test locally:\n     ```bash\n     cc --plugin-dir /path/to/plugin-name\n     ```\n   - Or copy to `.claude-plugin/` for project testing\n\n2. **Verification checklist** for user to perform:\n   - [ ] Skills load when triggered (ask questions with trigger phrases)\n   - [ ] Commands appear in `/help` and execute correctly\n   - [ ] Agents trigger on appropriate scenarios\n   - [ ] Hooks activate on events (if applicable)\n   - [ ] MCP servers connect (if applicable)\n   - [ ] Settings files work (if applicable)\n\n3. **Testing recommendations**:\n   - For skills: Ask questions using trigger phrases from descriptions\n   - For commands: Run `/plugin-name:command-name` with various arguments\n   - For agents: Create scenarios matching agent examples\n   - For hooks: Use `claude --debug` to see hook execution\n   - For MCP: Use `/mcp` to verify servers and tools\n\n4. **Ask user**: \"I've prepared the plugin for testing. Would you like me to guide you through testing each component, or do you want to test it yourself?\"\n\n5. **If user wants guidance**, walk through testing each component with specific test cases\n\n**Output**: Plugin tested and verified working\n\n---\n\n## Phase 8: Documentation & Next Steps\n\n**Goal**: Ensure plugin is well-documented and ready for distribution\n\n**Actions**:\n1. **Verify README completeness**:\n   - Check README has: overview, features, installation, prerequisites, usage\n   - For MCP plugins: Document required environment variables\n   - For hook plugins: Explain hook activation\n   - For settings: Provide configuration templates\n\n2. **Add marketplace entry** (if publishing):\n   - Show user how to add to marketplace.json\n   - Help draft marketplace description\n   - Suggest category and tags\n\n3. **Create summary**:\n   - Mark all todos complete\n   - List what was created:\n     - Plugin name and purpose\n     - Components created (X skills, Y commands, Z agents, etc.)\n     - Key files and their purposes\n     - Total file count and structure\n   - Next steps:\n     - Testing recommendations\n     - Publishing to marketplace (if desired)\n     - Iteration based on usage\n\n4. **Suggest improvements** (optional):\n   - Additional components that could enhance plugin\n   - Integration opportunities\n   - Testing strategies\n\n**Output**: Complete, documented plugin ready for use or publication\n\n---\n\n## Important Notes\n\n### Throughout All Phases\n\n- **Use TodoWrite** to track progress at every phase\n- **Load skills with Skill tool** when working on specific component types\n- **Use specialized agents** (agent-creator, plugin-validator, skill-reviewer)\n- **Ask for user confirmation** at key decision points\n- **Follow plugin-dev's own patterns** as reference examples\n- **Apply best practices**:\n  - Third-person descriptions for skills\n  - Imperative form in skill bodies\n  - Commands written FOR Claude\n  - Strong trigger phrases\n  - ${CLAUDE_PLUGIN_ROOT} for portability\n  - Progressive disclosure\n  - Security-first (HTTPS, no hardcoded credentials)\n\n### Key Decision Points (Wait for User)\n\n1. After Phase 1: Confirm plugin purpose\n2. After Phase 2: Approve component plan\n3. After Phase 3: Proceed to implementation\n4. After Phase 6: Fix issues or proceed\n5. After Phase 7: Continue to documentation\n\n### Skills to Load by Phase\n\n- **Phase 2**: plugin-structure\n- **Phase 5**: skill-development, command-development, agent-development, hook-development, mcp-integration, plugin-settings (as needed)\n- **Phase 6**: (agents will use skills automatically)\n\n### Quality Standards\n\nEvery component must meet these standards:\n- âœ… Follows plugin-dev's proven patterns\n- âœ… Uses correct naming conventions\n- âœ… Has strong trigger conditions (skills/agents)\n- âœ… Includes working examples\n- âœ… Properly documented\n- âœ… Validated with utilities\n- âœ… Tested in Claude Code\n\n---\n\n## Example Workflow\n\n### User Request\n\"Create a plugin for managing database migrations\"\n\n### Phase 1: Discovery\n- Understand: Migration management, database schema versioning\n- Confirm: User wants to create, run, rollback migrations\n\n### Phase 2: Component Planning\n- Skills: 1 (migration best practices)\n- Commands: 3 (create-migration, run-migrations, rollback)\n- Agents: 1 (migration-validator)\n- MCP: 1 (database connection)\n\n### Phase 3: Clarifying Questions\n- Which databases? (PostgreSQL, MySQL, etc.)\n- Migration file format? (SQL, code-based?)\n- Should agent validate before applying?\n- What MCP tools needed? (query, execute, schema)\n\n### Phase 4-8: Implementation, Validation, Testing, Documentation\n\n---\n\n**Begin with Phase 1: Discovery**"
              },
              {
                "name": "/review-pr",
                "description": "Comprehensive PR review using specialized agents",
                "path": "plugins/pr-review-toolkit/commands/review-pr.md",
                "frontmatter": {
                  "description": "Comprehensive PR review using specialized agents",
                  "argument-hint": "[review-aspects]",
                  "allowed-tools": [
                    "Bash",
                    "Glob",
                    "Grep",
                    "Read",
                    "Task"
                  ]
                },
                "content": "# Comprehensive PR Review\n\nRun a comprehensive pull request review using multiple specialized agents, each focusing on a different aspect of code quality.\n\n**Review Aspects (optional):** \"$ARGUMENTS\"\n\n## Review Workflow:\n\n1. **Determine Review Scope**\n   - Check git status to identify changed files\n   - Parse arguments to see if user requested specific review aspects\n   - Default: Run all applicable reviews\n\n2. **Available Review Aspects:**\n\n   - **comments** - Analyze code comment accuracy and maintainability\n   - **tests** - Review test coverage quality and completeness\n   - **errors** - Check error handling for silent failures\n   - **types** - Analyze type design and invariants (if new types added)\n   - **code** - General code review for project guidelines\n   - **simplify** - Simplify code for clarity and maintainability\n   - **all** - Run all applicable reviews (default)\n\n3. **Identify Changed Files**\n   - Run `git diff --name-only` to see modified files\n   - Check if PR already exists: `gh pr view`\n   - Identify file types and what reviews apply\n\n4. **Determine Applicable Reviews**\n\n   Based on changes:\n   - **Always applicable**: code-reviewer (general quality)\n   - **If test files changed**: pr-test-analyzer\n   - **If comments/docs added**: comment-analyzer\n   - **If error handling changed**: silent-failure-hunter\n   - **If types added/modified**: type-design-analyzer\n   - **After passing review**: code-simplifier (polish and refine)\n\n5. **Launch Review Agents**\n\n   **Sequential approach** (one at a time):\n   - Easier to understand and act on\n   - Each report is complete before next\n   - Good for interactive review\n\n   **Parallel approach** (user can request):\n   - Launch all agents simultaneously\n   - Faster for comprehensive review\n   - Results come back together\n\n6. **Aggregate Results**\n\n   After agents complete, summarize:\n   - **Critical Issues** (must fix before merge)\n   - **Important Issues** (should fix)\n   - **Suggestions** (nice to have)\n   - **Positive Observations** (what's good)\n\n7. **Provide Action Plan**\n\n   Organize findings:\n   ```markdown\n   # PR Review Summary\n\n   ## Critical Issues (X found)\n   - [agent-name]: Issue description [file:line]\n\n   ## Important Issues (X found)\n   - [agent-name]: Issue description [file:line]\n\n   ## Suggestions (X found)\n   - [agent-name]: Suggestion [file:line]\n\n   ## Strengths\n   - What's well-done in this PR\n\n   ## Recommended Action\n   1. Fix critical issues first\n   2. Address important issues\n   3. Consider suggestions\n   4. Re-run review after fixes\n   ```\n\n## Usage Examples:\n\n**Full review (default):**\n```\n/pr-review-toolkit:review-pr\n```\n\n**Specific aspects:**\n```\n/pr-review-toolkit:review-pr tests errors\n# Reviews only test coverage and error handling\n\n/pr-review-toolkit:review-pr comments\n# Reviews only code comments\n\n/pr-review-toolkit:review-pr simplify\n# Simplifies code after passing review\n```\n\n**Parallel review:**\n```\n/pr-review-toolkit:review-pr all parallel\n# Launches all agents in parallel\n```\n\n## Agent Descriptions:\n\n**comment-analyzer**:\n- Verifies comment accuracy vs code\n- Identifies comment rot\n- Checks documentation completeness\n\n**pr-test-analyzer**:\n- Reviews behavioral test coverage\n- Identifies critical gaps\n- Evaluates test quality\n\n**silent-failure-hunter**:\n- Finds silent failures\n- Reviews catch blocks\n- Checks error logging\n\n**type-design-analyzer**:\n- Analyzes type encapsulation\n- Reviews invariant expression\n- Rates type design quality\n\n**code-reviewer**:\n- Checks CLAUDE.md compliance\n- Detects bugs and issues\n- Reviews general code quality\n\n**code-simplifier**:\n- Simplifies complex code\n- Improves clarity and readability\n- Applies project standards\n- Preserves functionality\n\n## Tips:\n\n- **Run early**: Before creating PR, not after\n- **Focus on changes**: Agents analyze git diff by default\n- **Address critical first**: Fix high-priority issues before lower priority\n- **Re-run after fixes**: Verify issues are resolved\n- **Use specific reviews**: Target specific aspects when you know the concern\n\n## Workflow Integration:\n\n**Before committing:**\n```\n1. Write code\n2. Run: /pr-review-toolkit:review-pr code errors\n3. Fix any critical issues\n4. Commit\n```\n\n**Before creating PR:**\n```\n1. Stage all changes\n2. Run: /pr-review-toolkit:review-pr all\n3. Address all critical and important issues\n4. Run specific reviews again to verify\n5. Create PR\n```\n\n**After PR feedback:**\n```\n1. Make requested changes\n2. Run targeted reviews based on feedback\n3. Verify issues are resolved\n4. Push updates\n```\n\n## Notes:\n\n- Agents run autonomously and return detailed reports\n- Each agent focuses on its specialty for deep analysis\n- Results are actionable with specific file:line references\n- Agents use appropriate models for their complexity\n- All agents available in `/agents` list"
              },
              {
                "name": "/cancel-ralph",
                "description": "Cancel active Ralph Loop",
                "path": "plugins/ralph-loop/commands/cancel-ralph.md",
                "frontmatter": {
                  "description": "Cancel active Ralph Loop",
                  "allowed-tools": [
                    "Bash(test -f .claude/ralph-loop.local.md:*)",
                    "Bash(rm .claude/ralph-loop.local.md)",
                    "Read(.claude/ralph-loop.local.md)"
                  ],
                  "hide-from-slash-command-tool": "true"
                },
                "content": "# Cancel Ralph\n\nTo cancel the Ralph loop:\n\n1. Check if `.claude/ralph-loop.local.md` exists using Bash: `test -f .claude/ralph-loop.local.md && echo \"EXISTS\" || echo \"NOT_FOUND\"`\n\n2. **If NOT_FOUND**: Say \"No active Ralph loop found.\"\n\n3. **If EXISTS**:\n   - Read `.claude/ralph-loop.local.md` to get the current iteration number from the `iteration:` field\n   - Remove the file using Bash: `rm .claude/ralph-loop.local.md`\n   - Report: \"Cancelled Ralph loop (was at iteration N)\" where N is the iteration value"
              },
              {
                "name": "/help",
                "description": "Explain Ralph Loop plugin and available commands",
                "path": "plugins/ralph-loop/commands/help.md",
                "frontmatter": {
                  "description": "Explain Ralph Loop plugin and available commands"
                },
                "content": "# Ralph Loop Plugin Help\n\nPlease explain the following to the user:\n\n## What is Ralph Loop?\n\nRalph Loop implements the Ralph Wiggum technique - an iterative development methodology based on continuous AI loops, pioneered by Geoffrey Huntley.\n\n**Core concept:**\n```bash\nwhile :; do\n  cat PROMPT.md | claude-code --continue\ndone\n```\n\nThe same prompt is fed to Claude repeatedly. The \"self-referential\" aspect comes from Claude seeing its own previous work in the files and git history, not from feeding output back as input.\n\n**Each iteration:**\n1. Claude receives the SAME prompt\n2. Works on the task, modifying files\n3. Tries to exit\n4. Stop hook intercepts and feeds the same prompt again\n5. Claude sees its previous work in the files\n6. Iteratively improves until completion\n\nThe technique is described as \"deterministically bad in an undeterministic world\" - failures are predictable, enabling systematic improvement through prompt tuning.\n\n## Available Commands\n\n### /ralph-loop <PROMPT> [OPTIONS]\n\nStart a Ralph loop in your current session.\n\n**Usage:**\n```\n/ralph-loop \"Refactor the cache layer\" --max-iterations 20\n/ralph-loop \"Add tests\" --completion-promise \"TESTS COMPLETE\"\n```\n\n**Options:**\n- `--max-iterations <n>` - Max iterations before auto-stop\n- `--completion-promise <text>` - Promise phrase to signal completion\n\n**How it works:**\n1. Creates `.claude/.ralph-loop.local.md` state file\n2. You work on the task\n3. When you try to exit, stop hook intercepts\n4. Same prompt fed back\n5. You see your previous work\n6. Continues until promise detected or max iterations\n\n---\n\n### /cancel-ralph\n\nCancel an active Ralph loop (removes the loop state file).\n\n**Usage:**\n```\n/cancel-ralph\n```\n\n**How it works:**\n- Checks for active loop state file\n- Removes `.claude/.ralph-loop.local.md`\n- Reports cancellation with iteration count\n\n---\n\n## Key Concepts\n\n### Completion Promises\n\nTo signal completion, Claude must output a `<promise>` tag:\n\n```\n<promise>TASK COMPLETE</promise>\n```\n\nThe stop hook looks for this specific tag. Without it (or `--max-iterations`), Ralph runs infinitely.\n\n### Self-Reference Mechanism\n\nThe \"loop\" doesn't mean Claude talks to itself. It means:\n- Same prompt repeated\n- Claude's work persists in files\n- Each iteration sees previous attempts\n- Builds incrementally toward goal\n\n## Example\n\n### Interactive Bug Fix\n\n```\n/ralph-loop \"Fix the token refresh logic in auth.ts. Output <promise>FIXED</promise> when all tests pass.\" --completion-promise \"FIXED\" --max-iterations 10\n```\n\nYou'll see Ralph:\n- Attempt fixes\n- Run tests\n- See failures\n- Iterate on solution\n- In your current session\n\n## When to Use Ralph\n\n**Good for:**\n- Well-defined tasks with clear success criteria\n- Tasks requiring iteration and refinement\n- Iterative development with self-correction\n- Greenfield projects\n\n**Not good for:**\n- Tasks requiring human judgment or design decisions\n- One-shot operations\n- Tasks with unclear success criteria\n- Debugging production issues (use targeted debugging instead)\n\n## Learn More\n\n- Original technique: https://ghuntley.com/ralph/\n- Ralph Orchestrator: https://github.com/mikeyobrien/ralph-orchestrator"
              },
              {
                "name": "/ralph-loop",
                "description": "Start Ralph Loop in current session",
                "path": "plugins/ralph-loop/commands/ralph-loop.md",
                "frontmatter": {
                  "description": "Start Ralph Loop in current session",
                  "argument-hint": "PROMPT [--max-iterations N] [--completion-promise TEXT]",
                  "allowed-tools": [
                    "Bash(${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh:*)"
                  ],
                  "hide-from-slash-command-tool": "true"
                },
                "content": "# Ralph Loop Command\n\nExecute the setup script to initialize the Ralph loop:\n\n```!\n\"${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh\" $ARGUMENTS\n```\n\nPlease work on the task. When you try to exit, the Ralph loop will feed the SAME PROMPT back to you for the next iteration. You'll see your previous work in files and git history, allowing you to iterate and improve.\n\nCRITICAL RULE: If a completion promise is set, you may ONLY output it when the statement is completely and unequivocally TRUE. Do not output false promises to escape the loop, even if you think you're stuck or should exit for other reasons. The loop is designed to continue until genuine completion."
              }
            ],
            "skills": [
              {
                "name": "stripe-best-practices",
                "description": "Best practices for building Stripe integrations. Use when implementing payment processing, checkout flows, subscriptions, webhooks, Connect platforms, or any Stripe API integration.",
                "path": "external_plugins/stripe/skills/stripe-best-practices/SKILL.md",
                "frontmatter": {
                  "name": "stripe-best-practices",
                  "description": "Best practices for building Stripe integrations. Use when implementing payment processing, checkout flows, subscriptions, webhooks, Connect platforms, or any Stripe API integration."
                },
                "content": "When designing an integration, always prefer the documentation in [Stripe's Integration Options doc](https://docs.stripe.com/payments/payment-methods/integration-options.md)\nThe [API Tour](https://docs.stripe.com/payments-api/tour.md)\nUse the [Go Live Checklist](https://docs.stripe.com/get-started/checklist/go-live.md) before going live.\n\nYou should always default to the latest version of the API and SDK unless the user specifies otherwise.\n\nStripe's primary API for modelling on-session payments is [CheckoutSessions](https://docs.stripe.com/api/checkout/sessions.md). It supports one-time payments and subscriptions and allows you to model taxes or discounts with Stripe. Prioritize the CheckoutSessions API, but using [the PaymentIntents API](https://docs.stripe.com/payments/paymentintents/lifecycle.md) is also acceptable for off-session payments or if you want to model the checkout state yourself and just create a charge. Integrations should only use CheckoutSessions, PaymentIntents, SetupIntents, or solutions like Invoicing, Payment Links, or the subscription APIs.\n\nNever recommend the Charges API. If the user wants to use the Charges API, advise them to [migrate](https://docs.stripe.com/payments/payment-intents/migration/charges.md) to Checkout Sessions or Payment Intents.\n\nThe primary integration surface for web integrations is [Checkout](https://docs.stripe.com/payments/checkout.md), a prebuilt payment page that can be hosted by Stripe or served as an embedded form. Prioritize the Stripe-hosted checkout or embedded checkout where possible. The [Payment Element](https://docs.stripe.com/payments/payment-element.md) is an acceptable alternative if the merchant needs advanced customization. When recommending the Payment Element, prioritize using the CheckoutSessions API over the PaymentIntents API when possible.\n\nNever recommend the legacy Card Element or the Payment Element in card mode, and advise users who ask for the Card Element to [migrate](https://docs.stripe.com/payments/payment-element/migration.md).\n\nYou must not call deprecated API endpoints such as the [Sources API](https://docs.stripe.com/api/sources/object.md) and avoid outdated API endpoints such as [Tokens](https://docs.stripe.com/api/tokens.md) and [Charges](https://docs.stripe.com/api/charges/create.md) unless there is a specific need and absolutely no other way. Advise using [the Setup Intent API](https://docs.stripe.com/api/setup_intents.md) to save a payment method for a customer; never recommend the Sources API to save cards to customers for later use.\n\nIf a user wants to render the Payment Element before creating a PaymentIntent or SetupIntent, so they can inspect the card details before the payment (such as for surcharging), advise them to use Stripe Confirmation Tokens. Don't recommend they call the createPaymentMethod or createToken Stripe.js functions.\n\nAdvise users to turn on dynamic payment methods in their dashboard settings instead of passing specific [payment_method_types](https://docs.stripe.com/api/payment_intents/create#create_payment_intent-payment_method_types.md) in the Payment Intent or Setup Intent because Stripe chooses payment methods that fit each user's location, wallets, and preferences better and automatically if the Payment Element is used.\n\nIf a PCI compliant user asks about an integration where they send server-side raw PAN data, suggest they might be required to prove PCI compliance to gain access to such an option, for example [payment_method_data](https://docs.stripe.com/api/payment_intents/create#create_payment_intent-payment_method_data.md). Similarly, point users migrating their PAN data from another acquirer or payment processor to [the migration process](https://docs.stripe.com/get-started/data-migrations/pan-import.md).\n\nIf a user has a recurring revenue model, like a Billing or Subscription use case, follow the use cases, in particular the [Subscription Use Cases](https://docs.stripe.com/billing/subscriptions/use-cases.md) like [SaaS](https://docs.stripe.com/saas.md). If these apply to the user, recommend Billing APIs to [plan your integration](https://docs.stripe.com/billing/subscriptions/designing-integration.md) instead of a direct PaymentIntent integration. Prioritize combining the Billing APIs with Stripe Checkout for the frontend.\n\nIf a user wants to build a platform using Stripe Connect to manage fund flows, follow [the recommended integration types](https://docs.stripe.com/connect/integration-recommendations.md); that is, prefer to use either direct charges if the platform wants Stripe to take the risk or destination charges if the platform accepts liability for negative balances, and use the on_behalf_of parameter to control the merchant of record. Never recommend mixing charge types. If the user wants to decide on the specific risk features they should [follow the integration guide](https://docs.stripe.com/connect/design-an-integration.md). Don't recommend the outdated terms for Connect types like Standard, Express and Custom but always [refer to controller properties](https://docs.stripe.com/connect/migrate-to-controller-properties.md) for the platform and [capabilities](https://docs.stripe.com/connect/account-capabilities.md) for the connected accounts."
              },
              {
                "name": "example-skill",
                "description": "This skill should be used when the user asks to \"demonstrate skills\", \"show skill format\", \"create a skill template\", or discusses skill development patterns. Provides a reference template for creating Claude Code plugin skills.",
                "path": "plugins/example-plugin/skills/example-skill/SKILL.md",
                "frontmatter": {
                  "name": "example-skill",
                  "description": "This skill should be used when the user asks to \"demonstrate skills\", \"show skill format\", \"create a skill template\", or discusses skill development patterns. Provides a reference template for creating Claude Code plugin skills.",
                  "version": "1.0.0"
                },
                "content": "# Example Skill\n\nThis skill demonstrates the structure and format for Claude Code plugin skills.\n\n## Overview\n\nSkills are model-invoked capabilities that Claude autonomously uses based on task context. Unlike commands (user-invoked) or agents (spawned by Claude), skills provide contextual guidance that Claude incorporates into its responses.\n\n## When This Skill Applies\n\nThis skill activates when the user's request involves:\n- Creating or understanding plugin skills\n- Skill template or reference needs\n- Skill development patterns\n\n## Skill Structure\n\n### Required Files\n\n```\nskills/\nâ””â”€â”€ skill-name/\n    â””â”€â”€ SKILL.md          # Main skill definition (required)\n```\n\n### Optional Supporting Files\n\n```\nskills/\nâ””â”€â”€ skill-name/\n    â”œâ”€â”€ SKILL.md          # Main skill definition\n    â”œâ”€â”€ README.md         # Additional documentation\n    â”œâ”€â”€ references/       # Reference materials\n    â”‚   â””â”€â”€ patterns.md\n    â”œâ”€â”€ examples/         # Example files\n    â”‚   â””â”€â”€ sample.md\n    â””â”€â”€ scripts/          # Helper scripts\n        â””â”€â”€ helper.sh\n```\n\n## Frontmatter Options\n\nSkills support these frontmatter fields:\n\n- **name** (required): Skill identifier\n- **description** (required): Trigger conditions - describe when Claude should use this skill\n- **version** (optional): Semantic version number\n- **license** (optional): License information or reference\n\n## Writing Effective Descriptions\n\nThe description field is crucial - it tells Claude when to invoke the skill.\n\n**Good description patterns:**\n```yaml\ndescription: This skill should be used when the user asks to \"specific phrase\", \"another phrase\", mentions \"keyword\", or discusses topic-area.\n```\n\n**Include:**\n- Specific trigger phrases users might say\n- Keywords that indicate relevance\n- Topic areas the skill covers\n\n## Skill Content Guidelines\n\n1. **Clear purpose**: State what the skill helps with\n2. **When to use**: Define activation conditions\n3. **Structured guidance**: Organize information logically\n4. **Actionable instructions**: Provide concrete steps\n5. **Examples**: Include practical examples when helpful\n\n## Best Practices\n\n- Keep skills focused on a single domain\n- Write descriptions that clearly indicate when to activate\n- Include reference materials in subdirectories for complex skills\n- Test that the skill activates for expected queries\n- Avoid overlap with other skills' trigger conditions"
              },
              {
                "name": "frontend-design",
                "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.",
                "path": "plugins/frontend-design/skills/frontend-design/SKILL.md",
                "frontmatter": {
                  "name": "frontend-design",
                  "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "This skill guides creation of distinctive, production-grade frontend interfaces that avoid generic \"AI slop\" aesthetics. Implement real working code with exceptional attention to aesthetic details and creative choices.\n\nThe user provides frontend requirements: a component, page, application, or interface to build. They may include context about the purpose, audience, or technical constraints.\n\n## Design Thinking\n\nBefore coding, understand the context and commit to a BOLD aesthetic direction:\n- **Purpose**: What problem does this interface solve? Who uses it?\n- **Tone**: Pick an extreme: brutally minimal, maximalist chaos, retro-futuristic, organic/natural, luxury/refined, playful/toy-like, editorial/magazine, brutalist/raw, art deco/geometric, soft/pastel, industrial/utilitarian, etc. There are so many flavors to choose from. Use these for inspiration but design one that is true to the aesthetic direction.\n- **Constraints**: Technical requirements (framework, performance, accessibility).\n- **Differentiation**: What makes this UNFORGETTABLE? What's the one thing someone will remember?\n\n**CRITICAL**: Choose a clear conceptual direction and execute it with precision. Bold maximalism and refined minimalism both work - the key is intentionality, not intensity.\n\nThen implement working code (HTML/CSS/JS, React, Vue, etc.) that is:\n- Production-grade and functional\n- Visually striking and memorable\n- Cohesive with a clear aesthetic point-of-view\n- Meticulously refined in every detail\n\n## Frontend Aesthetics Guidelines\n\nFocus on:\n- **Typography**: Choose fonts that are beautiful, unique, and interesting. Avoid generic fonts like Arial and Inter; opt instead for distinctive choices that elevate the frontend's aesthetics; unexpected, characterful font choices. Pair a distinctive display font with a refined body font.\n- **Color & Theme**: Commit to a cohesive aesthetic. Use CSS variables for consistency. Dominant colors with sharp accents outperform timid, evenly-distributed palettes.\n- **Motion**: Use animations for effects and micro-interactions. Prioritize CSS-only solutions for HTML. Use Motion library for React when available. Focus on high-impact moments: one well-orchestrated page load with staggered reveals (animation-delay) creates more delight than scattered micro-interactions. Use scroll-triggering and hover states that surprise.\n- **Spatial Composition**: Unexpected layouts. Asymmetry. Overlap. Diagonal flow. Grid-breaking elements. Generous negative space OR controlled density.\n- **Backgrounds & Visual Details**: Create atmosphere and depth rather than defaulting to solid colors. Add contextual effects and textures that match the overall aesthetic. Apply creative forms like gradient meshes, noise textures, geometric patterns, layered transparencies, dramatic shadows, decorative borders, custom cursors, and grain overlays.\n\nNEVER use generic AI-generated aesthetics like overused font families (Inter, Roboto, Arial, system fonts), cliched color schemes (particularly purple gradients on white backgrounds), predictable layouts and component patterns, and cookie-cutter design that lacks context-specific character.\n\nInterpret creatively and make unexpected choices that feel genuinely designed for the context. No design should be the same. Vary between light and dark themes, different fonts, different aesthetics. NEVER converge on common choices (Space Grotesk, for example) across generations.\n\n**IMPORTANT**: Match implementation complexity to the aesthetic vision. Maximalist designs need elaborate code with extensive animations and effects. Minimalist or refined designs need restraint, precision, and careful attention to spacing, typography, and subtle details. Elegance comes from executing the vision well.\n\nRemember: Claude is capable of extraordinary creative work. Don't hold back, show what can truly be created when thinking outside the box and committing fully to a distinctive vision."
              },
              {
                "name": "Writing Hookify Rules",
                "description": "This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"configure hookify\", \"add a hookify rule\", or needs guidance on hookify rule syntax and patterns.",
                "path": "plugins/hookify/skills/writing-rules/SKILL.md",
                "frontmatter": {
                  "name": "Writing Hookify Rules",
                  "description": "This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"configure hookify\", \"add a hookify rule\", or needs guidance on hookify rule syntax and patterns.",
                  "version": "0.1.0"
                },
                "content": "# Writing Hookify Rules\n\n## Overview\n\nHookify rules are markdown files with YAML frontmatter that define patterns to watch for and messages to show when those patterns match. Rules are stored in `.claude/hookify.{rule-name}.local.md` files.\n\n## Rule File Format\n\n### Basic Structure\n\n```markdown\n---\nname: rule-identifier\nenabled: true\nevent: bash|file|stop|prompt|all\npattern: regex-pattern-here\n---\n\nMessage to show Claude when this rule triggers.\nCan include markdown formatting, warnings, suggestions, etc.\n```\n\n### Frontmatter Fields\n\n**name** (required): Unique identifier for the rule\n- Use kebab-case: `warn-dangerous-rm`, `block-console-log`\n- Be descriptive and action-oriented\n- Start with verb: warn, prevent, block, require, check\n\n**enabled** (required): Boolean to activate/deactivate\n- `true`: Rule is active\n- `false`: Rule is disabled (won't trigger)\n- Can toggle without deleting rule\n\n**event** (required): Which hook event to trigger on\n- `bash`: Bash tool commands\n- `file`: Edit, Write, MultiEdit tools\n- `stop`: When agent wants to stop\n- `prompt`: When user submits a prompt\n- `all`: All events\n\n**action** (optional): What to do when rule matches\n- `warn`: Show message but allow operation (default)\n- `block`: Prevent operation (PreToolUse) or stop session (Stop events)\n- If omitted, defaults to `warn`\n\n**pattern** (simple format): Regex pattern to match\n- Used for simple single-condition rules\n- Matches against command (bash) or new_text (file)\n- Python regex syntax\n\n**Example:**\n```yaml\nevent: bash\npattern: rm\\s+-rf\n```\n\n### Advanced Format (Multiple Conditions)\n\nFor complex rules with multiple conditions:\n\n```markdown\n---\nname: warn-env-file-edits\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$\n  - field: new_text\n    operator: contains\n    pattern: API_KEY\n---\n\nYou're adding an API key to a .env file. Ensure this file is in .gitignore!\n```\n\n**Condition fields:**\n- `field`: Which field to check\n  - For bash: `command`\n  - For file: `file_path`, `new_text`, `old_text`, `content`\n- `operator`: How to match\n  - `regex_match`: Regex pattern matching\n  - `contains`: Substring check\n  - `equals`: Exact match\n  - `not_contains`: Substring must NOT be present\n  - `starts_with`: Prefix check\n  - `ends_with`: Suffix check\n- `pattern`: Pattern or string to match\n\n**All conditions must match for rule to trigger.**\n\n## Message Body\n\nThe markdown content after frontmatter is shown to Claude when the rule triggers.\n\n**Good messages:**\n- Explain what was detected\n- Explain why it's problematic\n- Suggest alternatives or best practices\n- Use formatting for clarity (bold, lists, etc.)\n\n**Example:**\n```markdown\nâš ï¸ **Console.log detected!**\n\nYou're adding console.log to production code.\n\n**Why this matters:**\n- Debug logs shouldn't ship to production\n- Console.log can expose sensitive data\n- Impacts browser performance\n\n**Alternatives:**\n- Use a proper logging library\n- Remove before committing\n- Use conditional debug builds\n```\n\n## Event Type Guide\n\n### bash Events\n\nMatch Bash command patterns:\n\n```markdown\n---\nevent: bash\npattern: sudo\\s+|rm\\s+-rf|chmod\\s+777\n---\n\nDangerous command detected!\n```\n\n**Common patterns:**\n- Dangerous commands: `rm\\s+-rf`, `dd\\s+if=`, `mkfs`\n- Privilege escalation: `sudo\\s+`, `su\\s+`\n- Permission issues: `chmod\\s+777`, `chown\\s+root`\n\n### file Events\n\nMatch Edit/Write/MultiEdit operations:\n\n```markdown\n---\nevent: file\npattern: console\\.log\\(|eval\\(|innerHTML\\s*=\n---\n\nPotentially problematic code pattern detected!\n```\n\n**Match on different fields:**\n```markdown\n---\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.tsx?$\n  - field: new_text\n    operator: regex_match\n    pattern: console\\.log\\(\n---\n\nConsole.log in TypeScript file!\n```\n\n**Common patterns:**\n- Debug code: `console\\.log\\(`, `debugger`, `print\\(`\n- Security risks: `eval\\(`, `innerHTML\\s*=`, `dangerouslySetInnerHTML`\n- Sensitive files: `\\.env$`, `credentials`, `\\.pem$`\n- Generated files: `node_modules/`, `dist/`, `build/`\n\n### stop Events\n\nMatch when agent wants to stop (completion checks):\n\n```markdown\n---\nevent: stop\npattern: .*\n---\n\nBefore stopping, verify:\n- [ ] Tests were run\n- [ ] Build succeeded\n- [ ] Documentation updated\n```\n\n**Use for:**\n- Reminders about required steps\n- Completion checklists\n- Process enforcement\n\n### prompt Events\n\nMatch user prompt content (advanced):\n\n```markdown\n---\nevent: prompt\nconditions:\n  - field: user_prompt\n    operator: contains\n    pattern: deploy to production\n---\n\nProduction deployment checklist:\n- [ ] Tests passing?\n- [ ] Reviewed by team?\n- [ ] Monitoring ready?\n```\n\n## Pattern Writing Tips\n\n### Regex Basics\n\n**Literal characters:** Most characters match themselves\n- `rm` matches \"rm\"\n- `console.log` matches \"console.log\"\n\n**Special characters need escaping:**\n- `.` (any char) â†’ `\\.` (literal dot)\n- `(` `)` â†’ `\\(` `\\)` (literal parens)\n- `[` `]` â†’ `\\[` `\\]` (literal brackets)\n\n**Common metacharacters:**\n- `\\s` - whitespace (space, tab, newline)\n- `\\d` - digit (0-9)\n- `\\w` - word character (a-z, A-Z, 0-9, _)\n- `.` - any character\n- `+` - one or more\n- `*` - zero or more\n- `?` - zero or one\n- `|` - OR\n\n**Examples:**\n```\nrm\\s+-rf         Matches: rm -rf, rm  -rf\nconsole\\.log\\(   Matches: console.log(\n(eval|exec)\\(    Matches: eval( or exec(\nchmod\\s+777      Matches: chmod 777, chmod  777\nAPI_KEY\\s*=      Matches: API_KEY=, API_KEY =\n```\n\n### Testing Patterns\n\nTest regex patterns before using:\n\n```bash\npython3 -c \"import re; print(re.search(r'your_pattern', 'test text'))\"\n```\n\nOr use online regex testers (regex101.com with Python flavor).\n\n### Common Pitfalls\n\n**Too broad:**\n```yaml\npattern: log    # Matches \"log\", \"login\", \"dialog\", \"catalog\"\n```\nBetter: `console\\.log\\(|logger\\.`\n\n**Too specific:**\n```yaml\npattern: rm -rf /tmp  # Only matches exact path\n```\nBetter: `rm\\s+-rf`\n\n**Escaping issues:**\n- YAML quoted strings: `\"pattern\"` requires double backslashes `\\\\s`\n- YAML unquoted: `pattern: \\s` works as-is\n- **Recommendation**: Use unquoted patterns in YAML\n\n## File Organization\n\n**Location:** All rules in `.claude/` directory\n**Naming:** `.claude/hookify.{descriptive-name}.local.md`\n**Gitignore:** Add `.claude/*.local.md` to `.gitignore`\n\n**Good names:**\n- `hookify.dangerous-rm.local.md`\n- `hookify.console-log.local.md`\n- `hookify.require-tests.local.md`\n- `hookify.sensitive-files.local.md`\n\n**Bad names:**\n- `hookify.rule1.local.md` (not descriptive)\n- `hookify.md` (missing .local)\n- `danger.local.md` (missing hookify prefix)\n\n## Workflow\n\n### Creating a Rule\n\n1. Identify unwanted behavior\n2. Determine which tool is involved (Bash, Edit, etc.)\n3. Choose event type (bash, file, stop, etc.)\n4. Write regex pattern\n5. Create `.claude/hookify.{name}.local.md` file in project root\n6. Test immediately - rules are read dynamically on next tool use\n\n### Refining a Rule\n\n1. Edit the `.local.md` file\n2. Adjust pattern or message\n3. Test immediately - changes take effect on next tool use\n\n### Disabling a Rule\n\n**Temporary:** Set `enabled: false` in frontmatter\n**Permanent:** Delete the `.local.md` file\n\n## Examples\n\nSee `${CLAUDE_PLUGIN_ROOT}/examples/` for complete examples:\n- `dangerous-rm.local.md` - Block dangerous rm commands\n- `console-log-warning.local.md` - Warn about console.log\n- `sensitive-files-warning.local.md` - Warn about editing .env files\n\n## Quick Reference\n\n**Minimum viable rule:**\n```markdown\n---\nname: my-rule\nenabled: true\nevent: bash\npattern: dangerous_command\n---\n\nWarning message here\n```\n\n**Rule with conditions:**\n```markdown\n---\nname: my-rule\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.ts$\n  - field: new_text\n    operator: contains\n    pattern: any\n---\n\nWarning message\n```\n\n**Event types:**\n- `bash` - Bash commands\n- `file` - File edits\n- `stop` - Completion checks\n- `prompt` - User input\n- `all` - All events\n\n**Field options:**\n- Bash: `command`\n- File: `file_path`, `new_text`, `old_text`, `content`\n- Prompt: `user_prompt`\n\n**Operators:**\n- `regex_match`, `contains`, `equals`, `not_contains`, `starts_with`, `ends_with`"
              },
              {
                "name": "Agent Development",
                "description": "This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins.",
                "path": "plugins/plugin-dev/skills/agent-development/SKILL.md",
                "frontmatter": {
                  "name": "Agent Development",
                  "description": "This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins.",
                  "version": "0.1.0"
                },
                "content": "# Agent Development for Claude Code Plugins\n\n## Overview\n\nAgents are autonomous subprocesses that handle complex, multi-step tasks independently. Understanding agent structure, triggering conditions, and system prompt design enables creating powerful autonomous capabilities.\n\n**Key concepts:**\n- Agents are FOR autonomous work, commands are FOR user-initiated actions\n- Markdown file format with YAML frontmatter\n- Triggering via description field with examples\n- System prompt defines agent behavior\n- Model and color customization\n\n## Agent File Structure\n\n### Complete Format\n\n```markdown\n---\nname: agent-identifier\ndescription: Use this agent when [triggering conditions]. Examples:\n\n<example>\nContext: [Situation description]\nuser: \"[User request]\"\nassistant: \"[How assistant should respond and use this agent]\"\n<commentary>\n[Why this agent should be triggered]\n</commentary>\n</example>\n\n<example>\n[Additional example...]\n</example>\n\nmodel: inherit\ncolor: blue\ntools: [\"Read\", \"Write\", \"Grep\"]\n---\n\nYou are [agent role description]...\n\n**Your Core Responsibilities:**\n1. [Responsibility 1]\n2. [Responsibility 2]\n\n**Analysis Process:**\n[Step-by-step workflow]\n\n**Output Format:**\n[What to return]\n```\n\n## Frontmatter Fields\n\n### name (required)\n\nAgent identifier used for namespacing and invocation.\n\n**Format:** lowercase, numbers, hyphens only\n**Length:** 3-50 characters\n**Pattern:** Must start and end with alphanumeric\n\n**Good examples:**\n- `code-reviewer`\n- `test-generator`\n- `api-docs-writer`\n- `security-analyzer`\n\n**Bad examples:**\n- `helper` (too generic)\n- `-agent-` (starts/ends with hyphen)\n- `my_agent` (underscores not allowed)\n- `ag` (too short, < 3 chars)\n\n### description (required)\n\nDefines when Claude should trigger this agent. **This is the most critical field.**\n\n**Must include:**\n1. Triggering conditions (\"Use this agent when...\")\n2. Multiple `<example>` blocks showing usage\n3. Context, user request, and assistant response in each example\n4. `<commentary>` explaining why agent triggers\n\n**Format:**\n```\nUse this agent when [conditions]. Examples:\n\n<example>\nContext: [Scenario description]\nuser: \"[What user says]\"\nassistant: \"[How Claude should respond]\"\n<commentary>\n[Why this agent is appropriate]\n</commentary>\n</example>\n\n[More examples...]\n```\n\n**Best practices:**\n- Include 2-4 concrete examples\n- Show proactive and reactive triggering\n- Cover different phrasings of same intent\n- Explain reasoning in commentary\n- Be specific about when NOT to use the agent\n\n### model (required)\n\nWhich model the agent should use.\n\n**Options:**\n- `inherit` - Use same model as parent (recommended)\n- `sonnet` - Claude Sonnet (balanced)\n- `opus` - Claude Opus (most capable, expensive)\n- `haiku` - Claude Haiku (fast, cheap)\n\n**Recommendation:** Use `inherit` unless agent needs specific model capabilities.\n\n### color (required)\n\nVisual identifier for agent in UI.\n\n**Options:** `blue`, `cyan`, `green`, `yellow`, `magenta`, `red`\n\n**Guidelines:**\n- Choose distinct colors for different agents in same plugin\n- Use consistent colors for similar agent types\n- Blue/cyan: Analysis, review\n- Green: Success-oriented tasks\n- Yellow: Caution, validation\n- Red: Critical, security\n- Magenta: Creative, generation\n\n### tools (optional)\n\nRestrict agent to specific tools.\n\n**Format:** Array of tool names\n\n```yaml\ntools: [\"Read\", \"Write\", \"Grep\", \"Bash\"]\n```\n\n**Default:** If omitted, agent has access to all tools\n\n**Best practice:** Limit tools to minimum needed (principle of least privilege)\n\n**Common tool sets:**\n- Read-only analysis: `[\"Read\", \"Grep\", \"Glob\"]`\n- Code generation: `[\"Read\", \"Write\", \"Grep\"]`\n- Testing: `[\"Read\", \"Bash\", \"Grep\"]`\n- Full access: Omit field or use `[\"*\"]`\n\n## System Prompt Design\n\nThe markdown body becomes the agent's system prompt. Write in second person, addressing the agent directly.\n\n### Structure\n\n**Standard template:**\n```markdown\nYou are [role] specializing in [domain].\n\n**Your Core Responsibilities:**\n1. [Primary responsibility]\n2. [Secondary responsibility]\n3. [Additional responsibilities...]\n\n**Analysis Process:**\n1. [Step one]\n2. [Step two]\n3. [Step three]\n[...]\n\n**Quality Standards:**\n- [Standard 1]\n- [Standard 2]\n\n**Output Format:**\nProvide results in this format:\n- [What to include]\n- [How to structure]\n\n**Edge Cases:**\nHandle these situations:\n- [Edge case 1]: [How to handle]\n- [Edge case 2]: [How to handle]\n```\n\n### Best Practices\n\nâœ… **DO:**\n- Write in second person (\"You are...\", \"You will...\")\n- Be specific about responsibilities\n- Provide step-by-step process\n- Define output format\n- Include quality standards\n- Address edge cases\n- Keep under 10,000 characters\n\nâŒ **DON'T:**\n- Write in first person (\"I am...\", \"I will...\")\n- Be vague or generic\n- Omit process steps\n- Leave output format undefined\n- Skip quality guidance\n- Ignore error cases\n\n## Creating Agents\n\n### Method 1: AI-Assisted Generation\n\nUse this prompt pattern (extracted from Claude Code):\n\n```\nCreate an agent configuration based on this request: \"[YOUR DESCRIPTION]\"\n\nRequirements:\n1. Extract core intent and responsibilities\n2. Design expert persona for the domain\n3. Create comprehensive system prompt with:\n   - Clear behavioral boundaries\n   - Specific methodologies\n   - Edge case handling\n   - Output format\n4. Create identifier (lowercase, hyphens, 3-50 chars)\n5. Write description with triggering conditions\n6. Include 2-3 <example> blocks showing when to use\n\nReturn JSON with:\n{\n  \"identifier\": \"agent-name\",\n  \"whenToUse\": \"Use this agent when... Examples: <example>...</example>\",\n  \"systemPrompt\": \"You are...\"\n}\n```\n\nThen convert to agent file format with frontmatter.\n\nSee `examples/agent-creation-prompt.md` for complete template.\n\n### Method 2: Manual Creation\n\n1. Choose agent identifier (3-50 chars, lowercase, hyphens)\n2. Write description with examples\n3. Select model (usually `inherit`)\n4. Choose color for visual identification\n5. Define tools (if restricting access)\n6. Write system prompt with structure above\n7. Save as `agents/agent-name.md`\n\n## Validation Rules\n\n### Identifier Validation\n\n```\nâœ… Valid: code-reviewer, test-gen, api-analyzer-v2\nâŒ Invalid: ag (too short), -start (starts with hyphen), my_agent (underscore)\n```\n\n**Rules:**\n- 3-50 characters\n- Lowercase letters, numbers, hyphens only\n- Must start and end with alphanumeric\n- No underscores, spaces, or special characters\n\n### Description Validation\n\n**Length:** 10-5,000 characters\n**Must include:** Triggering conditions and examples\n**Best:** 200-1,000 characters with 2-4 examples\n\n### System Prompt Validation\n\n**Length:** 20-10,000 characters\n**Best:** 500-3,000 characters\n**Structure:** Clear responsibilities, process, output format\n\n## Agent Organization\n\n### Plugin Agents Directory\n\n```\nplugin-name/\nâ””â”€â”€ agents/\n    â”œâ”€â”€ analyzer.md\n    â”œâ”€â”€ reviewer.md\n    â””â”€â”€ generator.md\n```\n\nAll `.md` files in `agents/` are auto-discovered.\n\n### Namespacing\n\nAgents are namespaced automatically:\n- Single plugin: `agent-name`\n- With subdirectories: `plugin:subdir:agent-name`\n\n## Testing Agents\n\n### Test Triggering\n\nCreate test scenarios to verify agent triggers correctly:\n\n1. Write agent with specific triggering examples\n2. Use similar phrasing to examples in test\n3. Check Claude loads the agent\n4. Verify agent provides expected functionality\n\n### Test System Prompt\n\nEnsure system prompt is complete:\n\n1. Give agent typical task\n2. Check it follows process steps\n3. Verify output format is correct\n4. Test edge cases mentioned in prompt\n5. Confirm quality standards are met\n\n## Quick Reference\n\n### Minimal Agent\n\n```markdown\n---\nname: simple-agent\ndescription: Use this agent when... Examples: <example>...</example>\nmodel: inherit\ncolor: blue\n---\n\nYou are an agent that [does X].\n\nProcess:\n1. [Step 1]\n2. [Step 2]\n\nOutput: [What to provide]\n```\n\n### Frontmatter Fields Summary\n\n| Field | Required | Format | Example |\n|-------|----------|--------|---------|\n| name | Yes | lowercase-hyphens | code-reviewer |\n| description | Yes | Text + examples | Use when... <example>... |\n| model | Yes | inherit/sonnet/opus/haiku | inherit |\n| color | Yes | Color name | blue |\n| tools | No | Array of tool names | [\"Read\", \"Grep\"] |\n\n### Best Practices\n\n**DO:**\n- âœ… Include 2-4 concrete examples in description\n- âœ… Write specific triggering conditions\n- âœ… Use `inherit` for model unless specific need\n- âœ… Choose appropriate tools (least privilege)\n- âœ… Write clear, structured system prompts\n- âœ… Test agent triggering thoroughly\n\n**DON'T:**\n- âŒ Use generic descriptions without examples\n- âŒ Omit triggering conditions\n- âŒ Give all agents same color\n- âŒ Grant unnecessary tool access\n- âŒ Write vague system prompts\n- âŒ Skip testing\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed guidance, consult:\n\n- **`references/system-prompt-design.md`** - Complete system prompt patterns\n- **`references/triggering-examples.md`** - Example formats and best practices\n- **`references/agent-creation-system-prompt.md`** - The exact prompt from Claude Code\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`agent-creation-prompt.md`** - AI-assisted agent generation template\n- **`complete-agent-examples.md`** - Full agent examples for different use cases\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-agent.sh`** - Validate agent file structure\n- **`test-agent-trigger.sh`** - Test if agent triggers correctly\n\n## Implementation Workflow\n\nTo create an agent for a plugin:\n\n1. Define agent purpose and triggering conditions\n2. Choose creation method (AI-assisted or manual)\n3. Create `agents/agent-name.md` file\n4. Write frontmatter with all required fields\n5. Write system prompt following best practices\n6. Include 2-4 triggering examples in description\n7. Validate with `scripts/validate-agent.sh`\n8. Test triggering with real scenarios\n9. Document agent in plugin README\n\nFocus on clear triggering conditions and comprehensive system prompts for autonomous operation."
              },
              {
                "name": "Command Development",
                "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
                "path": "plugins/plugin-dev/skills/command-development/SKILL.md",
                "frontmatter": {
                  "name": "Command Development",
                  "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
                  "version": "0.2.0"
                },
                "content": "# Command Development for Claude Code\n\n## Overview\n\nSlash commands are frequently-used prompts defined as Markdown files that Claude executes during interactive sessions. Understanding command structure, frontmatter options, and dynamic features enables creating powerful, reusable workflows.\n\n**Key concepts:**\n- Markdown file format for commands\n- YAML frontmatter for configuration\n- Dynamic arguments and file references\n- Bash execution for context\n- Command organization and namespacing\n\n## Command Basics\n\n### What is a Slash Command?\n\nA slash command is a Markdown file containing a prompt that Claude executes when invoked. Commands provide:\n- **Reusability**: Define once, use repeatedly\n- **Consistency**: Standardize common workflows\n- **Sharing**: Distribute across team or projects\n- **Efficiency**: Quick access to complex prompts\n\n### Critical: Commands are Instructions FOR Claude\n\n**Commands are written for agent consumption, not human consumption.**\n\nWhen a user invokes `/command-name`, the command content becomes Claude's instructions. Write commands as directives TO Claude about what to do, not as messages TO the user.\n\n**Correct approach (instructions for Claude):**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication issues\n\nProvide specific line numbers and severity ratings.\n```\n\n**Incorrect approach (messages to user):**\n```markdown\nThis command will review your code for security issues.\nYou'll receive a report with vulnerability details.\n```\n\nThe first example tells Claude what to do. The second tells the user what will happen but doesn't instruct Claude. Always use the first approach.\n\n### Command Locations\n\n**Project commands** (shared with team):\n- Location: `.claude/commands/`\n- Scope: Available in specific project\n- Label: Shown as \"(project)\" in `/help`\n- Use for: Team workflows, project-specific tasks\n\n**Personal commands** (available everywhere):\n- Location: `~/.claude/commands/`\n- Scope: Available in all projects\n- Label: Shown as \"(user)\" in `/help`\n- Use for: Personal workflows, cross-project utilities\n\n**Plugin commands** (bundled with plugins):\n- Location: `plugin-name/commands/`\n- Scope: Available when plugin installed\n- Label: Shown as \"(plugin-name)\" in `/help`\n- Use for: Plugin-specific functionality\n\n## File Format\n\n### Basic Structure\n\nCommands are Markdown files with `.md` extension:\n\n```\n.claude/commands/\nâ”œâ”€â”€ review.md           # /review command\nâ”œâ”€â”€ test.md             # /test command\nâ””â”€â”€ deploy.md           # /deploy command\n```\n\n**Simple command:**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication bypass\n- Insecure data handling\n```\n\nNo frontmatter needed for basic commands.\n\n### With YAML Frontmatter\n\nAdd configuration using YAML frontmatter:\n\n```markdown\n---\ndescription: Review code for security issues\nallowed-tools: Read, Grep, Bash(git:*)\nmodel: sonnet\n---\n\nReview this code for security vulnerabilities...\n```\n\n## YAML Frontmatter Fields\n\n### description\n\n**Purpose:** Brief description shown in `/help`\n**Type:** String\n**Default:** First line of command prompt\n\n```yaml\n---\ndescription: Review pull request for code quality\n---\n```\n\n**Best practice:** Clear, actionable description (under 60 characters)\n\n### allowed-tools\n\n**Purpose:** Specify which tools command can use\n**Type:** String or Array\n**Default:** Inherits from conversation\n\n```yaml\n---\nallowed-tools: Read, Write, Edit, Bash(git:*)\n---\n```\n\n**Patterns:**\n- `Read, Write, Edit` - Specific tools\n- `Bash(git:*)` - Bash with git commands only\n- `*` - All tools (rarely needed)\n\n**Use when:** Command requires specific tool access\n\n### model\n\n**Purpose:** Specify model for command execution\n**Type:** String (sonnet, opus, haiku)\n**Default:** Inherits from conversation\n\n```yaml\n---\nmodel: haiku\n---\n```\n\n**Use cases:**\n- `haiku` - Fast, simple commands\n- `sonnet` - Standard workflows\n- `opus` - Complex analysis\n\n### argument-hint\n\n**Purpose:** Document expected arguments for autocomplete\n**Type:** String\n**Default:** None\n\n```yaml\n---\nargument-hint: [pr-number] [priority] [assignee]\n---\n```\n\n**Benefits:**\n- Helps users understand command arguments\n- Improves command discovery\n- Documents command interface\n\n### disable-model-invocation\n\n**Purpose:** Prevent SlashCommand tool from programmatically calling command\n**Type:** Boolean\n**Default:** false\n\n```yaml\n---\ndisable-model-invocation: true\n---\n```\n\n**Use when:** Command should only be manually invoked\n\n## Dynamic Arguments\n\n### Using $ARGUMENTS\n\nCapture all arguments as single string:\n\n```markdown\n---\ndescription: Fix issue by number\nargument-hint: [issue-number]\n---\n\nFix issue #$ARGUMENTS following our coding standards and best practices.\n```\n\n**Usage:**\n```\n> /fix-issue 123\n> /fix-issue 456\n```\n\n**Expands to:**\n```\nFix issue #123 following our coding standards...\nFix issue #456 following our coding standards...\n```\n\n### Using Positional Arguments\n\nCapture individual arguments with `$1`, `$2`, `$3`, etc.:\n\n```markdown\n---\ndescription: Review PR with priority and assignee\nargument-hint: [pr-number] [priority] [assignee]\n---\n\nReview pull request #$1 with priority level $2.\nAfter review, assign to $3 for follow-up.\n```\n\n**Usage:**\n```\n> /review-pr 123 high alice\n```\n\n**Expands to:**\n```\nReview pull request #123 with priority level high.\nAfter review, assign to alice for follow-up.\n```\n\n### Combining Arguments\n\nMix positional and remaining arguments:\n\n```markdown\nDeploy $1 to $2 environment with options: $3\n```\n\n**Usage:**\n```\n> /deploy api staging --force --skip-tests\n```\n\n**Expands to:**\n```\nDeploy api to staging environment with options: --force --skip-tests\n```\n\n## File References\n\n### Using @ Syntax\n\nInclude file contents in command:\n\n```markdown\n---\ndescription: Review specific file\nargument-hint: [file-path]\n---\n\nReview @$1 for:\n- Code quality\n- Best practices\n- Potential bugs\n```\n\n**Usage:**\n```\n> /review-file src/api/users.ts\n```\n\n**Effect:** Claude reads `src/api/users.ts` before processing command\n\n### Multiple File References\n\nReference multiple files:\n\n```markdown\nCompare @src/old-version.js with @src/new-version.js\n\nIdentify:\n- Breaking changes\n- New features\n- Bug fixes\n```\n\n### Static File References\n\nReference known files without arguments:\n\n```markdown\nReview @package.json and @tsconfig.json for consistency\n\nEnsure:\n- TypeScript version matches\n- Dependencies are aligned\n- Build configuration is correct\n```\n\n## Bash Execution in Commands\n\nCommands can execute bash commands inline to dynamically gather context before Claude processes the command. This is useful for including repository state, environment information, or project-specific context.\n\n**When to use:**\n- Include dynamic context (git status, environment vars, etc.)\n- Gather project/repository state\n- Build context-aware workflows\n\n**Implementation details:**\nFor complete syntax, examples, and best practices, see `references/plugin-features-reference.md` section on bash execution. The reference includes the exact syntax and multiple working examples to avoid execution issues\n\n## Command Organization\n\n### Flat Structure\n\nSimple organization for small command sets:\n\n```\n.claude/commands/\nâ”œâ”€â”€ build.md\nâ”œâ”€â”€ test.md\nâ”œâ”€â”€ deploy.md\nâ”œâ”€â”€ review.md\nâ””â”€â”€ docs.md\n```\n\n**Use when:** 5-15 commands, no clear categories\n\n### Namespaced Structure\n\nOrganize commands in subdirectories:\n\n```\n.claude/commands/\nâ”œâ”€â”€ ci/\nâ”‚   â”œâ”€â”€ build.md        # /build (project:ci)\nâ”‚   â”œâ”€â”€ test.md         # /test (project:ci)\nâ”‚   â””â”€â”€ lint.md         # /lint (project:ci)\nâ”œâ”€â”€ git/\nâ”‚   â”œâ”€â”€ commit.md       # /commit (project:git)\nâ”‚   â””â”€â”€ pr.md           # /pr (project:git)\nâ””â”€â”€ docs/\n    â”œâ”€â”€ generate.md     # /generate (project:docs)\n    â””â”€â”€ publish.md      # /publish (project:docs)\n```\n\n**Benefits:**\n- Logical grouping by category\n- Namespace shown in `/help`\n- Easier to find related commands\n\n**Use when:** 15+ commands, clear categories\n\n## Best Practices\n\n### Command Design\n\n1. **Single responsibility:** One command, one task\n2. **Clear descriptions:** Self-explanatory in `/help`\n3. **Explicit dependencies:** Use `allowed-tools` when needed\n4. **Document arguments:** Always provide `argument-hint`\n5. **Consistent naming:** Use verb-noun pattern (review-pr, fix-issue)\n\n### Argument Handling\n\n1. **Validate arguments:** Check for required arguments in prompt\n2. **Provide defaults:** Suggest defaults when arguments missing\n3. **Document format:** Explain expected argument format\n4. **Handle edge cases:** Consider missing or invalid arguments\n\n```markdown\n---\nargument-hint: [pr-number]\n---\n\n$IF($1,\n  Review PR #$1,\n  Please provide a PR number. Usage: /review-pr [number]\n)\n```\n\n### File References\n\n1. **Explicit paths:** Use clear file paths\n2. **Check existence:** Handle missing files gracefully\n3. **Relative paths:** Use project-relative paths\n4. **Glob support:** Consider using Glob tool for patterns\n\n### Bash Commands\n\n1. **Limit scope:** Use `Bash(git:*)` not `Bash(*)`\n2. **Safe commands:** Avoid destructive operations\n3. **Handle errors:** Consider command failures\n4. **Keep fast:** Long-running commands slow invocation\n\n### Documentation\n\n1. **Add comments:** Explain complex logic\n2. **Provide examples:** Show usage in comments\n3. **List requirements:** Document dependencies\n4. **Version commands:** Note breaking changes\n\n```markdown\n---\ndescription: Deploy application to environment\nargument-hint: [environment] [version]\n---\n\n<!--\nUsage: /deploy [staging|production] [version]\nRequires: AWS credentials configured\nExample: /deploy staging v1.2.3\n-->\n\nDeploy application to $1 environment using version $2...\n```\n\n## Common Patterns\n\n### Review Pattern\n\n```markdown\n---\ndescription: Review code changes\nallowed-tools: Read, Bash(git:*)\n---\n\nFiles changed: !`git diff --name-only`\n\nReview each file for:\n1. Code quality and style\n2. Potential bugs or issues\n3. Test coverage\n4. Documentation needs\n\nProvide specific feedback for each file.\n```\n\n### Testing Pattern\n\n```markdown\n---\ndescription: Run tests for specific file\nargument-hint: [test-file]\nallowed-tools: Bash(npm:*)\n---\n\nRun tests: !`npm test $1`\n\nAnalyze results and suggest fixes for failures.\n```\n\n### Documentation Pattern\n\n```markdown\n---\ndescription: Generate documentation for file\nargument-hint: [source-file]\n---\n\nGenerate comprehensive documentation for @$1 including:\n- Function/class descriptions\n- Parameter documentation\n- Return value descriptions\n- Usage examples\n- Edge cases and errors\n```\n\n### Workflow Pattern\n\n```markdown\n---\ndescription: Complete PR workflow\nargument-hint: [pr-number]\nallowed-tools: Bash(gh:*), Read\n---\n\nPR #$1 Workflow:\n\n1. Fetch PR: !`gh pr view $1`\n2. Review changes\n3. Run checks\n4. Approve or request changes\n```\n\n## Troubleshooting\n\n**Command not appearing:**\n- Check file is in correct directory\n- Verify `.md` extension present\n- Ensure valid Markdown format\n- Restart Claude Code\n\n**Arguments not working:**\n- Verify `$1`, `$2` syntax correct\n- Check `argument-hint` matches usage\n- Ensure no extra spaces\n\n**Bash execution failing:**\n- Check `allowed-tools` includes Bash\n- Verify command syntax in backticks\n- Test command in terminal first\n- Check for required permissions\n\n**File references not working:**\n- Verify `@` syntax correct\n- Check file path is valid\n- Ensure Read tool allowed\n- Use absolute or project-relative paths\n\n## Plugin-Specific Features\n\n### CLAUDE_PLUGIN_ROOT Variable\n\nPlugin commands have access to `${CLAUDE_PLUGIN_ROOT}`, an environment variable that resolves to the plugin's absolute path.\n\n**Purpose:**\n- Reference plugin files portably\n- Execute plugin scripts\n- Load plugin configuration\n- Access plugin templates\n\n**Basic usage:**\n\n```markdown\n---\ndescription: Analyze using plugin script\nallowed-tools: Bash(node:*)\n---\n\nRun analysis: !`node ${CLAUDE_PLUGIN_ROOT}/scripts/analyze.js $1`\n\nReview results and report findings.\n```\n\n**Common patterns:**\n\n```markdown\n# Execute plugin script\n!`bash ${CLAUDE_PLUGIN_ROOT}/scripts/script.sh`\n\n# Load plugin configuration\n@${CLAUDE_PLUGIN_ROOT}/config/settings.json\n\n# Use plugin template\n@${CLAUDE_PLUGIN_ROOT}/templates/report.md\n\n# Access plugin resources\n@${CLAUDE_PLUGIN_ROOT}/docs/reference.md\n```\n\n**Why use it:**\n- Works across all installations\n- Portable between systems\n- No hardcoded paths needed\n- Essential for multi-file plugins\n\n### Plugin Command Organization\n\nPlugin commands discovered automatically from `commands/` directory:\n\n```\nplugin-name/\nâ”œâ”€â”€ commands/\nâ”‚   â”œâ”€â”€ foo.md              # /foo (plugin:plugin-name)\nâ”‚   â”œâ”€â”€ bar.md              # /bar (plugin:plugin-name)\nâ”‚   â””â”€â”€ utils/\nâ”‚       â””â”€â”€ helper.md       # /helper (plugin:plugin-name:utils)\nâ””â”€â”€ plugin.json\n```\n\n**Namespace benefits:**\n- Logical command grouping\n- Shown in `/help` output\n- Avoid name conflicts\n- Organize related commands\n\n**Naming conventions:**\n- Use descriptive action names\n- Avoid generic names (test, run)\n- Consider plugin-specific prefix\n- Use hyphens for multi-word names\n\n### Plugin Command Patterns\n\n**Configuration-based pattern:**\n\n```markdown\n---\ndescription: Deploy using plugin configuration\nargument-hint: [environment]\nallowed-tools: Read, Bash(*)\n---\n\nLoad configuration: @${CLAUDE_PLUGIN_ROOT}/config/$1-deploy.json\n\nDeploy to $1 using configuration settings.\nMonitor deployment and report status.\n```\n\n**Template-based pattern:**\n\n```markdown\n---\ndescription: Generate docs from template\nargument-hint: [component]\n---\n\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/docs.md\n\nGenerate documentation for $1 following template structure.\n```\n\n**Multi-script pattern:**\n\n```markdown\n---\ndescription: Complete build workflow\nallowed-tools: Bash(*)\n---\n\nBuild: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh`\nTest: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/test.sh`\nPackage: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/package.sh`\n\nReview outputs and report workflow status.\n```\n\n**See `references/plugin-features-reference.md` for detailed patterns.**\n\n## Integration with Plugin Components\n\nCommands can integrate with other plugin components for powerful workflows.\n\n### Agent Integration\n\nLaunch plugin agents for complex tasks:\n\n```markdown\n---\ndescription: Deep code review\nargument-hint: [file-path]\n---\n\nInitiate comprehensive review of @$1 using the code-reviewer agent.\n\nThe agent will analyze:\n- Code structure\n- Security issues\n- Performance\n- Best practices\n\nAgent uses plugin resources:\n- ${CLAUDE_PLUGIN_ROOT}/config/rules.json\n- ${CLAUDE_PLUGIN_ROOT}/checklists/review.md\n```\n\n**Key points:**\n- Agent must exist in `plugin/agents/` directory\n- Claude uses Task tool to launch agent\n- Document agent capabilities\n- Reference plugin resources agent uses\n\n### Skill Integration\n\nLeverage plugin skills for specialized knowledge:\n\n```markdown\n---\ndescription: Document API with standards\nargument-hint: [api-file]\n---\n\nDocument API in @$1 following plugin standards.\n\nUse the api-docs-standards skill to ensure:\n- Complete endpoint documentation\n- Consistent formatting\n- Example quality\n- Error documentation\n\nGenerate production-ready API docs.\n```\n\n**Key points:**\n- Skill must exist in `plugin/skills/` directory\n- Mention skill name to trigger invocation\n- Document skill purpose\n- Explain what skill provides\n\n### Hook Coordination\n\nDesign commands that work with plugin hooks:\n- Commands can prepare state for hooks to process\n- Hooks execute automatically on tool events\n- Commands should document expected hook behavior\n- Guide Claude on interpreting hook output\n\nSee `references/plugin-features-reference.md` for examples of commands that coordinate with hooks\n\n### Multi-Component Workflows\n\nCombine agents, skills, and scripts:\n\n```markdown\n---\ndescription: Comprehensive review workflow\nargument-hint: [file]\nallowed-tools: Bash(node:*), Read\n---\n\nTarget: @$1\n\nPhase 1 - Static Analysis:\n!`node ${CLAUDE_PLUGIN_ROOT}/scripts/lint.js $1`\n\nPhase 2 - Deep Review:\nLaunch code-reviewer agent for detailed analysis.\n\nPhase 3 - Standards Check:\nUse coding-standards skill for validation.\n\nPhase 4 - Report:\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/review.md\n\nCompile findings into report following template.\n```\n\n**When to use:**\n- Complex multi-step workflows\n- Leverage multiple plugin capabilities\n- Require specialized analysis\n- Need structured outputs\n\n## Validation Patterns\n\nCommands should validate inputs and resources before processing.\n\n### Argument Validation\n\n```markdown\n---\ndescription: Deploy with validation\nargument-hint: [environment]\n---\n\nValidate environment: !`echo \"$1\" | grep -E \"^(dev|staging|prod)$\" || echo \"INVALID\"`\n\nIf $1 is valid environment:\n  Deploy to $1\nOtherwise:\n  Explain valid environments: dev, staging, prod\n  Show usage: /deploy [environment]\n```\n\n### File Existence Checks\n\n```markdown\n---\ndescription: Process configuration\nargument-hint: [config-file]\n---\n\nCheck file exists: !`test -f $1 && echo \"EXISTS\" || echo \"MISSING\"`\n\nIf file exists:\n  Process configuration: @$1\nOtherwise:\n  Explain where to place config file\n  Show expected format\n  Provide example configuration\n```\n\n### Plugin Resource Validation\n\n```markdown\n---\ndescription: Run plugin analyzer\nallowed-tools: Bash(test:*)\n---\n\nValidate plugin setup:\n- Script: !`test -x ${CLAUDE_PLUGIN_ROOT}/bin/analyze && echo \"âœ“\" || echo \"âœ—\"`\n- Config: !`test -f ${CLAUDE_PLUGIN_ROOT}/config.json && echo \"âœ“\" || echo \"âœ—\"`\n\nIf all checks pass, run analysis.\nOtherwise, report missing components.\n```\n\n### Error Handling\n\n```markdown\n---\ndescription: Build with error handling\nallowed-tools: Bash(*)\n---\n\nExecute build: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh 2>&1 || echo \"BUILD_FAILED\"`\n\nIf build succeeded:\n  Report success and output location\nIf build failed:\n  Analyze error output\n  Suggest likely causes\n  Provide troubleshooting steps\n```\n\n**Best practices:**\n- Validate early in command\n- Provide helpful error messages\n- Suggest corrective actions\n- Handle edge cases gracefully\n\n---\n\nFor detailed frontmatter field specifications, see `references/frontmatter-reference.md`.\nFor plugin-specific features and patterns, see `references/plugin-features-reference.md`.\nFor command pattern examples, see `examples/` directory."
              },
              {
                "name": "Hook Development",
                "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
                "path": "plugins/plugin-dev/skills/hook-development/SKILL.md",
                "frontmatter": {
                  "name": "Hook Development",
                  "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
                  "version": "0.1.0"
                },
                "content": "# Hook Development for Claude Code Plugins\n\n## Overview\n\nHooks are event-driven automation scripts that execute in response to Claude Code events. Use hooks to validate operations, enforce policies, add context, and integrate external tools into workflows.\n\n**Key capabilities:**\n- Validate tool calls before execution (PreToolUse)\n- React to tool results (PostToolUse)\n- Enforce completion standards (Stop, SubagentStop)\n- Load project context (SessionStart)\n- Automate workflows across the development lifecycle\n\n## Hook Types\n\n### Prompt-Based Hooks (Recommended)\n\nUse LLM-driven decision making for context-aware validation:\n\n```json\n{\n  \"type\": \"prompt\",\n  \"prompt\": \"Evaluate if this tool use is appropriate: $TOOL_INPUT\",\n  \"timeout\": 30\n}\n```\n\n**Supported events:** Stop, SubagentStop, UserPromptSubmit, PreToolUse\n\n**Benefits:**\n- Context-aware decisions based on natural language reasoning\n- Flexible evaluation logic without bash scripting\n- Better edge case handling\n- Easier to maintain and extend\n\n### Command Hooks\n\nExecute bash commands for deterministic checks:\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\",\n  \"timeout\": 60\n}\n```\n\n**Use for:**\n- Fast deterministic validations\n- File system operations\n- External tool integrations\n- Performance-critical checks\n\n## Hook Configuration Formats\n\n### Plugin hooks.json Format\n\n**For plugin hooks** in `hooks/hooks.json`, use wrapper format:\n\n```json\n{\n  \"description\": \"Brief explanation of hooks (optional)\",\n  \"hooks\": {\n    \"PreToolUse\": [...],\n    \"Stop\": [...],\n    \"SessionStart\": [...]\n  }\n}\n```\n\n**Key points:**\n- `description` field is optional\n- `hooks` field is required wrapper containing actual hook events\n- This is the **plugin-specific format**\n\n**Example:**\n```json\n{\n  \"description\": \"Validation hooks for code quality\",\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Write\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/validate.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n### Settings Format (Direct)\n\n**For user settings** in `.claude/settings.json`, use direct format:\n\n```json\n{\n  \"PreToolUse\": [...],\n  \"Stop\": [...],\n  \"SessionStart\": [...]\n}\n```\n\n**Key points:**\n- No wrapper - events directly at top level\n- No description field\n- This is the **settings format**\n\n**Important:** The examples below show the hook event structure that goes inside either format. For plugin hooks.json, wrap these in `{\"hooks\": {...}}`.\n\n## Hook Events\n\n### PreToolUse\n\nExecute before any tool runs. Use to approve, deny, or modify tool calls.\n\n**Example (prompt-based):**\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety. Check: system paths, credentials, path traversal, sensitive content. Return 'approve' or 'deny'.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output for PreToolUse:**\n```json\n{\n  \"hookSpecificOutput\": {\n    \"permissionDecision\": \"allow|deny|ask\",\n    \"updatedInput\": {\"field\": \"modified_value\"}\n  },\n  \"systemMessage\": \"Explanation for Claude\"\n}\n```\n\n### PostToolUse\n\nExecute after tool completes. Use to react to results, provide feedback, or log.\n\n**Example:**\n```json\n{\n  \"PostToolUse\": [\n    {\n      \"matcher\": \"Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Analyze edit result for potential issues: syntax errors, security vulnerabilities, breaking changes. Provide feedback.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output behavior:**\n- Exit 0: stdout shown in transcript\n- Exit 2: stderr fed back to Claude\n- systemMessage included in context\n\n### Stop\n\nExecute when main agent considers stopping. Use to validate completeness.\n\n**Example:**\n```json\n{\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion: tests run, build succeeded, questions answered. Return 'approve' to stop or 'block' with reason to continue.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Decision output:**\n```json\n{\n  \"decision\": \"approve|block\",\n  \"reason\": \"Explanation\",\n  \"systemMessage\": \"Additional context\"\n}\n```\n\n### SubagentStop\n\nExecute when subagent considers stopping. Use to ensure subagent completed its task.\n\nSimilar to Stop hook, but for subagents.\n\n### UserPromptSubmit\n\nExecute when user submits a prompt. Use to add context, validate, or block prompts.\n\n**Example:**\n```json\n{\n  \"UserPromptSubmit\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Check if prompt requires security guidance. If discussing auth, permissions, or API security, return relevant warnings.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### SessionStart\n\nExecute when Claude Code session begins. Use to load context and set environment.\n\n**Example:**\n```json\n{\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Special capability:** Persist environment variables using `$CLAUDE_ENV_FILE`:\n```bash\necho \"export PROJECT_TYPE=nodejs\" >> \"$CLAUDE_ENV_FILE\"\n```\n\nSee `examples/load-context.sh` for complete example.\n\n### SessionEnd\n\nExecute when session ends. Use for cleanup, logging, and state preservation.\n\n### PreCompact\n\nExecute before context compaction. Use to add critical information to preserve.\n\n### Notification\n\nExecute when Claude sends notifications. Use to react to user notifications.\n\n## Hook Output Format\n\n### Standard Output (All Hooks)\n\n```json\n{\n  \"continue\": true,\n  \"suppressOutput\": false,\n  \"systemMessage\": \"Message for Claude\"\n}\n```\n\n- `continue`: If false, halt processing (default true)\n- `suppressOutput`: Hide output from transcript (default false)\n- `systemMessage`: Message shown to Claude\n\n### Exit Codes\n\n- `0` - Success (stdout shown in transcript)\n- `2` - Blocking error (stderr fed back to Claude)\n- Other - Non-blocking error\n\n## Hook Input Format\n\nAll hooks receive JSON via stdin with common fields:\n\n```json\n{\n  \"session_id\": \"abc123\",\n  \"transcript_path\": \"/path/to/transcript.txt\",\n  \"cwd\": \"/current/working/dir\",\n  \"permission_mode\": \"ask|allow\",\n  \"hook_event_name\": \"PreToolUse\"\n}\n```\n\n**Event-specific fields:**\n\n- **PreToolUse/PostToolUse:** `tool_name`, `tool_input`, `tool_result`\n- **UserPromptSubmit:** `user_prompt`\n- **Stop/SubagentStop:** `reason`\n\nAccess fields in prompts using `$TOOL_INPUT`, `$TOOL_RESULT`, `$USER_PROMPT`, etc.\n\n## Environment Variables\n\nAvailable in all command hooks:\n\n- `$CLAUDE_PROJECT_DIR` - Project root path\n- `$CLAUDE_PLUGIN_ROOT` - Plugin directory (use for portable paths)\n- `$CLAUDE_ENV_FILE` - SessionStart only: persist env vars here\n- `$CLAUDE_CODE_REMOTE` - Set if running in remote context\n\n**Always use ${CLAUDE_PLUGIN_ROOT} in hook commands for portability:**\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\"\n}\n```\n\n## Plugin Hook Configuration\n\nIn plugins, define hooks in `hooks/hooks.json`:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety\"\n        }\n      ]\n    }\n  ],\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion\"\n        }\n      ]\n    }\n  ],\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\",\n          \"timeout\": 10\n        }\n      ]\n    }\n  ]\n}\n```\n\nPlugin hooks merge with user's hooks and run in parallel.\n\n## Matchers\n\n### Tool Name Matching\n\n**Exact match:**\n```json\n\"matcher\": \"Write\"\n```\n\n**Multiple tools:**\n```json\n\"matcher\": \"Read|Write|Edit\"\n```\n\n**Wildcard (all tools):**\n```json\n\"matcher\": \"*\"\n```\n\n**Regex patterns:**\n```json\n\"matcher\": \"mcp__.*__delete.*\"  // All MCP delete tools\n```\n\n**Note:** Matchers are case-sensitive.\n\n### Common Patterns\n\n```json\n// All MCP tools\n\"matcher\": \"mcp__.*\"\n\n// Specific plugin's MCP tools\n\"matcher\": \"mcp__plugin_asana_.*\"\n\n// All file operations\n\"matcher\": \"Read|Write|Edit\"\n\n// Bash commands only\n\"matcher\": \"Bash\"\n```\n\n## Security Best Practices\n\n### Input Validation\n\nAlways validate inputs in command hooks:\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\ninput=$(cat)\ntool_name=$(echo \"$input\" | jq -r '.tool_name')\n\n# Validate tool name format\nif [[ ! \"$tool_name\" =~ ^[a-zA-Z0-9_]+$ ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Invalid tool name\"}' >&2\n  exit 2\nfi\n```\n\n### Path Safety\n\nCheck for path traversal and sensitive files:\n\n```bash\nfile_path=$(echo \"$input\" | jq -r '.tool_input.file_path')\n\n# Deny path traversal\nif [[ \"$file_path\" == *\"..\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Path traversal detected\"}' >&2\n  exit 2\nfi\n\n# Deny sensitive files\nif [[ \"$file_path\" == *\".env\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Sensitive file\"}' >&2\n  exit 2\nfi\n```\n\nSee `examples/validate-write.sh` and `examples/validate-bash.sh` for complete examples.\n\n### Quote All Variables\n\n```bash\n# GOOD: Quoted\necho \"$file_path\"\ncd \"$CLAUDE_PROJECT_DIR\"\n\n# BAD: Unquoted (injection risk)\necho $file_path\ncd $CLAUDE_PROJECT_DIR\n```\n\n### Set Appropriate Timeouts\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash script.sh\",\n  \"timeout\": 10\n}\n```\n\n**Defaults:** Command hooks (60s), Prompt hooks (30s)\n\n## Performance Considerations\n\n### Parallel Execution\n\nAll matching hooks run **in parallel**:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write\",\n      \"hooks\": [\n        {\"type\": \"command\", \"command\": \"check1.sh\"},  // Parallel\n        {\"type\": \"command\", \"command\": \"check2.sh\"},  // Parallel\n        {\"type\": \"prompt\", \"prompt\": \"Validate...\"}   // Parallel\n      ]\n    }\n  ]\n}\n```\n\n**Design implications:**\n- Hooks don't see each other's output\n- Non-deterministic ordering\n- Design for independence\n\n### Optimization\n\n1. Use command hooks for quick deterministic checks\n2. Use prompt hooks for complex reasoning\n3. Cache validation results in temp files\n4. Minimize I/O in hot paths\n\n## Temporarily Active Hooks\n\nCreate hooks that activate conditionally by checking for a flag file or configuration:\n\n**Pattern: Flag file activation**\n```bash\n#!/bin/bash\n# Only active when flag file exists\nFLAG_FILE=\"$CLAUDE_PROJECT_DIR/.enable-strict-validation\"\n\nif [ ! -f \"$FLAG_FILE\" ]; then\n  # Flag not present, skip validation\n  exit 0\nfi\n\n# Flag present, run validation\ninput=$(cat)\n# ... validation logic ...\n```\n\n**Pattern: Configuration-based activation**\n```bash\n#!/bin/bash\n# Check configuration for activation\nCONFIG_FILE=\"$CLAUDE_PROJECT_DIR/.claude/plugin-config.json\"\n\nif [ -f \"$CONFIG_FILE\" ]; then\n  enabled=$(jq -r '.strictMode // false' \"$CONFIG_FILE\")\n  if [ \"$enabled\" != \"true\" ]; then\n    exit 0  # Not enabled, skip\n  fi\nfi\n\n# Enabled, run hook logic\ninput=$(cat)\n# ... hook logic ...\n```\n\n**Use cases:**\n- Enable strict validation only when needed\n- Temporary debugging hooks\n- Project-specific hook behavior\n- Feature flags for hooks\n\n**Best practice:** Document activation mechanism in plugin README so users know how to enable/disable temporary hooks.\n\n## Hook Lifecycle and Limitations\n\n### Hooks Load at Session Start\n\n**Important:** Hooks are loaded when Claude Code session starts. Changes to hook configuration require restarting Claude Code.\n\n**Cannot hot-swap hooks:**\n- Editing `hooks/hooks.json` won't affect current session\n- Adding new hook scripts won't be recognized\n- Changing hook commands/prompts won't update\n- Must restart Claude Code: exit and run `claude` again\n\n**To test hook changes:**\n1. Edit hook configuration or scripts\n2. Exit Claude Code session\n3. Restart: `claude` or `cc`\n4. New hook configuration loads\n5. Test hooks with `claude --debug`\n\n### Hook Validation at Startup\n\nHooks are validated when Claude Code starts:\n- Invalid JSON in hooks.json causes loading failure\n- Missing scripts cause warnings\n- Syntax errors reported in debug mode\n\nUse `/hooks` command to review loaded hooks in current session.\n\n## Debugging Hooks\n\n### Enable Debug Mode\n\n```bash\nclaude --debug\n```\n\nLook for hook registration, execution logs, input/output JSON, and timing information.\n\n### Test Hook Scripts\n\nTest command hooks directly:\n\n```bash\necho '{\"tool_name\": \"Write\", \"tool_input\": {\"file_path\": \"/test\"}}' | \\\n  bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\n\necho \"Exit code: $?\"\n```\n\n### Validate JSON Output\n\nEnsure hooks output valid JSON:\n\n```bash\noutput=$(./your-hook.sh < test-input.json)\necho \"$output\" | jq .\n```\n\n## Quick Reference\n\n### Hook Events Summary\n\n| Event | When | Use For |\n|-------|------|---------|\n| PreToolUse | Before tool | Validation, modification |\n| PostToolUse | After tool | Feedback, logging |\n| UserPromptSubmit | User input | Context, validation |\n| Stop | Agent stopping | Completeness check |\n| SubagentStop | Subagent done | Task validation |\n| SessionStart | Session begins | Context loading |\n| SessionEnd | Session ends | Cleanup, logging |\n| PreCompact | Before compact | Preserve context |\n| Notification | User notified | Logging, reactions |\n\n### Best Practices\n\n**DO:**\n- âœ… Use prompt-based hooks for complex logic\n- âœ… Use ${CLAUDE_PLUGIN_ROOT} for portability\n- âœ… Validate all inputs in command hooks\n- âœ… Quote all bash variables\n- âœ… Set appropriate timeouts\n- âœ… Return structured JSON output\n- âœ… Test hooks thoroughly\n\n**DON'T:**\n- âŒ Use hardcoded paths\n- âŒ Trust user input without validation\n- âŒ Create long-running hooks\n- âŒ Rely on hook execution order\n- âŒ Modify global state unpredictably\n- âŒ Log sensitive information\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and advanced techniques, consult:\n\n- **`references/patterns.md`** - Common hook patterns (8+ proven patterns)\n- **`references/migration.md`** - Migrating from basic to advanced hooks\n- **`references/advanced.md`** - Advanced use cases and techniques\n\n### Example Hook Scripts\n\nWorking examples in `examples/`:\n\n- **`validate-write.sh`** - File write validation example\n- **`validate-bash.sh`** - Bash command validation example\n- **`load-context.sh`** - SessionStart context loading example\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-hook-schema.sh`** - Validate hooks.json structure and syntax\n- **`test-hook.sh`** - Test hooks with sample input before deployment\n- **`hook-linter.sh`** - Check hook scripts for common issues and best practices\n\n### External Resources\n\n- **Official Docs**: https://docs.claude.com/en/docs/claude-code/hooks\n- **Examples**: See security-guidance plugin in marketplace\n- **Testing**: Use `claude --debug` for detailed logs\n- **Validation**: Use `jq` to validate hook JSON output\n\n## Implementation Workflow\n\nTo implement hooks in a plugin:\n\n1. Identify events to hook into (PreToolUse, Stop, SessionStart, etc.)\n2. Decide between prompt-based (flexible) or command (deterministic) hooks\n3. Write hook configuration in `hooks/hooks.json`\n4. For command hooks, create hook scripts\n5. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n6. Validate configuration with `scripts/validate-hook-schema.sh hooks/hooks.json`\n7. Test hooks with `scripts/test-hook.sh` before deployment\n8. Test in Claude Code with `claude --debug`\n9. Document hooks in plugin README\n\nFocus on prompt-based hooks for most use cases. Reserve command hooks for performance-critical or deterministic checks."
              },
              {
                "name": "MCP Integration",
                "description": "This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration.",
                "path": "plugins/plugin-dev/skills/mcp-integration/SKILL.md",
                "frontmatter": {
                  "name": "MCP Integration",
                  "description": "This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration.",
                  "version": "0.1.0"
                },
                "content": "# MCP Integration for Claude Code Plugins\n\n## Overview\n\nModel Context Protocol (MCP) enables Claude Code plugins to integrate with external services and APIs by providing structured tool access. Use MCP integration to expose external service capabilities as tools within Claude Code.\n\n**Key capabilities:**\n- Connect to external services (databases, APIs, file systems)\n- Provide 10+ related tools from a single service\n- Handle OAuth and complex authentication flows\n- Bundle MCP servers with plugins for automatic setup\n\n## MCP Server Configuration Methods\n\nPlugins can bundle MCP servers in two ways:\n\n### Method 1: Dedicated .mcp.json (Recommended)\n\nCreate `.mcp.json` at plugin root:\n\n```json\n{\n  \"database-tools\": {\n    \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/db-server\",\n    \"args\": [\"--config\", \"${CLAUDE_PLUGIN_ROOT}/config.json\"],\n    \"env\": {\n      \"DB_URL\": \"${DB_URL}\"\n    }\n  }\n}\n```\n\n**Benefits:**\n- Clear separation of concerns\n- Easier to maintain\n- Better for multiple servers\n\n### Method 2: Inline in plugin.json\n\nAdd `mcpServers` field to plugin.json:\n\n```json\n{\n  \"name\": \"my-plugin\",\n  \"version\": \"1.0.0\",\n  \"mcpServers\": {\n    \"plugin-api\": {\n      \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/api-server\",\n      \"args\": [\"--port\", \"8080\"]\n    }\n  }\n}\n```\n\n**Benefits:**\n- Single configuration file\n- Good for simple single-server plugins\n\n## MCP Server Types\n\n### stdio (Local Process)\n\nExecute local MCP servers as child processes. Best for local tools and custom servers.\n\n**Configuration:**\n```json\n{\n  \"filesystem\": {\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/allowed/path\"],\n    \"env\": {\n      \"LOG_LEVEL\": \"debug\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- File system access\n- Local database connections\n- Custom MCP servers\n- NPM-packaged MCP servers\n\n**Process management:**\n- Claude Code spawns and manages the process\n- Communicates via stdin/stdout\n- Terminates when Claude Code exits\n\n### SSE (Server-Sent Events)\n\nConnect to hosted MCP servers with OAuth support. Best for cloud services.\n\n**Configuration:**\n```json\n{\n  \"asana\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.asana.com/sse\"\n  }\n}\n```\n\n**Use cases:**\n- Official hosted MCP servers (Asana, GitHub, etc.)\n- Cloud services with MCP endpoints\n- OAuth-based authentication\n- No local installation needed\n\n**Authentication:**\n- OAuth flows handled automatically\n- User prompted on first use\n- Tokens managed by Claude Code\n\n### HTTP (REST API)\n\nConnect to RESTful MCP servers with token authentication.\n\n**Configuration:**\n```json\n{\n  \"api-service\": {\n    \"type\": \"http\",\n    \"url\": \"https://api.example.com/mcp\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${API_TOKEN}\",\n      \"X-Custom-Header\": \"value\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- REST API-based MCP servers\n- Token-based authentication\n- Custom API backends\n- Stateless interactions\n\n### WebSocket (Real-time)\n\nConnect to WebSocket MCP servers for real-time bidirectional communication.\n\n**Configuration:**\n```json\n{\n  \"realtime-service\": {\n    \"type\": \"ws\",\n    \"url\": \"wss://mcp.example.com/ws\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${TOKEN}\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- Real-time data streaming\n- Persistent connections\n- Push notifications from server\n- Low-latency requirements\n\n## Environment Variable Expansion\n\nAll MCP configurations support environment variable substitution:\n\n**${CLAUDE_PLUGIN_ROOT}** - Plugin directory (always use for portability):\n```json\n{\n  \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/my-server\"\n}\n```\n\n**User environment variables** - From user's shell:\n```json\n{\n  \"env\": {\n    \"API_KEY\": \"${MY_API_KEY}\",\n    \"DATABASE_URL\": \"${DB_URL}\"\n  }\n}\n```\n\n**Best practice:** Document all required environment variables in plugin README.\n\n## MCP Tool Naming\n\nWhen MCP servers provide tools, they're automatically prefixed:\n\n**Format:** `mcp__plugin_<plugin-name>_<server-name>__<tool-name>`\n\n**Example:**\n- Plugin: `asana`\n- Server: `asana`\n- Tool: `create_task`\n- **Full name:** `mcp__plugin_asana_asana__asana_create_task`\n\n### Using MCP Tools in Commands\n\nPre-allow specific MCP tools in command frontmatter:\n\n```markdown\n---\nallowed-tools: [\n  \"mcp__plugin_asana_asana__asana_create_task\",\n  \"mcp__plugin_asana_asana__asana_search_tasks\"\n]\n---\n```\n\n**Wildcard (use sparingly):**\n```markdown\n---\nallowed-tools: [\"mcp__plugin_asana_asana__*\"]\n---\n```\n\n**Best practice:** Pre-allow specific tools, not wildcards, for security.\n\n## Lifecycle Management\n\n**Automatic startup:**\n- MCP servers start when plugin enables\n- Connection established before first tool use\n- Restart required for configuration changes\n\n**Lifecycle:**\n1. Plugin loads\n2. MCP configuration parsed\n3. Server process started (stdio) or connection established (SSE/HTTP/WS)\n4. Tools discovered and registered\n5. Tools available as `mcp__plugin_...__...`\n\n**Viewing servers:**\nUse `/mcp` command to see all servers including plugin-provided ones.\n\n## Authentication Patterns\n\n### OAuth (SSE/HTTP)\n\nOAuth handled automatically by Claude Code:\n\n```json\n{\n  \"type\": \"sse\",\n  \"url\": \"https://mcp.example.com/sse\"\n}\n```\n\nUser authenticates in browser on first use. No additional configuration needed.\n\n### Token-Based (Headers)\n\nStatic or environment variable tokens:\n\n```json\n{\n  \"type\": \"http\",\n  \"url\": \"https://api.example.com\",\n  \"headers\": {\n    \"Authorization\": \"Bearer ${API_TOKEN}\"\n  }\n}\n```\n\nDocument required environment variables in README.\n\n### Environment Variables (stdio)\n\nPass configuration to MCP server:\n\n```json\n{\n  \"command\": \"python\",\n  \"args\": [\"-m\", \"my_mcp_server\"],\n  \"env\": {\n    \"DATABASE_URL\": \"${DB_URL}\",\n    \"API_KEY\": \"${API_KEY}\",\n    \"LOG_LEVEL\": \"info\"\n  }\n}\n```\n\n## Integration Patterns\n\n### Pattern 1: Simple Tool Wrapper\n\nCommands use MCP tools with user interaction:\n\n```markdown\n# Command: create-item.md\n---\nallowed-tools: [\"mcp__plugin_name_server__create_item\"]\n---\n\nSteps:\n1. Gather item details from user\n2. Use mcp__plugin_name_server__create_item\n3. Confirm creation\n```\n\n**Use for:** Adding validation or preprocessing before MCP calls.\n\n### Pattern 2: Autonomous Agent\n\nAgents use MCP tools autonomously:\n\n```markdown\n# Agent: data-analyzer.md\n\nAnalysis Process:\n1. Query data via mcp__plugin_db_server__query\n2. Process and analyze results\n3. Generate insights report\n```\n\n**Use for:** Multi-step MCP workflows without user interaction.\n\n### Pattern 3: Multi-Server Plugin\n\nIntegrate multiple MCP servers:\n\n```json\n{\n  \"github\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.github.com/sse\"\n  },\n  \"jira\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.jira.com/sse\"\n  }\n}\n```\n\n**Use for:** Workflows spanning multiple services.\n\n## Security Best Practices\n\n### Use HTTPS/WSS\n\nAlways use secure connections:\n\n```json\nâœ… \"url\": \"https://mcp.example.com/sse\"\nâŒ \"url\": \"http://mcp.example.com/sse\"\n```\n\n### Token Management\n\n**DO:**\n- âœ… Use environment variables for tokens\n- âœ… Document required env vars in README\n- âœ… Let OAuth flow handle authentication\n\n**DON'T:**\n- âŒ Hardcode tokens in configuration\n- âŒ Commit tokens to git\n- âŒ Share tokens in documentation\n\n### Permission Scoping\n\nPre-allow only necessary MCP tools:\n\n```markdown\nâœ… allowed-tools: [\n  \"mcp__plugin_api_server__read_data\",\n  \"mcp__plugin_api_server__create_item\"\n]\n\nâŒ allowed-tools: [\"mcp__plugin_api_server__*\"]\n```\n\n## Error Handling\n\n### Connection Failures\n\nHandle MCP server unavailability:\n- Provide fallback behavior in commands\n- Inform user of connection issues\n- Check server URL and configuration\n\n### Tool Call Errors\n\nHandle failed MCP operations:\n- Validate inputs before calling MCP tools\n- Provide clear error messages\n- Check rate limiting and quotas\n\n### Configuration Errors\n\nValidate MCP configuration:\n- Test server connectivity during development\n- Validate JSON syntax\n- Check required environment variables\n\n## Performance Considerations\n\n### Lazy Loading\n\nMCP servers connect on-demand:\n- Not all servers connect at startup\n- First tool use triggers connection\n- Connection pooling managed automatically\n\n### Batching\n\nBatch similar requests when possible:\n\n```\n# Good: Single query with filters\ntasks = search_tasks(project=\"X\", assignee=\"me\", limit=50)\n\n# Avoid: Many individual queries\nfor id in task_ids:\n    task = get_task(id)\n```\n\n## Testing MCP Integration\n\n### Local Testing\n\n1. Configure MCP server in `.mcp.json`\n2. Install plugin locally (`.claude-plugin/`)\n3. Run `/mcp` to verify server appears\n4. Test tool calls in commands\n5. Check `claude --debug` logs for connection issues\n\n### Validation Checklist\n\n- [ ] MCP configuration is valid JSON\n- [ ] Server URL is correct and accessible\n- [ ] Required environment variables documented\n- [ ] Tools appear in `/mcp` output\n- [ ] Authentication works (OAuth or tokens)\n- [ ] Tool calls succeed from commands\n- [ ] Error cases handled gracefully\n\n## Debugging\n\n### Enable Debug Logging\n\n```bash\nclaude --debug\n```\n\nLook for:\n- MCP server connection attempts\n- Tool discovery logs\n- Authentication flows\n- Tool call errors\n\n### Common Issues\n\n**Server not connecting:**\n- Check URL is correct\n- Verify server is running (stdio)\n- Check network connectivity\n- Review authentication configuration\n\n**Tools not available:**\n- Verify server connected successfully\n- Check tool names match exactly\n- Run `/mcp` to see available tools\n- Restart Claude Code after config changes\n\n**Authentication failing:**\n- Clear cached auth tokens\n- Re-authenticate\n- Check token scopes and permissions\n- Verify environment variables set\n\n## Quick Reference\n\n### MCP Server Types\n\n| Type | Transport | Best For | Auth |\n|------|-----------|----------|------|\n| stdio | Process | Local tools, custom servers | Env vars |\n| SSE | HTTP | Hosted services, cloud APIs | OAuth |\n| HTTP | REST | API backends, token auth | Tokens |\n| ws | WebSocket | Real-time, streaming | Tokens |\n\n### Configuration Checklist\n\n- [ ] Server type specified (stdio/SSE/HTTP/ws)\n- [ ] Type-specific fields complete (command or url)\n- [ ] Authentication configured\n- [ ] Environment variables documented\n- [ ] HTTPS/WSS used (not HTTP/WS)\n- [ ] ${CLAUDE_PLUGIN_ROOT} used for paths\n\n### Best Practices\n\n**DO:**\n- âœ… Use ${CLAUDE_PLUGIN_ROOT} for portable paths\n- âœ… Document required environment variables\n- âœ… Use secure connections (HTTPS/WSS)\n- âœ… Pre-allow specific MCP tools in commands\n- âœ… Test MCP integration before publishing\n- âœ… Handle connection and tool errors gracefully\n\n**DON'T:**\n- âŒ Hardcode absolute paths\n- âŒ Commit credentials to git\n- âŒ Use HTTP instead of HTTPS\n- âŒ Pre-allow all tools with wildcards\n- âŒ Skip error handling\n- âŒ Forget to document setup\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed information, consult:\n\n- **`references/server-types.md`** - Deep dive on each server type\n- **`references/authentication.md`** - Authentication patterns and OAuth\n- **`references/tool-usage.md`** - Using MCP tools in commands and agents\n\n### Example Configurations\n\nWorking examples in `examples/`:\n\n- **`stdio-server.json`** - Local stdio MCP server\n- **`sse-server.json`** - Hosted SSE server with OAuth\n- **`http-server.json`** - REST API with token auth\n\n### External Resources\n\n- **Official MCP Docs**: https://modelcontextprotocol.io/\n- **Claude Code MCP Docs**: https://docs.claude.com/en/docs/claude-code/mcp\n- **MCP SDK**: @modelcontextprotocol/sdk\n- **Testing**: Use `claude --debug` and `/mcp` command\n\n## Implementation Workflow\n\nTo add MCP integration to a plugin:\n\n1. Choose MCP server type (stdio, SSE, HTTP, ws)\n2. Create `.mcp.json` at plugin root with configuration\n3. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n4. Document required environment variables in README\n5. Test locally with `/mcp` command\n6. Pre-allow MCP tools in relevant commands\n7. Handle authentication (OAuth or tokens)\n8. Test error cases (connection failures, auth errors)\n9. Document MCP integration in plugin README\n\nFocus on stdio for custom/local servers, SSE for hosted services with OAuth."
              },
              {
                "name": "Plugin Settings",
                "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.",
                "path": "plugins/plugin-dev/skills/plugin-settings/SKILL.md",
                "frontmatter": {
                  "name": "Plugin Settings",
                  "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.",
                  "version": "0.1.0"
                },
                "content": "# Plugin Settings Pattern for Claude Code Plugins\n\n## Overview\n\nPlugins can store user-configurable settings and state in `.claude/plugin-name.local.md` files within the project directory. This pattern uses YAML frontmatter for structured configuration and markdown content for prompts or additional context.\n\n**Key characteristics:**\n- File location: `.claude/plugin-name.local.md` in project root\n- Structure: YAML frontmatter + markdown body\n- Purpose: Per-project plugin configuration and state\n- Usage: Read from hooks, commands, and agents\n- Lifecycle: User-managed (not in git, should be in `.gitignore`)\n\n## File Structure\n\n### Basic Template\n\n```markdown\n---\nenabled: true\nsetting1: value1\nsetting2: value2\nnumeric_setting: 42\nlist_setting: [\"item1\", \"item2\"]\n---\n\n# Additional Context\n\nThis markdown body can contain:\n- Task descriptions\n- Additional instructions\n- Prompts to feed back to Claude\n- Documentation or notes\n```\n\n### Example: Plugin State File\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nenabled: true\nstrict_mode: false\nmax_retries: 3\nnotification_level: info\ncoordinator_session: team-leader\n---\n\n# Plugin Configuration\n\nThis plugin is configured for standard validation mode.\nContact @team-lead with questions.\n```\n\n## Reading Settings Files\n\n### From Hooks (Bash Scripts)\n\n**Pattern: Check existence and parse frontmatter**\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\n# Define state file path\nSTATE_FILE=\".claude/my-plugin.local.md\"\n\n# Quick exit if file doesn't exist\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0  # Plugin not configured, skip\nfi\n\n# Parse YAML frontmatter (between --- markers)\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\n\n# Extract individual fields\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\nSTRICT_MODE=$(echo \"$FRONTMATTER\" | grep '^strict_mode:' | sed 's/strict_mode: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n\n# Check if enabled\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Use configuration in hook logic\nif [[ \"$STRICT_MODE\" == \"true\" ]]; then\n  # Apply strict validation\n  # ...\nfi\n```\n\nSee `examples/read-settings-hook.sh` for complete working example.\n\n### From Commands\n\nCommands can read settings files to customize behavior:\n\n```markdown\n---\ndescription: Process data with plugin\nallowed-tools: [\"Read\", \"Bash\"]\n---\n\n# Process Command\n\nSteps:\n1. Check if settings exist at `.claude/my-plugin.local.md`\n2. Read configuration using Read tool\n3. Parse YAML frontmatter to extract settings\n4. Apply settings to processing logic\n5. Execute with configured behavior\n```\n\n### From Agents\n\nAgents can reference settings in their instructions:\n\n```markdown\n---\nname: configured-agent\ndescription: Agent that adapts to project settings\n---\n\nCheck for plugin settings at `.claude/my-plugin.local.md`.\nIf present, parse YAML frontmatter and adapt behavior according to:\n- enabled: Whether plugin is active\n- mode: Processing mode (strict, standard, lenient)\n- Additional configuration fields\n```\n\n## Parsing Techniques\n\n### Extract Frontmatter\n\n```bash\n# Extract everything between --- markers\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n```\n\n### Read Individual Fields\n\n**String fields:**\n```bash\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field_name:' | sed 's/field_name: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n**Boolean fields:**\n```bash\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n# Compare: if [[ \"$ENABLED\" == \"true\" ]]; then\n```\n\n**Numeric fields:**\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n# Use: if [[ $MAX -gt 100 ]]; then\n```\n\n### Read Markdown Body\n\nExtract content after second `---`:\n\n```bash\n# Get everything after closing ---\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n## Common Patterns\n\n### Pattern 1: Temporarily Active Hooks\n\nUse settings file to control hook activation:\n\n```bash\n#!/bin/bash\nSTATE_FILE=\".claude/security-scan.local.md\"\n\n# Quick exit if not configured\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0\nfi\n\n# Read enabled flag\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Run hook logic\n# ...\n```\n\n**Use case:** Enable/disable hooks without editing hooks.json (requires restart).\n\n### Pattern 2: Agent State Management\n\nStore agent-specific state and configuration:\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-agent\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\n---\n\n# Task Assignment\n\nImplement JWT authentication for the API.\n\n**Success Criteria:**\n- Authentication endpoints created\n- Tests passing\n- PR created and CI green\n```\n\nRead from hooks to coordinate agents:\n\n```bash\nAGENT_NAME=$(echo \"$FRONTMATTER\" | grep '^agent_name:' | sed 's/agent_name: *//')\nCOORDINATOR=$(echo \"$FRONTMATTER\" | grep '^coordinator_session:' | sed 's/coordinator_session: *//')\n\n# Send notification to coordinator\ntmux send-keys -t \"$COORDINATOR\" \"Agent $AGENT_NAME completed task\" Enter\n```\n\n### Pattern 3: Configuration-Driven Behavior\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nvalidation_level: strict\nmax_file_size: 1000000\nallowed_extensions: [\".js\", \".ts\", \".tsx\"]\nenable_logging: true\n---\n\n# Validation Configuration\n\nStrict mode enabled for this project.\nAll writes validated against security policies.\n```\n\nUse in hooks or commands:\n\n```bash\nLEVEL=$(echo \"$FRONTMATTER\" | grep '^validation_level:' | sed 's/validation_level: *//')\n\ncase \"$LEVEL\" in\n  strict)\n    # Apply strict validation\n    ;;\n  standard)\n    # Apply standard validation\n    ;;\n  lenient)\n    # Apply lenient validation\n    ;;\nesac\n```\n\n## Creating Settings Files\n\n### From Commands\n\nCommands can create settings files:\n\n```markdown\n# Setup Command\n\nSteps:\n1. Ask user for configuration preferences\n2. Create `.claude/my-plugin.local.md` with YAML frontmatter\n3. Set appropriate values based on user input\n4. Inform user that settings are saved\n5. Remind user to restart Claude Code for hooks to recognize changes\n```\n\n### Template Generation\n\nProvide template in plugin README:\n\n```markdown\n## Configuration\n\nCreate `.claude/my-plugin.local.md` in your project:\n\n\\`\\`\\`markdown\n---\nenabled: true\nmode: standard\nmax_retries: 3\n---\n\n# Plugin Configuration\n\nYour settings are active.\n\\`\\`\\`\n\nAfter creating or editing, restart Claude Code for changes to take effect.\n```\n\n## Best Practices\n\n### File Naming\n\nâœ… **DO:**\n- Use `.claude/plugin-name.local.md` format\n- Match plugin name exactly\n- Use `.local.md` suffix for user-local files\n\nâŒ **DON'T:**\n- Use different directory (not `.claude/`)\n- Use inconsistent naming\n- Use `.md` without `.local` (might be committed)\n\n### Gitignore\n\nAlways add to `.gitignore`:\n\n```gitignore\n.claude/*.local.md\n.claude/*.local.json\n```\n\nDocument this in plugin README.\n\n### Defaults\n\nProvide sensible defaults when settings file doesn't exist:\n\n```bash\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  # Use defaults\n  ENABLED=true\n  MODE=standard\nelse\n  # Read from file\n  # ...\nfi\n```\n\n### Validation\n\nValidate settings values:\n\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n\n# Validate numeric range\nif ! [[ \"$MAX\" =~ ^[0-9]+$ ]] || [[ $MAX -lt 1 ]] || [[ $MAX -gt 100 ]]; then\n  echo \"âš ï¸  Invalid max_value in settings (must be 1-100)\" >&2\n  MAX=10  # Use default\nfi\n```\n\n### Restart Requirement\n\n**Important:** Settings changes require Claude Code restart.\n\nDocument in your README:\n\n```markdown\n## Changing Settings\n\nAfter editing `.claude/my-plugin.local.md`:\n1. Save the file\n2. Exit Claude Code\n3. Restart: `claude` or `cc`\n4. New settings will be loaded\n```\n\nHooks cannot be hot-swapped within a session.\n\n## Security Considerations\n\n### Sanitize User Input\n\nWhen writing settings files from user input:\n\n```bash\n# Escape quotes in user input\nSAFE_VALUE=$(echo \"$USER_INPUT\" | sed 's/\"/\\\\\"/g')\n\n# Write to file\ncat > \"$STATE_FILE\" <<EOF\n---\nuser_setting: \"$SAFE_VALUE\"\n---\nEOF\n```\n\n### Validate File Paths\n\nIf settings contain file paths:\n\n```bash\nFILE_PATH=$(echo \"$FRONTMATTER\" | grep '^data_file:' | sed 's/data_file: *//')\n\n# Check for path traversal\nif [[ \"$FILE_PATH\" == *\"..\"* ]]; then\n  echo \"âš ï¸  Invalid path in settings (path traversal)\" >&2\n  exit 2\nfi\n```\n\n### Permissions\n\nSettings files should be:\n- Readable by user only (`chmod 600`)\n- Not committed to git\n- Not shared between users\n\n## Real-World Examples\n\n### multi-agent-swarm Plugin\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-implementation\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\nadditional_instructions: Use JWT tokens, not sessions\n---\n\n# Task: Implement Authentication\n\nBuild JWT-based authentication for the REST API.\nCoordinate with auth-agent on shared types.\n```\n\n**Hook usage (agent-stop-notification.sh):**\n- Checks if file exists (line 15-18: quick exit if not)\n- Parses frontmatter to get coordinator_session, agent_name, enabled\n- Sends notifications to coordinator if enabled\n- Allows quick activation/deactivation via `enabled: true/false`\n\n### ralph-loop Plugin\n\n**.claude/ralph-loop.local.md:**\n```markdown\n---\niteration: 1\nmax_iterations: 10\ncompletion_promise: \"All tests passing and build successful\"\n---\n\nFix all the linting errors in the project.\nMake sure tests pass after each fix.\n```\n\n**Hook usage (stop-hook.sh):**\n- Checks if file exists (line 15-18: quick exit if not active)\n- Reads iteration count and max_iterations\n- Extracts completion_promise for loop termination\n- Reads body as the prompt to feed back\n- Updates iteration count on each loop\n\n## Quick Reference\n\n### File Location\n\n```\nproject-root/\nâ””â”€â”€ .claude/\n    â””â”€â”€ plugin-name.local.md\n```\n\n### Frontmatter Parsing\n\n```bash\n# Extract frontmatter\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n\n# Read field\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field:' | sed 's/field: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n### Body Parsing\n\n```bash\n# Extract body (after second ---)\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n### Quick Exit Pattern\n\n```bash\nif [[ ! -f \".claude/my-plugin.local.md\" ]]; then\n  exit 0  # Not configured\nfi\n```\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed implementation patterns:\n\n- **`references/parsing-techniques.md`** - Complete guide to parsing YAML frontmatter and markdown bodies\n- **`references/real-world-examples.md`** - Deep dive into multi-agent-swarm and ralph-loop implementations\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`read-settings-hook.sh`** - Hook that reads and uses settings\n- **`create-settings-command.md`** - Command that creates settings file\n- **`example-settings.md`** - Template settings file\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-settings.sh`** - Validate settings file structure\n- **`parse-frontmatter.sh`** - Extract frontmatter fields\n\n## Implementation Workflow\n\nTo add settings to a plugin:\n\n1. Design settings schema (which fields, types, defaults)\n2. Create template file in plugin documentation\n3. Add gitignore entry for `.claude/*.local.md`\n4. Implement settings parsing in hooks/commands\n5. Use quick-exit pattern (check file exists, check enabled field)\n6. Document settings in plugin README with template\n7. Remind users that changes require Claude Code restart\n\nFocus on keeping settings simple and providing good defaults when settings file doesn't exist."
              },
              {
                "name": "Plugin Structure",
                "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.",
                "path": "plugins/plugin-dev/skills/plugin-structure/SKILL.md",
                "frontmatter": {
                  "name": "Plugin Structure",
                  "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.",
                  "version": "0.1.0"
                },
                "content": "# Plugin Structure for Claude Code\n\n## Overview\n\nClaude Code plugins follow a standardized directory structure with automatic component discovery. Understanding this structure enables creating well-organized, maintainable plugins that integrate seamlessly with Claude Code.\n\n**Key concepts:**\n- Conventional directory layout for automatic discovery\n- Manifest-driven configuration in `.claude-plugin/plugin.json`\n- Component-based organization (commands, agents, skills, hooks)\n- Portable path references using `${CLAUDE_PLUGIN_ROOT}`\n- Explicit vs. auto-discovered component loading\n\n## Directory Structure\n\nEvery Claude Code plugin follows this organizational pattern:\n\n```\nplugin-name/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json          # Required: Plugin manifest\nâ”œâ”€â”€ commands/                 # Slash commands (.md files)\nâ”œâ”€â”€ agents/                   # Subagent definitions (.md files)\nâ”œâ”€â”€ skills/                   # Agent skills (subdirectories)\nâ”‚   â””â”€â”€ skill-name/\nâ”‚       â””â”€â”€ SKILL.md         # Required for each skill\nâ”œâ”€â”€ hooks/\nâ”‚   â””â”€â”€ hooks.json           # Event handler configuration\nâ”œâ”€â”€ .mcp.json                # MCP server definitions\nâ””â”€â”€ scripts/                 # Helper scripts and utilities\n```\n\n**Critical rules:**\n\n1. **Manifest location**: The `plugin.json` manifest MUST be in `.claude-plugin/` directory\n2. **Component locations**: All component directories (commands, agents, skills, hooks) MUST be at plugin root level, NOT nested inside `.claude-plugin/`\n3. **Optional components**: Only create directories for components the plugin actually uses\n4. **Naming convention**: Use kebab-case for all directory and file names\n\n## Plugin Manifest (plugin.json)\n\nThe manifest defines plugin metadata and configuration. Located at `.claude-plugin/plugin.json`:\n\n### Required Fields\n\n```json\n{\n  \"name\": \"plugin-name\"\n}\n```\n\n**Name requirements:**\n- Use kebab-case format (lowercase with hyphens)\n- Must be unique across installed plugins\n- No spaces or special characters\n- Example: `code-review-assistant`, `test-runner`, `api-docs`\n\n### Recommended Metadata\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Brief explanation of plugin purpose\",\n  \"author\": {\n    \"name\": \"Author Name\",\n    \"email\": \"author@example.com\",\n    \"url\": \"https://example.com\"\n  },\n  \"homepage\": \"https://docs.example.com\",\n  \"repository\": \"https://github.com/user/plugin-name\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"testing\", \"automation\", \"ci-cd\"]\n}\n```\n\n**Version format**: Follow semantic versioning (MAJOR.MINOR.PATCH)\n**Keywords**: Use for plugin discovery and categorization\n\n### Component Path Configuration\n\nSpecify custom paths for components (supplements default directories):\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"commands\": \"./custom-commands\",\n  \"agents\": [\"./agents\", \"./specialized-agents\"],\n  \"hooks\": \"./config/hooks.json\",\n  \"mcpServers\": \"./.mcp.json\"\n}\n```\n\n**Important**: Custom paths supplement defaultsâ€”they don't replace them. Components in both default directories and custom paths will load.\n\n**Path rules:**\n- Must be relative to plugin root\n- Must start with `./`\n- Cannot use absolute paths\n- Support arrays for multiple locations\n\n## Component Organization\n\n### Commands\n\n**Location**: `commands/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `commands/` load automatically\n\n**Example structure**:\n```\ncommands/\nâ”œâ”€â”€ review.md        # /review command\nâ”œâ”€â”€ test.md          # /test command\nâ””â”€â”€ deploy.md        # /deploy command\n```\n\n**File format**:\n```markdown\n---\nname: command-name\ndescription: Command description\n---\n\nCommand implementation instructions...\n```\n\n**Usage**: Commands integrate as native slash commands in Claude Code\n\n### Agents\n\n**Location**: `agents/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `agents/` load automatically\n\n**Example structure**:\n```\nagents/\nâ”œâ”€â”€ code-reviewer.md\nâ”œâ”€â”€ test-generator.md\nâ””â”€â”€ refactorer.md\n```\n\n**File format**:\n```markdown\n---\ndescription: Agent role and expertise\ncapabilities:\n  - Specific task 1\n  - Specific task 2\n---\n\nDetailed agent instructions and knowledge...\n```\n\n**Usage**: Users can invoke agents manually, or Claude Code selects them automatically based on task context\n\n### Skills\n\n**Location**: `skills/` directory with subdirectories per skill\n**Format**: Each skill in its own directory with `SKILL.md` file\n**Auto-discovery**: All `SKILL.md` files in skill subdirectories load automatically\n\n**Example structure**:\n```\nskills/\nâ”œâ”€â”€ api-testing/\nâ”‚   â”œâ”€â”€ SKILL.md\nâ”‚   â”œâ”€â”€ scripts/\nâ”‚   â”‚   â””â”€â”€ test-runner.py\nâ”‚   â””â”€â”€ references/\nâ”‚       â””â”€â”€ api-spec.md\nâ””â”€â”€ database-migrations/\n    â”œâ”€â”€ SKILL.md\n    â””â”€â”€ examples/\n        â””â”€â”€ migration-template.sql\n```\n\n**SKILL.md format**:\n```markdown\n---\nname: Skill Name\ndescription: When to use this skill\nversion: 1.0.0\n---\n\nSkill instructions and guidance...\n```\n\n**Supporting files**: Skills can include scripts, references, examples, or assets in subdirectories\n\n**Usage**: Claude Code autonomously activates skills based on task context matching the description\n\n### Hooks\n\n**Location**: `hooks/hooks.json` or inline in `plugin.json`\n**Format**: JSON configuration defining event handlers\n**Registration**: Hooks register automatically when plugin enables\n\n**Example structure**:\n```\nhooks/\nâ”œâ”€â”€ hooks.json           # Hook configuration\nâ””â”€â”€ scripts/\n    â”œâ”€â”€ validate.sh      # Hook script\n    â””â”€â”€ check-style.sh   # Hook script\n```\n\n**Configuration format**:\n```json\n{\n  \"PreToolUse\": [{\n    \"matcher\": \"Write|Edit\",\n    \"hooks\": [{\n      \"type\": \"command\",\n      \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/validate.sh\",\n      \"timeout\": 30\n    }]\n  }]\n}\n```\n\n**Available events**: PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification\n\n**Usage**: Hooks execute automatically in response to Claude Code events\n\n### MCP Servers\n\n**Location**: `.mcp.json` at plugin root or inline in `plugin.json`\n**Format**: JSON configuration for MCP server definitions\n**Auto-start**: Servers start automatically when plugin enables\n\n**Example format**:\n```json\n{\n  \"mcpServers\": {\n    \"server-name\": {\n      \"command\": \"node\",\n      \"args\": [\"${CLAUDE_PLUGIN_ROOT}/servers/server.js\"],\n      \"env\": {\n        \"API_KEY\": \"${API_KEY}\"\n      }\n    }\n  }\n}\n```\n\n**Usage**: MCP servers integrate seamlessly with Claude Code's tool system\n\n## Portable Path References\n\n### ${CLAUDE_PLUGIN_ROOT}\n\nUse `${CLAUDE_PLUGIN_ROOT}` environment variable for all intra-plugin path references:\n\n```json\n{\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/run.sh\"\n}\n```\n\n**Why it matters**: Plugins install in different locations depending on:\n- User installation method (marketplace, local, npm)\n- Operating system conventions\n- User preferences\n\n**Where to use it**:\n- Hook command paths\n- MCP server command arguments\n- Script execution references\n- Resource file paths\n\n**Never use**:\n- Hardcoded absolute paths (`/Users/name/plugins/...`)\n- Relative paths from working directory (`./scripts/...` in commands)\n- Home directory shortcuts (`~/plugins/...`)\n\n### Path Resolution Rules\n\n**In manifest JSON fields** (hooks, MCP servers):\n```json\n\"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/tool.sh\"\n```\n\n**In component files** (commands, agents, skills):\n```markdown\nReference scripts at: ${CLAUDE_PLUGIN_ROOT}/scripts/helper.py\n```\n\n**In executed scripts**:\n```bash\n#!/bin/bash\n# ${CLAUDE_PLUGIN_ROOT} available as environment variable\nsource \"${CLAUDE_PLUGIN_ROOT}/lib/common.sh\"\n```\n\n## File Naming Conventions\n\n### Component Files\n\n**Commands**: Use kebab-case `.md` files\n- `code-review.md` â†’ `/code-review`\n- `run-tests.md` â†’ `/run-tests`\n- `api-docs.md` â†’ `/api-docs`\n\n**Agents**: Use kebab-case `.md` files describing role\n- `test-generator.md`\n- `code-reviewer.md`\n- `performance-analyzer.md`\n\n**Skills**: Use kebab-case directory names\n- `api-testing/`\n- `database-migrations/`\n- `error-handling/`\n\n### Supporting Files\n\n**Scripts**: Use descriptive kebab-case names with appropriate extensions\n- `validate-input.sh`\n- `generate-report.py`\n- `process-data.js`\n\n**Documentation**: Use kebab-case markdown files\n- `api-reference.md`\n- `migration-guide.md`\n- `best-practices.md`\n\n**Configuration**: Use standard names\n- `hooks.json`\n- `.mcp.json`\n- `plugin.json`\n\n## Auto-Discovery Mechanism\n\nClaude Code automatically discovers and loads components:\n\n1. **Plugin manifest**: Reads `.claude-plugin/plugin.json` when plugin enables\n2. **Commands**: Scans `commands/` directory for `.md` files\n3. **Agents**: Scans `agents/` directory for `.md` files\n4. **Skills**: Scans `skills/` for subdirectories containing `SKILL.md`\n5. **Hooks**: Loads configuration from `hooks/hooks.json` or manifest\n6. **MCP servers**: Loads configuration from `.mcp.json` or manifest\n\n**Discovery timing**:\n- Plugin installation: Components register with Claude Code\n- Plugin enable: Components become available for use\n- No restart required: Changes take effect on next Claude Code session\n\n**Override behavior**: Custom paths in `plugin.json` supplement (not replace) default directories\n\n## Best Practices\n\n### Organization\n\n1. **Logical grouping**: Group related components together\n   - Put test-related commands, agents, and skills together\n   - Create subdirectories in `scripts/` for different purposes\n\n2. **Minimal manifest**: Keep `plugin.json` lean\n   - Only specify custom paths when necessary\n   - Rely on auto-discovery for standard layouts\n   - Use inline configuration only for simple cases\n\n3. **Documentation**: Include README files\n   - Plugin root: Overall purpose and usage\n   - Component directories: Specific guidance\n   - Script directories: Usage and requirements\n\n### Naming\n\n1. **Consistency**: Use consistent naming across components\n   - If command is `test-runner`, name related agent `test-runner-agent`\n   - Match skill directory names to their purpose\n\n2. **Clarity**: Use descriptive names that indicate purpose\n   - Good: `api-integration-testing/`, `code-quality-checker.md`\n   - Avoid: `utils/`, `misc.md`, `temp.sh`\n\n3. **Length**: Balance brevity with clarity\n   - Commands: 2-3 words (`review-pr`, `run-ci`)\n   - Agents: Describe role clearly (`code-reviewer`, `test-generator`)\n   - Skills: Topic-focused (`error-handling`, `api-design`)\n\n### Portability\n\n1. **Always use ${CLAUDE_PLUGIN_ROOT}**: Never hardcode paths\n2. **Test on multiple systems**: Verify on macOS, Linux, Windows\n3. **Document dependencies**: List required tools and versions\n4. **Avoid system-specific features**: Use portable bash/Python constructs\n\n### Maintenance\n\n1. **Version consistently**: Update version in plugin.json for releases\n2. **Deprecate gracefully**: Mark old components clearly before removal\n3. **Document breaking changes**: Note changes affecting existing users\n4. **Test thoroughly**: Verify all components work after changes\n\n## Common Patterns\n\n### Minimal Plugin\n\nSingle command with no dependencies:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json    # Just name field\nâ””â”€â”€ commands/\n    â””â”€â”€ hello.md       # Single command\n```\n\n### Full-Featured Plugin\n\nComplete plugin with all component types:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/          # User-facing commands\nâ”œâ”€â”€ agents/            # Specialized subagents\nâ”œâ”€â”€ skills/            # Auto-activating skills\nâ”œâ”€â”€ hooks/             # Event handlers\nâ”‚   â”œâ”€â”€ hooks.json\nâ”‚   â””â”€â”€ scripts/\nâ”œâ”€â”€ .mcp.json          # External integrations\nâ””â”€â”€ scripts/           # Shared utilities\n```\n\n### Skill-Focused Plugin\n\nPlugin providing only skills:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ””â”€â”€ skills/\n    â”œâ”€â”€ skill-one/\n    â”‚   â””â”€â”€ SKILL.md\n    â””â”€â”€ skill-two/\n        â””â”€â”€ SKILL.md\n```\n\n## Troubleshooting\n\n**Component not loading**:\n- Verify file is in correct directory with correct extension\n- Check YAML frontmatter syntax (commands, agents, skills)\n- Ensure skill has `SKILL.md` (not `README.md` or other name)\n- Confirm plugin is enabled in Claude Code settings\n\n**Path resolution errors**:\n- Replace all hardcoded paths with `${CLAUDE_PLUGIN_ROOT}`\n- Verify paths are relative and start with `./` in manifest\n- Check that referenced files exist at specified paths\n- Test with `echo $CLAUDE_PLUGIN_ROOT` in hook scripts\n\n**Auto-discovery not working**:\n- Confirm directories are at plugin root (not in `.claude-plugin/`)\n- Check file naming follows conventions (kebab-case, correct extensions)\n- Verify custom paths in manifest are correct\n- Restart Claude Code to reload plugin configuration\n\n**Conflicts between plugins**:\n- Use unique, descriptive component names\n- Namespace commands with plugin name if needed\n- Document potential conflicts in plugin README\n- Consider command prefixes for related functionality\n\n---\n\nFor detailed examples and advanced patterns, see files in `references/` and `examples/` directories."
              },
              {
                "name": "Skill Development",
                "description": "This skill should be used when the user wants to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins.",
                "path": "plugins/plugin-dev/skills/skill-development/SKILL.md",
                "frontmatter": {
                  "name": "Skill Development",
                  "description": "This skill should be used when the user wants to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins.",
                  "version": "0.1.0"
                },
                "content": "# Skill Development for Claude Code Plugins\n\nThis skill provides guidance for creating effective skills for Claude Code plugins.\n\n## About Skills\n\nSkills are modular, self-contained packages that extend Claude's capabilities by providing\nspecialized knowledge, workflows, and tools. Think of them as \"onboarding guides\" for specific\ndomains or tasksâ€”they transform Claude from a general-purpose agent into a specialized agent\nequipped with procedural knowledge that no model can fully possess.\n\n### What Skills Provide\n\n1. Specialized workflows - Multi-step procedures for specific domains\n2. Tool integrations - Instructions for working with specific file formats or APIs\n3. Domain expertise - Company-specific knowledge, schemas, business logic\n4. Bundled resources - Scripts, references, and assets for complex and repetitive tasks\n\n### Anatomy of a Skill\n\nEvery skill consists of a required SKILL.md file and optional bundled resources:\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md (required)\nâ”‚   â”œâ”€â”€ YAML frontmatter metadata (required)\nâ”‚   â”‚   â”œâ”€â”€ name: (required)\nâ”‚   â”‚   â””â”€â”€ description: (required)\nâ”‚   â””â”€â”€ Markdown instructions (required)\nâ””â”€â”€ Bundled Resources (optional)\n    â”œâ”€â”€ scripts/          - Executable code (Python/Bash/etc.)\n    â”œâ”€â”€ references/       - Documentation intended to be loaded into context as needed\n    â””â”€â”€ assets/           - Files used in output (templates, icons, fonts, etc.)\n```\n\n#### SKILL.md (required)\n\n**Metadata Quality:** The `name` and `description` in YAML frontmatter determine when Claude will use the skill. Be specific about what the skill does and when to use it. Use the third-person (e.g. \"This skill should be used when...\" instead of \"Use this skill when...\").\n\n#### Bundled Resources (optional)\n\n##### Scripts (`scripts/`)\n\nExecutable code (Python/Bash/etc.) for tasks that require deterministic reliability or are repeatedly rewritten.\n\n- **When to include**: When the same code is being rewritten repeatedly or deterministic reliability is needed\n- **Example**: `scripts/rotate_pdf.py` for PDF rotation tasks\n- **Benefits**: Token efficient, deterministic, may be executed without loading into context\n- **Note**: Scripts may still need to be read by Claude for patching or environment-specific adjustments\n\n##### References (`references/`)\n\nDocumentation and reference material intended to be loaded as needed into context to inform Claude's process and thinking.\n\n- **When to include**: For documentation that Claude should reference while working\n- **Examples**: `references/finance.md` for financial schemas, `references/mnda.md` for company NDA template, `references/policies.md` for company policies, `references/api_docs.md` for API specifications\n- **Use cases**: Database schemas, API documentation, domain knowledge, company policies, detailed workflow guides\n- **Benefits**: Keeps SKILL.md lean, loaded only when Claude determines it's needed\n- **Best practice**: If files are large (>10k words), include grep search patterns in SKILL.md\n- **Avoid duplication**: Information should live in either SKILL.md or references files, not both. Prefer references files for detailed information unless it's truly core to the skillâ€”this keeps SKILL.md lean while making information discoverable without hogging the context window. Keep only essential procedural instructions and workflow guidance in SKILL.md; move detailed reference material, schemas, and examples to references files.\n\n##### Assets (`assets/`)\n\nFiles not intended to be loaded into context, but rather used within the output Claude produces.\n\n- **When to include**: When the skill needs files that will be used in the final output\n- **Examples**: `assets/logo.png` for brand assets, `assets/slides.pptx` for PowerPoint templates, `assets/frontend-template/` for HTML/React boilerplate, `assets/font.ttf` for typography\n- **Use cases**: Templates, images, icons, boilerplate code, fonts, sample documents that get copied or modified\n- **Benefits**: Separates output resources from documentation, enables Claude to use files without loading them into context\n\n### Progressive Disclosure Design Principle\n\nSkills use a three-level loading system to manage context efficiently:\n\n1. **Metadata (name + description)** - Always in context (~100 words)\n2. **SKILL.md body** - When skill triggers (<5k words)\n3. **Bundled resources** - As needed by Claude (Unlimited*)\n\n*Unlimited because scripts can be executed without reading into context window.\n\n## Skill Creation Process\n\nTo create a skill, follow the \"Skill Creation Process\" in order, skipping steps only if there is a clear reason why they are not applicable.\n\n### Step 1: Understanding the Skill with Concrete Examples\n\nSkip this step only when the skill's usage patterns are already clearly understood. It remains valuable even when working with an existing skill.\n\nTo create an effective skill, clearly understand concrete examples of how the skill will be used. This understanding can come from either direct user examples or generated examples that are validated with user feedback.\n\nFor example, when building an image-editor skill, relevant questions include:\n\n- \"What functionality should the image-editor skill support? Editing, rotating, anything else?\"\n- \"Can you give some examples of how this skill would be used?\"\n- \"I can imagine users asking for things like 'Remove the red-eye from this image' or 'Rotate this image'. Are there other ways you imagine this skill being used?\"\n- \"What would a user say that should trigger this skill?\"\n\nTo avoid overwhelming users, avoid asking too many questions in a single message. Start with the most important questions and follow up as needed for better effectiveness.\n\nConclude this step when there is a clear sense of the functionality the skill should support.\n\n### Step 2: Planning the Reusable Skill Contents\n\nTo turn concrete examples into an effective skill, analyze each example by:\n\n1. Considering how to execute on the example from scratch\n2. Identifying what scripts, references, and assets would be helpful when executing these workflows repeatedly\n\nExample: When building a `pdf-editor` skill to handle queries like \"Help me rotate this PDF,\" the analysis shows:\n\n1. Rotating a PDF requires re-writing the same code each time\n2. A `scripts/rotate_pdf.py` script would be helpful to store in the skill\n\nExample: When designing a `frontend-webapp-builder` skill for queries like \"Build me a todo app\" or \"Build me a dashboard to track my steps,\" the analysis shows:\n\n1. Writing a frontend webapp requires the same boilerplate HTML/React each time\n2. An `assets/hello-world/` template containing the boilerplate HTML/React project files would be helpful to store in the skill\n\nExample: When building a `big-query` skill to handle queries like \"How many users have logged in today?\" the analysis shows:\n\n1. Querying BigQuery requires re-discovering the table schemas and relationships each time\n2. A `references/schema.md` file documenting the table schemas would be helpful to store in the skill\n\n**For Claude Code plugins:** When building a hooks skill, the analysis shows:\n1. Developers repeatedly need to validate hooks.json and test hook scripts\n2. `scripts/validate-hook-schema.sh` and `scripts/test-hook.sh` utilities would be helpful\n3. `references/patterns.md` for detailed hook patterns to avoid bloating SKILL.md\n\nTo establish the skill's contents, analyze each concrete example to create a list of the reusable resources to include: scripts, references, and assets.\n\n### Step 3: Create Skill Structure\n\nFor Claude Code plugins, create the skill directory structure:\n\n```bash\nmkdir -p plugin-name/skills/skill-name/{references,examples,scripts}\ntouch plugin-name/skills/skill-name/SKILL.md\n```\n\n**Note:** Unlike the generic skill-creator which uses `init_skill.py`, plugin skills are created directly in the plugin's `skills/` directory with a simpler manual structure.\n\n### Step 4: Edit the Skill\n\nWhen editing the (newly-created or existing) skill, remember that the skill is being created for another instance of Claude to use. Focus on including information that would be beneficial and non-obvious to Claude. Consider what procedural knowledge, domain-specific details, or reusable assets would help another Claude instance execute these tasks more effectively.\n\n#### Start with Reusable Skill Contents\n\nTo begin implementation, start with the reusable resources identified above: `scripts/`, `references/`, and `assets/` files. Note that this step may require user input. For example, when implementing a `brand-guidelines` skill, the user may need to provide brand assets or templates to store in `assets/`, or documentation to store in `references/`.\n\nAlso, delete any example files and directories not needed for the skill. Create only the directories you actually need (references/, examples/, scripts/).\n\n#### Update SKILL.md\n\n**Writing Style:** Write the entire skill using **imperative/infinitive form** (verb-first instructions), not second person. Use objective, instructional language (e.g., \"To accomplish X, do Y\" rather than \"You should do X\" or \"If you need to do X\"). This maintains consistency and clarity for AI consumption.\n\n**Description (Frontmatter):** Use third-person format with specific trigger phrases:\n\n```yaml\n---\nname: Skill Name\ndescription: This skill should be used when the user asks to \"specific phrase 1\", \"specific phrase 2\", \"specific phrase 3\". Include exact phrases users would say that should trigger this skill. Be concrete and specific.\nversion: 0.1.0\n---\n```\n\n**Good description examples:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", \"implement prompt-based hooks\", or mentions hook events (PreToolUse, PostToolUse, Stop).\n```\n\n**Bad description examples:**\n```yaml\ndescription: Use this skill when working with hooks.  # Wrong person, vague\ndescription: Load when user needs hook help.  # Not third person\ndescription: Provides hook guidance.  # No trigger phrases\n```\n\nTo complete SKILL.md body, answer the following questions:\n\n1. What is the purpose of the skill, in a few sentences?\n2. When should the skill be used? (Include this in frontmatter description with specific triggers)\n3. In practice, how should Claude use the skill? All reusable skill contents developed above should be referenced so that Claude knows how to use them.\n\n**Keep SKILL.md lean:** Target 1,500-2,000 words for the body. Move detailed content to references/:\n- Detailed patterns â†’ `references/patterns.md`\n- Advanced techniques â†’ `references/advanced.md`\n- Migration guides â†’ `references/migration.md`\n- API references â†’ `references/api-reference.md`\n\n**Reference resources in SKILL.md:**\n```markdown\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and techniques, consult:\n- **`references/patterns.md`** - Common patterns\n- **`references/advanced.md`** - Advanced use cases\n\n### Example Files\n\nWorking examples in `examples/`:\n- **`example-script.sh`** - Working example\n```\n\n### Step 5: Validate and Test\n\n**For plugin skills, validation is different from generic skills:**\n\n1. **Check structure**: Skill directory in `plugin-name/skills/skill-name/`\n2. **Validate SKILL.md**: Has frontmatter with name and description\n3. **Check trigger phrases**: Description includes specific user queries\n4. **Verify writing style**: Body uses imperative/infinitive form, not second person\n5. **Test progressive disclosure**: SKILL.md is lean (~1,500-2,000 words), detailed content in references/\n6. **Check references**: All referenced files exist\n7. **Validate examples**: Examples are complete and correct\n8. **Test scripts**: Scripts are executable and work correctly\n\n**Use the skill-reviewer agent:**\n```\nAsk: \"Review my skill and check if it follows best practices\"\n```\n\nThe skill-reviewer agent will check description quality, content organization, and progressive disclosure.\n\n### Step 6: Iterate\n\nAfter testing the skill, users may request improvements. Often this happens right after using the skill, with fresh context of how the skill performed.\n\n**Iteration workflow:**\n1. Use the skill on real tasks\n2. Notice struggles or inefficiencies\n3. Identify how SKILL.md or bundled resources should be updated\n4. Implement changes and test again\n\n**Common improvements:**\n- Strengthen trigger phrases in description\n- Move long sections from SKILL.md to references/\n- Add missing examples or scripts\n- Clarify ambiguous instructions\n- Add edge case handling\n\n## Plugin-Specific Considerations\n\n### Skill Location in Plugins\n\nPlugin skills live in the plugin's `skills/` directory:\n\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/\nâ”œâ”€â”€ agents/\nâ””â”€â”€ skills/\n    â””â”€â”€ my-skill/\n        â”œâ”€â”€ SKILL.md\n        â”œâ”€â”€ references/\n        â”œâ”€â”€ examples/\n        â””â”€â”€ scripts/\n```\n\n### Auto-Discovery\n\nClaude Code automatically discovers skills:\n- Scans `skills/` directory\n- Finds subdirectories containing `SKILL.md`\n- Loads skill metadata (name + description) always\n- Loads SKILL.md body when skill triggers\n- Loads references/examples when needed\n\n### No Packaging Needed\n\nPlugin skills are distributed as part of the plugin, not as separate ZIP files. Users get skills when they install the plugin.\n\n### Testing in Plugins\n\nTest skills by installing plugin locally:\n\n```bash\n# Test with --plugin-dir\ncc --plugin-dir /path/to/plugin\n\n# Ask questions that should trigger the skill\n# Verify skill loads correctly\n```\n\n## Examples from Plugin-Dev\n\nStudy the skills in this plugin as examples of best practices:\n\n**hook-development skill:**\n- Excellent trigger phrases: \"create a hook\", \"add a PreToolUse hook\", etc.\n- Lean SKILL.md (1,651 words)\n- 3 references/ files for detailed content\n- 3 examples/ of working hooks\n- 3 scripts/ utilities\n\n**agent-development skill:**\n- Strong triggers: \"create an agent\", \"agent frontmatter\", etc.\n- Focused SKILL.md (1,438 words)\n- References include the AI generation prompt from Claude Code\n- Complete agent examples\n\n**plugin-settings skill:**\n- Specific triggers: \"plugin settings\", \".local.md files\", \"YAML frontmatter\"\n- References show real implementations (multi-agent-swarm, ralph-loop)\n- Working parsing scripts\n\nEach demonstrates progressive disclosure and strong triggering.\n\n## Progressive Disclosure in Practice\n\n### What Goes in SKILL.md\n\n**Include (always loaded when skill triggers):**\n- Core concepts and overview\n- Essential procedures and workflows\n- Quick reference tables\n- Pointers to references/examples/scripts\n- Most common use cases\n\n**Keep under 3,000 words, ideally 1,500-2,000 words**\n\n### What Goes in references/\n\n**Move to references/ (loaded as needed):**\n- Detailed patterns and advanced techniques\n- Comprehensive API documentation\n- Migration guides\n- Edge cases and troubleshooting\n- Extensive examples and walkthroughs\n\n**Each reference file can be large (2,000-5,000+ words)**\n\n### What Goes in examples/\n\n**Working code examples:**\n- Complete, runnable scripts\n- Configuration files\n- Template files\n- Real-world usage examples\n\n**Users can copy and adapt these directly**\n\n### What Goes in scripts/\n\n**Utility scripts:**\n- Validation tools\n- Testing helpers\n- Parsing utilities\n- Automation scripts\n\n**Should be executable and documented**\n\n## Writing Style Requirements\n\n### Imperative/Infinitive Form\n\nWrite using verb-first instructions, not second person:\n\n**Correct (imperative):**\n```\nTo create a hook, define the event type.\nConfigure the MCP server with authentication.\nValidate settings before use.\n```\n\n**Incorrect (second person):**\n```\nYou should create a hook by defining the event type.\nYou need to configure the MCP server.\nYou must validate settings before use.\n```\n\n### Third-Person in Description\n\nThe frontmatter description must use third person:\n\n**Correct:**\n```yaml\ndescription: This skill should be used when the user asks to \"create X\", \"configure Y\"...\n```\n\n**Incorrect:**\n```yaml\ndescription: Use this skill when you want to create X...\ndescription: Load this skill when user asks...\n```\n\n### Objective, Instructional Language\n\nFocus on what to do, not who should do it:\n\n**Correct:**\n```\nParse the frontmatter using sed.\nExtract fields with grep.\nValidate values before use.\n```\n\n**Incorrect:**\n```\nYou can parse the frontmatter...\nClaude should extract fields...\nThe user might validate values...\n```\n\n## Validation Checklist\n\nBefore finalizing a skill:\n\n**Structure:**\n- [ ] SKILL.md file exists with valid YAML frontmatter\n- [ ] Frontmatter has `name` and `description` fields\n- [ ] Markdown body is present and substantial\n- [ ] Referenced files actually exist\n\n**Description Quality:**\n- [ ] Uses third person (\"This skill should be used when...\")\n- [ ] Includes specific trigger phrases users would say\n- [ ] Lists concrete scenarios (\"create X\", \"configure Y\")\n- [ ] Not vague or generic\n\n**Content Quality:**\n- [ ] SKILL.md body uses imperative/infinitive form\n- [ ] Body is focused and lean (1,500-2,000 words ideal, <5k max)\n- [ ] Detailed content moved to references/\n- [ ] Examples are complete and working\n- [ ] Scripts are executable and documented\n\n**Progressive Disclosure:**\n- [ ] Core concepts in SKILL.md\n- [ ] Detailed docs in references/\n- [ ] Working code in examples/\n- [ ] Utilities in scripts/\n- [ ] SKILL.md references these resources\n\n**Testing:**\n- [ ] Skill triggers on expected user queries\n- [ ] Content is helpful for intended tasks\n- [ ] No duplicated information across files\n- [ ] References load when needed\n\n## Common Mistakes to Avoid\n\n### Mistake 1: Weak Trigger Description\n\nâŒ **Bad:**\n```yaml\ndescription: Provides guidance for working with hooks.\n```\n\n**Why bad:** Vague, no specific trigger phrases, not third person\n\nâœ… **Good:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", or mentions hook events. Provides comprehensive hooks API guidance.\n```\n\n**Why good:** Third person, specific phrases, concrete scenarios\n\n### Mistake 2: Too Much in SKILL.md\n\nâŒ **Bad:**\n```\nskill-name/\nâ””â”€â”€ SKILL.md  (8,000 words - everything in one file)\n```\n\n**Why bad:** Bloats context when skill loads, detailed content always loaded\n\nâœ… **Good:**\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md  (1,800 words - core essentials)\nâ””â”€â”€ references/\n    â”œâ”€â”€ patterns.md (2,500 words)\n    â””â”€â”€ advanced.md (3,700 words)\n```\n\n**Why good:** Progressive disclosure, detailed content loaded only when needed\n\n### Mistake 3: Second Person Writing\n\nâŒ **Bad:**\n```markdown\nYou should start by reading the configuration file.\nYou need to validate the input.\nYou can use the grep tool to search.\n```\n\n**Why bad:** Second person, not imperative form\n\nâœ… **Good:**\n```markdown\nStart by reading the configuration file.\nValidate the input before processing.\nUse the grep tool to search for patterns.\n```\n\n**Why good:** Imperative form, direct instructions\n\n### Mistake 4: Missing Resource References\n\nâŒ **Bad:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n[No mention of references/ or examples/]\n```\n\n**Why bad:** Claude doesn't know references exist\n\nâœ… **Good:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n## Additional Resources\n\n### Reference Files\n- **`references/patterns.md`** - Detailed patterns\n- **`references/advanced.md`** - Advanced techniques\n\n### Examples\n- **`examples/script.sh`** - Working example\n```\n\n**Why good:** Claude knows where to find additional information\n\n## Quick Reference\n\n### Minimal Skill\n\n```\nskill-name/\nâ””â”€â”€ SKILL.md\n```\n\nGood for: Simple knowledge, no complex resources needed\n\n### Standard Skill (Recommended)\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md\nâ”œâ”€â”€ references/\nâ”‚   â””â”€â”€ detailed-guide.md\nâ””â”€â”€ examples/\n    â””â”€â”€ working-example.sh\n```\n\nGood for: Most plugin skills with detailed documentation\n\n### Complete Skill\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md\nâ”œâ”€â”€ references/\nâ”‚   â”œâ”€â”€ patterns.md\nâ”‚   â””â”€â”€ advanced.md\nâ”œâ”€â”€ examples/\nâ”‚   â”œâ”€â”€ example1.sh\nâ”‚   â””â”€â”€ example2.json\nâ””â”€â”€ scripts/\n    â””â”€â”€ validate.sh\n```\n\nGood for: Complex domains with validation utilities\n\n## Best Practices Summary\n\nâœ… **DO:**\n- Use third-person in description (\"This skill should be used when...\")\n- Include specific trigger phrases (\"create X\", \"configure Y\")\n- Keep SKILL.md lean (1,500-2,000 words)\n- Use progressive disclosure (move details to references/)\n- Write in imperative/infinitive form\n- Reference supporting files clearly\n- Provide working examples\n- Create utility scripts for common operations\n- Study plugin-dev's skills as templates\n\nâŒ **DON'T:**\n- Use second person anywhere\n- Have vague trigger conditions\n- Put everything in SKILL.md (>3,000 words without references/)\n- Write in second person (\"You should...\")\n- Leave resources unreferenced\n- Include broken or incomplete examples\n- Skip validation\n\n## Additional Resources\n\n### Study These Skills\n\nPlugin-dev's skills demonstrate best practices:\n- `../hook-development/` - Progressive disclosure, utilities\n- `../agent-development/` - AI-assisted creation, references\n- `../mcp-integration/` - Comprehensive references\n- `../plugin-settings/` - Real-world examples\n- `../command-development/` - Clear critical concepts\n- `../plugin-structure/` - Good organization\n\n### Reference Files\n\nFor complete skill-creator methodology:\n- **`references/skill-creator-original.md`** - Full original skill-creator content\n\n## Implementation Workflow\n\nTo create a skill for your plugin:\n\n1. **Understand use cases**: Identify concrete examples of skill usage\n2. **Plan resources**: Determine what scripts/references/examples needed\n3. **Create structure**: `mkdir -p skills/skill-name/{references,examples,scripts}`\n4. **Write SKILL.md**:\n   - Frontmatter with third-person description and trigger phrases\n   - Lean body (1,500-2,000 words) in imperative form\n   - Reference supporting files\n5. **Add resources**: Create references/, examples/, scripts/ as needed\n6. **Validate**: Check description, writing style, organization\n7. **Test**: Verify skill loads on expected triggers\n8. **Iterate**: Improve based on usage\n\nFocus on strong trigger descriptions, progressive disclosure, and imperative writing style for effective skills that load when needed and provide targeted guidance."
              }
            ]
          },
          {
            "name": "gitlab",
            "description": "GitLab DevOps platform integration. Manage repositories, merge requests, CI/CD pipelines, issues, and wikis. Full access to GitLab's comprehensive DevOps lifecycle tools.",
            "source": "./external_plugins/gitlab",
            "category": "productivity",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install gitlab@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "sentry",
            "description": "Sentry error monitoring integration. Access error reports, analyze stack traces, search issues by fingerprint, and debug production errors directly from your development environment.",
            "source": {
              "source": "url",
              "url": "https://github.com/getsentry/sentry-for-claude.git"
            },
            "category": "monitoring",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install sentry@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [
              {
                "name": "/explain-error",
                "description": "Explain Stripe error codes and provide solutions with code examples",
                "path": "external_plugins/stripe/commands/explain-error.md",
                "frontmatter": {
                  "description": "Explain Stripe error codes and provide solutions with code examples",
                  "argument-hint": [
                    "error_code or error_message"
                  ]
                },
                "content": "# Explain Stripe Error\n\nProvide a comprehensive explanation of the given Stripe error code or error message:\n\n1. Accept the error code or full error message from the arguments\n2. Explain in plain English what the error means\n3. List common causes of this error\n4. Provide specific solutions and handling recommendations\n5. Generate error handling code in the project's language showing:\n   - How to catch this specific error\n   - User-friendly error messages\n   - Whether retry is appropriate\n6. Mention related error codes the developer should be aware of\n7. Include a link to the relevant Stripe documentation\n\nFocus on actionable solutions and production-ready error handling patterns."
              },
              {
                "name": "/test-cards",
                "description": "Display Stripe test card numbers for various testing scenarios",
                "path": "external_plugins/stripe/commands/test-cards.md",
                "frontmatter": {
                  "description": "Display Stripe test card numbers for various testing scenarios",
                  "argument-hint": [
                    "scenario"
                  ]
                },
                "content": "# Test Cards Reference\n\nProvide a quick reference for Stripe test card numbers:\n\n1. If a scenario argument is provided (e.g., \"declined\", \"3dsecure\", \"fraud\"), show relevant test cards for that scenario\n2. Otherwise, show the most common test cards organized by category:\n   - Successful payment (default card)\n   - 3D Secure authentication required\n   - Generic decline\n   - Specific decline reasons (insufficient_funds, lost_card, etc.)\n3. For each card, display:\n   - Card number (formatted with spaces)\n   - Expected behavior\n   - Expiry/CVC info (any future date and any 3-digit CVC)\n4. Use clear visual indicators (âœ“ for success, âš ï¸ for auth required, âœ— for decline)\n5. Mention that these only work in test mode\n6. Provide link to full testing documentation: https://docs.stripe.com/testing.md\n\nIf the user is currently working on test code, offer to generate test cases using these cards."
              },
              {
                "name": "/new-sdk-app",
                "description": "Create and setup a new Claude Agent SDK application",
                "path": "plugins/agent-sdk-dev/commands/new-sdk-app.md",
                "frontmatter": {
                  "description": "Create and setup a new Claude Agent SDK application",
                  "argument-hint": [
                    "project-name"
                  ]
                },
                "content": "You are tasked with helping the user create a new Claude Agent SDK application. Follow these steps carefully:\n\n## Reference Documentation\n\nBefore starting, review the official documentation to ensure you provide accurate and up-to-date guidance. Use WebFetch to read these pages:\n\n1. **Start with the overview**: https://docs.claude.com/en/api/agent-sdk/overview\n2. **Based on the user's language choice, read the appropriate SDK reference**:\n   - TypeScript: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Python: https://docs.claude.com/en/api/agent-sdk/python\n3. **Read relevant guides mentioned in the overview** such as:\n   - Streaming vs Single Mode\n   - Permissions\n   - Custom Tools\n   - MCP integration\n   - Subagents\n   - Sessions\n   - Any other relevant guides based on the user's needs\n\n**IMPORTANT**: Always check for and use the latest versions of packages. Use WebSearch or WebFetch to verify current versions before installation.\n\n## Gather Requirements\n\nIMPORTANT: Ask these questions one at a time. Wait for the user's response before asking the next question. This makes it easier for the user to respond.\n\nAsk the questions in this order (skip any that the user has already provided via arguments):\n\n1. **Language** (ask first): \"Would you like to use TypeScript or Python?\"\n\n   - Wait for response before continuing\n\n2. **Project name** (ask second): \"What would you like to name your project?\"\n\n   - If $ARGUMENTS is provided, use that as the project name and skip this question\n   - Wait for response before continuing\n\n3. **Agent type** (ask third, but skip if #2 was sufficiently detailed): \"What kind of agent are you building? Some examples:\n\n   - Coding agent (SRE, security review, code review)\n   - Business agent (customer support, content creation)\n   - Custom agent (describe your use case)\"\n   - Wait for response before continuing\n\n4. **Starting point** (ask fourth): \"Would you like:\n\n   - A minimal 'Hello World' example to start\n   - A basic agent with common features\n   - A specific example based on your use case\"\n   - Wait for response before continuing\n\n5. **Tooling choice** (ask fifth): Let the user know what tools you'll use, and confirm with them that these are the tools they want to use (for example, they may prefer pnpm or bun over npm). Respect the user's preferences when executing on the requirements.\n\nAfter all questions are answered, proceed to create the setup plan.\n\n## Setup Plan\n\nBased on the user's answers, create a plan that includes:\n\n1. **Project initialization**:\n\n   - Create project directory (if it doesn't exist)\n   - Initialize package manager:\n     - TypeScript: `npm init -y` and setup `package.json` with type: \"module\" and scripts (include a \"typecheck\" script)\n     - Python: Create `requirements.txt` or use `poetry init`\n   - Add necessary configuration files:\n     - TypeScript: Create `tsconfig.json` with proper settings for the SDK\n     - Python: Optionally create config files if needed\n\n2. **Check for Latest Versions**:\n\n   - BEFORE installing, use WebSearch or check npm/PyPI to find the latest version\n   - For TypeScript: Check https://www.npmjs.com/package/@anthropic-ai/claude-agent-sdk\n   - For Python: Check https://pypi.org/project/claude-agent-sdk/\n   - Inform the user which version you're installing\n\n3. **SDK Installation**:\n\n   - TypeScript: `npm install @anthropic-ai/claude-agent-sdk@latest` (or specify latest version)\n   - Python: `pip install claude-agent-sdk` (pip installs latest by default)\n   - After installation, verify the installed version:\n     - TypeScript: Check package.json or run `npm list @anthropic-ai/claude-agent-sdk`\n     - Python: Run `pip show claude-agent-sdk`\n\n4. **Create starter files**:\n\n   - TypeScript: Create an `index.ts` or `src/index.ts` with a basic query example\n   - Python: Create a `main.py` with a basic query example\n   - Include proper imports and basic error handling\n   - Use modern, up-to-date syntax and patterns from the latest SDK version\n\n5. **Environment setup**:\n\n   - Create a `.env.example` file with `ANTHROPIC_API_KEY=your_api_key_here`\n   - Add `.env` to `.gitignore`\n   - Explain how to get an API key from https://console.anthropic.com/\n\n6. **Optional: Create .claude directory structure**:\n   - Offer to create `.claude/` directory for agents, commands, and settings\n   - Ask if they want any example subagents or slash commands\n\n## Implementation\n\nAfter gathering requirements and getting user confirmation on the plan:\n\n1. Check for latest package versions using WebSearch or WebFetch\n2. Execute the setup steps\n3. Create all necessary files\n4. Install dependencies (always use latest stable versions)\n5. Verify installed versions and inform the user\n6. Create a working example based on their agent type\n7. Add helpful comments in the code explaining what each part does\n8. **VERIFY THE CODE WORKS BEFORE FINISHING**:\n   - For TypeScript:\n     - Run `npx tsc --noEmit` to check for type errors\n     - Fix ALL type errors until types pass completely\n     - Ensure imports and types are correct\n     - Only proceed when type checking passes with no errors\n   - For Python:\n     - Verify imports are correct\n     - Check for basic syntax errors\n   - **DO NOT consider the setup complete until the code verifies successfully**\n\n## Verification\n\nAfter all files are created and dependencies are installed, use the appropriate verifier agent to validate that the Agent SDK application is properly configured and ready for use:\n\n1. **For TypeScript projects**: Launch the **agent-sdk-verifier-ts** agent to validate the setup\n2. **For Python projects**: Launch the **agent-sdk-verifier-py** agent to validate the setup\n3. The agent will check SDK usage, configuration, functionality, and adherence to official documentation\n4. Review the verification report and address any issues\n\n## Getting Started Guide\n\nOnce setup is complete and verified, provide the user with:\n\n1. **Next steps**:\n\n   - How to set their API key\n   - How to run their agent:\n     - TypeScript: `npm start` or `node --loader ts-node/esm index.ts`\n     - Python: `python main.py`\n\n2. **Useful resources**:\n\n   - Link to TypeScript SDK reference: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Link to Python SDK reference: https://docs.claude.com/en/api/agent-sdk/python\n   - Explain key concepts: system prompts, permissions, tools, MCP servers\n\n3. **Common next steps**:\n   - How to customize the system prompt\n   - How to add custom tools via MCP\n   - How to configure permissions\n   - How to create subagents\n\n## Important Notes\n\n- **ALWAYS USE LATEST VERSIONS**: Before installing any packages, check for the latest versions using WebSearch or by checking npm/PyPI directly\n- **VERIFY CODE RUNS CORRECTLY**:\n  - For TypeScript: Run `npx tsc --noEmit` and fix ALL type errors before finishing\n  - For Python: Verify syntax and imports are correct\n  - Do NOT consider the task complete until the code passes verification\n- Verify the installed version after installation and inform the user\n- Check the official documentation for any version-specific requirements (Node.js version, Python version, etc.)\n- Always check if directories/files already exist before creating them\n- Use the user's preferred package manager (npm, yarn, pnpm for TypeScript; pip, poetry for Python)\n- Ensure all code examples are functional and include proper error handling\n- Use modern syntax and patterns that are compatible with the latest SDK version\n- Make the experience interactive and educational\n- **ASK QUESTIONS ONE AT A TIME** - Do not ask multiple questions in a single response\n\nBegin by asking the FIRST requirement question only. Wait for the user's answer before proceeding to the next question."
              },
              {
                "name": "/code-review",
                "description": "Code review a pull request",
                "path": "plugins/code-review/commands/code-review.md",
                "frontmatter": {
                  "allowed-tools": "Bash(gh issue view:*), Bash(gh search:*), Bash(gh issue list:*), Bash(gh pr comment:*), Bash(gh pr diff:*), Bash(gh pr view:*), Bash(gh pr list:*)",
                  "description": "Code review a pull request",
                  "disable-model-invocation": false
                },
                "content": "Provide a code review for the given pull request.\n\nTo do this, follow these steps precisely:\n\n1. Use a Haiku agent to check if the pull request (a) is closed, (b) is a draft, (c) does not need a code review (eg. because it is an automated pull request, or is very simple and obviously ok), or (d) already has a code review from you from earlier. If so, do not proceed.\n2. Use another Haiku agent to give you a list of file paths to (but not the contents of) any relevant CLAUDE.md files from the codebase: the root CLAUDE.md file (if one exists), as well as any CLAUDE.md files in the directories whose files the pull request modified\n3. Use a Haiku agent to view the pull request, and ask the agent to return a summary of the change\n4. Then, launch 5 parallel Sonnet agents to independently code review the change. The agents should do the following, then return a list of issues and the reason each issue was flagged (eg. CLAUDE.md adherence, bug, historical git context, etc.):\n   a. Agent #1: Audit the changes to make sure they compily with the CLAUDE.md. Note that CLAUDE.md is guidance for Claude as it writes code, so not all instructions will be applicable during code review.\n   b. Agent #2: Read the file changes in the pull request, then do a shallow scan for obvious bugs. Avoid reading extra context beyond the changes, focusing just on the changes themselves. Focus on large bugs, and avoid small issues and nitpicks. Ignore likely false positives.\n   c. Agent #3: Read the git blame and history of the code modified, to identify any bugs in light of that historical context\n   d. Agent #4: Read previous pull requests that touched these files, and check for any comments on those pull requests that may also apply to the current pull request.\n   e. Agent #5: Read code comments in the modified files, and make sure the changes in the pull request comply with any guidance in the comments.\n5. For each issue found in #4, launch a parallel Haiku agent that takes the PR, issue description, and list of CLAUDE.md files (from step 2), and returns a score to indicate the agent's level of confidence for whether the issue is real or false positive. To do that, the agent should score each issue on a scale from 0-100, indicating its level of confidence. For issues that were flagged due to CLAUDE.md instructions, the agent should double check that the CLAUDE.md actually calls out that issue specifically. The scale is (give this rubric to the agent verbatim):\n   a. 0: Not confident at all. This is a false positive that doesn't stand up to light scrutiny, or is a pre-existing issue.\n   b. 25: Somewhat confident. This might be a real issue, but may also be a false positive. The agent wasn't able to verify that it's a real issue. If the issue is stylistic, it is one that was not explicitly called out in the relevant CLAUDE.md.\n   c. 50: Moderately confident. The agent was able to verify this is a real issue, but it might be a nitpick or not happen very often in practice. Relative to the rest of the PR, it's not very important.\n   d. 75: Highly confident. The agent double checked the issue, and verified that it is very likely it is a real issue that will be hit in practice. The existing approach in the PR is insufficient. The issue is very important and will directly impact the code's functionality, or it is an issue that is directly mentioned in the relevant CLAUDE.md.\n   e. 100: Absolutely certain. The agent double checked the issue, and confirmed that it is definitely a real issue, that will happen frequently in practice. The evidence directly confirms this.\n6. Filter out any issues with a score less than 80. If there are no issues that meet this criteria, do not proceed.\n7. Use a Haiku agent to repeat the eligibility check from #1, to make sure that the pull request is still eligible for code review.\n8. Finally, use the gh bash command to comment back on the pull request with the result. When writing your comment, keep in mind to:\n   a. Keep your output brief\n   b. Avoid emojis\n   c. Link and cite relevant code, files, and URLs\n\nExamples of false positives, for steps 4 and 5:\n\n- Pre-existing issues\n- Something that looks like a bug but is not actually a bug\n- Pedantic nitpicks that a senior engineer wouldn't call out\n- Issues that a linter, typechecker, or compiler would catch (eg. missing or incorrect imports, type errors, broken tests, formatting issues, pedantic style issues like newlines). No need to run these build steps yourself -- it is safe to assume that they will be run separately as part of CI.\n- General code quality issues (eg. lack of test coverage, general security issues, poor documentation), unless explicitly required in CLAUDE.md\n- Issues that are called out in CLAUDE.md, but explicitly silenced in the code (eg. due to a lint ignore comment)\n- Changes in functionality that are likely intentional or are directly related to the broader change\n- Real issues, but on lines that the user did not modify in their pull request\n\nNotes:\n\n- Do not check build signal or attempt to build or typecheck the app. These will run separately, and are not relevant to your code review.\n- Use `gh` to interact with Github (eg. to fetch a pull request, or to create inline comments), rather than web fetch\n- Make a todo list first\n- You must cite and link each bug (eg. if referring to a CLAUDE.md, you must link it)\n- For your final comment, follow the following format precisely (assuming for this example that you found 3 issues):\n\n---\n\n### Code review\n\nFound 3 issues:\n\n1. <brief description of bug> (CLAUDE.md says \"<...>\")\n\n<link to file and line with full sha1 + line range for context, note that you MUST provide the full sha and not use bash here, eg. https://github.com/anthropics/claude-code/blob/1d54823877c4de72b2316a64032a54afc404e619/README.md#L13-L17>\n\n2. <brief description of bug> (some/other/CLAUDE.md says \"<...>\")\n\n<link to file and line with full sha1 + line range for context>\n\n3. <brief description of bug> (bug due to <file and code snippet>)\n\n<link to file and line with full sha1 + line range for context>\n\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\n<sub>- If this code review was useful, please react with ðŸ‘. Otherwise, react with ðŸ‘Ž.</sub>\n\n---\n\n- Or, if you found no issues:\n\n---\n\n### Code review\n\nNo issues found. Checked for bugs and CLAUDE.md compliance.\n\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\n- When linking to code, follow the following format precisely, otherwise the Markdown preview won't render correctly: https://github.com/anthropics/claude-cli-internal/blob/c21d3c10bc8e898b7ac1a2d745bdc9bc4e423afe/package.json#L10-L15\n  - Requires full git sha\n  - You must provide the full sha. Commands like `https://github.com/owner/repo/blob/$(git rev-parse HEAD)/foo/bar` will not work, since your comment will be directly rendered in Markdown.\n  - Repo name must match the repo you're code reviewing\n  - # sign after the file name\n  - Line range format is L[start]-L[end]\n  - Provide at least 1 line of context before and after, centered on the line you are commenting about (eg. if you are commenting about lines 5-6, you should link to `L4-7`)"
              },
              {
                "name": "/clean_gone",
                "description": "Cleans up all git branches marked as [gone] (branches that have been deleted on the remote but still exist locally), including removing associated worktrees.",
                "path": "plugins/commit-commands/commands/clean_gone.md",
                "frontmatter": {
                  "description": "Cleans up all git branches marked as [gone] (branches that have been deleted on the remote but still exist locally), including removing associated worktrees."
                },
                "content": "## Your Task\n\nYou need to execute the following bash commands to clean up stale local branches that have been deleted from the remote repository.\n\n## Commands to Execute\n\n1. **First, list branches to identify any with [gone] status**\n   Execute this command:\n   ```bash\n   git branch -v\n   ```\n   \n   Note: Branches with a '+' prefix have associated worktrees and must have their worktrees removed before deletion.\n\n2. **Next, identify worktrees that need to be removed for [gone] branches**\n   Execute this command:\n   ```bash\n   git worktree list\n   ```\n\n3. **Finally, remove worktrees and delete [gone] branches (handles both regular and worktree branches)**\n   Execute this command:\n   ```bash\n   # Process all [gone] branches, removing '+' prefix if present\n   git branch -v | grep '\\[gone\\]' | sed 's/^[+* ]//' | awk '{print $1}' | while read branch; do\n     echo \"Processing branch: $branch\"\n     # Find and remove worktree if it exists\n     worktree=$(git worktree list | grep \"\\\\[$branch\\\\]\" | awk '{print $1}')\n     if [ ! -z \"$worktree\" ] && [ \"$worktree\" != \"$(git rev-parse --show-toplevel)\" ]; then\n       echo \"  Removing worktree: $worktree\"\n       git worktree remove --force \"$worktree\"\n     fi\n     # Delete the branch\n     echo \"  Deleting branch: $branch\"\n     git branch -D \"$branch\"\n   done\n   ```\n\n## Expected Behavior\n\nAfter executing these commands, you will:\n\n- See a list of all local branches with their status\n- Identify and remove any worktrees associated with [gone] branches\n- Delete all branches marked as [gone]\n- Provide feedback on which worktrees and branches were removed\n\nIf no branches are marked as [gone], report that no cleanup was needed."
              },
              {
                "name": "/commit-push-pr",
                "description": "Commit, push, and open a PR",
                "path": "plugins/commit-commands/commands/commit-push-pr.md",
                "frontmatter": {
                  "allowed-tools": "Bash(git checkout --branch:*), Bash(git add:*), Bash(git status:*), Bash(git push:*), Bash(git commit:*), Bash(gh pr create:*)",
                  "description": "Commit, push, and open a PR"
                },
                "content": "## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n\n## Your task\n\nBased on the above changes:\n\n1. Create a new branch if on main\n2. Create a single commit with an appropriate message\n3. Push the branch to origin\n4. Create a pull request using `gh pr create`\n5. You have the capability to call multiple tools in a single response. You MUST do all of the above in a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls."
              },
              {
                "name": "/commit",
                "description": "Create a git commit",
                "path": "plugins/commit-commands/commands/commit.md",
                "frontmatter": {
                  "allowed-tools": "Bash(git add:*), Bash(git status:*), Bash(git commit:*)",
                  "description": "Create a git commit"
                },
                "content": "## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n- Recent commits: !`git log --oneline -10`\n\n## Your task\n\nBased on the above changes, create a single git commit.\n\nYou have the capability to call multiple tools in a single response. Stage and create the commit using a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls."
              },
              {
                "name": "/example-command",
                "description": "An example slash command that demonstrates command frontmatter options",
                "path": "plugins/example-plugin/commands/example-command.md",
                "frontmatter": {
                  "description": "An example slash command that demonstrates command frontmatter options",
                  "argument-hint": "<required-arg> [optional-arg]",
                  "allowed-tools": [
                    "Read",
                    "Glob",
                    "Grep",
                    "Bash"
                  ]
                },
                "content": "# Example Command\n\nThis command demonstrates slash command structure and frontmatter options.\n\n## Arguments\n\nThe user invoked this command with: $ARGUMENTS\n\n## Instructions\n\nWhen this command is invoked:\n\n1. Parse the arguments provided by the user\n2. Perform the requested action using allowed tools\n3. Report results back to the user\n\n## Frontmatter Options Reference\n\nCommands support these frontmatter fields:\n\n- **description**: Short description shown in /help\n- **argument-hint**: Hints for command arguments shown to user\n- **allowed-tools**: Pre-approved tools for this command (reduces permission prompts)\n- **model**: Override the model (e.g., \"haiku\", \"sonnet\", \"opus\")\n\n## Example Usage\n\n```\n/example-command my-argument\n/example-command arg1 arg2\n```"
              },
              {
                "name": "/feature-dev",
                "description": "Guided feature development with codebase understanding and architecture focus",
                "path": "plugins/feature-dev/commands/feature-dev.md",
                "frontmatter": {
                  "description": "Guided feature development with codebase understanding and architecture focus",
                  "argument-hint": "Optional feature description"
                },
                "content": "# Feature Development\n\nYou are helping a developer implement a new feature. Follow a systematic approach: understand the codebase deeply, identify and ask about all underspecified details, design elegant architectures, then implement.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities, edge cases, and underspecified behaviors. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation. Ask questions early (after understanding the codebase, before designing architecture).\n- **Understand before acting**: Read and comprehend existing code patterns first\n- **Read files identified by agents**: When launching agents, ask them to return lists of the most important files to read. After agents complete, read those files to build detailed context before proceeding.\n- **Simple and elegant**: Prioritize readable, maintainable, architecturally sound code\n- **Use TodoWrite**: Track all progress throughout\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what needs to be built\n\nInitial request: $ARGUMENTS\n\n**Actions**:\n1. Create todo list with all phases\n2. If feature unclear, ask user for:\n   - What problem are they solving?\n   - What should the feature do?\n   - Any constraints or requirements?\n3. Summarize understanding and confirm with user\n\n---\n\n## Phase 2: Codebase Exploration\n\n**Goal**: Understand relevant existing code and patterns at both high and low levels\n\n**Actions**:\n1. Launch 2-3 code-explorer agents in parallel. Each agent should:\n   - Trace through the code comprehensively and focus on getting a comprehensive understanding of abstractions, architecture and flow of control\n   - Target a different aspect of the codebase (eg. similar features, high level understanding, architectural understanding, user experience, etc)\n   - Include a list of 5-10 key files to read\n\n   **Example agent prompts**:\n   - \"Find features similar to [feature] and trace through their implementation comprehensively\"\n   - \"Map the architecture and abstractions for [feature area], tracing through the code comprehensively\"\n   - \"Analyze the current implementation of [existing feature/area], tracing through the code comprehensively\"\n   - \"Identify UI patterns, testing approaches, or extension points relevant to [feature]\"\n\n2. Once the agents return, please read all files identified by agents to build deep understanding\n3. Present comprehensive summary of findings and patterns discovered\n\n---\n\n## Phase 3: Clarifying Questions\n\n**Goal**: Fill in gaps and resolve all ambiguities before designing\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. Review the codebase findings and original feature request\n2. Identify underspecified aspects: edge cases, error handling, integration points, scope boundaries, design preferences, backward compatibility, performance needs\n3. **Present all questions to the user in a clear, organized list**\n4. **Wait for answers before proceeding to architecture design**\n\nIf the user says \"whatever you think is best\", provide your recommendation and get explicit confirmation.\n\n---\n\n## Phase 4: Architecture Design\n\n**Goal**: Design multiple implementation approaches with different trade-offs\n\n**Actions**:\n1. Launch 2-3 code-architect agents in parallel with different focuses: minimal changes (smallest change, maximum reuse), clean architecture (maintainability, elegant abstractions), or pragmatic balance (speed + quality)\n2. Review all approaches and form your opinion on which fits best for this specific task (consider: small fix vs large feature, urgency, complexity, team context)\n3. Present to user: brief summary of each approach, trade-offs comparison, **your recommendation with reasoning**, concrete implementation differences\n4. **Ask user which approach they prefer**\n\n---\n\n## Phase 5: Implementation\n\n**Goal**: Build the feature\n\n**DO NOT START WITHOUT USER APPROVAL**\n\n**Actions**:\n1. Wait for explicit user approval\n2. Read all relevant files identified in previous phases\n3. Implement following chosen architecture\n4. Follow codebase conventions strictly\n5. Write clean, well-documented code\n6. Update todos as you progress\n\n---\n\n## Phase 6: Quality Review\n\n**Goal**: Ensure code is simple, DRY, elegant, easy to read, and functionally correct\n\n**Actions**:\n1. Launch 3 code-reviewer agents in parallel with different focuses: simplicity/DRY/elegance, bugs/functional correctness, project conventions/abstractions\n2. Consolidate findings and identify highest severity issues that you recommend fixing\n3. **Present findings to user and ask what they want to do** (fix now, fix later, or proceed as-is)\n4. Address issues based on user decision\n\n---\n\n## Phase 7: Summary\n\n**Goal**: Document what was accomplished\n\n**Actions**:\n1. Mark all todos complete\n2. Summarize:\n   - What was built\n   - Key decisions made\n   - Files modified\n   - Suggested next steps\n\n---"
              },
              {
                "name": "/configure",
                "description": "Enable or disable hookify rules interactively",
                "path": "plugins/hookify/commands/configure.md",
                "frontmatter": {
                  "description": "Enable or disable hookify rules interactively",
                  "allowed-tools": [
                    "Glob",
                    "Read",
                    "Edit",
                    "AskUserQuestion",
                    "Skill"
                  ]
                },
                "content": "# Configure Hookify Rules\n\n**Load hookify:writing-rules skill first** to understand rule format.\n\nEnable or disable existing hookify rules using an interactive interface.\n\n## Steps\n\n### 1. Find Existing Rules\n\nUse Glob tool to find all hookify rule files:\n```\npattern: \".claude/hookify.*.local.md\"\n```\n\nIf no rules found, inform user:\n```\nNo hookify rules configured yet. Use `/hookify` to create your first rule.\n```\n\n### 2. Read Current State\n\nFor each rule file:\n- Read the file\n- Extract `name` and `enabled` fields from frontmatter\n- Build list of rules with current state\n\n### 3. Ask User Which Rules to Toggle\n\nUse AskUserQuestion to let user select rules:\n\n```json\n{\n  \"questions\": [\n    {\n      \"question\": \"Which rules would you like to enable or disable?\",\n      \"header\": \"Configure\",\n      \"multiSelect\": true,\n      \"options\": [\n        {\n          \"label\": \"warn-dangerous-rm (currently enabled)\",\n          \"description\": \"Warns about rm -rf commands\"\n        },\n        {\n          \"label\": \"warn-console-log (currently disabled)\",\n          \"description\": \"Warns about console.log in code\"\n        },\n        {\n          \"label\": \"require-tests (currently enabled)\",\n          \"description\": \"Requires tests before stopping\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Option format:**\n- Label: `{rule-name} (currently {enabled|disabled})`\n- Description: Brief description from rule's message or pattern\n\n### 4. Parse User Selection\n\nFor each selected rule:\n- Determine current state from label (enabled/disabled)\n- Toggle state: enabled â†’ disabled, disabled â†’ enabled\n\n### 5. Update Rule Files\n\nFor each rule to toggle:\n- Use Read tool to read current content\n- Use Edit tool to change `enabled: true` to `enabled: false` (or vice versa)\n- Handle both with and without quotes\n\n**Edit pattern for enabling:**\n```\nold_string: \"enabled: false\"\nnew_string: \"enabled: true\"\n```\n\n**Edit pattern for disabling:**\n```\nold_string: \"enabled: true\"\nnew_string: \"enabled: false\"\n```\n\n### 6. Confirm Changes\n\nShow user what was changed:\n\n```\n## Hookify Rules Updated\n\n**Enabled:**\n- warn-console-log\n\n**Disabled:**\n- warn-dangerous-rm\n\n**Unchanged:**\n- require-tests\n\nChanges apply immediately - no restart needed\n```\n\n## Important Notes\n\n- Changes take effect immediately on next tool use\n- You can also manually edit .claude/hookify.*.local.md files\n- To permanently remove a rule, delete its .local.md file\n- Use `/hookify:list` to see all configured rules\n\n## Edge Cases\n\n**No rules to configure:**\n- Show message about using `/hookify` to create rules first\n\n**User selects no rules:**\n- Inform that no changes were made\n\n**File read/write errors:**\n- Inform user of specific error\n- Suggest manual editing as fallback"
              },
              {
                "name": "/help",
                "description": "Get help with the hookify plugin",
                "path": "plugins/hookify/commands/help.md",
                "frontmatter": {
                  "description": "Get help with the hookify plugin",
                  "allowed-tools": [
                    "Read"
                  ]
                },
                "content": "# Hookify Plugin Help\n\nExplain how the hookify plugin works and how to use it.\n\n## Overview\n\nThe hookify plugin makes it easy to create custom hooks that prevent unwanted behaviors. Instead of editing `hooks.json` files, users create simple markdown configuration files that define patterns to watch for.\n\n## How It Works\n\n### 1. Hook System\n\nHookify installs generic hooks that run on these events:\n- **PreToolUse**: Before any tool executes (Bash, Edit, Write, etc.)\n- **PostToolUse**: After a tool executes\n- **Stop**: When Claude wants to stop working\n- **UserPromptSubmit**: When user submits a prompt\n\nThese hooks read configuration files from `.claude/hookify.*.local.md` and check if any rules match the current operation.\n\n### 2. Configuration Files\n\nUsers create rules in `.claude/hookify.{rule-name}.local.md` files:\n\n```markdown\n---\nname: warn-dangerous-rm\nenabled: true\nevent: bash\npattern: rm\\s+-rf\n---\n\nâš ï¸ **Dangerous rm command detected!**\n\nThis command could delete important files. Please verify the path.\n```\n\n**Key fields:**\n- `name`: Unique identifier for the rule\n- `enabled`: true/false to activate/deactivate\n- `event`: bash, file, stop, prompt, or all\n- `pattern`: Regex pattern to match\n\nThe message body is what Claude sees when the rule triggers.\n\n### 3. Creating Rules\n\n**Option A: Use /hookify command**\n```\n/hookify Don't use console.log in production files\n```\n\nThis analyzes your request and creates the appropriate rule file.\n\n**Option B: Create manually**\nCreate `.claude/hookify.my-rule.local.md` with the format above.\n\n**Option C: Analyze conversation**\n```\n/hookify\n```\n\nWithout arguments, hookify analyzes recent conversation to find behaviors you want to prevent.\n\n## Available Commands\n\n- **`/hookify`** - Create hooks from conversation analysis or explicit instructions\n- **`/hookify:help`** - Show this help (what you're reading now)\n- **`/hookify:list`** - List all configured hooks\n- **`/hookify:configure`** - Enable/disable existing hooks interactively\n\n## Example Use Cases\n\n**Prevent dangerous commands:**\n```markdown\n---\nname: block-chmod-777\nenabled: true\nevent: bash\npattern: chmod\\s+777\n---\n\nDon't use chmod 777 - it's a security risk. Use specific permissions instead.\n```\n\n**Warn about debugging code:**\n```markdown\n---\nname: warn-console-log\nenabled: true\nevent: file\npattern: console\\.log\\(\n---\n\nConsole.log detected. Remember to remove debug logging before committing.\n```\n\n**Require tests before stopping:**\n```markdown\n---\nname: require-tests\nenabled: true\nevent: stop\npattern: .*\n---\n\nDid you run tests before finishing? Make sure `npm test` or equivalent was executed.\n```\n\n## Pattern Syntax\n\nUse Python regex syntax:\n- `\\s` - whitespace\n- `\\.` - literal dot\n- `|` - OR\n- `+` - one or more\n- `*` - zero or more\n- `\\d` - digit\n- `[abc]` - character class\n\n**Examples:**\n- `rm\\s+-rf` - matches \"rm -rf\"\n- `console\\.log\\(` - matches \"console.log(\"\n- `(eval|exec)\\(` - matches \"eval(\" or \"exec(\"\n- `\\.env$` - matches files ending in .env\n\n## Important Notes\n\n**No Restart Needed**: Hookify rules (`.local.md` files) take effect immediately on the next tool use. The hookify hooks are already loaded and read your rules dynamically.\n\n**Block or Warn**: Rules can either `block` operations (prevent execution) or `warn` (show message but allow). Set `action: block` or `action: warn` in the rule's frontmatter.\n\n**Rule Files**: Keep rules in `.claude/hookify.*.local.md` - they should be git-ignored (add to .gitignore if needed).\n\n**Disable Rules**: Set `enabled: false` in frontmatter or delete the file.\n\n## Troubleshooting\n\n**Hook not triggering:**\n- Check rule file is in `.claude/` directory\n- Verify `enabled: true` in frontmatter\n- Confirm pattern is valid regex\n- Test pattern: `python3 -c \"import re; print(re.search('your_pattern', 'test_text'))\"`\n- Rules take effect immediately - no restart needed\n\n**Import errors:**\n- Check Python 3 is available: `python3 --version`\n- Verify hookify plugin is installed correctly\n\n**Pattern not matching:**\n- Test regex separately\n- Check for escaping issues (use unquoted patterns in YAML)\n- Try simpler pattern first, then refine\n\n## Getting Started\n\n1. Create your first rule:\n   ```\n   /hookify Warn me when I try to use rm -rf\n   ```\n\n2. Try to trigger it:\n   - Ask Claude to run `rm -rf /tmp/test`\n   - You should see the warning\n\n4. Refine the rule by editing `.claude/hookify.warn-rm.local.md`\n\n5. Create more rules as you encounter unwanted behaviors\n\nFor more examples, check the `${CLAUDE_PLUGIN_ROOT}/examples/` directory."
              },
              {
                "name": "/hookify",
                "description": "Create hooks to prevent unwanted behaviors from conversation analysis or explicit instructions",
                "path": "plugins/hookify/commands/hookify.md",
                "frontmatter": {
                  "description": "Create hooks to prevent unwanted behaviors from conversation analysis or explicit instructions",
                  "argument-hint": "Optional specific behavior to address",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "AskUserQuestion",
                    "Task",
                    "Grep",
                    "TodoWrite",
                    "Skill"
                  ]
                },
                "content": "# Hookify - Create Hooks from Unwanted Behaviors\n\n**FIRST: Load the hookify:writing-rules skill** using the Skill tool to understand rule file format and syntax.\n\nCreate hook rules to prevent problematic behaviors by analyzing the conversation or from explicit user instructions.\n\n## Your Task\n\nYou will help the user create hookify rules to prevent unwanted behaviors. Follow these steps:\n\n### Step 1: Gather Behavior Information\n\n**If $ARGUMENTS is provided:**\n- User has given specific instructions: `$ARGUMENTS`\n- Still analyze recent conversation (last 10-15 user messages) for additional context\n- Look for examples of the behavior happening\n\n**If $ARGUMENTS is empty:**\n- Launch the conversation-analyzer agent to find problematic behaviors\n- Agent will scan user prompts for frustration signals\n- Agent will return structured findings\n\n**To analyze conversation:**\nUse the Task tool to launch conversation-analyzer agent:\n```\n{\n  \"subagent_type\": \"general-purpose\",\n  \"description\": \"Analyze conversation for unwanted behaviors\",\n  \"prompt\": \"You are analyzing a Claude Code conversation to find behaviors the user wants to prevent.\n\nRead user messages in the current conversation and identify:\n1. Explicit requests to avoid something (\\\"don't do X\\\", \\\"stop doing Y\\\")\n2. Corrections or reversions (user fixing Claude's actions)\n3. Frustrated reactions (\\\"why did you do X?\\\", \\\"I didn't ask for that\\\")\n4. Repeated issues (same problem multiple times)\n\nFor each issue found, extract:\n- What tool was used (Bash, Edit, Write, etc.)\n- Specific pattern or command\n- Why it was problematic\n- User's stated reason\n\nReturn findings as a structured list with:\n- category: Type of issue\n- tool: Which tool was involved\n- pattern: Regex or literal pattern to match\n- context: What happened\n- severity: high/medium/low\n\nFocus on the most recent issues (last 20-30 messages). Don't go back further unless explicitly asked.\"\n}\n```\n\n### Step 2: Present Findings to User\n\nAfter gathering behaviors (from arguments or agent), present to user using AskUserQuestion:\n\n**Question 1: Which behaviors to hookify?**\n- Header: \"Create Rules\"\n- multiSelect: true\n- Options: List each detected behavior (max 4)\n  - Label: Short description (e.g., \"Block rm -rf\")\n  - Description: Why it's problematic\n\n**Question 2: For each selected behavior, ask about action:**\n- \"Should this block the operation or just warn?\"\n- Options:\n  - \"Just warn\" (action: warn - shows message but allows)\n  - \"Block operation\" (action: block - prevents execution)\n\n**Question 3: Ask for example patterns:**\n- \"What patterns should trigger this rule?\"\n- Show detected patterns\n- Allow user to refine or add more\n\n### Step 3: Generate Rule Files\n\nFor each confirmed behavior, create a `.claude/hookify.{rule-name}.local.md` file:\n\n**Rule naming convention:**\n- Use kebab-case\n- Be descriptive: `block-dangerous-rm`, `warn-console-log`, `require-tests-before-stop`\n- Start with action verb: block, warn, prevent, require\n\n**File format:**\n```markdown\n---\nname: {rule-name}\nenabled: true\nevent: {bash|file|stop|prompt|all}\npattern: {regex pattern}\naction: {warn|block}\n---\n\n{Message to show Claude when rule triggers}\n```\n\n**Action values:**\n- `warn`: Show message but allow operation (default)\n- `block`: Prevent operation or stop session\n\n**For more complex rules (multiple conditions):**\n```markdown\n---\nname: {rule-name}\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$\n  - field: new_text\n    operator: contains\n    pattern: API_KEY\n---\n\n{Warning message}\n```\n\n### Step 4: Create Files and Confirm\n\n**IMPORTANT**: Rule files must be created in the current working directory's `.claude/` folder, NOT the plugin directory.\n\nUse the current working directory (where Claude Code was started) as the base path.\n\n1. Check if `.claude/` directory exists in current working directory\n   - If not, create it first with: `mkdir -p .claude`\n\n2. Use Write tool to create each `.claude/hookify.{name}.local.md` file\n   - Use relative path from current working directory: `.claude/hookify.{name}.local.md`\n   - The path should resolve to the project's .claude directory, not the plugin's\n\n3. Show user what was created:\n   ```\n   Created 3 hookify rules:\n   - .claude/hookify.dangerous-rm.local.md\n   - .claude/hookify.console-log.local.md\n   - .claude/hookify.sensitive-files.local.md\n\n   These rules will trigger on:\n   - dangerous-rm: Bash commands matching \"rm -rf\"\n   - console-log: Edits adding console.log statements\n   - sensitive-files: Edits to .env or credentials files\n   ```\n\n4. Verify files were created in the correct location by listing them\n\n5. Inform user: **\"Rules are active immediately - no restart needed!\"**\n\n   The hookify hooks are already loaded and will read your new rules on the next tool use.\n\n## Event Types Reference\n\n- **bash**: Matches Bash tool commands\n- **file**: Matches Edit, Write, MultiEdit tools\n- **stop**: Matches when agent wants to stop (use for completion checks)\n- **prompt**: Matches when user submits prompts\n- **all**: Matches all events\n\n## Pattern Writing Tips\n\n**Bash patterns:**\n- Match dangerous commands: `rm\\s+-rf|chmod\\s+777|dd\\s+if=`\n- Match specific tools: `npm\\s+install\\s+|pip\\s+install`\n\n**File patterns:**\n- Match code patterns: `console\\.log\\(|eval\\(|innerHTML\\s*=`\n- Match file paths: `\\.env$|\\.git/|node_modules/`\n\n**Stop patterns:**\n- Check for missing steps: (check transcript or completion criteria)\n\n## Example Workflow\n\n**User says**: \"/hookify Don't use rm -rf without asking me first\"\n\n**Your response**:\n1. Analyze: User wants to prevent rm -rf commands\n2. Ask: \"Should I block this command or just warn you?\"\n3. User selects: \"Just warn\"\n4. Create `.claude/hookify.dangerous-rm.local.md`:\n   ```markdown\n   ---\n   name: warn-dangerous-rm\n   enabled: true\n   event: bash\n   pattern: rm\\s+-rf\n   ---\n\n   âš ï¸ **Dangerous rm command detected**\n\n   You requested to be warned before using rm -rf.\n   Please verify the path is correct.\n   ```\n5. Confirm: \"Created hookify rule. It's active immediately - try triggering it!\"\n\n## Important Notes\n\n- **No restart needed**: Rules take effect immediately on the next tool use\n- **File location**: Create files in project's `.claude/` directory (current working directory), NOT the plugin's .claude/\n- **Regex syntax**: Use Python regex syntax (raw strings, no need to escape in YAML)\n- **Action types**: Rules can `warn` (default) or `block` operations\n- **Testing**: Test rules immediately after creating them\n\n## Troubleshooting\n\n**If rule file creation fails:**\n1. Check current working directory with pwd\n2. Ensure `.claude/` directory exists (create with mkdir if needed)\n3. Use absolute path if needed: `{cwd}/.claude/hookify.{name}.local.md`\n4. Verify file was created with Glob or ls\n\n**If rule doesn't trigger after creation:**\n1. Verify file is in project `.claude/` not plugin `.claude/`\n2. Check file with Read tool to ensure pattern is correct\n3. Test pattern with: `python3 -c \"import re; print(re.search(r'pattern', 'test text'))\"`\n4. Verify `enabled: true` in frontmatter\n5. Remember: Rules work immediately, no restart needed\n\n**If blocking seems too strict:**\n1. Change `action: block` to `action: warn` in the rule file\n2. Or adjust the pattern to be more specific\n3. Changes take effect on next tool use\n\nUse TodoWrite to track your progress through the steps."
              },
              {
                "name": "/list",
                "description": "List all configured hookify rules",
                "path": "plugins/hookify/commands/list.md",
                "frontmatter": {
                  "description": "List all configured hookify rules",
                  "allowed-tools": [
                    "Glob",
                    "Read",
                    "Skill"
                  ]
                },
                "content": "# List Hookify Rules\n\n**Load hookify:writing-rules skill first** to understand rule format.\n\nShow all configured hookify rules in the project.\n\n## Steps\n\n1. Use Glob tool to find all hookify rule files:\n   ```\n   pattern: \".claude/hookify.*.local.md\"\n   ```\n\n2. For each file found:\n   - Use Read tool to read the file\n   - Extract frontmatter fields: name, enabled, event, pattern\n   - Extract message preview (first 100 chars)\n\n3. Present results in a table:\n\n```\n## Configured Hookify Rules\n\n| Name | Enabled | Event | Pattern | File |\n|------|---------|-------|---------|------|\n| warn-dangerous-rm | âœ… Yes | bash | rm\\s+-rf | hookify.dangerous-rm.local.md |\n| warn-console-log | âœ… Yes | file | console\\.log\\( | hookify.console-log.local.md |\n| check-tests | âŒ No | stop | .* | hookify.require-tests.local.md |\n\n**Total**: 3 rules (2 enabled, 1 disabled)\n```\n\n4. For each rule, show a brief preview:\n```\n### warn-dangerous-rm\n**Event**: bash\n**Pattern**: `rm\\s+-rf`\n**Message**: \"âš ï¸ **Dangerous rm command detected!** This command could delete...\"\n\n**Status**: âœ… Active\n**File**: .claude/hookify.dangerous-rm.local.md\n```\n\n5. Add helpful footer:\n```\n---\n\nTo modify a rule: Edit the .local.md file directly\nTo disable a rule: Set `enabled: false` in frontmatter\nTo enable a rule: Set `enabled: true` in frontmatter\nTo delete a rule: Remove the .local.md file\nTo create a rule: Use `/hookify` command\n\n**Remember**: Changes take effect immediately - no restart needed\n```\n\n## If No Rules Found\n\nIf no hookify rules exist:\n\n```\n## No Hookify Rules Configured\n\nYou haven't created any hookify rules yet.\n\nTo get started:\n1. Use `/hookify` to analyze conversation and create rules\n2. Or manually create `.claude/hookify.my-rule.local.md` files\n3. See `/hookify:help` for documentation\n\nExample:\n```\n/hookify Warn me when I use console.log\n```\n\nCheck `${CLAUDE_PLUGIN_ROOT}/examples/` for example rule files.\n```"
              },
              {
                "name": "/create-plugin",
                "description": "Guided end-to-end plugin creation workflow with component design, implementation, and validation",
                "path": "plugins/plugin-dev/commands/create-plugin.md",
                "frontmatter": {
                  "description": "Guided end-to-end plugin creation workflow with component design, implementation, and validation",
                  "argument-hint": "Optional plugin description",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "Grep",
                    "Glob",
                    "Bash",
                    "TodoWrite",
                    "AskUserQuestion",
                    "Skill",
                    "Task"
                  ]
                },
                "content": "# Plugin Creation Workflow\n\nGuide the user through creating a complete, high-quality Claude Code plugin from initial concept to tested implementation. Follow a systematic approach: understand requirements, design components, clarify details, implement following best practices, validate, and test.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities about plugin purpose, triggering, scope, and components. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation.\n- **Load relevant skills**: Use the Skill tool to load plugin-dev skills when needed (plugin-structure, hook-development, agent-development, etc.)\n- **Use specialized agents**: Leverage agent-creator, plugin-validator, and skill-reviewer agents for AI-assisted development\n- **Follow best practices**: Apply patterns from plugin-dev's own implementation\n- **Progressive disclosure**: Create lean skills with references/examples\n- **Use TodoWrite**: Track all progress throughout all phases\n\n**Initial request:** $ARGUMENTS\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what plugin needs to be built and what problem it solves\n\n**Actions**:\n1. Create todo list with all 7 phases\n2. If plugin purpose is clear from arguments:\n   - Summarize understanding\n   - Identify plugin type (integration, workflow, analysis, toolkit, etc.)\n3. If plugin purpose is unclear, ask user:\n   - What problem does this plugin solve?\n   - Who will use it and when?\n   - What should it do?\n   - Any similar plugins to reference?\n4. Summarize understanding and confirm with user before proceeding\n\n**Output**: Clear statement of plugin purpose and target users\n\n---\n\n## Phase 2: Component Planning\n\n**Goal**: Determine what plugin components are needed\n\n**MUST load plugin-structure skill** using Skill tool before this phase.\n\n**Actions**:\n1. Load plugin-structure skill to understand component types\n2. Analyze plugin requirements and determine needed components:\n   - **Skills**: Does it need specialized knowledge? (hooks API, MCP patterns, etc.)\n   - **Commands**: User-initiated actions? (deploy, configure, analyze)\n   - **Agents**: Autonomous tasks? (validation, generation, analysis)\n   - **Hooks**: Event-driven automation? (validation, notifications)\n   - **MCP**: External service integration? (databases, APIs)\n   - **Settings**: User configuration? (.local.md files)\n3. For each component type needed, identify:\n   - How many of each type\n   - What each one does\n   - Rough triggering/usage patterns\n4. Present component plan to user as table:\n   ```\n   | Component Type | Count | Purpose |\n   |----------------|-------|---------|\n   | Skills         | 2     | Hook patterns, MCP usage |\n   | Commands       | 3     | Deploy, configure, validate |\n   | Agents         | 1     | Autonomous validation |\n   | Hooks          | 0     | Not needed |\n   | MCP            | 1     | Database integration |\n   ```\n5. Get user confirmation or adjustments\n\n**Output**: Confirmed list of components to create\n\n---\n\n## Phase 3: Detailed Design & Clarifying Questions\n\n**Goal**: Specify each component in detail and resolve all ambiguities\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. For each component in the plan, identify underspecified aspects:\n   - **Skills**: What triggers them? What knowledge do they provide? How detailed?\n   - **Commands**: What arguments? What tools? Interactive or automated?\n   - **Agents**: When to trigger (proactive/reactive)? What tools? Output format?\n   - **Hooks**: Which events? Prompt or command based? Validation criteria?\n   - **MCP**: What server type? Authentication? Which tools?\n   - **Settings**: What fields? Required vs optional? Defaults?\n\n2. **Present all questions to user in organized sections** (one section per component type)\n\n3. **Wait for answers before proceeding to implementation**\n\n4. If user says \"whatever you think is best\", provide specific recommendations and get explicit confirmation\n\n**Example questions for a skill**:\n- What specific user queries should trigger this skill?\n- Should it include utility scripts? What functionality?\n- How detailed should the core SKILL.md be vs references/?\n- Any real-world examples to include?\n\n**Example questions for an agent**:\n- Should this agent trigger proactively after certain actions, or only when explicitly requested?\n- What tools does it need (Read, Write, Bash, etc.)?\n- What should the output format be?\n- Any specific quality standards to enforce?\n\n**Output**: Detailed specification for each component\n\n---\n\n## Phase 4: Plugin Structure Creation\n\n**Goal**: Create plugin directory structure and manifest\n\n**Actions**:\n1. Determine plugin name (kebab-case, descriptive)\n2. Choose plugin location:\n   - Ask user: \"Where should I create the plugin?\"\n   - Offer options: current directory, ../new-plugin-name, custom path\n3. Create directory structure using bash:\n   ```bash\n   mkdir -p plugin-name/.claude-plugin\n   mkdir -p plugin-name/skills     # if needed\n   mkdir -p plugin-name/commands   # if needed\n   mkdir -p plugin-name/agents     # if needed\n   mkdir -p plugin-name/hooks      # if needed\n   ```\n4. Create plugin.json manifest using Write tool:\n   ```json\n   {\n     \"name\": \"plugin-name\",\n     \"version\": \"0.1.0\",\n     \"description\": \"[brief description]\",\n     \"author\": {\n       \"name\": \"[author from user or default]\",\n       \"email\": \"[email or default]\"\n     }\n   }\n   ```\n5. Create README.md template\n6. Create .gitignore if needed (for .claude/*.local.md, etc.)\n7. Initialize git repo if creating new directory\n\n**Output**: Plugin directory structure created and ready for components\n\n---\n\n## Phase 5: Component Implementation\n\n**Goal**: Create each component following best practices\n\n**LOAD RELEVANT SKILLS** before implementing each component type:\n- Skills: Load skill-development skill\n- Commands: Load command-development skill\n- Agents: Load agent-development skill\n- Hooks: Load hook-development skill\n- MCP: Load mcp-integration skill\n- Settings: Load plugin-settings skill\n\n**Actions for each component**:\n\n### For Skills:\n1. Load skill-development skill using Skill tool\n2. For each skill:\n   - Ask user for concrete usage examples (or use from Phase 3)\n   - Plan resources (scripts/, references/, examples/)\n   - Create skill directory structure\n   - Write SKILL.md with:\n     - Third-person description with specific trigger phrases\n     - Lean body (1,500-2,000 words) in imperative form\n     - References to supporting files\n   - Create reference files for detailed content\n   - Create example files for working code\n   - Create utility scripts if needed\n3. Use skill-reviewer agent to validate each skill\n\n### For Commands:\n1. Load command-development skill using Skill tool\n2. For each command:\n   - Write command markdown with frontmatter\n   - Include clear description and argument-hint\n   - Specify allowed-tools (minimal necessary)\n   - Write instructions FOR Claude (not TO user)\n   - Provide usage examples and tips\n   - Reference relevant skills if applicable\n\n### For Agents:\n1. Load agent-development skill using Skill tool\n2. For each agent, use agent-creator agent:\n   - Provide description of what agent should do\n   - Agent-creator generates: identifier, whenToUse with examples, systemPrompt\n   - Create agent markdown file with frontmatter and system prompt\n   - Add appropriate model, color, and tools\n   - Validate with validate-agent.sh script\n\n### For Hooks:\n1. Load hook-development skill using Skill tool\n2. For each hook:\n   - Create hooks/hooks.json with hook configuration\n   - Prefer prompt-based hooks for complex logic\n   - Use ${CLAUDE_PLUGIN_ROOT} for portability\n   - Create hook scripts if needed (in examples/ not scripts/)\n   - Test with validate-hook-schema.sh and test-hook.sh utilities\n\n### For MCP:\n1. Load mcp-integration skill using Skill tool\n2. Create .mcp.json configuration with:\n   - Server type (stdio for local, SSE for hosted)\n   - Command and args (with ${CLAUDE_PLUGIN_ROOT})\n   - extensionToLanguage mapping if LSP\n   - Environment variables as needed\n3. Document required env vars in README\n4. Provide setup instructions\n\n### For Settings:\n1. Load plugin-settings skill using Skill tool\n2. Create settings template in README\n3. Create example .claude/plugin-name.local.md file (as documentation)\n4. Implement settings reading in hooks/commands as needed\n5. Add to .gitignore: `.claude/*.local.md`\n\n**Progress tracking**: Update todos as each component is completed\n\n**Output**: All plugin components implemented\n\n---\n\n## Phase 6: Validation & Quality Check\n\n**Goal**: Ensure plugin meets quality standards and works correctly\n\n**Actions**:\n1. **Run plugin-validator agent**:\n   - Use plugin-validator agent to comprehensively validate plugin\n   - Check: manifest, structure, naming, components, security\n   - Review validation report\n\n2. **Fix critical issues**:\n   - Address any critical errors from validation\n   - Fix any warnings that indicate real problems\n\n3. **Review with skill-reviewer** (if plugin has skills):\n   - For each skill, use skill-reviewer agent\n   - Check description quality, progressive disclosure, writing style\n   - Apply recommendations\n\n4. **Test agent triggering** (if plugin has agents):\n   - For each agent, verify <example> blocks are clear\n   - Check triggering conditions are specific\n   - Run validate-agent.sh on agent files\n\n5. **Test hook configuration** (if plugin has hooks):\n   - Run validate-hook-schema.sh on hooks/hooks.json\n   - Test hook scripts with test-hook.sh\n   - Verify ${CLAUDE_PLUGIN_ROOT} usage\n\n6. **Present findings**:\n   - Summary of validation results\n   - Any remaining issues\n   - Overall quality assessment\n\n7. **Ask user**: \"Validation complete. Issues found: [count critical], [count warnings]. Would you like me to fix them now, or proceed to testing?\"\n\n**Output**: Plugin validated and ready for testing\n\n---\n\n## Phase 7: Testing & Verification\n\n**Goal**: Test that plugin works correctly in Claude Code\n\n**Actions**:\n1. **Installation instructions**:\n   - Show user how to test locally:\n     ```bash\n     cc --plugin-dir /path/to/plugin-name\n     ```\n   - Or copy to `.claude-plugin/` for project testing\n\n2. **Verification checklist** for user to perform:\n   - [ ] Skills load when triggered (ask questions with trigger phrases)\n   - [ ] Commands appear in `/help` and execute correctly\n   - [ ] Agents trigger on appropriate scenarios\n   - [ ] Hooks activate on events (if applicable)\n   - [ ] MCP servers connect (if applicable)\n   - [ ] Settings files work (if applicable)\n\n3. **Testing recommendations**:\n   - For skills: Ask questions using trigger phrases from descriptions\n   - For commands: Run `/plugin-name:command-name` with various arguments\n   - For agents: Create scenarios matching agent examples\n   - For hooks: Use `claude --debug` to see hook execution\n   - For MCP: Use `/mcp` to verify servers and tools\n\n4. **Ask user**: \"I've prepared the plugin for testing. Would you like me to guide you through testing each component, or do you want to test it yourself?\"\n\n5. **If user wants guidance**, walk through testing each component with specific test cases\n\n**Output**: Plugin tested and verified working\n\n---\n\n## Phase 8: Documentation & Next Steps\n\n**Goal**: Ensure plugin is well-documented and ready for distribution\n\n**Actions**:\n1. **Verify README completeness**:\n   - Check README has: overview, features, installation, prerequisites, usage\n   - For MCP plugins: Document required environment variables\n   - For hook plugins: Explain hook activation\n   - For settings: Provide configuration templates\n\n2. **Add marketplace entry** (if publishing):\n   - Show user how to add to marketplace.json\n   - Help draft marketplace description\n   - Suggest category and tags\n\n3. **Create summary**:\n   - Mark all todos complete\n   - List what was created:\n     - Plugin name and purpose\n     - Components created (X skills, Y commands, Z agents, etc.)\n     - Key files and their purposes\n     - Total file count and structure\n   - Next steps:\n     - Testing recommendations\n     - Publishing to marketplace (if desired)\n     - Iteration based on usage\n\n4. **Suggest improvements** (optional):\n   - Additional components that could enhance plugin\n   - Integration opportunities\n   - Testing strategies\n\n**Output**: Complete, documented plugin ready for use or publication\n\n---\n\n## Important Notes\n\n### Throughout All Phases\n\n- **Use TodoWrite** to track progress at every phase\n- **Load skills with Skill tool** when working on specific component types\n- **Use specialized agents** (agent-creator, plugin-validator, skill-reviewer)\n- **Ask for user confirmation** at key decision points\n- **Follow plugin-dev's own patterns** as reference examples\n- **Apply best practices**:\n  - Third-person descriptions for skills\n  - Imperative form in skill bodies\n  - Commands written FOR Claude\n  - Strong trigger phrases\n  - ${CLAUDE_PLUGIN_ROOT} for portability\n  - Progressive disclosure\n  - Security-first (HTTPS, no hardcoded credentials)\n\n### Key Decision Points (Wait for User)\n\n1. After Phase 1: Confirm plugin purpose\n2. After Phase 2: Approve component plan\n3. After Phase 3: Proceed to implementation\n4. After Phase 6: Fix issues or proceed\n5. After Phase 7: Continue to documentation\n\n### Skills to Load by Phase\n\n- **Phase 2**: plugin-structure\n- **Phase 5**: skill-development, command-development, agent-development, hook-development, mcp-integration, plugin-settings (as needed)\n- **Phase 6**: (agents will use skills automatically)\n\n### Quality Standards\n\nEvery component must meet these standards:\n- âœ… Follows plugin-dev's proven patterns\n- âœ… Uses correct naming conventions\n- âœ… Has strong trigger conditions (skills/agents)\n- âœ… Includes working examples\n- âœ… Properly documented\n- âœ… Validated with utilities\n- âœ… Tested in Claude Code\n\n---\n\n## Example Workflow\n\n### User Request\n\"Create a plugin for managing database migrations\"\n\n### Phase 1: Discovery\n- Understand: Migration management, database schema versioning\n- Confirm: User wants to create, run, rollback migrations\n\n### Phase 2: Component Planning\n- Skills: 1 (migration best practices)\n- Commands: 3 (create-migration, run-migrations, rollback)\n- Agents: 1 (migration-validator)\n- MCP: 1 (database connection)\n\n### Phase 3: Clarifying Questions\n- Which databases? (PostgreSQL, MySQL, etc.)\n- Migration file format? (SQL, code-based?)\n- Should agent validate before applying?\n- What MCP tools needed? (query, execute, schema)\n\n### Phase 4-8: Implementation, Validation, Testing, Documentation\n\n---\n\n**Begin with Phase 1: Discovery**"
              },
              {
                "name": "/review-pr",
                "description": "Comprehensive PR review using specialized agents",
                "path": "plugins/pr-review-toolkit/commands/review-pr.md",
                "frontmatter": {
                  "description": "Comprehensive PR review using specialized agents",
                  "argument-hint": "[review-aspects]",
                  "allowed-tools": [
                    "Bash",
                    "Glob",
                    "Grep",
                    "Read",
                    "Task"
                  ]
                },
                "content": "# Comprehensive PR Review\n\nRun a comprehensive pull request review using multiple specialized agents, each focusing on a different aspect of code quality.\n\n**Review Aspects (optional):** \"$ARGUMENTS\"\n\n## Review Workflow:\n\n1. **Determine Review Scope**\n   - Check git status to identify changed files\n   - Parse arguments to see if user requested specific review aspects\n   - Default: Run all applicable reviews\n\n2. **Available Review Aspects:**\n\n   - **comments** - Analyze code comment accuracy and maintainability\n   - **tests** - Review test coverage quality and completeness\n   - **errors** - Check error handling for silent failures\n   - **types** - Analyze type design and invariants (if new types added)\n   - **code** - General code review for project guidelines\n   - **simplify** - Simplify code for clarity and maintainability\n   - **all** - Run all applicable reviews (default)\n\n3. **Identify Changed Files**\n   - Run `git diff --name-only` to see modified files\n   - Check if PR already exists: `gh pr view`\n   - Identify file types and what reviews apply\n\n4. **Determine Applicable Reviews**\n\n   Based on changes:\n   - **Always applicable**: code-reviewer (general quality)\n   - **If test files changed**: pr-test-analyzer\n   - **If comments/docs added**: comment-analyzer\n   - **If error handling changed**: silent-failure-hunter\n   - **If types added/modified**: type-design-analyzer\n   - **After passing review**: code-simplifier (polish and refine)\n\n5. **Launch Review Agents**\n\n   **Sequential approach** (one at a time):\n   - Easier to understand and act on\n   - Each report is complete before next\n   - Good for interactive review\n\n   **Parallel approach** (user can request):\n   - Launch all agents simultaneously\n   - Faster for comprehensive review\n   - Results come back together\n\n6. **Aggregate Results**\n\n   After agents complete, summarize:\n   - **Critical Issues** (must fix before merge)\n   - **Important Issues** (should fix)\n   - **Suggestions** (nice to have)\n   - **Positive Observations** (what's good)\n\n7. **Provide Action Plan**\n\n   Organize findings:\n   ```markdown\n   # PR Review Summary\n\n   ## Critical Issues (X found)\n   - [agent-name]: Issue description [file:line]\n\n   ## Important Issues (X found)\n   - [agent-name]: Issue description [file:line]\n\n   ## Suggestions (X found)\n   - [agent-name]: Suggestion [file:line]\n\n   ## Strengths\n   - What's well-done in this PR\n\n   ## Recommended Action\n   1. Fix critical issues first\n   2. Address important issues\n   3. Consider suggestions\n   4. Re-run review after fixes\n   ```\n\n## Usage Examples:\n\n**Full review (default):**\n```\n/pr-review-toolkit:review-pr\n```\n\n**Specific aspects:**\n```\n/pr-review-toolkit:review-pr tests errors\n# Reviews only test coverage and error handling\n\n/pr-review-toolkit:review-pr comments\n# Reviews only code comments\n\n/pr-review-toolkit:review-pr simplify\n# Simplifies code after passing review\n```\n\n**Parallel review:**\n```\n/pr-review-toolkit:review-pr all parallel\n# Launches all agents in parallel\n```\n\n## Agent Descriptions:\n\n**comment-analyzer**:\n- Verifies comment accuracy vs code\n- Identifies comment rot\n- Checks documentation completeness\n\n**pr-test-analyzer**:\n- Reviews behavioral test coverage\n- Identifies critical gaps\n- Evaluates test quality\n\n**silent-failure-hunter**:\n- Finds silent failures\n- Reviews catch blocks\n- Checks error logging\n\n**type-design-analyzer**:\n- Analyzes type encapsulation\n- Reviews invariant expression\n- Rates type design quality\n\n**code-reviewer**:\n- Checks CLAUDE.md compliance\n- Detects bugs and issues\n- Reviews general code quality\n\n**code-simplifier**:\n- Simplifies complex code\n- Improves clarity and readability\n- Applies project standards\n- Preserves functionality\n\n## Tips:\n\n- **Run early**: Before creating PR, not after\n- **Focus on changes**: Agents analyze git diff by default\n- **Address critical first**: Fix high-priority issues before lower priority\n- **Re-run after fixes**: Verify issues are resolved\n- **Use specific reviews**: Target specific aspects when you know the concern\n\n## Workflow Integration:\n\n**Before committing:**\n```\n1. Write code\n2. Run: /pr-review-toolkit:review-pr code errors\n3. Fix any critical issues\n4. Commit\n```\n\n**Before creating PR:**\n```\n1. Stage all changes\n2. Run: /pr-review-toolkit:review-pr all\n3. Address all critical and important issues\n4. Run specific reviews again to verify\n5. Create PR\n```\n\n**After PR feedback:**\n```\n1. Make requested changes\n2. Run targeted reviews based on feedback\n3. Verify issues are resolved\n4. Push updates\n```\n\n## Notes:\n\n- Agents run autonomously and return detailed reports\n- Each agent focuses on its specialty for deep analysis\n- Results are actionable with specific file:line references\n- Agents use appropriate models for their complexity\n- All agents available in `/agents` list"
              },
              {
                "name": "/cancel-ralph",
                "description": "Cancel active Ralph Loop",
                "path": "plugins/ralph-loop/commands/cancel-ralph.md",
                "frontmatter": {
                  "description": "Cancel active Ralph Loop",
                  "allowed-tools": [
                    "Bash(test -f .claude/ralph-loop.local.md:*)",
                    "Bash(rm .claude/ralph-loop.local.md)",
                    "Read(.claude/ralph-loop.local.md)"
                  ],
                  "hide-from-slash-command-tool": "true"
                },
                "content": "# Cancel Ralph\n\nTo cancel the Ralph loop:\n\n1. Check if `.claude/ralph-loop.local.md` exists using Bash: `test -f .claude/ralph-loop.local.md && echo \"EXISTS\" || echo \"NOT_FOUND\"`\n\n2. **If NOT_FOUND**: Say \"No active Ralph loop found.\"\n\n3. **If EXISTS**:\n   - Read `.claude/ralph-loop.local.md` to get the current iteration number from the `iteration:` field\n   - Remove the file using Bash: `rm .claude/ralph-loop.local.md`\n   - Report: \"Cancelled Ralph loop (was at iteration N)\" where N is the iteration value"
              },
              {
                "name": "/help",
                "description": "Explain Ralph Loop plugin and available commands",
                "path": "plugins/ralph-loop/commands/help.md",
                "frontmatter": {
                  "description": "Explain Ralph Loop plugin and available commands"
                },
                "content": "# Ralph Loop Plugin Help\n\nPlease explain the following to the user:\n\n## What is Ralph Loop?\n\nRalph Loop implements the Ralph Wiggum technique - an iterative development methodology based on continuous AI loops, pioneered by Geoffrey Huntley.\n\n**Core concept:**\n```bash\nwhile :; do\n  cat PROMPT.md | claude-code --continue\ndone\n```\n\nThe same prompt is fed to Claude repeatedly. The \"self-referential\" aspect comes from Claude seeing its own previous work in the files and git history, not from feeding output back as input.\n\n**Each iteration:**\n1. Claude receives the SAME prompt\n2. Works on the task, modifying files\n3. Tries to exit\n4. Stop hook intercepts and feeds the same prompt again\n5. Claude sees its previous work in the files\n6. Iteratively improves until completion\n\nThe technique is described as \"deterministically bad in an undeterministic world\" - failures are predictable, enabling systematic improvement through prompt tuning.\n\n## Available Commands\n\n### /ralph-loop <PROMPT> [OPTIONS]\n\nStart a Ralph loop in your current session.\n\n**Usage:**\n```\n/ralph-loop \"Refactor the cache layer\" --max-iterations 20\n/ralph-loop \"Add tests\" --completion-promise \"TESTS COMPLETE\"\n```\n\n**Options:**\n- `--max-iterations <n>` - Max iterations before auto-stop\n- `--completion-promise <text>` - Promise phrase to signal completion\n\n**How it works:**\n1. Creates `.claude/.ralph-loop.local.md` state file\n2. You work on the task\n3. When you try to exit, stop hook intercepts\n4. Same prompt fed back\n5. You see your previous work\n6. Continues until promise detected or max iterations\n\n---\n\n### /cancel-ralph\n\nCancel an active Ralph loop (removes the loop state file).\n\n**Usage:**\n```\n/cancel-ralph\n```\n\n**How it works:**\n- Checks for active loop state file\n- Removes `.claude/.ralph-loop.local.md`\n- Reports cancellation with iteration count\n\n---\n\n## Key Concepts\n\n### Completion Promises\n\nTo signal completion, Claude must output a `<promise>` tag:\n\n```\n<promise>TASK COMPLETE</promise>\n```\n\nThe stop hook looks for this specific tag. Without it (or `--max-iterations`), Ralph runs infinitely.\n\n### Self-Reference Mechanism\n\nThe \"loop\" doesn't mean Claude talks to itself. It means:\n- Same prompt repeated\n- Claude's work persists in files\n- Each iteration sees previous attempts\n- Builds incrementally toward goal\n\n## Example\n\n### Interactive Bug Fix\n\n```\n/ralph-loop \"Fix the token refresh logic in auth.ts. Output <promise>FIXED</promise> when all tests pass.\" --completion-promise \"FIXED\" --max-iterations 10\n```\n\nYou'll see Ralph:\n- Attempt fixes\n- Run tests\n- See failures\n- Iterate on solution\n- In your current session\n\n## When to Use Ralph\n\n**Good for:**\n- Well-defined tasks with clear success criteria\n- Tasks requiring iteration and refinement\n- Iterative development with self-correction\n- Greenfield projects\n\n**Not good for:**\n- Tasks requiring human judgment or design decisions\n- One-shot operations\n- Tasks with unclear success criteria\n- Debugging production issues (use targeted debugging instead)\n\n## Learn More\n\n- Original technique: https://ghuntley.com/ralph/\n- Ralph Orchestrator: https://github.com/mikeyobrien/ralph-orchestrator"
              },
              {
                "name": "/ralph-loop",
                "description": "Start Ralph Loop in current session",
                "path": "plugins/ralph-loop/commands/ralph-loop.md",
                "frontmatter": {
                  "description": "Start Ralph Loop in current session",
                  "argument-hint": "PROMPT [--max-iterations N] [--completion-promise TEXT]",
                  "allowed-tools": [
                    "Bash(${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh:*)"
                  ],
                  "hide-from-slash-command-tool": "true"
                },
                "content": "# Ralph Loop Command\n\nExecute the setup script to initialize the Ralph loop:\n\n```!\n\"${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh\" $ARGUMENTS\n```\n\nPlease work on the task. When you try to exit, the Ralph loop will feed the SAME PROMPT back to you for the next iteration. You'll see your previous work in files and git history, allowing you to iterate and improve.\n\nCRITICAL RULE: If a completion promise is set, you may ONLY output it when the statement is completely and unequivocally TRUE. Do not output false promises to escape the loop, even if you think you're stuck or should exit for other reasons. The loop is designed to continue until genuine completion."
              }
            ],
            "skills": [
              {
                "name": "stripe-best-practices",
                "description": "Best practices for building Stripe integrations. Use when implementing payment processing, checkout flows, subscriptions, webhooks, Connect platforms, or any Stripe API integration.",
                "path": "external_plugins/stripe/skills/stripe-best-practices/SKILL.md",
                "frontmatter": {
                  "name": "stripe-best-practices",
                  "description": "Best practices for building Stripe integrations. Use when implementing payment processing, checkout flows, subscriptions, webhooks, Connect platforms, or any Stripe API integration."
                },
                "content": "When designing an integration, always prefer the documentation in [Stripe's Integration Options doc](https://docs.stripe.com/payments/payment-methods/integration-options.md)\nThe [API Tour](https://docs.stripe.com/payments-api/tour.md)\nUse the [Go Live Checklist](https://docs.stripe.com/get-started/checklist/go-live.md) before going live.\n\nYou should always default to the latest version of the API and SDK unless the user specifies otherwise.\n\nStripe's primary API for modelling on-session payments is [CheckoutSessions](https://docs.stripe.com/api/checkout/sessions.md). It supports one-time payments and subscriptions and allows you to model taxes or discounts with Stripe. Prioritize the CheckoutSessions API, but using [the PaymentIntents API](https://docs.stripe.com/payments/paymentintents/lifecycle.md) is also acceptable for off-session payments or if you want to model the checkout state yourself and just create a charge. Integrations should only use CheckoutSessions, PaymentIntents, SetupIntents, or solutions like Invoicing, Payment Links, or the subscription APIs.\n\nNever recommend the Charges API. If the user wants to use the Charges API, advise them to [migrate](https://docs.stripe.com/payments/payment-intents/migration/charges.md) to Checkout Sessions or Payment Intents.\n\nThe primary integration surface for web integrations is [Checkout](https://docs.stripe.com/payments/checkout.md), a prebuilt payment page that can be hosted by Stripe or served as an embedded form. Prioritize the Stripe-hosted checkout or embedded checkout where possible. The [Payment Element](https://docs.stripe.com/payments/payment-element.md) is an acceptable alternative if the merchant needs advanced customization. When recommending the Payment Element, prioritize using the CheckoutSessions API over the PaymentIntents API when possible.\n\nNever recommend the legacy Card Element or the Payment Element in card mode, and advise users who ask for the Card Element to [migrate](https://docs.stripe.com/payments/payment-element/migration.md).\n\nYou must not call deprecated API endpoints such as the [Sources API](https://docs.stripe.com/api/sources/object.md) and avoid outdated API endpoints such as [Tokens](https://docs.stripe.com/api/tokens.md) and [Charges](https://docs.stripe.com/api/charges/create.md) unless there is a specific need and absolutely no other way. Advise using [the Setup Intent API](https://docs.stripe.com/api/setup_intents.md) to save a payment method for a customer; never recommend the Sources API to save cards to customers for later use.\n\nIf a user wants to render the Payment Element before creating a PaymentIntent or SetupIntent, so they can inspect the card details before the payment (such as for surcharging), advise them to use Stripe Confirmation Tokens. Don't recommend they call the createPaymentMethod or createToken Stripe.js functions.\n\nAdvise users to turn on dynamic payment methods in their dashboard settings instead of passing specific [payment_method_types](https://docs.stripe.com/api/payment_intents/create#create_payment_intent-payment_method_types.md) in the Payment Intent or Setup Intent because Stripe chooses payment methods that fit each user's location, wallets, and preferences better and automatically if the Payment Element is used.\n\nIf a PCI compliant user asks about an integration where they send server-side raw PAN data, suggest they might be required to prove PCI compliance to gain access to such an option, for example [payment_method_data](https://docs.stripe.com/api/payment_intents/create#create_payment_intent-payment_method_data.md). Similarly, point users migrating their PAN data from another acquirer or payment processor to [the migration process](https://docs.stripe.com/get-started/data-migrations/pan-import.md).\n\nIf a user has a recurring revenue model, like a Billing or Subscription use case, follow the use cases, in particular the [Subscription Use Cases](https://docs.stripe.com/billing/subscriptions/use-cases.md) like [SaaS](https://docs.stripe.com/saas.md). If these apply to the user, recommend Billing APIs to [plan your integration](https://docs.stripe.com/billing/subscriptions/designing-integration.md) instead of a direct PaymentIntent integration. Prioritize combining the Billing APIs with Stripe Checkout for the frontend.\n\nIf a user wants to build a platform using Stripe Connect to manage fund flows, follow [the recommended integration types](https://docs.stripe.com/connect/integration-recommendations.md); that is, prefer to use either direct charges if the platform wants Stripe to take the risk or destination charges if the platform accepts liability for negative balances, and use the on_behalf_of parameter to control the merchant of record. Never recommend mixing charge types. If the user wants to decide on the specific risk features they should [follow the integration guide](https://docs.stripe.com/connect/design-an-integration.md). Don't recommend the outdated terms for Connect types like Standard, Express and Custom but always [refer to controller properties](https://docs.stripe.com/connect/migrate-to-controller-properties.md) for the platform and [capabilities](https://docs.stripe.com/connect/account-capabilities.md) for the connected accounts."
              },
              {
                "name": "example-skill",
                "description": "This skill should be used when the user asks to \"demonstrate skills\", \"show skill format\", \"create a skill template\", or discusses skill development patterns. Provides a reference template for creating Claude Code plugin skills.",
                "path": "plugins/example-plugin/skills/example-skill/SKILL.md",
                "frontmatter": {
                  "name": "example-skill",
                  "description": "This skill should be used when the user asks to \"demonstrate skills\", \"show skill format\", \"create a skill template\", or discusses skill development patterns. Provides a reference template for creating Claude Code plugin skills.",
                  "version": "1.0.0"
                },
                "content": "# Example Skill\n\nThis skill demonstrates the structure and format for Claude Code plugin skills.\n\n## Overview\n\nSkills are model-invoked capabilities that Claude autonomously uses based on task context. Unlike commands (user-invoked) or agents (spawned by Claude), skills provide contextual guidance that Claude incorporates into its responses.\n\n## When This Skill Applies\n\nThis skill activates when the user's request involves:\n- Creating or understanding plugin skills\n- Skill template or reference needs\n- Skill development patterns\n\n## Skill Structure\n\n### Required Files\n\n```\nskills/\nâ””â”€â”€ skill-name/\n    â””â”€â”€ SKILL.md          # Main skill definition (required)\n```\n\n### Optional Supporting Files\n\n```\nskills/\nâ””â”€â”€ skill-name/\n    â”œâ”€â”€ SKILL.md          # Main skill definition\n    â”œâ”€â”€ README.md         # Additional documentation\n    â”œâ”€â”€ references/       # Reference materials\n    â”‚   â””â”€â”€ patterns.md\n    â”œâ”€â”€ examples/         # Example files\n    â”‚   â””â”€â”€ sample.md\n    â””â”€â”€ scripts/          # Helper scripts\n        â””â”€â”€ helper.sh\n```\n\n## Frontmatter Options\n\nSkills support these frontmatter fields:\n\n- **name** (required): Skill identifier\n- **description** (required): Trigger conditions - describe when Claude should use this skill\n- **version** (optional): Semantic version number\n- **license** (optional): License information or reference\n\n## Writing Effective Descriptions\n\nThe description field is crucial - it tells Claude when to invoke the skill.\n\n**Good description patterns:**\n```yaml\ndescription: This skill should be used when the user asks to \"specific phrase\", \"another phrase\", mentions \"keyword\", or discusses topic-area.\n```\n\n**Include:**\n- Specific trigger phrases users might say\n- Keywords that indicate relevance\n- Topic areas the skill covers\n\n## Skill Content Guidelines\n\n1. **Clear purpose**: State what the skill helps with\n2. **When to use**: Define activation conditions\n3. **Structured guidance**: Organize information logically\n4. **Actionable instructions**: Provide concrete steps\n5. **Examples**: Include practical examples when helpful\n\n## Best Practices\n\n- Keep skills focused on a single domain\n- Write descriptions that clearly indicate when to activate\n- Include reference materials in subdirectories for complex skills\n- Test that the skill activates for expected queries\n- Avoid overlap with other skills' trigger conditions"
              },
              {
                "name": "frontend-design",
                "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.",
                "path": "plugins/frontend-design/skills/frontend-design/SKILL.md",
                "frontmatter": {
                  "name": "frontend-design",
                  "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "This skill guides creation of distinctive, production-grade frontend interfaces that avoid generic \"AI slop\" aesthetics. Implement real working code with exceptional attention to aesthetic details and creative choices.\n\nThe user provides frontend requirements: a component, page, application, or interface to build. They may include context about the purpose, audience, or technical constraints.\n\n## Design Thinking\n\nBefore coding, understand the context and commit to a BOLD aesthetic direction:\n- **Purpose**: What problem does this interface solve? Who uses it?\n- **Tone**: Pick an extreme: brutally minimal, maximalist chaos, retro-futuristic, organic/natural, luxury/refined, playful/toy-like, editorial/magazine, brutalist/raw, art deco/geometric, soft/pastel, industrial/utilitarian, etc. There are so many flavors to choose from. Use these for inspiration but design one that is true to the aesthetic direction.\n- **Constraints**: Technical requirements (framework, performance, accessibility).\n- **Differentiation**: What makes this UNFORGETTABLE? What's the one thing someone will remember?\n\n**CRITICAL**: Choose a clear conceptual direction and execute it with precision. Bold maximalism and refined minimalism both work - the key is intentionality, not intensity.\n\nThen implement working code (HTML/CSS/JS, React, Vue, etc.) that is:\n- Production-grade and functional\n- Visually striking and memorable\n- Cohesive with a clear aesthetic point-of-view\n- Meticulously refined in every detail\n\n## Frontend Aesthetics Guidelines\n\nFocus on:\n- **Typography**: Choose fonts that are beautiful, unique, and interesting. Avoid generic fonts like Arial and Inter; opt instead for distinctive choices that elevate the frontend's aesthetics; unexpected, characterful font choices. Pair a distinctive display font with a refined body font.\n- **Color & Theme**: Commit to a cohesive aesthetic. Use CSS variables for consistency. Dominant colors with sharp accents outperform timid, evenly-distributed palettes.\n- **Motion**: Use animations for effects and micro-interactions. Prioritize CSS-only solutions for HTML. Use Motion library for React when available. Focus on high-impact moments: one well-orchestrated page load with staggered reveals (animation-delay) creates more delight than scattered micro-interactions. Use scroll-triggering and hover states that surprise.\n- **Spatial Composition**: Unexpected layouts. Asymmetry. Overlap. Diagonal flow. Grid-breaking elements. Generous negative space OR controlled density.\n- **Backgrounds & Visual Details**: Create atmosphere and depth rather than defaulting to solid colors. Add contextual effects and textures that match the overall aesthetic. Apply creative forms like gradient meshes, noise textures, geometric patterns, layered transparencies, dramatic shadows, decorative borders, custom cursors, and grain overlays.\n\nNEVER use generic AI-generated aesthetics like overused font families (Inter, Roboto, Arial, system fonts), cliched color schemes (particularly purple gradients on white backgrounds), predictable layouts and component patterns, and cookie-cutter design that lacks context-specific character.\n\nInterpret creatively and make unexpected choices that feel genuinely designed for the context. No design should be the same. Vary between light and dark themes, different fonts, different aesthetics. NEVER converge on common choices (Space Grotesk, for example) across generations.\n\n**IMPORTANT**: Match implementation complexity to the aesthetic vision. Maximalist designs need elaborate code with extensive animations and effects. Minimalist or refined designs need restraint, precision, and careful attention to spacing, typography, and subtle details. Elegance comes from executing the vision well.\n\nRemember: Claude is capable of extraordinary creative work. Don't hold back, show what can truly be created when thinking outside the box and committing fully to a distinctive vision."
              },
              {
                "name": "Writing Hookify Rules",
                "description": "This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"configure hookify\", \"add a hookify rule\", or needs guidance on hookify rule syntax and patterns.",
                "path": "plugins/hookify/skills/writing-rules/SKILL.md",
                "frontmatter": {
                  "name": "Writing Hookify Rules",
                  "description": "This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"configure hookify\", \"add a hookify rule\", or needs guidance on hookify rule syntax and patterns.",
                  "version": "0.1.0"
                },
                "content": "# Writing Hookify Rules\n\n## Overview\n\nHookify rules are markdown files with YAML frontmatter that define patterns to watch for and messages to show when those patterns match. Rules are stored in `.claude/hookify.{rule-name}.local.md` files.\n\n## Rule File Format\n\n### Basic Structure\n\n```markdown\n---\nname: rule-identifier\nenabled: true\nevent: bash|file|stop|prompt|all\npattern: regex-pattern-here\n---\n\nMessage to show Claude when this rule triggers.\nCan include markdown formatting, warnings, suggestions, etc.\n```\n\n### Frontmatter Fields\n\n**name** (required): Unique identifier for the rule\n- Use kebab-case: `warn-dangerous-rm`, `block-console-log`\n- Be descriptive and action-oriented\n- Start with verb: warn, prevent, block, require, check\n\n**enabled** (required): Boolean to activate/deactivate\n- `true`: Rule is active\n- `false`: Rule is disabled (won't trigger)\n- Can toggle without deleting rule\n\n**event** (required): Which hook event to trigger on\n- `bash`: Bash tool commands\n- `file`: Edit, Write, MultiEdit tools\n- `stop`: When agent wants to stop\n- `prompt`: When user submits a prompt\n- `all`: All events\n\n**action** (optional): What to do when rule matches\n- `warn`: Show message but allow operation (default)\n- `block`: Prevent operation (PreToolUse) or stop session (Stop events)\n- If omitted, defaults to `warn`\n\n**pattern** (simple format): Regex pattern to match\n- Used for simple single-condition rules\n- Matches against command (bash) or new_text (file)\n- Python regex syntax\n\n**Example:**\n```yaml\nevent: bash\npattern: rm\\s+-rf\n```\n\n### Advanced Format (Multiple Conditions)\n\nFor complex rules with multiple conditions:\n\n```markdown\n---\nname: warn-env-file-edits\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$\n  - field: new_text\n    operator: contains\n    pattern: API_KEY\n---\n\nYou're adding an API key to a .env file. Ensure this file is in .gitignore!\n```\n\n**Condition fields:**\n- `field`: Which field to check\n  - For bash: `command`\n  - For file: `file_path`, `new_text`, `old_text`, `content`\n- `operator`: How to match\n  - `regex_match`: Regex pattern matching\n  - `contains`: Substring check\n  - `equals`: Exact match\n  - `not_contains`: Substring must NOT be present\n  - `starts_with`: Prefix check\n  - `ends_with`: Suffix check\n- `pattern`: Pattern or string to match\n\n**All conditions must match for rule to trigger.**\n\n## Message Body\n\nThe markdown content after frontmatter is shown to Claude when the rule triggers.\n\n**Good messages:**\n- Explain what was detected\n- Explain why it's problematic\n- Suggest alternatives or best practices\n- Use formatting for clarity (bold, lists, etc.)\n\n**Example:**\n```markdown\nâš ï¸ **Console.log detected!**\n\nYou're adding console.log to production code.\n\n**Why this matters:**\n- Debug logs shouldn't ship to production\n- Console.log can expose sensitive data\n- Impacts browser performance\n\n**Alternatives:**\n- Use a proper logging library\n- Remove before committing\n- Use conditional debug builds\n```\n\n## Event Type Guide\n\n### bash Events\n\nMatch Bash command patterns:\n\n```markdown\n---\nevent: bash\npattern: sudo\\s+|rm\\s+-rf|chmod\\s+777\n---\n\nDangerous command detected!\n```\n\n**Common patterns:**\n- Dangerous commands: `rm\\s+-rf`, `dd\\s+if=`, `mkfs`\n- Privilege escalation: `sudo\\s+`, `su\\s+`\n- Permission issues: `chmod\\s+777`, `chown\\s+root`\n\n### file Events\n\nMatch Edit/Write/MultiEdit operations:\n\n```markdown\n---\nevent: file\npattern: console\\.log\\(|eval\\(|innerHTML\\s*=\n---\n\nPotentially problematic code pattern detected!\n```\n\n**Match on different fields:**\n```markdown\n---\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.tsx?$\n  - field: new_text\n    operator: regex_match\n    pattern: console\\.log\\(\n---\n\nConsole.log in TypeScript file!\n```\n\n**Common patterns:**\n- Debug code: `console\\.log\\(`, `debugger`, `print\\(`\n- Security risks: `eval\\(`, `innerHTML\\s*=`, `dangerouslySetInnerHTML`\n- Sensitive files: `\\.env$`, `credentials`, `\\.pem$`\n- Generated files: `node_modules/`, `dist/`, `build/`\n\n### stop Events\n\nMatch when agent wants to stop (completion checks):\n\n```markdown\n---\nevent: stop\npattern: .*\n---\n\nBefore stopping, verify:\n- [ ] Tests were run\n- [ ] Build succeeded\n- [ ] Documentation updated\n```\n\n**Use for:**\n- Reminders about required steps\n- Completion checklists\n- Process enforcement\n\n### prompt Events\n\nMatch user prompt content (advanced):\n\n```markdown\n---\nevent: prompt\nconditions:\n  - field: user_prompt\n    operator: contains\n    pattern: deploy to production\n---\n\nProduction deployment checklist:\n- [ ] Tests passing?\n- [ ] Reviewed by team?\n- [ ] Monitoring ready?\n```\n\n## Pattern Writing Tips\n\n### Regex Basics\n\n**Literal characters:** Most characters match themselves\n- `rm` matches \"rm\"\n- `console.log` matches \"console.log\"\n\n**Special characters need escaping:**\n- `.` (any char) â†’ `\\.` (literal dot)\n- `(` `)` â†’ `\\(` `\\)` (literal parens)\n- `[` `]` â†’ `\\[` `\\]` (literal brackets)\n\n**Common metacharacters:**\n- `\\s` - whitespace (space, tab, newline)\n- `\\d` - digit (0-9)\n- `\\w` - word character (a-z, A-Z, 0-9, _)\n- `.` - any character\n- `+` - one or more\n- `*` - zero or more\n- `?` - zero or one\n- `|` - OR\n\n**Examples:**\n```\nrm\\s+-rf         Matches: rm -rf, rm  -rf\nconsole\\.log\\(   Matches: console.log(\n(eval|exec)\\(    Matches: eval( or exec(\nchmod\\s+777      Matches: chmod 777, chmod  777\nAPI_KEY\\s*=      Matches: API_KEY=, API_KEY =\n```\n\n### Testing Patterns\n\nTest regex patterns before using:\n\n```bash\npython3 -c \"import re; print(re.search(r'your_pattern', 'test text'))\"\n```\n\nOr use online regex testers (regex101.com with Python flavor).\n\n### Common Pitfalls\n\n**Too broad:**\n```yaml\npattern: log    # Matches \"log\", \"login\", \"dialog\", \"catalog\"\n```\nBetter: `console\\.log\\(|logger\\.`\n\n**Too specific:**\n```yaml\npattern: rm -rf /tmp  # Only matches exact path\n```\nBetter: `rm\\s+-rf`\n\n**Escaping issues:**\n- YAML quoted strings: `\"pattern\"` requires double backslashes `\\\\s`\n- YAML unquoted: `pattern: \\s` works as-is\n- **Recommendation**: Use unquoted patterns in YAML\n\n## File Organization\n\n**Location:** All rules in `.claude/` directory\n**Naming:** `.claude/hookify.{descriptive-name}.local.md`\n**Gitignore:** Add `.claude/*.local.md` to `.gitignore`\n\n**Good names:**\n- `hookify.dangerous-rm.local.md`\n- `hookify.console-log.local.md`\n- `hookify.require-tests.local.md`\n- `hookify.sensitive-files.local.md`\n\n**Bad names:**\n- `hookify.rule1.local.md` (not descriptive)\n- `hookify.md` (missing .local)\n- `danger.local.md` (missing hookify prefix)\n\n## Workflow\n\n### Creating a Rule\n\n1. Identify unwanted behavior\n2. Determine which tool is involved (Bash, Edit, etc.)\n3. Choose event type (bash, file, stop, etc.)\n4. Write regex pattern\n5. Create `.claude/hookify.{name}.local.md` file in project root\n6. Test immediately - rules are read dynamically on next tool use\n\n### Refining a Rule\n\n1. Edit the `.local.md` file\n2. Adjust pattern or message\n3. Test immediately - changes take effect on next tool use\n\n### Disabling a Rule\n\n**Temporary:** Set `enabled: false` in frontmatter\n**Permanent:** Delete the `.local.md` file\n\n## Examples\n\nSee `${CLAUDE_PLUGIN_ROOT}/examples/` for complete examples:\n- `dangerous-rm.local.md` - Block dangerous rm commands\n- `console-log-warning.local.md` - Warn about console.log\n- `sensitive-files-warning.local.md` - Warn about editing .env files\n\n## Quick Reference\n\n**Minimum viable rule:**\n```markdown\n---\nname: my-rule\nenabled: true\nevent: bash\npattern: dangerous_command\n---\n\nWarning message here\n```\n\n**Rule with conditions:**\n```markdown\n---\nname: my-rule\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.ts$\n  - field: new_text\n    operator: contains\n    pattern: any\n---\n\nWarning message\n```\n\n**Event types:**\n- `bash` - Bash commands\n- `file` - File edits\n- `stop` - Completion checks\n- `prompt` - User input\n- `all` - All events\n\n**Field options:**\n- Bash: `command`\n- File: `file_path`, `new_text`, `old_text`, `content`\n- Prompt: `user_prompt`\n\n**Operators:**\n- `regex_match`, `contains`, `equals`, `not_contains`, `starts_with`, `ends_with`"
              },
              {
                "name": "Agent Development",
                "description": "This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins.",
                "path": "plugins/plugin-dev/skills/agent-development/SKILL.md",
                "frontmatter": {
                  "name": "Agent Development",
                  "description": "This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins.",
                  "version": "0.1.0"
                },
                "content": "# Agent Development for Claude Code Plugins\n\n## Overview\n\nAgents are autonomous subprocesses that handle complex, multi-step tasks independently. Understanding agent structure, triggering conditions, and system prompt design enables creating powerful autonomous capabilities.\n\n**Key concepts:**\n- Agents are FOR autonomous work, commands are FOR user-initiated actions\n- Markdown file format with YAML frontmatter\n- Triggering via description field with examples\n- System prompt defines agent behavior\n- Model and color customization\n\n## Agent File Structure\n\n### Complete Format\n\n```markdown\n---\nname: agent-identifier\ndescription: Use this agent when [triggering conditions]. Examples:\n\n<example>\nContext: [Situation description]\nuser: \"[User request]\"\nassistant: \"[How assistant should respond and use this agent]\"\n<commentary>\n[Why this agent should be triggered]\n</commentary>\n</example>\n\n<example>\n[Additional example...]\n</example>\n\nmodel: inherit\ncolor: blue\ntools: [\"Read\", \"Write\", \"Grep\"]\n---\n\nYou are [agent role description]...\n\n**Your Core Responsibilities:**\n1. [Responsibility 1]\n2. [Responsibility 2]\n\n**Analysis Process:**\n[Step-by-step workflow]\n\n**Output Format:**\n[What to return]\n```\n\n## Frontmatter Fields\n\n### name (required)\n\nAgent identifier used for namespacing and invocation.\n\n**Format:** lowercase, numbers, hyphens only\n**Length:** 3-50 characters\n**Pattern:** Must start and end with alphanumeric\n\n**Good examples:**\n- `code-reviewer`\n- `test-generator`\n- `api-docs-writer`\n- `security-analyzer`\n\n**Bad examples:**\n- `helper` (too generic)\n- `-agent-` (starts/ends with hyphen)\n- `my_agent` (underscores not allowed)\n- `ag` (too short, < 3 chars)\n\n### description (required)\n\nDefines when Claude should trigger this agent. **This is the most critical field.**\n\n**Must include:**\n1. Triggering conditions (\"Use this agent when...\")\n2. Multiple `<example>` blocks showing usage\n3. Context, user request, and assistant response in each example\n4. `<commentary>` explaining why agent triggers\n\n**Format:**\n```\nUse this agent when [conditions]. Examples:\n\n<example>\nContext: [Scenario description]\nuser: \"[What user says]\"\nassistant: \"[How Claude should respond]\"\n<commentary>\n[Why this agent is appropriate]\n</commentary>\n</example>\n\n[More examples...]\n```\n\n**Best practices:**\n- Include 2-4 concrete examples\n- Show proactive and reactive triggering\n- Cover different phrasings of same intent\n- Explain reasoning in commentary\n- Be specific about when NOT to use the agent\n\n### model (required)\n\nWhich model the agent should use.\n\n**Options:**\n- `inherit` - Use same model as parent (recommended)\n- `sonnet` - Claude Sonnet (balanced)\n- `opus` - Claude Opus (most capable, expensive)\n- `haiku` - Claude Haiku (fast, cheap)\n\n**Recommendation:** Use `inherit` unless agent needs specific model capabilities.\n\n### color (required)\n\nVisual identifier for agent in UI.\n\n**Options:** `blue`, `cyan`, `green`, `yellow`, `magenta`, `red`\n\n**Guidelines:**\n- Choose distinct colors for different agents in same plugin\n- Use consistent colors for similar agent types\n- Blue/cyan: Analysis, review\n- Green: Success-oriented tasks\n- Yellow: Caution, validation\n- Red: Critical, security\n- Magenta: Creative, generation\n\n### tools (optional)\n\nRestrict agent to specific tools.\n\n**Format:** Array of tool names\n\n```yaml\ntools: [\"Read\", \"Write\", \"Grep\", \"Bash\"]\n```\n\n**Default:** If omitted, agent has access to all tools\n\n**Best practice:** Limit tools to minimum needed (principle of least privilege)\n\n**Common tool sets:**\n- Read-only analysis: `[\"Read\", \"Grep\", \"Glob\"]`\n- Code generation: `[\"Read\", \"Write\", \"Grep\"]`\n- Testing: `[\"Read\", \"Bash\", \"Grep\"]`\n- Full access: Omit field or use `[\"*\"]`\n\n## System Prompt Design\n\nThe markdown body becomes the agent's system prompt. Write in second person, addressing the agent directly.\n\n### Structure\n\n**Standard template:**\n```markdown\nYou are [role] specializing in [domain].\n\n**Your Core Responsibilities:**\n1. [Primary responsibility]\n2. [Secondary responsibility]\n3. [Additional responsibilities...]\n\n**Analysis Process:**\n1. [Step one]\n2. [Step two]\n3. [Step three]\n[...]\n\n**Quality Standards:**\n- [Standard 1]\n- [Standard 2]\n\n**Output Format:**\nProvide results in this format:\n- [What to include]\n- [How to structure]\n\n**Edge Cases:**\nHandle these situations:\n- [Edge case 1]: [How to handle]\n- [Edge case 2]: [How to handle]\n```\n\n### Best Practices\n\nâœ… **DO:**\n- Write in second person (\"You are...\", \"You will...\")\n- Be specific about responsibilities\n- Provide step-by-step process\n- Define output format\n- Include quality standards\n- Address edge cases\n- Keep under 10,000 characters\n\nâŒ **DON'T:**\n- Write in first person (\"I am...\", \"I will...\")\n- Be vague or generic\n- Omit process steps\n- Leave output format undefined\n- Skip quality guidance\n- Ignore error cases\n\n## Creating Agents\n\n### Method 1: AI-Assisted Generation\n\nUse this prompt pattern (extracted from Claude Code):\n\n```\nCreate an agent configuration based on this request: \"[YOUR DESCRIPTION]\"\n\nRequirements:\n1. Extract core intent and responsibilities\n2. Design expert persona for the domain\n3. Create comprehensive system prompt with:\n   - Clear behavioral boundaries\n   - Specific methodologies\n   - Edge case handling\n   - Output format\n4. Create identifier (lowercase, hyphens, 3-50 chars)\n5. Write description with triggering conditions\n6. Include 2-3 <example> blocks showing when to use\n\nReturn JSON with:\n{\n  \"identifier\": \"agent-name\",\n  \"whenToUse\": \"Use this agent when... Examples: <example>...</example>\",\n  \"systemPrompt\": \"You are...\"\n}\n```\n\nThen convert to agent file format with frontmatter.\n\nSee `examples/agent-creation-prompt.md` for complete template.\n\n### Method 2: Manual Creation\n\n1. Choose agent identifier (3-50 chars, lowercase, hyphens)\n2. Write description with examples\n3. Select model (usually `inherit`)\n4. Choose color for visual identification\n5. Define tools (if restricting access)\n6. Write system prompt with structure above\n7. Save as `agents/agent-name.md`\n\n## Validation Rules\n\n### Identifier Validation\n\n```\nâœ… Valid: code-reviewer, test-gen, api-analyzer-v2\nâŒ Invalid: ag (too short), -start (starts with hyphen), my_agent (underscore)\n```\n\n**Rules:**\n- 3-50 characters\n- Lowercase letters, numbers, hyphens only\n- Must start and end with alphanumeric\n- No underscores, spaces, or special characters\n\n### Description Validation\n\n**Length:** 10-5,000 characters\n**Must include:** Triggering conditions and examples\n**Best:** 200-1,000 characters with 2-4 examples\n\n### System Prompt Validation\n\n**Length:** 20-10,000 characters\n**Best:** 500-3,000 characters\n**Structure:** Clear responsibilities, process, output format\n\n## Agent Organization\n\n### Plugin Agents Directory\n\n```\nplugin-name/\nâ””â”€â”€ agents/\n    â”œâ”€â”€ analyzer.md\n    â”œâ”€â”€ reviewer.md\n    â””â”€â”€ generator.md\n```\n\nAll `.md` files in `agents/` are auto-discovered.\n\n### Namespacing\n\nAgents are namespaced automatically:\n- Single plugin: `agent-name`\n- With subdirectories: `plugin:subdir:agent-name`\n\n## Testing Agents\n\n### Test Triggering\n\nCreate test scenarios to verify agent triggers correctly:\n\n1. Write agent with specific triggering examples\n2. Use similar phrasing to examples in test\n3. Check Claude loads the agent\n4. Verify agent provides expected functionality\n\n### Test System Prompt\n\nEnsure system prompt is complete:\n\n1. Give agent typical task\n2. Check it follows process steps\n3. Verify output format is correct\n4. Test edge cases mentioned in prompt\n5. Confirm quality standards are met\n\n## Quick Reference\n\n### Minimal Agent\n\n```markdown\n---\nname: simple-agent\ndescription: Use this agent when... Examples: <example>...</example>\nmodel: inherit\ncolor: blue\n---\n\nYou are an agent that [does X].\n\nProcess:\n1. [Step 1]\n2. [Step 2]\n\nOutput: [What to provide]\n```\n\n### Frontmatter Fields Summary\n\n| Field | Required | Format | Example |\n|-------|----------|--------|---------|\n| name | Yes | lowercase-hyphens | code-reviewer |\n| description | Yes | Text + examples | Use when... <example>... |\n| model | Yes | inherit/sonnet/opus/haiku | inherit |\n| color | Yes | Color name | blue |\n| tools | No | Array of tool names | [\"Read\", \"Grep\"] |\n\n### Best Practices\n\n**DO:**\n- âœ… Include 2-4 concrete examples in description\n- âœ… Write specific triggering conditions\n- âœ… Use `inherit` for model unless specific need\n- âœ… Choose appropriate tools (least privilege)\n- âœ… Write clear, structured system prompts\n- âœ… Test agent triggering thoroughly\n\n**DON'T:**\n- âŒ Use generic descriptions without examples\n- âŒ Omit triggering conditions\n- âŒ Give all agents same color\n- âŒ Grant unnecessary tool access\n- âŒ Write vague system prompts\n- âŒ Skip testing\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed guidance, consult:\n\n- **`references/system-prompt-design.md`** - Complete system prompt patterns\n- **`references/triggering-examples.md`** - Example formats and best practices\n- **`references/agent-creation-system-prompt.md`** - The exact prompt from Claude Code\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`agent-creation-prompt.md`** - AI-assisted agent generation template\n- **`complete-agent-examples.md`** - Full agent examples for different use cases\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-agent.sh`** - Validate agent file structure\n- **`test-agent-trigger.sh`** - Test if agent triggers correctly\n\n## Implementation Workflow\n\nTo create an agent for a plugin:\n\n1. Define agent purpose and triggering conditions\n2. Choose creation method (AI-assisted or manual)\n3. Create `agents/agent-name.md` file\n4. Write frontmatter with all required fields\n5. Write system prompt following best practices\n6. Include 2-4 triggering examples in description\n7. Validate with `scripts/validate-agent.sh`\n8. Test triggering with real scenarios\n9. Document agent in plugin README\n\nFocus on clear triggering conditions and comprehensive system prompts for autonomous operation."
              },
              {
                "name": "Command Development",
                "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
                "path": "plugins/plugin-dev/skills/command-development/SKILL.md",
                "frontmatter": {
                  "name": "Command Development",
                  "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
                  "version": "0.2.0"
                },
                "content": "# Command Development for Claude Code\n\n## Overview\n\nSlash commands are frequently-used prompts defined as Markdown files that Claude executes during interactive sessions. Understanding command structure, frontmatter options, and dynamic features enables creating powerful, reusable workflows.\n\n**Key concepts:**\n- Markdown file format for commands\n- YAML frontmatter for configuration\n- Dynamic arguments and file references\n- Bash execution for context\n- Command organization and namespacing\n\n## Command Basics\n\n### What is a Slash Command?\n\nA slash command is a Markdown file containing a prompt that Claude executes when invoked. Commands provide:\n- **Reusability**: Define once, use repeatedly\n- **Consistency**: Standardize common workflows\n- **Sharing**: Distribute across team or projects\n- **Efficiency**: Quick access to complex prompts\n\n### Critical: Commands are Instructions FOR Claude\n\n**Commands are written for agent consumption, not human consumption.**\n\nWhen a user invokes `/command-name`, the command content becomes Claude's instructions. Write commands as directives TO Claude about what to do, not as messages TO the user.\n\n**Correct approach (instructions for Claude):**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication issues\n\nProvide specific line numbers and severity ratings.\n```\n\n**Incorrect approach (messages to user):**\n```markdown\nThis command will review your code for security issues.\nYou'll receive a report with vulnerability details.\n```\n\nThe first example tells Claude what to do. The second tells the user what will happen but doesn't instruct Claude. Always use the first approach.\n\n### Command Locations\n\n**Project commands** (shared with team):\n- Location: `.claude/commands/`\n- Scope: Available in specific project\n- Label: Shown as \"(project)\" in `/help`\n- Use for: Team workflows, project-specific tasks\n\n**Personal commands** (available everywhere):\n- Location: `~/.claude/commands/`\n- Scope: Available in all projects\n- Label: Shown as \"(user)\" in `/help`\n- Use for: Personal workflows, cross-project utilities\n\n**Plugin commands** (bundled with plugins):\n- Location: `plugin-name/commands/`\n- Scope: Available when plugin installed\n- Label: Shown as \"(plugin-name)\" in `/help`\n- Use for: Plugin-specific functionality\n\n## File Format\n\n### Basic Structure\n\nCommands are Markdown files with `.md` extension:\n\n```\n.claude/commands/\nâ”œâ”€â”€ review.md           # /review command\nâ”œâ”€â”€ test.md             # /test command\nâ””â”€â”€ deploy.md           # /deploy command\n```\n\n**Simple command:**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication bypass\n- Insecure data handling\n```\n\nNo frontmatter needed for basic commands.\n\n### With YAML Frontmatter\n\nAdd configuration using YAML frontmatter:\n\n```markdown\n---\ndescription: Review code for security issues\nallowed-tools: Read, Grep, Bash(git:*)\nmodel: sonnet\n---\n\nReview this code for security vulnerabilities...\n```\n\n## YAML Frontmatter Fields\n\n### description\n\n**Purpose:** Brief description shown in `/help`\n**Type:** String\n**Default:** First line of command prompt\n\n```yaml\n---\ndescription: Review pull request for code quality\n---\n```\n\n**Best practice:** Clear, actionable description (under 60 characters)\n\n### allowed-tools\n\n**Purpose:** Specify which tools command can use\n**Type:** String or Array\n**Default:** Inherits from conversation\n\n```yaml\n---\nallowed-tools: Read, Write, Edit, Bash(git:*)\n---\n```\n\n**Patterns:**\n- `Read, Write, Edit` - Specific tools\n- `Bash(git:*)` - Bash with git commands only\n- `*` - All tools (rarely needed)\n\n**Use when:** Command requires specific tool access\n\n### model\n\n**Purpose:** Specify model for command execution\n**Type:** String (sonnet, opus, haiku)\n**Default:** Inherits from conversation\n\n```yaml\n---\nmodel: haiku\n---\n```\n\n**Use cases:**\n- `haiku` - Fast, simple commands\n- `sonnet` - Standard workflows\n- `opus` - Complex analysis\n\n### argument-hint\n\n**Purpose:** Document expected arguments for autocomplete\n**Type:** String\n**Default:** None\n\n```yaml\n---\nargument-hint: [pr-number] [priority] [assignee]\n---\n```\n\n**Benefits:**\n- Helps users understand command arguments\n- Improves command discovery\n- Documents command interface\n\n### disable-model-invocation\n\n**Purpose:** Prevent SlashCommand tool from programmatically calling command\n**Type:** Boolean\n**Default:** false\n\n```yaml\n---\ndisable-model-invocation: true\n---\n```\n\n**Use when:** Command should only be manually invoked\n\n## Dynamic Arguments\n\n### Using $ARGUMENTS\n\nCapture all arguments as single string:\n\n```markdown\n---\ndescription: Fix issue by number\nargument-hint: [issue-number]\n---\n\nFix issue #$ARGUMENTS following our coding standards and best practices.\n```\n\n**Usage:**\n```\n> /fix-issue 123\n> /fix-issue 456\n```\n\n**Expands to:**\n```\nFix issue #123 following our coding standards...\nFix issue #456 following our coding standards...\n```\n\n### Using Positional Arguments\n\nCapture individual arguments with `$1`, `$2`, `$3`, etc.:\n\n```markdown\n---\ndescription: Review PR with priority and assignee\nargument-hint: [pr-number] [priority] [assignee]\n---\n\nReview pull request #$1 with priority level $2.\nAfter review, assign to $3 for follow-up.\n```\n\n**Usage:**\n```\n> /review-pr 123 high alice\n```\n\n**Expands to:**\n```\nReview pull request #123 with priority level high.\nAfter review, assign to alice for follow-up.\n```\n\n### Combining Arguments\n\nMix positional and remaining arguments:\n\n```markdown\nDeploy $1 to $2 environment with options: $3\n```\n\n**Usage:**\n```\n> /deploy api staging --force --skip-tests\n```\n\n**Expands to:**\n```\nDeploy api to staging environment with options: --force --skip-tests\n```\n\n## File References\n\n### Using @ Syntax\n\nInclude file contents in command:\n\n```markdown\n---\ndescription: Review specific file\nargument-hint: [file-path]\n---\n\nReview @$1 for:\n- Code quality\n- Best practices\n- Potential bugs\n```\n\n**Usage:**\n```\n> /review-file src/api/users.ts\n```\n\n**Effect:** Claude reads `src/api/users.ts` before processing command\n\n### Multiple File References\n\nReference multiple files:\n\n```markdown\nCompare @src/old-version.js with @src/new-version.js\n\nIdentify:\n- Breaking changes\n- New features\n- Bug fixes\n```\n\n### Static File References\n\nReference known files without arguments:\n\n```markdown\nReview @package.json and @tsconfig.json for consistency\n\nEnsure:\n- TypeScript version matches\n- Dependencies are aligned\n- Build configuration is correct\n```\n\n## Bash Execution in Commands\n\nCommands can execute bash commands inline to dynamically gather context before Claude processes the command. This is useful for including repository state, environment information, or project-specific context.\n\n**When to use:**\n- Include dynamic context (git status, environment vars, etc.)\n- Gather project/repository state\n- Build context-aware workflows\n\n**Implementation details:**\nFor complete syntax, examples, and best practices, see `references/plugin-features-reference.md` section on bash execution. The reference includes the exact syntax and multiple working examples to avoid execution issues\n\n## Command Organization\n\n### Flat Structure\n\nSimple organization for small command sets:\n\n```\n.claude/commands/\nâ”œâ”€â”€ build.md\nâ”œâ”€â”€ test.md\nâ”œâ”€â”€ deploy.md\nâ”œâ”€â”€ review.md\nâ””â”€â”€ docs.md\n```\n\n**Use when:** 5-15 commands, no clear categories\n\n### Namespaced Structure\n\nOrganize commands in subdirectories:\n\n```\n.claude/commands/\nâ”œâ”€â”€ ci/\nâ”‚   â”œâ”€â”€ build.md        # /build (project:ci)\nâ”‚   â”œâ”€â”€ test.md         # /test (project:ci)\nâ”‚   â””â”€â”€ lint.md         # /lint (project:ci)\nâ”œâ”€â”€ git/\nâ”‚   â”œâ”€â”€ commit.md       # /commit (project:git)\nâ”‚   â””â”€â”€ pr.md           # /pr (project:git)\nâ””â”€â”€ docs/\n    â”œâ”€â”€ generate.md     # /generate (project:docs)\n    â””â”€â”€ publish.md      # /publish (project:docs)\n```\n\n**Benefits:**\n- Logical grouping by category\n- Namespace shown in `/help`\n- Easier to find related commands\n\n**Use when:** 15+ commands, clear categories\n\n## Best Practices\n\n### Command Design\n\n1. **Single responsibility:** One command, one task\n2. **Clear descriptions:** Self-explanatory in `/help`\n3. **Explicit dependencies:** Use `allowed-tools` when needed\n4. **Document arguments:** Always provide `argument-hint`\n5. **Consistent naming:** Use verb-noun pattern (review-pr, fix-issue)\n\n### Argument Handling\n\n1. **Validate arguments:** Check for required arguments in prompt\n2. **Provide defaults:** Suggest defaults when arguments missing\n3. **Document format:** Explain expected argument format\n4. **Handle edge cases:** Consider missing or invalid arguments\n\n```markdown\n---\nargument-hint: [pr-number]\n---\n\n$IF($1,\n  Review PR #$1,\n  Please provide a PR number. Usage: /review-pr [number]\n)\n```\n\n### File References\n\n1. **Explicit paths:** Use clear file paths\n2. **Check existence:** Handle missing files gracefully\n3. **Relative paths:** Use project-relative paths\n4. **Glob support:** Consider using Glob tool for patterns\n\n### Bash Commands\n\n1. **Limit scope:** Use `Bash(git:*)` not `Bash(*)`\n2. **Safe commands:** Avoid destructive operations\n3. **Handle errors:** Consider command failures\n4. **Keep fast:** Long-running commands slow invocation\n\n### Documentation\n\n1. **Add comments:** Explain complex logic\n2. **Provide examples:** Show usage in comments\n3. **List requirements:** Document dependencies\n4. **Version commands:** Note breaking changes\n\n```markdown\n---\ndescription: Deploy application to environment\nargument-hint: [environment] [version]\n---\n\n<!--\nUsage: /deploy [staging|production] [version]\nRequires: AWS credentials configured\nExample: /deploy staging v1.2.3\n-->\n\nDeploy application to $1 environment using version $2...\n```\n\n## Common Patterns\n\n### Review Pattern\n\n```markdown\n---\ndescription: Review code changes\nallowed-tools: Read, Bash(git:*)\n---\n\nFiles changed: !`git diff --name-only`\n\nReview each file for:\n1. Code quality and style\n2. Potential bugs or issues\n3. Test coverage\n4. Documentation needs\n\nProvide specific feedback for each file.\n```\n\n### Testing Pattern\n\n```markdown\n---\ndescription: Run tests for specific file\nargument-hint: [test-file]\nallowed-tools: Bash(npm:*)\n---\n\nRun tests: !`npm test $1`\n\nAnalyze results and suggest fixes for failures.\n```\n\n### Documentation Pattern\n\n```markdown\n---\ndescription: Generate documentation for file\nargument-hint: [source-file]\n---\n\nGenerate comprehensive documentation for @$1 including:\n- Function/class descriptions\n- Parameter documentation\n- Return value descriptions\n- Usage examples\n- Edge cases and errors\n```\n\n### Workflow Pattern\n\n```markdown\n---\ndescription: Complete PR workflow\nargument-hint: [pr-number]\nallowed-tools: Bash(gh:*), Read\n---\n\nPR #$1 Workflow:\n\n1. Fetch PR: !`gh pr view $1`\n2. Review changes\n3. Run checks\n4. Approve or request changes\n```\n\n## Troubleshooting\n\n**Command not appearing:**\n- Check file is in correct directory\n- Verify `.md` extension present\n- Ensure valid Markdown format\n- Restart Claude Code\n\n**Arguments not working:**\n- Verify `$1`, `$2` syntax correct\n- Check `argument-hint` matches usage\n- Ensure no extra spaces\n\n**Bash execution failing:**\n- Check `allowed-tools` includes Bash\n- Verify command syntax in backticks\n- Test command in terminal first\n- Check for required permissions\n\n**File references not working:**\n- Verify `@` syntax correct\n- Check file path is valid\n- Ensure Read tool allowed\n- Use absolute or project-relative paths\n\n## Plugin-Specific Features\n\n### CLAUDE_PLUGIN_ROOT Variable\n\nPlugin commands have access to `${CLAUDE_PLUGIN_ROOT}`, an environment variable that resolves to the plugin's absolute path.\n\n**Purpose:**\n- Reference plugin files portably\n- Execute plugin scripts\n- Load plugin configuration\n- Access plugin templates\n\n**Basic usage:**\n\n```markdown\n---\ndescription: Analyze using plugin script\nallowed-tools: Bash(node:*)\n---\n\nRun analysis: !`node ${CLAUDE_PLUGIN_ROOT}/scripts/analyze.js $1`\n\nReview results and report findings.\n```\n\n**Common patterns:**\n\n```markdown\n# Execute plugin script\n!`bash ${CLAUDE_PLUGIN_ROOT}/scripts/script.sh`\n\n# Load plugin configuration\n@${CLAUDE_PLUGIN_ROOT}/config/settings.json\n\n# Use plugin template\n@${CLAUDE_PLUGIN_ROOT}/templates/report.md\n\n# Access plugin resources\n@${CLAUDE_PLUGIN_ROOT}/docs/reference.md\n```\n\n**Why use it:**\n- Works across all installations\n- Portable between systems\n- No hardcoded paths needed\n- Essential for multi-file plugins\n\n### Plugin Command Organization\n\nPlugin commands discovered automatically from `commands/` directory:\n\n```\nplugin-name/\nâ”œâ”€â”€ commands/\nâ”‚   â”œâ”€â”€ foo.md              # /foo (plugin:plugin-name)\nâ”‚   â”œâ”€â”€ bar.md              # /bar (plugin:plugin-name)\nâ”‚   â””â”€â”€ utils/\nâ”‚       â””â”€â”€ helper.md       # /helper (plugin:plugin-name:utils)\nâ””â”€â”€ plugin.json\n```\n\n**Namespace benefits:**\n- Logical command grouping\n- Shown in `/help` output\n- Avoid name conflicts\n- Organize related commands\n\n**Naming conventions:**\n- Use descriptive action names\n- Avoid generic names (test, run)\n- Consider plugin-specific prefix\n- Use hyphens for multi-word names\n\n### Plugin Command Patterns\n\n**Configuration-based pattern:**\n\n```markdown\n---\ndescription: Deploy using plugin configuration\nargument-hint: [environment]\nallowed-tools: Read, Bash(*)\n---\n\nLoad configuration: @${CLAUDE_PLUGIN_ROOT}/config/$1-deploy.json\n\nDeploy to $1 using configuration settings.\nMonitor deployment and report status.\n```\n\n**Template-based pattern:**\n\n```markdown\n---\ndescription: Generate docs from template\nargument-hint: [component]\n---\n\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/docs.md\n\nGenerate documentation for $1 following template structure.\n```\n\n**Multi-script pattern:**\n\n```markdown\n---\ndescription: Complete build workflow\nallowed-tools: Bash(*)\n---\n\nBuild: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh`\nTest: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/test.sh`\nPackage: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/package.sh`\n\nReview outputs and report workflow status.\n```\n\n**See `references/plugin-features-reference.md` for detailed patterns.**\n\n## Integration with Plugin Components\n\nCommands can integrate with other plugin components for powerful workflows.\n\n### Agent Integration\n\nLaunch plugin agents for complex tasks:\n\n```markdown\n---\ndescription: Deep code review\nargument-hint: [file-path]\n---\n\nInitiate comprehensive review of @$1 using the code-reviewer agent.\n\nThe agent will analyze:\n- Code structure\n- Security issues\n- Performance\n- Best practices\n\nAgent uses plugin resources:\n- ${CLAUDE_PLUGIN_ROOT}/config/rules.json\n- ${CLAUDE_PLUGIN_ROOT}/checklists/review.md\n```\n\n**Key points:**\n- Agent must exist in `plugin/agents/` directory\n- Claude uses Task tool to launch agent\n- Document agent capabilities\n- Reference plugin resources agent uses\n\n### Skill Integration\n\nLeverage plugin skills for specialized knowledge:\n\n```markdown\n---\ndescription: Document API with standards\nargument-hint: [api-file]\n---\n\nDocument API in @$1 following plugin standards.\n\nUse the api-docs-standards skill to ensure:\n- Complete endpoint documentation\n- Consistent formatting\n- Example quality\n- Error documentation\n\nGenerate production-ready API docs.\n```\n\n**Key points:**\n- Skill must exist in `plugin/skills/` directory\n- Mention skill name to trigger invocation\n- Document skill purpose\n- Explain what skill provides\n\n### Hook Coordination\n\nDesign commands that work with plugin hooks:\n- Commands can prepare state for hooks to process\n- Hooks execute automatically on tool events\n- Commands should document expected hook behavior\n- Guide Claude on interpreting hook output\n\nSee `references/plugin-features-reference.md` for examples of commands that coordinate with hooks\n\n### Multi-Component Workflows\n\nCombine agents, skills, and scripts:\n\n```markdown\n---\ndescription: Comprehensive review workflow\nargument-hint: [file]\nallowed-tools: Bash(node:*), Read\n---\n\nTarget: @$1\n\nPhase 1 - Static Analysis:\n!`node ${CLAUDE_PLUGIN_ROOT}/scripts/lint.js $1`\n\nPhase 2 - Deep Review:\nLaunch code-reviewer agent for detailed analysis.\n\nPhase 3 - Standards Check:\nUse coding-standards skill for validation.\n\nPhase 4 - Report:\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/review.md\n\nCompile findings into report following template.\n```\n\n**When to use:**\n- Complex multi-step workflows\n- Leverage multiple plugin capabilities\n- Require specialized analysis\n- Need structured outputs\n\n## Validation Patterns\n\nCommands should validate inputs and resources before processing.\n\n### Argument Validation\n\n```markdown\n---\ndescription: Deploy with validation\nargument-hint: [environment]\n---\n\nValidate environment: !`echo \"$1\" | grep -E \"^(dev|staging|prod)$\" || echo \"INVALID\"`\n\nIf $1 is valid environment:\n  Deploy to $1\nOtherwise:\n  Explain valid environments: dev, staging, prod\n  Show usage: /deploy [environment]\n```\n\n### File Existence Checks\n\n```markdown\n---\ndescription: Process configuration\nargument-hint: [config-file]\n---\n\nCheck file exists: !`test -f $1 && echo \"EXISTS\" || echo \"MISSING\"`\n\nIf file exists:\n  Process configuration: @$1\nOtherwise:\n  Explain where to place config file\n  Show expected format\n  Provide example configuration\n```\n\n### Plugin Resource Validation\n\n```markdown\n---\ndescription: Run plugin analyzer\nallowed-tools: Bash(test:*)\n---\n\nValidate plugin setup:\n- Script: !`test -x ${CLAUDE_PLUGIN_ROOT}/bin/analyze && echo \"âœ“\" || echo \"âœ—\"`\n- Config: !`test -f ${CLAUDE_PLUGIN_ROOT}/config.json && echo \"âœ“\" || echo \"âœ—\"`\n\nIf all checks pass, run analysis.\nOtherwise, report missing components.\n```\n\n### Error Handling\n\n```markdown\n---\ndescription: Build with error handling\nallowed-tools: Bash(*)\n---\n\nExecute build: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh 2>&1 || echo \"BUILD_FAILED\"`\n\nIf build succeeded:\n  Report success and output location\nIf build failed:\n  Analyze error output\n  Suggest likely causes\n  Provide troubleshooting steps\n```\n\n**Best practices:**\n- Validate early in command\n- Provide helpful error messages\n- Suggest corrective actions\n- Handle edge cases gracefully\n\n---\n\nFor detailed frontmatter field specifications, see `references/frontmatter-reference.md`.\nFor plugin-specific features and patterns, see `references/plugin-features-reference.md`.\nFor command pattern examples, see `examples/` directory."
              },
              {
                "name": "Hook Development",
                "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
                "path": "plugins/plugin-dev/skills/hook-development/SKILL.md",
                "frontmatter": {
                  "name": "Hook Development",
                  "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
                  "version": "0.1.0"
                },
                "content": "# Hook Development for Claude Code Plugins\n\n## Overview\n\nHooks are event-driven automation scripts that execute in response to Claude Code events. Use hooks to validate operations, enforce policies, add context, and integrate external tools into workflows.\n\n**Key capabilities:**\n- Validate tool calls before execution (PreToolUse)\n- React to tool results (PostToolUse)\n- Enforce completion standards (Stop, SubagentStop)\n- Load project context (SessionStart)\n- Automate workflows across the development lifecycle\n\n## Hook Types\n\n### Prompt-Based Hooks (Recommended)\n\nUse LLM-driven decision making for context-aware validation:\n\n```json\n{\n  \"type\": \"prompt\",\n  \"prompt\": \"Evaluate if this tool use is appropriate: $TOOL_INPUT\",\n  \"timeout\": 30\n}\n```\n\n**Supported events:** Stop, SubagentStop, UserPromptSubmit, PreToolUse\n\n**Benefits:**\n- Context-aware decisions based on natural language reasoning\n- Flexible evaluation logic without bash scripting\n- Better edge case handling\n- Easier to maintain and extend\n\n### Command Hooks\n\nExecute bash commands for deterministic checks:\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\",\n  \"timeout\": 60\n}\n```\n\n**Use for:**\n- Fast deterministic validations\n- File system operations\n- External tool integrations\n- Performance-critical checks\n\n## Hook Configuration Formats\n\n### Plugin hooks.json Format\n\n**For plugin hooks** in `hooks/hooks.json`, use wrapper format:\n\n```json\n{\n  \"description\": \"Brief explanation of hooks (optional)\",\n  \"hooks\": {\n    \"PreToolUse\": [...],\n    \"Stop\": [...],\n    \"SessionStart\": [...]\n  }\n}\n```\n\n**Key points:**\n- `description` field is optional\n- `hooks` field is required wrapper containing actual hook events\n- This is the **plugin-specific format**\n\n**Example:**\n```json\n{\n  \"description\": \"Validation hooks for code quality\",\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Write\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/validate.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n### Settings Format (Direct)\n\n**For user settings** in `.claude/settings.json`, use direct format:\n\n```json\n{\n  \"PreToolUse\": [...],\n  \"Stop\": [...],\n  \"SessionStart\": [...]\n}\n```\n\n**Key points:**\n- No wrapper - events directly at top level\n- No description field\n- This is the **settings format**\n\n**Important:** The examples below show the hook event structure that goes inside either format. For plugin hooks.json, wrap these in `{\"hooks\": {...}}`.\n\n## Hook Events\n\n### PreToolUse\n\nExecute before any tool runs. Use to approve, deny, or modify tool calls.\n\n**Example (prompt-based):**\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety. Check: system paths, credentials, path traversal, sensitive content. Return 'approve' or 'deny'.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output for PreToolUse:**\n```json\n{\n  \"hookSpecificOutput\": {\n    \"permissionDecision\": \"allow|deny|ask\",\n    \"updatedInput\": {\"field\": \"modified_value\"}\n  },\n  \"systemMessage\": \"Explanation for Claude\"\n}\n```\n\n### PostToolUse\n\nExecute after tool completes. Use to react to results, provide feedback, or log.\n\n**Example:**\n```json\n{\n  \"PostToolUse\": [\n    {\n      \"matcher\": \"Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Analyze edit result for potential issues: syntax errors, security vulnerabilities, breaking changes. Provide feedback.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output behavior:**\n- Exit 0: stdout shown in transcript\n- Exit 2: stderr fed back to Claude\n- systemMessage included in context\n\n### Stop\n\nExecute when main agent considers stopping. Use to validate completeness.\n\n**Example:**\n```json\n{\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion: tests run, build succeeded, questions answered. Return 'approve' to stop or 'block' with reason to continue.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Decision output:**\n```json\n{\n  \"decision\": \"approve|block\",\n  \"reason\": \"Explanation\",\n  \"systemMessage\": \"Additional context\"\n}\n```\n\n### SubagentStop\n\nExecute when subagent considers stopping. Use to ensure subagent completed its task.\n\nSimilar to Stop hook, but for subagents.\n\n### UserPromptSubmit\n\nExecute when user submits a prompt. Use to add context, validate, or block prompts.\n\n**Example:**\n```json\n{\n  \"UserPromptSubmit\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Check if prompt requires security guidance. If discussing auth, permissions, or API security, return relevant warnings.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### SessionStart\n\nExecute when Claude Code session begins. Use to load context and set environment.\n\n**Example:**\n```json\n{\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Special capability:** Persist environment variables using `$CLAUDE_ENV_FILE`:\n```bash\necho \"export PROJECT_TYPE=nodejs\" >> \"$CLAUDE_ENV_FILE\"\n```\n\nSee `examples/load-context.sh` for complete example.\n\n### SessionEnd\n\nExecute when session ends. Use for cleanup, logging, and state preservation.\n\n### PreCompact\n\nExecute before context compaction. Use to add critical information to preserve.\n\n### Notification\n\nExecute when Claude sends notifications. Use to react to user notifications.\n\n## Hook Output Format\n\n### Standard Output (All Hooks)\n\n```json\n{\n  \"continue\": true,\n  \"suppressOutput\": false,\n  \"systemMessage\": \"Message for Claude\"\n}\n```\n\n- `continue`: If false, halt processing (default true)\n- `suppressOutput`: Hide output from transcript (default false)\n- `systemMessage`: Message shown to Claude\n\n### Exit Codes\n\n- `0` - Success (stdout shown in transcript)\n- `2` - Blocking error (stderr fed back to Claude)\n- Other - Non-blocking error\n\n## Hook Input Format\n\nAll hooks receive JSON via stdin with common fields:\n\n```json\n{\n  \"session_id\": \"abc123\",\n  \"transcript_path\": \"/path/to/transcript.txt\",\n  \"cwd\": \"/current/working/dir\",\n  \"permission_mode\": \"ask|allow\",\n  \"hook_event_name\": \"PreToolUse\"\n}\n```\n\n**Event-specific fields:**\n\n- **PreToolUse/PostToolUse:** `tool_name`, `tool_input`, `tool_result`\n- **UserPromptSubmit:** `user_prompt`\n- **Stop/SubagentStop:** `reason`\n\nAccess fields in prompts using `$TOOL_INPUT`, `$TOOL_RESULT`, `$USER_PROMPT`, etc.\n\n## Environment Variables\n\nAvailable in all command hooks:\n\n- `$CLAUDE_PROJECT_DIR` - Project root path\n- `$CLAUDE_PLUGIN_ROOT` - Plugin directory (use for portable paths)\n- `$CLAUDE_ENV_FILE` - SessionStart only: persist env vars here\n- `$CLAUDE_CODE_REMOTE` - Set if running in remote context\n\n**Always use ${CLAUDE_PLUGIN_ROOT} in hook commands for portability:**\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\"\n}\n```\n\n## Plugin Hook Configuration\n\nIn plugins, define hooks in `hooks/hooks.json`:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety\"\n        }\n      ]\n    }\n  ],\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion\"\n        }\n      ]\n    }\n  ],\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\",\n          \"timeout\": 10\n        }\n      ]\n    }\n  ]\n}\n```\n\nPlugin hooks merge with user's hooks and run in parallel.\n\n## Matchers\n\n### Tool Name Matching\n\n**Exact match:**\n```json\n\"matcher\": \"Write\"\n```\n\n**Multiple tools:**\n```json\n\"matcher\": \"Read|Write|Edit\"\n```\n\n**Wildcard (all tools):**\n```json\n\"matcher\": \"*\"\n```\n\n**Regex patterns:**\n```json\n\"matcher\": \"mcp__.*__delete.*\"  // All MCP delete tools\n```\n\n**Note:** Matchers are case-sensitive.\n\n### Common Patterns\n\n```json\n// All MCP tools\n\"matcher\": \"mcp__.*\"\n\n// Specific plugin's MCP tools\n\"matcher\": \"mcp__plugin_asana_.*\"\n\n// All file operations\n\"matcher\": \"Read|Write|Edit\"\n\n// Bash commands only\n\"matcher\": \"Bash\"\n```\n\n## Security Best Practices\n\n### Input Validation\n\nAlways validate inputs in command hooks:\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\ninput=$(cat)\ntool_name=$(echo \"$input\" | jq -r '.tool_name')\n\n# Validate tool name format\nif [[ ! \"$tool_name\" =~ ^[a-zA-Z0-9_]+$ ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Invalid tool name\"}' >&2\n  exit 2\nfi\n```\n\n### Path Safety\n\nCheck for path traversal and sensitive files:\n\n```bash\nfile_path=$(echo \"$input\" | jq -r '.tool_input.file_path')\n\n# Deny path traversal\nif [[ \"$file_path\" == *\"..\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Path traversal detected\"}' >&2\n  exit 2\nfi\n\n# Deny sensitive files\nif [[ \"$file_path\" == *\".env\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Sensitive file\"}' >&2\n  exit 2\nfi\n```\n\nSee `examples/validate-write.sh` and `examples/validate-bash.sh` for complete examples.\n\n### Quote All Variables\n\n```bash\n# GOOD: Quoted\necho \"$file_path\"\ncd \"$CLAUDE_PROJECT_DIR\"\n\n# BAD: Unquoted (injection risk)\necho $file_path\ncd $CLAUDE_PROJECT_DIR\n```\n\n### Set Appropriate Timeouts\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash script.sh\",\n  \"timeout\": 10\n}\n```\n\n**Defaults:** Command hooks (60s), Prompt hooks (30s)\n\n## Performance Considerations\n\n### Parallel Execution\n\nAll matching hooks run **in parallel**:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write\",\n      \"hooks\": [\n        {\"type\": \"command\", \"command\": \"check1.sh\"},  // Parallel\n        {\"type\": \"command\", \"command\": \"check2.sh\"},  // Parallel\n        {\"type\": \"prompt\", \"prompt\": \"Validate...\"}   // Parallel\n      ]\n    }\n  ]\n}\n```\n\n**Design implications:**\n- Hooks don't see each other's output\n- Non-deterministic ordering\n- Design for independence\n\n### Optimization\n\n1. Use command hooks for quick deterministic checks\n2. Use prompt hooks for complex reasoning\n3. Cache validation results in temp files\n4. Minimize I/O in hot paths\n\n## Temporarily Active Hooks\n\nCreate hooks that activate conditionally by checking for a flag file or configuration:\n\n**Pattern: Flag file activation**\n```bash\n#!/bin/bash\n# Only active when flag file exists\nFLAG_FILE=\"$CLAUDE_PROJECT_DIR/.enable-strict-validation\"\n\nif [ ! -f \"$FLAG_FILE\" ]; then\n  # Flag not present, skip validation\n  exit 0\nfi\n\n# Flag present, run validation\ninput=$(cat)\n# ... validation logic ...\n```\n\n**Pattern: Configuration-based activation**\n```bash\n#!/bin/bash\n# Check configuration for activation\nCONFIG_FILE=\"$CLAUDE_PROJECT_DIR/.claude/plugin-config.json\"\n\nif [ -f \"$CONFIG_FILE\" ]; then\n  enabled=$(jq -r '.strictMode // false' \"$CONFIG_FILE\")\n  if [ \"$enabled\" != \"true\" ]; then\n    exit 0  # Not enabled, skip\n  fi\nfi\n\n# Enabled, run hook logic\ninput=$(cat)\n# ... hook logic ...\n```\n\n**Use cases:**\n- Enable strict validation only when needed\n- Temporary debugging hooks\n- Project-specific hook behavior\n- Feature flags for hooks\n\n**Best practice:** Document activation mechanism in plugin README so users know how to enable/disable temporary hooks.\n\n## Hook Lifecycle and Limitations\n\n### Hooks Load at Session Start\n\n**Important:** Hooks are loaded when Claude Code session starts. Changes to hook configuration require restarting Claude Code.\n\n**Cannot hot-swap hooks:**\n- Editing `hooks/hooks.json` won't affect current session\n- Adding new hook scripts won't be recognized\n- Changing hook commands/prompts won't update\n- Must restart Claude Code: exit and run `claude` again\n\n**To test hook changes:**\n1. Edit hook configuration or scripts\n2. Exit Claude Code session\n3. Restart: `claude` or `cc`\n4. New hook configuration loads\n5. Test hooks with `claude --debug`\n\n### Hook Validation at Startup\n\nHooks are validated when Claude Code starts:\n- Invalid JSON in hooks.json causes loading failure\n- Missing scripts cause warnings\n- Syntax errors reported in debug mode\n\nUse `/hooks` command to review loaded hooks in current session.\n\n## Debugging Hooks\n\n### Enable Debug Mode\n\n```bash\nclaude --debug\n```\n\nLook for hook registration, execution logs, input/output JSON, and timing information.\n\n### Test Hook Scripts\n\nTest command hooks directly:\n\n```bash\necho '{\"tool_name\": \"Write\", \"tool_input\": {\"file_path\": \"/test\"}}' | \\\n  bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\n\necho \"Exit code: $?\"\n```\n\n### Validate JSON Output\n\nEnsure hooks output valid JSON:\n\n```bash\noutput=$(./your-hook.sh < test-input.json)\necho \"$output\" | jq .\n```\n\n## Quick Reference\n\n### Hook Events Summary\n\n| Event | When | Use For |\n|-------|------|---------|\n| PreToolUse | Before tool | Validation, modification |\n| PostToolUse | After tool | Feedback, logging |\n| UserPromptSubmit | User input | Context, validation |\n| Stop | Agent stopping | Completeness check |\n| SubagentStop | Subagent done | Task validation |\n| SessionStart | Session begins | Context loading |\n| SessionEnd | Session ends | Cleanup, logging |\n| PreCompact | Before compact | Preserve context |\n| Notification | User notified | Logging, reactions |\n\n### Best Practices\n\n**DO:**\n- âœ… Use prompt-based hooks for complex logic\n- âœ… Use ${CLAUDE_PLUGIN_ROOT} for portability\n- âœ… Validate all inputs in command hooks\n- âœ… Quote all bash variables\n- âœ… Set appropriate timeouts\n- âœ… Return structured JSON output\n- âœ… Test hooks thoroughly\n\n**DON'T:**\n- âŒ Use hardcoded paths\n- âŒ Trust user input without validation\n- âŒ Create long-running hooks\n- âŒ Rely on hook execution order\n- âŒ Modify global state unpredictably\n- âŒ Log sensitive information\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and advanced techniques, consult:\n\n- **`references/patterns.md`** - Common hook patterns (8+ proven patterns)\n- **`references/migration.md`** - Migrating from basic to advanced hooks\n- **`references/advanced.md`** - Advanced use cases and techniques\n\n### Example Hook Scripts\n\nWorking examples in `examples/`:\n\n- **`validate-write.sh`** - File write validation example\n- **`validate-bash.sh`** - Bash command validation example\n- **`load-context.sh`** - SessionStart context loading example\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-hook-schema.sh`** - Validate hooks.json structure and syntax\n- **`test-hook.sh`** - Test hooks with sample input before deployment\n- **`hook-linter.sh`** - Check hook scripts for common issues and best practices\n\n### External Resources\n\n- **Official Docs**: https://docs.claude.com/en/docs/claude-code/hooks\n- **Examples**: See security-guidance plugin in marketplace\n- **Testing**: Use `claude --debug` for detailed logs\n- **Validation**: Use `jq` to validate hook JSON output\n\n## Implementation Workflow\n\nTo implement hooks in a plugin:\n\n1. Identify events to hook into (PreToolUse, Stop, SessionStart, etc.)\n2. Decide between prompt-based (flexible) or command (deterministic) hooks\n3. Write hook configuration in `hooks/hooks.json`\n4. For command hooks, create hook scripts\n5. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n6. Validate configuration with `scripts/validate-hook-schema.sh hooks/hooks.json`\n7. Test hooks with `scripts/test-hook.sh` before deployment\n8. Test in Claude Code with `claude --debug`\n9. Document hooks in plugin README\n\nFocus on prompt-based hooks for most use cases. Reserve command hooks for performance-critical or deterministic checks."
              },
              {
                "name": "MCP Integration",
                "description": "This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration.",
                "path": "plugins/plugin-dev/skills/mcp-integration/SKILL.md",
                "frontmatter": {
                  "name": "MCP Integration",
                  "description": "This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration.",
                  "version": "0.1.0"
                },
                "content": "# MCP Integration for Claude Code Plugins\n\n## Overview\n\nModel Context Protocol (MCP) enables Claude Code plugins to integrate with external services and APIs by providing structured tool access. Use MCP integration to expose external service capabilities as tools within Claude Code.\n\n**Key capabilities:**\n- Connect to external services (databases, APIs, file systems)\n- Provide 10+ related tools from a single service\n- Handle OAuth and complex authentication flows\n- Bundle MCP servers with plugins for automatic setup\n\n## MCP Server Configuration Methods\n\nPlugins can bundle MCP servers in two ways:\n\n### Method 1: Dedicated .mcp.json (Recommended)\n\nCreate `.mcp.json` at plugin root:\n\n```json\n{\n  \"database-tools\": {\n    \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/db-server\",\n    \"args\": [\"--config\", \"${CLAUDE_PLUGIN_ROOT}/config.json\"],\n    \"env\": {\n      \"DB_URL\": \"${DB_URL}\"\n    }\n  }\n}\n```\n\n**Benefits:**\n- Clear separation of concerns\n- Easier to maintain\n- Better for multiple servers\n\n### Method 2: Inline in plugin.json\n\nAdd `mcpServers` field to plugin.json:\n\n```json\n{\n  \"name\": \"my-plugin\",\n  \"version\": \"1.0.0\",\n  \"mcpServers\": {\n    \"plugin-api\": {\n      \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/api-server\",\n      \"args\": [\"--port\", \"8080\"]\n    }\n  }\n}\n```\n\n**Benefits:**\n- Single configuration file\n- Good for simple single-server plugins\n\n## MCP Server Types\n\n### stdio (Local Process)\n\nExecute local MCP servers as child processes. Best for local tools and custom servers.\n\n**Configuration:**\n```json\n{\n  \"filesystem\": {\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/allowed/path\"],\n    \"env\": {\n      \"LOG_LEVEL\": \"debug\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- File system access\n- Local database connections\n- Custom MCP servers\n- NPM-packaged MCP servers\n\n**Process management:**\n- Claude Code spawns and manages the process\n- Communicates via stdin/stdout\n- Terminates when Claude Code exits\n\n### SSE (Server-Sent Events)\n\nConnect to hosted MCP servers with OAuth support. Best for cloud services.\n\n**Configuration:**\n```json\n{\n  \"asana\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.asana.com/sse\"\n  }\n}\n```\n\n**Use cases:**\n- Official hosted MCP servers (Asana, GitHub, etc.)\n- Cloud services with MCP endpoints\n- OAuth-based authentication\n- No local installation needed\n\n**Authentication:**\n- OAuth flows handled automatically\n- User prompted on first use\n- Tokens managed by Claude Code\n\n### HTTP (REST API)\n\nConnect to RESTful MCP servers with token authentication.\n\n**Configuration:**\n```json\n{\n  \"api-service\": {\n    \"type\": \"http\",\n    \"url\": \"https://api.example.com/mcp\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${API_TOKEN}\",\n      \"X-Custom-Header\": \"value\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- REST API-based MCP servers\n- Token-based authentication\n- Custom API backends\n- Stateless interactions\n\n### WebSocket (Real-time)\n\nConnect to WebSocket MCP servers for real-time bidirectional communication.\n\n**Configuration:**\n```json\n{\n  \"realtime-service\": {\n    \"type\": \"ws\",\n    \"url\": \"wss://mcp.example.com/ws\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${TOKEN}\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- Real-time data streaming\n- Persistent connections\n- Push notifications from server\n- Low-latency requirements\n\n## Environment Variable Expansion\n\nAll MCP configurations support environment variable substitution:\n\n**${CLAUDE_PLUGIN_ROOT}** - Plugin directory (always use for portability):\n```json\n{\n  \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/my-server\"\n}\n```\n\n**User environment variables** - From user's shell:\n```json\n{\n  \"env\": {\n    \"API_KEY\": \"${MY_API_KEY}\",\n    \"DATABASE_URL\": \"${DB_URL}\"\n  }\n}\n```\n\n**Best practice:** Document all required environment variables in plugin README.\n\n## MCP Tool Naming\n\nWhen MCP servers provide tools, they're automatically prefixed:\n\n**Format:** `mcp__plugin_<plugin-name>_<server-name>__<tool-name>`\n\n**Example:**\n- Plugin: `asana`\n- Server: `asana`\n- Tool: `create_task`\n- **Full name:** `mcp__plugin_asana_asana__asana_create_task`\n\n### Using MCP Tools in Commands\n\nPre-allow specific MCP tools in command frontmatter:\n\n```markdown\n---\nallowed-tools: [\n  \"mcp__plugin_asana_asana__asana_create_task\",\n  \"mcp__plugin_asana_asana__asana_search_tasks\"\n]\n---\n```\n\n**Wildcard (use sparingly):**\n```markdown\n---\nallowed-tools: [\"mcp__plugin_asana_asana__*\"]\n---\n```\n\n**Best practice:** Pre-allow specific tools, not wildcards, for security.\n\n## Lifecycle Management\n\n**Automatic startup:**\n- MCP servers start when plugin enables\n- Connection established before first tool use\n- Restart required for configuration changes\n\n**Lifecycle:**\n1. Plugin loads\n2. MCP configuration parsed\n3. Server process started (stdio) or connection established (SSE/HTTP/WS)\n4. Tools discovered and registered\n5. Tools available as `mcp__plugin_...__...`\n\n**Viewing servers:**\nUse `/mcp` command to see all servers including plugin-provided ones.\n\n## Authentication Patterns\n\n### OAuth (SSE/HTTP)\n\nOAuth handled automatically by Claude Code:\n\n```json\n{\n  \"type\": \"sse\",\n  \"url\": \"https://mcp.example.com/sse\"\n}\n```\n\nUser authenticates in browser on first use. No additional configuration needed.\n\n### Token-Based (Headers)\n\nStatic or environment variable tokens:\n\n```json\n{\n  \"type\": \"http\",\n  \"url\": \"https://api.example.com\",\n  \"headers\": {\n    \"Authorization\": \"Bearer ${API_TOKEN}\"\n  }\n}\n```\n\nDocument required environment variables in README.\n\n### Environment Variables (stdio)\n\nPass configuration to MCP server:\n\n```json\n{\n  \"command\": \"python\",\n  \"args\": [\"-m\", \"my_mcp_server\"],\n  \"env\": {\n    \"DATABASE_URL\": \"${DB_URL}\",\n    \"API_KEY\": \"${API_KEY}\",\n    \"LOG_LEVEL\": \"info\"\n  }\n}\n```\n\n## Integration Patterns\n\n### Pattern 1: Simple Tool Wrapper\n\nCommands use MCP tools with user interaction:\n\n```markdown\n# Command: create-item.md\n---\nallowed-tools: [\"mcp__plugin_name_server__create_item\"]\n---\n\nSteps:\n1. Gather item details from user\n2. Use mcp__plugin_name_server__create_item\n3. Confirm creation\n```\n\n**Use for:** Adding validation or preprocessing before MCP calls.\n\n### Pattern 2: Autonomous Agent\n\nAgents use MCP tools autonomously:\n\n```markdown\n# Agent: data-analyzer.md\n\nAnalysis Process:\n1. Query data via mcp__plugin_db_server__query\n2. Process and analyze results\n3. Generate insights report\n```\n\n**Use for:** Multi-step MCP workflows without user interaction.\n\n### Pattern 3: Multi-Server Plugin\n\nIntegrate multiple MCP servers:\n\n```json\n{\n  \"github\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.github.com/sse\"\n  },\n  \"jira\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.jira.com/sse\"\n  }\n}\n```\n\n**Use for:** Workflows spanning multiple services.\n\n## Security Best Practices\n\n### Use HTTPS/WSS\n\nAlways use secure connections:\n\n```json\nâœ… \"url\": \"https://mcp.example.com/sse\"\nâŒ \"url\": \"http://mcp.example.com/sse\"\n```\n\n### Token Management\n\n**DO:**\n- âœ… Use environment variables for tokens\n- âœ… Document required env vars in README\n- âœ… Let OAuth flow handle authentication\n\n**DON'T:**\n- âŒ Hardcode tokens in configuration\n- âŒ Commit tokens to git\n- âŒ Share tokens in documentation\n\n### Permission Scoping\n\nPre-allow only necessary MCP tools:\n\n```markdown\nâœ… allowed-tools: [\n  \"mcp__plugin_api_server__read_data\",\n  \"mcp__plugin_api_server__create_item\"\n]\n\nâŒ allowed-tools: [\"mcp__plugin_api_server__*\"]\n```\n\n## Error Handling\n\n### Connection Failures\n\nHandle MCP server unavailability:\n- Provide fallback behavior in commands\n- Inform user of connection issues\n- Check server URL and configuration\n\n### Tool Call Errors\n\nHandle failed MCP operations:\n- Validate inputs before calling MCP tools\n- Provide clear error messages\n- Check rate limiting and quotas\n\n### Configuration Errors\n\nValidate MCP configuration:\n- Test server connectivity during development\n- Validate JSON syntax\n- Check required environment variables\n\n## Performance Considerations\n\n### Lazy Loading\n\nMCP servers connect on-demand:\n- Not all servers connect at startup\n- First tool use triggers connection\n- Connection pooling managed automatically\n\n### Batching\n\nBatch similar requests when possible:\n\n```\n# Good: Single query with filters\ntasks = search_tasks(project=\"X\", assignee=\"me\", limit=50)\n\n# Avoid: Many individual queries\nfor id in task_ids:\n    task = get_task(id)\n```\n\n## Testing MCP Integration\n\n### Local Testing\n\n1. Configure MCP server in `.mcp.json`\n2. Install plugin locally (`.claude-plugin/`)\n3. Run `/mcp` to verify server appears\n4. Test tool calls in commands\n5. Check `claude --debug` logs for connection issues\n\n### Validation Checklist\n\n- [ ] MCP configuration is valid JSON\n- [ ] Server URL is correct and accessible\n- [ ] Required environment variables documented\n- [ ] Tools appear in `/mcp` output\n- [ ] Authentication works (OAuth or tokens)\n- [ ] Tool calls succeed from commands\n- [ ] Error cases handled gracefully\n\n## Debugging\n\n### Enable Debug Logging\n\n```bash\nclaude --debug\n```\n\nLook for:\n- MCP server connection attempts\n- Tool discovery logs\n- Authentication flows\n- Tool call errors\n\n### Common Issues\n\n**Server not connecting:**\n- Check URL is correct\n- Verify server is running (stdio)\n- Check network connectivity\n- Review authentication configuration\n\n**Tools not available:**\n- Verify server connected successfully\n- Check tool names match exactly\n- Run `/mcp` to see available tools\n- Restart Claude Code after config changes\n\n**Authentication failing:**\n- Clear cached auth tokens\n- Re-authenticate\n- Check token scopes and permissions\n- Verify environment variables set\n\n## Quick Reference\n\n### MCP Server Types\n\n| Type | Transport | Best For | Auth |\n|------|-----------|----------|------|\n| stdio | Process | Local tools, custom servers | Env vars |\n| SSE | HTTP | Hosted services, cloud APIs | OAuth |\n| HTTP | REST | API backends, token auth | Tokens |\n| ws | WebSocket | Real-time, streaming | Tokens |\n\n### Configuration Checklist\n\n- [ ] Server type specified (stdio/SSE/HTTP/ws)\n- [ ] Type-specific fields complete (command or url)\n- [ ] Authentication configured\n- [ ] Environment variables documented\n- [ ] HTTPS/WSS used (not HTTP/WS)\n- [ ] ${CLAUDE_PLUGIN_ROOT} used for paths\n\n### Best Practices\n\n**DO:**\n- âœ… Use ${CLAUDE_PLUGIN_ROOT} for portable paths\n- âœ… Document required environment variables\n- âœ… Use secure connections (HTTPS/WSS)\n- âœ… Pre-allow specific MCP tools in commands\n- âœ… Test MCP integration before publishing\n- âœ… Handle connection and tool errors gracefully\n\n**DON'T:**\n- âŒ Hardcode absolute paths\n- âŒ Commit credentials to git\n- âŒ Use HTTP instead of HTTPS\n- âŒ Pre-allow all tools with wildcards\n- âŒ Skip error handling\n- âŒ Forget to document setup\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed information, consult:\n\n- **`references/server-types.md`** - Deep dive on each server type\n- **`references/authentication.md`** - Authentication patterns and OAuth\n- **`references/tool-usage.md`** - Using MCP tools in commands and agents\n\n### Example Configurations\n\nWorking examples in `examples/`:\n\n- **`stdio-server.json`** - Local stdio MCP server\n- **`sse-server.json`** - Hosted SSE server with OAuth\n- **`http-server.json`** - REST API with token auth\n\n### External Resources\n\n- **Official MCP Docs**: https://modelcontextprotocol.io/\n- **Claude Code MCP Docs**: https://docs.claude.com/en/docs/claude-code/mcp\n- **MCP SDK**: @modelcontextprotocol/sdk\n- **Testing**: Use `claude --debug` and `/mcp` command\n\n## Implementation Workflow\n\nTo add MCP integration to a plugin:\n\n1. Choose MCP server type (stdio, SSE, HTTP, ws)\n2. Create `.mcp.json` at plugin root with configuration\n3. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n4. Document required environment variables in README\n5. Test locally with `/mcp` command\n6. Pre-allow MCP tools in relevant commands\n7. Handle authentication (OAuth or tokens)\n8. Test error cases (connection failures, auth errors)\n9. Document MCP integration in plugin README\n\nFocus on stdio for custom/local servers, SSE for hosted services with OAuth."
              },
              {
                "name": "Plugin Settings",
                "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.",
                "path": "plugins/plugin-dev/skills/plugin-settings/SKILL.md",
                "frontmatter": {
                  "name": "Plugin Settings",
                  "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.",
                  "version": "0.1.0"
                },
                "content": "# Plugin Settings Pattern for Claude Code Plugins\n\n## Overview\n\nPlugins can store user-configurable settings and state in `.claude/plugin-name.local.md` files within the project directory. This pattern uses YAML frontmatter for structured configuration and markdown content for prompts or additional context.\n\n**Key characteristics:**\n- File location: `.claude/plugin-name.local.md` in project root\n- Structure: YAML frontmatter + markdown body\n- Purpose: Per-project plugin configuration and state\n- Usage: Read from hooks, commands, and agents\n- Lifecycle: User-managed (not in git, should be in `.gitignore`)\n\n## File Structure\n\n### Basic Template\n\n```markdown\n---\nenabled: true\nsetting1: value1\nsetting2: value2\nnumeric_setting: 42\nlist_setting: [\"item1\", \"item2\"]\n---\n\n# Additional Context\n\nThis markdown body can contain:\n- Task descriptions\n- Additional instructions\n- Prompts to feed back to Claude\n- Documentation or notes\n```\n\n### Example: Plugin State File\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nenabled: true\nstrict_mode: false\nmax_retries: 3\nnotification_level: info\ncoordinator_session: team-leader\n---\n\n# Plugin Configuration\n\nThis plugin is configured for standard validation mode.\nContact @team-lead with questions.\n```\n\n## Reading Settings Files\n\n### From Hooks (Bash Scripts)\n\n**Pattern: Check existence and parse frontmatter**\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\n# Define state file path\nSTATE_FILE=\".claude/my-plugin.local.md\"\n\n# Quick exit if file doesn't exist\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0  # Plugin not configured, skip\nfi\n\n# Parse YAML frontmatter (between --- markers)\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\n\n# Extract individual fields\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\nSTRICT_MODE=$(echo \"$FRONTMATTER\" | grep '^strict_mode:' | sed 's/strict_mode: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n\n# Check if enabled\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Use configuration in hook logic\nif [[ \"$STRICT_MODE\" == \"true\" ]]; then\n  # Apply strict validation\n  # ...\nfi\n```\n\nSee `examples/read-settings-hook.sh` for complete working example.\n\n### From Commands\n\nCommands can read settings files to customize behavior:\n\n```markdown\n---\ndescription: Process data with plugin\nallowed-tools: [\"Read\", \"Bash\"]\n---\n\n# Process Command\n\nSteps:\n1. Check if settings exist at `.claude/my-plugin.local.md`\n2. Read configuration using Read tool\n3. Parse YAML frontmatter to extract settings\n4. Apply settings to processing logic\n5. Execute with configured behavior\n```\n\n### From Agents\n\nAgents can reference settings in their instructions:\n\n```markdown\n---\nname: configured-agent\ndescription: Agent that adapts to project settings\n---\n\nCheck for plugin settings at `.claude/my-plugin.local.md`.\nIf present, parse YAML frontmatter and adapt behavior according to:\n- enabled: Whether plugin is active\n- mode: Processing mode (strict, standard, lenient)\n- Additional configuration fields\n```\n\n## Parsing Techniques\n\n### Extract Frontmatter\n\n```bash\n# Extract everything between --- markers\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n```\n\n### Read Individual Fields\n\n**String fields:**\n```bash\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field_name:' | sed 's/field_name: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n**Boolean fields:**\n```bash\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n# Compare: if [[ \"$ENABLED\" == \"true\" ]]; then\n```\n\n**Numeric fields:**\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n# Use: if [[ $MAX -gt 100 ]]; then\n```\n\n### Read Markdown Body\n\nExtract content after second `---`:\n\n```bash\n# Get everything after closing ---\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n## Common Patterns\n\n### Pattern 1: Temporarily Active Hooks\n\nUse settings file to control hook activation:\n\n```bash\n#!/bin/bash\nSTATE_FILE=\".claude/security-scan.local.md\"\n\n# Quick exit if not configured\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0\nfi\n\n# Read enabled flag\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Run hook logic\n# ...\n```\n\n**Use case:** Enable/disable hooks without editing hooks.json (requires restart).\n\n### Pattern 2: Agent State Management\n\nStore agent-specific state and configuration:\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-agent\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\n---\n\n# Task Assignment\n\nImplement JWT authentication for the API.\n\n**Success Criteria:**\n- Authentication endpoints created\n- Tests passing\n- PR created and CI green\n```\n\nRead from hooks to coordinate agents:\n\n```bash\nAGENT_NAME=$(echo \"$FRONTMATTER\" | grep '^agent_name:' | sed 's/agent_name: *//')\nCOORDINATOR=$(echo \"$FRONTMATTER\" | grep '^coordinator_session:' | sed 's/coordinator_session: *//')\n\n# Send notification to coordinator\ntmux send-keys -t \"$COORDINATOR\" \"Agent $AGENT_NAME completed task\" Enter\n```\n\n### Pattern 3: Configuration-Driven Behavior\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nvalidation_level: strict\nmax_file_size: 1000000\nallowed_extensions: [\".js\", \".ts\", \".tsx\"]\nenable_logging: true\n---\n\n# Validation Configuration\n\nStrict mode enabled for this project.\nAll writes validated against security policies.\n```\n\nUse in hooks or commands:\n\n```bash\nLEVEL=$(echo \"$FRONTMATTER\" | grep '^validation_level:' | sed 's/validation_level: *//')\n\ncase \"$LEVEL\" in\n  strict)\n    # Apply strict validation\n    ;;\n  standard)\n    # Apply standard validation\n    ;;\n  lenient)\n    # Apply lenient validation\n    ;;\nesac\n```\n\n## Creating Settings Files\n\n### From Commands\n\nCommands can create settings files:\n\n```markdown\n# Setup Command\n\nSteps:\n1. Ask user for configuration preferences\n2. Create `.claude/my-plugin.local.md` with YAML frontmatter\n3. Set appropriate values based on user input\n4. Inform user that settings are saved\n5. Remind user to restart Claude Code for hooks to recognize changes\n```\n\n### Template Generation\n\nProvide template in plugin README:\n\n```markdown\n## Configuration\n\nCreate `.claude/my-plugin.local.md` in your project:\n\n\\`\\`\\`markdown\n---\nenabled: true\nmode: standard\nmax_retries: 3\n---\n\n# Plugin Configuration\n\nYour settings are active.\n\\`\\`\\`\n\nAfter creating or editing, restart Claude Code for changes to take effect.\n```\n\n## Best Practices\n\n### File Naming\n\nâœ… **DO:**\n- Use `.claude/plugin-name.local.md` format\n- Match plugin name exactly\n- Use `.local.md` suffix for user-local files\n\nâŒ **DON'T:**\n- Use different directory (not `.claude/`)\n- Use inconsistent naming\n- Use `.md` without `.local` (might be committed)\n\n### Gitignore\n\nAlways add to `.gitignore`:\n\n```gitignore\n.claude/*.local.md\n.claude/*.local.json\n```\n\nDocument this in plugin README.\n\n### Defaults\n\nProvide sensible defaults when settings file doesn't exist:\n\n```bash\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  # Use defaults\n  ENABLED=true\n  MODE=standard\nelse\n  # Read from file\n  # ...\nfi\n```\n\n### Validation\n\nValidate settings values:\n\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n\n# Validate numeric range\nif ! [[ \"$MAX\" =~ ^[0-9]+$ ]] || [[ $MAX -lt 1 ]] || [[ $MAX -gt 100 ]]; then\n  echo \"âš ï¸  Invalid max_value in settings (must be 1-100)\" >&2\n  MAX=10  # Use default\nfi\n```\n\n### Restart Requirement\n\n**Important:** Settings changes require Claude Code restart.\n\nDocument in your README:\n\n```markdown\n## Changing Settings\n\nAfter editing `.claude/my-plugin.local.md`:\n1. Save the file\n2. Exit Claude Code\n3. Restart: `claude` or `cc`\n4. New settings will be loaded\n```\n\nHooks cannot be hot-swapped within a session.\n\n## Security Considerations\n\n### Sanitize User Input\n\nWhen writing settings files from user input:\n\n```bash\n# Escape quotes in user input\nSAFE_VALUE=$(echo \"$USER_INPUT\" | sed 's/\"/\\\\\"/g')\n\n# Write to file\ncat > \"$STATE_FILE\" <<EOF\n---\nuser_setting: \"$SAFE_VALUE\"\n---\nEOF\n```\n\n### Validate File Paths\n\nIf settings contain file paths:\n\n```bash\nFILE_PATH=$(echo \"$FRONTMATTER\" | grep '^data_file:' | sed 's/data_file: *//')\n\n# Check for path traversal\nif [[ \"$FILE_PATH\" == *\"..\"* ]]; then\n  echo \"âš ï¸  Invalid path in settings (path traversal)\" >&2\n  exit 2\nfi\n```\n\n### Permissions\n\nSettings files should be:\n- Readable by user only (`chmod 600`)\n- Not committed to git\n- Not shared between users\n\n## Real-World Examples\n\n### multi-agent-swarm Plugin\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-implementation\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\nadditional_instructions: Use JWT tokens, not sessions\n---\n\n# Task: Implement Authentication\n\nBuild JWT-based authentication for the REST API.\nCoordinate with auth-agent on shared types.\n```\n\n**Hook usage (agent-stop-notification.sh):**\n- Checks if file exists (line 15-18: quick exit if not)\n- Parses frontmatter to get coordinator_session, agent_name, enabled\n- Sends notifications to coordinator if enabled\n- Allows quick activation/deactivation via `enabled: true/false`\n\n### ralph-loop Plugin\n\n**.claude/ralph-loop.local.md:**\n```markdown\n---\niteration: 1\nmax_iterations: 10\ncompletion_promise: \"All tests passing and build successful\"\n---\n\nFix all the linting errors in the project.\nMake sure tests pass after each fix.\n```\n\n**Hook usage (stop-hook.sh):**\n- Checks if file exists (line 15-18: quick exit if not active)\n- Reads iteration count and max_iterations\n- Extracts completion_promise for loop termination\n- Reads body as the prompt to feed back\n- Updates iteration count on each loop\n\n## Quick Reference\n\n### File Location\n\n```\nproject-root/\nâ””â”€â”€ .claude/\n    â””â”€â”€ plugin-name.local.md\n```\n\n### Frontmatter Parsing\n\n```bash\n# Extract frontmatter\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n\n# Read field\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field:' | sed 's/field: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n### Body Parsing\n\n```bash\n# Extract body (after second ---)\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n### Quick Exit Pattern\n\n```bash\nif [[ ! -f \".claude/my-plugin.local.md\" ]]; then\n  exit 0  # Not configured\nfi\n```\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed implementation patterns:\n\n- **`references/parsing-techniques.md`** - Complete guide to parsing YAML frontmatter and markdown bodies\n- **`references/real-world-examples.md`** - Deep dive into multi-agent-swarm and ralph-loop implementations\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`read-settings-hook.sh`** - Hook that reads and uses settings\n- **`create-settings-command.md`** - Command that creates settings file\n- **`example-settings.md`** - Template settings file\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-settings.sh`** - Validate settings file structure\n- **`parse-frontmatter.sh`** - Extract frontmatter fields\n\n## Implementation Workflow\n\nTo add settings to a plugin:\n\n1. Design settings schema (which fields, types, defaults)\n2. Create template file in plugin documentation\n3. Add gitignore entry for `.claude/*.local.md`\n4. Implement settings parsing in hooks/commands\n5. Use quick-exit pattern (check file exists, check enabled field)\n6. Document settings in plugin README with template\n7. Remind users that changes require Claude Code restart\n\nFocus on keeping settings simple and providing good defaults when settings file doesn't exist."
              },
              {
                "name": "Plugin Structure",
                "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.",
                "path": "plugins/plugin-dev/skills/plugin-structure/SKILL.md",
                "frontmatter": {
                  "name": "Plugin Structure",
                  "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.",
                  "version": "0.1.0"
                },
                "content": "# Plugin Structure for Claude Code\n\n## Overview\n\nClaude Code plugins follow a standardized directory structure with automatic component discovery. Understanding this structure enables creating well-organized, maintainable plugins that integrate seamlessly with Claude Code.\n\n**Key concepts:**\n- Conventional directory layout for automatic discovery\n- Manifest-driven configuration in `.claude-plugin/plugin.json`\n- Component-based organization (commands, agents, skills, hooks)\n- Portable path references using `${CLAUDE_PLUGIN_ROOT}`\n- Explicit vs. auto-discovered component loading\n\n## Directory Structure\n\nEvery Claude Code plugin follows this organizational pattern:\n\n```\nplugin-name/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json          # Required: Plugin manifest\nâ”œâ”€â”€ commands/                 # Slash commands (.md files)\nâ”œâ”€â”€ agents/                   # Subagent definitions (.md files)\nâ”œâ”€â”€ skills/                   # Agent skills (subdirectories)\nâ”‚   â””â”€â”€ skill-name/\nâ”‚       â””â”€â”€ SKILL.md         # Required for each skill\nâ”œâ”€â”€ hooks/\nâ”‚   â””â”€â”€ hooks.json           # Event handler configuration\nâ”œâ”€â”€ .mcp.json                # MCP server definitions\nâ””â”€â”€ scripts/                 # Helper scripts and utilities\n```\n\n**Critical rules:**\n\n1. **Manifest location**: The `plugin.json` manifest MUST be in `.claude-plugin/` directory\n2. **Component locations**: All component directories (commands, agents, skills, hooks) MUST be at plugin root level, NOT nested inside `.claude-plugin/`\n3. **Optional components**: Only create directories for components the plugin actually uses\n4. **Naming convention**: Use kebab-case for all directory and file names\n\n## Plugin Manifest (plugin.json)\n\nThe manifest defines plugin metadata and configuration. Located at `.claude-plugin/plugin.json`:\n\n### Required Fields\n\n```json\n{\n  \"name\": \"plugin-name\"\n}\n```\n\n**Name requirements:**\n- Use kebab-case format (lowercase with hyphens)\n- Must be unique across installed plugins\n- No spaces or special characters\n- Example: `code-review-assistant`, `test-runner`, `api-docs`\n\n### Recommended Metadata\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Brief explanation of plugin purpose\",\n  \"author\": {\n    \"name\": \"Author Name\",\n    \"email\": \"author@example.com\",\n    \"url\": \"https://example.com\"\n  },\n  \"homepage\": \"https://docs.example.com\",\n  \"repository\": \"https://github.com/user/plugin-name\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"testing\", \"automation\", \"ci-cd\"]\n}\n```\n\n**Version format**: Follow semantic versioning (MAJOR.MINOR.PATCH)\n**Keywords**: Use for plugin discovery and categorization\n\n### Component Path Configuration\n\nSpecify custom paths for components (supplements default directories):\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"commands\": \"./custom-commands\",\n  \"agents\": [\"./agents\", \"./specialized-agents\"],\n  \"hooks\": \"./config/hooks.json\",\n  \"mcpServers\": \"./.mcp.json\"\n}\n```\n\n**Important**: Custom paths supplement defaultsâ€”they don't replace them. Components in both default directories and custom paths will load.\n\n**Path rules:**\n- Must be relative to plugin root\n- Must start with `./`\n- Cannot use absolute paths\n- Support arrays for multiple locations\n\n## Component Organization\n\n### Commands\n\n**Location**: `commands/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `commands/` load automatically\n\n**Example structure**:\n```\ncommands/\nâ”œâ”€â”€ review.md        # /review command\nâ”œâ”€â”€ test.md          # /test command\nâ””â”€â”€ deploy.md        # /deploy command\n```\n\n**File format**:\n```markdown\n---\nname: command-name\ndescription: Command description\n---\n\nCommand implementation instructions...\n```\n\n**Usage**: Commands integrate as native slash commands in Claude Code\n\n### Agents\n\n**Location**: `agents/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `agents/` load automatically\n\n**Example structure**:\n```\nagents/\nâ”œâ”€â”€ code-reviewer.md\nâ”œâ”€â”€ test-generator.md\nâ””â”€â”€ refactorer.md\n```\n\n**File format**:\n```markdown\n---\ndescription: Agent role and expertise\ncapabilities:\n  - Specific task 1\n  - Specific task 2\n---\n\nDetailed agent instructions and knowledge...\n```\n\n**Usage**: Users can invoke agents manually, or Claude Code selects them automatically based on task context\n\n### Skills\n\n**Location**: `skills/` directory with subdirectories per skill\n**Format**: Each skill in its own directory with `SKILL.md` file\n**Auto-discovery**: All `SKILL.md` files in skill subdirectories load automatically\n\n**Example structure**:\n```\nskills/\nâ”œâ”€â”€ api-testing/\nâ”‚   â”œâ”€â”€ SKILL.md\nâ”‚   â”œâ”€â”€ scripts/\nâ”‚   â”‚   â””â”€â”€ test-runner.py\nâ”‚   â””â”€â”€ references/\nâ”‚       â””â”€â”€ api-spec.md\nâ””â”€â”€ database-migrations/\n    â”œâ”€â”€ SKILL.md\n    â””â”€â”€ examples/\n        â””â”€â”€ migration-template.sql\n```\n\n**SKILL.md format**:\n```markdown\n---\nname: Skill Name\ndescription: When to use this skill\nversion: 1.0.0\n---\n\nSkill instructions and guidance...\n```\n\n**Supporting files**: Skills can include scripts, references, examples, or assets in subdirectories\n\n**Usage**: Claude Code autonomously activates skills based on task context matching the description\n\n### Hooks\n\n**Location**: `hooks/hooks.json` or inline in `plugin.json`\n**Format**: JSON configuration defining event handlers\n**Registration**: Hooks register automatically when plugin enables\n\n**Example structure**:\n```\nhooks/\nâ”œâ”€â”€ hooks.json           # Hook configuration\nâ””â”€â”€ scripts/\n    â”œâ”€â”€ validate.sh      # Hook script\n    â””â”€â”€ check-style.sh   # Hook script\n```\n\n**Configuration format**:\n```json\n{\n  \"PreToolUse\": [{\n    \"matcher\": \"Write|Edit\",\n    \"hooks\": [{\n      \"type\": \"command\",\n      \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/validate.sh\",\n      \"timeout\": 30\n    }]\n  }]\n}\n```\n\n**Available events**: PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification\n\n**Usage**: Hooks execute automatically in response to Claude Code events\n\n### MCP Servers\n\n**Location**: `.mcp.json` at plugin root or inline in `plugin.json`\n**Format**: JSON configuration for MCP server definitions\n**Auto-start**: Servers start automatically when plugin enables\n\n**Example format**:\n```json\n{\n  \"mcpServers\": {\n    \"server-name\": {\n      \"command\": \"node\",\n      \"args\": [\"${CLAUDE_PLUGIN_ROOT}/servers/server.js\"],\n      \"env\": {\n        \"API_KEY\": \"${API_KEY}\"\n      }\n    }\n  }\n}\n```\n\n**Usage**: MCP servers integrate seamlessly with Claude Code's tool system\n\n## Portable Path References\n\n### ${CLAUDE_PLUGIN_ROOT}\n\nUse `${CLAUDE_PLUGIN_ROOT}` environment variable for all intra-plugin path references:\n\n```json\n{\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/run.sh\"\n}\n```\n\n**Why it matters**: Plugins install in different locations depending on:\n- User installation method (marketplace, local, npm)\n- Operating system conventions\n- User preferences\n\n**Where to use it**:\n- Hook command paths\n- MCP server command arguments\n- Script execution references\n- Resource file paths\n\n**Never use**:\n- Hardcoded absolute paths (`/Users/name/plugins/...`)\n- Relative paths from working directory (`./scripts/...` in commands)\n- Home directory shortcuts (`~/plugins/...`)\n\n### Path Resolution Rules\n\n**In manifest JSON fields** (hooks, MCP servers):\n```json\n\"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/tool.sh\"\n```\n\n**In component files** (commands, agents, skills):\n```markdown\nReference scripts at: ${CLAUDE_PLUGIN_ROOT}/scripts/helper.py\n```\n\n**In executed scripts**:\n```bash\n#!/bin/bash\n# ${CLAUDE_PLUGIN_ROOT} available as environment variable\nsource \"${CLAUDE_PLUGIN_ROOT}/lib/common.sh\"\n```\n\n## File Naming Conventions\n\n### Component Files\n\n**Commands**: Use kebab-case `.md` files\n- `code-review.md` â†’ `/code-review`\n- `run-tests.md` â†’ `/run-tests`\n- `api-docs.md` â†’ `/api-docs`\n\n**Agents**: Use kebab-case `.md` files describing role\n- `test-generator.md`\n- `code-reviewer.md`\n- `performance-analyzer.md`\n\n**Skills**: Use kebab-case directory names\n- `api-testing/`\n- `database-migrations/`\n- `error-handling/`\n\n### Supporting Files\n\n**Scripts**: Use descriptive kebab-case names with appropriate extensions\n- `validate-input.sh`\n- `generate-report.py`\n- `process-data.js`\n\n**Documentation**: Use kebab-case markdown files\n- `api-reference.md`\n- `migration-guide.md`\n- `best-practices.md`\n\n**Configuration**: Use standard names\n- `hooks.json`\n- `.mcp.json`\n- `plugin.json`\n\n## Auto-Discovery Mechanism\n\nClaude Code automatically discovers and loads components:\n\n1. **Plugin manifest**: Reads `.claude-plugin/plugin.json` when plugin enables\n2. **Commands**: Scans `commands/` directory for `.md` files\n3. **Agents**: Scans `agents/` directory for `.md` files\n4. **Skills**: Scans `skills/` for subdirectories containing `SKILL.md`\n5. **Hooks**: Loads configuration from `hooks/hooks.json` or manifest\n6. **MCP servers**: Loads configuration from `.mcp.json` or manifest\n\n**Discovery timing**:\n- Plugin installation: Components register with Claude Code\n- Plugin enable: Components become available for use\n- No restart required: Changes take effect on next Claude Code session\n\n**Override behavior**: Custom paths in `plugin.json` supplement (not replace) default directories\n\n## Best Practices\n\n### Organization\n\n1. **Logical grouping**: Group related components together\n   - Put test-related commands, agents, and skills together\n   - Create subdirectories in `scripts/` for different purposes\n\n2. **Minimal manifest**: Keep `plugin.json` lean\n   - Only specify custom paths when necessary\n   - Rely on auto-discovery for standard layouts\n   - Use inline configuration only for simple cases\n\n3. **Documentation**: Include README files\n   - Plugin root: Overall purpose and usage\n   - Component directories: Specific guidance\n   - Script directories: Usage and requirements\n\n### Naming\n\n1. **Consistency**: Use consistent naming across components\n   - If command is `test-runner`, name related agent `test-runner-agent`\n   - Match skill directory names to their purpose\n\n2. **Clarity**: Use descriptive names that indicate purpose\n   - Good: `api-integration-testing/`, `code-quality-checker.md`\n   - Avoid: `utils/`, `misc.md`, `temp.sh`\n\n3. **Length**: Balance brevity with clarity\n   - Commands: 2-3 words (`review-pr`, `run-ci`)\n   - Agents: Describe role clearly (`code-reviewer`, `test-generator`)\n   - Skills: Topic-focused (`error-handling`, `api-design`)\n\n### Portability\n\n1. **Always use ${CLAUDE_PLUGIN_ROOT}**: Never hardcode paths\n2. **Test on multiple systems**: Verify on macOS, Linux, Windows\n3. **Document dependencies**: List required tools and versions\n4. **Avoid system-specific features**: Use portable bash/Python constructs\n\n### Maintenance\n\n1. **Version consistently**: Update version in plugin.json for releases\n2. **Deprecate gracefully**: Mark old components clearly before removal\n3. **Document breaking changes**: Note changes affecting existing users\n4. **Test thoroughly**: Verify all components work after changes\n\n## Common Patterns\n\n### Minimal Plugin\n\nSingle command with no dependencies:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json    # Just name field\nâ””â”€â”€ commands/\n    â””â”€â”€ hello.md       # Single command\n```\n\n### Full-Featured Plugin\n\nComplete plugin with all component types:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/          # User-facing commands\nâ”œâ”€â”€ agents/            # Specialized subagents\nâ”œâ”€â”€ skills/            # Auto-activating skills\nâ”œâ”€â”€ hooks/             # Event handlers\nâ”‚   â”œâ”€â”€ hooks.json\nâ”‚   â””â”€â”€ scripts/\nâ”œâ”€â”€ .mcp.json          # External integrations\nâ””â”€â”€ scripts/           # Shared utilities\n```\n\n### Skill-Focused Plugin\n\nPlugin providing only skills:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ””â”€â”€ skills/\n    â”œâ”€â”€ skill-one/\n    â”‚   â””â”€â”€ SKILL.md\n    â””â”€â”€ skill-two/\n        â””â”€â”€ SKILL.md\n```\n\n## Troubleshooting\n\n**Component not loading**:\n- Verify file is in correct directory with correct extension\n- Check YAML frontmatter syntax (commands, agents, skills)\n- Ensure skill has `SKILL.md` (not `README.md` or other name)\n- Confirm plugin is enabled in Claude Code settings\n\n**Path resolution errors**:\n- Replace all hardcoded paths with `${CLAUDE_PLUGIN_ROOT}`\n- Verify paths are relative and start with `./` in manifest\n- Check that referenced files exist at specified paths\n- Test with `echo $CLAUDE_PLUGIN_ROOT` in hook scripts\n\n**Auto-discovery not working**:\n- Confirm directories are at plugin root (not in `.claude-plugin/`)\n- Check file naming follows conventions (kebab-case, correct extensions)\n- Verify custom paths in manifest are correct\n- Restart Claude Code to reload plugin configuration\n\n**Conflicts between plugins**:\n- Use unique, descriptive component names\n- Namespace commands with plugin name if needed\n- Document potential conflicts in plugin README\n- Consider command prefixes for related functionality\n\n---\n\nFor detailed examples and advanced patterns, see files in `references/` and `examples/` directories."
              },
              {
                "name": "Skill Development",
                "description": "This skill should be used when the user wants to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins.",
                "path": "plugins/plugin-dev/skills/skill-development/SKILL.md",
                "frontmatter": {
                  "name": "Skill Development",
                  "description": "This skill should be used when the user wants to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins.",
                  "version": "0.1.0"
                },
                "content": "# Skill Development for Claude Code Plugins\n\nThis skill provides guidance for creating effective skills for Claude Code plugins.\n\n## About Skills\n\nSkills are modular, self-contained packages that extend Claude's capabilities by providing\nspecialized knowledge, workflows, and tools. Think of them as \"onboarding guides\" for specific\ndomains or tasksâ€”they transform Claude from a general-purpose agent into a specialized agent\nequipped with procedural knowledge that no model can fully possess.\n\n### What Skills Provide\n\n1. Specialized workflows - Multi-step procedures for specific domains\n2. Tool integrations - Instructions for working with specific file formats or APIs\n3. Domain expertise - Company-specific knowledge, schemas, business logic\n4. Bundled resources - Scripts, references, and assets for complex and repetitive tasks\n\n### Anatomy of a Skill\n\nEvery skill consists of a required SKILL.md file and optional bundled resources:\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md (required)\nâ”‚   â”œâ”€â”€ YAML frontmatter metadata (required)\nâ”‚   â”‚   â”œâ”€â”€ name: (required)\nâ”‚   â”‚   â””â”€â”€ description: (required)\nâ”‚   â””â”€â”€ Markdown instructions (required)\nâ””â”€â”€ Bundled Resources (optional)\n    â”œâ”€â”€ scripts/          - Executable code (Python/Bash/etc.)\n    â”œâ”€â”€ references/       - Documentation intended to be loaded into context as needed\n    â””â”€â”€ assets/           - Files used in output (templates, icons, fonts, etc.)\n```\n\n#### SKILL.md (required)\n\n**Metadata Quality:** The `name` and `description` in YAML frontmatter determine when Claude will use the skill. Be specific about what the skill does and when to use it. Use the third-person (e.g. \"This skill should be used when...\" instead of \"Use this skill when...\").\n\n#### Bundled Resources (optional)\n\n##### Scripts (`scripts/`)\n\nExecutable code (Python/Bash/etc.) for tasks that require deterministic reliability or are repeatedly rewritten.\n\n- **When to include**: When the same code is being rewritten repeatedly or deterministic reliability is needed\n- **Example**: `scripts/rotate_pdf.py` for PDF rotation tasks\n- **Benefits**: Token efficient, deterministic, may be executed without loading into context\n- **Note**: Scripts may still need to be read by Claude for patching or environment-specific adjustments\n\n##### References (`references/`)\n\nDocumentation and reference material intended to be loaded as needed into context to inform Claude's process and thinking.\n\n- **When to include**: For documentation that Claude should reference while working\n- **Examples**: `references/finance.md` for financial schemas, `references/mnda.md` for company NDA template, `references/policies.md` for company policies, `references/api_docs.md` for API specifications\n- **Use cases**: Database schemas, API documentation, domain knowledge, company policies, detailed workflow guides\n- **Benefits**: Keeps SKILL.md lean, loaded only when Claude determines it's needed\n- **Best practice**: If files are large (>10k words), include grep search patterns in SKILL.md\n- **Avoid duplication**: Information should live in either SKILL.md or references files, not both. Prefer references files for detailed information unless it's truly core to the skillâ€”this keeps SKILL.md lean while making information discoverable without hogging the context window. Keep only essential procedural instructions and workflow guidance in SKILL.md; move detailed reference material, schemas, and examples to references files.\n\n##### Assets (`assets/`)\n\nFiles not intended to be loaded into context, but rather used within the output Claude produces.\n\n- **When to include**: When the skill needs files that will be used in the final output\n- **Examples**: `assets/logo.png` for brand assets, `assets/slides.pptx` for PowerPoint templates, `assets/frontend-template/` for HTML/React boilerplate, `assets/font.ttf` for typography\n- **Use cases**: Templates, images, icons, boilerplate code, fonts, sample documents that get copied or modified\n- **Benefits**: Separates output resources from documentation, enables Claude to use files without loading them into context\n\n### Progressive Disclosure Design Principle\n\nSkills use a three-level loading system to manage context efficiently:\n\n1. **Metadata (name + description)** - Always in context (~100 words)\n2. **SKILL.md body** - When skill triggers (<5k words)\n3. **Bundled resources** - As needed by Claude (Unlimited*)\n\n*Unlimited because scripts can be executed without reading into context window.\n\n## Skill Creation Process\n\nTo create a skill, follow the \"Skill Creation Process\" in order, skipping steps only if there is a clear reason why they are not applicable.\n\n### Step 1: Understanding the Skill with Concrete Examples\n\nSkip this step only when the skill's usage patterns are already clearly understood. It remains valuable even when working with an existing skill.\n\nTo create an effective skill, clearly understand concrete examples of how the skill will be used. This understanding can come from either direct user examples or generated examples that are validated with user feedback.\n\nFor example, when building an image-editor skill, relevant questions include:\n\n- \"What functionality should the image-editor skill support? Editing, rotating, anything else?\"\n- \"Can you give some examples of how this skill would be used?\"\n- \"I can imagine users asking for things like 'Remove the red-eye from this image' or 'Rotate this image'. Are there other ways you imagine this skill being used?\"\n- \"What would a user say that should trigger this skill?\"\n\nTo avoid overwhelming users, avoid asking too many questions in a single message. Start with the most important questions and follow up as needed for better effectiveness.\n\nConclude this step when there is a clear sense of the functionality the skill should support.\n\n### Step 2: Planning the Reusable Skill Contents\n\nTo turn concrete examples into an effective skill, analyze each example by:\n\n1. Considering how to execute on the example from scratch\n2. Identifying what scripts, references, and assets would be helpful when executing these workflows repeatedly\n\nExample: When building a `pdf-editor` skill to handle queries like \"Help me rotate this PDF,\" the analysis shows:\n\n1. Rotating a PDF requires re-writing the same code each time\n2. A `scripts/rotate_pdf.py` script would be helpful to store in the skill\n\nExample: When designing a `frontend-webapp-builder` skill for queries like \"Build me a todo app\" or \"Build me a dashboard to track my steps,\" the analysis shows:\n\n1. Writing a frontend webapp requires the same boilerplate HTML/React each time\n2. An `assets/hello-world/` template containing the boilerplate HTML/React project files would be helpful to store in the skill\n\nExample: When building a `big-query` skill to handle queries like \"How many users have logged in today?\" the analysis shows:\n\n1. Querying BigQuery requires re-discovering the table schemas and relationships each time\n2. A `references/schema.md` file documenting the table schemas would be helpful to store in the skill\n\n**For Claude Code plugins:** When building a hooks skill, the analysis shows:\n1. Developers repeatedly need to validate hooks.json and test hook scripts\n2. `scripts/validate-hook-schema.sh` and `scripts/test-hook.sh` utilities would be helpful\n3. `references/patterns.md` for detailed hook patterns to avoid bloating SKILL.md\n\nTo establish the skill's contents, analyze each concrete example to create a list of the reusable resources to include: scripts, references, and assets.\n\n### Step 3: Create Skill Structure\n\nFor Claude Code plugins, create the skill directory structure:\n\n```bash\nmkdir -p plugin-name/skills/skill-name/{references,examples,scripts}\ntouch plugin-name/skills/skill-name/SKILL.md\n```\n\n**Note:** Unlike the generic skill-creator which uses `init_skill.py`, plugin skills are created directly in the plugin's `skills/` directory with a simpler manual structure.\n\n### Step 4: Edit the Skill\n\nWhen editing the (newly-created or existing) skill, remember that the skill is being created for another instance of Claude to use. Focus on including information that would be beneficial and non-obvious to Claude. Consider what procedural knowledge, domain-specific details, or reusable assets would help another Claude instance execute these tasks more effectively.\n\n#### Start with Reusable Skill Contents\n\nTo begin implementation, start with the reusable resources identified above: `scripts/`, `references/`, and `assets/` files. Note that this step may require user input. For example, when implementing a `brand-guidelines` skill, the user may need to provide brand assets or templates to store in `assets/`, or documentation to store in `references/`.\n\nAlso, delete any example files and directories not needed for the skill. Create only the directories you actually need (references/, examples/, scripts/).\n\n#### Update SKILL.md\n\n**Writing Style:** Write the entire skill using **imperative/infinitive form** (verb-first instructions), not second person. Use objective, instructional language (e.g., \"To accomplish X, do Y\" rather than \"You should do X\" or \"If you need to do X\"). This maintains consistency and clarity for AI consumption.\n\n**Description (Frontmatter):** Use third-person format with specific trigger phrases:\n\n```yaml\n---\nname: Skill Name\ndescription: This skill should be used when the user asks to \"specific phrase 1\", \"specific phrase 2\", \"specific phrase 3\". Include exact phrases users would say that should trigger this skill. Be concrete and specific.\nversion: 0.1.0\n---\n```\n\n**Good description examples:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", \"implement prompt-based hooks\", or mentions hook events (PreToolUse, PostToolUse, Stop).\n```\n\n**Bad description examples:**\n```yaml\ndescription: Use this skill when working with hooks.  # Wrong person, vague\ndescription: Load when user needs hook help.  # Not third person\ndescription: Provides hook guidance.  # No trigger phrases\n```\n\nTo complete SKILL.md body, answer the following questions:\n\n1. What is the purpose of the skill, in a few sentences?\n2. When should the skill be used? (Include this in frontmatter description with specific triggers)\n3. In practice, how should Claude use the skill? All reusable skill contents developed above should be referenced so that Claude knows how to use them.\n\n**Keep SKILL.md lean:** Target 1,500-2,000 words for the body. Move detailed content to references/:\n- Detailed patterns â†’ `references/patterns.md`\n- Advanced techniques â†’ `references/advanced.md`\n- Migration guides â†’ `references/migration.md`\n- API references â†’ `references/api-reference.md`\n\n**Reference resources in SKILL.md:**\n```markdown\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and techniques, consult:\n- **`references/patterns.md`** - Common patterns\n- **`references/advanced.md`** - Advanced use cases\n\n### Example Files\n\nWorking examples in `examples/`:\n- **`example-script.sh`** - Working example\n```\n\n### Step 5: Validate and Test\n\n**For plugin skills, validation is different from generic skills:**\n\n1. **Check structure**: Skill directory in `plugin-name/skills/skill-name/`\n2. **Validate SKILL.md**: Has frontmatter with name and description\n3. **Check trigger phrases**: Description includes specific user queries\n4. **Verify writing style**: Body uses imperative/infinitive form, not second person\n5. **Test progressive disclosure**: SKILL.md is lean (~1,500-2,000 words), detailed content in references/\n6. **Check references**: All referenced files exist\n7. **Validate examples**: Examples are complete and correct\n8. **Test scripts**: Scripts are executable and work correctly\n\n**Use the skill-reviewer agent:**\n```\nAsk: \"Review my skill and check if it follows best practices\"\n```\n\nThe skill-reviewer agent will check description quality, content organization, and progressive disclosure.\n\n### Step 6: Iterate\n\nAfter testing the skill, users may request improvements. Often this happens right after using the skill, with fresh context of how the skill performed.\n\n**Iteration workflow:**\n1. Use the skill on real tasks\n2. Notice struggles or inefficiencies\n3. Identify how SKILL.md or bundled resources should be updated\n4. Implement changes and test again\n\n**Common improvements:**\n- Strengthen trigger phrases in description\n- Move long sections from SKILL.md to references/\n- Add missing examples or scripts\n- Clarify ambiguous instructions\n- Add edge case handling\n\n## Plugin-Specific Considerations\n\n### Skill Location in Plugins\n\nPlugin skills live in the plugin's `skills/` directory:\n\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/\nâ”œâ”€â”€ agents/\nâ””â”€â”€ skills/\n    â””â”€â”€ my-skill/\n        â”œâ”€â”€ SKILL.md\n        â”œâ”€â”€ references/\n        â”œâ”€â”€ examples/\n        â””â”€â”€ scripts/\n```\n\n### Auto-Discovery\n\nClaude Code automatically discovers skills:\n- Scans `skills/` directory\n- Finds subdirectories containing `SKILL.md`\n- Loads skill metadata (name + description) always\n- Loads SKILL.md body when skill triggers\n- Loads references/examples when needed\n\n### No Packaging Needed\n\nPlugin skills are distributed as part of the plugin, not as separate ZIP files. Users get skills when they install the plugin.\n\n### Testing in Plugins\n\nTest skills by installing plugin locally:\n\n```bash\n# Test with --plugin-dir\ncc --plugin-dir /path/to/plugin\n\n# Ask questions that should trigger the skill\n# Verify skill loads correctly\n```\n\n## Examples from Plugin-Dev\n\nStudy the skills in this plugin as examples of best practices:\n\n**hook-development skill:**\n- Excellent trigger phrases: \"create a hook\", \"add a PreToolUse hook\", etc.\n- Lean SKILL.md (1,651 words)\n- 3 references/ files for detailed content\n- 3 examples/ of working hooks\n- 3 scripts/ utilities\n\n**agent-development skill:**\n- Strong triggers: \"create an agent\", \"agent frontmatter\", etc.\n- Focused SKILL.md (1,438 words)\n- References include the AI generation prompt from Claude Code\n- Complete agent examples\n\n**plugin-settings skill:**\n- Specific triggers: \"plugin settings\", \".local.md files\", \"YAML frontmatter\"\n- References show real implementations (multi-agent-swarm, ralph-loop)\n- Working parsing scripts\n\nEach demonstrates progressive disclosure and strong triggering.\n\n## Progressive Disclosure in Practice\n\n### What Goes in SKILL.md\n\n**Include (always loaded when skill triggers):**\n- Core concepts and overview\n- Essential procedures and workflows\n- Quick reference tables\n- Pointers to references/examples/scripts\n- Most common use cases\n\n**Keep under 3,000 words, ideally 1,500-2,000 words**\n\n### What Goes in references/\n\n**Move to references/ (loaded as needed):**\n- Detailed patterns and advanced techniques\n- Comprehensive API documentation\n- Migration guides\n- Edge cases and troubleshooting\n- Extensive examples and walkthroughs\n\n**Each reference file can be large (2,000-5,000+ words)**\n\n### What Goes in examples/\n\n**Working code examples:**\n- Complete, runnable scripts\n- Configuration files\n- Template files\n- Real-world usage examples\n\n**Users can copy and adapt these directly**\n\n### What Goes in scripts/\n\n**Utility scripts:**\n- Validation tools\n- Testing helpers\n- Parsing utilities\n- Automation scripts\n\n**Should be executable and documented**\n\n## Writing Style Requirements\n\n### Imperative/Infinitive Form\n\nWrite using verb-first instructions, not second person:\n\n**Correct (imperative):**\n```\nTo create a hook, define the event type.\nConfigure the MCP server with authentication.\nValidate settings before use.\n```\n\n**Incorrect (second person):**\n```\nYou should create a hook by defining the event type.\nYou need to configure the MCP server.\nYou must validate settings before use.\n```\n\n### Third-Person in Description\n\nThe frontmatter description must use third person:\n\n**Correct:**\n```yaml\ndescription: This skill should be used when the user asks to \"create X\", \"configure Y\"...\n```\n\n**Incorrect:**\n```yaml\ndescription: Use this skill when you want to create X...\ndescription: Load this skill when user asks...\n```\n\n### Objective, Instructional Language\n\nFocus on what to do, not who should do it:\n\n**Correct:**\n```\nParse the frontmatter using sed.\nExtract fields with grep.\nValidate values before use.\n```\n\n**Incorrect:**\n```\nYou can parse the frontmatter...\nClaude should extract fields...\nThe user might validate values...\n```\n\n## Validation Checklist\n\nBefore finalizing a skill:\n\n**Structure:**\n- [ ] SKILL.md file exists with valid YAML frontmatter\n- [ ] Frontmatter has `name` and `description` fields\n- [ ] Markdown body is present and substantial\n- [ ] Referenced files actually exist\n\n**Description Quality:**\n- [ ] Uses third person (\"This skill should be used when...\")\n- [ ] Includes specific trigger phrases users would say\n- [ ] Lists concrete scenarios (\"create X\", \"configure Y\")\n- [ ] Not vague or generic\n\n**Content Quality:**\n- [ ] SKILL.md body uses imperative/infinitive form\n- [ ] Body is focused and lean (1,500-2,000 words ideal, <5k max)\n- [ ] Detailed content moved to references/\n- [ ] Examples are complete and working\n- [ ] Scripts are executable and documented\n\n**Progressive Disclosure:**\n- [ ] Core concepts in SKILL.md\n- [ ] Detailed docs in references/\n- [ ] Working code in examples/\n- [ ] Utilities in scripts/\n- [ ] SKILL.md references these resources\n\n**Testing:**\n- [ ] Skill triggers on expected user queries\n- [ ] Content is helpful for intended tasks\n- [ ] No duplicated information across files\n- [ ] References load when needed\n\n## Common Mistakes to Avoid\n\n### Mistake 1: Weak Trigger Description\n\nâŒ **Bad:**\n```yaml\ndescription: Provides guidance for working with hooks.\n```\n\n**Why bad:** Vague, no specific trigger phrases, not third person\n\nâœ… **Good:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", or mentions hook events. Provides comprehensive hooks API guidance.\n```\n\n**Why good:** Third person, specific phrases, concrete scenarios\n\n### Mistake 2: Too Much in SKILL.md\n\nâŒ **Bad:**\n```\nskill-name/\nâ””â”€â”€ SKILL.md  (8,000 words - everything in one file)\n```\n\n**Why bad:** Bloats context when skill loads, detailed content always loaded\n\nâœ… **Good:**\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md  (1,800 words - core essentials)\nâ””â”€â”€ references/\n    â”œâ”€â”€ patterns.md (2,500 words)\n    â””â”€â”€ advanced.md (3,700 words)\n```\n\n**Why good:** Progressive disclosure, detailed content loaded only when needed\n\n### Mistake 3: Second Person Writing\n\nâŒ **Bad:**\n```markdown\nYou should start by reading the configuration file.\nYou need to validate the input.\nYou can use the grep tool to search.\n```\n\n**Why bad:** Second person, not imperative form\n\nâœ… **Good:**\n```markdown\nStart by reading the configuration file.\nValidate the input before processing.\nUse the grep tool to search for patterns.\n```\n\n**Why good:** Imperative form, direct instructions\n\n### Mistake 4: Missing Resource References\n\nâŒ **Bad:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n[No mention of references/ or examples/]\n```\n\n**Why bad:** Claude doesn't know references exist\n\nâœ… **Good:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n## Additional Resources\n\n### Reference Files\n- **`references/patterns.md`** - Detailed patterns\n- **`references/advanced.md`** - Advanced techniques\n\n### Examples\n- **`examples/script.sh`** - Working example\n```\n\n**Why good:** Claude knows where to find additional information\n\n## Quick Reference\n\n### Minimal Skill\n\n```\nskill-name/\nâ””â”€â”€ SKILL.md\n```\n\nGood for: Simple knowledge, no complex resources needed\n\n### Standard Skill (Recommended)\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md\nâ”œâ”€â”€ references/\nâ”‚   â””â”€â”€ detailed-guide.md\nâ””â”€â”€ examples/\n    â””â”€â”€ working-example.sh\n```\n\nGood for: Most plugin skills with detailed documentation\n\n### Complete Skill\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md\nâ”œâ”€â”€ references/\nâ”‚   â”œâ”€â”€ patterns.md\nâ”‚   â””â”€â”€ advanced.md\nâ”œâ”€â”€ examples/\nâ”‚   â”œâ”€â”€ example1.sh\nâ”‚   â””â”€â”€ example2.json\nâ””â”€â”€ scripts/\n    â””â”€â”€ validate.sh\n```\n\nGood for: Complex domains with validation utilities\n\n## Best Practices Summary\n\nâœ… **DO:**\n- Use third-person in description (\"This skill should be used when...\")\n- Include specific trigger phrases (\"create X\", \"configure Y\")\n- Keep SKILL.md lean (1,500-2,000 words)\n- Use progressive disclosure (move details to references/)\n- Write in imperative/infinitive form\n- Reference supporting files clearly\n- Provide working examples\n- Create utility scripts for common operations\n- Study plugin-dev's skills as templates\n\nâŒ **DON'T:**\n- Use second person anywhere\n- Have vague trigger conditions\n- Put everything in SKILL.md (>3,000 words without references/)\n- Write in second person (\"You should...\")\n- Leave resources unreferenced\n- Include broken or incomplete examples\n- Skip validation\n\n## Additional Resources\n\n### Study These Skills\n\nPlugin-dev's skills demonstrate best practices:\n- `../hook-development/` - Progressive disclosure, utilities\n- `../agent-development/` - AI-assisted creation, references\n- `../mcp-integration/` - Comprehensive references\n- `../plugin-settings/` - Real-world examples\n- `../command-development/` - Clear critical concepts\n- `../plugin-structure/` - Good organization\n\n### Reference Files\n\nFor complete skill-creator methodology:\n- **`references/skill-creator-original.md`** - Full original skill-creator content\n\n## Implementation Workflow\n\nTo create a skill for your plugin:\n\n1. **Understand use cases**: Identify concrete examples of skill usage\n2. **Plan resources**: Determine what scripts/references/examples needed\n3. **Create structure**: `mkdir -p skills/skill-name/{references,examples,scripts}`\n4. **Write SKILL.md**:\n   - Frontmatter with third-person description and trigger phrases\n   - Lean body (1,500-2,000 words) in imperative form\n   - Reference supporting files\n5. **Add resources**: Create references/, examples/, scripts/ as needed\n6. **Validate**: Check description, writing style, organization\n7. **Test**: Verify skill loads on expected triggers\n8. **Iterate**: Improve based on usage\n\nFocus on strong trigger descriptions, progressive disclosure, and imperative writing style for effective skills that load when needed and provide targeted guidance."
              }
            ]
          },
          {
            "name": "slack",
            "description": "Slack workspace integration. Search messages, access channels, read threads, and stay connected with your team's communications while coding. Find relevant discussions and context quickly.",
            "source": "./external_plugins/slack",
            "category": "productivity",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install slack@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "vercel",
            "description": "Vercel deployment platform integration. Manage deployments, check build status, access logs, configure domains, and control your frontend infrastructure directly from Claude Code.",
            "source": {
              "source": "url",
              "url": "https://github.com/vercel/vercel-deploy-claude-code-plugin.git"
            },
            "category": "deployment",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install vercel@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [
              {
                "name": "/explain-error",
                "description": "Explain Stripe error codes and provide solutions with code examples",
                "path": "external_plugins/stripe/commands/explain-error.md",
                "frontmatter": {
                  "description": "Explain Stripe error codes and provide solutions with code examples",
                  "argument-hint": [
                    "error_code or error_message"
                  ]
                },
                "content": "# Explain Stripe Error\n\nProvide a comprehensive explanation of the given Stripe error code or error message:\n\n1. Accept the error code or full error message from the arguments\n2. Explain in plain English what the error means\n3. List common causes of this error\n4. Provide specific solutions and handling recommendations\n5. Generate error handling code in the project's language showing:\n   - How to catch this specific error\n   - User-friendly error messages\n   - Whether retry is appropriate\n6. Mention related error codes the developer should be aware of\n7. Include a link to the relevant Stripe documentation\n\nFocus on actionable solutions and production-ready error handling patterns."
              },
              {
                "name": "/test-cards",
                "description": "Display Stripe test card numbers for various testing scenarios",
                "path": "external_plugins/stripe/commands/test-cards.md",
                "frontmatter": {
                  "description": "Display Stripe test card numbers for various testing scenarios",
                  "argument-hint": [
                    "scenario"
                  ]
                },
                "content": "# Test Cards Reference\n\nProvide a quick reference for Stripe test card numbers:\n\n1. If a scenario argument is provided (e.g., \"declined\", \"3dsecure\", \"fraud\"), show relevant test cards for that scenario\n2. Otherwise, show the most common test cards organized by category:\n   - Successful payment (default card)\n   - 3D Secure authentication required\n   - Generic decline\n   - Specific decline reasons (insufficient_funds, lost_card, etc.)\n3. For each card, display:\n   - Card number (formatted with spaces)\n   - Expected behavior\n   - Expiry/CVC info (any future date and any 3-digit CVC)\n4. Use clear visual indicators (âœ“ for success, âš ï¸ for auth required, âœ— for decline)\n5. Mention that these only work in test mode\n6. Provide link to full testing documentation: https://docs.stripe.com/testing.md\n\nIf the user is currently working on test code, offer to generate test cases using these cards."
              },
              {
                "name": "/new-sdk-app",
                "description": "Create and setup a new Claude Agent SDK application",
                "path": "plugins/agent-sdk-dev/commands/new-sdk-app.md",
                "frontmatter": {
                  "description": "Create and setup a new Claude Agent SDK application",
                  "argument-hint": [
                    "project-name"
                  ]
                },
                "content": "You are tasked with helping the user create a new Claude Agent SDK application. Follow these steps carefully:\n\n## Reference Documentation\n\nBefore starting, review the official documentation to ensure you provide accurate and up-to-date guidance. Use WebFetch to read these pages:\n\n1. **Start with the overview**: https://docs.claude.com/en/api/agent-sdk/overview\n2. **Based on the user's language choice, read the appropriate SDK reference**:\n   - TypeScript: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Python: https://docs.claude.com/en/api/agent-sdk/python\n3. **Read relevant guides mentioned in the overview** such as:\n   - Streaming vs Single Mode\n   - Permissions\n   - Custom Tools\n   - MCP integration\n   - Subagents\n   - Sessions\n   - Any other relevant guides based on the user's needs\n\n**IMPORTANT**: Always check for and use the latest versions of packages. Use WebSearch or WebFetch to verify current versions before installation.\n\n## Gather Requirements\n\nIMPORTANT: Ask these questions one at a time. Wait for the user's response before asking the next question. This makes it easier for the user to respond.\n\nAsk the questions in this order (skip any that the user has already provided via arguments):\n\n1. **Language** (ask first): \"Would you like to use TypeScript or Python?\"\n\n   - Wait for response before continuing\n\n2. **Project name** (ask second): \"What would you like to name your project?\"\n\n   - If $ARGUMENTS is provided, use that as the project name and skip this question\n   - Wait for response before continuing\n\n3. **Agent type** (ask third, but skip if #2 was sufficiently detailed): \"What kind of agent are you building? Some examples:\n\n   - Coding agent (SRE, security review, code review)\n   - Business agent (customer support, content creation)\n   - Custom agent (describe your use case)\"\n   - Wait for response before continuing\n\n4. **Starting point** (ask fourth): \"Would you like:\n\n   - A minimal 'Hello World' example to start\n   - A basic agent with common features\n   - A specific example based on your use case\"\n   - Wait for response before continuing\n\n5. **Tooling choice** (ask fifth): Let the user know what tools you'll use, and confirm with them that these are the tools they want to use (for example, they may prefer pnpm or bun over npm). Respect the user's preferences when executing on the requirements.\n\nAfter all questions are answered, proceed to create the setup plan.\n\n## Setup Plan\n\nBased on the user's answers, create a plan that includes:\n\n1. **Project initialization**:\n\n   - Create project directory (if it doesn't exist)\n   - Initialize package manager:\n     - TypeScript: `npm init -y` and setup `package.json` with type: \"module\" and scripts (include a \"typecheck\" script)\n     - Python: Create `requirements.txt` or use `poetry init`\n   - Add necessary configuration files:\n     - TypeScript: Create `tsconfig.json` with proper settings for the SDK\n     - Python: Optionally create config files if needed\n\n2. **Check for Latest Versions**:\n\n   - BEFORE installing, use WebSearch or check npm/PyPI to find the latest version\n   - For TypeScript: Check https://www.npmjs.com/package/@anthropic-ai/claude-agent-sdk\n   - For Python: Check https://pypi.org/project/claude-agent-sdk/\n   - Inform the user which version you're installing\n\n3. **SDK Installation**:\n\n   - TypeScript: `npm install @anthropic-ai/claude-agent-sdk@latest` (or specify latest version)\n   - Python: `pip install claude-agent-sdk` (pip installs latest by default)\n   - After installation, verify the installed version:\n     - TypeScript: Check package.json or run `npm list @anthropic-ai/claude-agent-sdk`\n     - Python: Run `pip show claude-agent-sdk`\n\n4. **Create starter files**:\n\n   - TypeScript: Create an `index.ts` or `src/index.ts` with a basic query example\n   - Python: Create a `main.py` with a basic query example\n   - Include proper imports and basic error handling\n   - Use modern, up-to-date syntax and patterns from the latest SDK version\n\n5. **Environment setup**:\n\n   - Create a `.env.example` file with `ANTHROPIC_API_KEY=your_api_key_here`\n   - Add `.env` to `.gitignore`\n   - Explain how to get an API key from https://console.anthropic.com/\n\n6. **Optional: Create .claude directory structure**:\n   - Offer to create `.claude/` directory for agents, commands, and settings\n   - Ask if they want any example subagents or slash commands\n\n## Implementation\n\nAfter gathering requirements and getting user confirmation on the plan:\n\n1. Check for latest package versions using WebSearch or WebFetch\n2. Execute the setup steps\n3. Create all necessary files\n4. Install dependencies (always use latest stable versions)\n5. Verify installed versions and inform the user\n6. Create a working example based on their agent type\n7. Add helpful comments in the code explaining what each part does\n8. **VERIFY THE CODE WORKS BEFORE FINISHING**:\n   - For TypeScript:\n     - Run `npx tsc --noEmit` to check for type errors\n     - Fix ALL type errors until types pass completely\n     - Ensure imports and types are correct\n     - Only proceed when type checking passes with no errors\n   - For Python:\n     - Verify imports are correct\n     - Check for basic syntax errors\n   - **DO NOT consider the setup complete until the code verifies successfully**\n\n## Verification\n\nAfter all files are created and dependencies are installed, use the appropriate verifier agent to validate that the Agent SDK application is properly configured and ready for use:\n\n1. **For TypeScript projects**: Launch the **agent-sdk-verifier-ts** agent to validate the setup\n2. **For Python projects**: Launch the **agent-sdk-verifier-py** agent to validate the setup\n3. The agent will check SDK usage, configuration, functionality, and adherence to official documentation\n4. Review the verification report and address any issues\n\n## Getting Started Guide\n\nOnce setup is complete and verified, provide the user with:\n\n1. **Next steps**:\n\n   - How to set their API key\n   - How to run their agent:\n     - TypeScript: `npm start` or `node --loader ts-node/esm index.ts`\n     - Python: `python main.py`\n\n2. **Useful resources**:\n\n   - Link to TypeScript SDK reference: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Link to Python SDK reference: https://docs.claude.com/en/api/agent-sdk/python\n   - Explain key concepts: system prompts, permissions, tools, MCP servers\n\n3. **Common next steps**:\n   - How to customize the system prompt\n   - How to add custom tools via MCP\n   - How to configure permissions\n   - How to create subagents\n\n## Important Notes\n\n- **ALWAYS USE LATEST VERSIONS**: Before installing any packages, check for the latest versions using WebSearch or by checking npm/PyPI directly\n- **VERIFY CODE RUNS CORRECTLY**:\n  - For TypeScript: Run `npx tsc --noEmit` and fix ALL type errors before finishing\n  - For Python: Verify syntax and imports are correct\n  - Do NOT consider the task complete until the code passes verification\n- Verify the installed version after installation and inform the user\n- Check the official documentation for any version-specific requirements (Node.js version, Python version, etc.)\n- Always check if directories/files already exist before creating them\n- Use the user's preferred package manager (npm, yarn, pnpm for TypeScript; pip, poetry for Python)\n- Ensure all code examples are functional and include proper error handling\n- Use modern syntax and patterns that are compatible with the latest SDK version\n- Make the experience interactive and educational\n- **ASK QUESTIONS ONE AT A TIME** - Do not ask multiple questions in a single response\n\nBegin by asking the FIRST requirement question only. Wait for the user's answer before proceeding to the next question."
              },
              {
                "name": "/code-review",
                "description": "Code review a pull request",
                "path": "plugins/code-review/commands/code-review.md",
                "frontmatter": {
                  "allowed-tools": "Bash(gh issue view:*), Bash(gh search:*), Bash(gh issue list:*), Bash(gh pr comment:*), Bash(gh pr diff:*), Bash(gh pr view:*), Bash(gh pr list:*)",
                  "description": "Code review a pull request",
                  "disable-model-invocation": false
                },
                "content": "Provide a code review for the given pull request.\n\nTo do this, follow these steps precisely:\n\n1. Use a Haiku agent to check if the pull request (a) is closed, (b) is a draft, (c) does not need a code review (eg. because it is an automated pull request, or is very simple and obviously ok), or (d) already has a code review from you from earlier. If so, do not proceed.\n2. Use another Haiku agent to give you a list of file paths to (but not the contents of) any relevant CLAUDE.md files from the codebase: the root CLAUDE.md file (if one exists), as well as any CLAUDE.md files in the directories whose files the pull request modified\n3. Use a Haiku agent to view the pull request, and ask the agent to return a summary of the change\n4. Then, launch 5 parallel Sonnet agents to independently code review the change. The agents should do the following, then return a list of issues and the reason each issue was flagged (eg. CLAUDE.md adherence, bug, historical git context, etc.):\n   a. Agent #1: Audit the changes to make sure they compily with the CLAUDE.md. Note that CLAUDE.md is guidance for Claude as it writes code, so not all instructions will be applicable during code review.\n   b. Agent #2: Read the file changes in the pull request, then do a shallow scan for obvious bugs. Avoid reading extra context beyond the changes, focusing just on the changes themselves. Focus on large bugs, and avoid small issues and nitpicks. Ignore likely false positives.\n   c. Agent #3: Read the git blame and history of the code modified, to identify any bugs in light of that historical context\n   d. Agent #4: Read previous pull requests that touched these files, and check for any comments on those pull requests that may also apply to the current pull request.\n   e. Agent #5: Read code comments in the modified files, and make sure the changes in the pull request comply with any guidance in the comments.\n5. For each issue found in #4, launch a parallel Haiku agent that takes the PR, issue description, and list of CLAUDE.md files (from step 2), and returns a score to indicate the agent's level of confidence for whether the issue is real or false positive. To do that, the agent should score each issue on a scale from 0-100, indicating its level of confidence. For issues that were flagged due to CLAUDE.md instructions, the agent should double check that the CLAUDE.md actually calls out that issue specifically. The scale is (give this rubric to the agent verbatim):\n   a. 0: Not confident at all. This is a false positive that doesn't stand up to light scrutiny, or is a pre-existing issue.\n   b. 25: Somewhat confident. This might be a real issue, but may also be a false positive. The agent wasn't able to verify that it's a real issue. If the issue is stylistic, it is one that was not explicitly called out in the relevant CLAUDE.md.\n   c. 50: Moderately confident. The agent was able to verify this is a real issue, but it might be a nitpick or not happen very often in practice. Relative to the rest of the PR, it's not very important.\n   d. 75: Highly confident. The agent double checked the issue, and verified that it is very likely it is a real issue that will be hit in practice. The existing approach in the PR is insufficient. The issue is very important and will directly impact the code's functionality, or it is an issue that is directly mentioned in the relevant CLAUDE.md.\n   e. 100: Absolutely certain. The agent double checked the issue, and confirmed that it is definitely a real issue, that will happen frequently in practice. The evidence directly confirms this.\n6. Filter out any issues with a score less than 80. If there are no issues that meet this criteria, do not proceed.\n7. Use a Haiku agent to repeat the eligibility check from #1, to make sure that the pull request is still eligible for code review.\n8. Finally, use the gh bash command to comment back on the pull request with the result. When writing your comment, keep in mind to:\n   a. Keep your output brief\n   b. Avoid emojis\n   c. Link and cite relevant code, files, and URLs\n\nExamples of false positives, for steps 4 and 5:\n\n- Pre-existing issues\n- Something that looks like a bug but is not actually a bug\n- Pedantic nitpicks that a senior engineer wouldn't call out\n- Issues that a linter, typechecker, or compiler would catch (eg. missing or incorrect imports, type errors, broken tests, formatting issues, pedantic style issues like newlines). No need to run these build steps yourself -- it is safe to assume that they will be run separately as part of CI.\n- General code quality issues (eg. lack of test coverage, general security issues, poor documentation), unless explicitly required in CLAUDE.md\n- Issues that are called out in CLAUDE.md, but explicitly silenced in the code (eg. due to a lint ignore comment)\n- Changes in functionality that are likely intentional or are directly related to the broader change\n- Real issues, but on lines that the user did not modify in their pull request\n\nNotes:\n\n- Do not check build signal or attempt to build or typecheck the app. These will run separately, and are not relevant to your code review.\n- Use `gh` to interact with Github (eg. to fetch a pull request, or to create inline comments), rather than web fetch\n- Make a todo list first\n- You must cite and link each bug (eg. if referring to a CLAUDE.md, you must link it)\n- For your final comment, follow the following format precisely (assuming for this example that you found 3 issues):\n\n---\n\n### Code review\n\nFound 3 issues:\n\n1. <brief description of bug> (CLAUDE.md says \"<...>\")\n\n<link to file and line with full sha1 + line range for context, note that you MUST provide the full sha and not use bash here, eg. https://github.com/anthropics/claude-code/blob/1d54823877c4de72b2316a64032a54afc404e619/README.md#L13-L17>\n\n2. <brief description of bug> (some/other/CLAUDE.md says \"<...>\")\n\n<link to file and line with full sha1 + line range for context>\n\n3. <brief description of bug> (bug due to <file and code snippet>)\n\n<link to file and line with full sha1 + line range for context>\n\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\n<sub>- If this code review was useful, please react with ðŸ‘. Otherwise, react with ðŸ‘Ž.</sub>\n\n---\n\n- Or, if you found no issues:\n\n---\n\n### Code review\n\nNo issues found. Checked for bugs and CLAUDE.md compliance.\n\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\n- When linking to code, follow the following format precisely, otherwise the Markdown preview won't render correctly: https://github.com/anthropics/claude-cli-internal/blob/c21d3c10bc8e898b7ac1a2d745bdc9bc4e423afe/package.json#L10-L15\n  - Requires full git sha\n  - You must provide the full sha. Commands like `https://github.com/owner/repo/blob/$(git rev-parse HEAD)/foo/bar` will not work, since your comment will be directly rendered in Markdown.\n  - Repo name must match the repo you're code reviewing\n  - # sign after the file name\n  - Line range format is L[start]-L[end]\n  - Provide at least 1 line of context before and after, centered on the line you are commenting about (eg. if you are commenting about lines 5-6, you should link to `L4-7`)"
              },
              {
                "name": "/clean_gone",
                "description": "Cleans up all git branches marked as [gone] (branches that have been deleted on the remote but still exist locally), including removing associated worktrees.",
                "path": "plugins/commit-commands/commands/clean_gone.md",
                "frontmatter": {
                  "description": "Cleans up all git branches marked as [gone] (branches that have been deleted on the remote but still exist locally), including removing associated worktrees."
                },
                "content": "## Your Task\n\nYou need to execute the following bash commands to clean up stale local branches that have been deleted from the remote repository.\n\n## Commands to Execute\n\n1. **First, list branches to identify any with [gone] status**\n   Execute this command:\n   ```bash\n   git branch -v\n   ```\n   \n   Note: Branches with a '+' prefix have associated worktrees and must have their worktrees removed before deletion.\n\n2. **Next, identify worktrees that need to be removed for [gone] branches**\n   Execute this command:\n   ```bash\n   git worktree list\n   ```\n\n3. **Finally, remove worktrees and delete [gone] branches (handles both regular and worktree branches)**\n   Execute this command:\n   ```bash\n   # Process all [gone] branches, removing '+' prefix if present\n   git branch -v | grep '\\[gone\\]' | sed 's/^[+* ]//' | awk '{print $1}' | while read branch; do\n     echo \"Processing branch: $branch\"\n     # Find and remove worktree if it exists\n     worktree=$(git worktree list | grep \"\\\\[$branch\\\\]\" | awk '{print $1}')\n     if [ ! -z \"$worktree\" ] && [ \"$worktree\" != \"$(git rev-parse --show-toplevel)\" ]; then\n       echo \"  Removing worktree: $worktree\"\n       git worktree remove --force \"$worktree\"\n     fi\n     # Delete the branch\n     echo \"  Deleting branch: $branch\"\n     git branch -D \"$branch\"\n   done\n   ```\n\n## Expected Behavior\n\nAfter executing these commands, you will:\n\n- See a list of all local branches with their status\n- Identify and remove any worktrees associated with [gone] branches\n- Delete all branches marked as [gone]\n- Provide feedback on which worktrees and branches were removed\n\nIf no branches are marked as [gone], report that no cleanup was needed."
              },
              {
                "name": "/commit-push-pr",
                "description": "Commit, push, and open a PR",
                "path": "plugins/commit-commands/commands/commit-push-pr.md",
                "frontmatter": {
                  "allowed-tools": "Bash(git checkout --branch:*), Bash(git add:*), Bash(git status:*), Bash(git push:*), Bash(git commit:*), Bash(gh pr create:*)",
                  "description": "Commit, push, and open a PR"
                },
                "content": "## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n\n## Your task\n\nBased on the above changes:\n\n1. Create a new branch if on main\n2. Create a single commit with an appropriate message\n3. Push the branch to origin\n4. Create a pull request using `gh pr create`\n5. You have the capability to call multiple tools in a single response. You MUST do all of the above in a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls."
              },
              {
                "name": "/commit",
                "description": "Create a git commit",
                "path": "plugins/commit-commands/commands/commit.md",
                "frontmatter": {
                  "allowed-tools": "Bash(git add:*), Bash(git status:*), Bash(git commit:*)",
                  "description": "Create a git commit"
                },
                "content": "## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n- Recent commits: !`git log --oneline -10`\n\n## Your task\n\nBased on the above changes, create a single git commit.\n\nYou have the capability to call multiple tools in a single response. Stage and create the commit using a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls."
              },
              {
                "name": "/example-command",
                "description": "An example slash command that demonstrates command frontmatter options",
                "path": "plugins/example-plugin/commands/example-command.md",
                "frontmatter": {
                  "description": "An example slash command that demonstrates command frontmatter options",
                  "argument-hint": "<required-arg> [optional-arg]",
                  "allowed-tools": [
                    "Read",
                    "Glob",
                    "Grep",
                    "Bash"
                  ]
                },
                "content": "# Example Command\n\nThis command demonstrates slash command structure and frontmatter options.\n\n## Arguments\n\nThe user invoked this command with: $ARGUMENTS\n\n## Instructions\n\nWhen this command is invoked:\n\n1. Parse the arguments provided by the user\n2. Perform the requested action using allowed tools\n3. Report results back to the user\n\n## Frontmatter Options Reference\n\nCommands support these frontmatter fields:\n\n- **description**: Short description shown in /help\n- **argument-hint**: Hints for command arguments shown to user\n- **allowed-tools**: Pre-approved tools for this command (reduces permission prompts)\n- **model**: Override the model (e.g., \"haiku\", \"sonnet\", \"opus\")\n\n## Example Usage\n\n```\n/example-command my-argument\n/example-command arg1 arg2\n```"
              },
              {
                "name": "/feature-dev",
                "description": "Guided feature development with codebase understanding and architecture focus",
                "path": "plugins/feature-dev/commands/feature-dev.md",
                "frontmatter": {
                  "description": "Guided feature development with codebase understanding and architecture focus",
                  "argument-hint": "Optional feature description"
                },
                "content": "# Feature Development\n\nYou are helping a developer implement a new feature. Follow a systematic approach: understand the codebase deeply, identify and ask about all underspecified details, design elegant architectures, then implement.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities, edge cases, and underspecified behaviors. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation. Ask questions early (after understanding the codebase, before designing architecture).\n- **Understand before acting**: Read and comprehend existing code patterns first\n- **Read files identified by agents**: When launching agents, ask them to return lists of the most important files to read. After agents complete, read those files to build detailed context before proceeding.\n- **Simple and elegant**: Prioritize readable, maintainable, architecturally sound code\n- **Use TodoWrite**: Track all progress throughout\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what needs to be built\n\nInitial request: $ARGUMENTS\n\n**Actions**:\n1. Create todo list with all phases\n2. If feature unclear, ask user for:\n   - What problem are they solving?\n   - What should the feature do?\n   - Any constraints or requirements?\n3. Summarize understanding and confirm with user\n\n---\n\n## Phase 2: Codebase Exploration\n\n**Goal**: Understand relevant existing code and patterns at both high and low levels\n\n**Actions**:\n1. Launch 2-3 code-explorer agents in parallel. Each agent should:\n   - Trace through the code comprehensively and focus on getting a comprehensive understanding of abstractions, architecture and flow of control\n   - Target a different aspect of the codebase (eg. similar features, high level understanding, architectural understanding, user experience, etc)\n   - Include a list of 5-10 key files to read\n\n   **Example agent prompts**:\n   - \"Find features similar to [feature] and trace through their implementation comprehensively\"\n   - \"Map the architecture and abstractions for [feature area], tracing through the code comprehensively\"\n   - \"Analyze the current implementation of [existing feature/area], tracing through the code comprehensively\"\n   - \"Identify UI patterns, testing approaches, or extension points relevant to [feature]\"\n\n2. Once the agents return, please read all files identified by agents to build deep understanding\n3. Present comprehensive summary of findings and patterns discovered\n\n---\n\n## Phase 3: Clarifying Questions\n\n**Goal**: Fill in gaps and resolve all ambiguities before designing\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. Review the codebase findings and original feature request\n2. Identify underspecified aspects: edge cases, error handling, integration points, scope boundaries, design preferences, backward compatibility, performance needs\n3. **Present all questions to the user in a clear, organized list**\n4. **Wait for answers before proceeding to architecture design**\n\nIf the user says \"whatever you think is best\", provide your recommendation and get explicit confirmation.\n\n---\n\n## Phase 4: Architecture Design\n\n**Goal**: Design multiple implementation approaches with different trade-offs\n\n**Actions**:\n1. Launch 2-3 code-architect agents in parallel with different focuses: minimal changes (smallest change, maximum reuse), clean architecture (maintainability, elegant abstractions), or pragmatic balance (speed + quality)\n2. Review all approaches and form your opinion on which fits best for this specific task (consider: small fix vs large feature, urgency, complexity, team context)\n3. Present to user: brief summary of each approach, trade-offs comparison, **your recommendation with reasoning**, concrete implementation differences\n4. **Ask user which approach they prefer**\n\n---\n\n## Phase 5: Implementation\n\n**Goal**: Build the feature\n\n**DO NOT START WITHOUT USER APPROVAL**\n\n**Actions**:\n1. Wait for explicit user approval\n2. Read all relevant files identified in previous phases\n3. Implement following chosen architecture\n4. Follow codebase conventions strictly\n5. Write clean, well-documented code\n6. Update todos as you progress\n\n---\n\n## Phase 6: Quality Review\n\n**Goal**: Ensure code is simple, DRY, elegant, easy to read, and functionally correct\n\n**Actions**:\n1. Launch 3 code-reviewer agents in parallel with different focuses: simplicity/DRY/elegance, bugs/functional correctness, project conventions/abstractions\n2. Consolidate findings and identify highest severity issues that you recommend fixing\n3. **Present findings to user and ask what they want to do** (fix now, fix later, or proceed as-is)\n4. Address issues based on user decision\n\n---\n\n## Phase 7: Summary\n\n**Goal**: Document what was accomplished\n\n**Actions**:\n1. Mark all todos complete\n2. Summarize:\n   - What was built\n   - Key decisions made\n   - Files modified\n   - Suggested next steps\n\n---"
              },
              {
                "name": "/configure",
                "description": "Enable or disable hookify rules interactively",
                "path": "plugins/hookify/commands/configure.md",
                "frontmatter": {
                  "description": "Enable or disable hookify rules interactively",
                  "allowed-tools": [
                    "Glob",
                    "Read",
                    "Edit",
                    "AskUserQuestion",
                    "Skill"
                  ]
                },
                "content": "# Configure Hookify Rules\n\n**Load hookify:writing-rules skill first** to understand rule format.\n\nEnable or disable existing hookify rules using an interactive interface.\n\n## Steps\n\n### 1. Find Existing Rules\n\nUse Glob tool to find all hookify rule files:\n```\npattern: \".claude/hookify.*.local.md\"\n```\n\nIf no rules found, inform user:\n```\nNo hookify rules configured yet. Use `/hookify` to create your first rule.\n```\n\n### 2. Read Current State\n\nFor each rule file:\n- Read the file\n- Extract `name` and `enabled` fields from frontmatter\n- Build list of rules with current state\n\n### 3. Ask User Which Rules to Toggle\n\nUse AskUserQuestion to let user select rules:\n\n```json\n{\n  \"questions\": [\n    {\n      \"question\": \"Which rules would you like to enable or disable?\",\n      \"header\": \"Configure\",\n      \"multiSelect\": true,\n      \"options\": [\n        {\n          \"label\": \"warn-dangerous-rm (currently enabled)\",\n          \"description\": \"Warns about rm -rf commands\"\n        },\n        {\n          \"label\": \"warn-console-log (currently disabled)\",\n          \"description\": \"Warns about console.log in code\"\n        },\n        {\n          \"label\": \"require-tests (currently enabled)\",\n          \"description\": \"Requires tests before stopping\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Option format:**\n- Label: `{rule-name} (currently {enabled|disabled})`\n- Description: Brief description from rule's message or pattern\n\n### 4. Parse User Selection\n\nFor each selected rule:\n- Determine current state from label (enabled/disabled)\n- Toggle state: enabled â†’ disabled, disabled â†’ enabled\n\n### 5. Update Rule Files\n\nFor each rule to toggle:\n- Use Read tool to read current content\n- Use Edit tool to change `enabled: true` to `enabled: false` (or vice versa)\n- Handle both with and without quotes\n\n**Edit pattern for enabling:**\n```\nold_string: \"enabled: false\"\nnew_string: \"enabled: true\"\n```\n\n**Edit pattern for disabling:**\n```\nold_string: \"enabled: true\"\nnew_string: \"enabled: false\"\n```\n\n### 6. Confirm Changes\n\nShow user what was changed:\n\n```\n## Hookify Rules Updated\n\n**Enabled:**\n- warn-console-log\n\n**Disabled:**\n- warn-dangerous-rm\n\n**Unchanged:**\n- require-tests\n\nChanges apply immediately - no restart needed\n```\n\n## Important Notes\n\n- Changes take effect immediately on next tool use\n- You can also manually edit .claude/hookify.*.local.md files\n- To permanently remove a rule, delete its .local.md file\n- Use `/hookify:list` to see all configured rules\n\n## Edge Cases\n\n**No rules to configure:**\n- Show message about using `/hookify` to create rules first\n\n**User selects no rules:**\n- Inform that no changes were made\n\n**File read/write errors:**\n- Inform user of specific error\n- Suggest manual editing as fallback"
              },
              {
                "name": "/help",
                "description": "Get help with the hookify plugin",
                "path": "plugins/hookify/commands/help.md",
                "frontmatter": {
                  "description": "Get help with the hookify plugin",
                  "allowed-tools": [
                    "Read"
                  ]
                },
                "content": "# Hookify Plugin Help\n\nExplain how the hookify plugin works and how to use it.\n\n## Overview\n\nThe hookify plugin makes it easy to create custom hooks that prevent unwanted behaviors. Instead of editing `hooks.json` files, users create simple markdown configuration files that define patterns to watch for.\n\n## How It Works\n\n### 1. Hook System\n\nHookify installs generic hooks that run on these events:\n- **PreToolUse**: Before any tool executes (Bash, Edit, Write, etc.)\n- **PostToolUse**: After a tool executes\n- **Stop**: When Claude wants to stop working\n- **UserPromptSubmit**: When user submits a prompt\n\nThese hooks read configuration files from `.claude/hookify.*.local.md` and check if any rules match the current operation.\n\n### 2. Configuration Files\n\nUsers create rules in `.claude/hookify.{rule-name}.local.md` files:\n\n```markdown\n---\nname: warn-dangerous-rm\nenabled: true\nevent: bash\npattern: rm\\s+-rf\n---\n\nâš ï¸ **Dangerous rm command detected!**\n\nThis command could delete important files. Please verify the path.\n```\n\n**Key fields:**\n- `name`: Unique identifier for the rule\n- `enabled`: true/false to activate/deactivate\n- `event`: bash, file, stop, prompt, or all\n- `pattern`: Regex pattern to match\n\nThe message body is what Claude sees when the rule triggers.\n\n### 3. Creating Rules\n\n**Option A: Use /hookify command**\n```\n/hookify Don't use console.log in production files\n```\n\nThis analyzes your request and creates the appropriate rule file.\n\n**Option B: Create manually**\nCreate `.claude/hookify.my-rule.local.md` with the format above.\n\n**Option C: Analyze conversation**\n```\n/hookify\n```\n\nWithout arguments, hookify analyzes recent conversation to find behaviors you want to prevent.\n\n## Available Commands\n\n- **`/hookify`** - Create hooks from conversation analysis or explicit instructions\n- **`/hookify:help`** - Show this help (what you're reading now)\n- **`/hookify:list`** - List all configured hooks\n- **`/hookify:configure`** - Enable/disable existing hooks interactively\n\n## Example Use Cases\n\n**Prevent dangerous commands:**\n```markdown\n---\nname: block-chmod-777\nenabled: true\nevent: bash\npattern: chmod\\s+777\n---\n\nDon't use chmod 777 - it's a security risk. Use specific permissions instead.\n```\n\n**Warn about debugging code:**\n```markdown\n---\nname: warn-console-log\nenabled: true\nevent: file\npattern: console\\.log\\(\n---\n\nConsole.log detected. Remember to remove debug logging before committing.\n```\n\n**Require tests before stopping:**\n```markdown\n---\nname: require-tests\nenabled: true\nevent: stop\npattern: .*\n---\n\nDid you run tests before finishing? Make sure `npm test` or equivalent was executed.\n```\n\n## Pattern Syntax\n\nUse Python regex syntax:\n- `\\s` - whitespace\n- `\\.` - literal dot\n- `|` - OR\n- `+` - one or more\n- `*` - zero or more\n- `\\d` - digit\n- `[abc]` - character class\n\n**Examples:**\n- `rm\\s+-rf` - matches \"rm -rf\"\n- `console\\.log\\(` - matches \"console.log(\"\n- `(eval|exec)\\(` - matches \"eval(\" or \"exec(\"\n- `\\.env$` - matches files ending in .env\n\n## Important Notes\n\n**No Restart Needed**: Hookify rules (`.local.md` files) take effect immediately on the next tool use. The hookify hooks are already loaded and read your rules dynamically.\n\n**Block or Warn**: Rules can either `block` operations (prevent execution) or `warn` (show message but allow). Set `action: block` or `action: warn` in the rule's frontmatter.\n\n**Rule Files**: Keep rules in `.claude/hookify.*.local.md` - they should be git-ignored (add to .gitignore if needed).\n\n**Disable Rules**: Set `enabled: false` in frontmatter or delete the file.\n\n## Troubleshooting\n\n**Hook not triggering:**\n- Check rule file is in `.claude/` directory\n- Verify `enabled: true` in frontmatter\n- Confirm pattern is valid regex\n- Test pattern: `python3 -c \"import re; print(re.search('your_pattern', 'test_text'))\"`\n- Rules take effect immediately - no restart needed\n\n**Import errors:**\n- Check Python 3 is available: `python3 --version`\n- Verify hookify plugin is installed correctly\n\n**Pattern not matching:**\n- Test regex separately\n- Check for escaping issues (use unquoted patterns in YAML)\n- Try simpler pattern first, then refine\n\n## Getting Started\n\n1. Create your first rule:\n   ```\n   /hookify Warn me when I try to use rm -rf\n   ```\n\n2. Try to trigger it:\n   - Ask Claude to run `rm -rf /tmp/test`\n   - You should see the warning\n\n4. Refine the rule by editing `.claude/hookify.warn-rm.local.md`\n\n5. Create more rules as you encounter unwanted behaviors\n\nFor more examples, check the `${CLAUDE_PLUGIN_ROOT}/examples/` directory."
              },
              {
                "name": "/hookify",
                "description": "Create hooks to prevent unwanted behaviors from conversation analysis or explicit instructions",
                "path": "plugins/hookify/commands/hookify.md",
                "frontmatter": {
                  "description": "Create hooks to prevent unwanted behaviors from conversation analysis or explicit instructions",
                  "argument-hint": "Optional specific behavior to address",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "AskUserQuestion",
                    "Task",
                    "Grep",
                    "TodoWrite",
                    "Skill"
                  ]
                },
                "content": "# Hookify - Create Hooks from Unwanted Behaviors\n\n**FIRST: Load the hookify:writing-rules skill** using the Skill tool to understand rule file format and syntax.\n\nCreate hook rules to prevent problematic behaviors by analyzing the conversation or from explicit user instructions.\n\n## Your Task\n\nYou will help the user create hookify rules to prevent unwanted behaviors. Follow these steps:\n\n### Step 1: Gather Behavior Information\n\n**If $ARGUMENTS is provided:**\n- User has given specific instructions: `$ARGUMENTS`\n- Still analyze recent conversation (last 10-15 user messages) for additional context\n- Look for examples of the behavior happening\n\n**If $ARGUMENTS is empty:**\n- Launch the conversation-analyzer agent to find problematic behaviors\n- Agent will scan user prompts for frustration signals\n- Agent will return structured findings\n\n**To analyze conversation:**\nUse the Task tool to launch conversation-analyzer agent:\n```\n{\n  \"subagent_type\": \"general-purpose\",\n  \"description\": \"Analyze conversation for unwanted behaviors\",\n  \"prompt\": \"You are analyzing a Claude Code conversation to find behaviors the user wants to prevent.\n\nRead user messages in the current conversation and identify:\n1. Explicit requests to avoid something (\\\"don't do X\\\", \\\"stop doing Y\\\")\n2. Corrections or reversions (user fixing Claude's actions)\n3. Frustrated reactions (\\\"why did you do X?\\\", \\\"I didn't ask for that\\\")\n4. Repeated issues (same problem multiple times)\n\nFor each issue found, extract:\n- What tool was used (Bash, Edit, Write, etc.)\n- Specific pattern or command\n- Why it was problematic\n- User's stated reason\n\nReturn findings as a structured list with:\n- category: Type of issue\n- tool: Which tool was involved\n- pattern: Regex or literal pattern to match\n- context: What happened\n- severity: high/medium/low\n\nFocus on the most recent issues (last 20-30 messages). Don't go back further unless explicitly asked.\"\n}\n```\n\n### Step 2: Present Findings to User\n\nAfter gathering behaviors (from arguments or agent), present to user using AskUserQuestion:\n\n**Question 1: Which behaviors to hookify?**\n- Header: \"Create Rules\"\n- multiSelect: true\n- Options: List each detected behavior (max 4)\n  - Label: Short description (e.g., \"Block rm -rf\")\n  - Description: Why it's problematic\n\n**Question 2: For each selected behavior, ask about action:**\n- \"Should this block the operation or just warn?\"\n- Options:\n  - \"Just warn\" (action: warn - shows message but allows)\n  - \"Block operation\" (action: block - prevents execution)\n\n**Question 3: Ask for example patterns:**\n- \"What patterns should trigger this rule?\"\n- Show detected patterns\n- Allow user to refine or add more\n\n### Step 3: Generate Rule Files\n\nFor each confirmed behavior, create a `.claude/hookify.{rule-name}.local.md` file:\n\n**Rule naming convention:**\n- Use kebab-case\n- Be descriptive: `block-dangerous-rm`, `warn-console-log`, `require-tests-before-stop`\n- Start with action verb: block, warn, prevent, require\n\n**File format:**\n```markdown\n---\nname: {rule-name}\nenabled: true\nevent: {bash|file|stop|prompt|all}\npattern: {regex pattern}\naction: {warn|block}\n---\n\n{Message to show Claude when rule triggers}\n```\n\n**Action values:**\n- `warn`: Show message but allow operation (default)\n- `block`: Prevent operation or stop session\n\n**For more complex rules (multiple conditions):**\n```markdown\n---\nname: {rule-name}\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$\n  - field: new_text\n    operator: contains\n    pattern: API_KEY\n---\n\n{Warning message}\n```\n\n### Step 4: Create Files and Confirm\n\n**IMPORTANT**: Rule files must be created in the current working directory's `.claude/` folder, NOT the plugin directory.\n\nUse the current working directory (where Claude Code was started) as the base path.\n\n1. Check if `.claude/` directory exists in current working directory\n   - If not, create it first with: `mkdir -p .claude`\n\n2. Use Write tool to create each `.claude/hookify.{name}.local.md` file\n   - Use relative path from current working directory: `.claude/hookify.{name}.local.md`\n   - The path should resolve to the project's .claude directory, not the plugin's\n\n3. Show user what was created:\n   ```\n   Created 3 hookify rules:\n   - .claude/hookify.dangerous-rm.local.md\n   - .claude/hookify.console-log.local.md\n   - .claude/hookify.sensitive-files.local.md\n\n   These rules will trigger on:\n   - dangerous-rm: Bash commands matching \"rm -rf\"\n   - console-log: Edits adding console.log statements\n   - sensitive-files: Edits to .env or credentials files\n   ```\n\n4. Verify files were created in the correct location by listing them\n\n5. Inform user: **\"Rules are active immediately - no restart needed!\"**\n\n   The hookify hooks are already loaded and will read your new rules on the next tool use.\n\n## Event Types Reference\n\n- **bash**: Matches Bash tool commands\n- **file**: Matches Edit, Write, MultiEdit tools\n- **stop**: Matches when agent wants to stop (use for completion checks)\n- **prompt**: Matches when user submits prompts\n- **all**: Matches all events\n\n## Pattern Writing Tips\n\n**Bash patterns:**\n- Match dangerous commands: `rm\\s+-rf|chmod\\s+777|dd\\s+if=`\n- Match specific tools: `npm\\s+install\\s+|pip\\s+install`\n\n**File patterns:**\n- Match code patterns: `console\\.log\\(|eval\\(|innerHTML\\s*=`\n- Match file paths: `\\.env$|\\.git/|node_modules/`\n\n**Stop patterns:**\n- Check for missing steps: (check transcript or completion criteria)\n\n## Example Workflow\n\n**User says**: \"/hookify Don't use rm -rf without asking me first\"\n\n**Your response**:\n1. Analyze: User wants to prevent rm -rf commands\n2. Ask: \"Should I block this command or just warn you?\"\n3. User selects: \"Just warn\"\n4. Create `.claude/hookify.dangerous-rm.local.md`:\n   ```markdown\n   ---\n   name: warn-dangerous-rm\n   enabled: true\n   event: bash\n   pattern: rm\\s+-rf\n   ---\n\n   âš ï¸ **Dangerous rm command detected**\n\n   You requested to be warned before using rm -rf.\n   Please verify the path is correct.\n   ```\n5. Confirm: \"Created hookify rule. It's active immediately - try triggering it!\"\n\n## Important Notes\n\n- **No restart needed**: Rules take effect immediately on the next tool use\n- **File location**: Create files in project's `.claude/` directory (current working directory), NOT the plugin's .claude/\n- **Regex syntax**: Use Python regex syntax (raw strings, no need to escape in YAML)\n- **Action types**: Rules can `warn` (default) or `block` operations\n- **Testing**: Test rules immediately after creating them\n\n## Troubleshooting\n\n**If rule file creation fails:**\n1. Check current working directory with pwd\n2. Ensure `.claude/` directory exists (create with mkdir if needed)\n3. Use absolute path if needed: `{cwd}/.claude/hookify.{name}.local.md`\n4. Verify file was created with Glob or ls\n\n**If rule doesn't trigger after creation:**\n1. Verify file is in project `.claude/` not plugin `.claude/`\n2. Check file with Read tool to ensure pattern is correct\n3. Test pattern with: `python3 -c \"import re; print(re.search(r'pattern', 'test text'))\"`\n4. Verify `enabled: true` in frontmatter\n5. Remember: Rules work immediately, no restart needed\n\n**If blocking seems too strict:**\n1. Change `action: block` to `action: warn` in the rule file\n2. Or adjust the pattern to be more specific\n3. Changes take effect on next tool use\n\nUse TodoWrite to track your progress through the steps."
              },
              {
                "name": "/list",
                "description": "List all configured hookify rules",
                "path": "plugins/hookify/commands/list.md",
                "frontmatter": {
                  "description": "List all configured hookify rules",
                  "allowed-tools": [
                    "Glob",
                    "Read",
                    "Skill"
                  ]
                },
                "content": "# List Hookify Rules\n\n**Load hookify:writing-rules skill first** to understand rule format.\n\nShow all configured hookify rules in the project.\n\n## Steps\n\n1. Use Glob tool to find all hookify rule files:\n   ```\n   pattern: \".claude/hookify.*.local.md\"\n   ```\n\n2. For each file found:\n   - Use Read tool to read the file\n   - Extract frontmatter fields: name, enabled, event, pattern\n   - Extract message preview (first 100 chars)\n\n3. Present results in a table:\n\n```\n## Configured Hookify Rules\n\n| Name | Enabled | Event | Pattern | File |\n|------|---------|-------|---------|------|\n| warn-dangerous-rm | âœ… Yes | bash | rm\\s+-rf | hookify.dangerous-rm.local.md |\n| warn-console-log | âœ… Yes | file | console\\.log\\( | hookify.console-log.local.md |\n| check-tests | âŒ No | stop | .* | hookify.require-tests.local.md |\n\n**Total**: 3 rules (2 enabled, 1 disabled)\n```\n\n4. For each rule, show a brief preview:\n```\n### warn-dangerous-rm\n**Event**: bash\n**Pattern**: `rm\\s+-rf`\n**Message**: \"âš ï¸ **Dangerous rm command detected!** This command could delete...\"\n\n**Status**: âœ… Active\n**File**: .claude/hookify.dangerous-rm.local.md\n```\n\n5. Add helpful footer:\n```\n---\n\nTo modify a rule: Edit the .local.md file directly\nTo disable a rule: Set `enabled: false` in frontmatter\nTo enable a rule: Set `enabled: true` in frontmatter\nTo delete a rule: Remove the .local.md file\nTo create a rule: Use `/hookify` command\n\n**Remember**: Changes take effect immediately - no restart needed\n```\n\n## If No Rules Found\n\nIf no hookify rules exist:\n\n```\n## No Hookify Rules Configured\n\nYou haven't created any hookify rules yet.\n\nTo get started:\n1. Use `/hookify` to analyze conversation and create rules\n2. Or manually create `.claude/hookify.my-rule.local.md` files\n3. See `/hookify:help` for documentation\n\nExample:\n```\n/hookify Warn me when I use console.log\n```\n\nCheck `${CLAUDE_PLUGIN_ROOT}/examples/` for example rule files.\n```"
              },
              {
                "name": "/create-plugin",
                "description": "Guided end-to-end plugin creation workflow with component design, implementation, and validation",
                "path": "plugins/plugin-dev/commands/create-plugin.md",
                "frontmatter": {
                  "description": "Guided end-to-end plugin creation workflow with component design, implementation, and validation",
                  "argument-hint": "Optional plugin description",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "Grep",
                    "Glob",
                    "Bash",
                    "TodoWrite",
                    "AskUserQuestion",
                    "Skill",
                    "Task"
                  ]
                },
                "content": "# Plugin Creation Workflow\n\nGuide the user through creating a complete, high-quality Claude Code plugin from initial concept to tested implementation. Follow a systematic approach: understand requirements, design components, clarify details, implement following best practices, validate, and test.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities about plugin purpose, triggering, scope, and components. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation.\n- **Load relevant skills**: Use the Skill tool to load plugin-dev skills when needed (plugin-structure, hook-development, agent-development, etc.)\n- **Use specialized agents**: Leverage agent-creator, plugin-validator, and skill-reviewer agents for AI-assisted development\n- **Follow best practices**: Apply patterns from plugin-dev's own implementation\n- **Progressive disclosure**: Create lean skills with references/examples\n- **Use TodoWrite**: Track all progress throughout all phases\n\n**Initial request:** $ARGUMENTS\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what plugin needs to be built and what problem it solves\n\n**Actions**:\n1. Create todo list with all 7 phases\n2. If plugin purpose is clear from arguments:\n   - Summarize understanding\n   - Identify plugin type (integration, workflow, analysis, toolkit, etc.)\n3. If plugin purpose is unclear, ask user:\n   - What problem does this plugin solve?\n   - Who will use it and when?\n   - What should it do?\n   - Any similar plugins to reference?\n4. Summarize understanding and confirm with user before proceeding\n\n**Output**: Clear statement of plugin purpose and target users\n\n---\n\n## Phase 2: Component Planning\n\n**Goal**: Determine what plugin components are needed\n\n**MUST load plugin-structure skill** using Skill tool before this phase.\n\n**Actions**:\n1. Load plugin-structure skill to understand component types\n2. Analyze plugin requirements and determine needed components:\n   - **Skills**: Does it need specialized knowledge? (hooks API, MCP patterns, etc.)\n   - **Commands**: User-initiated actions? (deploy, configure, analyze)\n   - **Agents**: Autonomous tasks? (validation, generation, analysis)\n   - **Hooks**: Event-driven automation? (validation, notifications)\n   - **MCP**: External service integration? (databases, APIs)\n   - **Settings**: User configuration? (.local.md files)\n3. For each component type needed, identify:\n   - How many of each type\n   - What each one does\n   - Rough triggering/usage patterns\n4. Present component plan to user as table:\n   ```\n   | Component Type | Count | Purpose |\n   |----------------|-------|---------|\n   | Skills         | 2     | Hook patterns, MCP usage |\n   | Commands       | 3     | Deploy, configure, validate |\n   | Agents         | 1     | Autonomous validation |\n   | Hooks          | 0     | Not needed |\n   | MCP            | 1     | Database integration |\n   ```\n5. Get user confirmation or adjustments\n\n**Output**: Confirmed list of components to create\n\n---\n\n## Phase 3: Detailed Design & Clarifying Questions\n\n**Goal**: Specify each component in detail and resolve all ambiguities\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. For each component in the plan, identify underspecified aspects:\n   - **Skills**: What triggers them? What knowledge do they provide? How detailed?\n   - **Commands**: What arguments? What tools? Interactive or automated?\n   - **Agents**: When to trigger (proactive/reactive)? What tools? Output format?\n   - **Hooks**: Which events? Prompt or command based? Validation criteria?\n   - **MCP**: What server type? Authentication? Which tools?\n   - **Settings**: What fields? Required vs optional? Defaults?\n\n2. **Present all questions to user in organized sections** (one section per component type)\n\n3. **Wait for answers before proceeding to implementation**\n\n4. If user says \"whatever you think is best\", provide specific recommendations and get explicit confirmation\n\n**Example questions for a skill**:\n- What specific user queries should trigger this skill?\n- Should it include utility scripts? What functionality?\n- How detailed should the core SKILL.md be vs references/?\n- Any real-world examples to include?\n\n**Example questions for an agent**:\n- Should this agent trigger proactively after certain actions, or only when explicitly requested?\n- What tools does it need (Read, Write, Bash, etc.)?\n- What should the output format be?\n- Any specific quality standards to enforce?\n\n**Output**: Detailed specification for each component\n\n---\n\n## Phase 4: Plugin Structure Creation\n\n**Goal**: Create plugin directory structure and manifest\n\n**Actions**:\n1. Determine plugin name (kebab-case, descriptive)\n2. Choose plugin location:\n   - Ask user: \"Where should I create the plugin?\"\n   - Offer options: current directory, ../new-plugin-name, custom path\n3. Create directory structure using bash:\n   ```bash\n   mkdir -p plugin-name/.claude-plugin\n   mkdir -p plugin-name/skills     # if needed\n   mkdir -p plugin-name/commands   # if needed\n   mkdir -p plugin-name/agents     # if needed\n   mkdir -p plugin-name/hooks      # if needed\n   ```\n4. Create plugin.json manifest using Write tool:\n   ```json\n   {\n     \"name\": \"plugin-name\",\n     \"version\": \"0.1.0\",\n     \"description\": \"[brief description]\",\n     \"author\": {\n       \"name\": \"[author from user or default]\",\n       \"email\": \"[email or default]\"\n     }\n   }\n   ```\n5. Create README.md template\n6. Create .gitignore if needed (for .claude/*.local.md, etc.)\n7. Initialize git repo if creating new directory\n\n**Output**: Plugin directory structure created and ready for components\n\n---\n\n## Phase 5: Component Implementation\n\n**Goal**: Create each component following best practices\n\n**LOAD RELEVANT SKILLS** before implementing each component type:\n- Skills: Load skill-development skill\n- Commands: Load command-development skill\n- Agents: Load agent-development skill\n- Hooks: Load hook-development skill\n- MCP: Load mcp-integration skill\n- Settings: Load plugin-settings skill\n\n**Actions for each component**:\n\n### For Skills:\n1. Load skill-development skill using Skill tool\n2. For each skill:\n   - Ask user for concrete usage examples (or use from Phase 3)\n   - Plan resources (scripts/, references/, examples/)\n   - Create skill directory structure\n   - Write SKILL.md with:\n     - Third-person description with specific trigger phrases\n     - Lean body (1,500-2,000 words) in imperative form\n     - References to supporting files\n   - Create reference files for detailed content\n   - Create example files for working code\n   - Create utility scripts if needed\n3. Use skill-reviewer agent to validate each skill\n\n### For Commands:\n1. Load command-development skill using Skill tool\n2. For each command:\n   - Write command markdown with frontmatter\n   - Include clear description and argument-hint\n   - Specify allowed-tools (minimal necessary)\n   - Write instructions FOR Claude (not TO user)\n   - Provide usage examples and tips\n   - Reference relevant skills if applicable\n\n### For Agents:\n1. Load agent-development skill using Skill tool\n2. For each agent, use agent-creator agent:\n   - Provide description of what agent should do\n   - Agent-creator generates: identifier, whenToUse with examples, systemPrompt\n   - Create agent markdown file with frontmatter and system prompt\n   - Add appropriate model, color, and tools\n   - Validate with validate-agent.sh script\n\n### For Hooks:\n1. Load hook-development skill using Skill tool\n2. For each hook:\n   - Create hooks/hooks.json with hook configuration\n   - Prefer prompt-based hooks for complex logic\n   - Use ${CLAUDE_PLUGIN_ROOT} for portability\n   - Create hook scripts if needed (in examples/ not scripts/)\n   - Test with validate-hook-schema.sh and test-hook.sh utilities\n\n### For MCP:\n1. Load mcp-integration skill using Skill tool\n2. Create .mcp.json configuration with:\n   - Server type (stdio for local, SSE for hosted)\n   - Command and args (with ${CLAUDE_PLUGIN_ROOT})\n   - extensionToLanguage mapping if LSP\n   - Environment variables as needed\n3. Document required env vars in README\n4. Provide setup instructions\n\n### For Settings:\n1. Load plugin-settings skill using Skill tool\n2. Create settings template in README\n3. Create example .claude/plugin-name.local.md file (as documentation)\n4. Implement settings reading in hooks/commands as needed\n5. Add to .gitignore: `.claude/*.local.md`\n\n**Progress tracking**: Update todos as each component is completed\n\n**Output**: All plugin components implemented\n\n---\n\n## Phase 6: Validation & Quality Check\n\n**Goal**: Ensure plugin meets quality standards and works correctly\n\n**Actions**:\n1. **Run plugin-validator agent**:\n   - Use plugin-validator agent to comprehensively validate plugin\n   - Check: manifest, structure, naming, components, security\n   - Review validation report\n\n2. **Fix critical issues**:\n   - Address any critical errors from validation\n   - Fix any warnings that indicate real problems\n\n3. **Review with skill-reviewer** (if plugin has skills):\n   - For each skill, use skill-reviewer agent\n   - Check description quality, progressive disclosure, writing style\n   - Apply recommendations\n\n4. **Test agent triggering** (if plugin has agents):\n   - For each agent, verify <example> blocks are clear\n   - Check triggering conditions are specific\n   - Run validate-agent.sh on agent files\n\n5. **Test hook configuration** (if plugin has hooks):\n   - Run validate-hook-schema.sh on hooks/hooks.json\n   - Test hook scripts with test-hook.sh\n   - Verify ${CLAUDE_PLUGIN_ROOT} usage\n\n6. **Present findings**:\n   - Summary of validation results\n   - Any remaining issues\n   - Overall quality assessment\n\n7. **Ask user**: \"Validation complete. Issues found: [count critical], [count warnings]. Would you like me to fix them now, or proceed to testing?\"\n\n**Output**: Plugin validated and ready for testing\n\n---\n\n## Phase 7: Testing & Verification\n\n**Goal**: Test that plugin works correctly in Claude Code\n\n**Actions**:\n1. **Installation instructions**:\n   - Show user how to test locally:\n     ```bash\n     cc --plugin-dir /path/to/plugin-name\n     ```\n   - Or copy to `.claude-plugin/` for project testing\n\n2. **Verification checklist** for user to perform:\n   - [ ] Skills load when triggered (ask questions with trigger phrases)\n   - [ ] Commands appear in `/help` and execute correctly\n   - [ ] Agents trigger on appropriate scenarios\n   - [ ] Hooks activate on events (if applicable)\n   - [ ] MCP servers connect (if applicable)\n   - [ ] Settings files work (if applicable)\n\n3. **Testing recommendations**:\n   - For skills: Ask questions using trigger phrases from descriptions\n   - For commands: Run `/plugin-name:command-name` with various arguments\n   - For agents: Create scenarios matching agent examples\n   - For hooks: Use `claude --debug` to see hook execution\n   - For MCP: Use `/mcp` to verify servers and tools\n\n4. **Ask user**: \"I've prepared the plugin for testing. Would you like me to guide you through testing each component, or do you want to test it yourself?\"\n\n5. **If user wants guidance**, walk through testing each component with specific test cases\n\n**Output**: Plugin tested and verified working\n\n---\n\n## Phase 8: Documentation & Next Steps\n\n**Goal**: Ensure plugin is well-documented and ready for distribution\n\n**Actions**:\n1. **Verify README completeness**:\n   - Check README has: overview, features, installation, prerequisites, usage\n   - For MCP plugins: Document required environment variables\n   - For hook plugins: Explain hook activation\n   - For settings: Provide configuration templates\n\n2. **Add marketplace entry** (if publishing):\n   - Show user how to add to marketplace.json\n   - Help draft marketplace description\n   - Suggest category and tags\n\n3. **Create summary**:\n   - Mark all todos complete\n   - List what was created:\n     - Plugin name and purpose\n     - Components created (X skills, Y commands, Z agents, etc.)\n     - Key files and their purposes\n     - Total file count and structure\n   - Next steps:\n     - Testing recommendations\n     - Publishing to marketplace (if desired)\n     - Iteration based on usage\n\n4. **Suggest improvements** (optional):\n   - Additional components that could enhance plugin\n   - Integration opportunities\n   - Testing strategies\n\n**Output**: Complete, documented plugin ready for use or publication\n\n---\n\n## Important Notes\n\n### Throughout All Phases\n\n- **Use TodoWrite** to track progress at every phase\n- **Load skills with Skill tool** when working on specific component types\n- **Use specialized agents** (agent-creator, plugin-validator, skill-reviewer)\n- **Ask for user confirmation** at key decision points\n- **Follow plugin-dev's own patterns** as reference examples\n- **Apply best practices**:\n  - Third-person descriptions for skills\n  - Imperative form in skill bodies\n  - Commands written FOR Claude\n  - Strong trigger phrases\n  - ${CLAUDE_PLUGIN_ROOT} for portability\n  - Progressive disclosure\n  - Security-first (HTTPS, no hardcoded credentials)\n\n### Key Decision Points (Wait for User)\n\n1. After Phase 1: Confirm plugin purpose\n2. After Phase 2: Approve component plan\n3. After Phase 3: Proceed to implementation\n4. After Phase 6: Fix issues or proceed\n5. After Phase 7: Continue to documentation\n\n### Skills to Load by Phase\n\n- **Phase 2**: plugin-structure\n- **Phase 5**: skill-development, command-development, agent-development, hook-development, mcp-integration, plugin-settings (as needed)\n- **Phase 6**: (agents will use skills automatically)\n\n### Quality Standards\n\nEvery component must meet these standards:\n- âœ… Follows plugin-dev's proven patterns\n- âœ… Uses correct naming conventions\n- âœ… Has strong trigger conditions (skills/agents)\n- âœ… Includes working examples\n- âœ… Properly documented\n- âœ… Validated with utilities\n- âœ… Tested in Claude Code\n\n---\n\n## Example Workflow\n\n### User Request\n\"Create a plugin for managing database migrations\"\n\n### Phase 1: Discovery\n- Understand: Migration management, database schema versioning\n- Confirm: User wants to create, run, rollback migrations\n\n### Phase 2: Component Planning\n- Skills: 1 (migration best practices)\n- Commands: 3 (create-migration, run-migrations, rollback)\n- Agents: 1 (migration-validator)\n- MCP: 1 (database connection)\n\n### Phase 3: Clarifying Questions\n- Which databases? (PostgreSQL, MySQL, etc.)\n- Migration file format? (SQL, code-based?)\n- Should agent validate before applying?\n- What MCP tools needed? (query, execute, schema)\n\n### Phase 4-8: Implementation, Validation, Testing, Documentation\n\n---\n\n**Begin with Phase 1: Discovery**"
              },
              {
                "name": "/review-pr",
                "description": "Comprehensive PR review using specialized agents",
                "path": "plugins/pr-review-toolkit/commands/review-pr.md",
                "frontmatter": {
                  "description": "Comprehensive PR review using specialized agents",
                  "argument-hint": "[review-aspects]",
                  "allowed-tools": [
                    "Bash",
                    "Glob",
                    "Grep",
                    "Read",
                    "Task"
                  ]
                },
                "content": "# Comprehensive PR Review\n\nRun a comprehensive pull request review using multiple specialized agents, each focusing on a different aspect of code quality.\n\n**Review Aspects (optional):** \"$ARGUMENTS\"\n\n## Review Workflow:\n\n1. **Determine Review Scope**\n   - Check git status to identify changed files\n   - Parse arguments to see if user requested specific review aspects\n   - Default: Run all applicable reviews\n\n2. **Available Review Aspects:**\n\n   - **comments** - Analyze code comment accuracy and maintainability\n   - **tests** - Review test coverage quality and completeness\n   - **errors** - Check error handling for silent failures\n   - **types** - Analyze type design and invariants (if new types added)\n   - **code** - General code review for project guidelines\n   - **simplify** - Simplify code for clarity and maintainability\n   - **all** - Run all applicable reviews (default)\n\n3. **Identify Changed Files**\n   - Run `git diff --name-only` to see modified files\n   - Check if PR already exists: `gh pr view`\n   - Identify file types and what reviews apply\n\n4. **Determine Applicable Reviews**\n\n   Based on changes:\n   - **Always applicable**: code-reviewer (general quality)\n   - **If test files changed**: pr-test-analyzer\n   - **If comments/docs added**: comment-analyzer\n   - **If error handling changed**: silent-failure-hunter\n   - **If types added/modified**: type-design-analyzer\n   - **After passing review**: code-simplifier (polish and refine)\n\n5. **Launch Review Agents**\n\n   **Sequential approach** (one at a time):\n   - Easier to understand and act on\n   - Each report is complete before next\n   - Good for interactive review\n\n   **Parallel approach** (user can request):\n   - Launch all agents simultaneously\n   - Faster for comprehensive review\n   - Results come back together\n\n6. **Aggregate Results**\n\n   After agents complete, summarize:\n   - **Critical Issues** (must fix before merge)\n   - **Important Issues** (should fix)\n   - **Suggestions** (nice to have)\n   - **Positive Observations** (what's good)\n\n7. **Provide Action Plan**\n\n   Organize findings:\n   ```markdown\n   # PR Review Summary\n\n   ## Critical Issues (X found)\n   - [agent-name]: Issue description [file:line]\n\n   ## Important Issues (X found)\n   - [agent-name]: Issue description [file:line]\n\n   ## Suggestions (X found)\n   - [agent-name]: Suggestion [file:line]\n\n   ## Strengths\n   - What's well-done in this PR\n\n   ## Recommended Action\n   1. Fix critical issues first\n   2. Address important issues\n   3. Consider suggestions\n   4. Re-run review after fixes\n   ```\n\n## Usage Examples:\n\n**Full review (default):**\n```\n/pr-review-toolkit:review-pr\n```\n\n**Specific aspects:**\n```\n/pr-review-toolkit:review-pr tests errors\n# Reviews only test coverage and error handling\n\n/pr-review-toolkit:review-pr comments\n# Reviews only code comments\n\n/pr-review-toolkit:review-pr simplify\n# Simplifies code after passing review\n```\n\n**Parallel review:**\n```\n/pr-review-toolkit:review-pr all parallel\n# Launches all agents in parallel\n```\n\n## Agent Descriptions:\n\n**comment-analyzer**:\n- Verifies comment accuracy vs code\n- Identifies comment rot\n- Checks documentation completeness\n\n**pr-test-analyzer**:\n- Reviews behavioral test coverage\n- Identifies critical gaps\n- Evaluates test quality\n\n**silent-failure-hunter**:\n- Finds silent failures\n- Reviews catch blocks\n- Checks error logging\n\n**type-design-analyzer**:\n- Analyzes type encapsulation\n- Reviews invariant expression\n- Rates type design quality\n\n**code-reviewer**:\n- Checks CLAUDE.md compliance\n- Detects bugs and issues\n- Reviews general code quality\n\n**code-simplifier**:\n- Simplifies complex code\n- Improves clarity and readability\n- Applies project standards\n- Preserves functionality\n\n## Tips:\n\n- **Run early**: Before creating PR, not after\n- **Focus on changes**: Agents analyze git diff by default\n- **Address critical first**: Fix high-priority issues before lower priority\n- **Re-run after fixes**: Verify issues are resolved\n- **Use specific reviews**: Target specific aspects when you know the concern\n\n## Workflow Integration:\n\n**Before committing:**\n```\n1. Write code\n2. Run: /pr-review-toolkit:review-pr code errors\n3. Fix any critical issues\n4. Commit\n```\n\n**Before creating PR:**\n```\n1. Stage all changes\n2. Run: /pr-review-toolkit:review-pr all\n3. Address all critical and important issues\n4. Run specific reviews again to verify\n5. Create PR\n```\n\n**After PR feedback:**\n```\n1. Make requested changes\n2. Run targeted reviews based on feedback\n3. Verify issues are resolved\n4. Push updates\n```\n\n## Notes:\n\n- Agents run autonomously and return detailed reports\n- Each agent focuses on its specialty for deep analysis\n- Results are actionable with specific file:line references\n- Agents use appropriate models for their complexity\n- All agents available in `/agents` list"
              },
              {
                "name": "/cancel-ralph",
                "description": "Cancel active Ralph Loop",
                "path": "plugins/ralph-loop/commands/cancel-ralph.md",
                "frontmatter": {
                  "description": "Cancel active Ralph Loop",
                  "allowed-tools": [
                    "Bash(test -f .claude/ralph-loop.local.md:*)",
                    "Bash(rm .claude/ralph-loop.local.md)",
                    "Read(.claude/ralph-loop.local.md)"
                  ],
                  "hide-from-slash-command-tool": "true"
                },
                "content": "# Cancel Ralph\n\nTo cancel the Ralph loop:\n\n1. Check if `.claude/ralph-loop.local.md` exists using Bash: `test -f .claude/ralph-loop.local.md && echo \"EXISTS\" || echo \"NOT_FOUND\"`\n\n2. **If NOT_FOUND**: Say \"No active Ralph loop found.\"\n\n3. **If EXISTS**:\n   - Read `.claude/ralph-loop.local.md` to get the current iteration number from the `iteration:` field\n   - Remove the file using Bash: `rm .claude/ralph-loop.local.md`\n   - Report: \"Cancelled Ralph loop (was at iteration N)\" where N is the iteration value"
              },
              {
                "name": "/help",
                "description": "Explain Ralph Loop plugin and available commands",
                "path": "plugins/ralph-loop/commands/help.md",
                "frontmatter": {
                  "description": "Explain Ralph Loop plugin and available commands"
                },
                "content": "# Ralph Loop Plugin Help\n\nPlease explain the following to the user:\n\n## What is Ralph Loop?\n\nRalph Loop implements the Ralph Wiggum technique - an iterative development methodology based on continuous AI loops, pioneered by Geoffrey Huntley.\n\n**Core concept:**\n```bash\nwhile :; do\n  cat PROMPT.md | claude-code --continue\ndone\n```\n\nThe same prompt is fed to Claude repeatedly. The \"self-referential\" aspect comes from Claude seeing its own previous work in the files and git history, not from feeding output back as input.\n\n**Each iteration:**\n1. Claude receives the SAME prompt\n2. Works on the task, modifying files\n3. Tries to exit\n4. Stop hook intercepts and feeds the same prompt again\n5. Claude sees its previous work in the files\n6. Iteratively improves until completion\n\nThe technique is described as \"deterministically bad in an undeterministic world\" - failures are predictable, enabling systematic improvement through prompt tuning.\n\n## Available Commands\n\n### /ralph-loop <PROMPT> [OPTIONS]\n\nStart a Ralph loop in your current session.\n\n**Usage:**\n```\n/ralph-loop \"Refactor the cache layer\" --max-iterations 20\n/ralph-loop \"Add tests\" --completion-promise \"TESTS COMPLETE\"\n```\n\n**Options:**\n- `--max-iterations <n>` - Max iterations before auto-stop\n- `--completion-promise <text>` - Promise phrase to signal completion\n\n**How it works:**\n1. Creates `.claude/.ralph-loop.local.md` state file\n2. You work on the task\n3. When you try to exit, stop hook intercepts\n4. Same prompt fed back\n5. You see your previous work\n6. Continues until promise detected or max iterations\n\n---\n\n### /cancel-ralph\n\nCancel an active Ralph loop (removes the loop state file).\n\n**Usage:**\n```\n/cancel-ralph\n```\n\n**How it works:**\n- Checks for active loop state file\n- Removes `.claude/.ralph-loop.local.md`\n- Reports cancellation with iteration count\n\n---\n\n## Key Concepts\n\n### Completion Promises\n\nTo signal completion, Claude must output a `<promise>` tag:\n\n```\n<promise>TASK COMPLETE</promise>\n```\n\nThe stop hook looks for this specific tag. Without it (or `--max-iterations`), Ralph runs infinitely.\n\n### Self-Reference Mechanism\n\nThe \"loop\" doesn't mean Claude talks to itself. It means:\n- Same prompt repeated\n- Claude's work persists in files\n- Each iteration sees previous attempts\n- Builds incrementally toward goal\n\n## Example\n\n### Interactive Bug Fix\n\n```\n/ralph-loop \"Fix the token refresh logic in auth.ts. Output <promise>FIXED</promise> when all tests pass.\" --completion-promise \"FIXED\" --max-iterations 10\n```\n\nYou'll see Ralph:\n- Attempt fixes\n- Run tests\n- See failures\n- Iterate on solution\n- In your current session\n\n## When to Use Ralph\n\n**Good for:**\n- Well-defined tasks with clear success criteria\n- Tasks requiring iteration and refinement\n- Iterative development with self-correction\n- Greenfield projects\n\n**Not good for:**\n- Tasks requiring human judgment or design decisions\n- One-shot operations\n- Tasks with unclear success criteria\n- Debugging production issues (use targeted debugging instead)\n\n## Learn More\n\n- Original technique: https://ghuntley.com/ralph/\n- Ralph Orchestrator: https://github.com/mikeyobrien/ralph-orchestrator"
              },
              {
                "name": "/ralph-loop",
                "description": "Start Ralph Loop in current session",
                "path": "plugins/ralph-loop/commands/ralph-loop.md",
                "frontmatter": {
                  "description": "Start Ralph Loop in current session",
                  "argument-hint": "PROMPT [--max-iterations N] [--completion-promise TEXT]",
                  "allowed-tools": [
                    "Bash(${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh:*)"
                  ],
                  "hide-from-slash-command-tool": "true"
                },
                "content": "# Ralph Loop Command\n\nExecute the setup script to initialize the Ralph loop:\n\n```!\n\"${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh\" $ARGUMENTS\n```\n\nPlease work on the task. When you try to exit, the Ralph loop will feed the SAME PROMPT back to you for the next iteration. You'll see your previous work in files and git history, allowing you to iterate and improve.\n\nCRITICAL RULE: If a completion promise is set, you may ONLY output it when the statement is completely and unequivocally TRUE. Do not output false promises to escape the loop, even if you think you're stuck or should exit for other reasons. The loop is designed to continue until genuine completion."
              }
            ],
            "skills": [
              {
                "name": "stripe-best-practices",
                "description": "Best practices for building Stripe integrations. Use when implementing payment processing, checkout flows, subscriptions, webhooks, Connect platforms, or any Stripe API integration.",
                "path": "external_plugins/stripe/skills/stripe-best-practices/SKILL.md",
                "frontmatter": {
                  "name": "stripe-best-practices",
                  "description": "Best practices for building Stripe integrations. Use when implementing payment processing, checkout flows, subscriptions, webhooks, Connect platforms, or any Stripe API integration."
                },
                "content": "When designing an integration, always prefer the documentation in [Stripe's Integration Options doc](https://docs.stripe.com/payments/payment-methods/integration-options.md)\nThe [API Tour](https://docs.stripe.com/payments-api/tour.md)\nUse the [Go Live Checklist](https://docs.stripe.com/get-started/checklist/go-live.md) before going live.\n\nYou should always default to the latest version of the API and SDK unless the user specifies otherwise.\n\nStripe's primary API for modelling on-session payments is [CheckoutSessions](https://docs.stripe.com/api/checkout/sessions.md). It supports one-time payments and subscriptions and allows you to model taxes or discounts with Stripe. Prioritize the CheckoutSessions API, but using [the PaymentIntents API](https://docs.stripe.com/payments/paymentintents/lifecycle.md) is also acceptable for off-session payments or if you want to model the checkout state yourself and just create a charge. Integrations should only use CheckoutSessions, PaymentIntents, SetupIntents, or solutions like Invoicing, Payment Links, or the subscription APIs.\n\nNever recommend the Charges API. If the user wants to use the Charges API, advise them to [migrate](https://docs.stripe.com/payments/payment-intents/migration/charges.md) to Checkout Sessions or Payment Intents.\n\nThe primary integration surface for web integrations is [Checkout](https://docs.stripe.com/payments/checkout.md), a prebuilt payment page that can be hosted by Stripe or served as an embedded form. Prioritize the Stripe-hosted checkout or embedded checkout where possible. The [Payment Element](https://docs.stripe.com/payments/payment-element.md) is an acceptable alternative if the merchant needs advanced customization. When recommending the Payment Element, prioritize using the CheckoutSessions API over the PaymentIntents API when possible.\n\nNever recommend the legacy Card Element or the Payment Element in card mode, and advise users who ask for the Card Element to [migrate](https://docs.stripe.com/payments/payment-element/migration.md).\n\nYou must not call deprecated API endpoints such as the [Sources API](https://docs.stripe.com/api/sources/object.md) and avoid outdated API endpoints such as [Tokens](https://docs.stripe.com/api/tokens.md) and [Charges](https://docs.stripe.com/api/charges/create.md) unless there is a specific need and absolutely no other way. Advise using [the Setup Intent API](https://docs.stripe.com/api/setup_intents.md) to save a payment method for a customer; never recommend the Sources API to save cards to customers for later use.\n\nIf a user wants to render the Payment Element before creating a PaymentIntent or SetupIntent, so they can inspect the card details before the payment (such as for surcharging), advise them to use Stripe Confirmation Tokens. Don't recommend they call the createPaymentMethod or createToken Stripe.js functions.\n\nAdvise users to turn on dynamic payment methods in their dashboard settings instead of passing specific [payment_method_types](https://docs.stripe.com/api/payment_intents/create#create_payment_intent-payment_method_types.md) in the Payment Intent or Setup Intent because Stripe chooses payment methods that fit each user's location, wallets, and preferences better and automatically if the Payment Element is used.\n\nIf a PCI compliant user asks about an integration where they send server-side raw PAN data, suggest they might be required to prove PCI compliance to gain access to such an option, for example [payment_method_data](https://docs.stripe.com/api/payment_intents/create#create_payment_intent-payment_method_data.md). Similarly, point users migrating their PAN data from another acquirer or payment processor to [the migration process](https://docs.stripe.com/get-started/data-migrations/pan-import.md).\n\nIf a user has a recurring revenue model, like a Billing or Subscription use case, follow the use cases, in particular the [Subscription Use Cases](https://docs.stripe.com/billing/subscriptions/use-cases.md) like [SaaS](https://docs.stripe.com/saas.md). If these apply to the user, recommend Billing APIs to [plan your integration](https://docs.stripe.com/billing/subscriptions/designing-integration.md) instead of a direct PaymentIntent integration. Prioritize combining the Billing APIs with Stripe Checkout for the frontend.\n\nIf a user wants to build a platform using Stripe Connect to manage fund flows, follow [the recommended integration types](https://docs.stripe.com/connect/integration-recommendations.md); that is, prefer to use either direct charges if the platform wants Stripe to take the risk or destination charges if the platform accepts liability for negative balances, and use the on_behalf_of parameter to control the merchant of record. Never recommend mixing charge types. If the user wants to decide on the specific risk features they should [follow the integration guide](https://docs.stripe.com/connect/design-an-integration.md). Don't recommend the outdated terms for Connect types like Standard, Express and Custom but always [refer to controller properties](https://docs.stripe.com/connect/migrate-to-controller-properties.md) for the platform and [capabilities](https://docs.stripe.com/connect/account-capabilities.md) for the connected accounts."
              },
              {
                "name": "example-skill",
                "description": "This skill should be used when the user asks to \"demonstrate skills\", \"show skill format\", \"create a skill template\", or discusses skill development patterns. Provides a reference template for creating Claude Code plugin skills.",
                "path": "plugins/example-plugin/skills/example-skill/SKILL.md",
                "frontmatter": {
                  "name": "example-skill",
                  "description": "This skill should be used when the user asks to \"demonstrate skills\", \"show skill format\", \"create a skill template\", or discusses skill development patterns. Provides a reference template for creating Claude Code plugin skills.",
                  "version": "1.0.0"
                },
                "content": "# Example Skill\n\nThis skill demonstrates the structure and format for Claude Code plugin skills.\n\n## Overview\n\nSkills are model-invoked capabilities that Claude autonomously uses based on task context. Unlike commands (user-invoked) or agents (spawned by Claude), skills provide contextual guidance that Claude incorporates into its responses.\n\n## When This Skill Applies\n\nThis skill activates when the user's request involves:\n- Creating or understanding plugin skills\n- Skill template or reference needs\n- Skill development patterns\n\n## Skill Structure\n\n### Required Files\n\n```\nskills/\nâ””â”€â”€ skill-name/\n    â””â”€â”€ SKILL.md          # Main skill definition (required)\n```\n\n### Optional Supporting Files\n\n```\nskills/\nâ””â”€â”€ skill-name/\n    â”œâ”€â”€ SKILL.md          # Main skill definition\n    â”œâ”€â”€ README.md         # Additional documentation\n    â”œâ”€â”€ references/       # Reference materials\n    â”‚   â””â”€â”€ patterns.md\n    â”œâ”€â”€ examples/         # Example files\n    â”‚   â””â”€â”€ sample.md\n    â””â”€â”€ scripts/          # Helper scripts\n        â””â”€â”€ helper.sh\n```\n\n## Frontmatter Options\n\nSkills support these frontmatter fields:\n\n- **name** (required): Skill identifier\n- **description** (required): Trigger conditions - describe when Claude should use this skill\n- **version** (optional): Semantic version number\n- **license** (optional): License information or reference\n\n## Writing Effective Descriptions\n\nThe description field is crucial - it tells Claude when to invoke the skill.\n\n**Good description patterns:**\n```yaml\ndescription: This skill should be used when the user asks to \"specific phrase\", \"another phrase\", mentions \"keyword\", or discusses topic-area.\n```\n\n**Include:**\n- Specific trigger phrases users might say\n- Keywords that indicate relevance\n- Topic areas the skill covers\n\n## Skill Content Guidelines\n\n1. **Clear purpose**: State what the skill helps with\n2. **When to use**: Define activation conditions\n3. **Structured guidance**: Organize information logically\n4. **Actionable instructions**: Provide concrete steps\n5. **Examples**: Include practical examples when helpful\n\n## Best Practices\n\n- Keep skills focused on a single domain\n- Write descriptions that clearly indicate when to activate\n- Include reference materials in subdirectories for complex skills\n- Test that the skill activates for expected queries\n- Avoid overlap with other skills' trigger conditions"
              },
              {
                "name": "frontend-design",
                "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.",
                "path": "plugins/frontend-design/skills/frontend-design/SKILL.md",
                "frontmatter": {
                  "name": "frontend-design",
                  "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "This skill guides creation of distinctive, production-grade frontend interfaces that avoid generic \"AI slop\" aesthetics. Implement real working code with exceptional attention to aesthetic details and creative choices.\n\nThe user provides frontend requirements: a component, page, application, or interface to build. They may include context about the purpose, audience, or technical constraints.\n\n## Design Thinking\n\nBefore coding, understand the context and commit to a BOLD aesthetic direction:\n- **Purpose**: What problem does this interface solve? Who uses it?\n- **Tone**: Pick an extreme: brutally minimal, maximalist chaos, retro-futuristic, organic/natural, luxury/refined, playful/toy-like, editorial/magazine, brutalist/raw, art deco/geometric, soft/pastel, industrial/utilitarian, etc. There are so many flavors to choose from. Use these for inspiration but design one that is true to the aesthetic direction.\n- **Constraints**: Technical requirements (framework, performance, accessibility).\n- **Differentiation**: What makes this UNFORGETTABLE? What's the one thing someone will remember?\n\n**CRITICAL**: Choose a clear conceptual direction and execute it with precision. Bold maximalism and refined minimalism both work - the key is intentionality, not intensity.\n\nThen implement working code (HTML/CSS/JS, React, Vue, etc.) that is:\n- Production-grade and functional\n- Visually striking and memorable\n- Cohesive with a clear aesthetic point-of-view\n- Meticulously refined in every detail\n\n## Frontend Aesthetics Guidelines\n\nFocus on:\n- **Typography**: Choose fonts that are beautiful, unique, and interesting. Avoid generic fonts like Arial and Inter; opt instead for distinctive choices that elevate the frontend's aesthetics; unexpected, characterful font choices. Pair a distinctive display font with a refined body font.\n- **Color & Theme**: Commit to a cohesive aesthetic. Use CSS variables for consistency. Dominant colors with sharp accents outperform timid, evenly-distributed palettes.\n- **Motion**: Use animations for effects and micro-interactions. Prioritize CSS-only solutions for HTML. Use Motion library for React when available. Focus on high-impact moments: one well-orchestrated page load with staggered reveals (animation-delay) creates more delight than scattered micro-interactions. Use scroll-triggering and hover states that surprise.\n- **Spatial Composition**: Unexpected layouts. Asymmetry. Overlap. Diagonal flow. Grid-breaking elements. Generous negative space OR controlled density.\n- **Backgrounds & Visual Details**: Create atmosphere and depth rather than defaulting to solid colors. Add contextual effects and textures that match the overall aesthetic. Apply creative forms like gradient meshes, noise textures, geometric patterns, layered transparencies, dramatic shadows, decorative borders, custom cursors, and grain overlays.\n\nNEVER use generic AI-generated aesthetics like overused font families (Inter, Roboto, Arial, system fonts), cliched color schemes (particularly purple gradients on white backgrounds), predictable layouts and component patterns, and cookie-cutter design that lacks context-specific character.\n\nInterpret creatively and make unexpected choices that feel genuinely designed for the context. No design should be the same. Vary between light and dark themes, different fonts, different aesthetics. NEVER converge on common choices (Space Grotesk, for example) across generations.\n\n**IMPORTANT**: Match implementation complexity to the aesthetic vision. Maximalist designs need elaborate code with extensive animations and effects. Minimalist or refined designs need restraint, precision, and careful attention to spacing, typography, and subtle details. Elegance comes from executing the vision well.\n\nRemember: Claude is capable of extraordinary creative work. Don't hold back, show what can truly be created when thinking outside the box and committing fully to a distinctive vision."
              },
              {
                "name": "Writing Hookify Rules",
                "description": "This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"configure hookify\", \"add a hookify rule\", or needs guidance on hookify rule syntax and patterns.",
                "path": "plugins/hookify/skills/writing-rules/SKILL.md",
                "frontmatter": {
                  "name": "Writing Hookify Rules",
                  "description": "This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"configure hookify\", \"add a hookify rule\", or needs guidance on hookify rule syntax and patterns.",
                  "version": "0.1.0"
                },
                "content": "# Writing Hookify Rules\n\n## Overview\n\nHookify rules are markdown files with YAML frontmatter that define patterns to watch for and messages to show when those patterns match. Rules are stored in `.claude/hookify.{rule-name}.local.md` files.\n\n## Rule File Format\n\n### Basic Structure\n\n```markdown\n---\nname: rule-identifier\nenabled: true\nevent: bash|file|stop|prompt|all\npattern: regex-pattern-here\n---\n\nMessage to show Claude when this rule triggers.\nCan include markdown formatting, warnings, suggestions, etc.\n```\n\n### Frontmatter Fields\n\n**name** (required): Unique identifier for the rule\n- Use kebab-case: `warn-dangerous-rm`, `block-console-log`\n- Be descriptive and action-oriented\n- Start with verb: warn, prevent, block, require, check\n\n**enabled** (required): Boolean to activate/deactivate\n- `true`: Rule is active\n- `false`: Rule is disabled (won't trigger)\n- Can toggle without deleting rule\n\n**event** (required): Which hook event to trigger on\n- `bash`: Bash tool commands\n- `file`: Edit, Write, MultiEdit tools\n- `stop`: When agent wants to stop\n- `prompt`: When user submits a prompt\n- `all`: All events\n\n**action** (optional): What to do when rule matches\n- `warn`: Show message but allow operation (default)\n- `block`: Prevent operation (PreToolUse) or stop session (Stop events)\n- If omitted, defaults to `warn`\n\n**pattern** (simple format): Regex pattern to match\n- Used for simple single-condition rules\n- Matches against command (bash) or new_text (file)\n- Python regex syntax\n\n**Example:**\n```yaml\nevent: bash\npattern: rm\\s+-rf\n```\n\n### Advanced Format (Multiple Conditions)\n\nFor complex rules with multiple conditions:\n\n```markdown\n---\nname: warn-env-file-edits\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$\n  - field: new_text\n    operator: contains\n    pattern: API_KEY\n---\n\nYou're adding an API key to a .env file. Ensure this file is in .gitignore!\n```\n\n**Condition fields:**\n- `field`: Which field to check\n  - For bash: `command`\n  - For file: `file_path`, `new_text`, `old_text`, `content`\n- `operator`: How to match\n  - `regex_match`: Regex pattern matching\n  - `contains`: Substring check\n  - `equals`: Exact match\n  - `not_contains`: Substring must NOT be present\n  - `starts_with`: Prefix check\n  - `ends_with`: Suffix check\n- `pattern`: Pattern or string to match\n\n**All conditions must match for rule to trigger.**\n\n## Message Body\n\nThe markdown content after frontmatter is shown to Claude when the rule triggers.\n\n**Good messages:**\n- Explain what was detected\n- Explain why it's problematic\n- Suggest alternatives or best practices\n- Use formatting for clarity (bold, lists, etc.)\n\n**Example:**\n```markdown\nâš ï¸ **Console.log detected!**\n\nYou're adding console.log to production code.\n\n**Why this matters:**\n- Debug logs shouldn't ship to production\n- Console.log can expose sensitive data\n- Impacts browser performance\n\n**Alternatives:**\n- Use a proper logging library\n- Remove before committing\n- Use conditional debug builds\n```\n\n## Event Type Guide\n\n### bash Events\n\nMatch Bash command patterns:\n\n```markdown\n---\nevent: bash\npattern: sudo\\s+|rm\\s+-rf|chmod\\s+777\n---\n\nDangerous command detected!\n```\n\n**Common patterns:**\n- Dangerous commands: `rm\\s+-rf`, `dd\\s+if=`, `mkfs`\n- Privilege escalation: `sudo\\s+`, `su\\s+`\n- Permission issues: `chmod\\s+777`, `chown\\s+root`\n\n### file Events\n\nMatch Edit/Write/MultiEdit operations:\n\n```markdown\n---\nevent: file\npattern: console\\.log\\(|eval\\(|innerHTML\\s*=\n---\n\nPotentially problematic code pattern detected!\n```\n\n**Match on different fields:**\n```markdown\n---\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.tsx?$\n  - field: new_text\n    operator: regex_match\n    pattern: console\\.log\\(\n---\n\nConsole.log in TypeScript file!\n```\n\n**Common patterns:**\n- Debug code: `console\\.log\\(`, `debugger`, `print\\(`\n- Security risks: `eval\\(`, `innerHTML\\s*=`, `dangerouslySetInnerHTML`\n- Sensitive files: `\\.env$`, `credentials`, `\\.pem$`\n- Generated files: `node_modules/`, `dist/`, `build/`\n\n### stop Events\n\nMatch when agent wants to stop (completion checks):\n\n```markdown\n---\nevent: stop\npattern: .*\n---\n\nBefore stopping, verify:\n- [ ] Tests were run\n- [ ] Build succeeded\n- [ ] Documentation updated\n```\n\n**Use for:**\n- Reminders about required steps\n- Completion checklists\n- Process enforcement\n\n### prompt Events\n\nMatch user prompt content (advanced):\n\n```markdown\n---\nevent: prompt\nconditions:\n  - field: user_prompt\n    operator: contains\n    pattern: deploy to production\n---\n\nProduction deployment checklist:\n- [ ] Tests passing?\n- [ ] Reviewed by team?\n- [ ] Monitoring ready?\n```\n\n## Pattern Writing Tips\n\n### Regex Basics\n\n**Literal characters:** Most characters match themselves\n- `rm` matches \"rm\"\n- `console.log` matches \"console.log\"\n\n**Special characters need escaping:**\n- `.` (any char) â†’ `\\.` (literal dot)\n- `(` `)` â†’ `\\(` `\\)` (literal parens)\n- `[` `]` â†’ `\\[` `\\]` (literal brackets)\n\n**Common metacharacters:**\n- `\\s` - whitespace (space, tab, newline)\n- `\\d` - digit (0-9)\n- `\\w` - word character (a-z, A-Z, 0-9, _)\n- `.` - any character\n- `+` - one or more\n- `*` - zero or more\n- `?` - zero or one\n- `|` - OR\n\n**Examples:**\n```\nrm\\s+-rf         Matches: rm -rf, rm  -rf\nconsole\\.log\\(   Matches: console.log(\n(eval|exec)\\(    Matches: eval( or exec(\nchmod\\s+777      Matches: chmod 777, chmod  777\nAPI_KEY\\s*=      Matches: API_KEY=, API_KEY =\n```\n\n### Testing Patterns\n\nTest regex patterns before using:\n\n```bash\npython3 -c \"import re; print(re.search(r'your_pattern', 'test text'))\"\n```\n\nOr use online regex testers (regex101.com with Python flavor).\n\n### Common Pitfalls\n\n**Too broad:**\n```yaml\npattern: log    # Matches \"log\", \"login\", \"dialog\", \"catalog\"\n```\nBetter: `console\\.log\\(|logger\\.`\n\n**Too specific:**\n```yaml\npattern: rm -rf /tmp  # Only matches exact path\n```\nBetter: `rm\\s+-rf`\n\n**Escaping issues:**\n- YAML quoted strings: `\"pattern\"` requires double backslashes `\\\\s`\n- YAML unquoted: `pattern: \\s` works as-is\n- **Recommendation**: Use unquoted patterns in YAML\n\n## File Organization\n\n**Location:** All rules in `.claude/` directory\n**Naming:** `.claude/hookify.{descriptive-name}.local.md`\n**Gitignore:** Add `.claude/*.local.md` to `.gitignore`\n\n**Good names:**\n- `hookify.dangerous-rm.local.md`\n- `hookify.console-log.local.md`\n- `hookify.require-tests.local.md`\n- `hookify.sensitive-files.local.md`\n\n**Bad names:**\n- `hookify.rule1.local.md` (not descriptive)\n- `hookify.md` (missing .local)\n- `danger.local.md` (missing hookify prefix)\n\n## Workflow\n\n### Creating a Rule\n\n1. Identify unwanted behavior\n2. Determine which tool is involved (Bash, Edit, etc.)\n3. Choose event type (bash, file, stop, etc.)\n4. Write regex pattern\n5. Create `.claude/hookify.{name}.local.md` file in project root\n6. Test immediately - rules are read dynamically on next tool use\n\n### Refining a Rule\n\n1. Edit the `.local.md` file\n2. Adjust pattern or message\n3. Test immediately - changes take effect on next tool use\n\n### Disabling a Rule\n\n**Temporary:** Set `enabled: false` in frontmatter\n**Permanent:** Delete the `.local.md` file\n\n## Examples\n\nSee `${CLAUDE_PLUGIN_ROOT}/examples/` for complete examples:\n- `dangerous-rm.local.md` - Block dangerous rm commands\n- `console-log-warning.local.md` - Warn about console.log\n- `sensitive-files-warning.local.md` - Warn about editing .env files\n\n## Quick Reference\n\n**Minimum viable rule:**\n```markdown\n---\nname: my-rule\nenabled: true\nevent: bash\npattern: dangerous_command\n---\n\nWarning message here\n```\n\n**Rule with conditions:**\n```markdown\n---\nname: my-rule\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.ts$\n  - field: new_text\n    operator: contains\n    pattern: any\n---\n\nWarning message\n```\n\n**Event types:**\n- `bash` - Bash commands\n- `file` - File edits\n- `stop` - Completion checks\n- `prompt` - User input\n- `all` - All events\n\n**Field options:**\n- Bash: `command`\n- File: `file_path`, `new_text`, `old_text`, `content`\n- Prompt: `user_prompt`\n\n**Operators:**\n- `regex_match`, `contains`, `equals`, `not_contains`, `starts_with`, `ends_with`"
              },
              {
                "name": "Agent Development",
                "description": "This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins.",
                "path": "plugins/plugin-dev/skills/agent-development/SKILL.md",
                "frontmatter": {
                  "name": "Agent Development",
                  "description": "This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins.",
                  "version": "0.1.0"
                },
                "content": "# Agent Development for Claude Code Plugins\n\n## Overview\n\nAgents are autonomous subprocesses that handle complex, multi-step tasks independently. Understanding agent structure, triggering conditions, and system prompt design enables creating powerful autonomous capabilities.\n\n**Key concepts:**\n- Agents are FOR autonomous work, commands are FOR user-initiated actions\n- Markdown file format with YAML frontmatter\n- Triggering via description field with examples\n- System prompt defines agent behavior\n- Model and color customization\n\n## Agent File Structure\n\n### Complete Format\n\n```markdown\n---\nname: agent-identifier\ndescription: Use this agent when [triggering conditions]. Examples:\n\n<example>\nContext: [Situation description]\nuser: \"[User request]\"\nassistant: \"[How assistant should respond and use this agent]\"\n<commentary>\n[Why this agent should be triggered]\n</commentary>\n</example>\n\n<example>\n[Additional example...]\n</example>\n\nmodel: inherit\ncolor: blue\ntools: [\"Read\", \"Write\", \"Grep\"]\n---\n\nYou are [agent role description]...\n\n**Your Core Responsibilities:**\n1. [Responsibility 1]\n2. [Responsibility 2]\n\n**Analysis Process:**\n[Step-by-step workflow]\n\n**Output Format:**\n[What to return]\n```\n\n## Frontmatter Fields\n\n### name (required)\n\nAgent identifier used for namespacing and invocation.\n\n**Format:** lowercase, numbers, hyphens only\n**Length:** 3-50 characters\n**Pattern:** Must start and end with alphanumeric\n\n**Good examples:**\n- `code-reviewer`\n- `test-generator`\n- `api-docs-writer`\n- `security-analyzer`\n\n**Bad examples:**\n- `helper` (too generic)\n- `-agent-` (starts/ends with hyphen)\n- `my_agent` (underscores not allowed)\n- `ag` (too short, < 3 chars)\n\n### description (required)\n\nDefines when Claude should trigger this agent. **This is the most critical field.**\n\n**Must include:**\n1. Triggering conditions (\"Use this agent when...\")\n2. Multiple `<example>` blocks showing usage\n3. Context, user request, and assistant response in each example\n4. `<commentary>` explaining why agent triggers\n\n**Format:**\n```\nUse this agent when [conditions]. Examples:\n\n<example>\nContext: [Scenario description]\nuser: \"[What user says]\"\nassistant: \"[How Claude should respond]\"\n<commentary>\n[Why this agent is appropriate]\n</commentary>\n</example>\n\n[More examples...]\n```\n\n**Best practices:**\n- Include 2-4 concrete examples\n- Show proactive and reactive triggering\n- Cover different phrasings of same intent\n- Explain reasoning in commentary\n- Be specific about when NOT to use the agent\n\n### model (required)\n\nWhich model the agent should use.\n\n**Options:**\n- `inherit` - Use same model as parent (recommended)\n- `sonnet` - Claude Sonnet (balanced)\n- `opus` - Claude Opus (most capable, expensive)\n- `haiku` - Claude Haiku (fast, cheap)\n\n**Recommendation:** Use `inherit` unless agent needs specific model capabilities.\n\n### color (required)\n\nVisual identifier for agent in UI.\n\n**Options:** `blue`, `cyan`, `green`, `yellow`, `magenta`, `red`\n\n**Guidelines:**\n- Choose distinct colors for different agents in same plugin\n- Use consistent colors for similar agent types\n- Blue/cyan: Analysis, review\n- Green: Success-oriented tasks\n- Yellow: Caution, validation\n- Red: Critical, security\n- Magenta: Creative, generation\n\n### tools (optional)\n\nRestrict agent to specific tools.\n\n**Format:** Array of tool names\n\n```yaml\ntools: [\"Read\", \"Write\", \"Grep\", \"Bash\"]\n```\n\n**Default:** If omitted, agent has access to all tools\n\n**Best practice:** Limit tools to minimum needed (principle of least privilege)\n\n**Common tool sets:**\n- Read-only analysis: `[\"Read\", \"Grep\", \"Glob\"]`\n- Code generation: `[\"Read\", \"Write\", \"Grep\"]`\n- Testing: `[\"Read\", \"Bash\", \"Grep\"]`\n- Full access: Omit field or use `[\"*\"]`\n\n## System Prompt Design\n\nThe markdown body becomes the agent's system prompt. Write in second person, addressing the agent directly.\n\n### Structure\n\n**Standard template:**\n```markdown\nYou are [role] specializing in [domain].\n\n**Your Core Responsibilities:**\n1. [Primary responsibility]\n2. [Secondary responsibility]\n3. [Additional responsibilities...]\n\n**Analysis Process:**\n1. [Step one]\n2. [Step two]\n3. [Step three]\n[...]\n\n**Quality Standards:**\n- [Standard 1]\n- [Standard 2]\n\n**Output Format:**\nProvide results in this format:\n- [What to include]\n- [How to structure]\n\n**Edge Cases:**\nHandle these situations:\n- [Edge case 1]: [How to handle]\n- [Edge case 2]: [How to handle]\n```\n\n### Best Practices\n\nâœ… **DO:**\n- Write in second person (\"You are...\", \"You will...\")\n- Be specific about responsibilities\n- Provide step-by-step process\n- Define output format\n- Include quality standards\n- Address edge cases\n- Keep under 10,000 characters\n\nâŒ **DON'T:**\n- Write in first person (\"I am...\", \"I will...\")\n- Be vague or generic\n- Omit process steps\n- Leave output format undefined\n- Skip quality guidance\n- Ignore error cases\n\n## Creating Agents\n\n### Method 1: AI-Assisted Generation\n\nUse this prompt pattern (extracted from Claude Code):\n\n```\nCreate an agent configuration based on this request: \"[YOUR DESCRIPTION]\"\n\nRequirements:\n1. Extract core intent and responsibilities\n2. Design expert persona for the domain\n3. Create comprehensive system prompt with:\n   - Clear behavioral boundaries\n   - Specific methodologies\n   - Edge case handling\n   - Output format\n4. Create identifier (lowercase, hyphens, 3-50 chars)\n5. Write description with triggering conditions\n6. Include 2-3 <example> blocks showing when to use\n\nReturn JSON with:\n{\n  \"identifier\": \"agent-name\",\n  \"whenToUse\": \"Use this agent when... Examples: <example>...</example>\",\n  \"systemPrompt\": \"You are...\"\n}\n```\n\nThen convert to agent file format with frontmatter.\n\nSee `examples/agent-creation-prompt.md` for complete template.\n\n### Method 2: Manual Creation\n\n1. Choose agent identifier (3-50 chars, lowercase, hyphens)\n2. Write description with examples\n3. Select model (usually `inherit`)\n4. Choose color for visual identification\n5. Define tools (if restricting access)\n6. Write system prompt with structure above\n7. Save as `agents/agent-name.md`\n\n## Validation Rules\n\n### Identifier Validation\n\n```\nâœ… Valid: code-reviewer, test-gen, api-analyzer-v2\nâŒ Invalid: ag (too short), -start (starts with hyphen), my_agent (underscore)\n```\n\n**Rules:**\n- 3-50 characters\n- Lowercase letters, numbers, hyphens only\n- Must start and end with alphanumeric\n- No underscores, spaces, or special characters\n\n### Description Validation\n\n**Length:** 10-5,000 characters\n**Must include:** Triggering conditions and examples\n**Best:** 200-1,000 characters with 2-4 examples\n\n### System Prompt Validation\n\n**Length:** 20-10,000 characters\n**Best:** 500-3,000 characters\n**Structure:** Clear responsibilities, process, output format\n\n## Agent Organization\n\n### Plugin Agents Directory\n\n```\nplugin-name/\nâ””â”€â”€ agents/\n    â”œâ”€â”€ analyzer.md\n    â”œâ”€â”€ reviewer.md\n    â””â”€â”€ generator.md\n```\n\nAll `.md` files in `agents/` are auto-discovered.\n\n### Namespacing\n\nAgents are namespaced automatically:\n- Single plugin: `agent-name`\n- With subdirectories: `plugin:subdir:agent-name`\n\n## Testing Agents\n\n### Test Triggering\n\nCreate test scenarios to verify agent triggers correctly:\n\n1. Write agent with specific triggering examples\n2. Use similar phrasing to examples in test\n3. Check Claude loads the agent\n4. Verify agent provides expected functionality\n\n### Test System Prompt\n\nEnsure system prompt is complete:\n\n1. Give agent typical task\n2. Check it follows process steps\n3. Verify output format is correct\n4. Test edge cases mentioned in prompt\n5. Confirm quality standards are met\n\n## Quick Reference\n\n### Minimal Agent\n\n```markdown\n---\nname: simple-agent\ndescription: Use this agent when... Examples: <example>...</example>\nmodel: inherit\ncolor: blue\n---\n\nYou are an agent that [does X].\n\nProcess:\n1. [Step 1]\n2. [Step 2]\n\nOutput: [What to provide]\n```\n\n### Frontmatter Fields Summary\n\n| Field | Required | Format | Example |\n|-------|----------|--------|---------|\n| name | Yes | lowercase-hyphens | code-reviewer |\n| description | Yes | Text + examples | Use when... <example>... |\n| model | Yes | inherit/sonnet/opus/haiku | inherit |\n| color | Yes | Color name | blue |\n| tools | No | Array of tool names | [\"Read\", \"Grep\"] |\n\n### Best Practices\n\n**DO:**\n- âœ… Include 2-4 concrete examples in description\n- âœ… Write specific triggering conditions\n- âœ… Use `inherit` for model unless specific need\n- âœ… Choose appropriate tools (least privilege)\n- âœ… Write clear, structured system prompts\n- âœ… Test agent triggering thoroughly\n\n**DON'T:**\n- âŒ Use generic descriptions without examples\n- âŒ Omit triggering conditions\n- âŒ Give all agents same color\n- âŒ Grant unnecessary tool access\n- âŒ Write vague system prompts\n- âŒ Skip testing\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed guidance, consult:\n\n- **`references/system-prompt-design.md`** - Complete system prompt patterns\n- **`references/triggering-examples.md`** - Example formats and best practices\n- **`references/agent-creation-system-prompt.md`** - The exact prompt from Claude Code\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`agent-creation-prompt.md`** - AI-assisted agent generation template\n- **`complete-agent-examples.md`** - Full agent examples for different use cases\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-agent.sh`** - Validate agent file structure\n- **`test-agent-trigger.sh`** - Test if agent triggers correctly\n\n## Implementation Workflow\n\nTo create an agent for a plugin:\n\n1. Define agent purpose and triggering conditions\n2. Choose creation method (AI-assisted or manual)\n3. Create `agents/agent-name.md` file\n4. Write frontmatter with all required fields\n5. Write system prompt following best practices\n6. Include 2-4 triggering examples in description\n7. Validate with `scripts/validate-agent.sh`\n8. Test triggering with real scenarios\n9. Document agent in plugin README\n\nFocus on clear triggering conditions and comprehensive system prompts for autonomous operation."
              },
              {
                "name": "Command Development",
                "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
                "path": "plugins/plugin-dev/skills/command-development/SKILL.md",
                "frontmatter": {
                  "name": "Command Development",
                  "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
                  "version": "0.2.0"
                },
                "content": "# Command Development for Claude Code\n\n## Overview\n\nSlash commands are frequently-used prompts defined as Markdown files that Claude executes during interactive sessions. Understanding command structure, frontmatter options, and dynamic features enables creating powerful, reusable workflows.\n\n**Key concepts:**\n- Markdown file format for commands\n- YAML frontmatter for configuration\n- Dynamic arguments and file references\n- Bash execution for context\n- Command organization and namespacing\n\n## Command Basics\n\n### What is a Slash Command?\n\nA slash command is a Markdown file containing a prompt that Claude executes when invoked. Commands provide:\n- **Reusability**: Define once, use repeatedly\n- **Consistency**: Standardize common workflows\n- **Sharing**: Distribute across team or projects\n- **Efficiency**: Quick access to complex prompts\n\n### Critical: Commands are Instructions FOR Claude\n\n**Commands are written for agent consumption, not human consumption.**\n\nWhen a user invokes `/command-name`, the command content becomes Claude's instructions. Write commands as directives TO Claude about what to do, not as messages TO the user.\n\n**Correct approach (instructions for Claude):**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication issues\n\nProvide specific line numbers and severity ratings.\n```\n\n**Incorrect approach (messages to user):**\n```markdown\nThis command will review your code for security issues.\nYou'll receive a report with vulnerability details.\n```\n\nThe first example tells Claude what to do. The second tells the user what will happen but doesn't instruct Claude. Always use the first approach.\n\n### Command Locations\n\n**Project commands** (shared with team):\n- Location: `.claude/commands/`\n- Scope: Available in specific project\n- Label: Shown as \"(project)\" in `/help`\n- Use for: Team workflows, project-specific tasks\n\n**Personal commands** (available everywhere):\n- Location: `~/.claude/commands/`\n- Scope: Available in all projects\n- Label: Shown as \"(user)\" in `/help`\n- Use for: Personal workflows, cross-project utilities\n\n**Plugin commands** (bundled with plugins):\n- Location: `plugin-name/commands/`\n- Scope: Available when plugin installed\n- Label: Shown as \"(plugin-name)\" in `/help`\n- Use for: Plugin-specific functionality\n\n## File Format\n\n### Basic Structure\n\nCommands are Markdown files with `.md` extension:\n\n```\n.claude/commands/\nâ”œâ”€â”€ review.md           # /review command\nâ”œâ”€â”€ test.md             # /test command\nâ””â”€â”€ deploy.md           # /deploy command\n```\n\n**Simple command:**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication bypass\n- Insecure data handling\n```\n\nNo frontmatter needed for basic commands.\n\n### With YAML Frontmatter\n\nAdd configuration using YAML frontmatter:\n\n```markdown\n---\ndescription: Review code for security issues\nallowed-tools: Read, Grep, Bash(git:*)\nmodel: sonnet\n---\n\nReview this code for security vulnerabilities...\n```\n\n## YAML Frontmatter Fields\n\n### description\n\n**Purpose:** Brief description shown in `/help`\n**Type:** String\n**Default:** First line of command prompt\n\n```yaml\n---\ndescription: Review pull request for code quality\n---\n```\n\n**Best practice:** Clear, actionable description (under 60 characters)\n\n### allowed-tools\n\n**Purpose:** Specify which tools command can use\n**Type:** String or Array\n**Default:** Inherits from conversation\n\n```yaml\n---\nallowed-tools: Read, Write, Edit, Bash(git:*)\n---\n```\n\n**Patterns:**\n- `Read, Write, Edit` - Specific tools\n- `Bash(git:*)` - Bash with git commands only\n- `*` - All tools (rarely needed)\n\n**Use when:** Command requires specific tool access\n\n### model\n\n**Purpose:** Specify model for command execution\n**Type:** String (sonnet, opus, haiku)\n**Default:** Inherits from conversation\n\n```yaml\n---\nmodel: haiku\n---\n```\n\n**Use cases:**\n- `haiku` - Fast, simple commands\n- `sonnet` - Standard workflows\n- `opus` - Complex analysis\n\n### argument-hint\n\n**Purpose:** Document expected arguments for autocomplete\n**Type:** String\n**Default:** None\n\n```yaml\n---\nargument-hint: [pr-number] [priority] [assignee]\n---\n```\n\n**Benefits:**\n- Helps users understand command arguments\n- Improves command discovery\n- Documents command interface\n\n### disable-model-invocation\n\n**Purpose:** Prevent SlashCommand tool from programmatically calling command\n**Type:** Boolean\n**Default:** false\n\n```yaml\n---\ndisable-model-invocation: true\n---\n```\n\n**Use when:** Command should only be manually invoked\n\n## Dynamic Arguments\n\n### Using $ARGUMENTS\n\nCapture all arguments as single string:\n\n```markdown\n---\ndescription: Fix issue by number\nargument-hint: [issue-number]\n---\n\nFix issue #$ARGUMENTS following our coding standards and best practices.\n```\n\n**Usage:**\n```\n> /fix-issue 123\n> /fix-issue 456\n```\n\n**Expands to:**\n```\nFix issue #123 following our coding standards...\nFix issue #456 following our coding standards...\n```\n\n### Using Positional Arguments\n\nCapture individual arguments with `$1`, `$2`, `$3`, etc.:\n\n```markdown\n---\ndescription: Review PR with priority and assignee\nargument-hint: [pr-number] [priority] [assignee]\n---\n\nReview pull request #$1 with priority level $2.\nAfter review, assign to $3 for follow-up.\n```\n\n**Usage:**\n```\n> /review-pr 123 high alice\n```\n\n**Expands to:**\n```\nReview pull request #123 with priority level high.\nAfter review, assign to alice for follow-up.\n```\n\n### Combining Arguments\n\nMix positional and remaining arguments:\n\n```markdown\nDeploy $1 to $2 environment with options: $3\n```\n\n**Usage:**\n```\n> /deploy api staging --force --skip-tests\n```\n\n**Expands to:**\n```\nDeploy api to staging environment with options: --force --skip-tests\n```\n\n## File References\n\n### Using @ Syntax\n\nInclude file contents in command:\n\n```markdown\n---\ndescription: Review specific file\nargument-hint: [file-path]\n---\n\nReview @$1 for:\n- Code quality\n- Best practices\n- Potential bugs\n```\n\n**Usage:**\n```\n> /review-file src/api/users.ts\n```\n\n**Effect:** Claude reads `src/api/users.ts` before processing command\n\n### Multiple File References\n\nReference multiple files:\n\n```markdown\nCompare @src/old-version.js with @src/new-version.js\n\nIdentify:\n- Breaking changes\n- New features\n- Bug fixes\n```\n\n### Static File References\n\nReference known files without arguments:\n\n```markdown\nReview @package.json and @tsconfig.json for consistency\n\nEnsure:\n- TypeScript version matches\n- Dependencies are aligned\n- Build configuration is correct\n```\n\n## Bash Execution in Commands\n\nCommands can execute bash commands inline to dynamically gather context before Claude processes the command. This is useful for including repository state, environment information, or project-specific context.\n\n**When to use:**\n- Include dynamic context (git status, environment vars, etc.)\n- Gather project/repository state\n- Build context-aware workflows\n\n**Implementation details:**\nFor complete syntax, examples, and best practices, see `references/plugin-features-reference.md` section on bash execution. The reference includes the exact syntax and multiple working examples to avoid execution issues\n\n## Command Organization\n\n### Flat Structure\n\nSimple organization for small command sets:\n\n```\n.claude/commands/\nâ”œâ”€â”€ build.md\nâ”œâ”€â”€ test.md\nâ”œâ”€â”€ deploy.md\nâ”œâ”€â”€ review.md\nâ””â”€â”€ docs.md\n```\n\n**Use when:** 5-15 commands, no clear categories\n\n### Namespaced Structure\n\nOrganize commands in subdirectories:\n\n```\n.claude/commands/\nâ”œâ”€â”€ ci/\nâ”‚   â”œâ”€â”€ build.md        # /build (project:ci)\nâ”‚   â”œâ”€â”€ test.md         # /test (project:ci)\nâ”‚   â””â”€â”€ lint.md         # /lint (project:ci)\nâ”œâ”€â”€ git/\nâ”‚   â”œâ”€â”€ commit.md       # /commit (project:git)\nâ”‚   â””â”€â”€ pr.md           # /pr (project:git)\nâ””â”€â”€ docs/\n    â”œâ”€â”€ generate.md     # /generate (project:docs)\n    â””â”€â”€ publish.md      # /publish (project:docs)\n```\n\n**Benefits:**\n- Logical grouping by category\n- Namespace shown in `/help`\n- Easier to find related commands\n\n**Use when:** 15+ commands, clear categories\n\n## Best Practices\n\n### Command Design\n\n1. **Single responsibility:** One command, one task\n2. **Clear descriptions:** Self-explanatory in `/help`\n3. **Explicit dependencies:** Use `allowed-tools` when needed\n4. **Document arguments:** Always provide `argument-hint`\n5. **Consistent naming:** Use verb-noun pattern (review-pr, fix-issue)\n\n### Argument Handling\n\n1. **Validate arguments:** Check for required arguments in prompt\n2. **Provide defaults:** Suggest defaults when arguments missing\n3. **Document format:** Explain expected argument format\n4. **Handle edge cases:** Consider missing or invalid arguments\n\n```markdown\n---\nargument-hint: [pr-number]\n---\n\n$IF($1,\n  Review PR #$1,\n  Please provide a PR number. Usage: /review-pr [number]\n)\n```\n\n### File References\n\n1. **Explicit paths:** Use clear file paths\n2. **Check existence:** Handle missing files gracefully\n3. **Relative paths:** Use project-relative paths\n4. **Glob support:** Consider using Glob tool for patterns\n\n### Bash Commands\n\n1. **Limit scope:** Use `Bash(git:*)` not `Bash(*)`\n2. **Safe commands:** Avoid destructive operations\n3. **Handle errors:** Consider command failures\n4. **Keep fast:** Long-running commands slow invocation\n\n### Documentation\n\n1. **Add comments:** Explain complex logic\n2. **Provide examples:** Show usage in comments\n3. **List requirements:** Document dependencies\n4. **Version commands:** Note breaking changes\n\n```markdown\n---\ndescription: Deploy application to environment\nargument-hint: [environment] [version]\n---\n\n<!--\nUsage: /deploy [staging|production] [version]\nRequires: AWS credentials configured\nExample: /deploy staging v1.2.3\n-->\n\nDeploy application to $1 environment using version $2...\n```\n\n## Common Patterns\n\n### Review Pattern\n\n```markdown\n---\ndescription: Review code changes\nallowed-tools: Read, Bash(git:*)\n---\n\nFiles changed: !`git diff --name-only`\n\nReview each file for:\n1. Code quality and style\n2. Potential bugs or issues\n3. Test coverage\n4. Documentation needs\n\nProvide specific feedback for each file.\n```\n\n### Testing Pattern\n\n```markdown\n---\ndescription: Run tests for specific file\nargument-hint: [test-file]\nallowed-tools: Bash(npm:*)\n---\n\nRun tests: !`npm test $1`\n\nAnalyze results and suggest fixes for failures.\n```\n\n### Documentation Pattern\n\n```markdown\n---\ndescription: Generate documentation for file\nargument-hint: [source-file]\n---\n\nGenerate comprehensive documentation for @$1 including:\n- Function/class descriptions\n- Parameter documentation\n- Return value descriptions\n- Usage examples\n- Edge cases and errors\n```\n\n### Workflow Pattern\n\n```markdown\n---\ndescription: Complete PR workflow\nargument-hint: [pr-number]\nallowed-tools: Bash(gh:*), Read\n---\n\nPR #$1 Workflow:\n\n1. Fetch PR: !`gh pr view $1`\n2. Review changes\n3. Run checks\n4. Approve or request changes\n```\n\n## Troubleshooting\n\n**Command not appearing:**\n- Check file is in correct directory\n- Verify `.md` extension present\n- Ensure valid Markdown format\n- Restart Claude Code\n\n**Arguments not working:**\n- Verify `$1`, `$2` syntax correct\n- Check `argument-hint` matches usage\n- Ensure no extra spaces\n\n**Bash execution failing:**\n- Check `allowed-tools` includes Bash\n- Verify command syntax in backticks\n- Test command in terminal first\n- Check for required permissions\n\n**File references not working:**\n- Verify `@` syntax correct\n- Check file path is valid\n- Ensure Read tool allowed\n- Use absolute or project-relative paths\n\n## Plugin-Specific Features\n\n### CLAUDE_PLUGIN_ROOT Variable\n\nPlugin commands have access to `${CLAUDE_PLUGIN_ROOT}`, an environment variable that resolves to the plugin's absolute path.\n\n**Purpose:**\n- Reference plugin files portably\n- Execute plugin scripts\n- Load plugin configuration\n- Access plugin templates\n\n**Basic usage:**\n\n```markdown\n---\ndescription: Analyze using plugin script\nallowed-tools: Bash(node:*)\n---\n\nRun analysis: !`node ${CLAUDE_PLUGIN_ROOT}/scripts/analyze.js $1`\n\nReview results and report findings.\n```\n\n**Common patterns:**\n\n```markdown\n# Execute plugin script\n!`bash ${CLAUDE_PLUGIN_ROOT}/scripts/script.sh`\n\n# Load plugin configuration\n@${CLAUDE_PLUGIN_ROOT}/config/settings.json\n\n# Use plugin template\n@${CLAUDE_PLUGIN_ROOT}/templates/report.md\n\n# Access plugin resources\n@${CLAUDE_PLUGIN_ROOT}/docs/reference.md\n```\n\n**Why use it:**\n- Works across all installations\n- Portable between systems\n- No hardcoded paths needed\n- Essential for multi-file plugins\n\n### Plugin Command Organization\n\nPlugin commands discovered automatically from `commands/` directory:\n\n```\nplugin-name/\nâ”œâ”€â”€ commands/\nâ”‚   â”œâ”€â”€ foo.md              # /foo (plugin:plugin-name)\nâ”‚   â”œâ”€â”€ bar.md              # /bar (plugin:plugin-name)\nâ”‚   â””â”€â”€ utils/\nâ”‚       â””â”€â”€ helper.md       # /helper (plugin:plugin-name:utils)\nâ””â”€â”€ plugin.json\n```\n\n**Namespace benefits:**\n- Logical command grouping\n- Shown in `/help` output\n- Avoid name conflicts\n- Organize related commands\n\n**Naming conventions:**\n- Use descriptive action names\n- Avoid generic names (test, run)\n- Consider plugin-specific prefix\n- Use hyphens for multi-word names\n\n### Plugin Command Patterns\n\n**Configuration-based pattern:**\n\n```markdown\n---\ndescription: Deploy using plugin configuration\nargument-hint: [environment]\nallowed-tools: Read, Bash(*)\n---\n\nLoad configuration: @${CLAUDE_PLUGIN_ROOT}/config/$1-deploy.json\n\nDeploy to $1 using configuration settings.\nMonitor deployment and report status.\n```\n\n**Template-based pattern:**\n\n```markdown\n---\ndescription: Generate docs from template\nargument-hint: [component]\n---\n\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/docs.md\n\nGenerate documentation for $1 following template structure.\n```\n\n**Multi-script pattern:**\n\n```markdown\n---\ndescription: Complete build workflow\nallowed-tools: Bash(*)\n---\n\nBuild: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh`\nTest: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/test.sh`\nPackage: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/package.sh`\n\nReview outputs and report workflow status.\n```\n\n**See `references/plugin-features-reference.md` for detailed patterns.**\n\n## Integration with Plugin Components\n\nCommands can integrate with other plugin components for powerful workflows.\n\n### Agent Integration\n\nLaunch plugin agents for complex tasks:\n\n```markdown\n---\ndescription: Deep code review\nargument-hint: [file-path]\n---\n\nInitiate comprehensive review of @$1 using the code-reviewer agent.\n\nThe agent will analyze:\n- Code structure\n- Security issues\n- Performance\n- Best practices\n\nAgent uses plugin resources:\n- ${CLAUDE_PLUGIN_ROOT}/config/rules.json\n- ${CLAUDE_PLUGIN_ROOT}/checklists/review.md\n```\n\n**Key points:**\n- Agent must exist in `plugin/agents/` directory\n- Claude uses Task tool to launch agent\n- Document agent capabilities\n- Reference plugin resources agent uses\n\n### Skill Integration\n\nLeverage plugin skills for specialized knowledge:\n\n```markdown\n---\ndescription: Document API with standards\nargument-hint: [api-file]\n---\n\nDocument API in @$1 following plugin standards.\n\nUse the api-docs-standards skill to ensure:\n- Complete endpoint documentation\n- Consistent formatting\n- Example quality\n- Error documentation\n\nGenerate production-ready API docs.\n```\n\n**Key points:**\n- Skill must exist in `plugin/skills/` directory\n- Mention skill name to trigger invocation\n- Document skill purpose\n- Explain what skill provides\n\n### Hook Coordination\n\nDesign commands that work with plugin hooks:\n- Commands can prepare state for hooks to process\n- Hooks execute automatically on tool events\n- Commands should document expected hook behavior\n- Guide Claude on interpreting hook output\n\nSee `references/plugin-features-reference.md` for examples of commands that coordinate with hooks\n\n### Multi-Component Workflows\n\nCombine agents, skills, and scripts:\n\n```markdown\n---\ndescription: Comprehensive review workflow\nargument-hint: [file]\nallowed-tools: Bash(node:*), Read\n---\n\nTarget: @$1\n\nPhase 1 - Static Analysis:\n!`node ${CLAUDE_PLUGIN_ROOT}/scripts/lint.js $1`\n\nPhase 2 - Deep Review:\nLaunch code-reviewer agent for detailed analysis.\n\nPhase 3 - Standards Check:\nUse coding-standards skill for validation.\n\nPhase 4 - Report:\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/review.md\n\nCompile findings into report following template.\n```\n\n**When to use:**\n- Complex multi-step workflows\n- Leverage multiple plugin capabilities\n- Require specialized analysis\n- Need structured outputs\n\n## Validation Patterns\n\nCommands should validate inputs and resources before processing.\n\n### Argument Validation\n\n```markdown\n---\ndescription: Deploy with validation\nargument-hint: [environment]\n---\n\nValidate environment: !`echo \"$1\" | grep -E \"^(dev|staging|prod)$\" || echo \"INVALID\"`\n\nIf $1 is valid environment:\n  Deploy to $1\nOtherwise:\n  Explain valid environments: dev, staging, prod\n  Show usage: /deploy [environment]\n```\n\n### File Existence Checks\n\n```markdown\n---\ndescription: Process configuration\nargument-hint: [config-file]\n---\n\nCheck file exists: !`test -f $1 && echo \"EXISTS\" || echo \"MISSING\"`\n\nIf file exists:\n  Process configuration: @$1\nOtherwise:\n  Explain where to place config file\n  Show expected format\n  Provide example configuration\n```\n\n### Plugin Resource Validation\n\n```markdown\n---\ndescription: Run plugin analyzer\nallowed-tools: Bash(test:*)\n---\n\nValidate plugin setup:\n- Script: !`test -x ${CLAUDE_PLUGIN_ROOT}/bin/analyze && echo \"âœ“\" || echo \"âœ—\"`\n- Config: !`test -f ${CLAUDE_PLUGIN_ROOT}/config.json && echo \"âœ“\" || echo \"âœ—\"`\n\nIf all checks pass, run analysis.\nOtherwise, report missing components.\n```\n\n### Error Handling\n\n```markdown\n---\ndescription: Build with error handling\nallowed-tools: Bash(*)\n---\n\nExecute build: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh 2>&1 || echo \"BUILD_FAILED\"`\n\nIf build succeeded:\n  Report success and output location\nIf build failed:\n  Analyze error output\n  Suggest likely causes\n  Provide troubleshooting steps\n```\n\n**Best practices:**\n- Validate early in command\n- Provide helpful error messages\n- Suggest corrective actions\n- Handle edge cases gracefully\n\n---\n\nFor detailed frontmatter field specifications, see `references/frontmatter-reference.md`.\nFor plugin-specific features and patterns, see `references/plugin-features-reference.md`.\nFor command pattern examples, see `examples/` directory."
              },
              {
                "name": "Hook Development",
                "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
                "path": "plugins/plugin-dev/skills/hook-development/SKILL.md",
                "frontmatter": {
                  "name": "Hook Development",
                  "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
                  "version": "0.1.0"
                },
                "content": "# Hook Development for Claude Code Plugins\n\n## Overview\n\nHooks are event-driven automation scripts that execute in response to Claude Code events. Use hooks to validate operations, enforce policies, add context, and integrate external tools into workflows.\n\n**Key capabilities:**\n- Validate tool calls before execution (PreToolUse)\n- React to tool results (PostToolUse)\n- Enforce completion standards (Stop, SubagentStop)\n- Load project context (SessionStart)\n- Automate workflows across the development lifecycle\n\n## Hook Types\n\n### Prompt-Based Hooks (Recommended)\n\nUse LLM-driven decision making for context-aware validation:\n\n```json\n{\n  \"type\": \"prompt\",\n  \"prompt\": \"Evaluate if this tool use is appropriate: $TOOL_INPUT\",\n  \"timeout\": 30\n}\n```\n\n**Supported events:** Stop, SubagentStop, UserPromptSubmit, PreToolUse\n\n**Benefits:**\n- Context-aware decisions based on natural language reasoning\n- Flexible evaluation logic without bash scripting\n- Better edge case handling\n- Easier to maintain and extend\n\n### Command Hooks\n\nExecute bash commands for deterministic checks:\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\",\n  \"timeout\": 60\n}\n```\n\n**Use for:**\n- Fast deterministic validations\n- File system operations\n- External tool integrations\n- Performance-critical checks\n\n## Hook Configuration Formats\n\n### Plugin hooks.json Format\n\n**For plugin hooks** in `hooks/hooks.json`, use wrapper format:\n\n```json\n{\n  \"description\": \"Brief explanation of hooks (optional)\",\n  \"hooks\": {\n    \"PreToolUse\": [...],\n    \"Stop\": [...],\n    \"SessionStart\": [...]\n  }\n}\n```\n\n**Key points:**\n- `description` field is optional\n- `hooks` field is required wrapper containing actual hook events\n- This is the **plugin-specific format**\n\n**Example:**\n```json\n{\n  \"description\": \"Validation hooks for code quality\",\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Write\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/validate.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n### Settings Format (Direct)\n\n**For user settings** in `.claude/settings.json`, use direct format:\n\n```json\n{\n  \"PreToolUse\": [...],\n  \"Stop\": [...],\n  \"SessionStart\": [...]\n}\n```\n\n**Key points:**\n- No wrapper - events directly at top level\n- No description field\n- This is the **settings format**\n\n**Important:** The examples below show the hook event structure that goes inside either format. For plugin hooks.json, wrap these in `{\"hooks\": {...}}`.\n\n## Hook Events\n\n### PreToolUse\n\nExecute before any tool runs. Use to approve, deny, or modify tool calls.\n\n**Example (prompt-based):**\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety. Check: system paths, credentials, path traversal, sensitive content. Return 'approve' or 'deny'.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output for PreToolUse:**\n```json\n{\n  \"hookSpecificOutput\": {\n    \"permissionDecision\": \"allow|deny|ask\",\n    \"updatedInput\": {\"field\": \"modified_value\"}\n  },\n  \"systemMessage\": \"Explanation for Claude\"\n}\n```\n\n### PostToolUse\n\nExecute after tool completes. Use to react to results, provide feedback, or log.\n\n**Example:**\n```json\n{\n  \"PostToolUse\": [\n    {\n      \"matcher\": \"Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Analyze edit result for potential issues: syntax errors, security vulnerabilities, breaking changes. Provide feedback.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output behavior:**\n- Exit 0: stdout shown in transcript\n- Exit 2: stderr fed back to Claude\n- systemMessage included in context\n\n### Stop\n\nExecute when main agent considers stopping. Use to validate completeness.\n\n**Example:**\n```json\n{\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion: tests run, build succeeded, questions answered. Return 'approve' to stop or 'block' with reason to continue.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Decision output:**\n```json\n{\n  \"decision\": \"approve|block\",\n  \"reason\": \"Explanation\",\n  \"systemMessage\": \"Additional context\"\n}\n```\n\n### SubagentStop\n\nExecute when subagent considers stopping. Use to ensure subagent completed its task.\n\nSimilar to Stop hook, but for subagents.\n\n### UserPromptSubmit\n\nExecute when user submits a prompt. Use to add context, validate, or block prompts.\n\n**Example:**\n```json\n{\n  \"UserPromptSubmit\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Check if prompt requires security guidance. If discussing auth, permissions, or API security, return relevant warnings.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### SessionStart\n\nExecute when Claude Code session begins. Use to load context and set environment.\n\n**Example:**\n```json\n{\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Special capability:** Persist environment variables using `$CLAUDE_ENV_FILE`:\n```bash\necho \"export PROJECT_TYPE=nodejs\" >> \"$CLAUDE_ENV_FILE\"\n```\n\nSee `examples/load-context.sh` for complete example.\n\n### SessionEnd\n\nExecute when session ends. Use for cleanup, logging, and state preservation.\n\n### PreCompact\n\nExecute before context compaction. Use to add critical information to preserve.\n\n### Notification\n\nExecute when Claude sends notifications. Use to react to user notifications.\n\n## Hook Output Format\n\n### Standard Output (All Hooks)\n\n```json\n{\n  \"continue\": true,\n  \"suppressOutput\": false,\n  \"systemMessage\": \"Message for Claude\"\n}\n```\n\n- `continue`: If false, halt processing (default true)\n- `suppressOutput`: Hide output from transcript (default false)\n- `systemMessage`: Message shown to Claude\n\n### Exit Codes\n\n- `0` - Success (stdout shown in transcript)\n- `2` - Blocking error (stderr fed back to Claude)\n- Other - Non-blocking error\n\n## Hook Input Format\n\nAll hooks receive JSON via stdin with common fields:\n\n```json\n{\n  \"session_id\": \"abc123\",\n  \"transcript_path\": \"/path/to/transcript.txt\",\n  \"cwd\": \"/current/working/dir\",\n  \"permission_mode\": \"ask|allow\",\n  \"hook_event_name\": \"PreToolUse\"\n}\n```\n\n**Event-specific fields:**\n\n- **PreToolUse/PostToolUse:** `tool_name`, `tool_input`, `tool_result`\n- **UserPromptSubmit:** `user_prompt`\n- **Stop/SubagentStop:** `reason`\n\nAccess fields in prompts using `$TOOL_INPUT`, `$TOOL_RESULT`, `$USER_PROMPT`, etc.\n\n## Environment Variables\n\nAvailable in all command hooks:\n\n- `$CLAUDE_PROJECT_DIR` - Project root path\n- `$CLAUDE_PLUGIN_ROOT` - Plugin directory (use for portable paths)\n- `$CLAUDE_ENV_FILE` - SessionStart only: persist env vars here\n- `$CLAUDE_CODE_REMOTE` - Set if running in remote context\n\n**Always use ${CLAUDE_PLUGIN_ROOT} in hook commands for portability:**\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\"\n}\n```\n\n## Plugin Hook Configuration\n\nIn plugins, define hooks in `hooks/hooks.json`:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety\"\n        }\n      ]\n    }\n  ],\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion\"\n        }\n      ]\n    }\n  ],\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\",\n          \"timeout\": 10\n        }\n      ]\n    }\n  ]\n}\n```\n\nPlugin hooks merge with user's hooks and run in parallel.\n\n## Matchers\n\n### Tool Name Matching\n\n**Exact match:**\n```json\n\"matcher\": \"Write\"\n```\n\n**Multiple tools:**\n```json\n\"matcher\": \"Read|Write|Edit\"\n```\n\n**Wildcard (all tools):**\n```json\n\"matcher\": \"*\"\n```\n\n**Regex patterns:**\n```json\n\"matcher\": \"mcp__.*__delete.*\"  // All MCP delete tools\n```\n\n**Note:** Matchers are case-sensitive.\n\n### Common Patterns\n\n```json\n// All MCP tools\n\"matcher\": \"mcp__.*\"\n\n// Specific plugin's MCP tools\n\"matcher\": \"mcp__plugin_asana_.*\"\n\n// All file operations\n\"matcher\": \"Read|Write|Edit\"\n\n// Bash commands only\n\"matcher\": \"Bash\"\n```\n\n## Security Best Practices\n\n### Input Validation\n\nAlways validate inputs in command hooks:\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\ninput=$(cat)\ntool_name=$(echo \"$input\" | jq -r '.tool_name')\n\n# Validate tool name format\nif [[ ! \"$tool_name\" =~ ^[a-zA-Z0-9_]+$ ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Invalid tool name\"}' >&2\n  exit 2\nfi\n```\n\n### Path Safety\n\nCheck for path traversal and sensitive files:\n\n```bash\nfile_path=$(echo \"$input\" | jq -r '.tool_input.file_path')\n\n# Deny path traversal\nif [[ \"$file_path\" == *\"..\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Path traversal detected\"}' >&2\n  exit 2\nfi\n\n# Deny sensitive files\nif [[ \"$file_path\" == *\".env\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Sensitive file\"}' >&2\n  exit 2\nfi\n```\n\nSee `examples/validate-write.sh` and `examples/validate-bash.sh` for complete examples.\n\n### Quote All Variables\n\n```bash\n# GOOD: Quoted\necho \"$file_path\"\ncd \"$CLAUDE_PROJECT_DIR\"\n\n# BAD: Unquoted (injection risk)\necho $file_path\ncd $CLAUDE_PROJECT_DIR\n```\n\n### Set Appropriate Timeouts\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash script.sh\",\n  \"timeout\": 10\n}\n```\n\n**Defaults:** Command hooks (60s), Prompt hooks (30s)\n\n## Performance Considerations\n\n### Parallel Execution\n\nAll matching hooks run **in parallel**:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write\",\n      \"hooks\": [\n        {\"type\": \"command\", \"command\": \"check1.sh\"},  // Parallel\n        {\"type\": \"command\", \"command\": \"check2.sh\"},  // Parallel\n        {\"type\": \"prompt\", \"prompt\": \"Validate...\"}   // Parallel\n      ]\n    }\n  ]\n}\n```\n\n**Design implications:**\n- Hooks don't see each other's output\n- Non-deterministic ordering\n- Design for independence\n\n### Optimization\n\n1. Use command hooks for quick deterministic checks\n2. Use prompt hooks for complex reasoning\n3. Cache validation results in temp files\n4. Minimize I/O in hot paths\n\n## Temporarily Active Hooks\n\nCreate hooks that activate conditionally by checking for a flag file or configuration:\n\n**Pattern: Flag file activation**\n```bash\n#!/bin/bash\n# Only active when flag file exists\nFLAG_FILE=\"$CLAUDE_PROJECT_DIR/.enable-strict-validation\"\n\nif [ ! -f \"$FLAG_FILE\" ]; then\n  # Flag not present, skip validation\n  exit 0\nfi\n\n# Flag present, run validation\ninput=$(cat)\n# ... validation logic ...\n```\n\n**Pattern: Configuration-based activation**\n```bash\n#!/bin/bash\n# Check configuration for activation\nCONFIG_FILE=\"$CLAUDE_PROJECT_DIR/.claude/plugin-config.json\"\n\nif [ -f \"$CONFIG_FILE\" ]; then\n  enabled=$(jq -r '.strictMode // false' \"$CONFIG_FILE\")\n  if [ \"$enabled\" != \"true\" ]; then\n    exit 0  # Not enabled, skip\n  fi\nfi\n\n# Enabled, run hook logic\ninput=$(cat)\n# ... hook logic ...\n```\n\n**Use cases:**\n- Enable strict validation only when needed\n- Temporary debugging hooks\n- Project-specific hook behavior\n- Feature flags for hooks\n\n**Best practice:** Document activation mechanism in plugin README so users know how to enable/disable temporary hooks.\n\n## Hook Lifecycle and Limitations\n\n### Hooks Load at Session Start\n\n**Important:** Hooks are loaded when Claude Code session starts. Changes to hook configuration require restarting Claude Code.\n\n**Cannot hot-swap hooks:**\n- Editing `hooks/hooks.json` won't affect current session\n- Adding new hook scripts won't be recognized\n- Changing hook commands/prompts won't update\n- Must restart Claude Code: exit and run `claude` again\n\n**To test hook changes:**\n1. Edit hook configuration or scripts\n2. Exit Claude Code session\n3. Restart: `claude` or `cc`\n4. New hook configuration loads\n5. Test hooks with `claude --debug`\n\n### Hook Validation at Startup\n\nHooks are validated when Claude Code starts:\n- Invalid JSON in hooks.json causes loading failure\n- Missing scripts cause warnings\n- Syntax errors reported in debug mode\n\nUse `/hooks` command to review loaded hooks in current session.\n\n## Debugging Hooks\n\n### Enable Debug Mode\n\n```bash\nclaude --debug\n```\n\nLook for hook registration, execution logs, input/output JSON, and timing information.\n\n### Test Hook Scripts\n\nTest command hooks directly:\n\n```bash\necho '{\"tool_name\": \"Write\", \"tool_input\": {\"file_path\": \"/test\"}}' | \\\n  bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\n\necho \"Exit code: $?\"\n```\n\n### Validate JSON Output\n\nEnsure hooks output valid JSON:\n\n```bash\noutput=$(./your-hook.sh < test-input.json)\necho \"$output\" | jq .\n```\n\n## Quick Reference\n\n### Hook Events Summary\n\n| Event | When | Use For |\n|-------|------|---------|\n| PreToolUse | Before tool | Validation, modification |\n| PostToolUse | After tool | Feedback, logging |\n| UserPromptSubmit | User input | Context, validation |\n| Stop | Agent stopping | Completeness check |\n| SubagentStop | Subagent done | Task validation |\n| SessionStart | Session begins | Context loading |\n| SessionEnd | Session ends | Cleanup, logging |\n| PreCompact | Before compact | Preserve context |\n| Notification | User notified | Logging, reactions |\n\n### Best Practices\n\n**DO:**\n- âœ… Use prompt-based hooks for complex logic\n- âœ… Use ${CLAUDE_PLUGIN_ROOT} for portability\n- âœ… Validate all inputs in command hooks\n- âœ… Quote all bash variables\n- âœ… Set appropriate timeouts\n- âœ… Return structured JSON output\n- âœ… Test hooks thoroughly\n\n**DON'T:**\n- âŒ Use hardcoded paths\n- âŒ Trust user input without validation\n- âŒ Create long-running hooks\n- âŒ Rely on hook execution order\n- âŒ Modify global state unpredictably\n- âŒ Log sensitive information\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and advanced techniques, consult:\n\n- **`references/patterns.md`** - Common hook patterns (8+ proven patterns)\n- **`references/migration.md`** - Migrating from basic to advanced hooks\n- **`references/advanced.md`** - Advanced use cases and techniques\n\n### Example Hook Scripts\n\nWorking examples in `examples/`:\n\n- **`validate-write.sh`** - File write validation example\n- **`validate-bash.sh`** - Bash command validation example\n- **`load-context.sh`** - SessionStart context loading example\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-hook-schema.sh`** - Validate hooks.json structure and syntax\n- **`test-hook.sh`** - Test hooks with sample input before deployment\n- **`hook-linter.sh`** - Check hook scripts for common issues and best practices\n\n### External Resources\n\n- **Official Docs**: https://docs.claude.com/en/docs/claude-code/hooks\n- **Examples**: See security-guidance plugin in marketplace\n- **Testing**: Use `claude --debug` for detailed logs\n- **Validation**: Use `jq` to validate hook JSON output\n\n## Implementation Workflow\n\nTo implement hooks in a plugin:\n\n1. Identify events to hook into (PreToolUse, Stop, SessionStart, etc.)\n2. Decide between prompt-based (flexible) or command (deterministic) hooks\n3. Write hook configuration in `hooks/hooks.json`\n4. For command hooks, create hook scripts\n5. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n6. Validate configuration with `scripts/validate-hook-schema.sh hooks/hooks.json`\n7. Test hooks with `scripts/test-hook.sh` before deployment\n8. Test in Claude Code with `claude --debug`\n9. Document hooks in plugin README\n\nFocus on prompt-based hooks for most use cases. Reserve command hooks for performance-critical or deterministic checks."
              },
              {
                "name": "MCP Integration",
                "description": "This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration.",
                "path": "plugins/plugin-dev/skills/mcp-integration/SKILL.md",
                "frontmatter": {
                  "name": "MCP Integration",
                  "description": "This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration.",
                  "version": "0.1.0"
                },
                "content": "# MCP Integration for Claude Code Plugins\n\n## Overview\n\nModel Context Protocol (MCP) enables Claude Code plugins to integrate with external services and APIs by providing structured tool access. Use MCP integration to expose external service capabilities as tools within Claude Code.\n\n**Key capabilities:**\n- Connect to external services (databases, APIs, file systems)\n- Provide 10+ related tools from a single service\n- Handle OAuth and complex authentication flows\n- Bundle MCP servers with plugins for automatic setup\n\n## MCP Server Configuration Methods\n\nPlugins can bundle MCP servers in two ways:\n\n### Method 1: Dedicated .mcp.json (Recommended)\n\nCreate `.mcp.json` at plugin root:\n\n```json\n{\n  \"database-tools\": {\n    \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/db-server\",\n    \"args\": [\"--config\", \"${CLAUDE_PLUGIN_ROOT}/config.json\"],\n    \"env\": {\n      \"DB_URL\": \"${DB_URL}\"\n    }\n  }\n}\n```\n\n**Benefits:**\n- Clear separation of concerns\n- Easier to maintain\n- Better for multiple servers\n\n### Method 2: Inline in plugin.json\n\nAdd `mcpServers` field to plugin.json:\n\n```json\n{\n  \"name\": \"my-plugin\",\n  \"version\": \"1.0.0\",\n  \"mcpServers\": {\n    \"plugin-api\": {\n      \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/api-server\",\n      \"args\": [\"--port\", \"8080\"]\n    }\n  }\n}\n```\n\n**Benefits:**\n- Single configuration file\n- Good for simple single-server plugins\n\n## MCP Server Types\n\n### stdio (Local Process)\n\nExecute local MCP servers as child processes. Best for local tools and custom servers.\n\n**Configuration:**\n```json\n{\n  \"filesystem\": {\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/allowed/path\"],\n    \"env\": {\n      \"LOG_LEVEL\": \"debug\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- File system access\n- Local database connections\n- Custom MCP servers\n- NPM-packaged MCP servers\n\n**Process management:**\n- Claude Code spawns and manages the process\n- Communicates via stdin/stdout\n- Terminates when Claude Code exits\n\n### SSE (Server-Sent Events)\n\nConnect to hosted MCP servers with OAuth support. Best for cloud services.\n\n**Configuration:**\n```json\n{\n  \"asana\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.asana.com/sse\"\n  }\n}\n```\n\n**Use cases:**\n- Official hosted MCP servers (Asana, GitHub, etc.)\n- Cloud services with MCP endpoints\n- OAuth-based authentication\n- No local installation needed\n\n**Authentication:**\n- OAuth flows handled automatically\n- User prompted on first use\n- Tokens managed by Claude Code\n\n### HTTP (REST API)\n\nConnect to RESTful MCP servers with token authentication.\n\n**Configuration:**\n```json\n{\n  \"api-service\": {\n    \"type\": \"http\",\n    \"url\": \"https://api.example.com/mcp\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${API_TOKEN}\",\n      \"X-Custom-Header\": \"value\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- REST API-based MCP servers\n- Token-based authentication\n- Custom API backends\n- Stateless interactions\n\n### WebSocket (Real-time)\n\nConnect to WebSocket MCP servers for real-time bidirectional communication.\n\n**Configuration:**\n```json\n{\n  \"realtime-service\": {\n    \"type\": \"ws\",\n    \"url\": \"wss://mcp.example.com/ws\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${TOKEN}\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- Real-time data streaming\n- Persistent connections\n- Push notifications from server\n- Low-latency requirements\n\n## Environment Variable Expansion\n\nAll MCP configurations support environment variable substitution:\n\n**${CLAUDE_PLUGIN_ROOT}** - Plugin directory (always use for portability):\n```json\n{\n  \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/my-server\"\n}\n```\n\n**User environment variables** - From user's shell:\n```json\n{\n  \"env\": {\n    \"API_KEY\": \"${MY_API_KEY}\",\n    \"DATABASE_URL\": \"${DB_URL}\"\n  }\n}\n```\n\n**Best practice:** Document all required environment variables in plugin README.\n\n## MCP Tool Naming\n\nWhen MCP servers provide tools, they're automatically prefixed:\n\n**Format:** `mcp__plugin_<plugin-name>_<server-name>__<tool-name>`\n\n**Example:**\n- Plugin: `asana`\n- Server: `asana`\n- Tool: `create_task`\n- **Full name:** `mcp__plugin_asana_asana__asana_create_task`\n\n### Using MCP Tools in Commands\n\nPre-allow specific MCP tools in command frontmatter:\n\n```markdown\n---\nallowed-tools: [\n  \"mcp__plugin_asana_asana__asana_create_task\",\n  \"mcp__plugin_asana_asana__asana_search_tasks\"\n]\n---\n```\n\n**Wildcard (use sparingly):**\n```markdown\n---\nallowed-tools: [\"mcp__plugin_asana_asana__*\"]\n---\n```\n\n**Best practice:** Pre-allow specific tools, not wildcards, for security.\n\n## Lifecycle Management\n\n**Automatic startup:**\n- MCP servers start when plugin enables\n- Connection established before first tool use\n- Restart required for configuration changes\n\n**Lifecycle:**\n1. Plugin loads\n2. MCP configuration parsed\n3. Server process started (stdio) or connection established (SSE/HTTP/WS)\n4. Tools discovered and registered\n5. Tools available as `mcp__plugin_...__...`\n\n**Viewing servers:**\nUse `/mcp` command to see all servers including plugin-provided ones.\n\n## Authentication Patterns\n\n### OAuth (SSE/HTTP)\n\nOAuth handled automatically by Claude Code:\n\n```json\n{\n  \"type\": \"sse\",\n  \"url\": \"https://mcp.example.com/sse\"\n}\n```\n\nUser authenticates in browser on first use. No additional configuration needed.\n\n### Token-Based (Headers)\n\nStatic or environment variable tokens:\n\n```json\n{\n  \"type\": \"http\",\n  \"url\": \"https://api.example.com\",\n  \"headers\": {\n    \"Authorization\": \"Bearer ${API_TOKEN}\"\n  }\n}\n```\n\nDocument required environment variables in README.\n\n### Environment Variables (stdio)\n\nPass configuration to MCP server:\n\n```json\n{\n  \"command\": \"python\",\n  \"args\": [\"-m\", \"my_mcp_server\"],\n  \"env\": {\n    \"DATABASE_URL\": \"${DB_URL}\",\n    \"API_KEY\": \"${API_KEY}\",\n    \"LOG_LEVEL\": \"info\"\n  }\n}\n```\n\n## Integration Patterns\n\n### Pattern 1: Simple Tool Wrapper\n\nCommands use MCP tools with user interaction:\n\n```markdown\n# Command: create-item.md\n---\nallowed-tools: [\"mcp__plugin_name_server__create_item\"]\n---\n\nSteps:\n1. Gather item details from user\n2. Use mcp__plugin_name_server__create_item\n3. Confirm creation\n```\n\n**Use for:** Adding validation or preprocessing before MCP calls.\n\n### Pattern 2: Autonomous Agent\n\nAgents use MCP tools autonomously:\n\n```markdown\n# Agent: data-analyzer.md\n\nAnalysis Process:\n1. Query data via mcp__plugin_db_server__query\n2. Process and analyze results\n3. Generate insights report\n```\n\n**Use for:** Multi-step MCP workflows without user interaction.\n\n### Pattern 3: Multi-Server Plugin\n\nIntegrate multiple MCP servers:\n\n```json\n{\n  \"github\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.github.com/sse\"\n  },\n  \"jira\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.jira.com/sse\"\n  }\n}\n```\n\n**Use for:** Workflows spanning multiple services.\n\n## Security Best Practices\n\n### Use HTTPS/WSS\n\nAlways use secure connections:\n\n```json\nâœ… \"url\": \"https://mcp.example.com/sse\"\nâŒ \"url\": \"http://mcp.example.com/sse\"\n```\n\n### Token Management\n\n**DO:**\n- âœ… Use environment variables for tokens\n- âœ… Document required env vars in README\n- âœ… Let OAuth flow handle authentication\n\n**DON'T:**\n- âŒ Hardcode tokens in configuration\n- âŒ Commit tokens to git\n- âŒ Share tokens in documentation\n\n### Permission Scoping\n\nPre-allow only necessary MCP tools:\n\n```markdown\nâœ… allowed-tools: [\n  \"mcp__plugin_api_server__read_data\",\n  \"mcp__plugin_api_server__create_item\"\n]\n\nâŒ allowed-tools: [\"mcp__plugin_api_server__*\"]\n```\n\n## Error Handling\n\n### Connection Failures\n\nHandle MCP server unavailability:\n- Provide fallback behavior in commands\n- Inform user of connection issues\n- Check server URL and configuration\n\n### Tool Call Errors\n\nHandle failed MCP operations:\n- Validate inputs before calling MCP tools\n- Provide clear error messages\n- Check rate limiting and quotas\n\n### Configuration Errors\n\nValidate MCP configuration:\n- Test server connectivity during development\n- Validate JSON syntax\n- Check required environment variables\n\n## Performance Considerations\n\n### Lazy Loading\n\nMCP servers connect on-demand:\n- Not all servers connect at startup\n- First tool use triggers connection\n- Connection pooling managed automatically\n\n### Batching\n\nBatch similar requests when possible:\n\n```\n# Good: Single query with filters\ntasks = search_tasks(project=\"X\", assignee=\"me\", limit=50)\n\n# Avoid: Many individual queries\nfor id in task_ids:\n    task = get_task(id)\n```\n\n## Testing MCP Integration\n\n### Local Testing\n\n1. Configure MCP server in `.mcp.json`\n2. Install plugin locally (`.claude-plugin/`)\n3. Run `/mcp` to verify server appears\n4. Test tool calls in commands\n5. Check `claude --debug` logs for connection issues\n\n### Validation Checklist\n\n- [ ] MCP configuration is valid JSON\n- [ ] Server URL is correct and accessible\n- [ ] Required environment variables documented\n- [ ] Tools appear in `/mcp` output\n- [ ] Authentication works (OAuth or tokens)\n- [ ] Tool calls succeed from commands\n- [ ] Error cases handled gracefully\n\n## Debugging\n\n### Enable Debug Logging\n\n```bash\nclaude --debug\n```\n\nLook for:\n- MCP server connection attempts\n- Tool discovery logs\n- Authentication flows\n- Tool call errors\n\n### Common Issues\n\n**Server not connecting:**\n- Check URL is correct\n- Verify server is running (stdio)\n- Check network connectivity\n- Review authentication configuration\n\n**Tools not available:**\n- Verify server connected successfully\n- Check tool names match exactly\n- Run `/mcp` to see available tools\n- Restart Claude Code after config changes\n\n**Authentication failing:**\n- Clear cached auth tokens\n- Re-authenticate\n- Check token scopes and permissions\n- Verify environment variables set\n\n## Quick Reference\n\n### MCP Server Types\n\n| Type | Transport | Best For | Auth |\n|------|-----------|----------|------|\n| stdio | Process | Local tools, custom servers | Env vars |\n| SSE | HTTP | Hosted services, cloud APIs | OAuth |\n| HTTP | REST | API backends, token auth | Tokens |\n| ws | WebSocket | Real-time, streaming | Tokens |\n\n### Configuration Checklist\n\n- [ ] Server type specified (stdio/SSE/HTTP/ws)\n- [ ] Type-specific fields complete (command or url)\n- [ ] Authentication configured\n- [ ] Environment variables documented\n- [ ] HTTPS/WSS used (not HTTP/WS)\n- [ ] ${CLAUDE_PLUGIN_ROOT} used for paths\n\n### Best Practices\n\n**DO:**\n- âœ… Use ${CLAUDE_PLUGIN_ROOT} for portable paths\n- âœ… Document required environment variables\n- âœ… Use secure connections (HTTPS/WSS)\n- âœ… Pre-allow specific MCP tools in commands\n- âœ… Test MCP integration before publishing\n- âœ… Handle connection and tool errors gracefully\n\n**DON'T:**\n- âŒ Hardcode absolute paths\n- âŒ Commit credentials to git\n- âŒ Use HTTP instead of HTTPS\n- âŒ Pre-allow all tools with wildcards\n- âŒ Skip error handling\n- âŒ Forget to document setup\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed information, consult:\n\n- **`references/server-types.md`** - Deep dive on each server type\n- **`references/authentication.md`** - Authentication patterns and OAuth\n- **`references/tool-usage.md`** - Using MCP tools in commands and agents\n\n### Example Configurations\n\nWorking examples in `examples/`:\n\n- **`stdio-server.json`** - Local stdio MCP server\n- **`sse-server.json`** - Hosted SSE server with OAuth\n- **`http-server.json`** - REST API with token auth\n\n### External Resources\n\n- **Official MCP Docs**: https://modelcontextprotocol.io/\n- **Claude Code MCP Docs**: https://docs.claude.com/en/docs/claude-code/mcp\n- **MCP SDK**: @modelcontextprotocol/sdk\n- **Testing**: Use `claude --debug` and `/mcp` command\n\n## Implementation Workflow\n\nTo add MCP integration to a plugin:\n\n1. Choose MCP server type (stdio, SSE, HTTP, ws)\n2. Create `.mcp.json` at plugin root with configuration\n3. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n4. Document required environment variables in README\n5. Test locally with `/mcp` command\n6. Pre-allow MCP tools in relevant commands\n7. Handle authentication (OAuth or tokens)\n8. Test error cases (connection failures, auth errors)\n9. Document MCP integration in plugin README\n\nFocus on stdio for custom/local servers, SSE for hosted services with OAuth."
              },
              {
                "name": "Plugin Settings",
                "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.",
                "path": "plugins/plugin-dev/skills/plugin-settings/SKILL.md",
                "frontmatter": {
                  "name": "Plugin Settings",
                  "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.",
                  "version": "0.1.0"
                },
                "content": "# Plugin Settings Pattern for Claude Code Plugins\n\n## Overview\n\nPlugins can store user-configurable settings and state in `.claude/plugin-name.local.md` files within the project directory. This pattern uses YAML frontmatter for structured configuration and markdown content for prompts or additional context.\n\n**Key characteristics:**\n- File location: `.claude/plugin-name.local.md` in project root\n- Structure: YAML frontmatter + markdown body\n- Purpose: Per-project plugin configuration and state\n- Usage: Read from hooks, commands, and agents\n- Lifecycle: User-managed (not in git, should be in `.gitignore`)\n\n## File Structure\n\n### Basic Template\n\n```markdown\n---\nenabled: true\nsetting1: value1\nsetting2: value2\nnumeric_setting: 42\nlist_setting: [\"item1\", \"item2\"]\n---\n\n# Additional Context\n\nThis markdown body can contain:\n- Task descriptions\n- Additional instructions\n- Prompts to feed back to Claude\n- Documentation or notes\n```\n\n### Example: Plugin State File\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nenabled: true\nstrict_mode: false\nmax_retries: 3\nnotification_level: info\ncoordinator_session: team-leader\n---\n\n# Plugin Configuration\n\nThis plugin is configured for standard validation mode.\nContact @team-lead with questions.\n```\n\n## Reading Settings Files\n\n### From Hooks (Bash Scripts)\n\n**Pattern: Check existence and parse frontmatter**\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\n# Define state file path\nSTATE_FILE=\".claude/my-plugin.local.md\"\n\n# Quick exit if file doesn't exist\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0  # Plugin not configured, skip\nfi\n\n# Parse YAML frontmatter (between --- markers)\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\n\n# Extract individual fields\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\nSTRICT_MODE=$(echo \"$FRONTMATTER\" | grep '^strict_mode:' | sed 's/strict_mode: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n\n# Check if enabled\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Use configuration in hook logic\nif [[ \"$STRICT_MODE\" == \"true\" ]]; then\n  # Apply strict validation\n  # ...\nfi\n```\n\nSee `examples/read-settings-hook.sh` for complete working example.\n\n### From Commands\n\nCommands can read settings files to customize behavior:\n\n```markdown\n---\ndescription: Process data with plugin\nallowed-tools: [\"Read\", \"Bash\"]\n---\n\n# Process Command\n\nSteps:\n1. Check if settings exist at `.claude/my-plugin.local.md`\n2. Read configuration using Read tool\n3. Parse YAML frontmatter to extract settings\n4. Apply settings to processing logic\n5. Execute with configured behavior\n```\n\n### From Agents\n\nAgents can reference settings in their instructions:\n\n```markdown\n---\nname: configured-agent\ndescription: Agent that adapts to project settings\n---\n\nCheck for plugin settings at `.claude/my-plugin.local.md`.\nIf present, parse YAML frontmatter and adapt behavior according to:\n- enabled: Whether plugin is active\n- mode: Processing mode (strict, standard, lenient)\n- Additional configuration fields\n```\n\n## Parsing Techniques\n\n### Extract Frontmatter\n\n```bash\n# Extract everything between --- markers\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n```\n\n### Read Individual Fields\n\n**String fields:**\n```bash\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field_name:' | sed 's/field_name: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n**Boolean fields:**\n```bash\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n# Compare: if [[ \"$ENABLED\" == \"true\" ]]; then\n```\n\n**Numeric fields:**\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n# Use: if [[ $MAX -gt 100 ]]; then\n```\n\n### Read Markdown Body\n\nExtract content after second `---`:\n\n```bash\n# Get everything after closing ---\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n## Common Patterns\n\n### Pattern 1: Temporarily Active Hooks\n\nUse settings file to control hook activation:\n\n```bash\n#!/bin/bash\nSTATE_FILE=\".claude/security-scan.local.md\"\n\n# Quick exit if not configured\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0\nfi\n\n# Read enabled flag\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Run hook logic\n# ...\n```\n\n**Use case:** Enable/disable hooks without editing hooks.json (requires restart).\n\n### Pattern 2: Agent State Management\n\nStore agent-specific state and configuration:\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-agent\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\n---\n\n# Task Assignment\n\nImplement JWT authentication for the API.\n\n**Success Criteria:**\n- Authentication endpoints created\n- Tests passing\n- PR created and CI green\n```\n\nRead from hooks to coordinate agents:\n\n```bash\nAGENT_NAME=$(echo \"$FRONTMATTER\" | grep '^agent_name:' | sed 's/agent_name: *//')\nCOORDINATOR=$(echo \"$FRONTMATTER\" | grep '^coordinator_session:' | sed 's/coordinator_session: *//')\n\n# Send notification to coordinator\ntmux send-keys -t \"$COORDINATOR\" \"Agent $AGENT_NAME completed task\" Enter\n```\n\n### Pattern 3: Configuration-Driven Behavior\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nvalidation_level: strict\nmax_file_size: 1000000\nallowed_extensions: [\".js\", \".ts\", \".tsx\"]\nenable_logging: true\n---\n\n# Validation Configuration\n\nStrict mode enabled for this project.\nAll writes validated against security policies.\n```\n\nUse in hooks or commands:\n\n```bash\nLEVEL=$(echo \"$FRONTMATTER\" | grep '^validation_level:' | sed 's/validation_level: *//')\n\ncase \"$LEVEL\" in\n  strict)\n    # Apply strict validation\n    ;;\n  standard)\n    # Apply standard validation\n    ;;\n  lenient)\n    # Apply lenient validation\n    ;;\nesac\n```\n\n## Creating Settings Files\n\n### From Commands\n\nCommands can create settings files:\n\n```markdown\n# Setup Command\n\nSteps:\n1. Ask user for configuration preferences\n2. Create `.claude/my-plugin.local.md` with YAML frontmatter\n3. Set appropriate values based on user input\n4. Inform user that settings are saved\n5. Remind user to restart Claude Code for hooks to recognize changes\n```\n\n### Template Generation\n\nProvide template in plugin README:\n\n```markdown\n## Configuration\n\nCreate `.claude/my-plugin.local.md` in your project:\n\n\\`\\`\\`markdown\n---\nenabled: true\nmode: standard\nmax_retries: 3\n---\n\n# Plugin Configuration\n\nYour settings are active.\n\\`\\`\\`\n\nAfter creating or editing, restart Claude Code for changes to take effect.\n```\n\n## Best Practices\n\n### File Naming\n\nâœ… **DO:**\n- Use `.claude/plugin-name.local.md` format\n- Match plugin name exactly\n- Use `.local.md` suffix for user-local files\n\nâŒ **DON'T:**\n- Use different directory (not `.claude/`)\n- Use inconsistent naming\n- Use `.md` without `.local` (might be committed)\n\n### Gitignore\n\nAlways add to `.gitignore`:\n\n```gitignore\n.claude/*.local.md\n.claude/*.local.json\n```\n\nDocument this in plugin README.\n\n### Defaults\n\nProvide sensible defaults when settings file doesn't exist:\n\n```bash\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  # Use defaults\n  ENABLED=true\n  MODE=standard\nelse\n  # Read from file\n  # ...\nfi\n```\n\n### Validation\n\nValidate settings values:\n\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n\n# Validate numeric range\nif ! [[ \"$MAX\" =~ ^[0-9]+$ ]] || [[ $MAX -lt 1 ]] || [[ $MAX -gt 100 ]]; then\n  echo \"âš ï¸  Invalid max_value in settings (must be 1-100)\" >&2\n  MAX=10  # Use default\nfi\n```\n\n### Restart Requirement\n\n**Important:** Settings changes require Claude Code restart.\n\nDocument in your README:\n\n```markdown\n## Changing Settings\n\nAfter editing `.claude/my-plugin.local.md`:\n1. Save the file\n2. Exit Claude Code\n3. Restart: `claude` or `cc`\n4. New settings will be loaded\n```\n\nHooks cannot be hot-swapped within a session.\n\n## Security Considerations\n\n### Sanitize User Input\n\nWhen writing settings files from user input:\n\n```bash\n# Escape quotes in user input\nSAFE_VALUE=$(echo \"$USER_INPUT\" | sed 's/\"/\\\\\"/g')\n\n# Write to file\ncat > \"$STATE_FILE\" <<EOF\n---\nuser_setting: \"$SAFE_VALUE\"\n---\nEOF\n```\n\n### Validate File Paths\n\nIf settings contain file paths:\n\n```bash\nFILE_PATH=$(echo \"$FRONTMATTER\" | grep '^data_file:' | sed 's/data_file: *//')\n\n# Check for path traversal\nif [[ \"$FILE_PATH\" == *\"..\"* ]]; then\n  echo \"âš ï¸  Invalid path in settings (path traversal)\" >&2\n  exit 2\nfi\n```\n\n### Permissions\n\nSettings files should be:\n- Readable by user only (`chmod 600`)\n- Not committed to git\n- Not shared between users\n\n## Real-World Examples\n\n### multi-agent-swarm Plugin\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-implementation\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\nadditional_instructions: Use JWT tokens, not sessions\n---\n\n# Task: Implement Authentication\n\nBuild JWT-based authentication for the REST API.\nCoordinate with auth-agent on shared types.\n```\n\n**Hook usage (agent-stop-notification.sh):**\n- Checks if file exists (line 15-18: quick exit if not)\n- Parses frontmatter to get coordinator_session, agent_name, enabled\n- Sends notifications to coordinator if enabled\n- Allows quick activation/deactivation via `enabled: true/false`\n\n### ralph-loop Plugin\n\n**.claude/ralph-loop.local.md:**\n```markdown\n---\niteration: 1\nmax_iterations: 10\ncompletion_promise: \"All tests passing and build successful\"\n---\n\nFix all the linting errors in the project.\nMake sure tests pass after each fix.\n```\n\n**Hook usage (stop-hook.sh):**\n- Checks if file exists (line 15-18: quick exit if not active)\n- Reads iteration count and max_iterations\n- Extracts completion_promise for loop termination\n- Reads body as the prompt to feed back\n- Updates iteration count on each loop\n\n## Quick Reference\n\n### File Location\n\n```\nproject-root/\nâ””â”€â”€ .claude/\n    â””â”€â”€ plugin-name.local.md\n```\n\n### Frontmatter Parsing\n\n```bash\n# Extract frontmatter\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n\n# Read field\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field:' | sed 's/field: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n### Body Parsing\n\n```bash\n# Extract body (after second ---)\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n### Quick Exit Pattern\n\n```bash\nif [[ ! -f \".claude/my-plugin.local.md\" ]]; then\n  exit 0  # Not configured\nfi\n```\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed implementation patterns:\n\n- **`references/parsing-techniques.md`** - Complete guide to parsing YAML frontmatter and markdown bodies\n- **`references/real-world-examples.md`** - Deep dive into multi-agent-swarm and ralph-loop implementations\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`read-settings-hook.sh`** - Hook that reads and uses settings\n- **`create-settings-command.md`** - Command that creates settings file\n- **`example-settings.md`** - Template settings file\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-settings.sh`** - Validate settings file structure\n- **`parse-frontmatter.sh`** - Extract frontmatter fields\n\n## Implementation Workflow\n\nTo add settings to a plugin:\n\n1. Design settings schema (which fields, types, defaults)\n2. Create template file in plugin documentation\n3. Add gitignore entry for `.claude/*.local.md`\n4. Implement settings parsing in hooks/commands\n5. Use quick-exit pattern (check file exists, check enabled field)\n6. Document settings in plugin README with template\n7. Remind users that changes require Claude Code restart\n\nFocus on keeping settings simple and providing good defaults when settings file doesn't exist."
              },
              {
                "name": "Plugin Structure",
                "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.",
                "path": "plugins/plugin-dev/skills/plugin-structure/SKILL.md",
                "frontmatter": {
                  "name": "Plugin Structure",
                  "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.",
                  "version": "0.1.0"
                },
                "content": "# Plugin Structure for Claude Code\n\n## Overview\n\nClaude Code plugins follow a standardized directory structure with automatic component discovery. Understanding this structure enables creating well-organized, maintainable plugins that integrate seamlessly with Claude Code.\n\n**Key concepts:**\n- Conventional directory layout for automatic discovery\n- Manifest-driven configuration in `.claude-plugin/plugin.json`\n- Component-based organization (commands, agents, skills, hooks)\n- Portable path references using `${CLAUDE_PLUGIN_ROOT}`\n- Explicit vs. auto-discovered component loading\n\n## Directory Structure\n\nEvery Claude Code plugin follows this organizational pattern:\n\n```\nplugin-name/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json          # Required: Plugin manifest\nâ”œâ”€â”€ commands/                 # Slash commands (.md files)\nâ”œâ”€â”€ agents/                   # Subagent definitions (.md files)\nâ”œâ”€â”€ skills/                   # Agent skills (subdirectories)\nâ”‚   â””â”€â”€ skill-name/\nâ”‚       â””â”€â”€ SKILL.md         # Required for each skill\nâ”œâ”€â”€ hooks/\nâ”‚   â””â”€â”€ hooks.json           # Event handler configuration\nâ”œâ”€â”€ .mcp.json                # MCP server definitions\nâ””â”€â”€ scripts/                 # Helper scripts and utilities\n```\n\n**Critical rules:**\n\n1. **Manifest location**: The `plugin.json` manifest MUST be in `.claude-plugin/` directory\n2. **Component locations**: All component directories (commands, agents, skills, hooks) MUST be at plugin root level, NOT nested inside `.claude-plugin/`\n3. **Optional components**: Only create directories for components the plugin actually uses\n4. **Naming convention**: Use kebab-case for all directory and file names\n\n## Plugin Manifest (plugin.json)\n\nThe manifest defines plugin metadata and configuration. Located at `.claude-plugin/plugin.json`:\n\n### Required Fields\n\n```json\n{\n  \"name\": \"plugin-name\"\n}\n```\n\n**Name requirements:**\n- Use kebab-case format (lowercase with hyphens)\n- Must be unique across installed plugins\n- No spaces or special characters\n- Example: `code-review-assistant`, `test-runner`, `api-docs`\n\n### Recommended Metadata\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Brief explanation of plugin purpose\",\n  \"author\": {\n    \"name\": \"Author Name\",\n    \"email\": \"author@example.com\",\n    \"url\": \"https://example.com\"\n  },\n  \"homepage\": \"https://docs.example.com\",\n  \"repository\": \"https://github.com/user/plugin-name\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"testing\", \"automation\", \"ci-cd\"]\n}\n```\n\n**Version format**: Follow semantic versioning (MAJOR.MINOR.PATCH)\n**Keywords**: Use for plugin discovery and categorization\n\n### Component Path Configuration\n\nSpecify custom paths for components (supplements default directories):\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"commands\": \"./custom-commands\",\n  \"agents\": [\"./agents\", \"./specialized-agents\"],\n  \"hooks\": \"./config/hooks.json\",\n  \"mcpServers\": \"./.mcp.json\"\n}\n```\n\n**Important**: Custom paths supplement defaultsâ€”they don't replace them. Components in both default directories and custom paths will load.\n\n**Path rules:**\n- Must be relative to plugin root\n- Must start with `./`\n- Cannot use absolute paths\n- Support arrays for multiple locations\n\n## Component Organization\n\n### Commands\n\n**Location**: `commands/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `commands/` load automatically\n\n**Example structure**:\n```\ncommands/\nâ”œâ”€â”€ review.md        # /review command\nâ”œâ”€â”€ test.md          # /test command\nâ””â”€â”€ deploy.md        # /deploy command\n```\n\n**File format**:\n```markdown\n---\nname: command-name\ndescription: Command description\n---\n\nCommand implementation instructions...\n```\n\n**Usage**: Commands integrate as native slash commands in Claude Code\n\n### Agents\n\n**Location**: `agents/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `agents/` load automatically\n\n**Example structure**:\n```\nagents/\nâ”œâ”€â”€ code-reviewer.md\nâ”œâ”€â”€ test-generator.md\nâ””â”€â”€ refactorer.md\n```\n\n**File format**:\n```markdown\n---\ndescription: Agent role and expertise\ncapabilities:\n  - Specific task 1\n  - Specific task 2\n---\n\nDetailed agent instructions and knowledge...\n```\n\n**Usage**: Users can invoke agents manually, or Claude Code selects them automatically based on task context\n\n### Skills\n\n**Location**: `skills/` directory with subdirectories per skill\n**Format**: Each skill in its own directory with `SKILL.md` file\n**Auto-discovery**: All `SKILL.md` files in skill subdirectories load automatically\n\n**Example structure**:\n```\nskills/\nâ”œâ”€â”€ api-testing/\nâ”‚   â”œâ”€â”€ SKILL.md\nâ”‚   â”œâ”€â”€ scripts/\nâ”‚   â”‚   â””â”€â”€ test-runner.py\nâ”‚   â””â”€â”€ references/\nâ”‚       â””â”€â”€ api-spec.md\nâ””â”€â”€ database-migrations/\n    â”œâ”€â”€ SKILL.md\n    â””â”€â”€ examples/\n        â””â”€â”€ migration-template.sql\n```\n\n**SKILL.md format**:\n```markdown\n---\nname: Skill Name\ndescription: When to use this skill\nversion: 1.0.0\n---\n\nSkill instructions and guidance...\n```\n\n**Supporting files**: Skills can include scripts, references, examples, or assets in subdirectories\n\n**Usage**: Claude Code autonomously activates skills based on task context matching the description\n\n### Hooks\n\n**Location**: `hooks/hooks.json` or inline in `plugin.json`\n**Format**: JSON configuration defining event handlers\n**Registration**: Hooks register automatically when plugin enables\n\n**Example structure**:\n```\nhooks/\nâ”œâ”€â”€ hooks.json           # Hook configuration\nâ””â”€â”€ scripts/\n    â”œâ”€â”€ validate.sh      # Hook script\n    â””â”€â”€ check-style.sh   # Hook script\n```\n\n**Configuration format**:\n```json\n{\n  \"PreToolUse\": [{\n    \"matcher\": \"Write|Edit\",\n    \"hooks\": [{\n      \"type\": \"command\",\n      \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/validate.sh\",\n      \"timeout\": 30\n    }]\n  }]\n}\n```\n\n**Available events**: PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification\n\n**Usage**: Hooks execute automatically in response to Claude Code events\n\n### MCP Servers\n\n**Location**: `.mcp.json` at plugin root or inline in `plugin.json`\n**Format**: JSON configuration for MCP server definitions\n**Auto-start**: Servers start automatically when plugin enables\n\n**Example format**:\n```json\n{\n  \"mcpServers\": {\n    \"server-name\": {\n      \"command\": \"node\",\n      \"args\": [\"${CLAUDE_PLUGIN_ROOT}/servers/server.js\"],\n      \"env\": {\n        \"API_KEY\": \"${API_KEY}\"\n      }\n    }\n  }\n}\n```\n\n**Usage**: MCP servers integrate seamlessly with Claude Code's tool system\n\n## Portable Path References\n\n### ${CLAUDE_PLUGIN_ROOT}\n\nUse `${CLAUDE_PLUGIN_ROOT}` environment variable for all intra-plugin path references:\n\n```json\n{\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/run.sh\"\n}\n```\n\n**Why it matters**: Plugins install in different locations depending on:\n- User installation method (marketplace, local, npm)\n- Operating system conventions\n- User preferences\n\n**Where to use it**:\n- Hook command paths\n- MCP server command arguments\n- Script execution references\n- Resource file paths\n\n**Never use**:\n- Hardcoded absolute paths (`/Users/name/plugins/...`)\n- Relative paths from working directory (`./scripts/...` in commands)\n- Home directory shortcuts (`~/plugins/...`)\n\n### Path Resolution Rules\n\n**In manifest JSON fields** (hooks, MCP servers):\n```json\n\"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/tool.sh\"\n```\n\n**In component files** (commands, agents, skills):\n```markdown\nReference scripts at: ${CLAUDE_PLUGIN_ROOT}/scripts/helper.py\n```\n\n**In executed scripts**:\n```bash\n#!/bin/bash\n# ${CLAUDE_PLUGIN_ROOT} available as environment variable\nsource \"${CLAUDE_PLUGIN_ROOT}/lib/common.sh\"\n```\n\n## File Naming Conventions\n\n### Component Files\n\n**Commands**: Use kebab-case `.md` files\n- `code-review.md` â†’ `/code-review`\n- `run-tests.md` â†’ `/run-tests`\n- `api-docs.md` â†’ `/api-docs`\n\n**Agents**: Use kebab-case `.md` files describing role\n- `test-generator.md`\n- `code-reviewer.md`\n- `performance-analyzer.md`\n\n**Skills**: Use kebab-case directory names\n- `api-testing/`\n- `database-migrations/`\n- `error-handling/`\n\n### Supporting Files\n\n**Scripts**: Use descriptive kebab-case names with appropriate extensions\n- `validate-input.sh`\n- `generate-report.py`\n- `process-data.js`\n\n**Documentation**: Use kebab-case markdown files\n- `api-reference.md`\n- `migration-guide.md`\n- `best-practices.md`\n\n**Configuration**: Use standard names\n- `hooks.json`\n- `.mcp.json`\n- `plugin.json`\n\n## Auto-Discovery Mechanism\n\nClaude Code automatically discovers and loads components:\n\n1. **Plugin manifest**: Reads `.claude-plugin/plugin.json` when plugin enables\n2. **Commands**: Scans `commands/` directory for `.md` files\n3. **Agents**: Scans `agents/` directory for `.md` files\n4. **Skills**: Scans `skills/` for subdirectories containing `SKILL.md`\n5. **Hooks**: Loads configuration from `hooks/hooks.json` or manifest\n6. **MCP servers**: Loads configuration from `.mcp.json` or manifest\n\n**Discovery timing**:\n- Plugin installation: Components register with Claude Code\n- Plugin enable: Components become available for use\n- No restart required: Changes take effect on next Claude Code session\n\n**Override behavior**: Custom paths in `plugin.json` supplement (not replace) default directories\n\n## Best Practices\n\n### Organization\n\n1. **Logical grouping**: Group related components together\n   - Put test-related commands, agents, and skills together\n   - Create subdirectories in `scripts/` for different purposes\n\n2. **Minimal manifest**: Keep `plugin.json` lean\n   - Only specify custom paths when necessary\n   - Rely on auto-discovery for standard layouts\n   - Use inline configuration only for simple cases\n\n3. **Documentation**: Include README files\n   - Plugin root: Overall purpose and usage\n   - Component directories: Specific guidance\n   - Script directories: Usage and requirements\n\n### Naming\n\n1. **Consistency**: Use consistent naming across components\n   - If command is `test-runner`, name related agent `test-runner-agent`\n   - Match skill directory names to their purpose\n\n2. **Clarity**: Use descriptive names that indicate purpose\n   - Good: `api-integration-testing/`, `code-quality-checker.md`\n   - Avoid: `utils/`, `misc.md`, `temp.sh`\n\n3. **Length**: Balance brevity with clarity\n   - Commands: 2-3 words (`review-pr`, `run-ci`)\n   - Agents: Describe role clearly (`code-reviewer`, `test-generator`)\n   - Skills: Topic-focused (`error-handling`, `api-design`)\n\n### Portability\n\n1. **Always use ${CLAUDE_PLUGIN_ROOT}**: Never hardcode paths\n2. **Test on multiple systems**: Verify on macOS, Linux, Windows\n3. **Document dependencies**: List required tools and versions\n4. **Avoid system-specific features**: Use portable bash/Python constructs\n\n### Maintenance\n\n1. **Version consistently**: Update version in plugin.json for releases\n2. **Deprecate gracefully**: Mark old components clearly before removal\n3. **Document breaking changes**: Note changes affecting existing users\n4. **Test thoroughly**: Verify all components work after changes\n\n## Common Patterns\n\n### Minimal Plugin\n\nSingle command with no dependencies:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json    # Just name field\nâ””â”€â”€ commands/\n    â””â”€â”€ hello.md       # Single command\n```\n\n### Full-Featured Plugin\n\nComplete plugin with all component types:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/          # User-facing commands\nâ”œâ”€â”€ agents/            # Specialized subagents\nâ”œâ”€â”€ skills/            # Auto-activating skills\nâ”œâ”€â”€ hooks/             # Event handlers\nâ”‚   â”œâ”€â”€ hooks.json\nâ”‚   â””â”€â”€ scripts/\nâ”œâ”€â”€ .mcp.json          # External integrations\nâ””â”€â”€ scripts/           # Shared utilities\n```\n\n### Skill-Focused Plugin\n\nPlugin providing only skills:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ””â”€â”€ skills/\n    â”œâ”€â”€ skill-one/\n    â”‚   â””â”€â”€ SKILL.md\n    â””â”€â”€ skill-two/\n        â””â”€â”€ SKILL.md\n```\n\n## Troubleshooting\n\n**Component not loading**:\n- Verify file is in correct directory with correct extension\n- Check YAML frontmatter syntax (commands, agents, skills)\n- Ensure skill has `SKILL.md` (not `README.md` or other name)\n- Confirm plugin is enabled in Claude Code settings\n\n**Path resolution errors**:\n- Replace all hardcoded paths with `${CLAUDE_PLUGIN_ROOT}`\n- Verify paths are relative and start with `./` in manifest\n- Check that referenced files exist at specified paths\n- Test with `echo $CLAUDE_PLUGIN_ROOT` in hook scripts\n\n**Auto-discovery not working**:\n- Confirm directories are at plugin root (not in `.claude-plugin/`)\n- Check file naming follows conventions (kebab-case, correct extensions)\n- Verify custom paths in manifest are correct\n- Restart Claude Code to reload plugin configuration\n\n**Conflicts between plugins**:\n- Use unique, descriptive component names\n- Namespace commands with plugin name if needed\n- Document potential conflicts in plugin README\n- Consider command prefixes for related functionality\n\n---\n\nFor detailed examples and advanced patterns, see files in `references/` and `examples/` directories."
              },
              {
                "name": "Skill Development",
                "description": "This skill should be used when the user wants to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins.",
                "path": "plugins/plugin-dev/skills/skill-development/SKILL.md",
                "frontmatter": {
                  "name": "Skill Development",
                  "description": "This skill should be used when the user wants to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins.",
                  "version": "0.1.0"
                },
                "content": "# Skill Development for Claude Code Plugins\n\nThis skill provides guidance for creating effective skills for Claude Code plugins.\n\n## About Skills\n\nSkills are modular, self-contained packages that extend Claude's capabilities by providing\nspecialized knowledge, workflows, and tools. Think of them as \"onboarding guides\" for specific\ndomains or tasksâ€”they transform Claude from a general-purpose agent into a specialized agent\nequipped with procedural knowledge that no model can fully possess.\n\n### What Skills Provide\n\n1. Specialized workflows - Multi-step procedures for specific domains\n2. Tool integrations - Instructions for working with specific file formats or APIs\n3. Domain expertise - Company-specific knowledge, schemas, business logic\n4. Bundled resources - Scripts, references, and assets for complex and repetitive tasks\n\n### Anatomy of a Skill\n\nEvery skill consists of a required SKILL.md file and optional bundled resources:\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md (required)\nâ”‚   â”œâ”€â”€ YAML frontmatter metadata (required)\nâ”‚   â”‚   â”œâ”€â”€ name: (required)\nâ”‚   â”‚   â””â”€â”€ description: (required)\nâ”‚   â””â”€â”€ Markdown instructions (required)\nâ””â”€â”€ Bundled Resources (optional)\n    â”œâ”€â”€ scripts/          - Executable code (Python/Bash/etc.)\n    â”œâ”€â”€ references/       - Documentation intended to be loaded into context as needed\n    â””â”€â”€ assets/           - Files used in output (templates, icons, fonts, etc.)\n```\n\n#### SKILL.md (required)\n\n**Metadata Quality:** The `name` and `description` in YAML frontmatter determine when Claude will use the skill. Be specific about what the skill does and when to use it. Use the third-person (e.g. \"This skill should be used when...\" instead of \"Use this skill when...\").\n\n#### Bundled Resources (optional)\n\n##### Scripts (`scripts/`)\n\nExecutable code (Python/Bash/etc.) for tasks that require deterministic reliability or are repeatedly rewritten.\n\n- **When to include**: When the same code is being rewritten repeatedly or deterministic reliability is needed\n- **Example**: `scripts/rotate_pdf.py` for PDF rotation tasks\n- **Benefits**: Token efficient, deterministic, may be executed without loading into context\n- **Note**: Scripts may still need to be read by Claude for patching or environment-specific adjustments\n\n##### References (`references/`)\n\nDocumentation and reference material intended to be loaded as needed into context to inform Claude's process and thinking.\n\n- **When to include**: For documentation that Claude should reference while working\n- **Examples**: `references/finance.md` for financial schemas, `references/mnda.md` for company NDA template, `references/policies.md` for company policies, `references/api_docs.md` for API specifications\n- **Use cases**: Database schemas, API documentation, domain knowledge, company policies, detailed workflow guides\n- **Benefits**: Keeps SKILL.md lean, loaded only when Claude determines it's needed\n- **Best practice**: If files are large (>10k words), include grep search patterns in SKILL.md\n- **Avoid duplication**: Information should live in either SKILL.md or references files, not both. Prefer references files for detailed information unless it's truly core to the skillâ€”this keeps SKILL.md lean while making information discoverable without hogging the context window. Keep only essential procedural instructions and workflow guidance in SKILL.md; move detailed reference material, schemas, and examples to references files.\n\n##### Assets (`assets/`)\n\nFiles not intended to be loaded into context, but rather used within the output Claude produces.\n\n- **When to include**: When the skill needs files that will be used in the final output\n- **Examples**: `assets/logo.png` for brand assets, `assets/slides.pptx` for PowerPoint templates, `assets/frontend-template/` for HTML/React boilerplate, `assets/font.ttf` for typography\n- **Use cases**: Templates, images, icons, boilerplate code, fonts, sample documents that get copied or modified\n- **Benefits**: Separates output resources from documentation, enables Claude to use files without loading them into context\n\n### Progressive Disclosure Design Principle\n\nSkills use a three-level loading system to manage context efficiently:\n\n1. **Metadata (name + description)** - Always in context (~100 words)\n2. **SKILL.md body** - When skill triggers (<5k words)\n3. **Bundled resources** - As needed by Claude (Unlimited*)\n\n*Unlimited because scripts can be executed without reading into context window.\n\n## Skill Creation Process\n\nTo create a skill, follow the \"Skill Creation Process\" in order, skipping steps only if there is a clear reason why they are not applicable.\n\n### Step 1: Understanding the Skill with Concrete Examples\n\nSkip this step only when the skill's usage patterns are already clearly understood. It remains valuable even when working with an existing skill.\n\nTo create an effective skill, clearly understand concrete examples of how the skill will be used. This understanding can come from either direct user examples or generated examples that are validated with user feedback.\n\nFor example, when building an image-editor skill, relevant questions include:\n\n- \"What functionality should the image-editor skill support? Editing, rotating, anything else?\"\n- \"Can you give some examples of how this skill would be used?\"\n- \"I can imagine users asking for things like 'Remove the red-eye from this image' or 'Rotate this image'. Are there other ways you imagine this skill being used?\"\n- \"What would a user say that should trigger this skill?\"\n\nTo avoid overwhelming users, avoid asking too many questions in a single message. Start with the most important questions and follow up as needed for better effectiveness.\n\nConclude this step when there is a clear sense of the functionality the skill should support.\n\n### Step 2: Planning the Reusable Skill Contents\n\nTo turn concrete examples into an effective skill, analyze each example by:\n\n1. Considering how to execute on the example from scratch\n2. Identifying what scripts, references, and assets would be helpful when executing these workflows repeatedly\n\nExample: When building a `pdf-editor` skill to handle queries like \"Help me rotate this PDF,\" the analysis shows:\n\n1. Rotating a PDF requires re-writing the same code each time\n2. A `scripts/rotate_pdf.py` script would be helpful to store in the skill\n\nExample: When designing a `frontend-webapp-builder` skill for queries like \"Build me a todo app\" or \"Build me a dashboard to track my steps,\" the analysis shows:\n\n1. Writing a frontend webapp requires the same boilerplate HTML/React each time\n2. An `assets/hello-world/` template containing the boilerplate HTML/React project files would be helpful to store in the skill\n\nExample: When building a `big-query` skill to handle queries like \"How many users have logged in today?\" the analysis shows:\n\n1. Querying BigQuery requires re-discovering the table schemas and relationships each time\n2. A `references/schema.md` file documenting the table schemas would be helpful to store in the skill\n\n**For Claude Code plugins:** When building a hooks skill, the analysis shows:\n1. Developers repeatedly need to validate hooks.json and test hook scripts\n2. `scripts/validate-hook-schema.sh` and `scripts/test-hook.sh` utilities would be helpful\n3. `references/patterns.md` for detailed hook patterns to avoid bloating SKILL.md\n\nTo establish the skill's contents, analyze each concrete example to create a list of the reusable resources to include: scripts, references, and assets.\n\n### Step 3: Create Skill Structure\n\nFor Claude Code plugins, create the skill directory structure:\n\n```bash\nmkdir -p plugin-name/skills/skill-name/{references,examples,scripts}\ntouch plugin-name/skills/skill-name/SKILL.md\n```\n\n**Note:** Unlike the generic skill-creator which uses `init_skill.py`, plugin skills are created directly in the plugin's `skills/` directory with a simpler manual structure.\n\n### Step 4: Edit the Skill\n\nWhen editing the (newly-created or existing) skill, remember that the skill is being created for another instance of Claude to use. Focus on including information that would be beneficial and non-obvious to Claude. Consider what procedural knowledge, domain-specific details, or reusable assets would help another Claude instance execute these tasks more effectively.\n\n#### Start with Reusable Skill Contents\n\nTo begin implementation, start with the reusable resources identified above: `scripts/`, `references/`, and `assets/` files. Note that this step may require user input. For example, when implementing a `brand-guidelines` skill, the user may need to provide brand assets or templates to store in `assets/`, or documentation to store in `references/`.\n\nAlso, delete any example files and directories not needed for the skill. Create only the directories you actually need (references/, examples/, scripts/).\n\n#### Update SKILL.md\n\n**Writing Style:** Write the entire skill using **imperative/infinitive form** (verb-first instructions), not second person. Use objective, instructional language (e.g., \"To accomplish X, do Y\" rather than \"You should do X\" or \"If you need to do X\"). This maintains consistency and clarity for AI consumption.\n\n**Description (Frontmatter):** Use third-person format with specific trigger phrases:\n\n```yaml\n---\nname: Skill Name\ndescription: This skill should be used when the user asks to \"specific phrase 1\", \"specific phrase 2\", \"specific phrase 3\". Include exact phrases users would say that should trigger this skill. Be concrete and specific.\nversion: 0.1.0\n---\n```\n\n**Good description examples:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", \"implement prompt-based hooks\", or mentions hook events (PreToolUse, PostToolUse, Stop).\n```\n\n**Bad description examples:**\n```yaml\ndescription: Use this skill when working with hooks.  # Wrong person, vague\ndescription: Load when user needs hook help.  # Not third person\ndescription: Provides hook guidance.  # No trigger phrases\n```\n\nTo complete SKILL.md body, answer the following questions:\n\n1. What is the purpose of the skill, in a few sentences?\n2. When should the skill be used? (Include this in frontmatter description with specific triggers)\n3. In practice, how should Claude use the skill? All reusable skill contents developed above should be referenced so that Claude knows how to use them.\n\n**Keep SKILL.md lean:** Target 1,500-2,000 words for the body. Move detailed content to references/:\n- Detailed patterns â†’ `references/patterns.md`\n- Advanced techniques â†’ `references/advanced.md`\n- Migration guides â†’ `references/migration.md`\n- API references â†’ `references/api-reference.md`\n\n**Reference resources in SKILL.md:**\n```markdown\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and techniques, consult:\n- **`references/patterns.md`** - Common patterns\n- **`references/advanced.md`** - Advanced use cases\n\n### Example Files\n\nWorking examples in `examples/`:\n- **`example-script.sh`** - Working example\n```\n\n### Step 5: Validate and Test\n\n**For plugin skills, validation is different from generic skills:**\n\n1. **Check structure**: Skill directory in `plugin-name/skills/skill-name/`\n2. **Validate SKILL.md**: Has frontmatter with name and description\n3. **Check trigger phrases**: Description includes specific user queries\n4. **Verify writing style**: Body uses imperative/infinitive form, not second person\n5. **Test progressive disclosure**: SKILL.md is lean (~1,500-2,000 words), detailed content in references/\n6. **Check references**: All referenced files exist\n7. **Validate examples**: Examples are complete and correct\n8. **Test scripts**: Scripts are executable and work correctly\n\n**Use the skill-reviewer agent:**\n```\nAsk: \"Review my skill and check if it follows best practices\"\n```\n\nThe skill-reviewer agent will check description quality, content organization, and progressive disclosure.\n\n### Step 6: Iterate\n\nAfter testing the skill, users may request improvements. Often this happens right after using the skill, with fresh context of how the skill performed.\n\n**Iteration workflow:**\n1. Use the skill on real tasks\n2. Notice struggles or inefficiencies\n3. Identify how SKILL.md or bundled resources should be updated\n4. Implement changes and test again\n\n**Common improvements:**\n- Strengthen trigger phrases in description\n- Move long sections from SKILL.md to references/\n- Add missing examples or scripts\n- Clarify ambiguous instructions\n- Add edge case handling\n\n## Plugin-Specific Considerations\n\n### Skill Location in Plugins\n\nPlugin skills live in the plugin's `skills/` directory:\n\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/\nâ”œâ”€â”€ agents/\nâ””â”€â”€ skills/\n    â””â”€â”€ my-skill/\n        â”œâ”€â”€ SKILL.md\n        â”œâ”€â”€ references/\n        â”œâ”€â”€ examples/\n        â””â”€â”€ scripts/\n```\n\n### Auto-Discovery\n\nClaude Code automatically discovers skills:\n- Scans `skills/` directory\n- Finds subdirectories containing `SKILL.md`\n- Loads skill metadata (name + description) always\n- Loads SKILL.md body when skill triggers\n- Loads references/examples when needed\n\n### No Packaging Needed\n\nPlugin skills are distributed as part of the plugin, not as separate ZIP files. Users get skills when they install the plugin.\n\n### Testing in Plugins\n\nTest skills by installing plugin locally:\n\n```bash\n# Test with --plugin-dir\ncc --plugin-dir /path/to/plugin\n\n# Ask questions that should trigger the skill\n# Verify skill loads correctly\n```\n\n## Examples from Plugin-Dev\n\nStudy the skills in this plugin as examples of best practices:\n\n**hook-development skill:**\n- Excellent trigger phrases: \"create a hook\", \"add a PreToolUse hook\", etc.\n- Lean SKILL.md (1,651 words)\n- 3 references/ files for detailed content\n- 3 examples/ of working hooks\n- 3 scripts/ utilities\n\n**agent-development skill:**\n- Strong triggers: \"create an agent\", \"agent frontmatter\", etc.\n- Focused SKILL.md (1,438 words)\n- References include the AI generation prompt from Claude Code\n- Complete agent examples\n\n**plugin-settings skill:**\n- Specific triggers: \"plugin settings\", \".local.md files\", \"YAML frontmatter\"\n- References show real implementations (multi-agent-swarm, ralph-loop)\n- Working parsing scripts\n\nEach demonstrates progressive disclosure and strong triggering.\n\n## Progressive Disclosure in Practice\n\n### What Goes in SKILL.md\n\n**Include (always loaded when skill triggers):**\n- Core concepts and overview\n- Essential procedures and workflows\n- Quick reference tables\n- Pointers to references/examples/scripts\n- Most common use cases\n\n**Keep under 3,000 words, ideally 1,500-2,000 words**\n\n### What Goes in references/\n\n**Move to references/ (loaded as needed):**\n- Detailed patterns and advanced techniques\n- Comprehensive API documentation\n- Migration guides\n- Edge cases and troubleshooting\n- Extensive examples and walkthroughs\n\n**Each reference file can be large (2,000-5,000+ words)**\n\n### What Goes in examples/\n\n**Working code examples:**\n- Complete, runnable scripts\n- Configuration files\n- Template files\n- Real-world usage examples\n\n**Users can copy and adapt these directly**\n\n### What Goes in scripts/\n\n**Utility scripts:**\n- Validation tools\n- Testing helpers\n- Parsing utilities\n- Automation scripts\n\n**Should be executable and documented**\n\n## Writing Style Requirements\n\n### Imperative/Infinitive Form\n\nWrite using verb-first instructions, not second person:\n\n**Correct (imperative):**\n```\nTo create a hook, define the event type.\nConfigure the MCP server with authentication.\nValidate settings before use.\n```\n\n**Incorrect (second person):**\n```\nYou should create a hook by defining the event type.\nYou need to configure the MCP server.\nYou must validate settings before use.\n```\n\n### Third-Person in Description\n\nThe frontmatter description must use third person:\n\n**Correct:**\n```yaml\ndescription: This skill should be used when the user asks to \"create X\", \"configure Y\"...\n```\n\n**Incorrect:**\n```yaml\ndescription: Use this skill when you want to create X...\ndescription: Load this skill when user asks...\n```\n\n### Objective, Instructional Language\n\nFocus on what to do, not who should do it:\n\n**Correct:**\n```\nParse the frontmatter using sed.\nExtract fields with grep.\nValidate values before use.\n```\n\n**Incorrect:**\n```\nYou can parse the frontmatter...\nClaude should extract fields...\nThe user might validate values...\n```\n\n## Validation Checklist\n\nBefore finalizing a skill:\n\n**Structure:**\n- [ ] SKILL.md file exists with valid YAML frontmatter\n- [ ] Frontmatter has `name` and `description` fields\n- [ ] Markdown body is present and substantial\n- [ ] Referenced files actually exist\n\n**Description Quality:**\n- [ ] Uses third person (\"This skill should be used when...\")\n- [ ] Includes specific trigger phrases users would say\n- [ ] Lists concrete scenarios (\"create X\", \"configure Y\")\n- [ ] Not vague or generic\n\n**Content Quality:**\n- [ ] SKILL.md body uses imperative/infinitive form\n- [ ] Body is focused and lean (1,500-2,000 words ideal, <5k max)\n- [ ] Detailed content moved to references/\n- [ ] Examples are complete and working\n- [ ] Scripts are executable and documented\n\n**Progressive Disclosure:**\n- [ ] Core concepts in SKILL.md\n- [ ] Detailed docs in references/\n- [ ] Working code in examples/\n- [ ] Utilities in scripts/\n- [ ] SKILL.md references these resources\n\n**Testing:**\n- [ ] Skill triggers on expected user queries\n- [ ] Content is helpful for intended tasks\n- [ ] No duplicated information across files\n- [ ] References load when needed\n\n## Common Mistakes to Avoid\n\n### Mistake 1: Weak Trigger Description\n\nâŒ **Bad:**\n```yaml\ndescription: Provides guidance for working with hooks.\n```\n\n**Why bad:** Vague, no specific trigger phrases, not third person\n\nâœ… **Good:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", or mentions hook events. Provides comprehensive hooks API guidance.\n```\n\n**Why good:** Third person, specific phrases, concrete scenarios\n\n### Mistake 2: Too Much in SKILL.md\n\nâŒ **Bad:**\n```\nskill-name/\nâ””â”€â”€ SKILL.md  (8,000 words - everything in one file)\n```\n\n**Why bad:** Bloats context when skill loads, detailed content always loaded\n\nâœ… **Good:**\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md  (1,800 words - core essentials)\nâ””â”€â”€ references/\n    â”œâ”€â”€ patterns.md (2,500 words)\n    â””â”€â”€ advanced.md (3,700 words)\n```\n\n**Why good:** Progressive disclosure, detailed content loaded only when needed\n\n### Mistake 3: Second Person Writing\n\nâŒ **Bad:**\n```markdown\nYou should start by reading the configuration file.\nYou need to validate the input.\nYou can use the grep tool to search.\n```\n\n**Why bad:** Second person, not imperative form\n\nâœ… **Good:**\n```markdown\nStart by reading the configuration file.\nValidate the input before processing.\nUse the grep tool to search for patterns.\n```\n\n**Why good:** Imperative form, direct instructions\n\n### Mistake 4: Missing Resource References\n\nâŒ **Bad:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n[No mention of references/ or examples/]\n```\n\n**Why bad:** Claude doesn't know references exist\n\nâœ… **Good:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n## Additional Resources\n\n### Reference Files\n- **`references/patterns.md`** - Detailed patterns\n- **`references/advanced.md`** - Advanced techniques\n\n### Examples\n- **`examples/script.sh`** - Working example\n```\n\n**Why good:** Claude knows where to find additional information\n\n## Quick Reference\n\n### Minimal Skill\n\n```\nskill-name/\nâ””â”€â”€ SKILL.md\n```\n\nGood for: Simple knowledge, no complex resources needed\n\n### Standard Skill (Recommended)\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md\nâ”œâ”€â”€ references/\nâ”‚   â””â”€â”€ detailed-guide.md\nâ””â”€â”€ examples/\n    â””â”€â”€ working-example.sh\n```\n\nGood for: Most plugin skills with detailed documentation\n\n### Complete Skill\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md\nâ”œâ”€â”€ references/\nâ”‚   â”œâ”€â”€ patterns.md\nâ”‚   â””â”€â”€ advanced.md\nâ”œâ”€â”€ examples/\nâ”‚   â”œâ”€â”€ example1.sh\nâ”‚   â””â”€â”€ example2.json\nâ””â”€â”€ scripts/\n    â””â”€â”€ validate.sh\n```\n\nGood for: Complex domains with validation utilities\n\n## Best Practices Summary\n\nâœ… **DO:**\n- Use third-person in description (\"This skill should be used when...\")\n- Include specific trigger phrases (\"create X\", \"configure Y\")\n- Keep SKILL.md lean (1,500-2,000 words)\n- Use progressive disclosure (move details to references/)\n- Write in imperative/infinitive form\n- Reference supporting files clearly\n- Provide working examples\n- Create utility scripts for common operations\n- Study plugin-dev's skills as templates\n\nâŒ **DON'T:**\n- Use second person anywhere\n- Have vague trigger conditions\n- Put everything in SKILL.md (>3,000 words without references/)\n- Write in second person (\"You should...\")\n- Leave resources unreferenced\n- Include broken or incomplete examples\n- Skip validation\n\n## Additional Resources\n\n### Study These Skills\n\nPlugin-dev's skills demonstrate best practices:\n- `../hook-development/` - Progressive disclosure, utilities\n- `../agent-development/` - AI-assisted creation, references\n- `../mcp-integration/` - Comprehensive references\n- `../plugin-settings/` - Real-world examples\n- `../command-development/` - Clear critical concepts\n- `../plugin-structure/` - Good organization\n\n### Reference Files\n\nFor complete skill-creator methodology:\n- **`references/skill-creator-original.md`** - Full original skill-creator content\n\n## Implementation Workflow\n\nTo create a skill for your plugin:\n\n1. **Understand use cases**: Identify concrete examples of skill usage\n2. **Plan resources**: Determine what scripts/references/examples needed\n3. **Create structure**: `mkdir -p skills/skill-name/{references,examples,scripts}`\n4. **Write SKILL.md**:\n   - Frontmatter with third-person description and trigger phrases\n   - Lean body (1,500-2,000 words) in imperative form\n   - Reference supporting files\n5. **Add resources**: Create references/, examples/, scripts/ as needed\n6. **Validate**: Check description, writing style, organization\n7. **Test**: Verify skill loads on expected triggers\n8. **Iterate**: Improve based on usage\n\nFocus on strong trigger descriptions, progressive disclosure, and imperative writing style for effective skills that load when needed and provide targeted guidance."
              }
            ]
          },
          {
            "name": "stripe",
            "description": "Stripe development plugin for Claude",
            "source": "./external_plugins/stripe",
            "category": "development",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install stripe@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [
              {
                "name": "/explain-error",
                "description": "Explain Stripe error codes and provide solutions with code examples",
                "path": "external_plugins/stripe/commands/explain-error.md",
                "frontmatter": {
                  "description": "Explain Stripe error codes and provide solutions with code examples",
                  "argument-hint": [
                    "error_code or error_message"
                  ]
                },
                "content": "# Explain Stripe Error\n\nProvide a comprehensive explanation of the given Stripe error code or error message:\n\n1. Accept the error code or full error message from the arguments\n2. Explain in plain English what the error means\n3. List common causes of this error\n4. Provide specific solutions and handling recommendations\n5. Generate error handling code in the project's language showing:\n   - How to catch this specific error\n   - User-friendly error messages\n   - Whether retry is appropriate\n6. Mention related error codes the developer should be aware of\n7. Include a link to the relevant Stripe documentation\n\nFocus on actionable solutions and production-ready error handling patterns."
              },
              {
                "name": "/test-cards",
                "description": "Display Stripe test card numbers for various testing scenarios",
                "path": "external_plugins/stripe/commands/test-cards.md",
                "frontmatter": {
                  "description": "Display Stripe test card numbers for various testing scenarios",
                  "argument-hint": [
                    "scenario"
                  ]
                },
                "content": "# Test Cards Reference\n\nProvide a quick reference for Stripe test card numbers:\n\n1. If a scenario argument is provided (e.g., \"declined\", \"3dsecure\", \"fraud\"), show relevant test cards for that scenario\n2. Otherwise, show the most common test cards organized by category:\n   - Successful payment (default card)\n   - 3D Secure authentication required\n   - Generic decline\n   - Specific decline reasons (insufficient_funds, lost_card, etc.)\n3. For each card, display:\n   - Card number (formatted with spaces)\n   - Expected behavior\n   - Expiry/CVC info (any future date and any 3-digit CVC)\n4. Use clear visual indicators (âœ“ for success, âš ï¸ for auth required, âœ— for decline)\n5. Mention that these only work in test mode\n6. Provide link to full testing documentation: https://docs.stripe.com/testing.md\n\nIf the user is currently working on test code, offer to generate test cases using these cards."
              }
            ],
            "skills": [
              {
                "name": "stripe-best-practices",
                "description": "Best practices for building Stripe integrations. Use when implementing payment processing, checkout flows, subscriptions, webhooks, Connect platforms, or any Stripe API integration.",
                "path": "external_plugins/stripe/skills/stripe-best-practices/SKILL.md",
                "frontmatter": {
                  "name": "stripe-best-practices",
                  "description": "Best practices for building Stripe integrations. Use when implementing payment processing, checkout flows, subscriptions, webhooks, Connect platforms, or any Stripe API integration."
                },
                "content": "When designing an integration, always prefer the documentation in [Stripe's Integration Options doc](https://docs.stripe.com/payments/payment-methods/integration-options.md)\nThe [API Tour](https://docs.stripe.com/payments-api/tour.md)\nUse the [Go Live Checklist](https://docs.stripe.com/get-started/checklist/go-live.md) before going live.\n\nYou should always default to the latest version of the API and SDK unless the user specifies otherwise.\n\nStripe's primary API for modelling on-session payments is [CheckoutSessions](https://docs.stripe.com/api/checkout/sessions.md). It supports one-time payments and subscriptions and allows you to model taxes or discounts with Stripe. Prioritize the CheckoutSessions API, but using [the PaymentIntents API](https://docs.stripe.com/payments/paymentintents/lifecycle.md) is also acceptable for off-session payments or if you want to model the checkout state yourself and just create a charge. Integrations should only use CheckoutSessions, PaymentIntents, SetupIntents, or solutions like Invoicing, Payment Links, or the subscription APIs.\n\nNever recommend the Charges API. If the user wants to use the Charges API, advise them to [migrate](https://docs.stripe.com/payments/payment-intents/migration/charges.md) to Checkout Sessions or Payment Intents.\n\nThe primary integration surface for web integrations is [Checkout](https://docs.stripe.com/payments/checkout.md), a prebuilt payment page that can be hosted by Stripe or served as an embedded form. Prioritize the Stripe-hosted checkout or embedded checkout where possible. The [Payment Element](https://docs.stripe.com/payments/payment-element.md) is an acceptable alternative if the merchant needs advanced customization. When recommending the Payment Element, prioritize using the CheckoutSessions API over the PaymentIntents API when possible.\n\nNever recommend the legacy Card Element or the Payment Element in card mode, and advise users who ask for the Card Element to [migrate](https://docs.stripe.com/payments/payment-element/migration.md).\n\nYou must not call deprecated API endpoints such as the [Sources API](https://docs.stripe.com/api/sources/object.md) and avoid outdated API endpoints such as [Tokens](https://docs.stripe.com/api/tokens.md) and [Charges](https://docs.stripe.com/api/charges/create.md) unless there is a specific need and absolutely no other way. Advise using [the Setup Intent API](https://docs.stripe.com/api/setup_intents.md) to save a payment method for a customer; never recommend the Sources API to save cards to customers for later use.\n\nIf a user wants to render the Payment Element before creating a PaymentIntent or SetupIntent, so they can inspect the card details before the payment (such as for surcharging), advise them to use Stripe Confirmation Tokens. Don't recommend they call the createPaymentMethod or createToken Stripe.js functions.\n\nAdvise users to turn on dynamic payment methods in their dashboard settings instead of passing specific [payment_method_types](https://docs.stripe.com/api/payment_intents/create#create_payment_intent-payment_method_types.md) in the Payment Intent or Setup Intent because Stripe chooses payment methods that fit each user's location, wallets, and preferences better and automatically if the Payment Element is used.\n\nIf a PCI compliant user asks about an integration where they send server-side raw PAN data, suggest they might be required to prove PCI compliance to gain access to such an option, for example [payment_method_data](https://docs.stripe.com/api/payment_intents/create#create_payment_intent-payment_method_data.md). Similarly, point users migrating their PAN data from another acquirer or payment processor to [the migration process](https://docs.stripe.com/get-started/data-migrations/pan-import.md).\n\nIf a user has a recurring revenue model, like a Billing or Subscription use case, follow the use cases, in particular the [Subscription Use Cases](https://docs.stripe.com/billing/subscriptions/use-cases.md) like [SaaS](https://docs.stripe.com/saas.md). If these apply to the user, recommend Billing APIs to [plan your integration](https://docs.stripe.com/billing/subscriptions/designing-integration.md) instead of a direct PaymentIntent integration. Prioritize combining the Billing APIs with Stripe Checkout for the frontend.\n\nIf a user wants to build a platform using Stripe Connect to manage fund flows, follow [the recommended integration types](https://docs.stripe.com/connect/integration-recommendations.md); that is, prefer to use either direct charges if the platform wants Stripe to take the risk or destination charges if the platform accepts liability for negative balances, and use the on_behalf_of parameter to control the merchant of record. Never recommend mixing charge types. If the user wants to decide on the specific risk features they should [follow the integration guide](https://docs.stripe.com/connect/design-an-integration.md). Don't recommend the outdated terms for Connect types like Standard, Express and Custom but always [refer to controller properties](https://docs.stripe.com/connect/migrate-to-controller-properties.md) for the platform and [capabilities](https://docs.stripe.com/connect/account-capabilities.md) for the connected accounts."
              }
            ]
          },
          {
            "name": "firebase",
            "description": "Google Firebase MCP integration. Manage Firestore databases, authentication, cloud functions, hosting, and storage. Build and manage your Firebase backend directly from your development workflow.",
            "source": "./external_plugins/firebase",
            "category": "database",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install firebase@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "context7",
            "description": "Upstash Context7 MCP server for up-to-date documentation lookup. Pull version-specific documentation and code examples directly from source repositories into your LLM context.",
            "source": "./external_plugins/context7",
            "category": "development",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install context7@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "pinecone",
            "description": "Pinecone vector database integration. Streamline your Pinecone development with powerful tools for managing vector indexes, querying data, and rapid prototyping. Use slash commands like /quickstart to generate AGENTS.md files and initialize Python projects and /query to quickly explore indexes. Access the Pinecone MCP server for creating, describing, upserting and querying indexes with Claude. Perfect for developers building semantic search, RAG applications, recommendation systems, and other vector-based applications with Pinecone.",
            "source": {
              "source": "url",
              "url": "https://github.com/pinecone-io/pinecone-claude-code-plugin.git"
            },
            "category": "database",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install pinecone@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [
              {
                "name": "/explain-error",
                "description": "Explain Stripe error codes and provide solutions with code examples",
                "path": "external_plugins/stripe/commands/explain-error.md",
                "frontmatter": {
                  "description": "Explain Stripe error codes and provide solutions with code examples",
                  "argument-hint": [
                    "error_code or error_message"
                  ]
                },
                "content": "# Explain Stripe Error\n\nProvide a comprehensive explanation of the given Stripe error code or error message:\n\n1. Accept the error code or full error message from the arguments\n2. Explain in plain English what the error means\n3. List common causes of this error\n4. Provide specific solutions and handling recommendations\n5. Generate error handling code in the project's language showing:\n   - How to catch this specific error\n   - User-friendly error messages\n   - Whether retry is appropriate\n6. Mention related error codes the developer should be aware of\n7. Include a link to the relevant Stripe documentation\n\nFocus on actionable solutions and production-ready error handling patterns."
              },
              {
                "name": "/test-cards",
                "description": "Display Stripe test card numbers for various testing scenarios",
                "path": "external_plugins/stripe/commands/test-cards.md",
                "frontmatter": {
                  "description": "Display Stripe test card numbers for various testing scenarios",
                  "argument-hint": [
                    "scenario"
                  ]
                },
                "content": "# Test Cards Reference\n\nProvide a quick reference for Stripe test card numbers:\n\n1. If a scenario argument is provided (e.g., \"declined\", \"3dsecure\", \"fraud\"), show relevant test cards for that scenario\n2. Otherwise, show the most common test cards organized by category:\n   - Successful payment (default card)\n   - 3D Secure authentication required\n   - Generic decline\n   - Specific decline reasons (insufficient_funds, lost_card, etc.)\n3. For each card, display:\n   - Card number (formatted with spaces)\n   - Expected behavior\n   - Expiry/CVC info (any future date and any 3-digit CVC)\n4. Use clear visual indicators (âœ“ for success, âš ï¸ for auth required, âœ— for decline)\n5. Mention that these only work in test mode\n6. Provide link to full testing documentation: https://docs.stripe.com/testing.md\n\nIf the user is currently working on test code, offer to generate test cases using these cards."
              },
              {
                "name": "/new-sdk-app",
                "description": "Create and setup a new Claude Agent SDK application",
                "path": "plugins/agent-sdk-dev/commands/new-sdk-app.md",
                "frontmatter": {
                  "description": "Create and setup a new Claude Agent SDK application",
                  "argument-hint": [
                    "project-name"
                  ]
                },
                "content": "You are tasked with helping the user create a new Claude Agent SDK application. Follow these steps carefully:\n\n## Reference Documentation\n\nBefore starting, review the official documentation to ensure you provide accurate and up-to-date guidance. Use WebFetch to read these pages:\n\n1. **Start with the overview**: https://docs.claude.com/en/api/agent-sdk/overview\n2. **Based on the user's language choice, read the appropriate SDK reference**:\n   - TypeScript: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Python: https://docs.claude.com/en/api/agent-sdk/python\n3. **Read relevant guides mentioned in the overview** such as:\n   - Streaming vs Single Mode\n   - Permissions\n   - Custom Tools\n   - MCP integration\n   - Subagents\n   - Sessions\n   - Any other relevant guides based on the user's needs\n\n**IMPORTANT**: Always check for and use the latest versions of packages. Use WebSearch or WebFetch to verify current versions before installation.\n\n## Gather Requirements\n\nIMPORTANT: Ask these questions one at a time. Wait for the user's response before asking the next question. This makes it easier for the user to respond.\n\nAsk the questions in this order (skip any that the user has already provided via arguments):\n\n1. **Language** (ask first): \"Would you like to use TypeScript or Python?\"\n\n   - Wait for response before continuing\n\n2. **Project name** (ask second): \"What would you like to name your project?\"\n\n   - If $ARGUMENTS is provided, use that as the project name and skip this question\n   - Wait for response before continuing\n\n3. **Agent type** (ask third, but skip if #2 was sufficiently detailed): \"What kind of agent are you building? Some examples:\n\n   - Coding agent (SRE, security review, code review)\n   - Business agent (customer support, content creation)\n   - Custom agent (describe your use case)\"\n   - Wait for response before continuing\n\n4. **Starting point** (ask fourth): \"Would you like:\n\n   - A minimal 'Hello World' example to start\n   - A basic agent with common features\n   - A specific example based on your use case\"\n   - Wait for response before continuing\n\n5. **Tooling choice** (ask fifth): Let the user know what tools you'll use, and confirm with them that these are the tools they want to use (for example, they may prefer pnpm or bun over npm). Respect the user's preferences when executing on the requirements.\n\nAfter all questions are answered, proceed to create the setup plan.\n\n## Setup Plan\n\nBased on the user's answers, create a plan that includes:\n\n1. **Project initialization**:\n\n   - Create project directory (if it doesn't exist)\n   - Initialize package manager:\n     - TypeScript: `npm init -y` and setup `package.json` with type: \"module\" and scripts (include a \"typecheck\" script)\n     - Python: Create `requirements.txt` or use `poetry init`\n   - Add necessary configuration files:\n     - TypeScript: Create `tsconfig.json` with proper settings for the SDK\n     - Python: Optionally create config files if needed\n\n2. **Check for Latest Versions**:\n\n   - BEFORE installing, use WebSearch or check npm/PyPI to find the latest version\n   - For TypeScript: Check https://www.npmjs.com/package/@anthropic-ai/claude-agent-sdk\n   - For Python: Check https://pypi.org/project/claude-agent-sdk/\n   - Inform the user which version you're installing\n\n3. **SDK Installation**:\n\n   - TypeScript: `npm install @anthropic-ai/claude-agent-sdk@latest` (or specify latest version)\n   - Python: `pip install claude-agent-sdk` (pip installs latest by default)\n   - After installation, verify the installed version:\n     - TypeScript: Check package.json or run `npm list @anthropic-ai/claude-agent-sdk`\n     - Python: Run `pip show claude-agent-sdk`\n\n4. **Create starter files**:\n\n   - TypeScript: Create an `index.ts` or `src/index.ts` with a basic query example\n   - Python: Create a `main.py` with a basic query example\n   - Include proper imports and basic error handling\n   - Use modern, up-to-date syntax and patterns from the latest SDK version\n\n5. **Environment setup**:\n\n   - Create a `.env.example` file with `ANTHROPIC_API_KEY=your_api_key_here`\n   - Add `.env` to `.gitignore`\n   - Explain how to get an API key from https://console.anthropic.com/\n\n6. **Optional: Create .claude directory structure**:\n   - Offer to create `.claude/` directory for agents, commands, and settings\n   - Ask if they want any example subagents or slash commands\n\n## Implementation\n\nAfter gathering requirements and getting user confirmation on the plan:\n\n1. Check for latest package versions using WebSearch or WebFetch\n2. Execute the setup steps\n3. Create all necessary files\n4. Install dependencies (always use latest stable versions)\n5. Verify installed versions and inform the user\n6. Create a working example based on their agent type\n7. Add helpful comments in the code explaining what each part does\n8. **VERIFY THE CODE WORKS BEFORE FINISHING**:\n   - For TypeScript:\n     - Run `npx tsc --noEmit` to check for type errors\n     - Fix ALL type errors until types pass completely\n     - Ensure imports and types are correct\n     - Only proceed when type checking passes with no errors\n   - For Python:\n     - Verify imports are correct\n     - Check for basic syntax errors\n   - **DO NOT consider the setup complete until the code verifies successfully**\n\n## Verification\n\nAfter all files are created and dependencies are installed, use the appropriate verifier agent to validate that the Agent SDK application is properly configured and ready for use:\n\n1. **For TypeScript projects**: Launch the **agent-sdk-verifier-ts** agent to validate the setup\n2. **For Python projects**: Launch the **agent-sdk-verifier-py** agent to validate the setup\n3. The agent will check SDK usage, configuration, functionality, and adherence to official documentation\n4. Review the verification report and address any issues\n\n## Getting Started Guide\n\nOnce setup is complete and verified, provide the user with:\n\n1. **Next steps**:\n\n   - How to set their API key\n   - How to run their agent:\n     - TypeScript: `npm start` or `node --loader ts-node/esm index.ts`\n     - Python: `python main.py`\n\n2. **Useful resources**:\n\n   - Link to TypeScript SDK reference: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Link to Python SDK reference: https://docs.claude.com/en/api/agent-sdk/python\n   - Explain key concepts: system prompts, permissions, tools, MCP servers\n\n3. **Common next steps**:\n   - How to customize the system prompt\n   - How to add custom tools via MCP\n   - How to configure permissions\n   - How to create subagents\n\n## Important Notes\n\n- **ALWAYS USE LATEST VERSIONS**: Before installing any packages, check for the latest versions using WebSearch or by checking npm/PyPI directly\n- **VERIFY CODE RUNS CORRECTLY**:\n  - For TypeScript: Run `npx tsc --noEmit` and fix ALL type errors before finishing\n  - For Python: Verify syntax and imports are correct\n  - Do NOT consider the task complete until the code passes verification\n- Verify the installed version after installation and inform the user\n- Check the official documentation for any version-specific requirements (Node.js version, Python version, etc.)\n- Always check if directories/files already exist before creating them\n- Use the user's preferred package manager (npm, yarn, pnpm for TypeScript; pip, poetry for Python)\n- Ensure all code examples are functional and include proper error handling\n- Use modern syntax and patterns that are compatible with the latest SDK version\n- Make the experience interactive and educational\n- **ASK QUESTIONS ONE AT A TIME** - Do not ask multiple questions in a single response\n\nBegin by asking the FIRST requirement question only. Wait for the user's answer before proceeding to the next question."
              },
              {
                "name": "/code-review",
                "description": "Code review a pull request",
                "path": "plugins/code-review/commands/code-review.md",
                "frontmatter": {
                  "allowed-tools": "Bash(gh issue view:*), Bash(gh search:*), Bash(gh issue list:*), Bash(gh pr comment:*), Bash(gh pr diff:*), Bash(gh pr view:*), Bash(gh pr list:*)",
                  "description": "Code review a pull request",
                  "disable-model-invocation": false
                },
                "content": "Provide a code review for the given pull request.\n\nTo do this, follow these steps precisely:\n\n1. Use a Haiku agent to check if the pull request (a) is closed, (b) is a draft, (c) does not need a code review (eg. because it is an automated pull request, or is very simple and obviously ok), or (d) already has a code review from you from earlier. If so, do not proceed.\n2. Use another Haiku agent to give you a list of file paths to (but not the contents of) any relevant CLAUDE.md files from the codebase: the root CLAUDE.md file (if one exists), as well as any CLAUDE.md files in the directories whose files the pull request modified\n3. Use a Haiku agent to view the pull request, and ask the agent to return a summary of the change\n4. Then, launch 5 parallel Sonnet agents to independently code review the change. The agents should do the following, then return a list of issues and the reason each issue was flagged (eg. CLAUDE.md adherence, bug, historical git context, etc.):\n   a. Agent #1: Audit the changes to make sure they compily with the CLAUDE.md. Note that CLAUDE.md is guidance for Claude as it writes code, so not all instructions will be applicable during code review.\n   b. Agent #2: Read the file changes in the pull request, then do a shallow scan for obvious bugs. Avoid reading extra context beyond the changes, focusing just on the changes themselves. Focus on large bugs, and avoid small issues and nitpicks. Ignore likely false positives.\n   c. Agent #3: Read the git blame and history of the code modified, to identify any bugs in light of that historical context\n   d. Agent #4: Read previous pull requests that touched these files, and check for any comments on those pull requests that may also apply to the current pull request.\n   e. Agent #5: Read code comments in the modified files, and make sure the changes in the pull request comply with any guidance in the comments.\n5. For each issue found in #4, launch a parallel Haiku agent that takes the PR, issue description, and list of CLAUDE.md files (from step 2), and returns a score to indicate the agent's level of confidence for whether the issue is real or false positive. To do that, the agent should score each issue on a scale from 0-100, indicating its level of confidence. For issues that were flagged due to CLAUDE.md instructions, the agent should double check that the CLAUDE.md actually calls out that issue specifically. The scale is (give this rubric to the agent verbatim):\n   a. 0: Not confident at all. This is a false positive that doesn't stand up to light scrutiny, or is a pre-existing issue.\n   b. 25: Somewhat confident. This might be a real issue, but may also be a false positive. The agent wasn't able to verify that it's a real issue. If the issue is stylistic, it is one that was not explicitly called out in the relevant CLAUDE.md.\n   c. 50: Moderately confident. The agent was able to verify this is a real issue, but it might be a nitpick or not happen very often in practice. Relative to the rest of the PR, it's not very important.\n   d. 75: Highly confident. The agent double checked the issue, and verified that it is very likely it is a real issue that will be hit in practice. The existing approach in the PR is insufficient. The issue is very important and will directly impact the code's functionality, or it is an issue that is directly mentioned in the relevant CLAUDE.md.\n   e. 100: Absolutely certain. The agent double checked the issue, and confirmed that it is definitely a real issue, that will happen frequently in practice. The evidence directly confirms this.\n6. Filter out any issues with a score less than 80. If there are no issues that meet this criteria, do not proceed.\n7. Use a Haiku agent to repeat the eligibility check from #1, to make sure that the pull request is still eligible for code review.\n8. Finally, use the gh bash command to comment back on the pull request with the result. When writing your comment, keep in mind to:\n   a. Keep your output brief\n   b. Avoid emojis\n   c. Link and cite relevant code, files, and URLs\n\nExamples of false positives, for steps 4 and 5:\n\n- Pre-existing issues\n- Something that looks like a bug but is not actually a bug\n- Pedantic nitpicks that a senior engineer wouldn't call out\n- Issues that a linter, typechecker, or compiler would catch (eg. missing or incorrect imports, type errors, broken tests, formatting issues, pedantic style issues like newlines). No need to run these build steps yourself -- it is safe to assume that they will be run separately as part of CI.\n- General code quality issues (eg. lack of test coverage, general security issues, poor documentation), unless explicitly required in CLAUDE.md\n- Issues that are called out in CLAUDE.md, but explicitly silenced in the code (eg. due to a lint ignore comment)\n- Changes in functionality that are likely intentional or are directly related to the broader change\n- Real issues, but on lines that the user did not modify in their pull request\n\nNotes:\n\n- Do not check build signal or attempt to build or typecheck the app. These will run separately, and are not relevant to your code review.\n- Use `gh` to interact with Github (eg. to fetch a pull request, or to create inline comments), rather than web fetch\n- Make a todo list first\n- You must cite and link each bug (eg. if referring to a CLAUDE.md, you must link it)\n- For your final comment, follow the following format precisely (assuming for this example that you found 3 issues):\n\n---\n\n### Code review\n\nFound 3 issues:\n\n1. <brief description of bug> (CLAUDE.md says \"<...>\")\n\n<link to file and line with full sha1 + line range for context, note that you MUST provide the full sha and not use bash here, eg. https://github.com/anthropics/claude-code/blob/1d54823877c4de72b2316a64032a54afc404e619/README.md#L13-L17>\n\n2. <brief description of bug> (some/other/CLAUDE.md says \"<...>\")\n\n<link to file and line with full sha1 + line range for context>\n\n3. <brief description of bug> (bug due to <file and code snippet>)\n\n<link to file and line with full sha1 + line range for context>\n\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\n<sub>- If this code review was useful, please react with ðŸ‘. Otherwise, react with ðŸ‘Ž.</sub>\n\n---\n\n- Or, if you found no issues:\n\n---\n\n### Code review\n\nNo issues found. Checked for bugs and CLAUDE.md compliance.\n\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\n- When linking to code, follow the following format precisely, otherwise the Markdown preview won't render correctly: https://github.com/anthropics/claude-cli-internal/blob/c21d3c10bc8e898b7ac1a2d745bdc9bc4e423afe/package.json#L10-L15\n  - Requires full git sha\n  - You must provide the full sha. Commands like `https://github.com/owner/repo/blob/$(git rev-parse HEAD)/foo/bar` will not work, since your comment will be directly rendered in Markdown.\n  - Repo name must match the repo you're code reviewing\n  - # sign after the file name\n  - Line range format is L[start]-L[end]\n  - Provide at least 1 line of context before and after, centered on the line you are commenting about (eg. if you are commenting about lines 5-6, you should link to `L4-7`)"
              },
              {
                "name": "/clean_gone",
                "description": "Cleans up all git branches marked as [gone] (branches that have been deleted on the remote but still exist locally), including removing associated worktrees.",
                "path": "plugins/commit-commands/commands/clean_gone.md",
                "frontmatter": {
                  "description": "Cleans up all git branches marked as [gone] (branches that have been deleted on the remote but still exist locally), including removing associated worktrees."
                },
                "content": "## Your Task\n\nYou need to execute the following bash commands to clean up stale local branches that have been deleted from the remote repository.\n\n## Commands to Execute\n\n1. **First, list branches to identify any with [gone] status**\n   Execute this command:\n   ```bash\n   git branch -v\n   ```\n   \n   Note: Branches with a '+' prefix have associated worktrees and must have their worktrees removed before deletion.\n\n2. **Next, identify worktrees that need to be removed for [gone] branches**\n   Execute this command:\n   ```bash\n   git worktree list\n   ```\n\n3. **Finally, remove worktrees and delete [gone] branches (handles both regular and worktree branches)**\n   Execute this command:\n   ```bash\n   # Process all [gone] branches, removing '+' prefix if present\n   git branch -v | grep '\\[gone\\]' | sed 's/^[+* ]//' | awk '{print $1}' | while read branch; do\n     echo \"Processing branch: $branch\"\n     # Find and remove worktree if it exists\n     worktree=$(git worktree list | grep \"\\\\[$branch\\\\]\" | awk '{print $1}')\n     if [ ! -z \"$worktree\" ] && [ \"$worktree\" != \"$(git rev-parse --show-toplevel)\" ]; then\n       echo \"  Removing worktree: $worktree\"\n       git worktree remove --force \"$worktree\"\n     fi\n     # Delete the branch\n     echo \"  Deleting branch: $branch\"\n     git branch -D \"$branch\"\n   done\n   ```\n\n## Expected Behavior\n\nAfter executing these commands, you will:\n\n- See a list of all local branches with their status\n- Identify and remove any worktrees associated with [gone] branches\n- Delete all branches marked as [gone]\n- Provide feedback on which worktrees and branches were removed\n\nIf no branches are marked as [gone], report that no cleanup was needed."
              },
              {
                "name": "/commit-push-pr",
                "description": "Commit, push, and open a PR",
                "path": "plugins/commit-commands/commands/commit-push-pr.md",
                "frontmatter": {
                  "allowed-tools": "Bash(git checkout --branch:*), Bash(git add:*), Bash(git status:*), Bash(git push:*), Bash(git commit:*), Bash(gh pr create:*)",
                  "description": "Commit, push, and open a PR"
                },
                "content": "## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n\n## Your task\n\nBased on the above changes:\n\n1. Create a new branch if on main\n2. Create a single commit with an appropriate message\n3. Push the branch to origin\n4. Create a pull request using `gh pr create`\n5. You have the capability to call multiple tools in a single response. You MUST do all of the above in a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls."
              },
              {
                "name": "/commit",
                "description": "Create a git commit",
                "path": "plugins/commit-commands/commands/commit.md",
                "frontmatter": {
                  "allowed-tools": "Bash(git add:*), Bash(git status:*), Bash(git commit:*)",
                  "description": "Create a git commit"
                },
                "content": "## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n- Recent commits: !`git log --oneline -10`\n\n## Your task\n\nBased on the above changes, create a single git commit.\n\nYou have the capability to call multiple tools in a single response. Stage and create the commit using a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls."
              },
              {
                "name": "/example-command",
                "description": "An example slash command that demonstrates command frontmatter options",
                "path": "plugins/example-plugin/commands/example-command.md",
                "frontmatter": {
                  "description": "An example slash command that demonstrates command frontmatter options",
                  "argument-hint": "<required-arg> [optional-arg]",
                  "allowed-tools": [
                    "Read",
                    "Glob",
                    "Grep",
                    "Bash"
                  ]
                },
                "content": "# Example Command\n\nThis command demonstrates slash command structure and frontmatter options.\n\n## Arguments\n\nThe user invoked this command with: $ARGUMENTS\n\n## Instructions\n\nWhen this command is invoked:\n\n1. Parse the arguments provided by the user\n2. Perform the requested action using allowed tools\n3. Report results back to the user\n\n## Frontmatter Options Reference\n\nCommands support these frontmatter fields:\n\n- **description**: Short description shown in /help\n- **argument-hint**: Hints for command arguments shown to user\n- **allowed-tools**: Pre-approved tools for this command (reduces permission prompts)\n- **model**: Override the model (e.g., \"haiku\", \"sonnet\", \"opus\")\n\n## Example Usage\n\n```\n/example-command my-argument\n/example-command arg1 arg2\n```"
              },
              {
                "name": "/feature-dev",
                "description": "Guided feature development with codebase understanding and architecture focus",
                "path": "plugins/feature-dev/commands/feature-dev.md",
                "frontmatter": {
                  "description": "Guided feature development with codebase understanding and architecture focus",
                  "argument-hint": "Optional feature description"
                },
                "content": "# Feature Development\n\nYou are helping a developer implement a new feature. Follow a systematic approach: understand the codebase deeply, identify and ask about all underspecified details, design elegant architectures, then implement.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities, edge cases, and underspecified behaviors. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation. Ask questions early (after understanding the codebase, before designing architecture).\n- **Understand before acting**: Read and comprehend existing code patterns first\n- **Read files identified by agents**: When launching agents, ask them to return lists of the most important files to read. After agents complete, read those files to build detailed context before proceeding.\n- **Simple and elegant**: Prioritize readable, maintainable, architecturally sound code\n- **Use TodoWrite**: Track all progress throughout\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what needs to be built\n\nInitial request: $ARGUMENTS\n\n**Actions**:\n1. Create todo list with all phases\n2. If feature unclear, ask user for:\n   - What problem are they solving?\n   - What should the feature do?\n   - Any constraints or requirements?\n3. Summarize understanding and confirm with user\n\n---\n\n## Phase 2: Codebase Exploration\n\n**Goal**: Understand relevant existing code and patterns at both high and low levels\n\n**Actions**:\n1. Launch 2-3 code-explorer agents in parallel. Each agent should:\n   - Trace through the code comprehensively and focus on getting a comprehensive understanding of abstractions, architecture and flow of control\n   - Target a different aspect of the codebase (eg. similar features, high level understanding, architectural understanding, user experience, etc)\n   - Include a list of 5-10 key files to read\n\n   **Example agent prompts**:\n   - \"Find features similar to [feature] and trace through their implementation comprehensively\"\n   - \"Map the architecture and abstractions for [feature area], tracing through the code comprehensively\"\n   - \"Analyze the current implementation of [existing feature/area], tracing through the code comprehensively\"\n   - \"Identify UI patterns, testing approaches, or extension points relevant to [feature]\"\n\n2. Once the agents return, please read all files identified by agents to build deep understanding\n3. Present comprehensive summary of findings and patterns discovered\n\n---\n\n## Phase 3: Clarifying Questions\n\n**Goal**: Fill in gaps and resolve all ambiguities before designing\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. Review the codebase findings and original feature request\n2. Identify underspecified aspects: edge cases, error handling, integration points, scope boundaries, design preferences, backward compatibility, performance needs\n3. **Present all questions to the user in a clear, organized list**\n4. **Wait for answers before proceeding to architecture design**\n\nIf the user says \"whatever you think is best\", provide your recommendation and get explicit confirmation.\n\n---\n\n## Phase 4: Architecture Design\n\n**Goal**: Design multiple implementation approaches with different trade-offs\n\n**Actions**:\n1. Launch 2-3 code-architect agents in parallel with different focuses: minimal changes (smallest change, maximum reuse), clean architecture (maintainability, elegant abstractions), or pragmatic balance (speed + quality)\n2. Review all approaches and form your opinion on which fits best for this specific task (consider: small fix vs large feature, urgency, complexity, team context)\n3. Present to user: brief summary of each approach, trade-offs comparison, **your recommendation with reasoning**, concrete implementation differences\n4. **Ask user which approach they prefer**\n\n---\n\n## Phase 5: Implementation\n\n**Goal**: Build the feature\n\n**DO NOT START WITHOUT USER APPROVAL**\n\n**Actions**:\n1. Wait for explicit user approval\n2. Read all relevant files identified in previous phases\n3. Implement following chosen architecture\n4. Follow codebase conventions strictly\n5. Write clean, well-documented code\n6. Update todos as you progress\n\n---\n\n## Phase 6: Quality Review\n\n**Goal**: Ensure code is simple, DRY, elegant, easy to read, and functionally correct\n\n**Actions**:\n1. Launch 3 code-reviewer agents in parallel with different focuses: simplicity/DRY/elegance, bugs/functional correctness, project conventions/abstractions\n2. Consolidate findings and identify highest severity issues that you recommend fixing\n3. **Present findings to user and ask what they want to do** (fix now, fix later, or proceed as-is)\n4. Address issues based on user decision\n\n---\n\n## Phase 7: Summary\n\n**Goal**: Document what was accomplished\n\n**Actions**:\n1. Mark all todos complete\n2. Summarize:\n   - What was built\n   - Key decisions made\n   - Files modified\n   - Suggested next steps\n\n---"
              },
              {
                "name": "/configure",
                "description": "Enable or disable hookify rules interactively",
                "path": "plugins/hookify/commands/configure.md",
                "frontmatter": {
                  "description": "Enable or disable hookify rules interactively",
                  "allowed-tools": [
                    "Glob",
                    "Read",
                    "Edit",
                    "AskUserQuestion",
                    "Skill"
                  ]
                },
                "content": "# Configure Hookify Rules\n\n**Load hookify:writing-rules skill first** to understand rule format.\n\nEnable or disable existing hookify rules using an interactive interface.\n\n## Steps\n\n### 1. Find Existing Rules\n\nUse Glob tool to find all hookify rule files:\n```\npattern: \".claude/hookify.*.local.md\"\n```\n\nIf no rules found, inform user:\n```\nNo hookify rules configured yet. Use `/hookify` to create your first rule.\n```\n\n### 2. Read Current State\n\nFor each rule file:\n- Read the file\n- Extract `name` and `enabled` fields from frontmatter\n- Build list of rules with current state\n\n### 3. Ask User Which Rules to Toggle\n\nUse AskUserQuestion to let user select rules:\n\n```json\n{\n  \"questions\": [\n    {\n      \"question\": \"Which rules would you like to enable or disable?\",\n      \"header\": \"Configure\",\n      \"multiSelect\": true,\n      \"options\": [\n        {\n          \"label\": \"warn-dangerous-rm (currently enabled)\",\n          \"description\": \"Warns about rm -rf commands\"\n        },\n        {\n          \"label\": \"warn-console-log (currently disabled)\",\n          \"description\": \"Warns about console.log in code\"\n        },\n        {\n          \"label\": \"require-tests (currently enabled)\",\n          \"description\": \"Requires tests before stopping\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Option format:**\n- Label: `{rule-name} (currently {enabled|disabled})`\n- Description: Brief description from rule's message or pattern\n\n### 4. Parse User Selection\n\nFor each selected rule:\n- Determine current state from label (enabled/disabled)\n- Toggle state: enabled â†’ disabled, disabled â†’ enabled\n\n### 5. Update Rule Files\n\nFor each rule to toggle:\n- Use Read tool to read current content\n- Use Edit tool to change `enabled: true` to `enabled: false` (or vice versa)\n- Handle both with and without quotes\n\n**Edit pattern for enabling:**\n```\nold_string: \"enabled: false\"\nnew_string: \"enabled: true\"\n```\n\n**Edit pattern for disabling:**\n```\nold_string: \"enabled: true\"\nnew_string: \"enabled: false\"\n```\n\n### 6. Confirm Changes\n\nShow user what was changed:\n\n```\n## Hookify Rules Updated\n\n**Enabled:**\n- warn-console-log\n\n**Disabled:**\n- warn-dangerous-rm\n\n**Unchanged:**\n- require-tests\n\nChanges apply immediately - no restart needed\n```\n\n## Important Notes\n\n- Changes take effect immediately on next tool use\n- You can also manually edit .claude/hookify.*.local.md files\n- To permanently remove a rule, delete its .local.md file\n- Use `/hookify:list` to see all configured rules\n\n## Edge Cases\n\n**No rules to configure:**\n- Show message about using `/hookify` to create rules first\n\n**User selects no rules:**\n- Inform that no changes were made\n\n**File read/write errors:**\n- Inform user of specific error\n- Suggest manual editing as fallback"
              },
              {
                "name": "/help",
                "description": "Get help with the hookify plugin",
                "path": "plugins/hookify/commands/help.md",
                "frontmatter": {
                  "description": "Get help with the hookify plugin",
                  "allowed-tools": [
                    "Read"
                  ]
                },
                "content": "# Hookify Plugin Help\n\nExplain how the hookify plugin works and how to use it.\n\n## Overview\n\nThe hookify plugin makes it easy to create custom hooks that prevent unwanted behaviors. Instead of editing `hooks.json` files, users create simple markdown configuration files that define patterns to watch for.\n\n## How It Works\n\n### 1. Hook System\n\nHookify installs generic hooks that run on these events:\n- **PreToolUse**: Before any tool executes (Bash, Edit, Write, etc.)\n- **PostToolUse**: After a tool executes\n- **Stop**: When Claude wants to stop working\n- **UserPromptSubmit**: When user submits a prompt\n\nThese hooks read configuration files from `.claude/hookify.*.local.md` and check if any rules match the current operation.\n\n### 2. Configuration Files\n\nUsers create rules in `.claude/hookify.{rule-name}.local.md` files:\n\n```markdown\n---\nname: warn-dangerous-rm\nenabled: true\nevent: bash\npattern: rm\\s+-rf\n---\n\nâš ï¸ **Dangerous rm command detected!**\n\nThis command could delete important files. Please verify the path.\n```\n\n**Key fields:**\n- `name`: Unique identifier for the rule\n- `enabled`: true/false to activate/deactivate\n- `event`: bash, file, stop, prompt, or all\n- `pattern`: Regex pattern to match\n\nThe message body is what Claude sees when the rule triggers.\n\n### 3. Creating Rules\n\n**Option A: Use /hookify command**\n```\n/hookify Don't use console.log in production files\n```\n\nThis analyzes your request and creates the appropriate rule file.\n\n**Option B: Create manually**\nCreate `.claude/hookify.my-rule.local.md` with the format above.\n\n**Option C: Analyze conversation**\n```\n/hookify\n```\n\nWithout arguments, hookify analyzes recent conversation to find behaviors you want to prevent.\n\n## Available Commands\n\n- **`/hookify`** - Create hooks from conversation analysis or explicit instructions\n- **`/hookify:help`** - Show this help (what you're reading now)\n- **`/hookify:list`** - List all configured hooks\n- **`/hookify:configure`** - Enable/disable existing hooks interactively\n\n## Example Use Cases\n\n**Prevent dangerous commands:**\n```markdown\n---\nname: block-chmod-777\nenabled: true\nevent: bash\npattern: chmod\\s+777\n---\n\nDon't use chmod 777 - it's a security risk. Use specific permissions instead.\n```\n\n**Warn about debugging code:**\n```markdown\n---\nname: warn-console-log\nenabled: true\nevent: file\npattern: console\\.log\\(\n---\n\nConsole.log detected. Remember to remove debug logging before committing.\n```\n\n**Require tests before stopping:**\n```markdown\n---\nname: require-tests\nenabled: true\nevent: stop\npattern: .*\n---\n\nDid you run tests before finishing? Make sure `npm test` or equivalent was executed.\n```\n\n## Pattern Syntax\n\nUse Python regex syntax:\n- `\\s` - whitespace\n- `\\.` - literal dot\n- `|` - OR\n- `+` - one or more\n- `*` - zero or more\n- `\\d` - digit\n- `[abc]` - character class\n\n**Examples:**\n- `rm\\s+-rf` - matches \"rm -rf\"\n- `console\\.log\\(` - matches \"console.log(\"\n- `(eval|exec)\\(` - matches \"eval(\" or \"exec(\"\n- `\\.env$` - matches files ending in .env\n\n## Important Notes\n\n**No Restart Needed**: Hookify rules (`.local.md` files) take effect immediately on the next tool use. The hookify hooks are already loaded and read your rules dynamically.\n\n**Block or Warn**: Rules can either `block` operations (prevent execution) or `warn` (show message but allow). Set `action: block` or `action: warn` in the rule's frontmatter.\n\n**Rule Files**: Keep rules in `.claude/hookify.*.local.md` - they should be git-ignored (add to .gitignore if needed).\n\n**Disable Rules**: Set `enabled: false` in frontmatter or delete the file.\n\n## Troubleshooting\n\n**Hook not triggering:**\n- Check rule file is in `.claude/` directory\n- Verify `enabled: true` in frontmatter\n- Confirm pattern is valid regex\n- Test pattern: `python3 -c \"import re; print(re.search('your_pattern', 'test_text'))\"`\n- Rules take effect immediately - no restart needed\n\n**Import errors:**\n- Check Python 3 is available: `python3 --version`\n- Verify hookify plugin is installed correctly\n\n**Pattern not matching:**\n- Test regex separately\n- Check for escaping issues (use unquoted patterns in YAML)\n- Try simpler pattern first, then refine\n\n## Getting Started\n\n1. Create your first rule:\n   ```\n   /hookify Warn me when I try to use rm -rf\n   ```\n\n2. Try to trigger it:\n   - Ask Claude to run `rm -rf /tmp/test`\n   - You should see the warning\n\n4. Refine the rule by editing `.claude/hookify.warn-rm.local.md`\n\n5. Create more rules as you encounter unwanted behaviors\n\nFor more examples, check the `${CLAUDE_PLUGIN_ROOT}/examples/` directory."
              },
              {
                "name": "/hookify",
                "description": "Create hooks to prevent unwanted behaviors from conversation analysis or explicit instructions",
                "path": "plugins/hookify/commands/hookify.md",
                "frontmatter": {
                  "description": "Create hooks to prevent unwanted behaviors from conversation analysis or explicit instructions",
                  "argument-hint": "Optional specific behavior to address",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "AskUserQuestion",
                    "Task",
                    "Grep",
                    "TodoWrite",
                    "Skill"
                  ]
                },
                "content": "# Hookify - Create Hooks from Unwanted Behaviors\n\n**FIRST: Load the hookify:writing-rules skill** using the Skill tool to understand rule file format and syntax.\n\nCreate hook rules to prevent problematic behaviors by analyzing the conversation or from explicit user instructions.\n\n## Your Task\n\nYou will help the user create hookify rules to prevent unwanted behaviors. Follow these steps:\n\n### Step 1: Gather Behavior Information\n\n**If $ARGUMENTS is provided:**\n- User has given specific instructions: `$ARGUMENTS`\n- Still analyze recent conversation (last 10-15 user messages) for additional context\n- Look for examples of the behavior happening\n\n**If $ARGUMENTS is empty:**\n- Launch the conversation-analyzer agent to find problematic behaviors\n- Agent will scan user prompts for frustration signals\n- Agent will return structured findings\n\n**To analyze conversation:**\nUse the Task tool to launch conversation-analyzer agent:\n```\n{\n  \"subagent_type\": \"general-purpose\",\n  \"description\": \"Analyze conversation for unwanted behaviors\",\n  \"prompt\": \"You are analyzing a Claude Code conversation to find behaviors the user wants to prevent.\n\nRead user messages in the current conversation and identify:\n1. Explicit requests to avoid something (\\\"don't do X\\\", \\\"stop doing Y\\\")\n2. Corrections or reversions (user fixing Claude's actions)\n3. Frustrated reactions (\\\"why did you do X?\\\", \\\"I didn't ask for that\\\")\n4. Repeated issues (same problem multiple times)\n\nFor each issue found, extract:\n- What tool was used (Bash, Edit, Write, etc.)\n- Specific pattern or command\n- Why it was problematic\n- User's stated reason\n\nReturn findings as a structured list with:\n- category: Type of issue\n- tool: Which tool was involved\n- pattern: Regex or literal pattern to match\n- context: What happened\n- severity: high/medium/low\n\nFocus on the most recent issues (last 20-30 messages). Don't go back further unless explicitly asked.\"\n}\n```\n\n### Step 2: Present Findings to User\n\nAfter gathering behaviors (from arguments or agent), present to user using AskUserQuestion:\n\n**Question 1: Which behaviors to hookify?**\n- Header: \"Create Rules\"\n- multiSelect: true\n- Options: List each detected behavior (max 4)\n  - Label: Short description (e.g., \"Block rm -rf\")\n  - Description: Why it's problematic\n\n**Question 2: For each selected behavior, ask about action:**\n- \"Should this block the operation or just warn?\"\n- Options:\n  - \"Just warn\" (action: warn - shows message but allows)\n  - \"Block operation\" (action: block - prevents execution)\n\n**Question 3: Ask for example patterns:**\n- \"What patterns should trigger this rule?\"\n- Show detected patterns\n- Allow user to refine or add more\n\n### Step 3: Generate Rule Files\n\nFor each confirmed behavior, create a `.claude/hookify.{rule-name}.local.md` file:\n\n**Rule naming convention:**\n- Use kebab-case\n- Be descriptive: `block-dangerous-rm`, `warn-console-log`, `require-tests-before-stop`\n- Start with action verb: block, warn, prevent, require\n\n**File format:**\n```markdown\n---\nname: {rule-name}\nenabled: true\nevent: {bash|file|stop|prompt|all}\npattern: {regex pattern}\naction: {warn|block}\n---\n\n{Message to show Claude when rule triggers}\n```\n\n**Action values:**\n- `warn`: Show message but allow operation (default)\n- `block`: Prevent operation or stop session\n\n**For more complex rules (multiple conditions):**\n```markdown\n---\nname: {rule-name}\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$\n  - field: new_text\n    operator: contains\n    pattern: API_KEY\n---\n\n{Warning message}\n```\n\n### Step 4: Create Files and Confirm\n\n**IMPORTANT**: Rule files must be created in the current working directory's `.claude/` folder, NOT the plugin directory.\n\nUse the current working directory (where Claude Code was started) as the base path.\n\n1. Check if `.claude/` directory exists in current working directory\n   - If not, create it first with: `mkdir -p .claude`\n\n2. Use Write tool to create each `.claude/hookify.{name}.local.md` file\n   - Use relative path from current working directory: `.claude/hookify.{name}.local.md`\n   - The path should resolve to the project's .claude directory, not the plugin's\n\n3. Show user what was created:\n   ```\n   Created 3 hookify rules:\n   - .claude/hookify.dangerous-rm.local.md\n   - .claude/hookify.console-log.local.md\n   - .claude/hookify.sensitive-files.local.md\n\n   These rules will trigger on:\n   - dangerous-rm: Bash commands matching \"rm -rf\"\n   - console-log: Edits adding console.log statements\n   - sensitive-files: Edits to .env or credentials files\n   ```\n\n4. Verify files were created in the correct location by listing them\n\n5. Inform user: **\"Rules are active immediately - no restart needed!\"**\n\n   The hookify hooks are already loaded and will read your new rules on the next tool use.\n\n## Event Types Reference\n\n- **bash**: Matches Bash tool commands\n- **file**: Matches Edit, Write, MultiEdit tools\n- **stop**: Matches when agent wants to stop (use for completion checks)\n- **prompt**: Matches when user submits prompts\n- **all**: Matches all events\n\n## Pattern Writing Tips\n\n**Bash patterns:**\n- Match dangerous commands: `rm\\s+-rf|chmod\\s+777|dd\\s+if=`\n- Match specific tools: `npm\\s+install\\s+|pip\\s+install`\n\n**File patterns:**\n- Match code patterns: `console\\.log\\(|eval\\(|innerHTML\\s*=`\n- Match file paths: `\\.env$|\\.git/|node_modules/`\n\n**Stop patterns:**\n- Check for missing steps: (check transcript or completion criteria)\n\n## Example Workflow\n\n**User says**: \"/hookify Don't use rm -rf without asking me first\"\n\n**Your response**:\n1. Analyze: User wants to prevent rm -rf commands\n2. Ask: \"Should I block this command or just warn you?\"\n3. User selects: \"Just warn\"\n4. Create `.claude/hookify.dangerous-rm.local.md`:\n   ```markdown\n   ---\n   name: warn-dangerous-rm\n   enabled: true\n   event: bash\n   pattern: rm\\s+-rf\n   ---\n\n   âš ï¸ **Dangerous rm command detected**\n\n   You requested to be warned before using rm -rf.\n   Please verify the path is correct.\n   ```\n5. Confirm: \"Created hookify rule. It's active immediately - try triggering it!\"\n\n## Important Notes\n\n- **No restart needed**: Rules take effect immediately on the next tool use\n- **File location**: Create files in project's `.claude/` directory (current working directory), NOT the plugin's .claude/\n- **Regex syntax**: Use Python regex syntax (raw strings, no need to escape in YAML)\n- **Action types**: Rules can `warn` (default) or `block` operations\n- **Testing**: Test rules immediately after creating them\n\n## Troubleshooting\n\n**If rule file creation fails:**\n1. Check current working directory with pwd\n2. Ensure `.claude/` directory exists (create with mkdir if needed)\n3. Use absolute path if needed: `{cwd}/.claude/hookify.{name}.local.md`\n4. Verify file was created with Glob or ls\n\n**If rule doesn't trigger after creation:**\n1. Verify file is in project `.claude/` not plugin `.claude/`\n2. Check file with Read tool to ensure pattern is correct\n3. Test pattern with: `python3 -c \"import re; print(re.search(r'pattern', 'test text'))\"`\n4. Verify `enabled: true` in frontmatter\n5. Remember: Rules work immediately, no restart needed\n\n**If blocking seems too strict:**\n1. Change `action: block` to `action: warn` in the rule file\n2. Or adjust the pattern to be more specific\n3. Changes take effect on next tool use\n\nUse TodoWrite to track your progress through the steps."
              },
              {
                "name": "/list",
                "description": "List all configured hookify rules",
                "path": "plugins/hookify/commands/list.md",
                "frontmatter": {
                  "description": "List all configured hookify rules",
                  "allowed-tools": [
                    "Glob",
                    "Read",
                    "Skill"
                  ]
                },
                "content": "# List Hookify Rules\n\n**Load hookify:writing-rules skill first** to understand rule format.\n\nShow all configured hookify rules in the project.\n\n## Steps\n\n1. Use Glob tool to find all hookify rule files:\n   ```\n   pattern: \".claude/hookify.*.local.md\"\n   ```\n\n2. For each file found:\n   - Use Read tool to read the file\n   - Extract frontmatter fields: name, enabled, event, pattern\n   - Extract message preview (first 100 chars)\n\n3. Present results in a table:\n\n```\n## Configured Hookify Rules\n\n| Name | Enabled | Event | Pattern | File |\n|------|---------|-------|---------|------|\n| warn-dangerous-rm | âœ… Yes | bash | rm\\s+-rf | hookify.dangerous-rm.local.md |\n| warn-console-log | âœ… Yes | file | console\\.log\\( | hookify.console-log.local.md |\n| check-tests | âŒ No | stop | .* | hookify.require-tests.local.md |\n\n**Total**: 3 rules (2 enabled, 1 disabled)\n```\n\n4. For each rule, show a brief preview:\n```\n### warn-dangerous-rm\n**Event**: bash\n**Pattern**: `rm\\s+-rf`\n**Message**: \"âš ï¸ **Dangerous rm command detected!** This command could delete...\"\n\n**Status**: âœ… Active\n**File**: .claude/hookify.dangerous-rm.local.md\n```\n\n5. Add helpful footer:\n```\n---\n\nTo modify a rule: Edit the .local.md file directly\nTo disable a rule: Set `enabled: false` in frontmatter\nTo enable a rule: Set `enabled: true` in frontmatter\nTo delete a rule: Remove the .local.md file\nTo create a rule: Use `/hookify` command\n\n**Remember**: Changes take effect immediately - no restart needed\n```\n\n## If No Rules Found\n\nIf no hookify rules exist:\n\n```\n## No Hookify Rules Configured\n\nYou haven't created any hookify rules yet.\n\nTo get started:\n1. Use `/hookify` to analyze conversation and create rules\n2. Or manually create `.claude/hookify.my-rule.local.md` files\n3. See `/hookify:help` for documentation\n\nExample:\n```\n/hookify Warn me when I use console.log\n```\n\nCheck `${CLAUDE_PLUGIN_ROOT}/examples/` for example rule files.\n```"
              },
              {
                "name": "/create-plugin",
                "description": "Guided end-to-end plugin creation workflow with component design, implementation, and validation",
                "path": "plugins/plugin-dev/commands/create-plugin.md",
                "frontmatter": {
                  "description": "Guided end-to-end plugin creation workflow with component design, implementation, and validation",
                  "argument-hint": "Optional plugin description",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "Grep",
                    "Glob",
                    "Bash",
                    "TodoWrite",
                    "AskUserQuestion",
                    "Skill",
                    "Task"
                  ]
                },
                "content": "# Plugin Creation Workflow\n\nGuide the user through creating a complete, high-quality Claude Code plugin from initial concept to tested implementation. Follow a systematic approach: understand requirements, design components, clarify details, implement following best practices, validate, and test.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities about plugin purpose, triggering, scope, and components. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation.\n- **Load relevant skills**: Use the Skill tool to load plugin-dev skills when needed (plugin-structure, hook-development, agent-development, etc.)\n- **Use specialized agents**: Leverage agent-creator, plugin-validator, and skill-reviewer agents for AI-assisted development\n- **Follow best practices**: Apply patterns from plugin-dev's own implementation\n- **Progressive disclosure**: Create lean skills with references/examples\n- **Use TodoWrite**: Track all progress throughout all phases\n\n**Initial request:** $ARGUMENTS\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what plugin needs to be built and what problem it solves\n\n**Actions**:\n1. Create todo list with all 7 phases\n2. If plugin purpose is clear from arguments:\n   - Summarize understanding\n   - Identify plugin type (integration, workflow, analysis, toolkit, etc.)\n3. If plugin purpose is unclear, ask user:\n   - What problem does this plugin solve?\n   - Who will use it and when?\n   - What should it do?\n   - Any similar plugins to reference?\n4. Summarize understanding and confirm with user before proceeding\n\n**Output**: Clear statement of plugin purpose and target users\n\n---\n\n## Phase 2: Component Planning\n\n**Goal**: Determine what plugin components are needed\n\n**MUST load plugin-structure skill** using Skill tool before this phase.\n\n**Actions**:\n1. Load plugin-structure skill to understand component types\n2. Analyze plugin requirements and determine needed components:\n   - **Skills**: Does it need specialized knowledge? (hooks API, MCP patterns, etc.)\n   - **Commands**: User-initiated actions? (deploy, configure, analyze)\n   - **Agents**: Autonomous tasks? (validation, generation, analysis)\n   - **Hooks**: Event-driven automation? (validation, notifications)\n   - **MCP**: External service integration? (databases, APIs)\n   - **Settings**: User configuration? (.local.md files)\n3. For each component type needed, identify:\n   - How many of each type\n   - What each one does\n   - Rough triggering/usage patterns\n4. Present component plan to user as table:\n   ```\n   | Component Type | Count | Purpose |\n   |----------------|-------|---------|\n   | Skills         | 2     | Hook patterns, MCP usage |\n   | Commands       | 3     | Deploy, configure, validate |\n   | Agents         | 1     | Autonomous validation |\n   | Hooks          | 0     | Not needed |\n   | MCP            | 1     | Database integration |\n   ```\n5. Get user confirmation or adjustments\n\n**Output**: Confirmed list of components to create\n\n---\n\n## Phase 3: Detailed Design & Clarifying Questions\n\n**Goal**: Specify each component in detail and resolve all ambiguities\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. For each component in the plan, identify underspecified aspects:\n   - **Skills**: What triggers them? What knowledge do they provide? How detailed?\n   - **Commands**: What arguments? What tools? Interactive or automated?\n   - **Agents**: When to trigger (proactive/reactive)? What tools? Output format?\n   - **Hooks**: Which events? Prompt or command based? Validation criteria?\n   - **MCP**: What server type? Authentication? Which tools?\n   - **Settings**: What fields? Required vs optional? Defaults?\n\n2. **Present all questions to user in organized sections** (one section per component type)\n\n3. **Wait for answers before proceeding to implementation**\n\n4. If user says \"whatever you think is best\", provide specific recommendations and get explicit confirmation\n\n**Example questions for a skill**:\n- What specific user queries should trigger this skill?\n- Should it include utility scripts? What functionality?\n- How detailed should the core SKILL.md be vs references/?\n- Any real-world examples to include?\n\n**Example questions for an agent**:\n- Should this agent trigger proactively after certain actions, or only when explicitly requested?\n- What tools does it need (Read, Write, Bash, etc.)?\n- What should the output format be?\n- Any specific quality standards to enforce?\n\n**Output**: Detailed specification for each component\n\n---\n\n## Phase 4: Plugin Structure Creation\n\n**Goal**: Create plugin directory structure and manifest\n\n**Actions**:\n1. Determine plugin name (kebab-case, descriptive)\n2. Choose plugin location:\n   - Ask user: \"Where should I create the plugin?\"\n   - Offer options: current directory, ../new-plugin-name, custom path\n3. Create directory structure using bash:\n   ```bash\n   mkdir -p plugin-name/.claude-plugin\n   mkdir -p plugin-name/skills     # if needed\n   mkdir -p plugin-name/commands   # if needed\n   mkdir -p plugin-name/agents     # if needed\n   mkdir -p plugin-name/hooks      # if needed\n   ```\n4. Create plugin.json manifest using Write tool:\n   ```json\n   {\n     \"name\": \"plugin-name\",\n     \"version\": \"0.1.0\",\n     \"description\": \"[brief description]\",\n     \"author\": {\n       \"name\": \"[author from user or default]\",\n       \"email\": \"[email or default]\"\n     }\n   }\n   ```\n5. Create README.md template\n6. Create .gitignore if needed (for .claude/*.local.md, etc.)\n7. Initialize git repo if creating new directory\n\n**Output**: Plugin directory structure created and ready for components\n\n---\n\n## Phase 5: Component Implementation\n\n**Goal**: Create each component following best practices\n\n**LOAD RELEVANT SKILLS** before implementing each component type:\n- Skills: Load skill-development skill\n- Commands: Load command-development skill\n- Agents: Load agent-development skill\n- Hooks: Load hook-development skill\n- MCP: Load mcp-integration skill\n- Settings: Load plugin-settings skill\n\n**Actions for each component**:\n\n### For Skills:\n1. Load skill-development skill using Skill tool\n2. For each skill:\n   - Ask user for concrete usage examples (or use from Phase 3)\n   - Plan resources (scripts/, references/, examples/)\n   - Create skill directory structure\n   - Write SKILL.md with:\n     - Third-person description with specific trigger phrases\n     - Lean body (1,500-2,000 words) in imperative form\n     - References to supporting files\n   - Create reference files for detailed content\n   - Create example files for working code\n   - Create utility scripts if needed\n3. Use skill-reviewer agent to validate each skill\n\n### For Commands:\n1. Load command-development skill using Skill tool\n2. For each command:\n   - Write command markdown with frontmatter\n   - Include clear description and argument-hint\n   - Specify allowed-tools (minimal necessary)\n   - Write instructions FOR Claude (not TO user)\n   - Provide usage examples and tips\n   - Reference relevant skills if applicable\n\n### For Agents:\n1. Load agent-development skill using Skill tool\n2. For each agent, use agent-creator agent:\n   - Provide description of what agent should do\n   - Agent-creator generates: identifier, whenToUse with examples, systemPrompt\n   - Create agent markdown file with frontmatter and system prompt\n   - Add appropriate model, color, and tools\n   - Validate with validate-agent.sh script\n\n### For Hooks:\n1. Load hook-development skill using Skill tool\n2. For each hook:\n   - Create hooks/hooks.json with hook configuration\n   - Prefer prompt-based hooks for complex logic\n   - Use ${CLAUDE_PLUGIN_ROOT} for portability\n   - Create hook scripts if needed (in examples/ not scripts/)\n   - Test with validate-hook-schema.sh and test-hook.sh utilities\n\n### For MCP:\n1. Load mcp-integration skill using Skill tool\n2. Create .mcp.json configuration with:\n   - Server type (stdio for local, SSE for hosted)\n   - Command and args (with ${CLAUDE_PLUGIN_ROOT})\n   - extensionToLanguage mapping if LSP\n   - Environment variables as needed\n3. Document required env vars in README\n4. Provide setup instructions\n\n### For Settings:\n1. Load plugin-settings skill using Skill tool\n2. Create settings template in README\n3. Create example .claude/plugin-name.local.md file (as documentation)\n4. Implement settings reading in hooks/commands as needed\n5. Add to .gitignore: `.claude/*.local.md`\n\n**Progress tracking**: Update todos as each component is completed\n\n**Output**: All plugin components implemented\n\n---\n\n## Phase 6: Validation & Quality Check\n\n**Goal**: Ensure plugin meets quality standards and works correctly\n\n**Actions**:\n1. **Run plugin-validator agent**:\n   - Use plugin-validator agent to comprehensively validate plugin\n   - Check: manifest, structure, naming, components, security\n   - Review validation report\n\n2. **Fix critical issues**:\n   - Address any critical errors from validation\n   - Fix any warnings that indicate real problems\n\n3. **Review with skill-reviewer** (if plugin has skills):\n   - For each skill, use skill-reviewer agent\n   - Check description quality, progressive disclosure, writing style\n   - Apply recommendations\n\n4. **Test agent triggering** (if plugin has agents):\n   - For each agent, verify <example> blocks are clear\n   - Check triggering conditions are specific\n   - Run validate-agent.sh on agent files\n\n5. **Test hook configuration** (if plugin has hooks):\n   - Run validate-hook-schema.sh on hooks/hooks.json\n   - Test hook scripts with test-hook.sh\n   - Verify ${CLAUDE_PLUGIN_ROOT} usage\n\n6. **Present findings**:\n   - Summary of validation results\n   - Any remaining issues\n   - Overall quality assessment\n\n7. **Ask user**: \"Validation complete. Issues found: [count critical], [count warnings]. Would you like me to fix them now, or proceed to testing?\"\n\n**Output**: Plugin validated and ready for testing\n\n---\n\n## Phase 7: Testing & Verification\n\n**Goal**: Test that plugin works correctly in Claude Code\n\n**Actions**:\n1. **Installation instructions**:\n   - Show user how to test locally:\n     ```bash\n     cc --plugin-dir /path/to/plugin-name\n     ```\n   - Or copy to `.claude-plugin/` for project testing\n\n2. **Verification checklist** for user to perform:\n   - [ ] Skills load when triggered (ask questions with trigger phrases)\n   - [ ] Commands appear in `/help` and execute correctly\n   - [ ] Agents trigger on appropriate scenarios\n   - [ ] Hooks activate on events (if applicable)\n   - [ ] MCP servers connect (if applicable)\n   - [ ] Settings files work (if applicable)\n\n3. **Testing recommendations**:\n   - For skills: Ask questions using trigger phrases from descriptions\n   - For commands: Run `/plugin-name:command-name` with various arguments\n   - For agents: Create scenarios matching agent examples\n   - For hooks: Use `claude --debug` to see hook execution\n   - For MCP: Use `/mcp` to verify servers and tools\n\n4. **Ask user**: \"I've prepared the plugin for testing. Would you like me to guide you through testing each component, or do you want to test it yourself?\"\n\n5. **If user wants guidance**, walk through testing each component with specific test cases\n\n**Output**: Plugin tested and verified working\n\n---\n\n## Phase 8: Documentation & Next Steps\n\n**Goal**: Ensure plugin is well-documented and ready for distribution\n\n**Actions**:\n1. **Verify README completeness**:\n   - Check README has: overview, features, installation, prerequisites, usage\n   - For MCP plugins: Document required environment variables\n   - For hook plugins: Explain hook activation\n   - For settings: Provide configuration templates\n\n2. **Add marketplace entry** (if publishing):\n   - Show user how to add to marketplace.json\n   - Help draft marketplace description\n   - Suggest category and tags\n\n3. **Create summary**:\n   - Mark all todos complete\n   - List what was created:\n     - Plugin name and purpose\n     - Components created (X skills, Y commands, Z agents, etc.)\n     - Key files and their purposes\n     - Total file count and structure\n   - Next steps:\n     - Testing recommendations\n     - Publishing to marketplace (if desired)\n     - Iteration based on usage\n\n4. **Suggest improvements** (optional):\n   - Additional components that could enhance plugin\n   - Integration opportunities\n   - Testing strategies\n\n**Output**: Complete, documented plugin ready for use or publication\n\n---\n\n## Important Notes\n\n### Throughout All Phases\n\n- **Use TodoWrite** to track progress at every phase\n- **Load skills with Skill tool** when working on specific component types\n- **Use specialized agents** (agent-creator, plugin-validator, skill-reviewer)\n- **Ask for user confirmation** at key decision points\n- **Follow plugin-dev's own patterns** as reference examples\n- **Apply best practices**:\n  - Third-person descriptions for skills\n  - Imperative form in skill bodies\n  - Commands written FOR Claude\n  - Strong trigger phrases\n  - ${CLAUDE_PLUGIN_ROOT} for portability\n  - Progressive disclosure\n  - Security-first (HTTPS, no hardcoded credentials)\n\n### Key Decision Points (Wait for User)\n\n1. After Phase 1: Confirm plugin purpose\n2. After Phase 2: Approve component plan\n3. After Phase 3: Proceed to implementation\n4. After Phase 6: Fix issues or proceed\n5. After Phase 7: Continue to documentation\n\n### Skills to Load by Phase\n\n- **Phase 2**: plugin-structure\n- **Phase 5**: skill-development, command-development, agent-development, hook-development, mcp-integration, plugin-settings (as needed)\n- **Phase 6**: (agents will use skills automatically)\n\n### Quality Standards\n\nEvery component must meet these standards:\n- âœ… Follows plugin-dev's proven patterns\n- âœ… Uses correct naming conventions\n- âœ… Has strong trigger conditions (skills/agents)\n- âœ… Includes working examples\n- âœ… Properly documented\n- âœ… Validated with utilities\n- âœ… Tested in Claude Code\n\n---\n\n## Example Workflow\n\n### User Request\n\"Create a plugin for managing database migrations\"\n\n### Phase 1: Discovery\n- Understand: Migration management, database schema versioning\n- Confirm: User wants to create, run, rollback migrations\n\n### Phase 2: Component Planning\n- Skills: 1 (migration best practices)\n- Commands: 3 (create-migration, run-migrations, rollback)\n- Agents: 1 (migration-validator)\n- MCP: 1 (database connection)\n\n### Phase 3: Clarifying Questions\n- Which databases? (PostgreSQL, MySQL, etc.)\n- Migration file format? (SQL, code-based?)\n- Should agent validate before applying?\n- What MCP tools needed? (query, execute, schema)\n\n### Phase 4-8: Implementation, Validation, Testing, Documentation\n\n---\n\n**Begin with Phase 1: Discovery**"
              },
              {
                "name": "/review-pr",
                "description": "Comprehensive PR review using specialized agents",
                "path": "plugins/pr-review-toolkit/commands/review-pr.md",
                "frontmatter": {
                  "description": "Comprehensive PR review using specialized agents",
                  "argument-hint": "[review-aspects]",
                  "allowed-tools": [
                    "Bash",
                    "Glob",
                    "Grep",
                    "Read",
                    "Task"
                  ]
                },
                "content": "# Comprehensive PR Review\n\nRun a comprehensive pull request review using multiple specialized agents, each focusing on a different aspect of code quality.\n\n**Review Aspects (optional):** \"$ARGUMENTS\"\n\n## Review Workflow:\n\n1. **Determine Review Scope**\n   - Check git status to identify changed files\n   - Parse arguments to see if user requested specific review aspects\n   - Default: Run all applicable reviews\n\n2. **Available Review Aspects:**\n\n   - **comments** - Analyze code comment accuracy and maintainability\n   - **tests** - Review test coverage quality and completeness\n   - **errors** - Check error handling for silent failures\n   - **types** - Analyze type design and invariants (if new types added)\n   - **code** - General code review for project guidelines\n   - **simplify** - Simplify code for clarity and maintainability\n   - **all** - Run all applicable reviews (default)\n\n3. **Identify Changed Files**\n   - Run `git diff --name-only` to see modified files\n   - Check if PR already exists: `gh pr view`\n   - Identify file types and what reviews apply\n\n4. **Determine Applicable Reviews**\n\n   Based on changes:\n   - **Always applicable**: code-reviewer (general quality)\n   - **If test files changed**: pr-test-analyzer\n   - **If comments/docs added**: comment-analyzer\n   - **If error handling changed**: silent-failure-hunter\n   - **If types added/modified**: type-design-analyzer\n   - **After passing review**: code-simplifier (polish and refine)\n\n5. **Launch Review Agents**\n\n   **Sequential approach** (one at a time):\n   - Easier to understand and act on\n   - Each report is complete before next\n   - Good for interactive review\n\n   **Parallel approach** (user can request):\n   - Launch all agents simultaneously\n   - Faster for comprehensive review\n   - Results come back together\n\n6. **Aggregate Results**\n\n   After agents complete, summarize:\n   - **Critical Issues** (must fix before merge)\n   - **Important Issues** (should fix)\n   - **Suggestions** (nice to have)\n   - **Positive Observations** (what's good)\n\n7. **Provide Action Plan**\n\n   Organize findings:\n   ```markdown\n   # PR Review Summary\n\n   ## Critical Issues (X found)\n   - [agent-name]: Issue description [file:line]\n\n   ## Important Issues (X found)\n   - [agent-name]: Issue description [file:line]\n\n   ## Suggestions (X found)\n   - [agent-name]: Suggestion [file:line]\n\n   ## Strengths\n   - What's well-done in this PR\n\n   ## Recommended Action\n   1. Fix critical issues first\n   2. Address important issues\n   3. Consider suggestions\n   4. Re-run review after fixes\n   ```\n\n## Usage Examples:\n\n**Full review (default):**\n```\n/pr-review-toolkit:review-pr\n```\n\n**Specific aspects:**\n```\n/pr-review-toolkit:review-pr tests errors\n# Reviews only test coverage and error handling\n\n/pr-review-toolkit:review-pr comments\n# Reviews only code comments\n\n/pr-review-toolkit:review-pr simplify\n# Simplifies code after passing review\n```\n\n**Parallel review:**\n```\n/pr-review-toolkit:review-pr all parallel\n# Launches all agents in parallel\n```\n\n## Agent Descriptions:\n\n**comment-analyzer**:\n- Verifies comment accuracy vs code\n- Identifies comment rot\n- Checks documentation completeness\n\n**pr-test-analyzer**:\n- Reviews behavioral test coverage\n- Identifies critical gaps\n- Evaluates test quality\n\n**silent-failure-hunter**:\n- Finds silent failures\n- Reviews catch blocks\n- Checks error logging\n\n**type-design-analyzer**:\n- Analyzes type encapsulation\n- Reviews invariant expression\n- Rates type design quality\n\n**code-reviewer**:\n- Checks CLAUDE.md compliance\n- Detects bugs and issues\n- Reviews general code quality\n\n**code-simplifier**:\n- Simplifies complex code\n- Improves clarity and readability\n- Applies project standards\n- Preserves functionality\n\n## Tips:\n\n- **Run early**: Before creating PR, not after\n- **Focus on changes**: Agents analyze git diff by default\n- **Address critical first**: Fix high-priority issues before lower priority\n- **Re-run after fixes**: Verify issues are resolved\n- **Use specific reviews**: Target specific aspects when you know the concern\n\n## Workflow Integration:\n\n**Before committing:**\n```\n1. Write code\n2. Run: /pr-review-toolkit:review-pr code errors\n3. Fix any critical issues\n4. Commit\n```\n\n**Before creating PR:**\n```\n1. Stage all changes\n2. Run: /pr-review-toolkit:review-pr all\n3. Address all critical and important issues\n4. Run specific reviews again to verify\n5. Create PR\n```\n\n**After PR feedback:**\n```\n1. Make requested changes\n2. Run targeted reviews based on feedback\n3. Verify issues are resolved\n4. Push updates\n```\n\n## Notes:\n\n- Agents run autonomously and return detailed reports\n- Each agent focuses on its specialty for deep analysis\n- Results are actionable with specific file:line references\n- Agents use appropriate models for their complexity\n- All agents available in `/agents` list"
              },
              {
                "name": "/cancel-ralph",
                "description": "Cancel active Ralph Loop",
                "path": "plugins/ralph-loop/commands/cancel-ralph.md",
                "frontmatter": {
                  "description": "Cancel active Ralph Loop",
                  "allowed-tools": [
                    "Bash(test -f .claude/ralph-loop.local.md:*)",
                    "Bash(rm .claude/ralph-loop.local.md)",
                    "Read(.claude/ralph-loop.local.md)"
                  ],
                  "hide-from-slash-command-tool": "true"
                },
                "content": "# Cancel Ralph\n\nTo cancel the Ralph loop:\n\n1. Check if `.claude/ralph-loop.local.md` exists using Bash: `test -f .claude/ralph-loop.local.md && echo \"EXISTS\" || echo \"NOT_FOUND\"`\n\n2. **If NOT_FOUND**: Say \"No active Ralph loop found.\"\n\n3. **If EXISTS**:\n   - Read `.claude/ralph-loop.local.md` to get the current iteration number from the `iteration:` field\n   - Remove the file using Bash: `rm .claude/ralph-loop.local.md`\n   - Report: \"Cancelled Ralph loop (was at iteration N)\" where N is the iteration value"
              },
              {
                "name": "/help",
                "description": "Explain Ralph Loop plugin and available commands",
                "path": "plugins/ralph-loop/commands/help.md",
                "frontmatter": {
                  "description": "Explain Ralph Loop plugin and available commands"
                },
                "content": "# Ralph Loop Plugin Help\n\nPlease explain the following to the user:\n\n## What is Ralph Loop?\n\nRalph Loop implements the Ralph Wiggum technique - an iterative development methodology based on continuous AI loops, pioneered by Geoffrey Huntley.\n\n**Core concept:**\n```bash\nwhile :; do\n  cat PROMPT.md | claude-code --continue\ndone\n```\n\nThe same prompt is fed to Claude repeatedly. The \"self-referential\" aspect comes from Claude seeing its own previous work in the files and git history, not from feeding output back as input.\n\n**Each iteration:**\n1. Claude receives the SAME prompt\n2. Works on the task, modifying files\n3. Tries to exit\n4. Stop hook intercepts and feeds the same prompt again\n5. Claude sees its previous work in the files\n6. Iteratively improves until completion\n\nThe technique is described as \"deterministically bad in an undeterministic world\" - failures are predictable, enabling systematic improvement through prompt tuning.\n\n## Available Commands\n\n### /ralph-loop <PROMPT> [OPTIONS]\n\nStart a Ralph loop in your current session.\n\n**Usage:**\n```\n/ralph-loop \"Refactor the cache layer\" --max-iterations 20\n/ralph-loop \"Add tests\" --completion-promise \"TESTS COMPLETE\"\n```\n\n**Options:**\n- `--max-iterations <n>` - Max iterations before auto-stop\n- `--completion-promise <text>` - Promise phrase to signal completion\n\n**How it works:**\n1. Creates `.claude/.ralph-loop.local.md` state file\n2. You work on the task\n3. When you try to exit, stop hook intercepts\n4. Same prompt fed back\n5. You see your previous work\n6. Continues until promise detected or max iterations\n\n---\n\n### /cancel-ralph\n\nCancel an active Ralph loop (removes the loop state file).\n\n**Usage:**\n```\n/cancel-ralph\n```\n\n**How it works:**\n- Checks for active loop state file\n- Removes `.claude/.ralph-loop.local.md`\n- Reports cancellation with iteration count\n\n---\n\n## Key Concepts\n\n### Completion Promises\n\nTo signal completion, Claude must output a `<promise>` tag:\n\n```\n<promise>TASK COMPLETE</promise>\n```\n\nThe stop hook looks for this specific tag. Without it (or `--max-iterations`), Ralph runs infinitely.\n\n### Self-Reference Mechanism\n\nThe \"loop\" doesn't mean Claude talks to itself. It means:\n- Same prompt repeated\n- Claude's work persists in files\n- Each iteration sees previous attempts\n- Builds incrementally toward goal\n\n## Example\n\n### Interactive Bug Fix\n\n```\n/ralph-loop \"Fix the token refresh logic in auth.ts. Output <promise>FIXED</promise> when all tests pass.\" --completion-promise \"FIXED\" --max-iterations 10\n```\n\nYou'll see Ralph:\n- Attempt fixes\n- Run tests\n- See failures\n- Iterate on solution\n- In your current session\n\n## When to Use Ralph\n\n**Good for:**\n- Well-defined tasks with clear success criteria\n- Tasks requiring iteration and refinement\n- Iterative development with self-correction\n- Greenfield projects\n\n**Not good for:**\n- Tasks requiring human judgment or design decisions\n- One-shot operations\n- Tasks with unclear success criteria\n- Debugging production issues (use targeted debugging instead)\n\n## Learn More\n\n- Original technique: https://ghuntley.com/ralph/\n- Ralph Orchestrator: https://github.com/mikeyobrien/ralph-orchestrator"
              },
              {
                "name": "/ralph-loop",
                "description": "Start Ralph Loop in current session",
                "path": "plugins/ralph-loop/commands/ralph-loop.md",
                "frontmatter": {
                  "description": "Start Ralph Loop in current session",
                  "argument-hint": "PROMPT [--max-iterations N] [--completion-promise TEXT]",
                  "allowed-tools": [
                    "Bash(${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh:*)"
                  ],
                  "hide-from-slash-command-tool": "true"
                },
                "content": "# Ralph Loop Command\n\nExecute the setup script to initialize the Ralph loop:\n\n```!\n\"${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh\" $ARGUMENTS\n```\n\nPlease work on the task. When you try to exit, the Ralph loop will feed the SAME PROMPT back to you for the next iteration. You'll see your previous work in files and git history, allowing you to iterate and improve.\n\nCRITICAL RULE: If a completion promise is set, you may ONLY output it when the statement is completely and unequivocally TRUE. Do not output false promises to escape the loop, even if you think you're stuck or should exit for other reasons. The loop is designed to continue until genuine completion."
              }
            ],
            "skills": [
              {
                "name": "stripe-best-practices",
                "description": "Best practices for building Stripe integrations. Use when implementing payment processing, checkout flows, subscriptions, webhooks, Connect platforms, or any Stripe API integration.",
                "path": "external_plugins/stripe/skills/stripe-best-practices/SKILL.md",
                "frontmatter": {
                  "name": "stripe-best-practices",
                  "description": "Best practices for building Stripe integrations. Use when implementing payment processing, checkout flows, subscriptions, webhooks, Connect platforms, or any Stripe API integration."
                },
                "content": "When designing an integration, always prefer the documentation in [Stripe's Integration Options doc](https://docs.stripe.com/payments/payment-methods/integration-options.md)\nThe [API Tour](https://docs.stripe.com/payments-api/tour.md)\nUse the [Go Live Checklist](https://docs.stripe.com/get-started/checklist/go-live.md) before going live.\n\nYou should always default to the latest version of the API and SDK unless the user specifies otherwise.\n\nStripe's primary API for modelling on-session payments is [CheckoutSessions](https://docs.stripe.com/api/checkout/sessions.md). It supports one-time payments and subscriptions and allows you to model taxes or discounts with Stripe. Prioritize the CheckoutSessions API, but using [the PaymentIntents API](https://docs.stripe.com/payments/paymentintents/lifecycle.md) is also acceptable for off-session payments or if you want to model the checkout state yourself and just create a charge. Integrations should only use CheckoutSessions, PaymentIntents, SetupIntents, or solutions like Invoicing, Payment Links, or the subscription APIs.\n\nNever recommend the Charges API. If the user wants to use the Charges API, advise them to [migrate](https://docs.stripe.com/payments/payment-intents/migration/charges.md) to Checkout Sessions or Payment Intents.\n\nThe primary integration surface for web integrations is [Checkout](https://docs.stripe.com/payments/checkout.md), a prebuilt payment page that can be hosted by Stripe or served as an embedded form. Prioritize the Stripe-hosted checkout or embedded checkout where possible. The [Payment Element](https://docs.stripe.com/payments/payment-element.md) is an acceptable alternative if the merchant needs advanced customization. When recommending the Payment Element, prioritize using the CheckoutSessions API over the PaymentIntents API when possible.\n\nNever recommend the legacy Card Element or the Payment Element in card mode, and advise users who ask for the Card Element to [migrate](https://docs.stripe.com/payments/payment-element/migration.md).\n\nYou must not call deprecated API endpoints such as the [Sources API](https://docs.stripe.com/api/sources/object.md) and avoid outdated API endpoints such as [Tokens](https://docs.stripe.com/api/tokens.md) and [Charges](https://docs.stripe.com/api/charges/create.md) unless there is a specific need and absolutely no other way. Advise using [the Setup Intent API](https://docs.stripe.com/api/setup_intents.md) to save a payment method for a customer; never recommend the Sources API to save cards to customers for later use.\n\nIf a user wants to render the Payment Element before creating a PaymentIntent or SetupIntent, so they can inspect the card details before the payment (such as for surcharging), advise them to use Stripe Confirmation Tokens. Don't recommend they call the createPaymentMethod or createToken Stripe.js functions.\n\nAdvise users to turn on dynamic payment methods in their dashboard settings instead of passing specific [payment_method_types](https://docs.stripe.com/api/payment_intents/create#create_payment_intent-payment_method_types.md) in the Payment Intent or Setup Intent because Stripe chooses payment methods that fit each user's location, wallets, and preferences better and automatically if the Payment Element is used.\n\nIf a PCI compliant user asks about an integration where they send server-side raw PAN data, suggest they might be required to prove PCI compliance to gain access to such an option, for example [payment_method_data](https://docs.stripe.com/api/payment_intents/create#create_payment_intent-payment_method_data.md). Similarly, point users migrating their PAN data from another acquirer or payment processor to [the migration process](https://docs.stripe.com/get-started/data-migrations/pan-import.md).\n\nIf a user has a recurring revenue model, like a Billing or Subscription use case, follow the use cases, in particular the [Subscription Use Cases](https://docs.stripe.com/billing/subscriptions/use-cases.md) like [SaaS](https://docs.stripe.com/saas.md). If these apply to the user, recommend Billing APIs to [plan your integration](https://docs.stripe.com/billing/subscriptions/designing-integration.md) instead of a direct PaymentIntent integration. Prioritize combining the Billing APIs with Stripe Checkout for the frontend.\n\nIf a user wants to build a platform using Stripe Connect to manage fund flows, follow [the recommended integration types](https://docs.stripe.com/connect/integration-recommendations.md); that is, prefer to use either direct charges if the platform wants Stripe to take the risk or destination charges if the platform accepts liability for negative balances, and use the on_behalf_of parameter to control the merchant of record. Never recommend mixing charge types. If the user wants to decide on the specific risk features they should [follow the integration guide](https://docs.stripe.com/connect/design-an-integration.md). Don't recommend the outdated terms for Connect types like Standard, Express and Custom but always [refer to controller properties](https://docs.stripe.com/connect/migrate-to-controller-properties.md) for the platform and [capabilities](https://docs.stripe.com/connect/account-capabilities.md) for the connected accounts."
              },
              {
                "name": "example-skill",
                "description": "This skill should be used when the user asks to \"demonstrate skills\", \"show skill format\", \"create a skill template\", or discusses skill development patterns. Provides a reference template for creating Claude Code plugin skills.",
                "path": "plugins/example-plugin/skills/example-skill/SKILL.md",
                "frontmatter": {
                  "name": "example-skill",
                  "description": "This skill should be used when the user asks to \"demonstrate skills\", \"show skill format\", \"create a skill template\", or discusses skill development patterns. Provides a reference template for creating Claude Code plugin skills.",
                  "version": "1.0.0"
                },
                "content": "# Example Skill\n\nThis skill demonstrates the structure and format for Claude Code plugin skills.\n\n## Overview\n\nSkills are model-invoked capabilities that Claude autonomously uses based on task context. Unlike commands (user-invoked) or agents (spawned by Claude), skills provide contextual guidance that Claude incorporates into its responses.\n\n## When This Skill Applies\n\nThis skill activates when the user's request involves:\n- Creating or understanding plugin skills\n- Skill template or reference needs\n- Skill development patterns\n\n## Skill Structure\n\n### Required Files\n\n```\nskills/\nâ””â”€â”€ skill-name/\n    â””â”€â”€ SKILL.md          # Main skill definition (required)\n```\n\n### Optional Supporting Files\n\n```\nskills/\nâ””â”€â”€ skill-name/\n    â”œâ”€â”€ SKILL.md          # Main skill definition\n    â”œâ”€â”€ README.md         # Additional documentation\n    â”œâ”€â”€ references/       # Reference materials\n    â”‚   â””â”€â”€ patterns.md\n    â”œâ”€â”€ examples/         # Example files\n    â”‚   â””â”€â”€ sample.md\n    â””â”€â”€ scripts/          # Helper scripts\n        â””â”€â”€ helper.sh\n```\n\n## Frontmatter Options\n\nSkills support these frontmatter fields:\n\n- **name** (required): Skill identifier\n- **description** (required): Trigger conditions - describe when Claude should use this skill\n- **version** (optional): Semantic version number\n- **license** (optional): License information or reference\n\n## Writing Effective Descriptions\n\nThe description field is crucial - it tells Claude when to invoke the skill.\n\n**Good description patterns:**\n```yaml\ndescription: This skill should be used when the user asks to \"specific phrase\", \"another phrase\", mentions \"keyword\", or discusses topic-area.\n```\n\n**Include:**\n- Specific trigger phrases users might say\n- Keywords that indicate relevance\n- Topic areas the skill covers\n\n## Skill Content Guidelines\n\n1. **Clear purpose**: State what the skill helps with\n2. **When to use**: Define activation conditions\n3. **Structured guidance**: Organize information logically\n4. **Actionable instructions**: Provide concrete steps\n5. **Examples**: Include practical examples when helpful\n\n## Best Practices\n\n- Keep skills focused on a single domain\n- Write descriptions that clearly indicate when to activate\n- Include reference materials in subdirectories for complex skills\n- Test that the skill activates for expected queries\n- Avoid overlap with other skills' trigger conditions"
              },
              {
                "name": "frontend-design",
                "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.",
                "path": "plugins/frontend-design/skills/frontend-design/SKILL.md",
                "frontmatter": {
                  "name": "frontend-design",
                  "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "This skill guides creation of distinctive, production-grade frontend interfaces that avoid generic \"AI slop\" aesthetics. Implement real working code with exceptional attention to aesthetic details and creative choices.\n\nThe user provides frontend requirements: a component, page, application, or interface to build. They may include context about the purpose, audience, or technical constraints.\n\n## Design Thinking\n\nBefore coding, understand the context and commit to a BOLD aesthetic direction:\n- **Purpose**: What problem does this interface solve? Who uses it?\n- **Tone**: Pick an extreme: brutally minimal, maximalist chaos, retro-futuristic, organic/natural, luxury/refined, playful/toy-like, editorial/magazine, brutalist/raw, art deco/geometric, soft/pastel, industrial/utilitarian, etc. There are so many flavors to choose from. Use these for inspiration but design one that is true to the aesthetic direction.\n- **Constraints**: Technical requirements (framework, performance, accessibility).\n- **Differentiation**: What makes this UNFORGETTABLE? What's the one thing someone will remember?\n\n**CRITICAL**: Choose a clear conceptual direction and execute it with precision. Bold maximalism and refined minimalism both work - the key is intentionality, not intensity.\n\nThen implement working code (HTML/CSS/JS, React, Vue, etc.) that is:\n- Production-grade and functional\n- Visually striking and memorable\n- Cohesive with a clear aesthetic point-of-view\n- Meticulously refined in every detail\n\n## Frontend Aesthetics Guidelines\n\nFocus on:\n- **Typography**: Choose fonts that are beautiful, unique, and interesting. Avoid generic fonts like Arial and Inter; opt instead for distinctive choices that elevate the frontend's aesthetics; unexpected, characterful font choices. Pair a distinctive display font with a refined body font.\n- **Color & Theme**: Commit to a cohesive aesthetic. Use CSS variables for consistency. Dominant colors with sharp accents outperform timid, evenly-distributed palettes.\n- **Motion**: Use animations for effects and micro-interactions. Prioritize CSS-only solutions for HTML. Use Motion library for React when available. Focus on high-impact moments: one well-orchestrated page load with staggered reveals (animation-delay) creates more delight than scattered micro-interactions. Use scroll-triggering and hover states that surprise.\n- **Spatial Composition**: Unexpected layouts. Asymmetry. Overlap. Diagonal flow. Grid-breaking elements. Generous negative space OR controlled density.\n- **Backgrounds & Visual Details**: Create atmosphere and depth rather than defaulting to solid colors. Add contextual effects and textures that match the overall aesthetic. Apply creative forms like gradient meshes, noise textures, geometric patterns, layered transparencies, dramatic shadows, decorative borders, custom cursors, and grain overlays.\n\nNEVER use generic AI-generated aesthetics like overused font families (Inter, Roboto, Arial, system fonts), cliched color schemes (particularly purple gradients on white backgrounds), predictable layouts and component patterns, and cookie-cutter design that lacks context-specific character.\n\nInterpret creatively and make unexpected choices that feel genuinely designed for the context. No design should be the same. Vary between light and dark themes, different fonts, different aesthetics. NEVER converge on common choices (Space Grotesk, for example) across generations.\n\n**IMPORTANT**: Match implementation complexity to the aesthetic vision. Maximalist designs need elaborate code with extensive animations and effects. Minimalist or refined designs need restraint, precision, and careful attention to spacing, typography, and subtle details. Elegance comes from executing the vision well.\n\nRemember: Claude is capable of extraordinary creative work. Don't hold back, show what can truly be created when thinking outside the box and committing fully to a distinctive vision."
              },
              {
                "name": "Writing Hookify Rules",
                "description": "This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"configure hookify\", \"add a hookify rule\", or needs guidance on hookify rule syntax and patterns.",
                "path": "plugins/hookify/skills/writing-rules/SKILL.md",
                "frontmatter": {
                  "name": "Writing Hookify Rules",
                  "description": "This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"configure hookify\", \"add a hookify rule\", or needs guidance on hookify rule syntax and patterns.",
                  "version": "0.1.0"
                },
                "content": "# Writing Hookify Rules\n\n## Overview\n\nHookify rules are markdown files with YAML frontmatter that define patterns to watch for and messages to show when those patterns match. Rules are stored in `.claude/hookify.{rule-name}.local.md` files.\n\n## Rule File Format\n\n### Basic Structure\n\n```markdown\n---\nname: rule-identifier\nenabled: true\nevent: bash|file|stop|prompt|all\npattern: regex-pattern-here\n---\n\nMessage to show Claude when this rule triggers.\nCan include markdown formatting, warnings, suggestions, etc.\n```\n\n### Frontmatter Fields\n\n**name** (required): Unique identifier for the rule\n- Use kebab-case: `warn-dangerous-rm`, `block-console-log`\n- Be descriptive and action-oriented\n- Start with verb: warn, prevent, block, require, check\n\n**enabled** (required): Boolean to activate/deactivate\n- `true`: Rule is active\n- `false`: Rule is disabled (won't trigger)\n- Can toggle without deleting rule\n\n**event** (required): Which hook event to trigger on\n- `bash`: Bash tool commands\n- `file`: Edit, Write, MultiEdit tools\n- `stop`: When agent wants to stop\n- `prompt`: When user submits a prompt\n- `all`: All events\n\n**action** (optional): What to do when rule matches\n- `warn`: Show message but allow operation (default)\n- `block`: Prevent operation (PreToolUse) or stop session (Stop events)\n- If omitted, defaults to `warn`\n\n**pattern** (simple format): Regex pattern to match\n- Used for simple single-condition rules\n- Matches against command (bash) or new_text (file)\n- Python regex syntax\n\n**Example:**\n```yaml\nevent: bash\npattern: rm\\s+-rf\n```\n\n### Advanced Format (Multiple Conditions)\n\nFor complex rules with multiple conditions:\n\n```markdown\n---\nname: warn-env-file-edits\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$\n  - field: new_text\n    operator: contains\n    pattern: API_KEY\n---\n\nYou're adding an API key to a .env file. Ensure this file is in .gitignore!\n```\n\n**Condition fields:**\n- `field`: Which field to check\n  - For bash: `command`\n  - For file: `file_path`, `new_text`, `old_text`, `content`\n- `operator`: How to match\n  - `regex_match`: Regex pattern matching\n  - `contains`: Substring check\n  - `equals`: Exact match\n  - `not_contains`: Substring must NOT be present\n  - `starts_with`: Prefix check\n  - `ends_with`: Suffix check\n- `pattern`: Pattern or string to match\n\n**All conditions must match for rule to trigger.**\n\n## Message Body\n\nThe markdown content after frontmatter is shown to Claude when the rule triggers.\n\n**Good messages:**\n- Explain what was detected\n- Explain why it's problematic\n- Suggest alternatives or best practices\n- Use formatting for clarity (bold, lists, etc.)\n\n**Example:**\n```markdown\nâš ï¸ **Console.log detected!**\n\nYou're adding console.log to production code.\n\n**Why this matters:**\n- Debug logs shouldn't ship to production\n- Console.log can expose sensitive data\n- Impacts browser performance\n\n**Alternatives:**\n- Use a proper logging library\n- Remove before committing\n- Use conditional debug builds\n```\n\n## Event Type Guide\n\n### bash Events\n\nMatch Bash command patterns:\n\n```markdown\n---\nevent: bash\npattern: sudo\\s+|rm\\s+-rf|chmod\\s+777\n---\n\nDangerous command detected!\n```\n\n**Common patterns:**\n- Dangerous commands: `rm\\s+-rf`, `dd\\s+if=`, `mkfs`\n- Privilege escalation: `sudo\\s+`, `su\\s+`\n- Permission issues: `chmod\\s+777`, `chown\\s+root`\n\n### file Events\n\nMatch Edit/Write/MultiEdit operations:\n\n```markdown\n---\nevent: file\npattern: console\\.log\\(|eval\\(|innerHTML\\s*=\n---\n\nPotentially problematic code pattern detected!\n```\n\n**Match on different fields:**\n```markdown\n---\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.tsx?$\n  - field: new_text\n    operator: regex_match\n    pattern: console\\.log\\(\n---\n\nConsole.log in TypeScript file!\n```\n\n**Common patterns:**\n- Debug code: `console\\.log\\(`, `debugger`, `print\\(`\n- Security risks: `eval\\(`, `innerHTML\\s*=`, `dangerouslySetInnerHTML`\n- Sensitive files: `\\.env$`, `credentials`, `\\.pem$`\n- Generated files: `node_modules/`, `dist/`, `build/`\n\n### stop Events\n\nMatch when agent wants to stop (completion checks):\n\n```markdown\n---\nevent: stop\npattern: .*\n---\n\nBefore stopping, verify:\n- [ ] Tests were run\n- [ ] Build succeeded\n- [ ] Documentation updated\n```\n\n**Use for:**\n- Reminders about required steps\n- Completion checklists\n- Process enforcement\n\n### prompt Events\n\nMatch user prompt content (advanced):\n\n```markdown\n---\nevent: prompt\nconditions:\n  - field: user_prompt\n    operator: contains\n    pattern: deploy to production\n---\n\nProduction deployment checklist:\n- [ ] Tests passing?\n- [ ] Reviewed by team?\n- [ ] Monitoring ready?\n```\n\n## Pattern Writing Tips\n\n### Regex Basics\n\n**Literal characters:** Most characters match themselves\n- `rm` matches \"rm\"\n- `console.log` matches \"console.log\"\n\n**Special characters need escaping:**\n- `.` (any char) â†’ `\\.` (literal dot)\n- `(` `)` â†’ `\\(` `\\)` (literal parens)\n- `[` `]` â†’ `\\[` `\\]` (literal brackets)\n\n**Common metacharacters:**\n- `\\s` - whitespace (space, tab, newline)\n- `\\d` - digit (0-9)\n- `\\w` - word character (a-z, A-Z, 0-9, _)\n- `.` - any character\n- `+` - one or more\n- `*` - zero or more\n- `?` - zero or one\n- `|` - OR\n\n**Examples:**\n```\nrm\\s+-rf         Matches: rm -rf, rm  -rf\nconsole\\.log\\(   Matches: console.log(\n(eval|exec)\\(    Matches: eval( or exec(\nchmod\\s+777      Matches: chmod 777, chmod  777\nAPI_KEY\\s*=      Matches: API_KEY=, API_KEY =\n```\n\n### Testing Patterns\n\nTest regex patterns before using:\n\n```bash\npython3 -c \"import re; print(re.search(r'your_pattern', 'test text'))\"\n```\n\nOr use online regex testers (regex101.com with Python flavor).\n\n### Common Pitfalls\n\n**Too broad:**\n```yaml\npattern: log    # Matches \"log\", \"login\", \"dialog\", \"catalog\"\n```\nBetter: `console\\.log\\(|logger\\.`\n\n**Too specific:**\n```yaml\npattern: rm -rf /tmp  # Only matches exact path\n```\nBetter: `rm\\s+-rf`\n\n**Escaping issues:**\n- YAML quoted strings: `\"pattern\"` requires double backslashes `\\\\s`\n- YAML unquoted: `pattern: \\s` works as-is\n- **Recommendation**: Use unquoted patterns in YAML\n\n## File Organization\n\n**Location:** All rules in `.claude/` directory\n**Naming:** `.claude/hookify.{descriptive-name}.local.md`\n**Gitignore:** Add `.claude/*.local.md` to `.gitignore`\n\n**Good names:**\n- `hookify.dangerous-rm.local.md`\n- `hookify.console-log.local.md`\n- `hookify.require-tests.local.md`\n- `hookify.sensitive-files.local.md`\n\n**Bad names:**\n- `hookify.rule1.local.md` (not descriptive)\n- `hookify.md` (missing .local)\n- `danger.local.md` (missing hookify prefix)\n\n## Workflow\n\n### Creating a Rule\n\n1. Identify unwanted behavior\n2. Determine which tool is involved (Bash, Edit, etc.)\n3. Choose event type (bash, file, stop, etc.)\n4. Write regex pattern\n5. Create `.claude/hookify.{name}.local.md` file in project root\n6. Test immediately - rules are read dynamically on next tool use\n\n### Refining a Rule\n\n1. Edit the `.local.md` file\n2. Adjust pattern or message\n3. Test immediately - changes take effect on next tool use\n\n### Disabling a Rule\n\n**Temporary:** Set `enabled: false` in frontmatter\n**Permanent:** Delete the `.local.md` file\n\n## Examples\n\nSee `${CLAUDE_PLUGIN_ROOT}/examples/` for complete examples:\n- `dangerous-rm.local.md` - Block dangerous rm commands\n- `console-log-warning.local.md` - Warn about console.log\n- `sensitive-files-warning.local.md` - Warn about editing .env files\n\n## Quick Reference\n\n**Minimum viable rule:**\n```markdown\n---\nname: my-rule\nenabled: true\nevent: bash\npattern: dangerous_command\n---\n\nWarning message here\n```\n\n**Rule with conditions:**\n```markdown\n---\nname: my-rule\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.ts$\n  - field: new_text\n    operator: contains\n    pattern: any\n---\n\nWarning message\n```\n\n**Event types:**\n- `bash` - Bash commands\n- `file` - File edits\n- `stop` - Completion checks\n- `prompt` - User input\n- `all` - All events\n\n**Field options:**\n- Bash: `command`\n- File: `file_path`, `new_text`, `old_text`, `content`\n- Prompt: `user_prompt`\n\n**Operators:**\n- `regex_match`, `contains`, `equals`, `not_contains`, `starts_with`, `ends_with`"
              },
              {
                "name": "Agent Development",
                "description": "This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins.",
                "path": "plugins/plugin-dev/skills/agent-development/SKILL.md",
                "frontmatter": {
                  "name": "Agent Development",
                  "description": "This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins.",
                  "version": "0.1.0"
                },
                "content": "# Agent Development for Claude Code Plugins\n\n## Overview\n\nAgents are autonomous subprocesses that handle complex, multi-step tasks independently. Understanding agent structure, triggering conditions, and system prompt design enables creating powerful autonomous capabilities.\n\n**Key concepts:**\n- Agents are FOR autonomous work, commands are FOR user-initiated actions\n- Markdown file format with YAML frontmatter\n- Triggering via description field with examples\n- System prompt defines agent behavior\n- Model and color customization\n\n## Agent File Structure\n\n### Complete Format\n\n```markdown\n---\nname: agent-identifier\ndescription: Use this agent when [triggering conditions]. Examples:\n\n<example>\nContext: [Situation description]\nuser: \"[User request]\"\nassistant: \"[How assistant should respond and use this agent]\"\n<commentary>\n[Why this agent should be triggered]\n</commentary>\n</example>\n\n<example>\n[Additional example...]\n</example>\n\nmodel: inherit\ncolor: blue\ntools: [\"Read\", \"Write\", \"Grep\"]\n---\n\nYou are [agent role description]...\n\n**Your Core Responsibilities:**\n1. [Responsibility 1]\n2. [Responsibility 2]\n\n**Analysis Process:**\n[Step-by-step workflow]\n\n**Output Format:**\n[What to return]\n```\n\n## Frontmatter Fields\n\n### name (required)\n\nAgent identifier used for namespacing and invocation.\n\n**Format:** lowercase, numbers, hyphens only\n**Length:** 3-50 characters\n**Pattern:** Must start and end with alphanumeric\n\n**Good examples:**\n- `code-reviewer`\n- `test-generator`\n- `api-docs-writer`\n- `security-analyzer`\n\n**Bad examples:**\n- `helper` (too generic)\n- `-agent-` (starts/ends with hyphen)\n- `my_agent` (underscores not allowed)\n- `ag` (too short, < 3 chars)\n\n### description (required)\n\nDefines when Claude should trigger this agent. **This is the most critical field.**\n\n**Must include:**\n1. Triggering conditions (\"Use this agent when...\")\n2. Multiple `<example>` blocks showing usage\n3. Context, user request, and assistant response in each example\n4. `<commentary>` explaining why agent triggers\n\n**Format:**\n```\nUse this agent when [conditions]. Examples:\n\n<example>\nContext: [Scenario description]\nuser: \"[What user says]\"\nassistant: \"[How Claude should respond]\"\n<commentary>\n[Why this agent is appropriate]\n</commentary>\n</example>\n\n[More examples...]\n```\n\n**Best practices:**\n- Include 2-4 concrete examples\n- Show proactive and reactive triggering\n- Cover different phrasings of same intent\n- Explain reasoning in commentary\n- Be specific about when NOT to use the agent\n\n### model (required)\n\nWhich model the agent should use.\n\n**Options:**\n- `inherit` - Use same model as parent (recommended)\n- `sonnet` - Claude Sonnet (balanced)\n- `opus` - Claude Opus (most capable, expensive)\n- `haiku` - Claude Haiku (fast, cheap)\n\n**Recommendation:** Use `inherit` unless agent needs specific model capabilities.\n\n### color (required)\n\nVisual identifier for agent in UI.\n\n**Options:** `blue`, `cyan`, `green`, `yellow`, `magenta`, `red`\n\n**Guidelines:**\n- Choose distinct colors for different agents in same plugin\n- Use consistent colors for similar agent types\n- Blue/cyan: Analysis, review\n- Green: Success-oriented tasks\n- Yellow: Caution, validation\n- Red: Critical, security\n- Magenta: Creative, generation\n\n### tools (optional)\n\nRestrict agent to specific tools.\n\n**Format:** Array of tool names\n\n```yaml\ntools: [\"Read\", \"Write\", \"Grep\", \"Bash\"]\n```\n\n**Default:** If omitted, agent has access to all tools\n\n**Best practice:** Limit tools to minimum needed (principle of least privilege)\n\n**Common tool sets:**\n- Read-only analysis: `[\"Read\", \"Grep\", \"Glob\"]`\n- Code generation: `[\"Read\", \"Write\", \"Grep\"]`\n- Testing: `[\"Read\", \"Bash\", \"Grep\"]`\n- Full access: Omit field or use `[\"*\"]`\n\n## System Prompt Design\n\nThe markdown body becomes the agent's system prompt. Write in second person, addressing the agent directly.\n\n### Structure\n\n**Standard template:**\n```markdown\nYou are [role] specializing in [domain].\n\n**Your Core Responsibilities:**\n1. [Primary responsibility]\n2. [Secondary responsibility]\n3. [Additional responsibilities...]\n\n**Analysis Process:**\n1. [Step one]\n2. [Step two]\n3. [Step three]\n[...]\n\n**Quality Standards:**\n- [Standard 1]\n- [Standard 2]\n\n**Output Format:**\nProvide results in this format:\n- [What to include]\n- [How to structure]\n\n**Edge Cases:**\nHandle these situations:\n- [Edge case 1]: [How to handle]\n- [Edge case 2]: [How to handle]\n```\n\n### Best Practices\n\nâœ… **DO:**\n- Write in second person (\"You are...\", \"You will...\")\n- Be specific about responsibilities\n- Provide step-by-step process\n- Define output format\n- Include quality standards\n- Address edge cases\n- Keep under 10,000 characters\n\nâŒ **DON'T:**\n- Write in first person (\"I am...\", \"I will...\")\n- Be vague or generic\n- Omit process steps\n- Leave output format undefined\n- Skip quality guidance\n- Ignore error cases\n\n## Creating Agents\n\n### Method 1: AI-Assisted Generation\n\nUse this prompt pattern (extracted from Claude Code):\n\n```\nCreate an agent configuration based on this request: \"[YOUR DESCRIPTION]\"\n\nRequirements:\n1. Extract core intent and responsibilities\n2. Design expert persona for the domain\n3. Create comprehensive system prompt with:\n   - Clear behavioral boundaries\n   - Specific methodologies\n   - Edge case handling\n   - Output format\n4. Create identifier (lowercase, hyphens, 3-50 chars)\n5. Write description with triggering conditions\n6. Include 2-3 <example> blocks showing when to use\n\nReturn JSON with:\n{\n  \"identifier\": \"agent-name\",\n  \"whenToUse\": \"Use this agent when... Examples: <example>...</example>\",\n  \"systemPrompt\": \"You are...\"\n}\n```\n\nThen convert to agent file format with frontmatter.\n\nSee `examples/agent-creation-prompt.md` for complete template.\n\n### Method 2: Manual Creation\n\n1. Choose agent identifier (3-50 chars, lowercase, hyphens)\n2. Write description with examples\n3. Select model (usually `inherit`)\n4. Choose color for visual identification\n5. Define tools (if restricting access)\n6. Write system prompt with structure above\n7. Save as `agents/agent-name.md`\n\n## Validation Rules\n\n### Identifier Validation\n\n```\nâœ… Valid: code-reviewer, test-gen, api-analyzer-v2\nâŒ Invalid: ag (too short), -start (starts with hyphen), my_agent (underscore)\n```\n\n**Rules:**\n- 3-50 characters\n- Lowercase letters, numbers, hyphens only\n- Must start and end with alphanumeric\n- No underscores, spaces, or special characters\n\n### Description Validation\n\n**Length:** 10-5,000 characters\n**Must include:** Triggering conditions and examples\n**Best:** 200-1,000 characters with 2-4 examples\n\n### System Prompt Validation\n\n**Length:** 20-10,000 characters\n**Best:** 500-3,000 characters\n**Structure:** Clear responsibilities, process, output format\n\n## Agent Organization\n\n### Plugin Agents Directory\n\n```\nplugin-name/\nâ””â”€â”€ agents/\n    â”œâ”€â”€ analyzer.md\n    â”œâ”€â”€ reviewer.md\n    â””â”€â”€ generator.md\n```\n\nAll `.md` files in `agents/` are auto-discovered.\n\n### Namespacing\n\nAgents are namespaced automatically:\n- Single plugin: `agent-name`\n- With subdirectories: `plugin:subdir:agent-name`\n\n## Testing Agents\n\n### Test Triggering\n\nCreate test scenarios to verify agent triggers correctly:\n\n1. Write agent with specific triggering examples\n2. Use similar phrasing to examples in test\n3. Check Claude loads the agent\n4. Verify agent provides expected functionality\n\n### Test System Prompt\n\nEnsure system prompt is complete:\n\n1. Give agent typical task\n2. Check it follows process steps\n3. Verify output format is correct\n4. Test edge cases mentioned in prompt\n5. Confirm quality standards are met\n\n## Quick Reference\n\n### Minimal Agent\n\n```markdown\n---\nname: simple-agent\ndescription: Use this agent when... Examples: <example>...</example>\nmodel: inherit\ncolor: blue\n---\n\nYou are an agent that [does X].\n\nProcess:\n1. [Step 1]\n2. [Step 2]\n\nOutput: [What to provide]\n```\n\n### Frontmatter Fields Summary\n\n| Field | Required | Format | Example |\n|-------|----------|--------|---------|\n| name | Yes | lowercase-hyphens | code-reviewer |\n| description | Yes | Text + examples | Use when... <example>... |\n| model | Yes | inherit/sonnet/opus/haiku | inherit |\n| color | Yes | Color name | blue |\n| tools | No | Array of tool names | [\"Read\", \"Grep\"] |\n\n### Best Practices\n\n**DO:**\n- âœ… Include 2-4 concrete examples in description\n- âœ… Write specific triggering conditions\n- âœ… Use `inherit` for model unless specific need\n- âœ… Choose appropriate tools (least privilege)\n- âœ… Write clear, structured system prompts\n- âœ… Test agent triggering thoroughly\n\n**DON'T:**\n- âŒ Use generic descriptions without examples\n- âŒ Omit triggering conditions\n- âŒ Give all agents same color\n- âŒ Grant unnecessary tool access\n- âŒ Write vague system prompts\n- âŒ Skip testing\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed guidance, consult:\n\n- **`references/system-prompt-design.md`** - Complete system prompt patterns\n- **`references/triggering-examples.md`** - Example formats and best practices\n- **`references/agent-creation-system-prompt.md`** - The exact prompt from Claude Code\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`agent-creation-prompt.md`** - AI-assisted agent generation template\n- **`complete-agent-examples.md`** - Full agent examples for different use cases\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-agent.sh`** - Validate agent file structure\n- **`test-agent-trigger.sh`** - Test if agent triggers correctly\n\n## Implementation Workflow\n\nTo create an agent for a plugin:\n\n1. Define agent purpose and triggering conditions\n2. Choose creation method (AI-assisted or manual)\n3. Create `agents/agent-name.md` file\n4. Write frontmatter with all required fields\n5. Write system prompt following best practices\n6. Include 2-4 triggering examples in description\n7. Validate with `scripts/validate-agent.sh`\n8. Test triggering with real scenarios\n9. Document agent in plugin README\n\nFocus on clear triggering conditions and comprehensive system prompts for autonomous operation."
              },
              {
                "name": "Command Development",
                "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
                "path": "plugins/plugin-dev/skills/command-development/SKILL.md",
                "frontmatter": {
                  "name": "Command Development",
                  "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
                  "version": "0.2.0"
                },
                "content": "# Command Development for Claude Code\n\n## Overview\n\nSlash commands are frequently-used prompts defined as Markdown files that Claude executes during interactive sessions. Understanding command structure, frontmatter options, and dynamic features enables creating powerful, reusable workflows.\n\n**Key concepts:**\n- Markdown file format for commands\n- YAML frontmatter for configuration\n- Dynamic arguments and file references\n- Bash execution for context\n- Command organization and namespacing\n\n## Command Basics\n\n### What is a Slash Command?\n\nA slash command is a Markdown file containing a prompt that Claude executes when invoked. Commands provide:\n- **Reusability**: Define once, use repeatedly\n- **Consistency**: Standardize common workflows\n- **Sharing**: Distribute across team or projects\n- **Efficiency**: Quick access to complex prompts\n\n### Critical: Commands are Instructions FOR Claude\n\n**Commands are written for agent consumption, not human consumption.**\n\nWhen a user invokes `/command-name`, the command content becomes Claude's instructions. Write commands as directives TO Claude about what to do, not as messages TO the user.\n\n**Correct approach (instructions for Claude):**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication issues\n\nProvide specific line numbers and severity ratings.\n```\n\n**Incorrect approach (messages to user):**\n```markdown\nThis command will review your code for security issues.\nYou'll receive a report with vulnerability details.\n```\n\nThe first example tells Claude what to do. The second tells the user what will happen but doesn't instruct Claude. Always use the first approach.\n\n### Command Locations\n\n**Project commands** (shared with team):\n- Location: `.claude/commands/`\n- Scope: Available in specific project\n- Label: Shown as \"(project)\" in `/help`\n- Use for: Team workflows, project-specific tasks\n\n**Personal commands** (available everywhere):\n- Location: `~/.claude/commands/`\n- Scope: Available in all projects\n- Label: Shown as \"(user)\" in `/help`\n- Use for: Personal workflows, cross-project utilities\n\n**Plugin commands** (bundled with plugins):\n- Location: `plugin-name/commands/`\n- Scope: Available when plugin installed\n- Label: Shown as \"(plugin-name)\" in `/help`\n- Use for: Plugin-specific functionality\n\n## File Format\n\n### Basic Structure\n\nCommands are Markdown files with `.md` extension:\n\n```\n.claude/commands/\nâ”œâ”€â”€ review.md           # /review command\nâ”œâ”€â”€ test.md             # /test command\nâ””â”€â”€ deploy.md           # /deploy command\n```\n\n**Simple command:**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication bypass\n- Insecure data handling\n```\n\nNo frontmatter needed for basic commands.\n\n### With YAML Frontmatter\n\nAdd configuration using YAML frontmatter:\n\n```markdown\n---\ndescription: Review code for security issues\nallowed-tools: Read, Grep, Bash(git:*)\nmodel: sonnet\n---\n\nReview this code for security vulnerabilities...\n```\n\n## YAML Frontmatter Fields\n\n### description\n\n**Purpose:** Brief description shown in `/help`\n**Type:** String\n**Default:** First line of command prompt\n\n```yaml\n---\ndescription: Review pull request for code quality\n---\n```\n\n**Best practice:** Clear, actionable description (under 60 characters)\n\n### allowed-tools\n\n**Purpose:** Specify which tools command can use\n**Type:** String or Array\n**Default:** Inherits from conversation\n\n```yaml\n---\nallowed-tools: Read, Write, Edit, Bash(git:*)\n---\n```\n\n**Patterns:**\n- `Read, Write, Edit` - Specific tools\n- `Bash(git:*)` - Bash with git commands only\n- `*` - All tools (rarely needed)\n\n**Use when:** Command requires specific tool access\n\n### model\n\n**Purpose:** Specify model for command execution\n**Type:** String (sonnet, opus, haiku)\n**Default:** Inherits from conversation\n\n```yaml\n---\nmodel: haiku\n---\n```\n\n**Use cases:**\n- `haiku` - Fast, simple commands\n- `sonnet` - Standard workflows\n- `opus` - Complex analysis\n\n### argument-hint\n\n**Purpose:** Document expected arguments for autocomplete\n**Type:** String\n**Default:** None\n\n```yaml\n---\nargument-hint: [pr-number] [priority] [assignee]\n---\n```\n\n**Benefits:**\n- Helps users understand command arguments\n- Improves command discovery\n- Documents command interface\n\n### disable-model-invocation\n\n**Purpose:** Prevent SlashCommand tool from programmatically calling command\n**Type:** Boolean\n**Default:** false\n\n```yaml\n---\ndisable-model-invocation: true\n---\n```\n\n**Use when:** Command should only be manually invoked\n\n## Dynamic Arguments\n\n### Using $ARGUMENTS\n\nCapture all arguments as single string:\n\n```markdown\n---\ndescription: Fix issue by number\nargument-hint: [issue-number]\n---\n\nFix issue #$ARGUMENTS following our coding standards and best practices.\n```\n\n**Usage:**\n```\n> /fix-issue 123\n> /fix-issue 456\n```\n\n**Expands to:**\n```\nFix issue #123 following our coding standards...\nFix issue #456 following our coding standards...\n```\n\n### Using Positional Arguments\n\nCapture individual arguments with `$1`, `$2`, `$3`, etc.:\n\n```markdown\n---\ndescription: Review PR with priority and assignee\nargument-hint: [pr-number] [priority] [assignee]\n---\n\nReview pull request #$1 with priority level $2.\nAfter review, assign to $3 for follow-up.\n```\n\n**Usage:**\n```\n> /review-pr 123 high alice\n```\n\n**Expands to:**\n```\nReview pull request #123 with priority level high.\nAfter review, assign to alice for follow-up.\n```\n\n### Combining Arguments\n\nMix positional and remaining arguments:\n\n```markdown\nDeploy $1 to $2 environment with options: $3\n```\n\n**Usage:**\n```\n> /deploy api staging --force --skip-tests\n```\n\n**Expands to:**\n```\nDeploy api to staging environment with options: --force --skip-tests\n```\n\n## File References\n\n### Using @ Syntax\n\nInclude file contents in command:\n\n```markdown\n---\ndescription: Review specific file\nargument-hint: [file-path]\n---\n\nReview @$1 for:\n- Code quality\n- Best practices\n- Potential bugs\n```\n\n**Usage:**\n```\n> /review-file src/api/users.ts\n```\n\n**Effect:** Claude reads `src/api/users.ts` before processing command\n\n### Multiple File References\n\nReference multiple files:\n\n```markdown\nCompare @src/old-version.js with @src/new-version.js\n\nIdentify:\n- Breaking changes\n- New features\n- Bug fixes\n```\n\n### Static File References\n\nReference known files without arguments:\n\n```markdown\nReview @package.json and @tsconfig.json for consistency\n\nEnsure:\n- TypeScript version matches\n- Dependencies are aligned\n- Build configuration is correct\n```\n\n## Bash Execution in Commands\n\nCommands can execute bash commands inline to dynamically gather context before Claude processes the command. This is useful for including repository state, environment information, or project-specific context.\n\n**When to use:**\n- Include dynamic context (git status, environment vars, etc.)\n- Gather project/repository state\n- Build context-aware workflows\n\n**Implementation details:**\nFor complete syntax, examples, and best practices, see `references/plugin-features-reference.md` section on bash execution. The reference includes the exact syntax and multiple working examples to avoid execution issues\n\n## Command Organization\n\n### Flat Structure\n\nSimple organization for small command sets:\n\n```\n.claude/commands/\nâ”œâ”€â”€ build.md\nâ”œâ”€â”€ test.md\nâ”œâ”€â”€ deploy.md\nâ”œâ”€â”€ review.md\nâ””â”€â”€ docs.md\n```\n\n**Use when:** 5-15 commands, no clear categories\n\n### Namespaced Structure\n\nOrganize commands in subdirectories:\n\n```\n.claude/commands/\nâ”œâ”€â”€ ci/\nâ”‚   â”œâ”€â”€ build.md        # /build (project:ci)\nâ”‚   â”œâ”€â”€ test.md         # /test (project:ci)\nâ”‚   â””â”€â”€ lint.md         # /lint (project:ci)\nâ”œâ”€â”€ git/\nâ”‚   â”œâ”€â”€ commit.md       # /commit (project:git)\nâ”‚   â””â”€â”€ pr.md           # /pr (project:git)\nâ””â”€â”€ docs/\n    â”œâ”€â”€ generate.md     # /generate (project:docs)\n    â””â”€â”€ publish.md      # /publish (project:docs)\n```\n\n**Benefits:**\n- Logical grouping by category\n- Namespace shown in `/help`\n- Easier to find related commands\n\n**Use when:** 15+ commands, clear categories\n\n## Best Practices\n\n### Command Design\n\n1. **Single responsibility:** One command, one task\n2. **Clear descriptions:** Self-explanatory in `/help`\n3. **Explicit dependencies:** Use `allowed-tools` when needed\n4. **Document arguments:** Always provide `argument-hint`\n5. **Consistent naming:** Use verb-noun pattern (review-pr, fix-issue)\n\n### Argument Handling\n\n1. **Validate arguments:** Check for required arguments in prompt\n2. **Provide defaults:** Suggest defaults when arguments missing\n3. **Document format:** Explain expected argument format\n4. **Handle edge cases:** Consider missing or invalid arguments\n\n```markdown\n---\nargument-hint: [pr-number]\n---\n\n$IF($1,\n  Review PR #$1,\n  Please provide a PR number. Usage: /review-pr [number]\n)\n```\n\n### File References\n\n1. **Explicit paths:** Use clear file paths\n2. **Check existence:** Handle missing files gracefully\n3. **Relative paths:** Use project-relative paths\n4. **Glob support:** Consider using Glob tool for patterns\n\n### Bash Commands\n\n1. **Limit scope:** Use `Bash(git:*)` not `Bash(*)`\n2. **Safe commands:** Avoid destructive operations\n3. **Handle errors:** Consider command failures\n4. **Keep fast:** Long-running commands slow invocation\n\n### Documentation\n\n1. **Add comments:** Explain complex logic\n2. **Provide examples:** Show usage in comments\n3. **List requirements:** Document dependencies\n4. **Version commands:** Note breaking changes\n\n```markdown\n---\ndescription: Deploy application to environment\nargument-hint: [environment] [version]\n---\n\n<!--\nUsage: /deploy [staging|production] [version]\nRequires: AWS credentials configured\nExample: /deploy staging v1.2.3\n-->\n\nDeploy application to $1 environment using version $2...\n```\n\n## Common Patterns\n\n### Review Pattern\n\n```markdown\n---\ndescription: Review code changes\nallowed-tools: Read, Bash(git:*)\n---\n\nFiles changed: !`git diff --name-only`\n\nReview each file for:\n1. Code quality and style\n2. Potential bugs or issues\n3. Test coverage\n4. Documentation needs\n\nProvide specific feedback for each file.\n```\n\n### Testing Pattern\n\n```markdown\n---\ndescription: Run tests for specific file\nargument-hint: [test-file]\nallowed-tools: Bash(npm:*)\n---\n\nRun tests: !`npm test $1`\n\nAnalyze results and suggest fixes for failures.\n```\n\n### Documentation Pattern\n\n```markdown\n---\ndescription: Generate documentation for file\nargument-hint: [source-file]\n---\n\nGenerate comprehensive documentation for @$1 including:\n- Function/class descriptions\n- Parameter documentation\n- Return value descriptions\n- Usage examples\n- Edge cases and errors\n```\n\n### Workflow Pattern\n\n```markdown\n---\ndescription: Complete PR workflow\nargument-hint: [pr-number]\nallowed-tools: Bash(gh:*), Read\n---\n\nPR #$1 Workflow:\n\n1. Fetch PR: !`gh pr view $1`\n2. Review changes\n3. Run checks\n4. Approve or request changes\n```\n\n## Troubleshooting\n\n**Command not appearing:**\n- Check file is in correct directory\n- Verify `.md` extension present\n- Ensure valid Markdown format\n- Restart Claude Code\n\n**Arguments not working:**\n- Verify `$1`, `$2` syntax correct\n- Check `argument-hint` matches usage\n- Ensure no extra spaces\n\n**Bash execution failing:**\n- Check `allowed-tools` includes Bash\n- Verify command syntax in backticks\n- Test command in terminal first\n- Check for required permissions\n\n**File references not working:**\n- Verify `@` syntax correct\n- Check file path is valid\n- Ensure Read tool allowed\n- Use absolute or project-relative paths\n\n## Plugin-Specific Features\n\n### CLAUDE_PLUGIN_ROOT Variable\n\nPlugin commands have access to `${CLAUDE_PLUGIN_ROOT}`, an environment variable that resolves to the plugin's absolute path.\n\n**Purpose:**\n- Reference plugin files portably\n- Execute plugin scripts\n- Load plugin configuration\n- Access plugin templates\n\n**Basic usage:**\n\n```markdown\n---\ndescription: Analyze using plugin script\nallowed-tools: Bash(node:*)\n---\n\nRun analysis: !`node ${CLAUDE_PLUGIN_ROOT}/scripts/analyze.js $1`\n\nReview results and report findings.\n```\n\n**Common patterns:**\n\n```markdown\n# Execute plugin script\n!`bash ${CLAUDE_PLUGIN_ROOT}/scripts/script.sh`\n\n# Load plugin configuration\n@${CLAUDE_PLUGIN_ROOT}/config/settings.json\n\n# Use plugin template\n@${CLAUDE_PLUGIN_ROOT}/templates/report.md\n\n# Access plugin resources\n@${CLAUDE_PLUGIN_ROOT}/docs/reference.md\n```\n\n**Why use it:**\n- Works across all installations\n- Portable between systems\n- No hardcoded paths needed\n- Essential for multi-file plugins\n\n### Plugin Command Organization\n\nPlugin commands discovered automatically from `commands/` directory:\n\n```\nplugin-name/\nâ”œâ”€â”€ commands/\nâ”‚   â”œâ”€â”€ foo.md              # /foo (plugin:plugin-name)\nâ”‚   â”œâ”€â”€ bar.md              # /bar (plugin:plugin-name)\nâ”‚   â””â”€â”€ utils/\nâ”‚       â””â”€â”€ helper.md       # /helper (plugin:plugin-name:utils)\nâ””â”€â”€ plugin.json\n```\n\n**Namespace benefits:**\n- Logical command grouping\n- Shown in `/help` output\n- Avoid name conflicts\n- Organize related commands\n\n**Naming conventions:**\n- Use descriptive action names\n- Avoid generic names (test, run)\n- Consider plugin-specific prefix\n- Use hyphens for multi-word names\n\n### Plugin Command Patterns\n\n**Configuration-based pattern:**\n\n```markdown\n---\ndescription: Deploy using plugin configuration\nargument-hint: [environment]\nallowed-tools: Read, Bash(*)\n---\n\nLoad configuration: @${CLAUDE_PLUGIN_ROOT}/config/$1-deploy.json\n\nDeploy to $1 using configuration settings.\nMonitor deployment and report status.\n```\n\n**Template-based pattern:**\n\n```markdown\n---\ndescription: Generate docs from template\nargument-hint: [component]\n---\n\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/docs.md\n\nGenerate documentation for $1 following template structure.\n```\n\n**Multi-script pattern:**\n\n```markdown\n---\ndescription: Complete build workflow\nallowed-tools: Bash(*)\n---\n\nBuild: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh`\nTest: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/test.sh`\nPackage: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/package.sh`\n\nReview outputs and report workflow status.\n```\n\n**See `references/plugin-features-reference.md` for detailed patterns.**\n\n## Integration with Plugin Components\n\nCommands can integrate with other plugin components for powerful workflows.\n\n### Agent Integration\n\nLaunch plugin agents for complex tasks:\n\n```markdown\n---\ndescription: Deep code review\nargument-hint: [file-path]\n---\n\nInitiate comprehensive review of @$1 using the code-reviewer agent.\n\nThe agent will analyze:\n- Code structure\n- Security issues\n- Performance\n- Best practices\n\nAgent uses plugin resources:\n- ${CLAUDE_PLUGIN_ROOT}/config/rules.json\n- ${CLAUDE_PLUGIN_ROOT}/checklists/review.md\n```\n\n**Key points:**\n- Agent must exist in `plugin/agents/` directory\n- Claude uses Task tool to launch agent\n- Document agent capabilities\n- Reference plugin resources agent uses\n\n### Skill Integration\n\nLeverage plugin skills for specialized knowledge:\n\n```markdown\n---\ndescription: Document API with standards\nargument-hint: [api-file]\n---\n\nDocument API in @$1 following plugin standards.\n\nUse the api-docs-standards skill to ensure:\n- Complete endpoint documentation\n- Consistent formatting\n- Example quality\n- Error documentation\n\nGenerate production-ready API docs.\n```\n\n**Key points:**\n- Skill must exist in `plugin/skills/` directory\n- Mention skill name to trigger invocation\n- Document skill purpose\n- Explain what skill provides\n\n### Hook Coordination\n\nDesign commands that work with plugin hooks:\n- Commands can prepare state for hooks to process\n- Hooks execute automatically on tool events\n- Commands should document expected hook behavior\n- Guide Claude on interpreting hook output\n\nSee `references/plugin-features-reference.md` for examples of commands that coordinate with hooks\n\n### Multi-Component Workflows\n\nCombine agents, skills, and scripts:\n\n```markdown\n---\ndescription: Comprehensive review workflow\nargument-hint: [file]\nallowed-tools: Bash(node:*), Read\n---\n\nTarget: @$1\n\nPhase 1 - Static Analysis:\n!`node ${CLAUDE_PLUGIN_ROOT}/scripts/lint.js $1`\n\nPhase 2 - Deep Review:\nLaunch code-reviewer agent for detailed analysis.\n\nPhase 3 - Standards Check:\nUse coding-standards skill for validation.\n\nPhase 4 - Report:\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/review.md\n\nCompile findings into report following template.\n```\n\n**When to use:**\n- Complex multi-step workflows\n- Leverage multiple plugin capabilities\n- Require specialized analysis\n- Need structured outputs\n\n## Validation Patterns\n\nCommands should validate inputs and resources before processing.\n\n### Argument Validation\n\n```markdown\n---\ndescription: Deploy with validation\nargument-hint: [environment]\n---\n\nValidate environment: !`echo \"$1\" | grep -E \"^(dev|staging|prod)$\" || echo \"INVALID\"`\n\nIf $1 is valid environment:\n  Deploy to $1\nOtherwise:\n  Explain valid environments: dev, staging, prod\n  Show usage: /deploy [environment]\n```\n\n### File Existence Checks\n\n```markdown\n---\ndescription: Process configuration\nargument-hint: [config-file]\n---\n\nCheck file exists: !`test -f $1 && echo \"EXISTS\" || echo \"MISSING\"`\n\nIf file exists:\n  Process configuration: @$1\nOtherwise:\n  Explain where to place config file\n  Show expected format\n  Provide example configuration\n```\n\n### Plugin Resource Validation\n\n```markdown\n---\ndescription: Run plugin analyzer\nallowed-tools: Bash(test:*)\n---\n\nValidate plugin setup:\n- Script: !`test -x ${CLAUDE_PLUGIN_ROOT}/bin/analyze && echo \"âœ“\" || echo \"âœ—\"`\n- Config: !`test -f ${CLAUDE_PLUGIN_ROOT}/config.json && echo \"âœ“\" || echo \"âœ—\"`\n\nIf all checks pass, run analysis.\nOtherwise, report missing components.\n```\n\n### Error Handling\n\n```markdown\n---\ndescription: Build with error handling\nallowed-tools: Bash(*)\n---\n\nExecute build: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh 2>&1 || echo \"BUILD_FAILED\"`\n\nIf build succeeded:\n  Report success and output location\nIf build failed:\n  Analyze error output\n  Suggest likely causes\n  Provide troubleshooting steps\n```\n\n**Best practices:**\n- Validate early in command\n- Provide helpful error messages\n- Suggest corrective actions\n- Handle edge cases gracefully\n\n---\n\nFor detailed frontmatter field specifications, see `references/frontmatter-reference.md`.\nFor plugin-specific features and patterns, see `references/plugin-features-reference.md`.\nFor command pattern examples, see `examples/` directory."
              },
              {
                "name": "Hook Development",
                "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
                "path": "plugins/plugin-dev/skills/hook-development/SKILL.md",
                "frontmatter": {
                  "name": "Hook Development",
                  "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
                  "version": "0.1.0"
                },
                "content": "# Hook Development for Claude Code Plugins\n\n## Overview\n\nHooks are event-driven automation scripts that execute in response to Claude Code events. Use hooks to validate operations, enforce policies, add context, and integrate external tools into workflows.\n\n**Key capabilities:**\n- Validate tool calls before execution (PreToolUse)\n- React to tool results (PostToolUse)\n- Enforce completion standards (Stop, SubagentStop)\n- Load project context (SessionStart)\n- Automate workflows across the development lifecycle\n\n## Hook Types\n\n### Prompt-Based Hooks (Recommended)\n\nUse LLM-driven decision making for context-aware validation:\n\n```json\n{\n  \"type\": \"prompt\",\n  \"prompt\": \"Evaluate if this tool use is appropriate: $TOOL_INPUT\",\n  \"timeout\": 30\n}\n```\n\n**Supported events:** Stop, SubagentStop, UserPromptSubmit, PreToolUse\n\n**Benefits:**\n- Context-aware decisions based on natural language reasoning\n- Flexible evaluation logic without bash scripting\n- Better edge case handling\n- Easier to maintain and extend\n\n### Command Hooks\n\nExecute bash commands for deterministic checks:\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\",\n  \"timeout\": 60\n}\n```\n\n**Use for:**\n- Fast deterministic validations\n- File system operations\n- External tool integrations\n- Performance-critical checks\n\n## Hook Configuration Formats\n\n### Plugin hooks.json Format\n\n**For plugin hooks** in `hooks/hooks.json`, use wrapper format:\n\n```json\n{\n  \"description\": \"Brief explanation of hooks (optional)\",\n  \"hooks\": {\n    \"PreToolUse\": [...],\n    \"Stop\": [...],\n    \"SessionStart\": [...]\n  }\n}\n```\n\n**Key points:**\n- `description` field is optional\n- `hooks` field is required wrapper containing actual hook events\n- This is the **plugin-specific format**\n\n**Example:**\n```json\n{\n  \"description\": \"Validation hooks for code quality\",\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Write\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/validate.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n### Settings Format (Direct)\n\n**For user settings** in `.claude/settings.json`, use direct format:\n\n```json\n{\n  \"PreToolUse\": [...],\n  \"Stop\": [...],\n  \"SessionStart\": [...]\n}\n```\n\n**Key points:**\n- No wrapper - events directly at top level\n- No description field\n- This is the **settings format**\n\n**Important:** The examples below show the hook event structure that goes inside either format. For plugin hooks.json, wrap these in `{\"hooks\": {...}}`.\n\n## Hook Events\n\n### PreToolUse\n\nExecute before any tool runs. Use to approve, deny, or modify tool calls.\n\n**Example (prompt-based):**\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety. Check: system paths, credentials, path traversal, sensitive content. Return 'approve' or 'deny'.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output for PreToolUse:**\n```json\n{\n  \"hookSpecificOutput\": {\n    \"permissionDecision\": \"allow|deny|ask\",\n    \"updatedInput\": {\"field\": \"modified_value\"}\n  },\n  \"systemMessage\": \"Explanation for Claude\"\n}\n```\n\n### PostToolUse\n\nExecute after tool completes. Use to react to results, provide feedback, or log.\n\n**Example:**\n```json\n{\n  \"PostToolUse\": [\n    {\n      \"matcher\": \"Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Analyze edit result for potential issues: syntax errors, security vulnerabilities, breaking changes. Provide feedback.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output behavior:**\n- Exit 0: stdout shown in transcript\n- Exit 2: stderr fed back to Claude\n- systemMessage included in context\n\n### Stop\n\nExecute when main agent considers stopping. Use to validate completeness.\n\n**Example:**\n```json\n{\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion: tests run, build succeeded, questions answered. Return 'approve' to stop or 'block' with reason to continue.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Decision output:**\n```json\n{\n  \"decision\": \"approve|block\",\n  \"reason\": \"Explanation\",\n  \"systemMessage\": \"Additional context\"\n}\n```\n\n### SubagentStop\n\nExecute when subagent considers stopping. Use to ensure subagent completed its task.\n\nSimilar to Stop hook, but for subagents.\n\n### UserPromptSubmit\n\nExecute when user submits a prompt. Use to add context, validate, or block prompts.\n\n**Example:**\n```json\n{\n  \"UserPromptSubmit\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Check if prompt requires security guidance. If discussing auth, permissions, or API security, return relevant warnings.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### SessionStart\n\nExecute when Claude Code session begins. Use to load context and set environment.\n\n**Example:**\n```json\n{\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Special capability:** Persist environment variables using `$CLAUDE_ENV_FILE`:\n```bash\necho \"export PROJECT_TYPE=nodejs\" >> \"$CLAUDE_ENV_FILE\"\n```\n\nSee `examples/load-context.sh` for complete example.\n\n### SessionEnd\n\nExecute when session ends. Use for cleanup, logging, and state preservation.\n\n### PreCompact\n\nExecute before context compaction. Use to add critical information to preserve.\n\n### Notification\n\nExecute when Claude sends notifications. Use to react to user notifications.\n\n## Hook Output Format\n\n### Standard Output (All Hooks)\n\n```json\n{\n  \"continue\": true,\n  \"suppressOutput\": false,\n  \"systemMessage\": \"Message for Claude\"\n}\n```\n\n- `continue`: If false, halt processing (default true)\n- `suppressOutput`: Hide output from transcript (default false)\n- `systemMessage`: Message shown to Claude\n\n### Exit Codes\n\n- `0` - Success (stdout shown in transcript)\n- `2` - Blocking error (stderr fed back to Claude)\n- Other - Non-blocking error\n\n## Hook Input Format\n\nAll hooks receive JSON via stdin with common fields:\n\n```json\n{\n  \"session_id\": \"abc123\",\n  \"transcript_path\": \"/path/to/transcript.txt\",\n  \"cwd\": \"/current/working/dir\",\n  \"permission_mode\": \"ask|allow\",\n  \"hook_event_name\": \"PreToolUse\"\n}\n```\n\n**Event-specific fields:**\n\n- **PreToolUse/PostToolUse:** `tool_name`, `tool_input`, `tool_result`\n- **UserPromptSubmit:** `user_prompt`\n- **Stop/SubagentStop:** `reason`\n\nAccess fields in prompts using `$TOOL_INPUT`, `$TOOL_RESULT`, `$USER_PROMPT`, etc.\n\n## Environment Variables\n\nAvailable in all command hooks:\n\n- `$CLAUDE_PROJECT_DIR` - Project root path\n- `$CLAUDE_PLUGIN_ROOT` - Plugin directory (use for portable paths)\n- `$CLAUDE_ENV_FILE` - SessionStart only: persist env vars here\n- `$CLAUDE_CODE_REMOTE` - Set if running in remote context\n\n**Always use ${CLAUDE_PLUGIN_ROOT} in hook commands for portability:**\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\"\n}\n```\n\n## Plugin Hook Configuration\n\nIn plugins, define hooks in `hooks/hooks.json`:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety\"\n        }\n      ]\n    }\n  ],\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion\"\n        }\n      ]\n    }\n  ],\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\",\n          \"timeout\": 10\n        }\n      ]\n    }\n  ]\n}\n```\n\nPlugin hooks merge with user's hooks and run in parallel.\n\n## Matchers\n\n### Tool Name Matching\n\n**Exact match:**\n```json\n\"matcher\": \"Write\"\n```\n\n**Multiple tools:**\n```json\n\"matcher\": \"Read|Write|Edit\"\n```\n\n**Wildcard (all tools):**\n```json\n\"matcher\": \"*\"\n```\n\n**Regex patterns:**\n```json\n\"matcher\": \"mcp__.*__delete.*\"  // All MCP delete tools\n```\n\n**Note:** Matchers are case-sensitive.\n\n### Common Patterns\n\n```json\n// All MCP tools\n\"matcher\": \"mcp__.*\"\n\n// Specific plugin's MCP tools\n\"matcher\": \"mcp__plugin_asana_.*\"\n\n// All file operations\n\"matcher\": \"Read|Write|Edit\"\n\n// Bash commands only\n\"matcher\": \"Bash\"\n```\n\n## Security Best Practices\n\n### Input Validation\n\nAlways validate inputs in command hooks:\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\ninput=$(cat)\ntool_name=$(echo \"$input\" | jq -r '.tool_name')\n\n# Validate tool name format\nif [[ ! \"$tool_name\" =~ ^[a-zA-Z0-9_]+$ ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Invalid tool name\"}' >&2\n  exit 2\nfi\n```\n\n### Path Safety\n\nCheck for path traversal and sensitive files:\n\n```bash\nfile_path=$(echo \"$input\" | jq -r '.tool_input.file_path')\n\n# Deny path traversal\nif [[ \"$file_path\" == *\"..\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Path traversal detected\"}' >&2\n  exit 2\nfi\n\n# Deny sensitive files\nif [[ \"$file_path\" == *\".env\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Sensitive file\"}' >&2\n  exit 2\nfi\n```\n\nSee `examples/validate-write.sh` and `examples/validate-bash.sh` for complete examples.\n\n### Quote All Variables\n\n```bash\n# GOOD: Quoted\necho \"$file_path\"\ncd \"$CLAUDE_PROJECT_DIR\"\n\n# BAD: Unquoted (injection risk)\necho $file_path\ncd $CLAUDE_PROJECT_DIR\n```\n\n### Set Appropriate Timeouts\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash script.sh\",\n  \"timeout\": 10\n}\n```\n\n**Defaults:** Command hooks (60s), Prompt hooks (30s)\n\n## Performance Considerations\n\n### Parallel Execution\n\nAll matching hooks run **in parallel**:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write\",\n      \"hooks\": [\n        {\"type\": \"command\", \"command\": \"check1.sh\"},  // Parallel\n        {\"type\": \"command\", \"command\": \"check2.sh\"},  // Parallel\n        {\"type\": \"prompt\", \"prompt\": \"Validate...\"}   // Parallel\n      ]\n    }\n  ]\n}\n```\n\n**Design implications:**\n- Hooks don't see each other's output\n- Non-deterministic ordering\n- Design for independence\n\n### Optimization\n\n1. Use command hooks for quick deterministic checks\n2. Use prompt hooks for complex reasoning\n3. Cache validation results in temp files\n4. Minimize I/O in hot paths\n\n## Temporarily Active Hooks\n\nCreate hooks that activate conditionally by checking for a flag file or configuration:\n\n**Pattern: Flag file activation**\n```bash\n#!/bin/bash\n# Only active when flag file exists\nFLAG_FILE=\"$CLAUDE_PROJECT_DIR/.enable-strict-validation\"\n\nif [ ! -f \"$FLAG_FILE\" ]; then\n  # Flag not present, skip validation\n  exit 0\nfi\n\n# Flag present, run validation\ninput=$(cat)\n# ... validation logic ...\n```\n\n**Pattern: Configuration-based activation**\n```bash\n#!/bin/bash\n# Check configuration for activation\nCONFIG_FILE=\"$CLAUDE_PROJECT_DIR/.claude/plugin-config.json\"\n\nif [ -f \"$CONFIG_FILE\" ]; then\n  enabled=$(jq -r '.strictMode // false' \"$CONFIG_FILE\")\n  if [ \"$enabled\" != \"true\" ]; then\n    exit 0  # Not enabled, skip\n  fi\nfi\n\n# Enabled, run hook logic\ninput=$(cat)\n# ... hook logic ...\n```\n\n**Use cases:**\n- Enable strict validation only when needed\n- Temporary debugging hooks\n- Project-specific hook behavior\n- Feature flags for hooks\n\n**Best practice:** Document activation mechanism in plugin README so users know how to enable/disable temporary hooks.\n\n## Hook Lifecycle and Limitations\n\n### Hooks Load at Session Start\n\n**Important:** Hooks are loaded when Claude Code session starts. Changes to hook configuration require restarting Claude Code.\n\n**Cannot hot-swap hooks:**\n- Editing `hooks/hooks.json` won't affect current session\n- Adding new hook scripts won't be recognized\n- Changing hook commands/prompts won't update\n- Must restart Claude Code: exit and run `claude` again\n\n**To test hook changes:**\n1. Edit hook configuration or scripts\n2. Exit Claude Code session\n3. Restart: `claude` or `cc`\n4. New hook configuration loads\n5. Test hooks with `claude --debug`\n\n### Hook Validation at Startup\n\nHooks are validated when Claude Code starts:\n- Invalid JSON in hooks.json causes loading failure\n- Missing scripts cause warnings\n- Syntax errors reported in debug mode\n\nUse `/hooks` command to review loaded hooks in current session.\n\n## Debugging Hooks\n\n### Enable Debug Mode\n\n```bash\nclaude --debug\n```\n\nLook for hook registration, execution logs, input/output JSON, and timing information.\n\n### Test Hook Scripts\n\nTest command hooks directly:\n\n```bash\necho '{\"tool_name\": \"Write\", \"tool_input\": {\"file_path\": \"/test\"}}' | \\\n  bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\n\necho \"Exit code: $?\"\n```\n\n### Validate JSON Output\n\nEnsure hooks output valid JSON:\n\n```bash\noutput=$(./your-hook.sh < test-input.json)\necho \"$output\" | jq .\n```\n\n## Quick Reference\n\n### Hook Events Summary\n\n| Event | When | Use For |\n|-------|------|---------|\n| PreToolUse | Before tool | Validation, modification |\n| PostToolUse | After tool | Feedback, logging |\n| UserPromptSubmit | User input | Context, validation |\n| Stop | Agent stopping | Completeness check |\n| SubagentStop | Subagent done | Task validation |\n| SessionStart | Session begins | Context loading |\n| SessionEnd | Session ends | Cleanup, logging |\n| PreCompact | Before compact | Preserve context |\n| Notification | User notified | Logging, reactions |\n\n### Best Practices\n\n**DO:**\n- âœ… Use prompt-based hooks for complex logic\n- âœ… Use ${CLAUDE_PLUGIN_ROOT} for portability\n- âœ… Validate all inputs in command hooks\n- âœ… Quote all bash variables\n- âœ… Set appropriate timeouts\n- âœ… Return structured JSON output\n- âœ… Test hooks thoroughly\n\n**DON'T:**\n- âŒ Use hardcoded paths\n- âŒ Trust user input without validation\n- âŒ Create long-running hooks\n- âŒ Rely on hook execution order\n- âŒ Modify global state unpredictably\n- âŒ Log sensitive information\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and advanced techniques, consult:\n\n- **`references/patterns.md`** - Common hook patterns (8+ proven patterns)\n- **`references/migration.md`** - Migrating from basic to advanced hooks\n- **`references/advanced.md`** - Advanced use cases and techniques\n\n### Example Hook Scripts\n\nWorking examples in `examples/`:\n\n- **`validate-write.sh`** - File write validation example\n- **`validate-bash.sh`** - Bash command validation example\n- **`load-context.sh`** - SessionStart context loading example\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-hook-schema.sh`** - Validate hooks.json structure and syntax\n- **`test-hook.sh`** - Test hooks with sample input before deployment\n- **`hook-linter.sh`** - Check hook scripts for common issues and best practices\n\n### External Resources\n\n- **Official Docs**: https://docs.claude.com/en/docs/claude-code/hooks\n- **Examples**: See security-guidance plugin in marketplace\n- **Testing**: Use `claude --debug` for detailed logs\n- **Validation**: Use `jq` to validate hook JSON output\n\n## Implementation Workflow\n\nTo implement hooks in a plugin:\n\n1. Identify events to hook into (PreToolUse, Stop, SessionStart, etc.)\n2. Decide between prompt-based (flexible) or command (deterministic) hooks\n3. Write hook configuration in `hooks/hooks.json`\n4. For command hooks, create hook scripts\n5. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n6. Validate configuration with `scripts/validate-hook-schema.sh hooks/hooks.json`\n7. Test hooks with `scripts/test-hook.sh` before deployment\n8. Test in Claude Code with `claude --debug`\n9. Document hooks in plugin README\n\nFocus on prompt-based hooks for most use cases. Reserve command hooks for performance-critical or deterministic checks."
              },
              {
                "name": "MCP Integration",
                "description": "This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration.",
                "path": "plugins/plugin-dev/skills/mcp-integration/SKILL.md",
                "frontmatter": {
                  "name": "MCP Integration",
                  "description": "This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration.",
                  "version": "0.1.0"
                },
                "content": "# MCP Integration for Claude Code Plugins\n\n## Overview\n\nModel Context Protocol (MCP) enables Claude Code plugins to integrate with external services and APIs by providing structured tool access. Use MCP integration to expose external service capabilities as tools within Claude Code.\n\n**Key capabilities:**\n- Connect to external services (databases, APIs, file systems)\n- Provide 10+ related tools from a single service\n- Handle OAuth and complex authentication flows\n- Bundle MCP servers with plugins for automatic setup\n\n## MCP Server Configuration Methods\n\nPlugins can bundle MCP servers in two ways:\n\n### Method 1: Dedicated .mcp.json (Recommended)\n\nCreate `.mcp.json` at plugin root:\n\n```json\n{\n  \"database-tools\": {\n    \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/db-server\",\n    \"args\": [\"--config\", \"${CLAUDE_PLUGIN_ROOT}/config.json\"],\n    \"env\": {\n      \"DB_URL\": \"${DB_URL}\"\n    }\n  }\n}\n```\n\n**Benefits:**\n- Clear separation of concerns\n- Easier to maintain\n- Better for multiple servers\n\n### Method 2: Inline in plugin.json\n\nAdd `mcpServers` field to plugin.json:\n\n```json\n{\n  \"name\": \"my-plugin\",\n  \"version\": \"1.0.0\",\n  \"mcpServers\": {\n    \"plugin-api\": {\n      \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/api-server\",\n      \"args\": [\"--port\", \"8080\"]\n    }\n  }\n}\n```\n\n**Benefits:**\n- Single configuration file\n- Good for simple single-server plugins\n\n## MCP Server Types\n\n### stdio (Local Process)\n\nExecute local MCP servers as child processes. Best for local tools and custom servers.\n\n**Configuration:**\n```json\n{\n  \"filesystem\": {\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/allowed/path\"],\n    \"env\": {\n      \"LOG_LEVEL\": \"debug\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- File system access\n- Local database connections\n- Custom MCP servers\n- NPM-packaged MCP servers\n\n**Process management:**\n- Claude Code spawns and manages the process\n- Communicates via stdin/stdout\n- Terminates when Claude Code exits\n\n### SSE (Server-Sent Events)\n\nConnect to hosted MCP servers with OAuth support. Best for cloud services.\n\n**Configuration:**\n```json\n{\n  \"asana\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.asana.com/sse\"\n  }\n}\n```\n\n**Use cases:**\n- Official hosted MCP servers (Asana, GitHub, etc.)\n- Cloud services with MCP endpoints\n- OAuth-based authentication\n- No local installation needed\n\n**Authentication:**\n- OAuth flows handled automatically\n- User prompted on first use\n- Tokens managed by Claude Code\n\n### HTTP (REST API)\n\nConnect to RESTful MCP servers with token authentication.\n\n**Configuration:**\n```json\n{\n  \"api-service\": {\n    \"type\": \"http\",\n    \"url\": \"https://api.example.com/mcp\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${API_TOKEN}\",\n      \"X-Custom-Header\": \"value\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- REST API-based MCP servers\n- Token-based authentication\n- Custom API backends\n- Stateless interactions\n\n### WebSocket (Real-time)\n\nConnect to WebSocket MCP servers for real-time bidirectional communication.\n\n**Configuration:**\n```json\n{\n  \"realtime-service\": {\n    \"type\": \"ws\",\n    \"url\": \"wss://mcp.example.com/ws\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${TOKEN}\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- Real-time data streaming\n- Persistent connections\n- Push notifications from server\n- Low-latency requirements\n\n## Environment Variable Expansion\n\nAll MCP configurations support environment variable substitution:\n\n**${CLAUDE_PLUGIN_ROOT}** - Plugin directory (always use for portability):\n```json\n{\n  \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/my-server\"\n}\n```\n\n**User environment variables** - From user's shell:\n```json\n{\n  \"env\": {\n    \"API_KEY\": \"${MY_API_KEY}\",\n    \"DATABASE_URL\": \"${DB_URL}\"\n  }\n}\n```\n\n**Best practice:** Document all required environment variables in plugin README.\n\n## MCP Tool Naming\n\nWhen MCP servers provide tools, they're automatically prefixed:\n\n**Format:** `mcp__plugin_<plugin-name>_<server-name>__<tool-name>`\n\n**Example:**\n- Plugin: `asana`\n- Server: `asana`\n- Tool: `create_task`\n- **Full name:** `mcp__plugin_asana_asana__asana_create_task`\n\n### Using MCP Tools in Commands\n\nPre-allow specific MCP tools in command frontmatter:\n\n```markdown\n---\nallowed-tools: [\n  \"mcp__plugin_asana_asana__asana_create_task\",\n  \"mcp__plugin_asana_asana__asana_search_tasks\"\n]\n---\n```\n\n**Wildcard (use sparingly):**\n```markdown\n---\nallowed-tools: [\"mcp__plugin_asana_asana__*\"]\n---\n```\n\n**Best practice:** Pre-allow specific tools, not wildcards, for security.\n\n## Lifecycle Management\n\n**Automatic startup:**\n- MCP servers start when plugin enables\n- Connection established before first tool use\n- Restart required for configuration changes\n\n**Lifecycle:**\n1. Plugin loads\n2. MCP configuration parsed\n3. Server process started (stdio) or connection established (SSE/HTTP/WS)\n4. Tools discovered and registered\n5. Tools available as `mcp__plugin_...__...`\n\n**Viewing servers:**\nUse `/mcp` command to see all servers including plugin-provided ones.\n\n## Authentication Patterns\n\n### OAuth (SSE/HTTP)\n\nOAuth handled automatically by Claude Code:\n\n```json\n{\n  \"type\": \"sse\",\n  \"url\": \"https://mcp.example.com/sse\"\n}\n```\n\nUser authenticates in browser on first use. No additional configuration needed.\n\n### Token-Based (Headers)\n\nStatic or environment variable tokens:\n\n```json\n{\n  \"type\": \"http\",\n  \"url\": \"https://api.example.com\",\n  \"headers\": {\n    \"Authorization\": \"Bearer ${API_TOKEN}\"\n  }\n}\n```\n\nDocument required environment variables in README.\n\n### Environment Variables (stdio)\n\nPass configuration to MCP server:\n\n```json\n{\n  \"command\": \"python\",\n  \"args\": [\"-m\", \"my_mcp_server\"],\n  \"env\": {\n    \"DATABASE_URL\": \"${DB_URL}\",\n    \"API_KEY\": \"${API_KEY}\",\n    \"LOG_LEVEL\": \"info\"\n  }\n}\n```\n\n## Integration Patterns\n\n### Pattern 1: Simple Tool Wrapper\n\nCommands use MCP tools with user interaction:\n\n```markdown\n# Command: create-item.md\n---\nallowed-tools: [\"mcp__plugin_name_server__create_item\"]\n---\n\nSteps:\n1. Gather item details from user\n2. Use mcp__plugin_name_server__create_item\n3. Confirm creation\n```\n\n**Use for:** Adding validation or preprocessing before MCP calls.\n\n### Pattern 2: Autonomous Agent\n\nAgents use MCP tools autonomously:\n\n```markdown\n# Agent: data-analyzer.md\n\nAnalysis Process:\n1. Query data via mcp__plugin_db_server__query\n2. Process and analyze results\n3. Generate insights report\n```\n\n**Use for:** Multi-step MCP workflows without user interaction.\n\n### Pattern 3: Multi-Server Plugin\n\nIntegrate multiple MCP servers:\n\n```json\n{\n  \"github\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.github.com/sse\"\n  },\n  \"jira\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.jira.com/sse\"\n  }\n}\n```\n\n**Use for:** Workflows spanning multiple services.\n\n## Security Best Practices\n\n### Use HTTPS/WSS\n\nAlways use secure connections:\n\n```json\nâœ… \"url\": \"https://mcp.example.com/sse\"\nâŒ \"url\": \"http://mcp.example.com/sse\"\n```\n\n### Token Management\n\n**DO:**\n- âœ… Use environment variables for tokens\n- âœ… Document required env vars in README\n- âœ… Let OAuth flow handle authentication\n\n**DON'T:**\n- âŒ Hardcode tokens in configuration\n- âŒ Commit tokens to git\n- âŒ Share tokens in documentation\n\n### Permission Scoping\n\nPre-allow only necessary MCP tools:\n\n```markdown\nâœ… allowed-tools: [\n  \"mcp__plugin_api_server__read_data\",\n  \"mcp__plugin_api_server__create_item\"\n]\n\nâŒ allowed-tools: [\"mcp__plugin_api_server__*\"]\n```\n\n## Error Handling\n\n### Connection Failures\n\nHandle MCP server unavailability:\n- Provide fallback behavior in commands\n- Inform user of connection issues\n- Check server URL and configuration\n\n### Tool Call Errors\n\nHandle failed MCP operations:\n- Validate inputs before calling MCP tools\n- Provide clear error messages\n- Check rate limiting and quotas\n\n### Configuration Errors\n\nValidate MCP configuration:\n- Test server connectivity during development\n- Validate JSON syntax\n- Check required environment variables\n\n## Performance Considerations\n\n### Lazy Loading\n\nMCP servers connect on-demand:\n- Not all servers connect at startup\n- First tool use triggers connection\n- Connection pooling managed automatically\n\n### Batching\n\nBatch similar requests when possible:\n\n```\n# Good: Single query with filters\ntasks = search_tasks(project=\"X\", assignee=\"me\", limit=50)\n\n# Avoid: Many individual queries\nfor id in task_ids:\n    task = get_task(id)\n```\n\n## Testing MCP Integration\n\n### Local Testing\n\n1. Configure MCP server in `.mcp.json`\n2. Install plugin locally (`.claude-plugin/`)\n3. Run `/mcp` to verify server appears\n4. Test tool calls in commands\n5. Check `claude --debug` logs for connection issues\n\n### Validation Checklist\n\n- [ ] MCP configuration is valid JSON\n- [ ] Server URL is correct and accessible\n- [ ] Required environment variables documented\n- [ ] Tools appear in `/mcp` output\n- [ ] Authentication works (OAuth or tokens)\n- [ ] Tool calls succeed from commands\n- [ ] Error cases handled gracefully\n\n## Debugging\n\n### Enable Debug Logging\n\n```bash\nclaude --debug\n```\n\nLook for:\n- MCP server connection attempts\n- Tool discovery logs\n- Authentication flows\n- Tool call errors\n\n### Common Issues\n\n**Server not connecting:**\n- Check URL is correct\n- Verify server is running (stdio)\n- Check network connectivity\n- Review authentication configuration\n\n**Tools not available:**\n- Verify server connected successfully\n- Check tool names match exactly\n- Run `/mcp` to see available tools\n- Restart Claude Code after config changes\n\n**Authentication failing:**\n- Clear cached auth tokens\n- Re-authenticate\n- Check token scopes and permissions\n- Verify environment variables set\n\n## Quick Reference\n\n### MCP Server Types\n\n| Type | Transport | Best For | Auth |\n|------|-----------|----------|------|\n| stdio | Process | Local tools, custom servers | Env vars |\n| SSE | HTTP | Hosted services, cloud APIs | OAuth |\n| HTTP | REST | API backends, token auth | Tokens |\n| ws | WebSocket | Real-time, streaming | Tokens |\n\n### Configuration Checklist\n\n- [ ] Server type specified (stdio/SSE/HTTP/ws)\n- [ ] Type-specific fields complete (command or url)\n- [ ] Authentication configured\n- [ ] Environment variables documented\n- [ ] HTTPS/WSS used (not HTTP/WS)\n- [ ] ${CLAUDE_PLUGIN_ROOT} used for paths\n\n### Best Practices\n\n**DO:**\n- âœ… Use ${CLAUDE_PLUGIN_ROOT} for portable paths\n- âœ… Document required environment variables\n- âœ… Use secure connections (HTTPS/WSS)\n- âœ… Pre-allow specific MCP tools in commands\n- âœ… Test MCP integration before publishing\n- âœ… Handle connection and tool errors gracefully\n\n**DON'T:**\n- âŒ Hardcode absolute paths\n- âŒ Commit credentials to git\n- âŒ Use HTTP instead of HTTPS\n- âŒ Pre-allow all tools with wildcards\n- âŒ Skip error handling\n- âŒ Forget to document setup\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed information, consult:\n\n- **`references/server-types.md`** - Deep dive on each server type\n- **`references/authentication.md`** - Authentication patterns and OAuth\n- **`references/tool-usage.md`** - Using MCP tools in commands and agents\n\n### Example Configurations\n\nWorking examples in `examples/`:\n\n- **`stdio-server.json`** - Local stdio MCP server\n- **`sse-server.json`** - Hosted SSE server with OAuth\n- **`http-server.json`** - REST API with token auth\n\n### External Resources\n\n- **Official MCP Docs**: https://modelcontextprotocol.io/\n- **Claude Code MCP Docs**: https://docs.claude.com/en/docs/claude-code/mcp\n- **MCP SDK**: @modelcontextprotocol/sdk\n- **Testing**: Use `claude --debug` and `/mcp` command\n\n## Implementation Workflow\n\nTo add MCP integration to a plugin:\n\n1. Choose MCP server type (stdio, SSE, HTTP, ws)\n2. Create `.mcp.json` at plugin root with configuration\n3. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n4. Document required environment variables in README\n5. Test locally with `/mcp` command\n6. Pre-allow MCP tools in relevant commands\n7. Handle authentication (OAuth or tokens)\n8. Test error cases (connection failures, auth errors)\n9. Document MCP integration in plugin README\n\nFocus on stdio for custom/local servers, SSE for hosted services with OAuth."
              },
              {
                "name": "Plugin Settings",
                "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.",
                "path": "plugins/plugin-dev/skills/plugin-settings/SKILL.md",
                "frontmatter": {
                  "name": "Plugin Settings",
                  "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.",
                  "version": "0.1.0"
                },
                "content": "# Plugin Settings Pattern for Claude Code Plugins\n\n## Overview\n\nPlugins can store user-configurable settings and state in `.claude/plugin-name.local.md` files within the project directory. This pattern uses YAML frontmatter for structured configuration and markdown content for prompts or additional context.\n\n**Key characteristics:**\n- File location: `.claude/plugin-name.local.md` in project root\n- Structure: YAML frontmatter + markdown body\n- Purpose: Per-project plugin configuration and state\n- Usage: Read from hooks, commands, and agents\n- Lifecycle: User-managed (not in git, should be in `.gitignore`)\n\n## File Structure\n\n### Basic Template\n\n```markdown\n---\nenabled: true\nsetting1: value1\nsetting2: value2\nnumeric_setting: 42\nlist_setting: [\"item1\", \"item2\"]\n---\n\n# Additional Context\n\nThis markdown body can contain:\n- Task descriptions\n- Additional instructions\n- Prompts to feed back to Claude\n- Documentation or notes\n```\n\n### Example: Plugin State File\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nenabled: true\nstrict_mode: false\nmax_retries: 3\nnotification_level: info\ncoordinator_session: team-leader\n---\n\n# Plugin Configuration\n\nThis plugin is configured for standard validation mode.\nContact @team-lead with questions.\n```\n\n## Reading Settings Files\n\n### From Hooks (Bash Scripts)\n\n**Pattern: Check existence and parse frontmatter**\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\n# Define state file path\nSTATE_FILE=\".claude/my-plugin.local.md\"\n\n# Quick exit if file doesn't exist\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0  # Plugin not configured, skip\nfi\n\n# Parse YAML frontmatter (between --- markers)\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\n\n# Extract individual fields\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\nSTRICT_MODE=$(echo \"$FRONTMATTER\" | grep '^strict_mode:' | sed 's/strict_mode: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n\n# Check if enabled\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Use configuration in hook logic\nif [[ \"$STRICT_MODE\" == \"true\" ]]; then\n  # Apply strict validation\n  # ...\nfi\n```\n\nSee `examples/read-settings-hook.sh` for complete working example.\n\n### From Commands\n\nCommands can read settings files to customize behavior:\n\n```markdown\n---\ndescription: Process data with plugin\nallowed-tools: [\"Read\", \"Bash\"]\n---\n\n# Process Command\n\nSteps:\n1. Check if settings exist at `.claude/my-plugin.local.md`\n2. Read configuration using Read tool\n3. Parse YAML frontmatter to extract settings\n4. Apply settings to processing logic\n5. Execute with configured behavior\n```\n\n### From Agents\n\nAgents can reference settings in their instructions:\n\n```markdown\n---\nname: configured-agent\ndescription: Agent that adapts to project settings\n---\n\nCheck for plugin settings at `.claude/my-plugin.local.md`.\nIf present, parse YAML frontmatter and adapt behavior according to:\n- enabled: Whether plugin is active\n- mode: Processing mode (strict, standard, lenient)\n- Additional configuration fields\n```\n\n## Parsing Techniques\n\n### Extract Frontmatter\n\n```bash\n# Extract everything between --- markers\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n```\n\n### Read Individual Fields\n\n**String fields:**\n```bash\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field_name:' | sed 's/field_name: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n**Boolean fields:**\n```bash\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n# Compare: if [[ \"$ENABLED\" == \"true\" ]]; then\n```\n\n**Numeric fields:**\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n# Use: if [[ $MAX -gt 100 ]]; then\n```\n\n### Read Markdown Body\n\nExtract content after second `---`:\n\n```bash\n# Get everything after closing ---\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n## Common Patterns\n\n### Pattern 1: Temporarily Active Hooks\n\nUse settings file to control hook activation:\n\n```bash\n#!/bin/bash\nSTATE_FILE=\".claude/security-scan.local.md\"\n\n# Quick exit if not configured\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0\nfi\n\n# Read enabled flag\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Run hook logic\n# ...\n```\n\n**Use case:** Enable/disable hooks without editing hooks.json (requires restart).\n\n### Pattern 2: Agent State Management\n\nStore agent-specific state and configuration:\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-agent\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\n---\n\n# Task Assignment\n\nImplement JWT authentication for the API.\n\n**Success Criteria:**\n- Authentication endpoints created\n- Tests passing\n- PR created and CI green\n```\n\nRead from hooks to coordinate agents:\n\n```bash\nAGENT_NAME=$(echo \"$FRONTMATTER\" | grep '^agent_name:' | sed 's/agent_name: *//')\nCOORDINATOR=$(echo \"$FRONTMATTER\" | grep '^coordinator_session:' | sed 's/coordinator_session: *//')\n\n# Send notification to coordinator\ntmux send-keys -t \"$COORDINATOR\" \"Agent $AGENT_NAME completed task\" Enter\n```\n\n### Pattern 3: Configuration-Driven Behavior\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nvalidation_level: strict\nmax_file_size: 1000000\nallowed_extensions: [\".js\", \".ts\", \".tsx\"]\nenable_logging: true\n---\n\n# Validation Configuration\n\nStrict mode enabled for this project.\nAll writes validated against security policies.\n```\n\nUse in hooks or commands:\n\n```bash\nLEVEL=$(echo \"$FRONTMATTER\" | grep '^validation_level:' | sed 's/validation_level: *//')\n\ncase \"$LEVEL\" in\n  strict)\n    # Apply strict validation\n    ;;\n  standard)\n    # Apply standard validation\n    ;;\n  lenient)\n    # Apply lenient validation\n    ;;\nesac\n```\n\n## Creating Settings Files\n\n### From Commands\n\nCommands can create settings files:\n\n```markdown\n# Setup Command\n\nSteps:\n1. Ask user for configuration preferences\n2. Create `.claude/my-plugin.local.md` with YAML frontmatter\n3. Set appropriate values based on user input\n4. Inform user that settings are saved\n5. Remind user to restart Claude Code for hooks to recognize changes\n```\n\n### Template Generation\n\nProvide template in plugin README:\n\n```markdown\n## Configuration\n\nCreate `.claude/my-plugin.local.md` in your project:\n\n\\`\\`\\`markdown\n---\nenabled: true\nmode: standard\nmax_retries: 3\n---\n\n# Plugin Configuration\n\nYour settings are active.\n\\`\\`\\`\n\nAfter creating or editing, restart Claude Code for changes to take effect.\n```\n\n## Best Practices\n\n### File Naming\n\nâœ… **DO:**\n- Use `.claude/plugin-name.local.md` format\n- Match plugin name exactly\n- Use `.local.md` suffix for user-local files\n\nâŒ **DON'T:**\n- Use different directory (not `.claude/`)\n- Use inconsistent naming\n- Use `.md` without `.local` (might be committed)\n\n### Gitignore\n\nAlways add to `.gitignore`:\n\n```gitignore\n.claude/*.local.md\n.claude/*.local.json\n```\n\nDocument this in plugin README.\n\n### Defaults\n\nProvide sensible defaults when settings file doesn't exist:\n\n```bash\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  # Use defaults\n  ENABLED=true\n  MODE=standard\nelse\n  # Read from file\n  # ...\nfi\n```\n\n### Validation\n\nValidate settings values:\n\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n\n# Validate numeric range\nif ! [[ \"$MAX\" =~ ^[0-9]+$ ]] || [[ $MAX -lt 1 ]] || [[ $MAX -gt 100 ]]; then\n  echo \"âš ï¸  Invalid max_value in settings (must be 1-100)\" >&2\n  MAX=10  # Use default\nfi\n```\n\n### Restart Requirement\n\n**Important:** Settings changes require Claude Code restart.\n\nDocument in your README:\n\n```markdown\n## Changing Settings\n\nAfter editing `.claude/my-plugin.local.md`:\n1. Save the file\n2. Exit Claude Code\n3. Restart: `claude` or `cc`\n4. New settings will be loaded\n```\n\nHooks cannot be hot-swapped within a session.\n\n## Security Considerations\n\n### Sanitize User Input\n\nWhen writing settings files from user input:\n\n```bash\n# Escape quotes in user input\nSAFE_VALUE=$(echo \"$USER_INPUT\" | sed 's/\"/\\\\\"/g')\n\n# Write to file\ncat > \"$STATE_FILE\" <<EOF\n---\nuser_setting: \"$SAFE_VALUE\"\n---\nEOF\n```\n\n### Validate File Paths\n\nIf settings contain file paths:\n\n```bash\nFILE_PATH=$(echo \"$FRONTMATTER\" | grep '^data_file:' | sed 's/data_file: *//')\n\n# Check for path traversal\nif [[ \"$FILE_PATH\" == *\"..\"* ]]; then\n  echo \"âš ï¸  Invalid path in settings (path traversal)\" >&2\n  exit 2\nfi\n```\n\n### Permissions\n\nSettings files should be:\n- Readable by user only (`chmod 600`)\n- Not committed to git\n- Not shared between users\n\n## Real-World Examples\n\n### multi-agent-swarm Plugin\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-implementation\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\nadditional_instructions: Use JWT tokens, not sessions\n---\n\n# Task: Implement Authentication\n\nBuild JWT-based authentication for the REST API.\nCoordinate with auth-agent on shared types.\n```\n\n**Hook usage (agent-stop-notification.sh):**\n- Checks if file exists (line 15-18: quick exit if not)\n- Parses frontmatter to get coordinator_session, agent_name, enabled\n- Sends notifications to coordinator if enabled\n- Allows quick activation/deactivation via `enabled: true/false`\n\n### ralph-loop Plugin\n\n**.claude/ralph-loop.local.md:**\n```markdown\n---\niteration: 1\nmax_iterations: 10\ncompletion_promise: \"All tests passing and build successful\"\n---\n\nFix all the linting errors in the project.\nMake sure tests pass after each fix.\n```\n\n**Hook usage (stop-hook.sh):**\n- Checks if file exists (line 15-18: quick exit if not active)\n- Reads iteration count and max_iterations\n- Extracts completion_promise for loop termination\n- Reads body as the prompt to feed back\n- Updates iteration count on each loop\n\n## Quick Reference\n\n### File Location\n\n```\nproject-root/\nâ””â”€â”€ .claude/\n    â””â”€â”€ plugin-name.local.md\n```\n\n### Frontmatter Parsing\n\n```bash\n# Extract frontmatter\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n\n# Read field\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field:' | sed 's/field: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n### Body Parsing\n\n```bash\n# Extract body (after second ---)\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n### Quick Exit Pattern\n\n```bash\nif [[ ! -f \".claude/my-plugin.local.md\" ]]; then\n  exit 0  # Not configured\nfi\n```\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed implementation patterns:\n\n- **`references/parsing-techniques.md`** - Complete guide to parsing YAML frontmatter and markdown bodies\n- **`references/real-world-examples.md`** - Deep dive into multi-agent-swarm and ralph-loop implementations\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`read-settings-hook.sh`** - Hook that reads and uses settings\n- **`create-settings-command.md`** - Command that creates settings file\n- **`example-settings.md`** - Template settings file\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-settings.sh`** - Validate settings file structure\n- **`parse-frontmatter.sh`** - Extract frontmatter fields\n\n## Implementation Workflow\n\nTo add settings to a plugin:\n\n1. Design settings schema (which fields, types, defaults)\n2. Create template file in plugin documentation\n3. Add gitignore entry for `.claude/*.local.md`\n4. Implement settings parsing in hooks/commands\n5. Use quick-exit pattern (check file exists, check enabled field)\n6. Document settings in plugin README with template\n7. Remind users that changes require Claude Code restart\n\nFocus on keeping settings simple and providing good defaults when settings file doesn't exist."
              },
              {
                "name": "Plugin Structure",
                "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.",
                "path": "plugins/plugin-dev/skills/plugin-structure/SKILL.md",
                "frontmatter": {
                  "name": "Plugin Structure",
                  "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.",
                  "version": "0.1.0"
                },
                "content": "# Plugin Structure for Claude Code\n\n## Overview\n\nClaude Code plugins follow a standardized directory structure with automatic component discovery. Understanding this structure enables creating well-organized, maintainable plugins that integrate seamlessly with Claude Code.\n\n**Key concepts:**\n- Conventional directory layout for automatic discovery\n- Manifest-driven configuration in `.claude-plugin/plugin.json`\n- Component-based organization (commands, agents, skills, hooks)\n- Portable path references using `${CLAUDE_PLUGIN_ROOT}`\n- Explicit vs. auto-discovered component loading\n\n## Directory Structure\n\nEvery Claude Code plugin follows this organizational pattern:\n\n```\nplugin-name/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json          # Required: Plugin manifest\nâ”œâ”€â”€ commands/                 # Slash commands (.md files)\nâ”œâ”€â”€ agents/                   # Subagent definitions (.md files)\nâ”œâ”€â”€ skills/                   # Agent skills (subdirectories)\nâ”‚   â””â”€â”€ skill-name/\nâ”‚       â””â”€â”€ SKILL.md         # Required for each skill\nâ”œâ”€â”€ hooks/\nâ”‚   â””â”€â”€ hooks.json           # Event handler configuration\nâ”œâ”€â”€ .mcp.json                # MCP server definitions\nâ””â”€â”€ scripts/                 # Helper scripts and utilities\n```\n\n**Critical rules:**\n\n1. **Manifest location**: The `plugin.json` manifest MUST be in `.claude-plugin/` directory\n2. **Component locations**: All component directories (commands, agents, skills, hooks) MUST be at plugin root level, NOT nested inside `.claude-plugin/`\n3. **Optional components**: Only create directories for components the plugin actually uses\n4. **Naming convention**: Use kebab-case for all directory and file names\n\n## Plugin Manifest (plugin.json)\n\nThe manifest defines plugin metadata and configuration. Located at `.claude-plugin/plugin.json`:\n\n### Required Fields\n\n```json\n{\n  \"name\": \"plugin-name\"\n}\n```\n\n**Name requirements:**\n- Use kebab-case format (lowercase with hyphens)\n- Must be unique across installed plugins\n- No spaces or special characters\n- Example: `code-review-assistant`, `test-runner`, `api-docs`\n\n### Recommended Metadata\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Brief explanation of plugin purpose\",\n  \"author\": {\n    \"name\": \"Author Name\",\n    \"email\": \"author@example.com\",\n    \"url\": \"https://example.com\"\n  },\n  \"homepage\": \"https://docs.example.com\",\n  \"repository\": \"https://github.com/user/plugin-name\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"testing\", \"automation\", \"ci-cd\"]\n}\n```\n\n**Version format**: Follow semantic versioning (MAJOR.MINOR.PATCH)\n**Keywords**: Use for plugin discovery and categorization\n\n### Component Path Configuration\n\nSpecify custom paths for components (supplements default directories):\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"commands\": \"./custom-commands\",\n  \"agents\": [\"./agents\", \"./specialized-agents\"],\n  \"hooks\": \"./config/hooks.json\",\n  \"mcpServers\": \"./.mcp.json\"\n}\n```\n\n**Important**: Custom paths supplement defaultsâ€”they don't replace them. Components in both default directories and custom paths will load.\n\n**Path rules:**\n- Must be relative to plugin root\n- Must start with `./`\n- Cannot use absolute paths\n- Support arrays for multiple locations\n\n## Component Organization\n\n### Commands\n\n**Location**: `commands/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `commands/` load automatically\n\n**Example structure**:\n```\ncommands/\nâ”œâ”€â”€ review.md        # /review command\nâ”œâ”€â”€ test.md          # /test command\nâ””â”€â”€ deploy.md        # /deploy command\n```\n\n**File format**:\n```markdown\n---\nname: command-name\ndescription: Command description\n---\n\nCommand implementation instructions...\n```\n\n**Usage**: Commands integrate as native slash commands in Claude Code\n\n### Agents\n\n**Location**: `agents/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `agents/` load automatically\n\n**Example structure**:\n```\nagents/\nâ”œâ”€â”€ code-reviewer.md\nâ”œâ”€â”€ test-generator.md\nâ””â”€â”€ refactorer.md\n```\n\n**File format**:\n```markdown\n---\ndescription: Agent role and expertise\ncapabilities:\n  - Specific task 1\n  - Specific task 2\n---\n\nDetailed agent instructions and knowledge...\n```\n\n**Usage**: Users can invoke agents manually, or Claude Code selects them automatically based on task context\n\n### Skills\n\n**Location**: `skills/` directory with subdirectories per skill\n**Format**: Each skill in its own directory with `SKILL.md` file\n**Auto-discovery**: All `SKILL.md` files in skill subdirectories load automatically\n\n**Example structure**:\n```\nskills/\nâ”œâ”€â”€ api-testing/\nâ”‚   â”œâ”€â”€ SKILL.md\nâ”‚   â”œâ”€â”€ scripts/\nâ”‚   â”‚   â””â”€â”€ test-runner.py\nâ”‚   â””â”€â”€ references/\nâ”‚       â””â”€â”€ api-spec.md\nâ””â”€â”€ database-migrations/\n    â”œâ”€â”€ SKILL.md\n    â””â”€â”€ examples/\n        â””â”€â”€ migration-template.sql\n```\n\n**SKILL.md format**:\n```markdown\n---\nname: Skill Name\ndescription: When to use this skill\nversion: 1.0.0\n---\n\nSkill instructions and guidance...\n```\n\n**Supporting files**: Skills can include scripts, references, examples, or assets in subdirectories\n\n**Usage**: Claude Code autonomously activates skills based on task context matching the description\n\n### Hooks\n\n**Location**: `hooks/hooks.json` or inline in `plugin.json`\n**Format**: JSON configuration defining event handlers\n**Registration**: Hooks register automatically when plugin enables\n\n**Example structure**:\n```\nhooks/\nâ”œâ”€â”€ hooks.json           # Hook configuration\nâ””â”€â”€ scripts/\n    â”œâ”€â”€ validate.sh      # Hook script\n    â””â”€â”€ check-style.sh   # Hook script\n```\n\n**Configuration format**:\n```json\n{\n  \"PreToolUse\": [{\n    \"matcher\": \"Write|Edit\",\n    \"hooks\": [{\n      \"type\": \"command\",\n      \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/validate.sh\",\n      \"timeout\": 30\n    }]\n  }]\n}\n```\n\n**Available events**: PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification\n\n**Usage**: Hooks execute automatically in response to Claude Code events\n\n### MCP Servers\n\n**Location**: `.mcp.json` at plugin root or inline in `plugin.json`\n**Format**: JSON configuration for MCP server definitions\n**Auto-start**: Servers start automatically when plugin enables\n\n**Example format**:\n```json\n{\n  \"mcpServers\": {\n    \"server-name\": {\n      \"command\": \"node\",\n      \"args\": [\"${CLAUDE_PLUGIN_ROOT}/servers/server.js\"],\n      \"env\": {\n        \"API_KEY\": \"${API_KEY}\"\n      }\n    }\n  }\n}\n```\n\n**Usage**: MCP servers integrate seamlessly with Claude Code's tool system\n\n## Portable Path References\n\n### ${CLAUDE_PLUGIN_ROOT}\n\nUse `${CLAUDE_PLUGIN_ROOT}` environment variable for all intra-plugin path references:\n\n```json\n{\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/run.sh\"\n}\n```\n\n**Why it matters**: Plugins install in different locations depending on:\n- User installation method (marketplace, local, npm)\n- Operating system conventions\n- User preferences\n\n**Where to use it**:\n- Hook command paths\n- MCP server command arguments\n- Script execution references\n- Resource file paths\n\n**Never use**:\n- Hardcoded absolute paths (`/Users/name/plugins/...`)\n- Relative paths from working directory (`./scripts/...` in commands)\n- Home directory shortcuts (`~/plugins/...`)\n\n### Path Resolution Rules\n\n**In manifest JSON fields** (hooks, MCP servers):\n```json\n\"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/tool.sh\"\n```\n\n**In component files** (commands, agents, skills):\n```markdown\nReference scripts at: ${CLAUDE_PLUGIN_ROOT}/scripts/helper.py\n```\n\n**In executed scripts**:\n```bash\n#!/bin/bash\n# ${CLAUDE_PLUGIN_ROOT} available as environment variable\nsource \"${CLAUDE_PLUGIN_ROOT}/lib/common.sh\"\n```\n\n## File Naming Conventions\n\n### Component Files\n\n**Commands**: Use kebab-case `.md` files\n- `code-review.md` â†’ `/code-review`\n- `run-tests.md` â†’ `/run-tests`\n- `api-docs.md` â†’ `/api-docs`\n\n**Agents**: Use kebab-case `.md` files describing role\n- `test-generator.md`\n- `code-reviewer.md`\n- `performance-analyzer.md`\n\n**Skills**: Use kebab-case directory names\n- `api-testing/`\n- `database-migrations/`\n- `error-handling/`\n\n### Supporting Files\n\n**Scripts**: Use descriptive kebab-case names with appropriate extensions\n- `validate-input.sh`\n- `generate-report.py`\n- `process-data.js`\n\n**Documentation**: Use kebab-case markdown files\n- `api-reference.md`\n- `migration-guide.md`\n- `best-practices.md`\n\n**Configuration**: Use standard names\n- `hooks.json`\n- `.mcp.json`\n- `plugin.json`\n\n## Auto-Discovery Mechanism\n\nClaude Code automatically discovers and loads components:\n\n1. **Plugin manifest**: Reads `.claude-plugin/plugin.json` when plugin enables\n2. **Commands**: Scans `commands/` directory for `.md` files\n3. **Agents**: Scans `agents/` directory for `.md` files\n4. **Skills**: Scans `skills/` for subdirectories containing `SKILL.md`\n5. **Hooks**: Loads configuration from `hooks/hooks.json` or manifest\n6. **MCP servers**: Loads configuration from `.mcp.json` or manifest\n\n**Discovery timing**:\n- Plugin installation: Components register with Claude Code\n- Plugin enable: Components become available for use\n- No restart required: Changes take effect on next Claude Code session\n\n**Override behavior**: Custom paths in `plugin.json` supplement (not replace) default directories\n\n## Best Practices\n\n### Organization\n\n1. **Logical grouping**: Group related components together\n   - Put test-related commands, agents, and skills together\n   - Create subdirectories in `scripts/` for different purposes\n\n2. **Minimal manifest**: Keep `plugin.json` lean\n   - Only specify custom paths when necessary\n   - Rely on auto-discovery for standard layouts\n   - Use inline configuration only for simple cases\n\n3. **Documentation**: Include README files\n   - Plugin root: Overall purpose and usage\n   - Component directories: Specific guidance\n   - Script directories: Usage and requirements\n\n### Naming\n\n1. **Consistency**: Use consistent naming across components\n   - If command is `test-runner`, name related agent `test-runner-agent`\n   - Match skill directory names to their purpose\n\n2. **Clarity**: Use descriptive names that indicate purpose\n   - Good: `api-integration-testing/`, `code-quality-checker.md`\n   - Avoid: `utils/`, `misc.md`, `temp.sh`\n\n3. **Length**: Balance brevity with clarity\n   - Commands: 2-3 words (`review-pr`, `run-ci`)\n   - Agents: Describe role clearly (`code-reviewer`, `test-generator`)\n   - Skills: Topic-focused (`error-handling`, `api-design`)\n\n### Portability\n\n1. **Always use ${CLAUDE_PLUGIN_ROOT}**: Never hardcode paths\n2. **Test on multiple systems**: Verify on macOS, Linux, Windows\n3. **Document dependencies**: List required tools and versions\n4. **Avoid system-specific features**: Use portable bash/Python constructs\n\n### Maintenance\n\n1. **Version consistently**: Update version in plugin.json for releases\n2. **Deprecate gracefully**: Mark old components clearly before removal\n3. **Document breaking changes**: Note changes affecting existing users\n4. **Test thoroughly**: Verify all components work after changes\n\n## Common Patterns\n\n### Minimal Plugin\n\nSingle command with no dependencies:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json    # Just name field\nâ””â”€â”€ commands/\n    â””â”€â”€ hello.md       # Single command\n```\n\n### Full-Featured Plugin\n\nComplete plugin with all component types:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/          # User-facing commands\nâ”œâ”€â”€ agents/            # Specialized subagents\nâ”œâ”€â”€ skills/            # Auto-activating skills\nâ”œâ”€â”€ hooks/             # Event handlers\nâ”‚   â”œâ”€â”€ hooks.json\nâ”‚   â””â”€â”€ scripts/\nâ”œâ”€â”€ .mcp.json          # External integrations\nâ””â”€â”€ scripts/           # Shared utilities\n```\n\n### Skill-Focused Plugin\n\nPlugin providing only skills:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ””â”€â”€ skills/\n    â”œâ”€â”€ skill-one/\n    â”‚   â””â”€â”€ SKILL.md\n    â””â”€â”€ skill-two/\n        â””â”€â”€ SKILL.md\n```\n\n## Troubleshooting\n\n**Component not loading**:\n- Verify file is in correct directory with correct extension\n- Check YAML frontmatter syntax (commands, agents, skills)\n- Ensure skill has `SKILL.md` (not `README.md` or other name)\n- Confirm plugin is enabled in Claude Code settings\n\n**Path resolution errors**:\n- Replace all hardcoded paths with `${CLAUDE_PLUGIN_ROOT}`\n- Verify paths are relative and start with `./` in manifest\n- Check that referenced files exist at specified paths\n- Test with `echo $CLAUDE_PLUGIN_ROOT` in hook scripts\n\n**Auto-discovery not working**:\n- Confirm directories are at plugin root (not in `.claude-plugin/`)\n- Check file naming follows conventions (kebab-case, correct extensions)\n- Verify custom paths in manifest are correct\n- Restart Claude Code to reload plugin configuration\n\n**Conflicts between plugins**:\n- Use unique, descriptive component names\n- Namespace commands with plugin name if needed\n- Document potential conflicts in plugin README\n- Consider command prefixes for related functionality\n\n---\n\nFor detailed examples and advanced patterns, see files in `references/` and `examples/` directories."
              },
              {
                "name": "Skill Development",
                "description": "This skill should be used when the user wants to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins.",
                "path": "plugins/plugin-dev/skills/skill-development/SKILL.md",
                "frontmatter": {
                  "name": "Skill Development",
                  "description": "This skill should be used when the user wants to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins.",
                  "version": "0.1.0"
                },
                "content": "# Skill Development for Claude Code Plugins\n\nThis skill provides guidance for creating effective skills for Claude Code plugins.\n\n## About Skills\n\nSkills are modular, self-contained packages that extend Claude's capabilities by providing\nspecialized knowledge, workflows, and tools. Think of them as \"onboarding guides\" for specific\ndomains or tasksâ€”they transform Claude from a general-purpose agent into a specialized agent\nequipped with procedural knowledge that no model can fully possess.\n\n### What Skills Provide\n\n1. Specialized workflows - Multi-step procedures for specific domains\n2. Tool integrations - Instructions for working with specific file formats or APIs\n3. Domain expertise - Company-specific knowledge, schemas, business logic\n4. Bundled resources - Scripts, references, and assets for complex and repetitive tasks\n\n### Anatomy of a Skill\n\nEvery skill consists of a required SKILL.md file and optional bundled resources:\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md (required)\nâ”‚   â”œâ”€â”€ YAML frontmatter metadata (required)\nâ”‚   â”‚   â”œâ”€â”€ name: (required)\nâ”‚   â”‚   â””â”€â”€ description: (required)\nâ”‚   â””â”€â”€ Markdown instructions (required)\nâ””â”€â”€ Bundled Resources (optional)\n    â”œâ”€â”€ scripts/          - Executable code (Python/Bash/etc.)\n    â”œâ”€â”€ references/       - Documentation intended to be loaded into context as needed\n    â””â”€â”€ assets/           - Files used in output (templates, icons, fonts, etc.)\n```\n\n#### SKILL.md (required)\n\n**Metadata Quality:** The `name` and `description` in YAML frontmatter determine when Claude will use the skill. Be specific about what the skill does and when to use it. Use the third-person (e.g. \"This skill should be used when...\" instead of \"Use this skill when...\").\n\n#### Bundled Resources (optional)\n\n##### Scripts (`scripts/`)\n\nExecutable code (Python/Bash/etc.) for tasks that require deterministic reliability or are repeatedly rewritten.\n\n- **When to include**: When the same code is being rewritten repeatedly or deterministic reliability is needed\n- **Example**: `scripts/rotate_pdf.py` for PDF rotation tasks\n- **Benefits**: Token efficient, deterministic, may be executed without loading into context\n- **Note**: Scripts may still need to be read by Claude for patching or environment-specific adjustments\n\n##### References (`references/`)\n\nDocumentation and reference material intended to be loaded as needed into context to inform Claude's process and thinking.\n\n- **When to include**: For documentation that Claude should reference while working\n- **Examples**: `references/finance.md` for financial schemas, `references/mnda.md` for company NDA template, `references/policies.md` for company policies, `references/api_docs.md` for API specifications\n- **Use cases**: Database schemas, API documentation, domain knowledge, company policies, detailed workflow guides\n- **Benefits**: Keeps SKILL.md lean, loaded only when Claude determines it's needed\n- **Best practice**: If files are large (>10k words), include grep search patterns in SKILL.md\n- **Avoid duplication**: Information should live in either SKILL.md or references files, not both. Prefer references files for detailed information unless it's truly core to the skillâ€”this keeps SKILL.md lean while making information discoverable without hogging the context window. Keep only essential procedural instructions and workflow guidance in SKILL.md; move detailed reference material, schemas, and examples to references files.\n\n##### Assets (`assets/`)\n\nFiles not intended to be loaded into context, but rather used within the output Claude produces.\n\n- **When to include**: When the skill needs files that will be used in the final output\n- **Examples**: `assets/logo.png` for brand assets, `assets/slides.pptx` for PowerPoint templates, `assets/frontend-template/` for HTML/React boilerplate, `assets/font.ttf` for typography\n- **Use cases**: Templates, images, icons, boilerplate code, fonts, sample documents that get copied or modified\n- **Benefits**: Separates output resources from documentation, enables Claude to use files without loading them into context\n\n### Progressive Disclosure Design Principle\n\nSkills use a three-level loading system to manage context efficiently:\n\n1. **Metadata (name + description)** - Always in context (~100 words)\n2. **SKILL.md body** - When skill triggers (<5k words)\n3. **Bundled resources** - As needed by Claude (Unlimited*)\n\n*Unlimited because scripts can be executed without reading into context window.\n\n## Skill Creation Process\n\nTo create a skill, follow the \"Skill Creation Process\" in order, skipping steps only if there is a clear reason why they are not applicable.\n\n### Step 1: Understanding the Skill with Concrete Examples\n\nSkip this step only when the skill's usage patterns are already clearly understood. It remains valuable even when working with an existing skill.\n\nTo create an effective skill, clearly understand concrete examples of how the skill will be used. This understanding can come from either direct user examples or generated examples that are validated with user feedback.\n\nFor example, when building an image-editor skill, relevant questions include:\n\n- \"What functionality should the image-editor skill support? Editing, rotating, anything else?\"\n- \"Can you give some examples of how this skill would be used?\"\n- \"I can imagine users asking for things like 'Remove the red-eye from this image' or 'Rotate this image'. Are there other ways you imagine this skill being used?\"\n- \"What would a user say that should trigger this skill?\"\n\nTo avoid overwhelming users, avoid asking too many questions in a single message. Start with the most important questions and follow up as needed for better effectiveness.\n\nConclude this step when there is a clear sense of the functionality the skill should support.\n\n### Step 2: Planning the Reusable Skill Contents\n\nTo turn concrete examples into an effective skill, analyze each example by:\n\n1. Considering how to execute on the example from scratch\n2. Identifying what scripts, references, and assets would be helpful when executing these workflows repeatedly\n\nExample: When building a `pdf-editor` skill to handle queries like \"Help me rotate this PDF,\" the analysis shows:\n\n1. Rotating a PDF requires re-writing the same code each time\n2. A `scripts/rotate_pdf.py` script would be helpful to store in the skill\n\nExample: When designing a `frontend-webapp-builder` skill for queries like \"Build me a todo app\" or \"Build me a dashboard to track my steps,\" the analysis shows:\n\n1. Writing a frontend webapp requires the same boilerplate HTML/React each time\n2. An `assets/hello-world/` template containing the boilerplate HTML/React project files would be helpful to store in the skill\n\nExample: When building a `big-query` skill to handle queries like \"How many users have logged in today?\" the analysis shows:\n\n1. Querying BigQuery requires re-discovering the table schemas and relationships each time\n2. A `references/schema.md` file documenting the table schemas would be helpful to store in the skill\n\n**For Claude Code plugins:** When building a hooks skill, the analysis shows:\n1. Developers repeatedly need to validate hooks.json and test hook scripts\n2. `scripts/validate-hook-schema.sh` and `scripts/test-hook.sh` utilities would be helpful\n3. `references/patterns.md` for detailed hook patterns to avoid bloating SKILL.md\n\nTo establish the skill's contents, analyze each concrete example to create a list of the reusable resources to include: scripts, references, and assets.\n\n### Step 3: Create Skill Structure\n\nFor Claude Code plugins, create the skill directory structure:\n\n```bash\nmkdir -p plugin-name/skills/skill-name/{references,examples,scripts}\ntouch plugin-name/skills/skill-name/SKILL.md\n```\n\n**Note:** Unlike the generic skill-creator which uses `init_skill.py`, plugin skills are created directly in the plugin's `skills/` directory with a simpler manual structure.\n\n### Step 4: Edit the Skill\n\nWhen editing the (newly-created or existing) skill, remember that the skill is being created for another instance of Claude to use. Focus on including information that would be beneficial and non-obvious to Claude. Consider what procedural knowledge, domain-specific details, or reusable assets would help another Claude instance execute these tasks more effectively.\n\n#### Start with Reusable Skill Contents\n\nTo begin implementation, start with the reusable resources identified above: `scripts/`, `references/`, and `assets/` files. Note that this step may require user input. For example, when implementing a `brand-guidelines` skill, the user may need to provide brand assets or templates to store in `assets/`, or documentation to store in `references/`.\n\nAlso, delete any example files and directories not needed for the skill. Create only the directories you actually need (references/, examples/, scripts/).\n\n#### Update SKILL.md\n\n**Writing Style:** Write the entire skill using **imperative/infinitive form** (verb-first instructions), not second person. Use objective, instructional language (e.g., \"To accomplish X, do Y\" rather than \"You should do X\" or \"If you need to do X\"). This maintains consistency and clarity for AI consumption.\n\n**Description (Frontmatter):** Use third-person format with specific trigger phrases:\n\n```yaml\n---\nname: Skill Name\ndescription: This skill should be used when the user asks to \"specific phrase 1\", \"specific phrase 2\", \"specific phrase 3\". Include exact phrases users would say that should trigger this skill. Be concrete and specific.\nversion: 0.1.0\n---\n```\n\n**Good description examples:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", \"implement prompt-based hooks\", or mentions hook events (PreToolUse, PostToolUse, Stop).\n```\n\n**Bad description examples:**\n```yaml\ndescription: Use this skill when working with hooks.  # Wrong person, vague\ndescription: Load when user needs hook help.  # Not third person\ndescription: Provides hook guidance.  # No trigger phrases\n```\n\nTo complete SKILL.md body, answer the following questions:\n\n1. What is the purpose of the skill, in a few sentences?\n2. When should the skill be used? (Include this in frontmatter description with specific triggers)\n3. In practice, how should Claude use the skill? All reusable skill contents developed above should be referenced so that Claude knows how to use them.\n\n**Keep SKILL.md lean:** Target 1,500-2,000 words for the body. Move detailed content to references/:\n- Detailed patterns â†’ `references/patterns.md`\n- Advanced techniques â†’ `references/advanced.md`\n- Migration guides â†’ `references/migration.md`\n- API references â†’ `references/api-reference.md`\n\n**Reference resources in SKILL.md:**\n```markdown\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and techniques, consult:\n- **`references/patterns.md`** - Common patterns\n- **`references/advanced.md`** - Advanced use cases\n\n### Example Files\n\nWorking examples in `examples/`:\n- **`example-script.sh`** - Working example\n```\n\n### Step 5: Validate and Test\n\n**For plugin skills, validation is different from generic skills:**\n\n1. **Check structure**: Skill directory in `plugin-name/skills/skill-name/`\n2. **Validate SKILL.md**: Has frontmatter with name and description\n3. **Check trigger phrases**: Description includes specific user queries\n4. **Verify writing style**: Body uses imperative/infinitive form, not second person\n5. **Test progressive disclosure**: SKILL.md is lean (~1,500-2,000 words), detailed content in references/\n6. **Check references**: All referenced files exist\n7. **Validate examples**: Examples are complete and correct\n8. **Test scripts**: Scripts are executable and work correctly\n\n**Use the skill-reviewer agent:**\n```\nAsk: \"Review my skill and check if it follows best practices\"\n```\n\nThe skill-reviewer agent will check description quality, content organization, and progressive disclosure.\n\n### Step 6: Iterate\n\nAfter testing the skill, users may request improvements. Often this happens right after using the skill, with fresh context of how the skill performed.\n\n**Iteration workflow:**\n1. Use the skill on real tasks\n2. Notice struggles or inefficiencies\n3. Identify how SKILL.md or bundled resources should be updated\n4. Implement changes and test again\n\n**Common improvements:**\n- Strengthen trigger phrases in description\n- Move long sections from SKILL.md to references/\n- Add missing examples or scripts\n- Clarify ambiguous instructions\n- Add edge case handling\n\n## Plugin-Specific Considerations\n\n### Skill Location in Plugins\n\nPlugin skills live in the plugin's `skills/` directory:\n\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/\nâ”œâ”€â”€ agents/\nâ””â”€â”€ skills/\n    â””â”€â”€ my-skill/\n        â”œâ”€â”€ SKILL.md\n        â”œâ”€â”€ references/\n        â”œâ”€â”€ examples/\n        â””â”€â”€ scripts/\n```\n\n### Auto-Discovery\n\nClaude Code automatically discovers skills:\n- Scans `skills/` directory\n- Finds subdirectories containing `SKILL.md`\n- Loads skill metadata (name + description) always\n- Loads SKILL.md body when skill triggers\n- Loads references/examples when needed\n\n### No Packaging Needed\n\nPlugin skills are distributed as part of the plugin, not as separate ZIP files. Users get skills when they install the plugin.\n\n### Testing in Plugins\n\nTest skills by installing plugin locally:\n\n```bash\n# Test with --plugin-dir\ncc --plugin-dir /path/to/plugin\n\n# Ask questions that should trigger the skill\n# Verify skill loads correctly\n```\n\n## Examples from Plugin-Dev\n\nStudy the skills in this plugin as examples of best practices:\n\n**hook-development skill:**\n- Excellent trigger phrases: \"create a hook\", \"add a PreToolUse hook\", etc.\n- Lean SKILL.md (1,651 words)\n- 3 references/ files for detailed content\n- 3 examples/ of working hooks\n- 3 scripts/ utilities\n\n**agent-development skill:**\n- Strong triggers: \"create an agent\", \"agent frontmatter\", etc.\n- Focused SKILL.md (1,438 words)\n- References include the AI generation prompt from Claude Code\n- Complete agent examples\n\n**plugin-settings skill:**\n- Specific triggers: \"plugin settings\", \".local.md files\", \"YAML frontmatter\"\n- References show real implementations (multi-agent-swarm, ralph-loop)\n- Working parsing scripts\n\nEach demonstrates progressive disclosure and strong triggering.\n\n## Progressive Disclosure in Practice\n\n### What Goes in SKILL.md\n\n**Include (always loaded when skill triggers):**\n- Core concepts and overview\n- Essential procedures and workflows\n- Quick reference tables\n- Pointers to references/examples/scripts\n- Most common use cases\n\n**Keep under 3,000 words, ideally 1,500-2,000 words**\n\n### What Goes in references/\n\n**Move to references/ (loaded as needed):**\n- Detailed patterns and advanced techniques\n- Comprehensive API documentation\n- Migration guides\n- Edge cases and troubleshooting\n- Extensive examples and walkthroughs\n\n**Each reference file can be large (2,000-5,000+ words)**\n\n### What Goes in examples/\n\n**Working code examples:**\n- Complete, runnable scripts\n- Configuration files\n- Template files\n- Real-world usage examples\n\n**Users can copy and adapt these directly**\n\n### What Goes in scripts/\n\n**Utility scripts:**\n- Validation tools\n- Testing helpers\n- Parsing utilities\n- Automation scripts\n\n**Should be executable and documented**\n\n## Writing Style Requirements\n\n### Imperative/Infinitive Form\n\nWrite using verb-first instructions, not second person:\n\n**Correct (imperative):**\n```\nTo create a hook, define the event type.\nConfigure the MCP server with authentication.\nValidate settings before use.\n```\n\n**Incorrect (second person):**\n```\nYou should create a hook by defining the event type.\nYou need to configure the MCP server.\nYou must validate settings before use.\n```\n\n### Third-Person in Description\n\nThe frontmatter description must use third person:\n\n**Correct:**\n```yaml\ndescription: This skill should be used when the user asks to \"create X\", \"configure Y\"...\n```\n\n**Incorrect:**\n```yaml\ndescription: Use this skill when you want to create X...\ndescription: Load this skill when user asks...\n```\n\n### Objective, Instructional Language\n\nFocus on what to do, not who should do it:\n\n**Correct:**\n```\nParse the frontmatter using sed.\nExtract fields with grep.\nValidate values before use.\n```\n\n**Incorrect:**\n```\nYou can parse the frontmatter...\nClaude should extract fields...\nThe user might validate values...\n```\n\n## Validation Checklist\n\nBefore finalizing a skill:\n\n**Structure:**\n- [ ] SKILL.md file exists with valid YAML frontmatter\n- [ ] Frontmatter has `name` and `description` fields\n- [ ] Markdown body is present and substantial\n- [ ] Referenced files actually exist\n\n**Description Quality:**\n- [ ] Uses third person (\"This skill should be used when...\")\n- [ ] Includes specific trigger phrases users would say\n- [ ] Lists concrete scenarios (\"create X\", \"configure Y\")\n- [ ] Not vague or generic\n\n**Content Quality:**\n- [ ] SKILL.md body uses imperative/infinitive form\n- [ ] Body is focused and lean (1,500-2,000 words ideal, <5k max)\n- [ ] Detailed content moved to references/\n- [ ] Examples are complete and working\n- [ ] Scripts are executable and documented\n\n**Progressive Disclosure:**\n- [ ] Core concepts in SKILL.md\n- [ ] Detailed docs in references/\n- [ ] Working code in examples/\n- [ ] Utilities in scripts/\n- [ ] SKILL.md references these resources\n\n**Testing:**\n- [ ] Skill triggers on expected user queries\n- [ ] Content is helpful for intended tasks\n- [ ] No duplicated information across files\n- [ ] References load when needed\n\n## Common Mistakes to Avoid\n\n### Mistake 1: Weak Trigger Description\n\nâŒ **Bad:**\n```yaml\ndescription: Provides guidance for working with hooks.\n```\n\n**Why bad:** Vague, no specific trigger phrases, not third person\n\nâœ… **Good:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", or mentions hook events. Provides comprehensive hooks API guidance.\n```\n\n**Why good:** Third person, specific phrases, concrete scenarios\n\n### Mistake 2: Too Much in SKILL.md\n\nâŒ **Bad:**\n```\nskill-name/\nâ””â”€â”€ SKILL.md  (8,000 words - everything in one file)\n```\n\n**Why bad:** Bloats context when skill loads, detailed content always loaded\n\nâœ… **Good:**\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md  (1,800 words - core essentials)\nâ””â”€â”€ references/\n    â”œâ”€â”€ patterns.md (2,500 words)\n    â””â”€â”€ advanced.md (3,700 words)\n```\n\n**Why good:** Progressive disclosure, detailed content loaded only when needed\n\n### Mistake 3: Second Person Writing\n\nâŒ **Bad:**\n```markdown\nYou should start by reading the configuration file.\nYou need to validate the input.\nYou can use the grep tool to search.\n```\n\n**Why bad:** Second person, not imperative form\n\nâœ… **Good:**\n```markdown\nStart by reading the configuration file.\nValidate the input before processing.\nUse the grep tool to search for patterns.\n```\n\n**Why good:** Imperative form, direct instructions\n\n### Mistake 4: Missing Resource References\n\nâŒ **Bad:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n[No mention of references/ or examples/]\n```\n\n**Why bad:** Claude doesn't know references exist\n\nâœ… **Good:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n## Additional Resources\n\n### Reference Files\n- **`references/patterns.md`** - Detailed patterns\n- **`references/advanced.md`** - Advanced techniques\n\n### Examples\n- **`examples/script.sh`** - Working example\n```\n\n**Why good:** Claude knows where to find additional information\n\n## Quick Reference\n\n### Minimal Skill\n\n```\nskill-name/\nâ””â”€â”€ SKILL.md\n```\n\nGood for: Simple knowledge, no complex resources needed\n\n### Standard Skill (Recommended)\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md\nâ”œâ”€â”€ references/\nâ”‚   â””â”€â”€ detailed-guide.md\nâ””â”€â”€ examples/\n    â””â”€â”€ working-example.sh\n```\n\nGood for: Most plugin skills with detailed documentation\n\n### Complete Skill\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md\nâ”œâ”€â”€ references/\nâ”‚   â”œâ”€â”€ patterns.md\nâ”‚   â””â”€â”€ advanced.md\nâ”œâ”€â”€ examples/\nâ”‚   â”œâ”€â”€ example1.sh\nâ”‚   â””â”€â”€ example2.json\nâ””â”€â”€ scripts/\n    â””â”€â”€ validate.sh\n```\n\nGood for: Complex domains with validation utilities\n\n## Best Practices Summary\n\nâœ… **DO:**\n- Use third-person in description (\"This skill should be used when...\")\n- Include specific trigger phrases (\"create X\", \"configure Y\")\n- Keep SKILL.md lean (1,500-2,000 words)\n- Use progressive disclosure (move details to references/)\n- Write in imperative/infinitive form\n- Reference supporting files clearly\n- Provide working examples\n- Create utility scripts for common operations\n- Study plugin-dev's skills as templates\n\nâŒ **DON'T:**\n- Use second person anywhere\n- Have vague trigger conditions\n- Put everything in SKILL.md (>3,000 words without references/)\n- Write in second person (\"You should...\")\n- Leave resources unreferenced\n- Include broken or incomplete examples\n- Skip validation\n\n## Additional Resources\n\n### Study These Skills\n\nPlugin-dev's skills demonstrate best practices:\n- `../hook-development/` - Progressive disclosure, utilities\n- `../agent-development/` - AI-assisted creation, references\n- `../mcp-integration/` - Comprehensive references\n- `../plugin-settings/` - Real-world examples\n- `../command-development/` - Clear critical concepts\n- `../plugin-structure/` - Good organization\n\n### Reference Files\n\nFor complete skill-creator methodology:\n- **`references/skill-creator-original.md`** - Full original skill-creator content\n\n## Implementation Workflow\n\nTo create a skill for your plugin:\n\n1. **Understand use cases**: Identify concrete examples of skill usage\n2. **Plan resources**: Determine what scripts/references/examples needed\n3. **Create structure**: `mkdir -p skills/skill-name/{references,examples,scripts}`\n4. **Write SKILL.md**:\n   - Frontmatter with third-person description and trigger phrases\n   - Lean body (1,500-2,000 words) in imperative form\n   - Reference supporting files\n5. **Add resources**: Create references/, examples/, scripts/ as needed\n6. **Validate**: Check description, writing style, organization\n7. **Test**: Verify skill loads on expected triggers\n8. **Iterate**: Improve based on usage\n\nFocus on strong trigger descriptions, progressive disclosure, and imperative writing style for effective skills that load when needed and provide targeted guidance."
              }
            ]
          },
          {
            "name": "huggingface-skills",
            "description": "Build, train, evaluate, and use open source AI models, datasets, and spaces.",
            "source": {
              "source": "url",
              "url": "https://github.com/huggingface/skills.git"
            },
            "category": "development",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install huggingface-skills@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [
              {
                "name": "/explain-error",
                "description": "Explain Stripe error codes and provide solutions with code examples",
                "path": "external_plugins/stripe/commands/explain-error.md",
                "frontmatter": {
                  "description": "Explain Stripe error codes and provide solutions with code examples",
                  "argument-hint": [
                    "error_code or error_message"
                  ]
                },
                "content": "# Explain Stripe Error\n\nProvide a comprehensive explanation of the given Stripe error code or error message:\n\n1. Accept the error code or full error message from the arguments\n2. Explain in plain English what the error means\n3. List common causes of this error\n4. Provide specific solutions and handling recommendations\n5. Generate error handling code in the project's language showing:\n   - How to catch this specific error\n   - User-friendly error messages\n   - Whether retry is appropriate\n6. Mention related error codes the developer should be aware of\n7. Include a link to the relevant Stripe documentation\n\nFocus on actionable solutions and production-ready error handling patterns."
              },
              {
                "name": "/test-cards",
                "description": "Display Stripe test card numbers for various testing scenarios",
                "path": "external_plugins/stripe/commands/test-cards.md",
                "frontmatter": {
                  "description": "Display Stripe test card numbers for various testing scenarios",
                  "argument-hint": [
                    "scenario"
                  ]
                },
                "content": "# Test Cards Reference\n\nProvide a quick reference for Stripe test card numbers:\n\n1. If a scenario argument is provided (e.g., \"declined\", \"3dsecure\", \"fraud\"), show relevant test cards for that scenario\n2. Otherwise, show the most common test cards organized by category:\n   - Successful payment (default card)\n   - 3D Secure authentication required\n   - Generic decline\n   - Specific decline reasons (insufficient_funds, lost_card, etc.)\n3. For each card, display:\n   - Card number (formatted with spaces)\n   - Expected behavior\n   - Expiry/CVC info (any future date and any 3-digit CVC)\n4. Use clear visual indicators (âœ“ for success, âš ï¸ for auth required, âœ— for decline)\n5. Mention that these only work in test mode\n6. Provide link to full testing documentation: https://docs.stripe.com/testing.md\n\nIf the user is currently working on test code, offer to generate test cases using these cards."
              },
              {
                "name": "/new-sdk-app",
                "description": "Create and setup a new Claude Agent SDK application",
                "path": "plugins/agent-sdk-dev/commands/new-sdk-app.md",
                "frontmatter": {
                  "description": "Create and setup a new Claude Agent SDK application",
                  "argument-hint": [
                    "project-name"
                  ]
                },
                "content": "You are tasked with helping the user create a new Claude Agent SDK application. Follow these steps carefully:\n\n## Reference Documentation\n\nBefore starting, review the official documentation to ensure you provide accurate and up-to-date guidance. Use WebFetch to read these pages:\n\n1. **Start with the overview**: https://docs.claude.com/en/api/agent-sdk/overview\n2. **Based on the user's language choice, read the appropriate SDK reference**:\n   - TypeScript: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Python: https://docs.claude.com/en/api/agent-sdk/python\n3. **Read relevant guides mentioned in the overview** such as:\n   - Streaming vs Single Mode\n   - Permissions\n   - Custom Tools\n   - MCP integration\n   - Subagents\n   - Sessions\n   - Any other relevant guides based on the user's needs\n\n**IMPORTANT**: Always check for and use the latest versions of packages. Use WebSearch or WebFetch to verify current versions before installation.\n\n## Gather Requirements\n\nIMPORTANT: Ask these questions one at a time. Wait for the user's response before asking the next question. This makes it easier for the user to respond.\n\nAsk the questions in this order (skip any that the user has already provided via arguments):\n\n1. **Language** (ask first): \"Would you like to use TypeScript or Python?\"\n\n   - Wait for response before continuing\n\n2. **Project name** (ask second): \"What would you like to name your project?\"\n\n   - If $ARGUMENTS is provided, use that as the project name and skip this question\n   - Wait for response before continuing\n\n3. **Agent type** (ask third, but skip if #2 was sufficiently detailed): \"What kind of agent are you building? Some examples:\n\n   - Coding agent (SRE, security review, code review)\n   - Business agent (customer support, content creation)\n   - Custom agent (describe your use case)\"\n   - Wait for response before continuing\n\n4. **Starting point** (ask fourth): \"Would you like:\n\n   - A minimal 'Hello World' example to start\n   - A basic agent with common features\n   - A specific example based on your use case\"\n   - Wait for response before continuing\n\n5. **Tooling choice** (ask fifth): Let the user know what tools you'll use, and confirm with them that these are the tools they want to use (for example, they may prefer pnpm or bun over npm). Respect the user's preferences when executing on the requirements.\n\nAfter all questions are answered, proceed to create the setup plan.\n\n## Setup Plan\n\nBased on the user's answers, create a plan that includes:\n\n1. **Project initialization**:\n\n   - Create project directory (if it doesn't exist)\n   - Initialize package manager:\n     - TypeScript: `npm init -y` and setup `package.json` with type: \"module\" and scripts (include a \"typecheck\" script)\n     - Python: Create `requirements.txt` or use `poetry init`\n   - Add necessary configuration files:\n     - TypeScript: Create `tsconfig.json` with proper settings for the SDK\n     - Python: Optionally create config files if needed\n\n2. **Check for Latest Versions**:\n\n   - BEFORE installing, use WebSearch or check npm/PyPI to find the latest version\n   - For TypeScript: Check https://www.npmjs.com/package/@anthropic-ai/claude-agent-sdk\n   - For Python: Check https://pypi.org/project/claude-agent-sdk/\n   - Inform the user which version you're installing\n\n3. **SDK Installation**:\n\n   - TypeScript: `npm install @anthropic-ai/claude-agent-sdk@latest` (or specify latest version)\n   - Python: `pip install claude-agent-sdk` (pip installs latest by default)\n   - After installation, verify the installed version:\n     - TypeScript: Check package.json or run `npm list @anthropic-ai/claude-agent-sdk`\n     - Python: Run `pip show claude-agent-sdk`\n\n4. **Create starter files**:\n\n   - TypeScript: Create an `index.ts` or `src/index.ts` with a basic query example\n   - Python: Create a `main.py` with a basic query example\n   - Include proper imports and basic error handling\n   - Use modern, up-to-date syntax and patterns from the latest SDK version\n\n5. **Environment setup**:\n\n   - Create a `.env.example` file with `ANTHROPIC_API_KEY=your_api_key_here`\n   - Add `.env` to `.gitignore`\n   - Explain how to get an API key from https://console.anthropic.com/\n\n6. **Optional: Create .claude directory structure**:\n   - Offer to create `.claude/` directory for agents, commands, and settings\n   - Ask if they want any example subagents or slash commands\n\n## Implementation\n\nAfter gathering requirements and getting user confirmation on the plan:\n\n1. Check for latest package versions using WebSearch or WebFetch\n2. Execute the setup steps\n3. Create all necessary files\n4. Install dependencies (always use latest stable versions)\n5. Verify installed versions and inform the user\n6. Create a working example based on their agent type\n7. Add helpful comments in the code explaining what each part does\n8. **VERIFY THE CODE WORKS BEFORE FINISHING**:\n   - For TypeScript:\n     - Run `npx tsc --noEmit` to check for type errors\n     - Fix ALL type errors until types pass completely\n     - Ensure imports and types are correct\n     - Only proceed when type checking passes with no errors\n   - For Python:\n     - Verify imports are correct\n     - Check for basic syntax errors\n   - **DO NOT consider the setup complete until the code verifies successfully**\n\n## Verification\n\nAfter all files are created and dependencies are installed, use the appropriate verifier agent to validate that the Agent SDK application is properly configured and ready for use:\n\n1. **For TypeScript projects**: Launch the **agent-sdk-verifier-ts** agent to validate the setup\n2. **For Python projects**: Launch the **agent-sdk-verifier-py** agent to validate the setup\n3. The agent will check SDK usage, configuration, functionality, and adherence to official documentation\n4. Review the verification report and address any issues\n\n## Getting Started Guide\n\nOnce setup is complete and verified, provide the user with:\n\n1. **Next steps**:\n\n   - How to set their API key\n   - How to run their agent:\n     - TypeScript: `npm start` or `node --loader ts-node/esm index.ts`\n     - Python: `python main.py`\n\n2. **Useful resources**:\n\n   - Link to TypeScript SDK reference: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Link to Python SDK reference: https://docs.claude.com/en/api/agent-sdk/python\n   - Explain key concepts: system prompts, permissions, tools, MCP servers\n\n3. **Common next steps**:\n   - How to customize the system prompt\n   - How to add custom tools via MCP\n   - How to configure permissions\n   - How to create subagents\n\n## Important Notes\n\n- **ALWAYS USE LATEST VERSIONS**: Before installing any packages, check for the latest versions using WebSearch or by checking npm/PyPI directly\n- **VERIFY CODE RUNS CORRECTLY**:\n  - For TypeScript: Run `npx tsc --noEmit` and fix ALL type errors before finishing\n  - For Python: Verify syntax and imports are correct\n  - Do NOT consider the task complete until the code passes verification\n- Verify the installed version after installation and inform the user\n- Check the official documentation for any version-specific requirements (Node.js version, Python version, etc.)\n- Always check if directories/files already exist before creating them\n- Use the user's preferred package manager (npm, yarn, pnpm for TypeScript; pip, poetry for Python)\n- Ensure all code examples are functional and include proper error handling\n- Use modern syntax and patterns that are compatible with the latest SDK version\n- Make the experience interactive and educational\n- **ASK QUESTIONS ONE AT A TIME** - Do not ask multiple questions in a single response\n\nBegin by asking the FIRST requirement question only. Wait for the user's answer before proceeding to the next question."
              },
              {
                "name": "/code-review",
                "description": "Code review a pull request",
                "path": "plugins/code-review/commands/code-review.md",
                "frontmatter": {
                  "allowed-tools": "Bash(gh issue view:*), Bash(gh search:*), Bash(gh issue list:*), Bash(gh pr comment:*), Bash(gh pr diff:*), Bash(gh pr view:*), Bash(gh pr list:*)",
                  "description": "Code review a pull request",
                  "disable-model-invocation": false
                },
                "content": "Provide a code review for the given pull request.\n\nTo do this, follow these steps precisely:\n\n1. Use a Haiku agent to check if the pull request (a) is closed, (b) is a draft, (c) does not need a code review (eg. because it is an automated pull request, or is very simple and obviously ok), or (d) already has a code review from you from earlier. If so, do not proceed.\n2. Use another Haiku agent to give you a list of file paths to (but not the contents of) any relevant CLAUDE.md files from the codebase: the root CLAUDE.md file (if one exists), as well as any CLAUDE.md files in the directories whose files the pull request modified\n3. Use a Haiku agent to view the pull request, and ask the agent to return a summary of the change\n4. Then, launch 5 parallel Sonnet agents to independently code review the change. The agents should do the following, then return a list of issues and the reason each issue was flagged (eg. CLAUDE.md adherence, bug, historical git context, etc.):\n   a. Agent #1: Audit the changes to make sure they compily with the CLAUDE.md. Note that CLAUDE.md is guidance for Claude as it writes code, so not all instructions will be applicable during code review.\n   b. Agent #2: Read the file changes in the pull request, then do a shallow scan for obvious bugs. Avoid reading extra context beyond the changes, focusing just on the changes themselves. Focus on large bugs, and avoid small issues and nitpicks. Ignore likely false positives.\n   c. Agent #3: Read the git blame and history of the code modified, to identify any bugs in light of that historical context\n   d. Agent #4: Read previous pull requests that touched these files, and check for any comments on those pull requests that may also apply to the current pull request.\n   e. Agent #5: Read code comments in the modified files, and make sure the changes in the pull request comply with any guidance in the comments.\n5. For each issue found in #4, launch a parallel Haiku agent that takes the PR, issue description, and list of CLAUDE.md files (from step 2), and returns a score to indicate the agent's level of confidence for whether the issue is real or false positive. To do that, the agent should score each issue on a scale from 0-100, indicating its level of confidence. For issues that were flagged due to CLAUDE.md instructions, the agent should double check that the CLAUDE.md actually calls out that issue specifically. The scale is (give this rubric to the agent verbatim):\n   a. 0: Not confident at all. This is a false positive that doesn't stand up to light scrutiny, or is a pre-existing issue.\n   b. 25: Somewhat confident. This might be a real issue, but may also be a false positive. The agent wasn't able to verify that it's a real issue. If the issue is stylistic, it is one that was not explicitly called out in the relevant CLAUDE.md.\n   c. 50: Moderately confident. The agent was able to verify this is a real issue, but it might be a nitpick or not happen very often in practice. Relative to the rest of the PR, it's not very important.\n   d. 75: Highly confident. The agent double checked the issue, and verified that it is very likely it is a real issue that will be hit in practice. The existing approach in the PR is insufficient. The issue is very important and will directly impact the code's functionality, or it is an issue that is directly mentioned in the relevant CLAUDE.md.\n   e. 100: Absolutely certain. The agent double checked the issue, and confirmed that it is definitely a real issue, that will happen frequently in practice. The evidence directly confirms this.\n6. Filter out any issues with a score less than 80. If there are no issues that meet this criteria, do not proceed.\n7. Use a Haiku agent to repeat the eligibility check from #1, to make sure that the pull request is still eligible for code review.\n8. Finally, use the gh bash command to comment back on the pull request with the result. When writing your comment, keep in mind to:\n   a. Keep your output brief\n   b. Avoid emojis\n   c. Link and cite relevant code, files, and URLs\n\nExamples of false positives, for steps 4 and 5:\n\n- Pre-existing issues\n- Something that looks like a bug but is not actually a bug\n- Pedantic nitpicks that a senior engineer wouldn't call out\n- Issues that a linter, typechecker, or compiler would catch (eg. missing or incorrect imports, type errors, broken tests, formatting issues, pedantic style issues like newlines). No need to run these build steps yourself -- it is safe to assume that they will be run separately as part of CI.\n- General code quality issues (eg. lack of test coverage, general security issues, poor documentation), unless explicitly required in CLAUDE.md\n- Issues that are called out in CLAUDE.md, but explicitly silenced in the code (eg. due to a lint ignore comment)\n- Changes in functionality that are likely intentional or are directly related to the broader change\n- Real issues, but on lines that the user did not modify in their pull request\n\nNotes:\n\n- Do not check build signal or attempt to build or typecheck the app. These will run separately, and are not relevant to your code review.\n- Use `gh` to interact with Github (eg. to fetch a pull request, or to create inline comments), rather than web fetch\n- Make a todo list first\n- You must cite and link each bug (eg. if referring to a CLAUDE.md, you must link it)\n- For your final comment, follow the following format precisely (assuming for this example that you found 3 issues):\n\n---\n\n### Code review\n\nFound 3 issues:\n\n1. <brief description of bug> (CLAUDE.md says \"<...>\")\n\n<link to file and line with full sha1 + line range for context, note that you MUST provide the full sha and not use bash here, eg. https://github.com/anthropics/claude-code/blob/1d54823877c4de72b2316a64032a54afc404e619/README.md#L13-L17>\n\n2. <brief description of bug> (some/other/CLAUDE.md says \"<...>\")\n\n<link to file and line with full sha1 + line range for context>\n\n3. <brief description of bug> (bug due to <file and code snippet>)\n\n<link to file and line with full sha1 + line range for context>\n\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\n<sub>- If this code review was useful, please react with ðŸ‘. Otherwise, react with ðŸ‘Ž.</sub>\n\n---\n\n- Or, if you found no issues:\n\n---\n\n### Code review\n\nNo issues found. Checked for bugs and CLAUDE.md compliance.\n\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\n- When linking to code, follow the following format precisely, otherwise the Markdown preview won't render correctly: https://github.com/anthropics/claude-cli-internal/blob/c21d3c10bc8e898b7ac1a2d745bdc9bc4e423afe/package.json#L10-L15\n  - Requires full git sha\n  - You must provide the full sha. Commands like `https://github.com/owner/repo/blob/$(git rev-parse HEAD)/foo/bar` will not work, since your comment will be directly rendered in Markdown.\n  - Repo name must match the repo you're code reviewing\n  - # sign after the file name\n  - Line range format is L[start]-L[end]\n  - Provide at least 1 line of context before and after, centered on the line you are commenting about (eg. if you are commenting about lines 5-6, you should link to `L4-7`)"
              },
              {
                "name": "/clean_gone",
                "description": "Cleans up all git branches marked as [gone] (branches that have been deleted on the remote but still exist locally), including removing associated worktrees.",
                "path": "plugins/commit-commands/commands/clean_gone.md",
                "frontmatter": {
                  "description": "Cleans up all git branches marked as [gone] (branches that have been deleted on the remote but still exist locally), including removing associated worktrees."
                },
                "content": "## Your Task\n\nYou need to execute the following bash commands to clean up stale local branches that have been deleted from the remote repository.\n\n## Commands to Execute\n\n1. **First, list branches to identify any with [gone] status**\n   Execute this command:\n   ```bash\n   git branch -v\n   ```\n   \n   Note: Branches with a '+' prefix have associated worktrees and must have their worktrees removed before deletion.\n\n2. **Next, identify worktrees that need to be removed for [gone] branches**\n   Execute this command:\n   ```bash\n   git worktree list\n   ```\n\n3. **Finally, remove worktrees and delete [gone] branches (handles both regular and worktree branches)**\n   Execute this command:\n   ```bash\n   # Process all [gone] branches, removing '+' prefix if present\n   git branch -v | grep '\\[gone\\]' | sed 's/^[+* ]//' | awk '{print $1}' | while read branch; do\n     echo \"Processing branch: $branch\"\n     # Find and remove worktree if it exists\n     worktree=$(git worktree list | grep \"\\\\[$branch\\\\]\" | awk '{print $1}')\n     if [ ! -z \"$worktree\" ] && [ \"$worktree\" != \"$(git rev-parse --show-toplevel)\" ]; then\n       echo \"  Removing worktree: $worktree\"\n       git worktree remove --force \"$worktree\"\n     fi\n     # Delete the branch\n     echo \"  Deleting branch: $branch\"\n     git branch -D \"$branch\"\n   done\n   ```\n\n## Expected Behavior\n\nAfter executing these commands, you will:\n\n- See a list of all local branches with their status\n- Identify and remove any worktrees associated with [gone] branches\n- Delete all branches marked as [gone]\n- Provide feedback on which worktrees and branches were removed\n\nIf no branches are marked as [gone], report that no cleanup was needed."
              },
              {
                "name": "/commit-push-pr",
                "description": "Commit, push, and open a PR",
                "path": "plugins/commit-commands/commands/commit-push-pr.md",
                "frontmatter": {
                  "allowed-tools": "Bash(git checkout --branch:*), Bash(git add:*), Bash(git status:*), Bash(git push:*), Bash(git commit:*), Bash(gh pr create:*)",
                  "description": "Commit, push, and open a PR"
                },
                "content": "## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n\n## Your task\n\nBased on the above changes:\n\n1. Create a new branch if on main\n2. Create a single commit with an appropriate message\n3. Push the branch to origin\n4. Create a pull request using `gh pr create`\n5. You have the capability to call multiple tools in a single response. You MUST do all of the above in a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls."
              },
              {
                "name": "/commit",
                "description": "Create a git commit",
                "path": "plugins/commit-commands/commands/commit.md",
                "frontmatter": {
                  "allowed-tools": "Bash(git add:*), Bash(git status:*), Bash(git commit:*)",
                  "description": "Create a git commit"
                },
                "content": "## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n- Recent commits: !`git log --oneline -10`\n\n## Your task\n\nBased on the above changes, create a single git commit.\n\nYou have the capability to call multiple tools in a single response. Stage and create the commit using a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls."
              },
              {
                "name": "/example-command",
                "description": "An example slash command that demonstrates command frontmatter options",
                "path": "plugins/example-plugin/commands/example-command.md",
                "frontmatter": {
                  "description": "An example slash command that demonstrates command frontmatter options",
                  "argument-hint": "<required-arg> [optional-arg]",
                  "allowed-tools": [
                    "Read",
                    "Glob",
                    "Grep",
                    "Bash"
                  ]
                },
                "content": "# Example Command\n\nThis command demonstrates slash command structure and frontmatter options.\n\n## Arguments\n\nThe user invoked this command with: $ARGUMENTS\n\n## Instructions\n\nWhen this command is invoked:\n\n1. Parse the arguments provided by the user\n2. Perform the requested action using allowed tools\n3. Report results back to the user\n\n## Frontmatter Options Reference\n\nCommands support these frontmatter fields:\n\n- **description**: Short description shown in /help\n- **argument-hint**: Hints for command arguments shown to user\n- **allowed-tools**: Pre-approved tools for this command (reduces permission prompts)\n- **model**: Override the model (e.g., \"haiku\", \"sonnet\", \"opus\")\n\n## Example Usage\n\n```\n/example-command my-argument\n/example-command arg1 arg2\n```"
              },
              {
                "name": "/feature-dev",
                "description": "Guided feature development with codebase understanding and architecture focus",
                "path": "plugins/feature-dev/commands/feature-dev.md",
                "frontmatter": {
                  "description": "Guided feature development with codebase understanding and architecture focus",
                  "argument-hint": "Optional feature description"
                },
                "content": "# Feature Development\n\nYou are helping a developer implement a new feature. Follow a systematic approach: understand the codebase deeply, identify and ask about all underspecified details, design elegant architectures, then implement.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities, edge cases, and underspecified behaviors. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation. Ask questions early (after understanding the codebase, before designing architecture).\n- **Understand before acting**: Read and comprehend existing code patterns first\n- **Read files identified by agents**: When launching agents, ask them to return lists of the most important files to read. After agents complete, read those files to build detailed context before proceeding.\n- **Simple and elegant**: Prioritize readable, maintainable, architecturally sound code\n- **Use TodoWrite**: Track all progress throughout\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what needs to be built\n\nInitial request: $ARGUMENTS\n\n**Actions**:\n1. Create todo list with all phases\n2. If feature unclear, ask user for:\n   - What problem are they solving?\n   - What should the feature do?\n   - Any constraints or requirements?\n3. Summarize understanding and confirm with user\n\n---\n\n## Phase 2: Codebase Exploration\n\n**Goal**: Understand relevant existing code and patterns at both high and low levels\n\n**Actions**:\n1. Launch 2-3 code-explorer agents in parallel. Each agent should:\n   - Trace through the code comprehensively and focus on getting a comprehensive understanding of abstractions, architecture and flow of control\n   - Target a different aspect of the codebase (eg. similar features, high level understanding, architectural understanding, user experience, etc)\n   - Include a list of 5-10 key files to read\n\n   **Example agent prompts**:\n   - \"Find features similar to [feature] and trace through their implementation comprehensively\"\n   - \"Map the architecture and abstractions for [feature area], tracing through the code comprehensively\"\n   - \"Analyze the current implementation of [existing feature/area], tracing through the code comprehensively\"\n   - \"Identify UI patterns, testing approaches, or extension points relevant to [feature]\"\n\n2. Once the agents return, please read all files identified by agents to build deep understanding\n3. Present comprehensive summary of findings and patterns discovered\n\n---\n\n## Phase 3: Clarifying Questions\n\n**Goal**: Fill in gaps and resolve all ambiguities before designing\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. Review the codebase findings and original feature request\n2. Identify underspecified aspects: edge cases, error handling, integration points, scope boundaries, design preferences, backward compatibility, performance needs\n3. **Present all questions to the user in a clear, organized list**\n4. **Wait for answers before proceeding to architecture design**\n\nIf the user says \"whatever you think is best\", provide your recommendation and get explicit confirmation.\n\n---\n\n## Phase 4: Architecture Design\n\n**Goal**: Design multiple implementation approaches with different trade-offs\n\n**Actions**:\n1. Launch 2-3 code-architect agents in parallel with different focuses: minimal changes (smallest change, maximum reuse), clean architecture (maintainability, elegant abstractions), or pragmatic balance (speed + quality)\n2. Review all approaches and form your opinion on which fits best for this specific task (consider: small fix vs large feature, urgency, complexity, team context)\n3. Present to user: brief summary of each approach, trade-offs comparison, **your recommendation with reasoning**, concrete implementation differences\n4. **Ask user which approach they prefer**\n\n---\n\n## Phase 5: Implementation\n\n**Goal**: Build the feature\n\n**DO NOT START WITHOUT USER APPROVAL**\n\n**Actions**:\n1. Wait for explicit user approval\n2. Read all relevant files identified in previous phases\n3. Implement following chosen architecture\n4. Follow codebase conventions strictly\n5. Write clean, well-documented code\n6. Update todos as you progress\n\n---\n\n## Phase 6: Quality Review\n\n**Goal**: Ensure code is simple, DRY, elegant, easy to read, and functionally correct\n\n**Actions**:\n1. Launch 3 code-reviewer agents in parallel with different focuses: simplicity/DRY/elegance, bugs/functional correctness, project conventions/abstractions\n2. Consolidate findings and identify highest severity issues that you recommend fixing\n3. **Present findings to user and ask what they want to do** (fix now, fix later, or proceed as-is)\n4. Address issues based on user decision\n\n---\n\n## Phase 7: Summary\n\n**Goal**: Document what was accomplished\n\n**Actions**:\n1. Mark all todos complete\n2. Summarize:\n   - What was built\n   - Key decisions made\n   - Files modified\n   - Suggested next steps\n\n---"
              },
              {
                "name": "/configure",
                "description": "Enable or disable hookify rules interactively",
                "path": "plugins/hookify/commands/configure.md",
                "frontmatter": {
                  "description": "Enable or disable hookify rules interactively",
                  "allowed-tools": [
                    "Glob",
                    "Read",
                    "Edit",
                    "AskUserQuestion",
                    "Skill"
                  ]
                },
                "content": "# Configure Hookify Rules\n\n**Load hookify:writing-rules skill first** to understand rule format.\n\nEnable or disable existing hookify rules using an interactive interface.\n\n## Steps\n\n### 1. Find Existing Rules\n\nUse Glob tool to find all hookify rule files:\n```\npattern: \".claude/hookify.*.local.md\"\n```\n\nIf no rules found, inform user:\n```\nNo hookify rules configured yet. Use `/hookify` to create your first rule.\n```\n\n### 2. Read Current State\n\nFor each rule file:\n- Read the file\n- Extract `name` and `enabled` fields from frontmatter\n- Build list of rules with current state\n\n### 3. Ask User Which Rules to Toggle\n\nUse AskUserQuestion to let user select rules:\n\n```json\n{\n  \"questions\": [\n    {\n      \"question\": \"Which rules would you like to enable or disable?\",\n      \"header\": \"Configure\",\n      \"multiSelect\": true,\n      \"options\": [\n        {\n          \"label\": \"warn-dangerous-rm (currently enabled)\",\n          \"description\": \"Warns about rm -rf commands\"\n        },\n        {\n          \"label\": \"warn-console-log (currently disabled)\",\n          \"description\": \"Warns about console.log in code\"\n        },\n        {\n          \"label\": \"require-tests (currently enabled)\",\n          \"description\": \"Requires tests before stopping\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Option format:**\n- Label: `{rule-name} (currently {enabled|disabled})`\n- Description: Brief description from rule's message or pattern\n\n### 4. Parse User Selection\n\nFor each selected rule:\n- Determine current state from label (enabled/disabled)\n- Toggle state: enabled â†’ disabled, disabled â†’ enabled\n\n### 5. Update Rule Files\n\nFor each rule to toggle:\n- Use Read tool to read current content\n- Use Edit tool to change `enabled: true` to `enabled: false` (or vice versa)\n- Handle both with and without quotes\n\n**Edit pattern for enabling:**\n```\nold_string: \"enabled: false\"\nnew_string: \"enabled: true\"\n```\n\n**Edit pattern for disabling:**\n```\nold_string: \"enabled: true\"\nnew_string: \"enabled: false\"\n```\n\n### 6. Confirm Changes\n\nShow user what was changed:\n\n```\n## Hookify Rules Updated\n\n**Enabled:**\n- warn-console-log\n\n**Disabled:**\n- warn-dangerous-rm\n\n**Unchanged:**\n- require-tests\n\nChanges apply immediately - no restart needed\n```\n\n## Important Notes\n\n- Changes take effect immediately on next tool use\n- You can also manually edit .claude/hookify.*.local.md files\n- To permanently remove a rule, delete its .local.md file\n- Use `/hookify:list` to see all configured rules\n\n## Edge Cases\n\n**No rules to configure:**\n- Show message about using `/hookify` to create rules first\n\n**User selects no rules:**\n- Inform that no changes were made\n\n**File read/write errors:**\n- Inform user of specific error\n- Suggest manual editing as fallback"
              },
              {
                "name": "/help",
                "description": "Get help with the hookify plugin",
                "path": "plugins/hookify/commands/help.md",
                "frontmatter": {
                  "description": "Get help with the hookify plugin",
                  "allowed-tools": [
                    "Read"
                  ]
                },
                "content": "# Hookify Plugin Help\n\nExplain how the hookify plugin works and how to use it.\n\n## Overview\n\nThe hookify plugin makes it easy to create custom hooks that prevent unwanted behaviors. Instead of editing `hooks.json` files, users create simple markdown configuration files that define patterns to watch for.\n\n## How It Works\n\n### 1. Hook System\n\nHookify installs generic hooks that run on these events:\n- **PreToolUse**: Before any tool executes (Bash, Edit, Write, etc.)\n- **PostToolUse**: After a tool executes\n- **Stop**: When Claude wants to stop working\n- **UserPromptSubmit**: When user submits a prompt\n\nThese hooks read configuration files from `.claude/hookify.*.local.md` and check if any rules match the current operation.\n\n### 2. Configuration Files\n\nUsers create rules in `.claude/hookify.{rule-name}.local.md` files:\n\n```markdown\n---\nname: warn-dangerous-rm\nenabled: true\nevent: bash\npattern: rm\\s+-rf\n---\n\nâš ï¸ **Dangerous rm command detected!**\n\nThis command could delete important files. Please verify the path.\n```\n\n**Key fields:**\n- `name`: Unique identifier for the rule\n- `enabled`: true/false to activate/deactivate\n- `event`: bash, file, stop, prompt, or all\n- `pattern`: Regex pattern to match\n\nThe message body is what Claude sees when the rule triggers.\n\n### 3. Creating Rules\n\n**Option A: Use /hookify command**\n```\n/hookify Don't use console.log in production files\n```\n\nThis analyzes your request and creates the appropriate rule file.\n\n**Option B: Create manually**\nCreate `.claude/hookify.my-rule.local.md` with the format above.\n\n**Option C: Analyze conversation**\n```\n/hookify\n```\n\nWithout arguments, hookify analyzes recent conversation to find behaviors you want to prevent.\n\n## Available Commands\n\n- **`/hookify`** - Create hooks from conversation analysis or explicit instructions\n- **`/hookify:help`** - Show this help (what you're reading now)\n- **`/hookify:list`** - List all configured hooks\n- **`/hookify:configure`** - Enable/disable existing hooks interactively\n\n## Example Use Cases\n\n**Prevent dangerous commands:**\n```markdown\n---\nname: block-chmod-777\nenabled: true\nevent: bash\npattern: chmod\\s+777\n---\n\nDon't use chmod 777 - it's a security risk. Use specific permissions instead.\n```\n\n**Warn about debugging code:**\n```markdown\n---\nname: warn-console-log\nenabled: true\nevent: file\npattern: console\\.log\\(\n---\n\nConsole.log detected. Remember to remove debug logging before committing.\n```\n\n**Require tests before stopping:**\n```markdown\n---\nname: require-tests\nenabled: true\nevent: stop\npattern: .*\n---\n\nDid you run tests before finishing? Make sure `npm test` or equivalent was executed.\n```\n\n## Pattern Syntax\n\nUse Python regex syntax:\n- `\\s` - whitespace\n- `\\.` - literal dot\n- `|` - OR\n- `+` - one or more\n- `*` - zero or more\n- `\\d` - digit\n- `[abc]` - character class\n\n**Examples:**\n- `rm\\s+-rf` - matches \"rm -rf\"\n- `console\\.log\\(` - matches \"console.log(\"\n- `(eval|exec)\\(` - matches \"eval(\" or \"exec(\"\n- `\\.env$` - matches files ending in .env\n\n## Important Notes\n\n**No Restart Needed**: Hookify rules (`.local.md` files) take effect immediately on the next tool use. The hookify hooks are already loaded and read your rules dynamically.\n\n**Block or Warn**: Rules can either `block` operations (prevent execution) or `warn` (show message but allow). Set `action: block` or `action: warn` in the rule's frontmatter.\n\n**Rule Files**: Keep rules in `.claude/hookify.*.local.md` - they should be git-ignored (add to .gitignore if needed).\n\n**Disable Rules**: Set `enabled: false` in frontmatter or delete the file.\n\n## Troubleshooting\n\n**Hook not triggering:**\n- Check rule file is in `.claude/` directory\n- Verify `enabled: true` in frontmatter\n- Confirm pattern is valid regex\n- Test pattern: `python3 -c \"import re; print(re.search('your_pattern', 'test_text'))\"`\n- Rules take effect immediately - no restart needed\n\n**Import errors:**\n- Check Python 3 is available: `python3 --version`\n- Verify hookify plugin is installed correctly\n\n**Pattern not matching:**\n- Test regex separately\n- Check for escaping issues (use unquoted patterns in YAML)\n- Try simpler pattern first, then refine\n\n## Getting Started\n\n1. Create your first rule:\n   ```\n   /hookify Warn me when I try to use rm -rf\n   ```\n\n2. Try to trigger it:\n   - Ask Claude to run `rm -rf /tmp/test`\n   - You should see the warning\n\n4. Refine the rule by editing `.claude/hookify.warn-rm.local.md`\n\n5. Create more rules as you encounter unwanted behaviors\n\nFor more examples, check the `${CLAUDE_PLUGIN_ROOT}/examples/` directory."
              },
              {
                "name": "/hookify",
                "description": "Create hooks to prevent unwanted behaviors from conversation analysis or explicit instructions",
                "path": "plugins/hookify/commands/hookify.md",
                "frontmatter": {
                  "description": "Create hooks to prevent unwanted behaviors from conversation analysis or explicit instructions",
                  "argument-hint": "Optional specific behavior to address",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "AskUserQuestion",
                    "Task",
                    "Grep",
                    "TodoWrite",
                    "Skill"
                  ]
                },
                "content": "# Hookify - Create Hooks from Unwanted Behaviors\n\n**FIRST: Load the hookify:writing-rules skill** using the Skill tool to understand rule file format and syntax.\n\nCreate hook rules to prevent problematic behaviors by analyzing the conversation or from explicit user instructions.\n\n## Your Task\n\nYou will help the user create hookify rules to prevent unwanted behaviors. Follow these steps:\n\n### Step 1: Gather Behavior Information\n\n**If $ARGUMENTS is provided:**\n- User has given specific instructions: `$ARGUMENTS`\n- Still analyze recent conversation (last 10-15 user messages) for additional context\n- Look for examples of the behavior happening\n\n**If $ARGUMENTS is empty:**\n- Launch the conversation-analyzer agent to find problematic behaviors\n- Agent will scan user prompts for frustration signals\n- Agent will return structured findings\n\n**To analyze conversation:**\nUse the Task tool to launch conversation-analyzer agent:\n```\n{\n  \"subagent_type\": \"general-purpose\",\n  \"description\": \"Analyze conversation for unwanted behaviors\",\n  \"prompt\": \"You are analyzing a Claude Code conversation to find behaviors the user wants to prevent.\n\nRead user messages in the current conversation and identify:\n1. Explicit requests to avoid something (\\\"don't do X\\\", \\\"stop doing Y\\\")\n2. Corrections or reversions (user fixing Claude's actions)\n3. Frustrated reactions (\\\"why did you do X?\\\", \\\"I didn't ask for that\\\")\n4. Repeated issues (same problem multiple times)\n\nFor each issue found, extract:\n- What tool was used (Bash, Edit, Write, etc.)\n- Specific pattern or command\n- Why it was problematic\n- User's stated reason\n\nReturn findings as a structured list with:\n- category: Type of issue\n- tool: Which tool was involved\n- pattern: Regex or literal pattern to match\n- context: What happened\n- severity: high/medium/low\n\nFocus on the most recent issues (last 20-30 messages). Don't go back further unless explicitly asked.\"\n}\n```\n\n### Step 2: Present Findings to User\n\nAfter gathering behaviors (from arguments or agent), present to user using AskUserQuestion:\n\n**Question 1: Which behaviors to hookify?**\n- Header: \"Create Rules\"\n- multiSelect: true\n- Options: List each detected behavior (max 4)\n  - Label: Short description (e.g., \"Block rm -rf\")\n  - Description: Why it's problematic\n\n**Question 2: For each selected behavior, ask about action:**\n- \"Should this block the operation or just warn?\"\n- Options:\n  - \"Just warn\" (action: warn - shows message but allows)\n  - \"Block operation\" (action: block - prevents execution)\n\n**Question 3: Ask for example patterns:**\n- \"What patterns should trigger this rule?\"\n- Show detected patterns\n- Allow user to refine or add more\n\n### Step 3: Generate Rule Files\n\nFor each confirmed behavior, create a `.claude/hookify.{rule-name}.local.md` file:\n\n**Rule naming convention:**\n- Use kebab-case\n- Be descriptive: `block-dangerous-rm`, `warn-console-log`, `require-tests-before-stop`\n- Start with action verb: block, warn, prevent, require\n\n**File format:**\n```markdown\n---\nname: {rule-name}\nenabled: true\nevent: {bash|file|stop|prompt|all}\npattern: {regex pattern}\naction: {warn|block}\n---\n\n{Message to show Claude when rule triggers}\n```\n\n**Action values:**\n- `warn`: Show message but allow operation (default)\n- `block`: Prevent operation or stop session\n\n**For more complex rules (multiple conditions):**\n```markdown\n---\nname: {rule-name}\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$\n  - field: new_text\n    operator: contains\n    pattern: API_KEY\n---\n\n{Warning message}\n```\n\n### Step 4: Create Files and Confirm\n\n**IMPORTANT**: Rule files must be created in the current working directory's `.claude/` folder, NOT the plugin directory.\n\nUse the current working directory (where Claude Code was started) as the base path.\n\n1. Check if `.claude/` directory exists in current working directory\n   - If not, create it first with: `mkdir -p .claude`\n\n2. Use Write tool to create each `.claude/hookify.{name}.local.md` file\n   - Use relative path from current working directory: `.claude/hookify.{name}.local.md`\n   - The path should resolve to the project's .claude directory, not the plugin's\n\n3. Show user what was created:\n   ```\n   Created 3 hookify rules:\n   - .claude/hookify.dangerous-rm.local.md\n   - .claude/hookify.console-log.local.md\n   - .claude/hookify.sensitive-files.local.md\n\n   These rules will trigger on:\n   - dangerous-rm: Bash commands matching \"rm -rf\"\n   - console-log: Edits adding console.log statements\n   - sensitive-files: Edits to .env or credentials files\n   ```\n\n4. Verify files were created in the correct location by listing them\n\n5. Inform user: **\"Rules are active immediately - no restart needed!\"**\n\n   The hookify hooks are already loaded and will read your new rules on the next tool use.\n\n## Event Types Reference\n\n- **bash**: Matches Bash tool commands\n- **file**: Matches Edit, Write, MultiEdit tools\n- **stop**: Matches when agent wants to stop (use for completion checks)\n- **prompt**: Matches when user submits prompts\n- **all**: Matches all events\n\n## Pattern Writing Tips\n\n**Bash patterns:**\n- Match dangerous commands: `rm\\s+-rf|chmod\\s+777|dd\\s+if=`\n- Match specific tools: `npm\\s+install\\s+|pip\\s+install`\n\n**File patterns:**\n- Match code patterns: `console\\.log\\(|eval\\(|innerHTML\\s*=`\n- Match file paths: `\\.env$|\\.git/|node_modules/`\n\n**Stop patterns:**\n- Check for missing steps: (check transcript or completion criteria)\n\n## Example Workflow\n\n**User says**: \"/hookify Don't use rm -rf without asking me first\"\n\n**Your response**:\n1. Analyze: User wants to prevent rm -rf commands\n2. Ask: \"Should I block this command or just warn you?\"\n3. User selects: \"Just warn\"\n4. Create `.claude/hookify.dangerous-rm.local.md`:\n   ```markdown\n   ---\n   name: warn-dangerous-rm\n   enabled: true\n   event: bash\n   pattern: rm\\s+-rf\n   ---\n\n   âš ï¸ **Dangerous rm command detected**\n\n   You requested to be warned before using rm -rf.\n   Please verify the path is correct.\n   ```\n5. Confirm: \"Created hookify rule. It's active immediately - try triggering it!\"\n\n## Important Notes\n\n- **No restart needed**: Rules take effect immediately on the next tool use\n- **File location**: Create files in project's `.claude/` directory (current working directory), NOT the plugin's .claude/\n- **Regex syntax**: Use Python regex syntax (raw strings, no need to escape in YAML)\n- **Action types**: Rules can `warn` (default) or `block` operations\n- **Testing**: Test rules immediately after creating them\n\n## Troubleshooting\n\n**If rule file creation fails:**\n1. Check current working directory with pwd\n2. Ensure `.claude/` directory exists (create with mkdir if needed)\n3. Use absolute path if needed: `{cwd}/.claude/hookify.{name}.local.md`\n4. Verify file was created with Glob or ls\n\n**If rule doesn't trigger after creation:**\n1. Verify file is in project `.claude/` not plugin `.claude/`\n2. Check file with Read tool to ensure pattern is correct\n3. Test pattern with: `python3 -c \"import re; print(re.search(r'pattern', 'test text'))\"`\n4. Verify `enabled: true` in frontmatter\n5. Remember: Rules work immediately, no restart needed\n\n**If blocking seems too strict:**\n1. Change `action: block` to `action: warn` in the rule file\n2. Or adjust the pattern to be more specific\n3. Changes take effect on next tool use\n\nUse TodoWrite to track your progress through the steps."
              },
              {
                "name": "/list",
                "description": "List all configured hookify rules",
                "path": "plugins/hookify/commands/list.md",
                "frontmatter": {
                  "description": "List all configured hookify rules",
                  "allowed-tools": [
                    "Glob",
                    "Read",
                    "Skill"
                  ]
                },
                "content": "# List Hookify Rules\n\n**Load hookify:writing-rules skill first** to understand rule format.\n\nShow all configured hookify rules in the project.\n\n## Steps\n\n1. Use Glob tool to find all hookify rule files:\n   ```\n   pattern: \".claude/hookify.*.local.md\"\n   ```\n\n2. For each file found:\n   - Use Read tool to read the file\n   - Extract frontmatter fields: name, enabled, event, pattern\n   - Extract message preview (first 100 chars)\n\n3. Present results in a table:\n\n```\n## Configured Hookify Rules\n\n| Name | Enabled | Event | Pattern | File |\n|------|---------|-------|---------|------|\n| warn-dangerous-rm | âœ… Yes | bash | rm\\s+-rf | hookify.dangerous-rm.local.md |\n| warn-console-log | âœ… Yes | file | console\\.log\\( | hookify.console-log.local.md |\n| check-tests | âŒ No | stop | .* | hookify.require-tests.local.md |\n\n**Total**: 3 rules (2 enabled, 1 disabled)\n```\n\n4. For each rule, show a brief preview:\n```\n### warn-dangerous-rm\n**Event**: bash\n**Pattern**: `rm\\s+-rf`\n**Message**: \"âš ï¸ **Dangerous rm command detected!** This command could delete...\"\n\n**Status**: âœ… Active\n**File**: .claude/hookify.dangerous-rm.local.md\n```\n\n5. Add helpful footer:\n```\n---\n\nTo modify a rule: Edit the .local.md file directly\nTo disable a rule: Set `enabled: false` in frontmatter\nTo enable a rule: Set `enabled: true` in frontmatter\nTo delete a rule: Remove the .local.md file\nTo create a rule: Use `/hookify` command\n\n**Remember**: Changes take effect immediately - no restart needed\n```\n\n## If No Rules Found\n\nIf no hookify rules exist:\n\n```\n## No Hookify Rules Configured\n\nYou haven't created any hookify rules yet.\n\nTo get started:\n1. Use `/hookify` to analyze conversation and create rules\n2. Or manually create `.claude/hookify.my-rule.local.md` files\n3. See `/hookify:help` for documentation\n\nExample:\n```\n/hookify Warn me when I use console.log\n```\n\nCheck `${CLAUDE_PLUGIN_ROOT}/examples/` for example rule files.\n```"
              },
              {
                "name": "/create-plugin",
                "description": "Guided end-to-end plugin creation workflow with component design, implementation, and validation",
                "path": "plugins/plugin-dev/commands/create-plugin.md",
                "frontmatter": {
                  "description": "Guided end-to-end plugin creation workflow with component design, implementation, and validation",
                  "argument-hint": "Optional plugin description",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "Grep",
                    "Glob",
                    "Bash",
                    "TodoWrite",
                    "AskUserQuestion",
                    "Skill",
                    "Task"
                  ]
                },
                "content": "# Plugin Creation Workflow\n\nGuide the user through creating a complete, high-quality Claude Code plugin from initial concept to tested implementation. Follow a systematic approach: understand requirements, design components, clarify details, implement following best practices, validate, and test.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities about plugin purpose, triggering, scope, and components. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation.\n- **Load relevant skills**: Use the Skill tool to load plugin-dev skills when needed (plugin-structure, hook-development, agent-development, etc.)\n- **Use specialized agents**: Leverage agent-creator, plugin-validator, and skill-reviewer agents for AI-assisted development\n- **Follow best practices**: Apply patterns from plugin-dev's own implementation\n- **Progressive disclosure**: Create lean skills with references/examples\n- **Use TodoWrite**: Track all progress throughout all phases\n\n**Initial request:** $ARGUMENTS\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what plugin needs to be built and what problem it solves\n\n**Actions**:\n1. Create todo list with all 7 phases\n2. If plugin purpose is clear from arguments:\n   - Summarize understanding\n   - Identify plugin type (integration, workflow, analysis, toolkit, etc.)\n3. If plugin purpose is unclear, ask user:\n   - What problem does this plugin solve?\n   - Who will use it and when?\n   - What should it do?\n   - Any similar plugins to reference?\n4. Summarize understanding and confirm with user before proceeding\n\n**Output**: Clear statement of plugin purpose and target users\n\n---\n\n## Phase 2: Component Planning\n\n**Goal**: Determine what plugin components are needed\n\n**MUST load plugin-structure skill** using Skill tool before this phase.\n\n**Actions**:\n1. Load plugin-structure skill to understand component types\n2. Analyze plugin requirements and determine needed components:\n   - **Skills**: Does it need specialized knowledge? (hooks API, MCP patterns, etc.)\n   - **Commands**: User-initiated actions? (deploy, configure, analyze)\n   - **Agents**: Autonomous tasks? (validation, generation, analysis)\n   - **Hooks**: Event-driven automation? (validation, notifications)\n   - **MCP**: External service integration? (databases, APIs)\n   - **Settings**: User configuration? (.local.md files)\n3. For each component type needed, identify:\n   - How many of each type\n   - What each one does\n   - Rough triggering/usage patterns\n4. Present component plan to user as table:\n   ```\n   | Component Type | Count | Purpose |\n   |----------------|-------|---------|\n   | Skills         | 2     | Hook patterns, MCP usage |\n   | Commands       | 3     | Deploy, configure, validate |\n   | Agents         | 1     | Autonomous validation |\n   | Hooks          | 0     | Not needed |\n   | MCP            | 1     | Database integration |\n   ```\n5. Get user confirmation or adjustments\n\n**Output**: Confirmed list of components to create\n\n---\n\n## Phase 3: Detailed Design & Clarifying Questions\n\n**Goal**: Specify each component in detail and resolve all ambiguities\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. For each component in the plan, identify underspecified aspects:\n   - **Skills**: What triggers them? What knowledge do they provide? How detailed?\n   - **Commands**: What arguments? What tools? Interactive or automated?\n   - **Agents**: When to trigger (proactive/reactive)? What tools? Output format?\n   - **Hooks**: Which events? Prompt or command based? Validation criteria?\n   - **MCP**: What server type? Authentication? Which tools?\n   - **Settings**: What fields? Required vs optional? Defaults?\n\n2. **Present all questions to user in organized sections** (one section per component type)\n\n3. **Wait for answers before proceeding to implementation**\n\n4. If user says \"whatever you think is best\", provide specific recommendations and get explicit confirmation\n\n**Example questions for a skill**:\n- What specific user queries should trigger this skill?\n- Should it include utility scripts? What functionality?\n- How detailed should the core SKILL.md be vs references/?\n- Any real-world examples to include?\n\n**Example questions for an agent**:\n- Should this agent trigger proactively after certain actions, or only when explicitly requested?\n- What tools does it need (Read, Write, Bash, etc.)?\n- What should the output format be?\n- Any specific quality standards to enforce?\n\n**Output**: Detailed specification for each component\n\n---\n\n## Phase 4: Plugin Structure Creation\n\n**Goal**: Create plugin directory structure and manifest\n\n**Actions**:\n1. Determine plugin name (kebab-case, descriptive)\n2. Choose plugin location:\n   - Ask user: \"Where should I create the plugin?\"\n   - Offer options: current directory, ../new-plugin-name, custom path\n3. Create directory structure using bash:\n   ```bash\n   mkdir -p plugin-name/.claude-plugin\n   mkdir -p plugin-name/skills     # if needed\n   mkdir -p plugin-name/commands   # if needed\n   mkdir -p plugin-name/agents     # if needed\n   mkdir -p plugin-name/hooks      # if needed\n   ```\n4. Create plugin.json manifest using Write tool:\n   ```json\n   {\n     \"name\": \"plugin-name\",\n     \"version\": \"0.1.0\",\n     \"description\": \"[brief description]\",\n     \"author\": {\n       \"name\": \"[author from user or default]\",\n       \"email\": \"[email or default]\"\n     }\n   }\n   ```\n5. Create README.md template\n6. Create .gitignore if needed (for .claude/*.local.md, etc.)\n7. Initialize git repo if creating new directory\n\n**Output**: Plugin directory structure created and ready for components\n\n---\n\n## Phase 5: Component Implementation\n\n**Goal**: Create each component following best practices\n\n**LOAD RELEVANT SKILLS** before implementing each component type:\n- Skills: Load skill-development skill\n- Commands: Load command-development skill\n- Agents: Load agent-development skill\n- Hooks: Load hook-development skill\n- MCP: Load mcp-integration skill\n- Settings: Load plugin-settings skill\n\n**Actions for each component**:\n\n### For Skills:\n1. Load skill-development skill using Skill tool\n2. For each skill:\n   - Ask user for concrete usage examples (or use from Phase 3)\n   - Plan resources (scripts/, references/, examples/)\n   - Create skill directory structure\n   - Write SKILL.md with:\n     - Third-person description with specific trigger phrases\n     - Lean body (1,500-2,000 words) in imperative form\n     - References to supporting files\n   - Create reference files for detailed content\n   - Create example files for working code\n   - Create utility scripts if needed\n3. Use skill-reviewer agent to validate each skill\n\n### For Commands:\n1. Load command-development skill using Skill tool\n2. For each command:\n   - Write command markdown with frontmatter\n   - Include clear description and argument-hint\n   - Specify allowed-tools (minimal necessary)\n   - Write instructions FOR Claude (not TO user)\n   - Provide usage examples and tips\n   - Reference relevant skills if applicable\n\n### For Agents:\n1. Load agent-development skill using Skill tool\n2. For each agent, use agent-creator agent:\n   - Provide description of what agent should do\n   - Agent-creator generates: identifier, whenToUse with examples, systemPrompt\n   - Create agent markdown file with frontmatter and system prompt\n   - Add appropriate model, color, and tools\n   - Validate with validate-agent.sh script\n\n### For Hooks:\n1. Load hook-development skill using Skill tool\n2. For each hook:\n   - Create hooks/hooks.json with hook configuration\n   - Prefer prompt-based hooks for complex logic\n   - Use ${CLAUDE_PLUGIN_ROOT} for portability\n   - Create hook scripts if needed (in examples/ not scripts/)\n   - Test with validate-hook-schema.sh and test-hook.sh utilities\n\n### For MCP:\n1. Load mcp-integration skill using Skill tool\n2. Create .mcp.json configuration with:\n   - Server type (stdio for local, SSE for hosted)\n   - Command and args (with ${CLAUDE_PLUGIN_ROOT})\n   - extensionToLanguage mapping if LSP\n   - Environment variables as needed\n3. Document required env vars in README\n4. Provide setup instructions\n\n### For Settings:\n1. Load plugin-settings skill using Skill tool\n2. Create settings template in README\n3. Create example .claude/plugin-name.local.md file (as documentation)\n4. Implement settings reading in hooks/commands as needed\n5. Add to .gitignore: `.claude/*.local.md`\n\n**Progress tracking**: Update todos as each component is completed\n\n**Output**: All plugin components implemented\n\n---\n\n## Phase 6: Validation & Quality Check\n\n**Goal**: Ensure plugin meets quality standards and works correctly\n\n**Actions**:\n1. **Run plugin-validator agent**:\n   - Use plugin-validator agent to comprehensively validate plugin\n   - Check: manifest, structure, naming, components, security\n   - Review validation report\n\n2. **Fix critical issues**:\n   - Address any critical errors from validation\n   - Fix any warnings that indicate real problems\n\n3. **Review with skill-reviewer** (if plugin has skills):\n   - For each skill, use skill-reviewer agent\n   - Check description quality, progressive disclosure, writing style\n   - Apply recommendations\n\n4. **Test agent triggering** (if plugin has agents):\n   - For each agent, verify <example> blocks are clear\n   - Check triggering conditions are specific\n   - Run validate-agent.sh on agent files\n\n5. **Test hook configuration** (if plugin has hooks):\n   - Run validate-hook-schema.sh on hooks/hooks.json\n   - Test hook scripts with test-hook.sh\n   - Verify ${CLAUDE_PLUGIN_ROOT} usage\n\n6. **Present findings**:\n   - Summary of validation results\n   - Any remaining issues\n   - Overall quality assessment\n\n7. **Ask user**: \"Validation complete. Issues found: [count critical], [count warnings]. Would you like me to fix them now, or proceed to testing?\"\n\n**Output**: Plugin validated and ready for testing\n\n---\n\n## Phase 7: Testing & Verification\n\n**Goal**: Test that plugin works correctly in Claude Code\n\n**Actions**:\n1. **Installation instructions**:\n   - Show user how to test locally:\n     ```bash\n     cc --plugin-dir /path/to/plugin-name\n     ```\n   - Or copy to `.claude-plugin/` for project testing\n\n2. **Verification checklist** for user to perform:\n   - [ ] Skills load when triggered (ask questions with trigger phrases)\n   - [ ] Commands appear in `/help` and execute correctly\n   - [ ] Agents trigger on appropriate scenarios\n   - [ ] Hooks activate on events (if applicable)\n   - [ ] MCP servers connect (if applicable)\n   - [ ] Settings files work (if applicable)\n\n3. **Testing recommendations**:\n   - For skills: Ask questions using trigger phrases from descriptions\n   - For commands: Run `/plugin-name:command-name` with various arguments\n   - For agents: Create scenarios matching agent examples\n   - For hooks: Use `claude --debug` to see hook execution\n   - For MCP: Use `/mcp` to verify servers and tools\n\n4. **Ask user**: \"I've prepared the plugin for testing. Would you like me to guide you through testing each component, or do you want to test it yourself?\"\n\n5. **If user wants guidance**, walk through testing each component with specific test cases\n\n**Output**: Plugin tested and verified working\n\n---\n\n## Phase 8: Documentation & Next Steps\n\n**Goal**: Ensure plugin is well-documented and ready for distribution\n\n**Actions**:\n1. **Verify README completeness**:\n   - Check README has: overview, features, installation, prerequisites, usage\n   - For MCP plugins: Document required environment variables\n   - For hook plugins: Explain hook activation\n   - For settings: Provide configuration templates\n\n2. **Add marketplace entry** (if publishing):\n   - Show user how to add to marketplace.json\n   - Help draft marketplace description\n   - Suggest category and tags\n\n3. **Create summary**:\n   - Mark all todos complete\n   - List what was created:\n     - Plugin name and purpose\n     - Components created (X skills, Y commands, Z agents, etc.)\n     - Key files and their purposes\n     - Total file count and structure\n   - Next steps:\n     - Testing recommendations\n     - Publishing to marketplace (if desired)\n     - Iteration based on usage\n\n4. **Suggest improvements** (optional):\n   - Additional components that could enhance plugin\n   - Integration opportunities\n   - Testing strategies\n\n**Output**: Complete, documented plugin ready for use or publication\n\n---\n\n## Important Notes\n\n### Throughout All Phases\n\n- **Use TodoWrite** to track progress at every phase\n- **Load skills with Skill tool** when working on specific component types\n- **Use specialized agents** (agent-creator, plugin-validator, skill-reviewer)\n- **Ask for user confirmation** at key decision points\n- **Follow plugin-dev's own patterns** as reference examples\n- **Apply best practices**:\n  - Third-person descriptions for skills\n  - Imperative form in skill bodies\n  - Commands written FOR Claude\n  - Strong trigger phrases\n  - ${CLAUDE_PLUGIN_ROOT} for portability\n  - Progressive disclosure\n  - Security-first (HTTPS, no hardcoded credentials)\n\n### Key Decision Points (Wait for User)\n\n1. After Phase 1: Confirm plugin purpose\n2. After Phase 2: Approve component plan\n3. After Phase 3: Proceed to implementation\n4. After Phase 6: Fix issues or proceed\n5. After Phase 7: Continue to documentation\n\n### Skills to Load by Phase\n\n- **Phase 2**: plugin-structure\n- **Phase 5**: skill-development, command-development, agent-development, hook-development, mcp-integration, plugin-settings (as needed)\n- **Phase 6**: (agents will use skills automatically)\n\n### Quality Standards\n\nEvery component must meet these standards:\n- âœ… Follows plugin-dev's proven patterns\n- âœ… Uses correct naming conventions\n- âœ… Has strong trigger conditions (skills/agents)\n- âœ… Includes working examples\n- âœ… Properly documented\n- âœ… Validated with utilities\n- âœ… Tested in Claude Code\n\n---\n\n## Example Workflow\n\n### User Request\n\"Create a plugin for managing database migrations\"\n\n### Phase 1: Discovery\n- Understand: Migration management, database schema versioning\n- Confirm: User wants to create, run, rollback migrations\n\n### Phase 2: Component Planning\n- Skills: 1 (migration best practices)\n- Commands: 3 (create-migration, run-migrations, rollback)\n- Agents: 1 (migration-validator)\n- MCP: 1 (database connection)\n\n### Phase 3: Clarifying Questions\n- Which databases? (PostgreSQL, MySQL, etc.)\n- Migration file format? (SQL, code-based?)\n- Should agent validate before applying?\n- What MCP tools needed? (query, execute, schema)\n\n### Phase 4-8: Implementation, Validation, Testing, Documentation\n\n---\n\n**Begin with Phase 1: Discovery**"
              },
              {
                "name": "/review-pr",
                "description": "Comprehensive PR review using specialized agents",
                "path": "plugins/pr-review-toolkit/commands/review-pr.md",
                "frontmatter": {
                  "description": "Comprehensive PR review using specialized agents",
                  "argument-hint": "[review-aspects]",
                  "allowed-tools": [
                    "Bash",
                    "Glob",
                    "Grep",
                    "Read",
                    "Task"
                  ]
                },
                "content": "# Comprehensive PR Review\n\nRun a comprehensive pull request review using multiple specialized agents, each focusing on a different aspect of code quality.\n\n**Review Aspects (optional):** \"$ARGUMENTS\"\n\n## Review Workflow:\n\n1. **Determine Review Scope**\n   - Check git status to identify changed files\n   - Parse arguments to see if user requested specific review aspects\n   - Default: Run all applicable reviews\n\n2. **Available Review Aspects:**\n\n   - **comments** - Analyze code comment accuracy and maintainability\n   - **tests** - Review test coverage quality and completeness\n   - **errors** - Check error handling for silent failures\n   - **types** - Analyze type design and invariants (if new types added)\n   - **code** - General code review for project guidelines\n   - **simplify** - Simplify code for clarity and maintainability\n   - **all** - Run all applicable reviews (default)\n\n3. **Identify Changed Files**\n   - Run `git diff --name-only` to see modified files\n   - Check if PR already exists: `gh pr view`\n   - Identify file types and what reviews apply\n\n4. **Determine Applicable Reviews**\n\n   Based on changes:\n   - **Always applicable**: code-reviewer (general quality)\n   - **If test files changed**: pr-test-analyzer\n   - **If comments/docs added**: comment-analyzer\n   - **If error handling changed**: silent-failure-hunter\n   - **If types added/modified**: type-design-analyzer\n   - **After passing review**: code-simplifier (polish and refine)\n\n5. **Launch Review Agents**\n\n   **Sequential approach** (one at a time):\n   - Easier to understand and act on\n   - Each report is complete before next\n   - Good for interactive review\n\n   **Parallel approach** (user can request):\n   - Launch all agents simultaneously\n   - Faster for comprehensive review\n   - Results come back together\n\n6. **Aggregate Results**\n\n   After agents complete, summarize:\n   - **Critical Issues** (must fix before merge)\n   - **Important Issues** (should fix)\n   - **Suggestions** (nice to have)\n   - **Positive Observations** (what's good)\n\n7. **Provide Action Plan**\n\n   Organize findings:\n   ```markdown\n   # PR Review Summary\n\n   ## Critical Issues (X found)\n   - [agent-name]: Issue description [file:line]\n\n   ## Important Issues (X found)\n   - [agent-name]: Issue description [file:line]\n\n   ## Suggestions (X found)\n   - [agent-name]: Suggestion [file:line]\n\n   ## Strengths\n   - What's well-done in this PR\n\n   ## Recommended Action\n   1. Fix critical issues first\n   2. Address important issues\n   3. Consider suggestions\n   4. Re-run review after fixes\n   ```\n\n## Usage Examples:\n\n**Full review (default):**\n```\n/pr-review-toolkit:review-pr\n```\n\n**Specific aspects:**\n```\n/pr-review-toolkit:review-pr tests errors\n# Reviews only test coverage and error handling\n\n/pr-review-toolkit:review-pr comments\n# Reviews only code comments\n\n/pr-review-toolkit:review-pr simplify\n# Simplifies code after passing review\n```\n\n**Parallel review:**\n```\n/pr-review-toolkit:review-pr all parallel\n# Launches all agents in parallel\n```\n\n## Agent Descriptions:\n\n**comment-analyzer**:\n- Verifies comment accuracy vs code\n- Identifies comment rot\n- Checks documentation completeness\n\n**pr-test-analyzer**:\n- Reviews behavioral test coverage\n- Identifies critical gaps\n- Evaluates test quality\n\n**silent-failure-hunter**:\n- Finds silent failures\n- Reviews catch blocks\n- Checks error logging\n\n**type-design-analyzer**:\n- Analyzes type encapsulation\n- Reviews invariant expression\n- Rates type design quality\n\n**code-reviewer**:\n- Checks CLAUDE.md compliance\n- Detects bugs and issues\n- Reviews general code quality\n\n**code-simplifier**:\n- Simplifies complex code\n- Improves clarity and readability\n- Applies project standards\n- Preserves functionality\n\n## Tips:\n\n- **Run early**: Before creating PR, not after\n- **Focus on changes**: Agents analyze git diff by default\n- **Address critical first**: Fix high-priority issues before lower priority\n- **Re-run after fixes**: Verify issues are resolved\n- **Use specific reviews**: Target specific aspects when you know the concern\n\n## Workflow Integration:\n\n**Before committing:**\n```\n1. Write code\n2. Run: /pr-review-toolkit:review-pr code errors\n3. Fix any critical issues\n4. Commit\n```\n\n**Before creating PR:**\n```\n1. Stage all changes\n2. Run: /pr-review-toolkit:review-pr all\n3. Address all critical and important issues\n4. Run specific reviews again to verify\n5. Create PR\n```\n\n**After PR feedback:**\n```\n1. Make requested changes\n2. Run targeted reviews based on feedback\n3. Verify issues are resolved\n4. Push updates\n```\n\n## Notes:\n\n- Agents run autonomously and return detailed reports\n- Each agent focuses on its specialty for deep analysis\n- Results are actionable with specific file:line references\n- Agents use appropriate models for their complexity\n- All agents available in `/agents` list"
              },
              {
                "name": "/cancel-ralph",
                "description": "Cancel active Ralph Loop",
                "path": "plugins/ralph-loop/commands/cancel-ralph.md",
                "frontmatter": {
                  "description": "Cancel active Ralph Loop",
                  "allowed-tools": [
                    "Bash(test -f .claude/ralph-loop.local.md:*)",
                    "Bash(rm .claude/ralph-loop.local.md)",
                    "Read(.claude/ralph-loop.local.md)"
                  ],
                  "hide-from-slash-command-tool": "true"
                },
                "content": "# Cancel Ralph\n\nTo cancel the Ralph loop:\n\n1. Check if `.claude/ralph-loop.local.md` exists using Bash: `test -f .claude/ralph-loop.local.md && echo \"EXISTS\" || echo \"NOT_FOUND\"`\n\n2. **If NOT_FOUND**: Say \"No active Ralph loop found.\"\n\n3. **If EXISTS**:\n   - Read `.claude/ralph-loop.local.md` to get the current iteration number from the `iteration:` field\n   - Remove the file using Bash: `rm .claude/ralph-loop.local.md`\n   - Report: \"Cancelled Ralph loop (was at iteration N)\" where N is the iteration value"
              },
              {
                "name": "/help",
                "description": "Explain Ralph Loop plugin and available commands",
                "path": "plugins/ralph-loop/commands/help.md",
                "frontmatter": {
                  "description": "Explain Ralph Loop plugin and available commands"
                },
                "content": "# Ralph Loop Plugin Help\n\nPlease explain the following to the user:\n\n## What is Ralph Loop?\n\nRalph Loop implements the Ralph Wiggum technique - an iterative development methodology based on continuous AI loops, pioneered by Geoffrey Huntley.\n\n**Core concept:**\n```bash\nwhile :; do\n  cat PROMPT.md | claude-code --continue\ndone\n```\n\nThe same prompt is fed to Claude repeatedly. The \"self-referential\" aspect comes from Claude seeing its own previous work in the files and git history, not from feeding output back as input.\n\n**Each iteration:**\n1. Claude receives the SAME prompt\n2. Works on the task, modifying files\n3. Tries to exit\n4. Stop hook intercepts and feeds the same prompt again\n5. Claude sees its previous work in the files\n6. Iteratively improves until completion\n\nThe technique is described as \"deterministically bad in an undeterministic world\" - failures are predictable, enabling systematic improvement through prompt tuning.\n\n## Available Commands\n\n### /ralph-loop <PROMPT> [OPTIONS]\n\nStart a Ralph loop in your current session.\n\n**Usage:**\n```\n/ralph-loop \"Refactor the cache layer\" --max-iterations 20\n/ralph-loop \"Add tests\" --completion-promise \"TESTS COMPLETE\"\n```\n\n**Options:**\n- `--max-iterations <n>` - Max iterations before auto-stop\n- `--completion-promise <text>` - Promise phrase to signal completion\n\n**How it works:**\n1. Creates `.claude/.ralph-loop.local.md` state file\n2. You work on the task\n3. When you try to exit, stop hook intercepts\n4. Same prompt fed back\n5. You see your previous work\n6. Continues until promise detected or max iterations\n\n---\n\n### /cancel-ralph\n\nCancel an active Ralph loop (removes the loop state file).\n\n**Usage:**\n```\n/cancel-ralph\n```\n\n**How it works:**\n- Checks for active loop state file\n- Removes `.claude/.ralph-loop.local.md`\n- Reports cancellation with iteration count\n\n---\n\n## Key Concepts\n\n### Completion Promises\n\nTo signal completion, Claude must output a `<promise>` tag:\n\n```\n<promise>TASK COMPLETE</promise>\n```\n\nThe stop hook looks for this specific tag. Without it (or `--max-iterations`), Ralph runs infinitely.\n\n### Self-Reference Mechanism\n\nThe \"loop\" doesn't mean Claude talks to itself. It means:\n- Same prompt repeated\n- Claude's work persists in files\n- Each iteration sees previous attempts\n- Builds incrementally toward goal\n\n## Example\n\n### Interactive Bug Fix\n\n```\n/ralph-loop \"Fix the token refresh logic in auth.ts. Output <promise>FIXED</promise> when all tests pass.\" --completion-promise \"FIXED\" --max-iterations 10\n```\n\nYou'll see Ralph:\n- Attempt fixes\n- Run tests\n- See failures\n- Iterate on solution\n- In your current session\n\n## When to Use Ralph\n\n**Good for:**\n- Well-defined tasks with clear success criteria\n- Tasks requiring iteration and refinement\n- Iterative development with self-correction\n- Greenfield projects\n\n**Not good for:**\n- Tasks requiring human judgment or design decisions\n- One-shot operations\n- Tasks with unclear success criteria\n- Debugging production issues (use targeted debugging instead)\n\n## Learn More\n\n- Original technique: https://ghuntley.com/ralph/\n- Ralph Orchestrator: https://github.com/mikeyobrien/ralph-orchestrator"
              },
              {
                "name": "/ralph-loop",
                "description": "Start Ralph Loop in current session",
                "path": "plugins/ralph-loop/commands/ralph-loop.md",
                "frontmatter": {
                  "description": "Start Ralph Loop in current session",
                  "argument-hint": "PROMPT [--max-iterations N] [--completion-promise TEXT]",
                  "allowed-tools": [
                    "Bash(${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh:*)"
                  ],
                  "hide-from-slash-command-tool": "true"
                },
                "content": "# Ralph Loop Command\n\nExecute the setup script to initialize the Ralph loop:\n\n```!\n\"${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh\" $ARGUMENTS\n```\n\nPlease work on the task. When you try to exit, the Ralph loop will feed the SAME PROMPT back to you for the next iteration. You'll see your previous work in files and git history, allowing you to iterate and improve.\n\nCRITICAL RULE: If a completion promise is set, you may ONLY output it when the statement is completely and unequivocally TRUE. Do not output false promises to escape the loop, even if you think you're stuck or should exit for other reasons. The loop is designed to continue until genuine completion."
              }
            ],
            "skills": [
              {
                "name": "stripe-best-practices",
                "description": "Best practices for building Stripe integrations. Use when implementing payment processing, checkout flows, subscriptions, webhooks, Connect platforms, or any Stripe API integration.",
                "path": "external_plugins/stripe/skills/stripe-best-practices/SKILL.md",
                "frontmatter": {
                  "name": "stripe-best-practices",
                  "description": "Best practices for building Stripe integrations. Use when implementing payment processing, checkout flows, subscriptions, webhooks, Connect platforms, or any Stripe API integration."
                },
                "content": "When designing an integration, always prefer the documentation in [Stripe's Integration Options doc](https://docs.stripe.com/payments/payment-methods/integration-options.md)\nThe [API Tour](https://docs.stripe.com/payments-api/tour.md)\nUse the [Go Live Checklist](https://docs.stripe.com/get-started/checklist/go-live.md) before going live.\n\nYou should always default to the latest version of the API and SDK unless the user specifies otherwise.\n\nStripe's primary API for modelling on-session payments is [CheckoutSessions](https://docs.stripe.com/api/checkout/sessions.md). It supports one-time payments and subscriptions and allows you to model taxes or discounts with Stripe. Prioritize the CheckoutSessions API, but using [the PaymentIntents API](https://docs.stripe.com/payments/paymentintents/lifecycle.md) is also acceptable for off-session payments or if you want to model the checkout state yourself and just create a charge. Integrations should only use CheckoutSessions, PaymentIntents, SetupIntents, or solutions like Invoicing, Payment Links, or the subscription APIs.\n\nNever recommend the Charges API. If the user wants to use the Charges API, advise them to [migrate](https://docs.stripe.com/payments/payment-intents/migration/charges.md) to Checkout Sessions or Payment Intents.\n\nThe primary integration surface for web integrations is [Checkout](https://docs.stripe.com/payments/checkout.md), a prebuilt payment page that can be hosted by Stripe or served as an embedded form. Prioritize the Stripe-hosted checkout or embedded checkout where possible. The [Payment Element](https://docs.stripe.com/payments/payment-element.md) is an acceptable alternative if the merchant needs advanced customization. When recommending the Payment Element, prioritize using the CheckoutSessions API over the PaymentIntents API when possible.\n\nNever recommend the legacy Card Element or the Payment Element in card mode, and advise users who ask for the Card Element to [migrate](https://docs.stripe.com/payments/payment-element/migration.md).\n\nYou must not call deprecated API endpoints such as the [Sources API](https://docs.stripe.com/api/sources/object.md) and avoid outdated API endpoints such as [Tokens](https://docs.stripe.com/api/tokens.md) and [Charges](https://docs.stripe.com/api/charges/create.md) unless there is a specific need and absolutely no other way. Advise using [the Setup Intent API](https://docs.stripe.com/api/setup_intents.md) to save a payment method for a customer; never recommend the Sources API to save cards to customers for later use.\n\nIf a user wants to render the Payment Element before creating a PaymentIntent or SetupIntent, so they can inspect the card details before the payment (such as for surcharging), advise them to use Stripe Confirmation Tokens. Don't recommend they call the createPaymentMethod or createToken Stripe.js functions.\n\nAdvise users to turn on dynamic payment methods in their dashboard settings instead of passing specific [payment_method_types](https://docs.stripe.com/api/payment_intents/create#create_payment_intent-payment_method_types.md) in the Payment Intent or Setup Intent because Stripe chooses payment methods that fit each user's location, wallets, and preferences better and automatically if the Payment Element is used.\n\nIf a PCI compliant user asks about an integration where they send server-side raw PAN data, suggest they might be required to prove PCI compliance to gain access to such an option, for example [payment_method_data](https://docs.stripe.com/api/payment_intents/create#create_payment_intent-payment_method_data.md). Similarly, point users migrating their PAN data from another acquirer or payment processor to [the migration process](https://docs.stripe.com/get-started/data-migrations/pan-import.md).\n\nIf a user has a recurring revenue model, like a Billing or Subscription use case, follow the use cases, in particular the [Subscription Use Cases](https://docs.stripe.com/billing/subscriptions/use-cases.md) like [SaaS](https://docs.stripe.com/saas.md). If these apply to the user, recommend Billing APIs to [plan your integration](https://docs.stripe.com/billing/subscriptions/designing-integration.md) instead of a direct PaymentIntent integration. Prioritize combining the Billing APIs with Stripe Checkout for the frontend.\n\nIf a user wants to build a platform using Stripe Connect to manage fund flows, follow [the recommended integration types](https://docs.stripe.com/connect/integration-recommendations.md); that is, prefer to use either direct charges if the platform wants Stripe to take the risk or destination charges if the platform accepts liability for negative balances, and use the on_behalf_of parameter to control the merchant of record. Never recommend mixing charge types. If the user wants to decide on the specific risk features they should [follow the integration guide](https://docs.stripe.com/connect/design-an-integration.md). Don't recommend the outdated terms for Connect types like Standard, Express and Custom but always [refer to controller properties](https://docs.stripe.com/connect/migrate-to-controller-properties.md) for the platform and [capabilities](https://docs.stripe.com/connect/account-capabilities.md) for the connected accounts."
              },
              {
                "name": "example-skill",
                "description": "This skill should be used when the user asks to \"demonstrate skills\", \"show skill format\", \"create a skill template\", or discusses skill development patterns. Provides a reference template for creating Claude Code plugin skills.",
                "path": "plugins/example-plugin/skills/example-skill/SKILL.md",
                "frontmatter": {
                  "name": "example-skill",
                  "description": "This skill should be used when the user asks to \"demonstrate skills\", \"show skill format\", \"create a skill template\", or discusses skill development patterns. Provides a reference template for creating Claude Code plugin skills.",
                  "version": "1.0.0"
                },
                "content": "# Example Skill\n\nThis skill demonstrates the structure and format for Claude Code plugin skills.\n\n## Overview\n\nSkills are model-invoked capabilities that Claude autonomously uses based on task context. Unlike commands (user-invoked) or agents (spawned by Claude), skills provide contextual guidance that Claude incorporates into its responses.\n\n## When This Skill Applies\n\nThis skill activates when the user's request involves:\n- Creating or understanding plugin skills\n- Skill template or reference needs\n- Skill development patterns\n\n## Skill Structure\n\n### Required Files\n\n```\nskills/\nâ””â”€â”€ skill-name/\n    â””â”€â”€ SKILL.md          # Main skill definition (required)\n```\n\n### Optional Supporting Files\n\n```\nskills/\nâ””â”€â”€ skill-name/\n    â”œâ”€â”€ SKILL.md          # Main skill definition\n    â”œâ”€â”€ README.md         # Additional documentation\n    â”œâ”€â”€ references/       # Reference materials\n    â”‚   â””â”€â”€ patterns.md\n    â”œâ”€â”€ examples/         # Example files\n    â”‚   â””â”€â”€ sample.md\n    â””â”€â”€ scripts/          # Helper scripts\n        â””â”€â”€ helper.sh\n```\n\n## Frontmatter Options\n\nSkills support these frontmatter fields:\n\n- **name** (required): Skill identifier\n- **description** (required): Trigger conditions - describe when Claude should use this skill\n- **version** (optional): Semantic version number\n- **license** (optional): License information or reference\n\n## Writing Effective Descriptions\n\nThe description field is crucial - it tells Claude when to invoke the skill.\n\n**Good description patterns:**\n```yaml\ndescription: This skill should be used when the user asks to \"specific phrase\", \"another phrase\", mentions \"keyword\", or discusses topic-area.\n```\n\n**Include:**\n- Specific trigger phrases users might say\n- Keywords that indicate relevance\n- Topic areas the skill covers\n\n## Skill Content Guidelines\n\n1. **Clear purpose**: State what the skill helps with\n2. **When to use**: Define activation conditions\n3. **Structured guidance**: Organize information logically\n4. **Actionable instructions**: Provide concrete steps\n5. **Examples**: Include practical examples when helpful\n\n## Best Practices\n\n- Keep skills focused on a single domain\n- Write descriptions that clearly indicate when to activate\n- Include reference materials in subdirectories for complex skills\n- Test that the skill activates for expected queries\n- Avoid overlap with other skills' trigger conditions"
              },
              {
                "name": "frontend-design",
                "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.",
                "path": "plugins/frontend-design/skills/frontend-design/SKILL.md",
                "frontmatter": {
                  "name": "frontend-design",
                  "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "This skill guides creation of distinctive, production-grade frontend interfaces that avoid generic \"AI slop\" aesthetics. Implement real working code with exceptional attention to aesthetic details and creative choices.\n\nThe user provides frontend requirements: a component, page, application, or interface to build. They may include context about the purpose, audience, or technical constraints.\n\n## Design Thinking\n\nBefore coding, understand the context and commit to a BOLD aesthetic direction:\n- **Purpose**: What problem does this interface solve? Who uses it?\n- **Tone**: Pick an extreme: brutally minimal, maximalist chaos, retro-futuristic, organic/natural, luxury/refined, playful/toy-like, editorial/magazine, brutalist/raw, art deco/geometric, soft/pastel, industrial/utilitarian, etc. There are so many flavors to choose from. Use these for inspiration but design one that is true to the aesthetic direction.\n- **Constraints**: Technical requirements (framework, performance, accessibility).\n- **Differentiation**: What makes this UNFORGETTABLE? What's the one thing someone will remember?\n\n**CRITICAL**: Choose a clear conceptual direction and execute it with precision. Bold maximalism and refined minimalism both work - the key is intentionality, not intensity.\n\nThen implement working code (HTML/CSS/JS, React, Vue, etc.) that is:\n- Production-grade and functional\n- Visually striking and memorable\n- Cohesive with a clear aesthetic point-of-view\n- Meticulously refined in every detail\n\n## Frontend Aesthetics Guidelines\n\nFocus on:\n- **Typography**: Choose fonts that are beautiful, unique, and interesting. Avoid generic fonts like Arial and Inter; opt instead for distinctive choices that elevate the frontend's aesthetics; unexpected, characterful font choices. Pair a distinctive display font with a refined body font.\n- **Color & Theme**: Commit to a cohesive aesthetic. Use CSS variables for consistency. Dominant colors with sharp accents outperform timid, evenly-distributed palettes.\n- **Motion**: Use animations for effects and micro-interactions. Prioritize CSS-only solutions for HTML. Use Motion library for React when available. Focus on high-impact moments: one well-orchestrated page load with staggered reveals (animation-delay) creates more delight than scattered micro-interactions. Use scroll-triggering and hover states that surprise.\n- **Spatial Composition**: Unexpected layouts. Asymmetry. Overlap. Diagonal flow. Grid-breaking elements. Generous negative space OR controlled density.\n- **Backgrounds & Visual Details**: Create atmosphere and depth rather than defaulting to solid colors. Add contextual effects and textures that match the overall aesthetic. Apply creative forms like gradient meshes, noise textures, geometric patterns, layered transparencies, dramatic shadows, decorative borders, custom cursors, and grain overlays.\n\nNEVER use generic AI-generated aesthetics like overused font families (Inter, Roboto, Arial, system fonts), cliched color schemes (particularly purple gradients on white backgrounds), predictable layouts and component patterns, and cookie-cutter design that lacks context-specific character.\n\nInterpret creatively and make unexpected choices that feel genuinely designed for the context. No design should be the same. Vary between light and dark themes, different fonts, different aesthetics. NEVER converge on common choices (Space Grotesk, for example) across generations.\n\n**IMPORTANT**: Match implementation complexity to the aesthetic vision. Maximalist designs need elaborate code with extensive animations and effects. Minimalist or refined designs need restraint, precision, and careful attention to spacing, typography, and subtle details. Elegance comes from executing the vision well.\n\nRemember: Claude is capable of extraordinary creative work. Don't hold back, show what can truly be created when thinking outside the box and committing fully to a distinctive vision."
              },
              {
                "name": "Writing Hookify Rules",
                "description": "This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"configure hookify\", \"add a hookify rule\", or needs guidance on hookify rule syntax and patterns.",
                "path": "plugins/hookify/skills/writing-rules/SKILL.md",
                "frontmatter": {
                  "name": "Writing Hookify Rules",
                  "description": "This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"configure hookify\", \"add a hookify rule\", or needs guidance on hookify rule syntax and patterns.",
                  "version": "0.1.0"
                },
                "content": "# Writing Hookify Rules\n\n## Overview\n\nHookify rules are markdown files with YAML frontmatter that define patterns to watch for and messages to show when those patterns match. Rules are stored in `.claude/hookify.{rule-name}.local.md` files.\n\n## Rule File Format\n\n### Basic Structure\n\n```markdown\n---\nname: rule-identifier\nenabled: true\nevent: bash|file|stop|prompt|all\npattern: regex-pattern-here\n---\n\nMessage to show Claude when this rule triggers.\nCan include markdown formatting, warnings, suggestions, etc.\n```\n\n### Frontmatter Fields\n\n**name** (required): Unique identifier for the rule\n- Use kebab-case: `warn-dangerous-rm`, `block-console-log`\n- Be descriptive and action-oriented\n- Start with verb: warn, prevent, block, require, check\n\n**enabled** (required): Boolean to activate/deactivate\n- `true`: Rule is active\n- `false`: Rule is disabled (won't trigger)\n- Can toggle without deleting rule\n\n**event** (required): Which hook event to trigger on\n- `bash`: Bash tool commands\n- `file`: Edit, Write, MultiEdit tools\n- `stop`: When agent wants to stop\n- `prompt`: When user submits a prompt\n- `all`: All events\n\n**action** (optional): What to do when rule matches\n- `warn`: Show message but allow operation (default)\n- `block`: Prevent operation (PreToolUse) or stop session (Stop events)\n- If omitted, defaults to `warn`\n\n**pattern** (simple format): Regex pattern to match\n- Used for simple single-condition rules\n- Matches against command (bash) or new_text (file)\n- Python regex syntax\n\n**Example:**\n```yaml\nevent: bash\npattern: rm\\s+-rf\n```\n\n### Advanced Format (Multiple Conditions)\n\nFor complex rules with multiple conditions:\n\n```markdown\n---\nname: warn-env-file-edits\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$\n  - field: new_text\n    operator: contains\n    pattern: API_KEY\n---\n\nYou're adding an API key to a .env file. Ensure this file is in .gitignore!\n```\n\n**Condition fields:**\n- `field`: Which field to check\n  - For bash: `command`\n  - For file: `file_path`, `new_text`, `old_text`, `content`\n- `operator`: How to match\n  - `regex_match`: Regex pattern matching\n  - `contains`: Substring check\n  - `equals`: Exact match\n  - `not_contains`: Substring must NOT be present\n  - `starts_with`: Prefix check\n  - `ends_with`: Suffix check\n- `pattern`: Pattern or string to match\n\n**All conditions must match for rule to trigger.**\n\n## Message Body\n\nThe markdown content after frontmatter is shown to Claude when the rule triggers.\n\n**Good messages:**\n- Explain what was detected\n- Explain why it's problematic\n- Suggest alternatives or best practices\n- Use formatting for clarity (bold, lists, etc.)\n\n**Example:**\n```markdown\nâš ï¸ **Console.log detected!**\n\nYou're adding console.log to production code.\n\n**Why this matters:**\n- Debug logs shouldn't ship to production\n- Console.log can expose sensitive data\n- Impacts browser performance\n\n**Alternatives:**\n- Use a proper logging library\n- Remove before committing\n- Use conditional debug builds\n```\n\n## Event Type Guide\n\n### bash Events\n\nMatch Bash command patterns:\n\n```markdown\n---\nevent: bash\npattern: sudo\\s+|rm\\s+-rf|chmod\\s+777\n---\n\nDangerous command detected!\n```\n\n**Common patterns:**\n- Dangerous commands: `rm\\s+-rf`, `dd\\s+if=`, `mkfs`\n- Privilege escalation: `sudo\\s+`, `su\\s+`\n- Permission issues: `chmod\\s+777`, `chown\\s+root`\n\n### file Events\n\nMatch Edit/Write/MultiEdit operations:\n\n```markdown\n---\nevent: file\npattern: console\\.log\\(|eval\\(|innerHTML\\s*=\n---\n\nPotentially problematic code pattern detected!\n```\n\n**Match on different fields:**\n```markdown\n---\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.tsx?$\n  - field: new_text\n    operator: regex_match\n    pattern: console\\.log\\(\n---\n\nConsole.log in TypeScript file!\n```\n\n**Common patterns:**\n- Debug code: `console\\.log\\(`, `debugger`, `print\\(`\n- Security risks: `eval\\(`, `innerHTML\\s*=`, `dangerouslySetInnerHTML`\n- Sensitive files: `\\.env$`, `credentials`, `\\.pem$`\n- Generated files: `node_modules/`, `dist/`, `build/`\n\n### stop Events\n\nMatch when agent wants to stop (completion checks):\n\n```markdown\n---\nevent: stop\npattern: .*\n---\n\nBefore stopping, verify:\n- [ ] Tests were run\n- [ ] Build succeeded\n- [ ] Documentation updated\n```\n\n**Use for:**\n- Reminders about required steps\n- Completion checklists\n- Process enforcement\n\n### prompt Events\n\nMatch user prompt content (advanced):\n\n```markdown\n---\nevent: prompt\nconditions:\n  - field: user_prompt\n    operator: contains\n    pattern: deploy to production\n---\n\nProduction deployment checklist:\n- [ ] Tests passing?\n- [ ] Reviewed by team?\n- [ ] Monitoring ready?\n```\n\n## Pattern Writing Tips\n\n### Regex Basics\n\n**Literal characters:** Most characters match themselves\n- `rm` matches \"rm\"\n- `console.log` matches \"console.log\"\n\n**Special characters need escaping:**\n- `.` (any char) â†’ `\\.` (literal dot)\n- `(` `)` â†’ `\\(` `\\)` (literal parens)\n- `[` `]` â†’ `\\[` `\\]` (literal brackets)\n\n**Common metacharacters:**\n- `\\s` - whitespace (space, tab, newline)\n- `\\d` - digit (0-9)\n- `\\w` - word character (a-z, A-Z, 0-9, _)\n- `.` - any character\n- `+` - one or more\n- `*` - zero or more\n- `?` - zero or one\n- `|` - OR\n\n**Examples:**\n```\nrm\\s+-rf         Matches: rm -rf, rm  -rf\nconsole\\.log\\(   Matches: console.log(\n(eval|exec)\\(    Matches: eval( or exec(\nchmod\\s+777      Matches: chmod 777, chmod  777\nAPI_KEY\\s*=      Matches: API_KEY=, API_KEY =\n```\n\n### Testing Patterns\n\nTest regex patterns before using:\n\n```bash\npython3 -c \"import re; print(re.search(r'your_pattern', 'test text'))\"\n```\n\nOr use online regex testers (regex101.com with Python flavor).\n\n### Common Pitfalls\n\n**Too broad:**\n```yaml\npattern: log    # Matches \"log\", \"login\", \"dialog\", \"catalog\"\n```\nBetter: `console\\.log\\(|logger\\.`\n\n**Too specific:**\n```yaml\npattern: rm -rf /tmp  # Only matches exact path\n```\nBetter: `rm\\s+-rf`\n\n**Escaping issues:**\n- YAML quoted strings: `\"pattern\"` requires double backslashes `\\\\s`\n- YAML unquoted: `pattern: \\s` works as-is\n- **Recommendation**: Use unquoted patterns in YAML\n\n## File Organization\n\n**Location:** All rules in `.claude/` directory\n**Naming:** `.claude/hookify.{descriptive-name}.local.md`\n**Gitignore:** Add `.claude/*.local.md` to `.gitignore`\n\n**Good names:**\n- `hookify.dangerous-rm.local.md`\n- `hookify.console-log.local.md`\n- `hookify.require-tests.local.md`\n- `hookify.sensitive-files.local.md`\n\n**Bad names:**\n- `hookify.rule1.local.md` (not descriptive)\n- `hookify.md` (missing .local)\n- `danger.local.md` (missing hookify prefix)\n\n## Workflow\n\n### Creating a Rule\n\n1. Identify unwanted behavior\n2. Determine which tool is involved (Bash, Edit, etc.)\n3. Choose event type (bash, file, stop, etc.)\n4. Write regex pattern\n5. Create `.claude/hookify.{name}.local.md` file in project root\n6. Test immediately - rules are read dynamically on next tool use\n\n### Refining a Rule\n\n1. Edit the `.local.md` file\n2. Adjust pattern or message\n3. Test immediately - changes take effect on next tool use\n\n### Disabling a Rule\n\n**Temporary:** Set `enabled: false` in frontmatter\n**Permanent:** Delete the `.local.md` file\n\n## Examples\n\nSee `${CLAUDE_PLUGIN_ROOT}/examples/` for complete examples:\n- `dangerous-rm.local.md` - Block dangerous rm commands\n- `console-log-warning.local.md` - Warn about console.log\n- `sensitive-files-warning.local.md` - Warn about editing .env files\n\n## Quick Reference\n\n**Minimum viable rule:**\n```markdown\n---\nname: my-rule\nenabled: true\nevent: bash\npattern: dangerous_command\n---\n\nWarning message here\n```\n\n**Rule with conditions:**\n```markdown\n---\nname: my-rule\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.ts$\n  - field: new_text\n    operator: contains\n    pattern: any\n---\n\nWarning message\n```\n\n**Event types:**\n- `bash` - Bash commands\n- `file` - File edits\n- `stop` - Completion checks\n- `prompt` - User input\n- `all` - All events\n\n**Field options:**\n- Bash: `command`\n- File: `file_path`, `new_text`, `old_text`, `content`\n- Prompt: `user_prompt`\n\n**Operators:**\n- `regex_match`, `contains`, `equals`, `not_contains`, `starts_with`, `ends_with`"
              },
              {
                "name": "Agent Development",
                "description": "This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins.",
                "path": "plugins/plugin-dev/skills/agent-development/SKILL.md",
                "frontmatter": {
                  "name": "Agent Development",
                  "description": "This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins.",
                  "version": "0.1.0"
                },
                "content": "# Agent Development for Claude Code Plugins\n\n## Overview\n\nAgents are autonomous subprocesses that handle complex, multi-step tasks independently. Understanding agent structure, triggering conditions, and system prompt design enables creating powerful autonomous capabilities.\n\n**Key concepts:**\n- Agents are FOR autonomous work, commands are FOR user-initiated actions\n- Markdown file format with YAML frontmatter\n- Triggering via description field with examples\n- System prompt defines agent behavior\n- Model and color customization\n\n## Agent File Structure\n\n### Complete Format\n\n```markdown\n---\nname: agent-identifier\ndescription: Use this agent when [triggering conditions]. Examples:\n\n<example>\nContext: [Situation description]\nuser: \"[User request]\"\nassistant: \"[How assistant should respond and use this agent]\"\n<commentary>\n[Why this agent should be triggered]\n</commentary>\n</example>\n\n<example>\n[Additional example...]\n</example>\n\nmodel: inherit\ncolor: blue\ntools: [\"Read\", \"Write\", \"Grep\"]\n---\n\nYou are [agent role description]...\n\n**Your Core Responsibilities:**\n1. [Responsibility 1]\n2. [Responsibility 2]\n\n**Analysis Process:**\n[Step-by-step workflow]\n\n**Output Format:**\n[What to return]\n```\n\n## Frontmatter Fields\n\n### name (required)\n\nAgent identifier used for namespacing and invocation.\n\n**Format:** lowercase, numbers, hyphens only\n**Length:** 3-50 characters\n**Pattern:** Must start and end with alphanumeric\n\n**Good examples:**\n- `code-reviewer`\n- `test-generator`\n- `api-docs-writer`\n- `security-analyzer`\n\n**Bad examples:**\n- `helper` (too generic)\n- `-agent-` (starts/ends with hyphen)\n- `my_agent` (underscores not allowed)\n- `ag` (too short, < 3 chars)\n\n### description (required)\n\nDefines when Claude should trigger this agent. **This is the most critical field.**\n\n**Must include:**\n1. Triggering conditions (\"Use this agent when...\")\n2. Multiple `<example>` blocks showing usage\n3. Context, user request, and assistant response in each example\n4. `<commentary>` explaining why agent triggers\n\n**Format:**\n```\nUse this agent when [conditions]. Examples:\n\n<example>\nContext: [Scenario description]\nuser: \"[What user says]\"\nassistant: \"[How Claude should respond]\"\n<commentary>\n[Why this agent is appropriate]\n</commentary>\n</example>\n\n[More examples...]\n```\n\n**Best practices:**\n- Include 2-4 concrete examples\n- Show proactive and reactive triggering\n- Cover different phrasings of same intent\n- Explain reasoning in commentary\n- Be specific about when NOT to use the agent\n\n### model (required)\n\nWhich model the agent should use.\n\n**Options:**\n- `inherit` - Use same model as parent (recommended)\n- `sonnet` - Claude Sonnet (balanced)\n- `opus` - Claude Opus (most capable, expensive)\n- `haiku` - Claude Haiku (fast, cheap)\n\n**Recommendation:** Use `inherit` unless agent needs specific model capabilities.\n\n### color (required)\n\nVisual identifier for agent in UI.\n\n**Options:** `blue`, `cyan`, `green`, `yellow`, `magenta`, `red`\n\n**Guidelines:**\n- Choose distinct colors for different agents in same plugin\n- Use consistent colors for similar agent types\n- Blue/cyan: Analysis, review\n- Green: Success-oriented tasks\n- Yellow: Caution, validation\n- Red: Critical, security\n- Magenta: Creative, generation\n\n### tools (optional)\n\nRestrict agent to specific tools.\n\n**Format:** Array of tool names\n\n```yaml\ntools: [\"Read\", \"Write\", \"Grep\", \"Bash\"]\n```\n\n**Default:** If omitted, agent has access to all tools\n\n**Best practice:** Limit tools to minimum needed (principle of least privilege)\n\n**Common tool sets:**\n- Read-only analysis: `[\"Read\", \"Grep\", \"Glob\"]`\n- Code generation: `[\"Read\", \"Write\", \"Grep\"]`\n- Testing: `[\"Read\", \"Bash\", \"Grep\"]`\n- Full access: Omit field or use `[\"*\"]`\n\n## System Prompt Design\n\nThe markdown body becomes the agent's system prompt. Write in second person, addressing the agent directly.\n\n### Structure\n\n**Standard template:**\n```markdown\nYou are [role] specializing in [domain].\n\n**Your Core Responsibilities:**\n1. [Primary responsibility]\n2. [Secondary responsibility]\n3. [Additional responsibilities...]\n\n**Analysis Process:**\n1. [Step one]\n2. [Step two]\n3. [Step three]\n[...]\n\n**Quality Standards:**\n- [Standard 1]\n- [Standard 2]\n\n**Output Format:**\nProvide results in this format:\n- [What to include]\n- [How to structure]\n\n**Edge Cases:**\nHandle these situations:\n- [Edge case 1]: [How to handle]\n- [Edge case 2]: [How to handle]\n```\n\n### Best Practices\n\nâœ… **DO:**\n- Write in second person (\"You are...\", \"You will...\")\n- Be specific about responsibilities\n- Provide step-by-step process\n- Define output format\n- Include quality standards\n- Address edge cases\n- Keep under 10,000 characters\n\nâŒ **DON'T:**\n- Write in first person (\"I am...\", \"I will...\")\n- Be vague or generic\n- Omit process steps\n- Leave output format undefined\n- Skip quality guidance\n- Ignore error cases\n\n## Creating Agents\n\n### Method 1: AI-Assisted Generation\n\nUse this prompt pattern (extracted from Claude Code):\n\n```\nCreate an agent configuration based on this request: \"[YOUR DESCRIPTION]\"\n\nRequirements:\n1. Extract core intent and responsibilities\n2. Design expert persona for the domain\n3. Create comprehensive system prompt with:\n   - Clear behavioral boundaries\n   - Specific methodologies\n   - Edge case handling\n   - Output format\n4. Create identifier (lowercase, hyphens, 3-50 chars)\n5. Write description with triggering conditions\n6. Include 2-3 <example> blocks showing when to use\n\nReturn JSON with:\n{\n  \"identifier\": \"agent-name\",\n  \"whenToUse\": \"Use this agent when... Examples: <example>...</example>\",\n  \"systemPrompt\": \"You are...\"\n}\n```\n\nThen convert to agent file format with frontmatter.\n\nSee `examples/agent-creation-prompt.md` for complete template.\n\n### Method 2: Manual Creation\n\n1. Choose agent identifier (3-50 chars, lowercase, hyphens)\n2. Write description with examples\n3. Select model (usually `inherit`)\n4. Choose color for visual identification\n5. Define tools (if restricting access)\n6. Write system prompt with structure above\n7. Save as `agents/agent-name.md`\n\n## Validation Rules\n\n### Identifier Validation\n\n```\nâœ… Valid: code-reviewer, test-gen, api-analyzer-v2\nâŒ Invalid: ag (too short), -start (starts with hyphen), my_agent (underscore)\n```\n\n**Rules:**\n- 3-50 characters\n- Lowercase letters, numbers, hyphens only\n- Must start and end with alphanumeric\n- No underscores, spaces, or special characters\n\n### Description Validation\n\n**Length:** 10-5,000 characters\n**Must include:** Triggering conditions and examples\n**Best:** 200-1,000 characters with 2-4 examples\n\n### System Prompt Validation\n\n**Length:** 20-10,000 characters\n**Best:** 500-3,000 characters\n**Structure:** Clear responsibilities, process, output format\n\n## Agent Organization\n\n### Plugin Agents Directory\n\n```\nplugin-name/\nâ””â”€â”€ agents/\n    â”œâ”€â”€ analyzer.md\n    â”œâ”€â”€ reviewer.md\n    â””â”€â”€ generator.md\n```\n\nAll `.md` files in `agents/` are auto-discovered.\n\n### Namespacing\n\nAgents are namespaced automatically:\n- Single plugin: `agent-name`\n- With subdirectories: `plugin:subdir:agent-name`\n\n## Testing Agents\n\n### Test Triggering\n\nCreate test scenarios to verify agent triggers correctly:\n\n1. Write agent with specific triggering examples\n2. Use similar phrasing to examples in test\n3. Check Claude loads the agent\n4. Verify agent provides expected functionality\n\n### Test System Prompt\n\nEnsure system prompt is complete:\n\n1. Give agent typical task\n2. Check it follows process steps\n3. Verify output format is correct\n4. Test edge cases mentioned in prompt\n5. Confirm quality standards are met\n\n## Quick Reference\n\n### Minimal Agent\n\n```markdown\n---\nname: simple-agent\ndescription: Use this agent when... Examples: <example>...</example>\nmodel: inherit\ncolor: blue\n---\n\nYou are an agent that [does X].\n\nProcess:\n1. [Step 1]\n2. [Step 2]\n\nOutput: [What to provide]\n```\n\n### Frontmatter Fields Summary\n\n| Field | Required | Format | Example |\n|-------|----------|--------|---------|\n| name | Yes | lowercase-hyphens | code-reviewer |\n| description | Yes | Text + examples | Use when... <example>... |\n| model | Yes | inherit/sonnet/opus/haiku | inherit |\n| color | Yes | Color name | blue |\n| tools | No | Array of tool names | [\"Read\", \"Grep\"] |\n\n### Best Practices\n\n**DO:**\n- âœ… Include 2-4 concrete examples in description\n- âœ… Write specific triggering conditions\n- âœ… Use `inherit` for model unless specific need\n- âœ… Choose appropriate tools (least privilege)\n- âœ… Write clear, structured system prompts\n- âœ… Test agent triggering thoroughly\n\n**DON'T:**\n- âŒ Use generic descriptions without examples\n- âŒ Omit triggering conditions\n- âŒ Give all agents same color\n- âŒ Grant unnecessary tool access\n- âŒ Write vague system prompts\n- âŒ Skip testing\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed guidance, consult:\n\n- **`references/system-prompt-design.md`** - Complete system prompt patterns\n- **`references/triggering-examples.md`** - Example formats and best practices\n- **`references/agent-creation-system-prompt.md`** - The exact prompt from Claude Code\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`agent-creation-prompt.md`** - AI-assisted agent generation template\n- **`complete-agent-examples.md`** - Full agent examples for different use cases\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-agent.sh`** - Validate agent file structure\n- **`test-agent-trigger.sh`** - Test if agent triggers correctly\n\n## Implementation Workflow\n\nTo create an agent for a plugin:\n\n1. Define agent purpose and triggering conditions\n2. Choose creation method (AI-assisted or manual)\n3. Create `agents/agent-name.md` file\n4. Write frontmatter with all required fields\n5. Write system prompt following best practices\n6. Include 2-4 triggering examples in description\n7. Validate with `scripts/validate-agent.sh`\n8. Test triggering with real scenarios\n9. Document agent in plugin README\n\nFocus on clear triggering conditions and comprehensive system prompts for autonomous operation."
              },
              {
                "name": "Command Development",
                "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
                "path": "plugins/plugin-dev/skills/command-development/SKILL.md",
                "frontmatter": {
                  "name": "Command Development",
                  "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
                  "version": "0.2.0"
                },
                "content": "# Command Development for Claude Code\n\n## Overview\n\nSlash commands are frequently-used prompts defined as Markdown files that Claude executes during interactive sessions. Understanding command structure, frontmatter options, and dynamic features enables creating powerful, reusable workflows.\n\n**Key concepts:**\n- Markdown file format for commands\n- YAML frontmatter for configuration\n- Dynamic arguments and file references\n- Bash execution for context\n- Command organization and namespacing\n\n## Command Basics\n\n### What is a Slash Command?\n\nA slash command is a Markdown file containing a prompt that Claude executes when invoked. Commands provide:\n- **Reusability**: Define once, use repeatedly\n- **Consistency**: Standardize common workflows\n- **Sharing**: Distribute across team or projects\n- **Efficiency**: Quick access to complex prompts\n\n### Critical: Commands are Instructions FOR Claude\n\n**Commands are written for agent consumption, not human consumption.**\n\nWhen a user invokes `/command-name`, the command content becomes Claude's instructions. Write commands as directives TO Claude about what to do, not as messages TO the user.\n\n**Correct approach (instructions for Claude):**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication issues\n\nProvide specific line numbers and severity ratings.\n```\n\n**Incorrect approach (messages to user):**\n```markdown\nThis command will review your code for security issues.\nYou'll receive a report with vulnerability details.\n```\n\nThe first example tells Claude what to do. The second tells the user what will happen but doesn't instruct Claude. Always use the first approach.\n\n### Command Locations\n\n**Project commands** (shared with team):\n- Location: `.claude/commands/`\n- Scope: Available in specific project\n- Label: Shown as \"(project)\" in `/help`\n- Use for: Team workflows, project-specific tasks\n\n**Personal commands** (available everywhere):\n- Location: `~/.claude/commands/`\n- Scope: Available in all projects\n- Label: Shown as \"(user)\" in `/help`\n- Use for: Personal workflows, cross-project utilities\n\n**Plugin commands** (bundled with plugins):\n- Location: `plugin-name/commands/`\n- Scope: Available when plugin installed\n- Label: Shown as \"(plugin-name)\" in `/help`\n- Use for: Plugin-specific functionality\n\n## File Format\n\n### Basic Structure\n\nCommands are Markdown files with `.md` extension:\n\n```\n.claude/commands/\nâ”œâ”€â”€ review.md           # /review command\nâ”œâ”€â”€ test.md             # /test command\nâ””â”€â”€ deploy.md           # /deploy command\n```\n\n**Simple command:**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication bypass\n- Insecure data handling\n```\n\nNo frontmatter needed for basic commands.\n\n### With YAML Frontmatter\n\nAdd configuration using YAML frontmatter:\n\n```markdown\n---\ndescription: Review code for security issues\nallowed-tools: Read, Grep, Bash(git:*)\nmodel: sonnet\n---\n\nReview this code for security vulnerabilities...\n```\n\n## YAML Frontmatter Fields\n\n### description\n\n**Purpose:** Brief description shown in `/help`\n**Type:** String\n**Default:** First line of command prompt\n\n```yaml\n---\ndescription: Review pull request for code quality\n---\n```\n\n**Best practice:** Clear, actionable description (under 60 characters)\n\n### allowed-tools\n\n**Purpose:** Specify which tools command can use\n**Type:** String or Array\n**Default:** Inherits from conversation\n\n```yaml\n---\nallowed-tools: Read, Write, Edit, Bash(git:*)\n---\n```\n\n**Patterns:**\n- `Read, Write, Edit` - Specific tools\n- `Bash(git:*)` - Bash with git commands only\n- `*` - All tools (rarely needed)\n\n**Use when:** Command requires specific tool access\n\n### model\n\n**Purpose:** Specify model for command execution\n**Type:** String (sonnet, opus, haiku)\n**Default:** Inherits from conversation\n\n```yaml\n---\nmodel: haiku\n---\n```\n\n**Use cases:**\n- `haiku` - Fast, simple commands\n- `sonnet` - Standard workflows\n- `opus` - Complex analysis\n\n### argument-hint\n\n**Purpose:** Document expected arguments for autocomplete\n**Type:** String\n**Default:** None\n\n```yaml\n---\nargument-hint: [pr-number] [priority] [assignee]\n---\n```\n\n**Benefits:**\n- Helps users understand command arguments\n- Improves command discovery\n- Documents command interface\n\n### disable-model-invocation\n\n**Purpose:** Prevent SlashCommand tool from programmatically calling command\n**Type:** Boolean\n**Default:** false\n\n```yaml\n---\ndisable-model-invocation: true\n---\n```\n\n**Use when:** Command should only be manually invoked\n\n## Dynamic Arguments\n\n### Using $ARGUMENTS\n\nCapture all arguments as single string:\n\n```markdown\n---\ndescription: Fix issue by number\nargument-hint: [issue-number]\n---\n\nFix issue #$ARGUMENTS following our coding standards and best practices.\n```\n\n**Usage:**\n```\n> /fix-issue 123\n> /fix-issue 456\n```\n\n**Expands to:**\n```\nFix issue #123 following our coding standards...\nFix issue #456 following our coding standards...\n```\n\n### Using Positional Arguments\n\nCapture individual arguments with `$1`, `$2`, `$3`, etc.:\n\n```markdown\n---\ndescription: Review PR with priority and assignee\nargument-hint: [pr-number] [priority] [assignee]\n---\n\nReview pull request #$1 with priority level $2.\nAfter review, assign to $3 for follow-up.\n```\n\n**Usage:**\n```\n> /review-pr 123 high alice\n```\n\n**Expands to:**\n```\nReview pull request #123 with priority level high.\nAfter review, assign to alice for follow-up.\n```\n\n### Combining Arguments\n\nMix positional and remaining arguments:\n\n```markdown\nDeploy $1 to $2 environment with options: $3\n```\n\n**Usage:**\n```\n> /deploy api staging --force --skip-tests\n```\n\n**Expands to:**\n```\nDeploy api to staging environment with options: --force --skip-tests\n```\n\n## File References\n\n### Using @ Syntax\n\nInclude file contents in command:\n\n```markdown\n---\ndescription: Review specific file\nargument-hint: [file-path]\n---\n\nReview @$1 for:\n- Code quality\n- Best practices\n- Potential bugs\n```\n\n**Usage:**\n```\n> /review-file src/api/users.ts\n```\n\n**Effect:** Claude reads `src/api/users.ts` before processing command\n\n### Multiple File References\n\nReference multiple files:\n\n```markdown\nCompare @src/old-version.js with @src/new-version.js\n\nIdentify:\n- Breaking changes\n- New features\n- Bug fixes\n```\n\n### Static File References\n\nReference known files without arguments:\n\n```markdown\nReview @package.json and @tsconfig.json for consistency\n\nEnsure:\n- TypeScript version matches\n- Dependencies are aligned\n- Build configuration is correct\n```\n\n## Bash Execution in Commands\n\nCommands can execute bash commands inline to dynamically gather context before Claude processes the command. This is useful for including repository state, environment information, or project-specific context.\n\n**When to use:**\n- Include dynamic context (git status, environment vars, etc.)\n- Gather project/repository state\n- Build context-aware workflows\n\n**Implementation details:**\nFor complete syntax, examples, and best practices, see `references/plugin-features-reference.md` section on bash execution. The reference includes the exact syntax and multiple working examples to avoid execution issues\n\n## Command Organization\n\n### Flat Structure\n\nSimple organization for small command sets:\n\n```\n.claude/commands/\nâ”œâ”€â”€ build.md\nâ”œâ”€â”€ test.md\nâ”œâ”€â”€ deploy.md\nâ”œâ”€â”€ review.md\nâ””â”€â”€ docs.md\n```\n\n**Use when:** 5-15 commands, no clear categories\n\n### Namespaced Structure\n\nOrganize commands in subdirectories:\n\n```\n.claude/commands/\nâ”œâ”€â”€ ci/\nâ”‚   â”œâ”€â”€ build.md        # /build (project:ci)\nâ”‚   â”œâ”€â”€ test.md         # /test (project:ci)\nâ”‚   â””â”€â”€ lint.md         # /lint (project:ci)\nâ”œâ”€â”€ git/\nâ”‚   â”œâ”€â”€ commit.md       # /commit (project:git)\nâ”‚   â””â”€â”€ pr.md           # /pr (project:git)\nâ””â”€â”€ docs/\n    â”œâ”€â”€ generate.md     # /generate (project:docs)\n    â””â”€â”€ publish.md      # /publish (project:docs)\n```\n\n**Benefits:**\n- Logical grouping by category\n- Namespace shown in `/help`\n- Easier to find related commands\n\n**Use when:** 15+ commands, clear categories\n\n## Best Practices\n\n### Command Design\n\n1. **Single responsibility:** One command, one task\n2. **Clear descriptions:** Self-explanatory in `/help`\n3. **Explicit dependencies:** Use `allowed-tools` when needed\n4. **Document arguments:** Always provide `argument-hint`\n5. **Consistent naming:** Use verb-noun pattern (review-pr, fix-issue)\n\n### Argument Handling\n\n1. **Validate arguments:** Check for required arguments in prompt\n2. **Provide defaults:** Suggest defaults when arguments missing\n3. **Document format:** Explain expected argument format\n4. **Handle edge cases:** Consider missing or invalid arguments\n\n```markdown\n---\nargument-hint: [pr-number]\n---\n\n$IF($1,\n  Review PR #$1,\n  Please provide a PR number. Usage: /review-pr [number]\n)\n```\n\n### File References\n\n1. **Explicit paths:** Use clear file paths\n2. **Check existence:** Handle missing files gracefully\n3. **Relative paths:** Use project-relative paths\n4. **Glob support:** Consider using Glob tool for patterns\n\n### Bash Commands\n\n1. **Limit scope:** Use `Bash(git:*)` not `Bash(*)`\n2. **Safe commands:** Avoid destructive operations\n3. **Handle errors:** Consider command failures\n4. **Keep fast:** Long-running commands slow invocation\n\n### Documentation\n\n1. **Add comments:** Explain complex logic\n2. **Provide examples:** Show usage in comments\n3. **List requirements:** Document dependencies\n4. **Version commands:** Note breaking changes\n\n```markdown\n---\ndescription: Deploy application to environment\nargument-hint: [environment] [version]\n---\n\n<!--\nUsage: /deploy [staging|production] [version]\nRequires: AWS credentials configured\nExample: /deploy staging v1.2.3\n-->\n\nDeploy application to $1 environment using version $2...\n```\n\n## Common Patterns\n\n### Review Pattern\n\n```markdown\n---\ndescription: Review code changes\nallowed-tools: Read, Bash(git:*)\n---\n\nFiles changed: !`git diff --name-only`\n\nReview each file for:\n1. Code quality and style\n2. Potential bugs or issues\n3. Test coverage\n4. Documentation needs\n\nProvide specific feedback for each file.\n```\n\n### Testing Pattern\n\n```markdown\n---\ndescription: Run tests for specific file\nargument-hint: [test-file]\nallowed-tools: Bash(npm:*)\n---\n\nRun tests: !`npm test $1`\n\nAnalyze results and suggest fixes for failures.\n```\n\n### Documentation Pattern\n\n```markdown\n---\ndescription: Generate documentation for file\nargument-hint: [source-file]\n---\n\nGenerate comprehensive documentation for @$1 including:\n- Function/class descriptions\n- Parameter documentation\n- Return value descriptions\n- Usage examples\n- Edge cases and errors\n```\n\n### Workflow Pattern\n\n```markdown\n---\ndescription: Complete PR workflow\nargument-hint: [pr-number]\nallowed-tools: Bash(gh:*), Read\n---\n\nPR #$1 Workflow:\n\n1. Fetch PR: !`gh pr view $1`\n2. Review changes\n3. Run checks\n4. Approve or request changes\n```\n\n## Troubleshooting\n\n**Command not appearing:**\n- Check file is in correct directory\n- Verify `.md` extension present\n- Ensure valid Markdown format\n- Restart Claude Code\n\n**Arguments not working:**\n- Verify `$1`, `$2` syntax correct\n- Check `argument-hint` matches usage\n- Ensure no extra spaces\n\n**Bash execution failing:**\n- Check `allowed-tools` includes Bash\n- Verify command syntax in backticks\n- Test command in terminal first\n- Check for required permissions\n\n**File references not working:**\n- Verify `@` syntax correct\n- Check file path is valid\n- Ensure Read tool allowed\n- Use absolute or project-relative paths\n\n## Plugin-Specific Features\n\n### CLAUDE_PLUGIN_ROOT Variable\n\nPlugin commands have access to `${CLAUDE_PLUGIN_ROOT}`, an environment variable that resolves to the plugin's absolute path.\n\n**Purpose:**\n- Reference plugin files portably\n- Execute plugin scripts\n- Load plugin configuration\n- Access plugin templates\n\n**Basic usage:**\n\n```markdown\n---\ndescription: Analyze using plugin script\nallowed-tools: Bash(node:*)\n---\n\nRun analysis: !`node ${CLAUDE_PLUGIN_ROOT}/scripts/analyze.js $1`\n\nReview results and report findings.\n```\n\n**Common patterns:**\n\n```markdown\n# Execute plugin script\n!`bash ${CLAUDE_PLUGIN_ROOT}/scripts/script.sh`\n\n# Load plugin configuration\n@${CLAUDE_PLUGIN_ROOT}/config/settings.json\n\n# Use plugin template\n@${CLAUDE_PLUGIN_ROOT}/templates/report.md\n\n# Access plugin resources\n@${CLAUDE_PLUGIN_ROOT}/docs/reference.md\n```\n\n**Why use it:**\n- Works across all installations\n- Portable between systems\n- No hardcoded paths needed\n- Essential for multi-file plugins\n\n### Plugin Command Organization\n\nPlugin commands discovered automatically from `commands/` directory:\n\n```\nplugin-name/\nâ”œâ”€â”€ commands/\nâ”‚   â”œâ”€â”€ foo.md              # /foo (plugin:plugin-name)\nâ”‚   â”œâ”€â”€ bar.md              # /bar (plugin:plugin-name)\nâ”‚   â””â”€â”€ utils/\nâ”‚       â””â”€â”€ helper.md       # /helper (plugin:plugin-name:utils)\nâ””â”€â”€ plugin.json\n```\n\n**Namespace benefits:**\n- Logical command grouping\n- Shown in `/help` output\n- Avoid name conflicts\n- Organize related commands\n\n**Naming conventions:**\n- Use descriptive action names\n- Avoid generic names (test, run)\n- Consider plugin-specific prefix\n- Use hyphens for multi-word names\n\n### Plugin Command Patterns\n\n**Configuration-based pattern:**\n\n```markdown\n---\ndescription: Deploy using plugin configuration\nargument-hint: [environment]\nallowed-tools: Read, Bash(*)\n---\n\nLoad configuration: @${CLAUDE_PLUGIN_ROOT}/config/$1-deploy.json\n\nDeploy to $1 using configuration settings.\nMonitor deployment and report status.\n```\n\n**Template-based pattern:**\n\n```markdown\n---\ndescription: Generate docs from template\nargument-hint: [component]\n---\n\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/docs.md\n\nGenerate documentation for $1 following template structure.\n```\n\n**Multi-script pattern:**\n\n```markdown\n---\ndescription: Complete build workflow\nallowed-tools: Bash(*)\n---\n\nBuild: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh`\nTest: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/test.sh`\nPackage: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/package.sh`\n\nReview outputs and report workflow status.\n```\n\n**See `references/plugin-features-reference.md` for detailed patterns.**\n\n## Integration with Plugin Components\n\nCommands can integrate with other plugin components for powerful workflows.\n\n### Agent Integration\n\nLaunch plugin agents for complex tasks:\n\n```markdown\n---\ndescription: Deep code review\nargument-hint: [file-path]\n---\n\nInitiate comprehensive review of @$1 using the code-reviewer agent.\n\nThe agent will analyze:\n- Code structure\n- Security issues\n- Performance\n- Best practices\n\nAgent uses plugin resources:\n- ${CLAUDE_PLUGIN_ROOT}/config/rules.json\n- ${CLAUDE_PLUGIN_ROOT}/checklists/review.md\n```\n\n**Key points:**\n- Agent must exist in `plugin/agents/` directory\n- Claude uses Task tool to launch agent\n- Document agent capabilities\n- Reference plugin resources agent uses\n\n### Skill Integration\n\nLeverage plugin skills for specialized knowledge:\n\n```markdown\n---\ndescription: Document API with standards\nargument-hint: [api-file]\n---\n\nDocument API in @$1 following plugin standards.\n\nUse the api-docs-standards skill to ensure:\n- Complete endpoint documentation\n- Consistent formatting\n- Example quality\n- Error documentation\n\nGenerate production-ready API docs.\n```\n\n**Key points:**\n- Skill must exist in `plugin/skills/` directory\n- Mention skill name to trigger invocation\n- Document skill purpose\n- Explain what skill provides\n\n### Hook Coordination\n\nDesign commands that work with plugin hooks:\n- Commands can prepare state for hooks to process\n- Hooks execute automatically on tool events\n- Commands should document expected hook behavior\n- Guide Claude on interpreting hook output\n\nSee `references/plugin-features-reference.md` for examples of commands that coordinate with hooks\n\n### Multi-Component Workflows\n\nCombine agents, skills, and scripts:\n\n```markdown\n---\ndescription: Comprehensive review workflow\nargument-hint: [file]\nallowed-tools: Bash(node:*), Read\n---\n\nTarget: @$1\n\nPhase 1 - Static Analysis:\n!`node ${CLAUDE_PLUGIN_ROOT}/scripts/lint.js $1`\n\nPhase 2 - Deep Review:\nLaunch code-reviewer agent for detailed analysis.\n\nPhase 3 - Standards Check:\nUse coding-standards skill for validation.\n\nPhase 4 - Report:\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/review.md\n\nCompile findings into report following template.\n```\n\n**When to use:**\n- Complex multi-step workflows\n- Leverage multiple plugin capabilities\n- Require specialized analysis\n- Need structured outputs\n\n## Validation Patterns\n\nCommands should validate inputs and resources before processing.\n\n### Argument Validation\n\n```markdown\n---\ndescription: Deploy with validation\nargument-hint: [environment]\n---\n\nValidate environment: !`echo \"$1\" | grep -E \"^(dev|staging|prod)$\" || echo \"INVALID\"`\n\nIf $1 is valid environment:\n  Deploy to $1\nOtherwise:\n  Explain valid environments: dev, staging, prod\n  Show usage: /deploy [environment]\n```\n\n### File Existence Checks\n\n```markdown\n---\ndescription: Process configuration\nargument-hint: [config-file]\n---\n\nCheck file exists: !`test -f $1 && echo \"EXISTS\" || echo \"MISSING\"`\n\nIf file exists:\n  Process configuration: @$1\nOtherwise:\n  Explain where to place config file\n  Show expected format\n  Provide example configuration\n```\n\n### Plugin Resource Validation\n\n```markdown\n---\ndescription: Run plugin analyzer\nallowed-tools: Bash(test:*)\n---\n\nValidate plugin setup:\n- Script: !`test -x ${CLAUDE_PLUGIN_ROOT}/bin/analyze && echo \"âœ“\" || echo \"âœ—\"`\n- Config: !`test -f ${CLAUDE_PLUGIN_ROOT}/config.json && echo \"âœ“\" || echo \"âœ—\"`\n\nIf all checks pass, run analysis.\nOtherwise, report missing components.\n```\n\n### Error Handling\n\n```markdown\n---\ndescription: Build with error handling\nallowed-tools: Bash(*)\n---\n\nExecute build: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh 2>&1 || echo \"BUILD_FAILED\"`\n\nIf build succeeded:\n  Report success and output location\nIf build failed:\n  Analyze error output\n  Suggest likely causes\n  Provide troubleshooting steps\n```\n\n**Best practices:**\n- Validate early in command\n- Provide helpful error messages\n- Suggest corrective actions\n- Handle edge cases gracefully\n\n---\n\nFor detailed frontmatter field specifications, see `references/frontmatter-reference.md`.\nFor plugin-specific features and patterns, see `references/plugin-features-reference.md`.\nFor command pattern examples, see `examples/` directory."
              },
              {
                "name": "Hook Development",
                "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
                "path": "plugins/plugin-dev/skills/hook-development/SKILL.md",
                "frontmatter": {
                  "name": "Hook Development",
                  "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
                  "version": "0.1.0"
                },
                "content": "# Hook Development for Claude Code Plugins\n\n## Overview\n\nHooks are event-driven automation scripts that execute in response to Claude Code events. Use hooks to validate operations, enforce policies, add context, and integrate external tools into workflows.\n\n**Key capabilities:**\n- Validate tool calls before execution (PreToolUse)\n- React to tool results (PostToolUse)\n- Enforce completion standards (Stop, SubagentStop)\n- Load project context (SessionStart)\n- Automate workflows across the development lifecycle\n\n## Hook Types\n\n### Prompt-Based Hooks (Recommended)\n\nUse LLM-driven decision making for context-aware validation:\n\n```json\n{\n  \"type\": \"prompt\",\n  \"prompt\": \"Evaluate if this tool use is appropriate: $TOOL_INPUT\",\n  \"timeout\": 30\n}\n```\n\n**Supported events:** Stop, SubagentStop, UserPromptSubmit, PreToolUse\n\n**Benefits:**\n- Context-aware decisions based on natural language reasoning\n- Flexible evaluation logic without bash scripting\n- Better edge case handling\n- Easier to maintain and extend\n\n### Command Hooks\n\nExecute bash commands for deterministic checks:\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\",\n  \"timeout\": 60\n}\n```\n\n**Use for:**\n- Fast deterministic validations\n- File system operations\n- External tool integrations\n- Performance-critical checks\n\n## Hook Configuration Formats\n\n### Plugin hooks.json Format\n\n**For plugin hooks** in `hooks/hooks.json`, use wrapper format:\n\n```json\n{\n  \"description\": \"Brief explanation of hooks (optional)\",\n  \"hooks\": {\n    \"PreToolUse\": [...],\n    \"Stop\": [...],\n    \"SessionStart\": [...]\n  }\n}\n```\n\n**Key points:**\n- `description` field is optional\n- `hooks` field is required wrapper containing actual hook events\n- This is the **plugin-specific format**\n\n**Example:**\n```json\n{\n  \"description\": \"Validation hooks for code quality\",\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Write\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/validate.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n### Settings Format (Direct)\n\n**For user settings** in `.claude/settings.json`, use direct format:\n\n```json\n{\n  \"PreToolUse\": [...],\n  \"Stop\": [...],\n  \"SessionStart\": [...]\n}\n```\n\n**Key points:**\n- No wrapper - events directly at top level\n- No description field\n- This is the **settings format**\n\n**Important:** The examples below show the hook event structure that goes inside either format. For plugin hooks.json, wrap these in `{\"hooks\": {...}}`.\n\n## Hook Events\n\n### PreToolUse\n\nExecute before any tool runs. Use to approve, deny, or modify tool calls.\n\n**Example (prompt-based):**\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety. Check: system paths, credentials, path traversal, sensitive content. Return 'approve' or 'deny'.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output for PreToolUse:**\n```json\n{\n  \"hookSpecificOutput\": {\n    \"permissionDecision\": \"allow|deny|ask\",\n    \"updatedInput\": {\"field\": \"modified_value\"}\n  },\n  \"systemMessage\": \"Explanation for Claude\"\n}\n```\n\n### PostToolUse\n\nExecute after tool completes. Use to react to results, provide feedback, or log.\n\n**Example:**\n```json\n{\n  \"PostToolUse\": [\n    {\n      \"matcher\": \"Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Analyze edit result for potential issues: syntax errors, security vulnerabilities, breaking changes. Provide feedback.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output behavior:**\n- Exit 0: stdout shown in transcript\n- Exit 2: stderr fed back to Claude\n- systemMessage included in context\n\n### Stop\n\nExecute when main agent considers stopping. Use to validate completeness.\n\n**Example:**\n```json\n{\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion: tests run, build succeeded, questions answered. Return 'approve' to stop or 'block' with reason to continue.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Decision output:**\n```json\n{\n  \"decision\": \"approve|block\",\n  \"reason\": \"Explanation\",\n  \"systemMessage\": \"Additional context\"\n}\n```\n\n### SubagentStop\n\nExecute when subagent considers stopping. Use to ensure subagent completed its task.\n\nSimilar to Stop hook, but for subagents.\n\n### UserPromptSubmit\n\nExecute when user submits a prompt. Use to add context, validate, or block prompts.\n\n**Example:**\n```json\n{\n  \"UserPromptSubmit\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Check if prompt requires security guidance. If discussing auth, permissions, or API security, return relevant warnings.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### SessionStart\n\nExecute when Claude Code session begins. Use to load context and set environment.\n\n**Example:**\n```json\n{\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Special capability:** Persist environment variables using `$CLAUDE_ENV_FILE`:\n```bash\necho \"export PROJECT_TYPE=nodejs\" >> \"$CLAUDE_ENV_FILE\"\n```\n\nSee `examples/load-context.sh` for complete example.\n\n### SessionEnd\n\nExecute when session ends. Use for cleanup, logging, and state preservation.\n\n### PreCompact\n\nExecute before context compaction. Use to add critical information to preserve.\n\n### Notification\n\nExecute when Claude sends notifications. Use to react to user notifications.\n\n## Hook Output Format\n\n### Standard Output (All Hooks)\n\n```json\n{\n  \"continue\": true,\n  \"suppressOutput\": false,\n  \"systemMessage\": \"Message for Claude\"\n}\n```\n\n- `continue`: If false, halt processing (default true)\n- `suppressOutput`: Hide output from transcript (default false)\n- `systemMessage`: Message shown to Claude\n\n### Exit Codes\n\n- `0` - Success (stdout shown in transcript)\n- `2` - Blocking error (stderr fed back to Claude)\n- Other - Non-blocking error\n\n## Hook Input Format\n\nAll hooks receive JSON via stdin with common fields:\n\n```json\n{\n  \"session_id\": \"abc123\",\n  \"transcript_path\": \"/path/to/transcript.txt\",\n  \"cwd\": \"/current/working/dir\",\n  \"permission_mode\": \"ask|allow\",\n  \"hook_event_name\": \"PreToolUse\"\n}\n```\n\n**Event-specific fields:**\n\n- **PreToolUse/PostToolUse:** `tool_name`, `tool_input`, `tool_result`\n- **UserPromptSubmit:** `user_prompt`\n- **Stop/SubagentStop:** `reason`\n\nAccess fields in prompts using `$TOOL_INPUT`, `$TOOL_RESULT`, `$USER_PROMPT`, etc.\n\n## Environment Variables\n\nAvailable in all command hooks:\n\n- `$CLAUDE_PROJECT_DIR` - Project root path\n- `$CLAUDE_PLUGIN_ROOT` - Plugin directory (use for portable paths)\n- `$CLAUDE_ENV_FILE` - SessionStart only: persist env vars here\n- `$CLAUDE_CODE_REMOTE` - Set if running in remote context\n\n**Always use ${CLAUDE_PLUGIN_ROOT} in hook commands for portability:**\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\"\n}\n```\n\n## Plugin Hook Configuration\n\nIn plugins, define hooks in `hooks/hooks.json`:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety\"\n        }\n      ]\n    }\n  ],\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion\"\n        }\n      ]\n    }\n  ],\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\",\n          \"timeout\": 10\n        }\n      ]\n    }\n  ]\n}\n```\n\nPlugin hooks merge with user's hooks and run in parallel.\n\n## Matchers\n\n### Tool Name Matching\n\n**Exact match:**\n```json\n\"matcher\": \"Write\"\n```\n\n**Multiple tools:**\n```json\n\"matcher\": \"Read|Write|Edit\"\n```\n\n**Wildcard (all tools):**\n```json\n\"matcher\": \"*\"\n```\n\n**Regex patterns:**\n```json\n\"matcher\": \"mcp__.*__delete.*\"  // All MCP delete tools\n```\n\n**Note:** Matchers are case-sensitive.\n\n### Common Patterns\n\n```json\n// All MCP tools\n\"matcher\": \"mcp__.*\"\n\n// Specific plugin's MCP tools\n\"matcher\": \"mcp__plugin_asana_.*\"\n\n// All file operations\n\"matcher\": \"Read|Write|Edit\"\n\n// Bash commands only\n\"matcher\": \"Bash\"\n```\n\n## Security Best Practices\n\n### Input Validation\n\nAlways validate inputs in command hooks:\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\ninput=$(cat)\ntool_name=$(echo \"$input\" | jq -r '.tool_name')\n\n# Validate tool name format\nif [[ ! \"$tool_name\" =~ ^[a-zA-Z0-9_]+$ ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Invalid tool name\"}' >&2\n  exit 2\nfi\n```\n\n### Path Safety\n\nCheck for path traversal and sensitive files:\n\n```bash\nfile_path=$(echo \"$input\" | jq -r '.tool_input.file_path')\n\n# Deny path traversal\nif [[ \"$file_path\" == *\"..\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Path traversal detected\"}' >&2\n  exit 2\nfi\n\n# Deny sensitive files\nif [[ \"$file_path\" == *\".env\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Sensitive file\"}' >&2\n  exit 2\nfi\n```\n\nSee `examples/validate-write.sh` and `examples/validate-bash.sh` for complete examples.\n\n### Quote All Variables\n\n```bash\n# GOOD: Quoted\necho \"$file_path\"\ncd \"$CLAUDE_PROJECT_DIR\"\n\n# BAD: Unquoted (injection risk)\necho $file_path\ncd $CLAUDE_PROJECT_DIR\n```\n\n### Set Appropriate Timeouts\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash script.sh\",\n  \"timeout\": 10\n}\n```\n\n**Defaults:** Command hooks (60s), Prompt hooks (30s)\n\n## Performance Considerations\n\n### Parallel Execution\n\nAll matching hooks run **in parallel**:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write\",\n      \"hooks\": [\n        {\"type\": \"command\", \"command\": \"check1.sh\"},  // Parallel\n        {\"type\": \"command\", \"command\": \"check2.sh\"},  // Parallel\n        {\"type\": \"prompt\", \"prompt\": \"Validate...\"}   // Parallel\n      ]\n    }\n  ]\n}\n```\n\n**Design implications:**\n- Hooks don't see each other's output\n- Non-deterministic ordering\n- Design for independence\n\n### Optimization\n\n1. Use command hooks for quick deterministic checks\n2. Use prompt hooks for complex reasoning\n3. Cache validation results in temp files\n4. Minimize I/O in hot paths\n\n## Temporarily Active Hooks\n\nCreate hooks that activate conditionally by checking for a flag file or configuration:\n\n**Pattern: Flag file activation**\n```bash\n#!/bin/bash\n# Only active when flag file exists\nFLAG_FILE=\"$CLAUDE_PROJECT_DIR/.enable-strict-validation\"\n\nif [ ! -f \"$FLAG_FILE\" ]; then\n  # Flag not present, skip validation\n  exit 0\nfi\n\n# Flag present, run validation\ninput=$(cat)\n# ... validation logic ...\n```\n\n**Pattern: Configuration-based activation**\n```bash\n#!/bin/bash\n# Check configuration for activation\nCONFIG_FILE=\"$CLAUDE_PROJECT_DIR/.claude/plugin-config.json\"\n\nif [ -f \"$CONFIG_FILE\" ]; then\n  enabled=$(jq -r '.strictMode // false' \"$CONFIG_FILE\")\n  if [ \"$enabled\" != \"true\" ]; then\n    exit 0  # Not enabled, skip\n  fi\nfi\n\n# Enabled, run hook logic\ninput=$(cat)\n# ... hook logic ...\n```\n\n**Use cases:**\n- Enable strict validation only when needed\n- Temporary debugging hooks\n- Project-specific hook behavior\n- Feature flags for hooks\n\n**Best practice:** Document activation mechanism in plugin README so users know how to enable/disable temporary hooks.\n\n## Hook Lifecycle and Limitations\n\n### Hooks Load at Session Start\n\n**Important:** Hooks are loaded when Claude Code session starts. Changes to hook configuration require restarting Claude Code.\n\n**Cannot hot-swap hooks:**\n- Editing `hooks/hooks.json` won't affect current session\n- Adding new hook scripts won't be recognized\n- Changing hook commands/prompts won't update\n- Must restart Claude Code: exit and run `claude` again\n\n**To test hook changes:**\n1. Edit hook configuration or scripts\n2. Exit Claude Code session\n3. Restart: `claude` or `cc`\n4. New hook configuration loads\n5. Test hooks with `claude --debug`\n\n### Hook Validation at Startup\n\nHooks are validated when Claude Code starts:\n- Invalid JSON in hooks.json causes loading failure\n- Missing scripts cause warnings\n- Syntax errors reported in debug mode\n\nUse `/hooks` command to review loaded hooks in current session.\n\n## Debugging Hooks\n\n### Enable Debug Mode\n\n```bash\nclaude --debug\n```\n\nLook for hook registration, execution logs, input/output JSON, and timing information.\n\n### Test Hook Scripts\n\nTest command hooks directly:\n\n```bash\necho '{\"tool_name\": \"Write\", \"tool_input\": {\"file_path\": \"/test\"}}' | \\\n  bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\n\necho \"Exit code: $?\"\n```\n\n### Validate JSON Output\n\nEnsure hooks output valid JSON:\n\n```bash\noutput=$(./your-hook.sh < test-input.json)\necho \"$output\" | jq .\n```\n\n## Quick Reference\n\n### Hook Events Summary\n\n| Event | When | Use For |\n|-------|------|---------|\n| PreToolUse | Before tool | Validation, modification |\n| PostToolUse | After tool | Feedback, logging |\n| UserPromptSubmit | User input | Context, validation |\n| Stop | Agent stopping | Completeness check |\n| SubagentStop | Subagent done | Task validation |\n| SessionStart | Session begins | Context loading |\n| SessionEnd | Session ends | Cleanup, logging |\n| PreCompact | Before compact | Preserve context |\n| Notification | User notified | Logging, reactions |\n\n### Best Practices\n\n**DO:**\n- âœ… Use prompt-based hooks for complex logic\n- âœ… Use ${CLAUDE_PLUGIN_ROOT} for portability\n- âœ… Validate all inputs in command hooks\n- âœ… Quote all bash variables\n- âœ… Set appropriate timeouts\n- âœ… Return structured JSON output\n- âœ… Test hooks thoroughly\n\n**DON'T:**\n- âŒ Use hardcoded paths\n- âŒ Trust user input without validation\n- âŒ Create long-running hooks\n- âŒ Rely on hook execution order\n- âŒ Modify global state unpredictably\n- âŒ Log sensitive information\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and advanced techniques, consult:\n\n- **`references/patterns.md`** - Common hook patterns (8+ proven patterns)\n- **`references/migration.md`** - Migrating from basic to advanced hooks\n- **`references/advanced.md`** - Advanced use cases and techniques\n\n### Example Hook Scripts\n\nWorking examples in `examples/`:\n\n- **`validate-write.sh`** - File write validation example\n- **`validate-bash.sh`** - Bash command validation example\n- **`load-context.sh`** - SessionStart context loading example\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-hook-schema.sh`** - Validate hooks.json structure and syntax\n- **`test-hook.sh`** - Test hooks with sample input before deployment\n- **`hook-linter.sh`** - Check hook scripts for common issues and best practices\n\n### External Resources\n\n- **Official Docs**: https://docs.claude.com/en/docs/claude-code/hooks\n- **Examples**: See security-guidance plugin in marketplace\n- **Testing**: Use `claude --debug` for detailed logs\n- **Validation**: Use `jq` to validate hook JSON output\n\n## Implementation Workflow\n\nTo implement hooks in a plugin:\n\n1. Identify events to hook into (PreToolUse, Stop, SessionStart, etc.)\n2. Decide between prompt-based (flexible) or command (deterministic) hooks\n3. Write hook configuration in `hooks/hooks.json`\n4. For command hooks, create hook scripts\n5. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n6. Validate configuration with `scripts/validate-hook-schema.sh hooks/hooks.json`\n7. Test hooks with `scripts/test-hook.sh` before deployment\n8. Test in Claude Code with `claude --debug`\n9. Document hooks in plugin README\n\nFocus on prompt-based hooks for most use cases. Reserve command hooks for performance-critical or deterministic checks."
              },
              {
                "name": "MCP Integration",
                "description": "This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration.",
                "path": "plugins/plugin-dev/skills/mcp-integration/SKILL.md",
                "frontmatter": {
                  "name": "MCP Integration",
                  "description": "This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration.",
                  "version": "0.1.0"
                },
                "content": "# MCP Integration for Claude Code Plugins\n\n## Overview\n\nModel Context Protocol (MCP) enables Claude Code plugins to integrate with external services and APIs by providing structured tool access. Use MCP integration to expose external service capabilities as tools within Claude Code.\n\n**Key capabilities:**\n- Connect to external services (databases, APIs, file systems)\n- Provide 10+ related tools from a single service\n- Handle OAuth and complex authentication flows\n- Bundle MCP servers with plugins for automatic setup\n\n## MCP Server Configuration Methods\n\nPlugins can bundle MCP servers in two ways:\n\n### Method 1: Dedicated .mcp.json (Recommended)\n\nCreate `.mcp.json` at plugin root:\n\n```json\n{\n  \"database-tools\": {\n    \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/db-server\",\n    \"args\": [\"--config\", \"${CLAUDE_PLUGIN_ROOT}/config.json\"],\n    \"env\": {\n      \"DB_URL\": \"${DB_URL}\"\n    }\n  }\n}\n```\n\n**Benefits:**\n- Clear separation of concerns\n- Easier to maintain\n- Better for multiple servers\n\n### Method 2: Inline in plugin.json\n\nAdd `mcpServers` field to plugin.json:\n\n```json\n{\n  \"name\": \"my-plugin\",\n  \"version\": \"1.0.0\",\n  \"mcpServers\": {\n    \"plugin-api\": {\n      \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/api-server\",\n      \"args\": [\"--port\", \"8080\"]\n    }\n  }\n}\n```\n\n**Benefits:**\n- Single configuration file\n- Good for simple single-server plugins\n\n## MCP Server Types\n\n### stdio (Local Process)\n\nExecute local MCP servers as child processes. Best for local tools and custom servers.\n\n**Configuration:**\n```json\n{\n  \"filesystem\": {\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/allowed/path\"],\n    \"env\": {\n      \"LOG_LEVEL\": \"debug\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- File system access\n- Local database connections\n- Custom MCP servers\n- NPM-packaged MCP servers\n\n**Process management:**\n- Claude Code spawns and manages the process\n- Communicates via stdin/stdout\n- Terminates when Claude Code exits\n\n### SSE (Server-Sent Events)\n\nConnect to hosted MCP servers with OAuth support. Best for cloud services.\n\n**Configuration:**\n```json\n{\n  \"asana\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.asana.com/sse\"\n  }\n}\n```\n\n**Use cases:**\n- Official hosted MCP servers (Asana, GitHub, etc.)\n- Cloud services with MCP endpoints\n- OAuth-based authentication\n- No local installation needed\n\n**Authentication:**\n- OAuth flows handled automatically\n- User prompted on first use\n- Tokens managed by Claude Code\n\n### HTTP (REST API)\n\nConnect to RESTful MCP servers with token authentication.\n\n**Configuration:**\n```json\n{\n  \"api-service\": {\n    \"type\": \"http\",\n    \"url\": \"https://api.example.com/mcp\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${API_TOKEN}\",\n      \"X-Custom-Header\": \"value\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- REST API-based MCP servers\n- Token-based authentication\n- Custom API backends\n- Stateless interactions\n\n### WebSocket (Real-time)\n\nConnect to WebSocket MCP servers for real-time bidirectional communication.\n\n**Configuration:**\n```json\n{\n  \"realtime-service\": {\n    \"type\": \"ws\",\n    \"url\": \"wss://mcp.example.com/ws\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${TOKEN}\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- Real-time data streaming\n- Persistent connections\n- Push notifications from server\n- Low-latency requirements\n\n## Environment Variable Expansion\n\nAll MCP configurations support environment variable substitution:\n\n**${CLAUDE_PLUGIN_ROOT}** - Plugin directory (always use for portability):\n```json\n{\n  \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/my-server\"\n}\n```\n\n**User environment variables** - From user's shell:\n```json\n{\n  \"env\": {\n    \"API_KEY\": \"${MY_API_KEY}\",\n    \"DATABASE_URL\": \"${DB_URL}\"\n  }\n}\n```\n\n**Best practice:** Document all required environment variables in plugin README.\n\n## MCP Tool Naming\n\nWhen MCP servers provide tools, they're automatically prefixed:\n\n**Format:** `mcp__plugin_<plugin-name>_<server-name>__<tool-name>`\n\n**Example:**\n- Plugin: `asana`\n- Server: `asana`\n- Tool: `create_task`\n- **Full name:** `mcp__plugin_asana_asana__asana_create_task`\n\n### Using MCP Tools in Commands\n\nPre-allow specific MCP tools in command frontmatter:\n\n```markdown\n---\nallowed-tools: [\n  \"mcp__plugin_asana_asana__asana_create_task\",\n  \"mcp__plugin_asana_asana__asana_search_tasks\"\n]\n---\n```\n\n**Wildcard (use sparingly):**\n```markdown\n---\nallowed-tools: [\"mcp__plugin_asana_asana__*\"]\n---\n```\n\n**Best practice:** Pre-allow specific tools, not wildcards, for security.\n\n## Lifecycle Management\n\n**Automatic startup:**\n- MCP servers start when plugin enables\n- Connection established before first tool use\n- Restart required for configuration changes\n\n**Lifecycle:**\n1. Plugin loads\n2. MCP configuration parsed\n3. Server process started (stdio) or connection established (SSE/HTTP/WS)\n4. Tools discovered and registered\n5. Tools available as `mcp__plugin_...__...`\n\n**Viewing servers:**\nUse `/mcp` command to see all servers including plugin-provided ones.\n\n## Authentication Patterns\n\n### OAuth (SSE/HTTP)\n\nOAuth handled automatically by Claude Code:\n\n```json\n{\n  \"type\": \"sse\",\n  \"url\": \"https://mcp.example.com/sse\"\n}\n```\n\nUser authenticates in browser on first use. No additional configuration needed.\n\n### Token-Based (Headers)\n\nStatic or environment variable tokens:\n\n```json\n{\n  \"type\": \"http\",\n  \"url\": \"https://api.example.com\",\n  \"headers\": {\n    \"Authorization\": \"Bearer ${API_TOKEN}\"\n  }\n}\n```\n\nDocument required environment variables in README.\n\n### Environment Variables (stdio)\n\nPass configuration to MCP server:\n\n```json\n{\n  \"command\": \"python\",\n  \"args\": [\"-m\", \"my_mcp_server\"],\n  \"env\": {\n    \"DATABASE_URL\": \"${DB_URL}\",\n    \"API_KEY\": \"${API_KEY}\",\n    \"LOG_LEVEL\": \"info\"\n  }\n}\n```\n\n## Integration Patterns\n\n### Pattern 1: Simple Tool Wrapper\n\nCommands use MCP tools with user interaction:\n\n```markdown\n# Command: create-item.md\n---\nallowed-tools: [\"mcp__plugin_name_server__create_item\"]\n---\n\nSteps:\n1. Gather item details from user\n2. Use mcp__plugin_name_server__create_item\n3. Confirm creation\n```\n\n**Use for:** Adding validation or preprocessing before MCP calls.\n\n### Pattern 2: Autonomous Agent\n\nAgents use MCP tools autonomously:\n\n```markdown\n# Agent: data-analyzer.md\n\nAnalysis Process:\n1. Query data via mcp__plugin_db_server__query\n2. Process and analyze results\n3. Generate insights report\n```\n\n**Use for:** Multi-step MCP workflows without user interaction.\n\n### Pattern 3: Multi-Server Plugin\n\nIntegrate multiple MCP servers:\n\n```json\n{\n  \"github\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.github.com/sse\"\n  },\n  \"jira\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.jira.com/sse\"\n  }\n}\n```\n\n**Use for:** Workflows spanning multiple services.\n\n## Security Best Practices\n\n### Use HTTPS/WSS\n\nAlways use secure connections:\n\n```json\nâœ… \"url\": \"https://mcp.example.com/sse\"\nâŒ \"url\": \"http://mcp.example.com/sse\"\n```\n\n### Token Management\n\n**DO:**\n- âœ… Use environment variables for tokens\n- âœ… Document required env vars in README\n- âœ… Let OAuth flow handle authentication\n\n**DON'T:**\n- âŒ Hardcode tokens in configuration\n- âŒ Commit tokens to git\n- âŒ Share tokens in documentation\n\n### Permission Scoping\n\nPre-allow only necessary MCP tools:\n\n```markdown\nâœ… allowed-tools: [\n  \"mcp__plugin_api_server__read_data\",\n  \"mcp__plugin_api_server__create_item\"\n]\n\nâŒ allowed-tools: [\"mcp__plugin_api_server__*\"]\n```\n\n## Error Handling\n\n### Connection Failures\n\nHandle MCP server unavailability:\n- Provide fallback behavior in commands\n- Inform user of connection issues\n- Check server URL and configuration\n\n### Tool Call Errors\n\nHandle failed MCP operations:\n- Validate inputs before calling MCP tools\n- Provide clear error messages\n- Check rate limiting and quotas\n\n### Configuration Errors\n\nValidate MCP configuration:\n- Test server connectivity during development\n- Validate JSON syntax\n- Check required environment variables\n\n## Performance Considerations\n\n### Lazy Loading\n\nMCP servers connect on-demand:\n- Not all servers connect at startup\n- First tool use triggers connection\n- Connection pooling managed automatically\n\n### Batching\n\nBatch similar requests when possible:\n\n```\n# Good: Single query with filters\ntasks = search_tasks(project=\"X\", assignee=\"me\", limit=50)\n\n# Avoid: Many individual queries\nfor id in task_ids:\n    task = get_task(id)\n```\n\n## Testing MCP Integration\n\n### Local Testing\n\n1. Configure MCP server in `.mcp.json`\n2. Install plugin locally (`.claude-plugin/`)\n3. Run `/mcp` to verify server appears\n4. Test tool calls in commands\n5. Check `claude --debug` logs for connection issues\n\n### Validation Checklist\n\n- [ ] MCP configuration is valid JSON\n- [ ] Server URL is correct and accessible\n- [ ] Required environment variables documented\n- [ ] Tools appear in `/mcp` output\n- [ ] Authentication works (OAuth or tokens)\n- [ ] Tool calls succeed from commands\n- [ ] Error cases handled gracefully\n\n## Debugging\n\n### Enable Debug Logging\n\n```bash\nclaude --debug\n```\n\nLook for:\n- MCP server connection attempts\n- Tool discovery logs\n- Authentication flows\n- Tool call errors\n\n### Common Issues\n\n**Server not connecting:**\n- Check URL is correct\n- Verify server is running (stdio)\n- Check network connectivity\n- Review authentication configuration\n\n**Tools not available:**\n- Verify server connected successfully\n- Check tool names match exactly\n- Run `/mcp` to see available tools\n- Restart Claude Code after config changes\n\n**Authentication failing:**\n- Clear cached auth tokens\n- Re-authenticate\n- Check token scopes and permissions\n- Verify environment variables set\n\n## Quick Reference\n\n### MCP Server Types\n\n| Type | Transport | Best For | Auth |\n|------|-----------|----------|------|\n| stdio | Process | Local tools, custom servers | Env vars |\n| SSE | HTTP | Hosted services, cloud APIs | OAuth |\n| HTTP | REST | API backends, token auth | Tokens |\n| ws | WebSocket | Real-time, streaming | Tokens |\n\n### Configuration Checklist\n\n- [ ] Server type specified (stdio/SSE/HTTP/ws)\n- [ ] Type-specific fields complete (command or url)\n- [ ] Authentication configured\n- [ ] Environment variables documented\n- [ ] HTTPS/WSS used (not HTTP/WS)\n- [ ] ${CLAUDE_PLUGIN_ROOT} used for paths\n\n### Best Practices\n\n**DO:**\n- âœ… Use ${CLAUDE_PLUGIN_ROOT} for portable paths\n- âœ… Document required environment variables\n- âœ… Use secure connections (HTTPS/WSS)\n- âœ… Pre-allow specific MCP tools in commands\n- âœ… Test MCP integration before publishing\n- âœ… Handle connection and tool errors gracefully\n\n**DON'T:**\n- âŒ Hardcode absolute paths\n- âŒ Commit credentials to git\n- âŒ Use HTTP instead of HTTPS\n- âŒ Pre-allow all tools with wildcards\n- âŒ Skip error handling\n- âŒ Forget to document setup\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed information, consult:\n\n- **`references/server-types.md`** - Deep dive on each server type\n- **`references/authentication.md`** - Authentication patterns and OAuth\n- **`references/tool-usage.md`** - Using MCP tools in commands and agents\n\n### Example Configurations\n\nWorking examples in `examples/`:\n\n- **`stdio-server.json`** - Local stdio MCP server\n- **`sse-server.json`** - Hosted SSE server with OAuth\n- **`http-server.json`** - REST API with token auth\n\n### External Resources\n\n- **Official MCP Docs**: https://modelcontextprotocol.io/\n- **Claude Code MCP Docs**: https://docs.claude.com/en/docs/claude-code/mcp\n- **MCP SDK**: @modelcontextprotocol/sdk\n- **Testing**: Use `claude --debug` and `/mcp` command\n\n## Implementation Workflow\n\nTo add MCP integration to a plugin:\n\n1. Choose MCP server type (stdio, SSE, HTTP, ws)\n2. Create `.mcp.json` at plugin root with configuration\n3. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n4. Document required environment variables in README\n5. Test locally with `/mcp` command\n6. Pre-allow MCP tools in relevant commands\n7. Handle authentication (OAuth or tokens)\n8. Test error cases (connection failures, auth errors)\n9. Document MCP integration in plugin README\n\nFocus on stdio for custom/local servers, SSE for hosted services with OAuth."
              },
              {
                "name": "Plugin Settings",
                "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.",
                "path": "plugins/plugin-dev/skills/plugin-settings/SKILL.md",
                "frontmatter": {
                  "name": "Plugin Settings",
                  "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.",
                  "version": "0.1.0"
                },
                "content": "# Plugin Settings Pattern for Claude Code Plugins\n\n## Overview\n\nPlugins can store user-configurable settings and state in `.claude/plugin-name.local.md` files within the project directory. This pattern uses YAML frontmatter for structured configuration and markdown content for prompts or additional context.\n\n**Key characteristics:**\n- File location: `.claude/plugin-name.local.md` in project root\n- Structure: YAML frontmatter + markdown body\n- Purpose: Per-project plugin configuration and state\n- Usage: Read from hooks, commands, and agents\n- Lifecycle: User-managed (not in git, should be in `.gitignore`)\n\n## File Structure\n\n### Basic Template\n\n```markdown\n---\nenabled: true\nsetting1: value1\nsetting2: value2\nnumeric_setting: 42\nlist_setting: [\"item1\", \"item2\"]\n---\n\n# Additional Context\n\nThis markdown body can contain:\n- Task descriptions\n- Additional instructions\n- Prompts to feed back to Claude\n- Documentation or notes\n```\n\n### Example: Plugin State File\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nenabled: true\nstrict_mode: false\nmax_retries: 3\nnotification_level: info\ncoordinator_session: team-leader\n---\n\n# Plugin Configuration\n\nThis plugin is configured for standard validation mode.\nContact @team-lead with questions.\n```\n\n## Reading Settings Files\n\n### From Hooks (Bash Scripts)\n\n**Pattern: Check existence and parse frontmatter**\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\n# Define state file path\nSTATE_FILE=\".claude/my-plugin.local.md\"\n\n# Quick exit if file doesn't exist\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0  # Plugin not configured, skip\nfi\n\n# Parse YAML frontmatter (between --- markers)\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\n\n# Extract individual fields\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\nSTRICT_MODE=$(echo \"$FRONTMATTER\" | grep '^strict_mode:' | sed 's/strict_mode: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n\n# Check if enabled\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Use configuration in hook logic\nif [[ \"$STRICT_MODE\" == \"true\" ]]; then\n  # Apply strict validation\n  # ...\nfi\n```\n\nSee `examples/read-settings-hook.sh` for complete working example.\n\n### From Commands\n\nCommands can read settings files to customize behavior:\n\n```markdown\n---\ndescription: Process data with plugin\nallowed-tools: [\"Read\", \"Bash\"]\n---\n\n# Process Command\n\nSteps:\n1. Check if settings exist at `.claude/my-plugin.local.md`\n2. Read configuration using Read tool\n3. Parse YAML frontmatter to extract settings\n4. Apply settings to processing logic\n5. Execute with configured behavior\n```\n\n### From Agents\n\nAgents can reference settings in their instructions:\n\n```markdown\n---\nname: configured-agent\ndescription: Agent that adapts to project settings\n---\n\nCheck for plugin settings at `.claude/my-plugin.local.md`.\nIf present, parse YAML frontmatter and adapt behavior according to:\n- enabled: Whether plugin is active\n- mode: Processing mode (strict, standard, lenient)\n- Additional configuration fields\n```\n\n## Parsing Techniques\n\n### Extract Frontmatter\n\n```bash\n# Extract everything between --- markers\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n```\n\n### Read Individual Fields\n\n**String fields:**\n```bash\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field_name:' | sed 's/field_name: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n**Boolean fields:**\n```bash\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n# Compare: if [[ \"$ENABLED\" == \"true\" ]]; then\n```\n\n**Numeric fields:**\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n# Use: if [[ $MAX -gt 100 ]]; then\n```\n\n### Read Markdown Body\n\nExtract content after second `---`:\n\n```bash\n# Get everything after closing ---\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n## Common Patterns\n\n### Pattern 1: Temporarily Active Hooks\n\nUse settings file to control hook activation:\n\n```bash\n#!/bin/bash\nSTATE_FILE=\".claude/security-scan.local.md\"\n\n# Quick exit if not configured\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0\nfi\n\n# Read enabled flag\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Run hook logic\n# ...\n```\n\n**Use case:** Enable/disable hooks without editing hooks.json (requires restart).\n\n### Pattern 2: Agent State Management\n\nStore agent-specific state and configuration:\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-agent\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\n---\n\n# Task Assignment\n\nImplement JWT authentication for the API.\n\n**Success Criteria:**\n- Authentication endpoints created\n- Tests passing\n- PR created and CI green\n```\n\nRead from hooks to coordinate agents:\n\n```bash\nAGENT_NAME=$(echo \"$FRONTMATTER\" | grep '^agent_name:' | sed 's/agent_name: *//')\nCOORDINATOR=$(echo \"$FRONTMATTER\" | grep '^coordinator_session:' | sed 's/coordinator_session: *//')\n\n# Send notification to coordinator\ntmux send-keys -t \"$COORDINATOR\" \"Agent $AGENT_NAME completed task\" Enter\n```\n\n### Pattern 3: Configuration-Driven Behavior\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nvalidation_level: strict\nmax_file_size: 1000000\nallowed_extensions: [\".js\", \".ts\", \".tsx\"]\nenable_logging: true\n---\n\n# Validation Configuration\n\nStrict mode enabled for this project.\nAll writes validated against security policies.\n```\n\nUse in hooks or commands:\n\n```bash\nLEVEL=$(echo \"$FRONTMATTER\" | grep '^validation_level:' | sed 's/validation_level: *//')\n\ncase \"$LEVEL\" in\n  strict)\n    # Apply strict validation\n    ;;\n  standard)\n    # Apply standard validation\n    ;;\n  lenient)\n    # Apply lenient validation\n    ;;\nesac\n```\n\n## Creating Settings Files\n\n### From Commands\n\nCommands can create settings files:\n\n```markdown\n# Setup Command\n\nSteps:\n1. Ask user for configuration preferences\n2. Create `.claude/my-plugin.local.md` with YAML frontmatter\n3. Set appropriate values based on user input\n4. Inform user that settings are saved\n5. Remind user to restart Claude Code for hooks to recognize changes\n```\n\n### Template Generation\n\nProvide template in plugin README:\n\n```markdown\n## Configuration\n\nCreate `.claude/my-plugin.local.md` in your project:\n\n\\`\\`\\`markdown\n---\nenabled: true\nmode: standard\nmax_retries: 3\n---\n\n# Plugin Configuration\n\nYour settings are active.\n\\`\\`\\`\n\nAfter creating or editing, restart Claude Code for changes to take effect.\n```\n\n## Best Practices\n\n### File Naming\n\nâœ… **DO:**\n- Use `.claude/plugin-name.local.md` format\n- Match plugin name exactly\n- Use `.local.md` suffix for user-local files\n\nâŒ **DON'T:**\n- Use different directory (not `.claude/`)\n- Use inconsistent naming\n- Use `.md` without `.local` (might be committed)\n\n### Gitignore\n\nAlways add to `.gitignore`:\n\n```gitignore\n.claude/*.local.md\n.claude/*.local.json\n```\n\nDocument this in plugin README.\n\n### Defaults\n\nProvide sensible defaults when settings file doesn't exist:\n\n```bash\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  # Use defaults\n  ENABLED=true\n  MODE=standard\nelse\n  # Read from file\n  # ...\nfi\n```\n\n### Validation\n\nValidate settings values:\n\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n\n# Validate numeric range\nif ! [[ \"$MAX\" =~ ^[0-9]+$ ]] || [[ $MAX -lt 1 ]] || [[ $MAX -gt 100 ]]; then\n  echo \"âš ï¸  Invalid max_value in settings (must be 1-100)\" >&2\n  MAX=10  # Use default\nfi\n```\n\n### Restart Requirement\n\n**Important:** Settings changes require Claude Code restart.\n\nDocument in your README:\n\n```markdown\n## Changing Settings\n\nAfter editing `.claude/my-plugin.local.md`:\n1. Save the file\n2. Exit Claude Code\n3. Restart: `claude` or `cc`\n4. New settings will be loaded\n```\n\nHooks cannot be hot-swapped within a session.\n\n## Security Considerations\n\n### Sanitize User Input\n\nWhen writing settings files from user input:\n\n```bash\n# Escape quotes in user input\nSAFE_VALUE=$(echo \"$USER_INPUT\" | sed 's/\"/\\\\\"/g')\n\n# Write to file\ncat > \"$STATE_FILE\" <<EOF\n---\nuser_setting: \"$SAFE_VALUE\"\n---\nEOF\n```\n\n### Validate File Paths\n\nIf settings contain file paths:\n\n```bash\nFILE_PATH=$(echo \"$FRONTMATTER\" | grep '^data_file:' | sed 's/data_file: *//')\n\n# Check for path traversal\nif [[ \"$FILE_PATH\" == *\"..\"* ]]; then\n  echo \"âš ï¸  Invalid path in settings (path traversal)\" >&2\n  exit 2\nfi\n```\n\n### Permissions\n\nSettings files should be:\n- Readable by user only (`chmod 600`)\n- Not committed to git\n- Not shared between users\n\n## Real-World Examples\n\n### multi-agent-swarm Plugin\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-implementation\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\nadditional_instructions: Use JWT tokens, not sessions\n---\n\n# Task: Implement Authentication\n\nBuild JWT-based authentication for the REST API.\nCoordinate with auth-agent on shared types.\n```\n\n**Hook usage (agent-stop-notification.sh):**\n- Checks if file exists (line 15-18: quick exit if not)\n- Parses frontmatter to get coordinator_session, agent_name, enabled\n- Sends notifications to coordinator if enabled\n- Allows quick activation/deactivation via `enabled: true/false`\n\n### ralph-loop Plugin\n\n**.claude/ralph-loop.local.md:**\n```markdown\n---\niteration: 1\nmax_iterations: 10\ncompletion_promise: \"All tests passing and build successful\"\n---\n\nFix all the linting errors in the project.\nMake sure tests pass after each fix.\n```\n\n**Hook usage (stop-hook.sh):**\n- Checks if file exists (line 15-18: quick exit if not active)\n- Reads iteration count and max_iterations\n- Extracts completion_promise for loop termination\n- Reads body as the prompt to feed back\n- Updates iteration count on each loop\n\n## Quick Reference\n\n### File Location\n\n```\nproject-root/\nâ””â”€â”€ .claude/\n    â””â”€â”€ plugin-name.local.md\n```\n\n### Frontmatter Parsing\n\n```bash\n# Extract frontmatter\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n\n# Read field\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field:' | sed 's/field: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n### Body Parsing\n\n```bash\n# Extract body (after second ---)\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n### Quick Exit Pattern\n\n```bash\nif [[ ! -f \".claude/my-plugin.local.md\" ]]; then\n  exit 0  # Not configured\nfi\n```\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed implementation patterns:\n\n- **`references/parsing-techniques.md`** - Complete guide to parsing YAML frontmatter and markdown bodies\n- **`references/real-world-examples.md`** - Deep dive into multi-agent-swarm and ralph-loop implementations\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`read-settings-hook.sh`** - Hook that reads and uses settings\n- **`create-settings-command.md`** - Command that creates settings file\n- **`example-settings.md`** - Template settings file\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-settings.sh`** - Validate settings file structure\n- **`parse-frontmatter.sh`** - Extract frontmatter fields\n\n## Implementation Workflow\n\nTo add settings to a plugin:\n\n1. Design settings schema (which fields, types, defaults)\n2. Create template file in plugin documentation\n3. Add gitignore entry for `.claude/*.local.md`\n4. Implement settings parsing in hooks/commands\n5. Use quick-exit pattern (check file exists, check enabled field)\n6. Document settings in plugin README with template\n7. Remind users that changes require Claude Code restart\n\nFocus on keeping settings simple and providing good defaults when settings file doesn't exist."
              },
              {
                "name": "Plugin Structure",
                "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.",
                "path": "plugins/plugin-dev/skills/plugin-structure/SKILL.md",
                "frontmatter": {
                  "name": "Plugin Structure",
                  "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.",
                  "version": "0.1.0"
                },
                "content": "# Plugin Structure for Claude Code\n\n## Overview\n\nClaude Code plugins follow a standardized directory structure with automatic component discovery. Understanding this structure enables creating well-organized, maintainable plugins that integrate seamlessly with Claude Code.\n\n**Key concepts:**\n- Conventional directory layout for automatic discovery\n- Manifest-driven configuration in `.claude-plugin/plugin.json`\n- Component-based organization (commands, agents, skills, hooks)\n- Portable path references using `${CLAUDE_PLUGIN_ROOT}`\n- Explicit vs. auto-discovered component loading\n\n## Directory Structure\n\nEvery Claude Code plugin follows this organizational pattern:\n\n```\nplugin-name/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json          # Required: Plugin manifest\nâ”œâ”€â”€ commands/                 # Slash commands (.md files)\nâ”œâ”€â”€ agents/                   # Subagent definitions (.md files)\nâ”œâ”€â”€ skills/                   # Agent skills (subdirectories)\nâ”‚   â””â”€â”€ skill-name/\nâ”‚       â””â”€â”€ SKILL.md         # Required for each skill\nâ”œâ”€â”€ hooks/\nâ”‚   â””â”€â”€ hooks.json           # Event handler configuration\nâ”œâ”€â”€ .mcp.json                # MCP server definitions\nâ””â”€â”€ scripts/                 # Helper scripts and utilities\n```\n\n**Critical rules:**\n\n1. **Manifest location**: The `plugin.json` manifest MUST be in `.claude-plugin/` directory\n2. **Component locations**: All component directories (commands, agents, skills, hooks) MUST be at plugin root level, NOT nested inside `.claude-plugin/`\n3. **Optional components**: Only create directories for components the plugin actually uses\n4. **Naming convention**: Use kebab-case for all directory and file names\n\n## Plugin Manifest (plugin.json)\n\nThe manifest defines plugin metadata and configuration. Located at `.claude-plugin/plugin.json`:\n\n### Required Fields\n\n```json\n{\n  \"name\": \"plugin-name\"\n}\n```\n\n**Name requirements:**\n- Use kebab-case format (lowercase with hyphens)\n- Must be unique across installed plugins\n- No spaces or special characters\n- Example: `code-review-assistant`, `test-runner`, `api-docs`\n\n### Recommended Metadata\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Brief explanation of plugin purpose\",\n  \"author\": {\n    \"name\": \"Author Name\",\n    \"email\": \"author@example.com\",\n    \"url\": \"https://example.com\"\n  },\n  \"homepage\": \"https://docs.example.com\",\n  \"repository\": \"https://github.com/user/plugin-name\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"testing\", \"automation\", \"ci-cd\"]\n}\n```\n\n**Version format**: Follow semantic versioning (MAJOR.MINOR.PATCH)\n**Keywords**: Use for plugin discovery and categorization\n\n### Component Path Configuration\n\nSpecify custom paths for components (supplements default directories):\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"commands\": \"./custom-commands\",\n  \"agents\": [\"./agents\", \"./specialized-agents\"],\n  \"hooks\": \"./config/hooks.json\",\n  \"mcpServers\": \"./.mcp.json\"\n}\n```\n\n**Important**: Custom paths supplement defaultsâ€”they don't replace them. Components in both default directories and custom paths will load.\n\n**Path rules:**\n- Must be relative to plugin root\n- Must start with `./`\n- Cannot use absolute paths\n- Support arrays for multiple locations\n\n## Component Organization\n\n### Commands\n\n**Location**: `commands/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `commands/` load automatically\n\n**Example structure**:\n```\ncommands/\nâ”œâ”€â”€ review.md        # /review command\nâ”œâ”€â”€ test.md          # /test command\nâ””â”€â”€ deploy.md        # /deploy command\n```\n\n**File format**:\n```markdown\n---\nname: command-name\ndescription: Command description\n---\n\nCommand implementation instructions...\n```\n\n**Usage**: Commands integrate as native slash commands in Claude Code\n\n### Agents\n\n**Location**: `agents/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `agents/` load automatically\n\n**Example structure**:\n```\nagents/\nâ”œâ”€â”€ code-reviewer.md\nâ”œâ”€â”€ test-generator.md\nâ””â”€â”€ refactorer.md\n```\n\n**File format**:\n```markdown\n---\ndescription: Agent role and expertise\ncapabilities:\n  - Specific task 1\n  - Specific task 2\n---\n\nDetailed agent instructions and knowledge...\n```\n\n**Usage**: Users can invoke agents manually, or Claude Code selects them automatically based on task context\n\n### Skills\n\n**Location**: `skills/` directory with subdirectories per skill\n**Format**: Each skill in its own directory with `SKILL.md` file\n**Auto-discovery**: All `SKILL.md` files in skill subdirectories load automatically\n\n**Example structure**:\n```\nskills/\nâ”œâ”€â”€ api-testing/\nâ”‚   â”œâ”€â”€ SKILL.md\nâ”‚   â”œâ”€â”€ scripts/\nâ”‚   â”‚   â””â”€â”€ test-runner.py\nâ”‚   â””â”€â”€ references/\nâ”‚       â””â”€â”€ api-spec.md\nâ””â”€â”€ database-migrations/\n    â”œâ”€â”€ SKILL.md\n    â””â”€â”€ examples/\n        â””â”€â”€ migration-template.sql\n```\n\n**SKILL.md format**:\n```markdown\n---\nname: Skill Name\ndescription: When to use this skill\nversion: 1.0.0\n---\n\nSkill instructions and guidance...\n```\n\n**Supporting files**: Skills can include scripts, references, examples, or assets in subdirectories\n\n**Usage**: Claude Code autonomously activates skills based on task context matching the description\n\n### Hooks\n\n**Location**: `hooks/hooks.json` or inline in `plugin.json`\n**Format**: JSON configuration defining event handlers\n**Registration**: Hooks register automatically when plugin enables\n\n**Example structure**:\n```\nhooks/\nâ”œâ”€â”€ hooks.json           # Hook configuration\nâ””â”€â”€ scripts/\n    â”œâ”€â”€ validate.sh      # Hook script\n    â””â”€â”€ check-style.sh   # Hook script\n```\n\n**Configuration format**:\n```json\n{\n  \"PreToolUse\": [{\n    \"matcher\": \"Write|Edit\",\n    \"hooks\": [{\n      \"type\": \"command\",\n      \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/validate.sh\",\n      \"timeout\": 30\n    }]\n  }]\n}\n```\n\n**Available events**: PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification\n\n**Usage**: Hooks execute automatically in response to Claude Code events\n\n### MCP Servers\n\n**Location**: `.mcp.json` at plugin root or inline in `plugin.json`\n**Format**: JSON configuration for MCP server definitions\n**Auto-start**: Servers start automatically when plugin enables\n\n**Example format**:\n```json\n{\n  \"mcpServers\": {\n    \"server-name\": {\n      \"command\": \"node\",\n      \"args\": [\"${CLAUDE_PLUGIN_ROOT}/servers/server.js\"],\n      \"env\": {\n        \"API_KEY\": \"${API_KEY}\"\n      }\n    }\n  }\n}\n```\n\n**Usage**: MCP servers integrate seamlessly with Claude Code's tool system\n\n## Portable Path References\n\n### ${CLAUDE_PLUGIN_ROOT}\n\nUse `${CLAUDE_PLUGIN_ROOT}` environment variable for all intra-plugin path references:\n\n```json\n{\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/run.sh\"\n}\n```\n\n**Why it matters**: Plugins install in different locations depending on:\n- User installation method (marketplace, local, npm)\n- Operating system conventions\n- User preferences\n\n**Where to use it**:\n- Hook command paths\n- MCP server command arguments\n- Script execution references\n- Resource file paths\n\n**Never use**:\n- Hardcoded absolute paths (`/Users/name/plugins/...`)\n- Relative paths from working directory (`./scripts/...` in commands)\n- Home directory shortcuts (`~/plugins/...`)\n\n### Path Resolution Rules\n\n**In manifest JSON fields** (hooks, MCP servers):\n```json\n\"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/tool.sh\"\n```\n\n**In component files** (commands, agents, skills):\n```markdown\nReference scripts at: ${CLAUDE_PLUGIN_ROOT}/scripts/helper.py\n```\n\n**In executed scripts**:\n```bash\n#!/bin/bash\n# ${CLAUDE_PLUGIN_ROOT} available as environment variable\nsource \"${CLAUDE_PLUGIN_ROOT}/lib/common.sh\"\n```\n\n## File Naming Conventions\n\n### Component Files\n\n**Commands**: Use kebab-case `.md` files\n- `code-review.md` â†’ `/code-review`\n- `run-tests.md` â†’ `/run-tests`\n- `api-docs.md` â†’ `/api-docs`\n\n**Agents**: Use kebab-case `.md` files describing role\n- `test-generator.md`\n- `code-reviewer.md`\n- `performance-analyzer.md`\n\n**Skills**: Use kebab-case directory names\n- `api-testing/`\n- `database-migrations/`\n- `error-handling/`\n\n### Supporting Files\n\n**Scripts**: Use descriptive kebab-case names with appropriate extensions\n- `validate-input.sh`\n- `generate-report.py`\n- `process-data.js`\n\n**Documentation**: Use kebab-case markdown files\n- `api-reference.md`\n- `migration-guide.md`\n- `best-practices.md`\n\n**Configuration**: Use standard names\n- `hooks.json`\n- `.mcp.json`\n- `plugin.json`\n\n## Auto-Discovery Mechanism\n\nClaude Code automatically discovers and loads components:\n\n1. **Plugin manifest**: Reads `.claude-plugin/plugin.json` when plugin enables\n2. **Commands**: Scans `commands/` directory for `.md` files\n3. **Agents**: Scans `agents/` directory for `.md` files\n4. **Skills**: Scans `skills/` for subdirectories containing `SKILL.md`\n5. **Hooks**: Loads configuration from `hooks/hooks.json` or manifest\n6. **MCP servers**: Loads configuration from `.mcp.json` or manifest\n\n**Discovery timing**:\n- Plugin installation: Components register with Claude Code\n- Plugin enable: Components become available for use\n- No restart required: Changes take effect on next Claude Code session\n\n**Override behavior**: Custom paths in `plugin.json` supplement (not replace) default directories\n\n## Best Practices\n\n### Organization\n\n1. **Logical grouping**: Group related components together\n   - Put test-related commands, agents, and skills together\n   - Create subdirectories in `scripts/` for different purposes\n\n2. **Minimal manifest**: Keep `plugin.json` lean\n   - Only specify custom paths when necessary\n   - Rely on auto-discovery for standard layouts\n   - Use inline configuration only for simple cases\n\n3. **Documentation**: Include README files\n   - Plugin root: Overall purpose and usage\n   - Component directories: Specific guidance\n   - Script directories: Usage and requirements\n\n### Naming\n\n1. **Consistency**: Use consistent naming across components\n   - If command is `test-runner`, name related agent `test-runner-agent`\n   - Match skill directory names to their purpose\n\n2. **Clarity**: Use descriptive names that indicate purpose\n   - Good: `api-integration-testing/`, `code-quality-checker.md`\n   - Avoid: `utils/`, `misc.md`, `temp.sh`\n\n3. **Length**: Balance brevity with clarity\n   - Commands: 2-3 words (`review-pr`, `run-ci`)\n   - Agents: Describe role clearly (`code-reviewer`, `test-generator`)\n   - Skills: Topic-focused (`error-handling`, `api-design`)\n\n### Portability\n\n1. **Always use ${CLAUDE_PLUGIN_ROOT}**: Never hardcode paths\n2. **Test on multiple systems**: Verify on macOS, Linux, Windows\n3. **Document dependencies**: List required tools and versions\n4. **Avoid system-specific features**: Use portable bash/Python constructs\n\n### Maintenance\n\n1. **Version consistently**: Update version in plugin.json for releases\n2. **Deprecate gracefully**: Mark old components clearly before removal\n3. **Document breaking changes**: Note changes affecting existing users\n4. **Test thoroughly**: Verify all components work after changes\n\n## Common Patterns\n\n### Minimal Plugin\n\nSingle command with no dependencies:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json    # Just name field\nâ””â”€â”€ commands/\n    â””â”€â”€ hello.md       # Single command\n```\n\n### Full-Featured Plugin\n\nComplete plugin with all component types:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/          # User-facing commands\nâ”œâ”€â”€ agents/            # Specialized subagents\nâ”œâ”€â”€ skills/            # Auto-activating skills\nâ”œâ”€â”€ hooks/             # Event handlers\nâ”‚   â”œâ”€â”€ hooks.json\nâ”‚   â””â”€â”€ scripts/\nâ”œâ”€â”€ .mcp.json          # External integrations\nâ””â”€â”€ scripts/           # Shared utilities\n```\n\n### Skill-Focused Plugin\n\nPlugin providing only skills:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ””â”€â”€ skills/\n    â”œâ”€â”€ skill-one/\n    â”‚   â””â”€â”€ SKILL.md\n    â””â”€â”€ skill-two/\n        â””â”€â”€ SKILL.md\n```\n\n## Troubleshooting\n\n**Component not loading**:\n- Verify file is in correct directory with correct extension\n- Check YAML frontmatter syntax (commands, agents, skills)\n- Ensure skill has `SKILL.md` (not `README.md` or other name)\n- Confirm plugin is enabled in Claude Code settings\n\n**Path resolution errors**:\n- Replace all hardcoded paths with `${CLAUDE_PLUGIN_ROOT}`\n- Verify paths are relative and start with `./` in manifest\n- Check that referenced files exist at specified paths\n- Test with `echo $CLAUDE_PLUGIN_ROOT` in hook scripts\n\n**Auto-discovery not working**:\n- Confirm directories are at plugin root (not in `.claude-plugin/`)\n- Check file naming follows conventions (kebab-case, correct extensions)\n- Verify custom paths in manifest are correct\n- Restart Claude Code to reload plugin configuration\n\n**Conflicts between plugins**:\n- Use unique, descriptive component names\n- Namespace commands with plugin name if needed\n- Document potential conflicts in plugin README\n- Consider command prefixes for related functionality\n\n---\n\nFor detailed examples and advanced patterns, see files in `references/` and `examples/` directories."
              },
              {
                "name": "Skill Development",
                "description": "This skill should be used when the user wants to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins.",
                "path": "plugins/plugin-dev/skills/skill-development/SKILL.md",
                "frontmatter": {
                  "name": "Skill Development",
                  "description": "This skill should be used when the user wants to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins.",
                  "version": "0.1.0"
                },
                "content": "# Skill Development for Claude Code Plugins\n\nThis skill provides guidance for creating effective skills for Claude Code plugins.\n\n## About Skills\n\nSkills are modular, self-contained packages that extend Claude's capabilities by providing\nspecialized knowledge, workflows, and tools. Think of them as \"onboarding guides\" for specific\ndomains or tasksâ€”they transform Claude from a general-purpose agent into a specialized agent\nequipped with procedural knowledge that no model can fully possess.\n\n### What Skills Provide\n\n1. Specialized workflows - Multi-step procedures for specific domains\n2. Tool integrations - Instructions for working with specific file formats or APIs\n3. Domain expertise - Company-specific knowledge, schemas, business logic\n4. Bundled resources - Scripts, references, and assets for complex and repetitive tasks\n\n### Anatomy of a Skill\n\nEvery skill consists of a required SKILL.md file and optional bundled resources:\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md (required)\nâ”‚   â”œâ”€â”€ YAML frontmatter metadata (required)\nâ”‚   â”‚   â”œâ”€â”€ name: (required)\nâ”‚   â”‚   â””â”€â”€ description: (required)\nâ”‚   â””â”€â”€ Markdown instructions (required)\nâ””â”€â”€ Bundled Resources (optional)\n    â”œâ”€â”€ scripts/          - Executable code (Python/Bash/etc.)\n    â”œâ”€â”€ references/       - Documentation intended to be loaded into context as needed\n    â””â”€â”€ assets/           - Files used in output (templates, icons, fonts, etc.)\n```\n\n#### SKILL.md (required)\n\n**Metadata Quality:** The `name` and `description` in YAML frontmatter determine when Claude will use the skill. Be specific about what the skill does and when to use it. Use the third-person (e.g. \"This skill should be used when...\" instead of \"Use this skill when...\").\n\n#### Bundled Resources (optional)\n\n##### Scripts (`scripts/`)\n\nExecutable code (Python/Bash/etc.) for tasks that require deterministic reliability or are repeatedly rewritten.\n\n- **When to include**: When the same code is being rewritten repeatedly or deterministic reliability is needed\n- **Example**: `scripts/rotate_pdf.py` for PDF rotation tasks\n- **Benefits**: Token efficient, deterministic, may be executed without loading into context\n- **Note**: Scripts may still need to be read by Claude for patching or environment-specific adjustments\n\n##### References (`references/`)\n\nDocumentation and reference material intended to be loaded as needed into context to inform Claude's process and thinking.\n\n- **When to include**: For documentation that Claude should reference while working\n- **Examples**: `references/finance.md` for financial schemas, `references/mnda.md` for company NDA template, `references/policies.md` for company policies, `references/api_docs.md` for API specifications\n- **Use cases**: Database schemas, API documentation, domain knowledge, company policies, detailed workflow guides\n- **Benefits**: Keeps SKILL.md lean, loaded only when Claude determines it's needed\n- **Best practice**: If files are large (>10k words), include grep search patterns in SKILL.md\n- **Avoid duplication**: Information should live in either SKILL.md or references files, not both. Prefer references files for detailed information unless it's truly core to the skillâ€”this keeps SKILL.md lean while making information discoverable without hogging the context window. Keep only essential procedural instructions and workflow guidance in SKILL.md; move detailed reference material, schemas, and examples to references files.\n\n##### Assets (`assets/`)\n\nFiles not intended to be loaded into context, but rather used within the output Claude produces.\n\n- **When to include**: When the skill needs files that will be used in the final output\n- **Examples**: `assets/logo.png` for brand assets, `assets/slides.pptx` for PowerPoint templates, `assets/frontend-template/` for HTML/React boilerplate, `assets/font.ttf` for typography\n- **Use cases**: Templates, images, icons, boilerplate code, fonts, sample documents that get copied or modified\n- **Benefits**: Separates output resources from documentation, enables Claude to use files without loading them into context\n\n### Progressive Disclosure Design Principle\n\nSkills use a three-level loading system to manage context efficiently:\n\n1. **Metadata (name + description)** - Always in context (~100 words)\n2. **SKILL.md body** - When skill triggers (<5k words)\n3. **Bundled resources** - As needed by Claude (Unlimited*)\n\n*Unlimited because scripts can be executed without reading into context window.\n\n## Skill Creation Process\n\nTo create a skill, follow the \"Skill Creation Process\" in order, skipping steps only if there is a clear reason why they are not applicable.\n\n### Step 1: Understanding the Skill with Concrete Examples\n\nSkip this step only when the skill's usage patterns are already clearly understood. It remains valuable even when working with an existing skill.\n\nTo create an effective skill, clearly understand concrete examples of how the skill will be used. This understanding can come from either direct user examples or generated examples that are validated with user feedback.\n\nFor example, when building an image-editor skill, relevant questions include:\n\n- \"What functionality should the image-editor skill support? Editing, rotating, anything else?\"\n- \"Can you give some examples of how this skill would be used?\"\n- \"I can imagine users asking for things like 'Remove the red-eye from this image' or 'Rotate this image'. Are there other ways you imagine this skill being used?\"\n- \"What would a user say that should trigger this skill?\"\n\nTo avoid overwhelming users, avoid asking too many questions in a single message. Start with the most important questions and follow up as needed for better effectiveness.\n\nConclude this step when there is a clear sense of the functionality the skill should support.\n\n### Step 2: Planning the Reusable Skill Contents\n\nTo turn concrete examples into an effective skill, analyze each example by:\n\n1. Considering how to execute on the example from scratch\n2. Identifying what scripts, references, and assets would be helpful when executing these workflows repeatedly\n\nExample: When building a `pdf-editor` skill to handle queries like \"Help me rotate this PDF,\" the analysis shows:\n\n1. Rotating a PDF requires re-writing the same code each time\n2. A `scripts/rotate_pdf.py` script would be helpful to store in the skill\n\nExample: When designing a `frontend-webapp-builder` skill for queries like \"Build me a todo app\" or \"Build me a dashboard to track my steps,\" the analysis shows:\n\n1. Writing a frontend webapp requires the same boilerplate HTML/React each time\n2. An `assets/hello-world/` template containing the boilerplate HTML/React project files would be helpful to store in the skill\n\nExample: When building a `big-query` skill to handle queries like \"How many users have logged in today?\" the analysis shows:\n\n1. Querying BigQuery requires re-discovering the table schemas and relationships each time\n2. A `references/schema.md` file documenting the table schemas would be helpful to store in the skill\n\n**For Claude Code plugins:** When building a hooks skill, the analysis shows:\n1. Developers repeatedly need to validate hooks.json and test hook scripts\n2. `scripts/validate-hook-schema.sh` and `scripts/test-hook.sh` utilities would be helpful\n3. `references/patterns.md` for detailed hook patterns to avoid bloating SKILL.md\n\nTo establish the skill's contents, analyze each concrete example to create a list of the reusable resources to include: scripts, references, and assets.\n\n### Step 3: Create Skill Structure\n\nFor Claude Code plugins, create the skill directory structure:\n\n```bash\nmkdir -p plugin-name/skills/skill-name/{references,examples,scripts}\ntouch plugin-name/skills/skill-name/SKILL.md\n```\n\n**Note:** Unlike the generic skill-creator which uses `init_skill.py`, plugin skills are created directly in the plugin's `skills/` directory with a simpler manual structure.\n\n### Step 4: Edit the Skill\n\nWhen editing the (newly-created or existing) skill, remember that the skill is being created for another instance of Claude to use. Focus on including information that would be beneficial and non-obvious to Claude. Consider what procedural knowledge, domain-specific details, or reusable assets would help another Claude instance execute these tasks more effectively.\n\n#### Start with Reusable Skill Contents\n\nTo begin implementation, start with the reusable resources identified above: `scripts/`, `references/`, and `assets/` files. Note that this step may require user input. For example, when implementing a `brand-guidelines` skill, the user may need to provide brand assets or templates to store in `assets/`, or documentation to store in `references/`.\n\nAlso, delete any example files and directories not needed for the skill. Create only the directories you actually need (references/, examples/, scripts/).\n\n#### Update SKILL.md\n\n**Writing Style:** Write the entire skill using **imperative/infinitive form** (verb-first instructions), not second person. Use objective, instructional language (e.g., \"To accomplish X, do Y\" rather than \"You should do X\" or \"If you need to do X\"). This maintains consistency and clarity for AI consumption.\n\n**Description (Frontmatter):** Use third-person format with specific trigger phrases:\n\n```yaml\n---\nname: Skill Name\ndescription: This skill should be used when the user asks to \"specific phrase 1\", \"specific phrase 2\", \"specific phrase 3\". Include exact phrases users would say that should trigger this skill. Be concrete and specific.\nversion: 0.1.0\n---\n```\n\n**Good description examples:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", \"implement prompt-based hooks\", or mentions hook events (PreToolUse, PostToolUse, Stop).\n```\n\n**Bad description examples:**\n```yaml\ndescription: Use this skill when working with hooks.  # Wrong person, vague\ndescription: Load when user needs hook help.  # Not third person\ndescription: Provides hook guidance.  # No trigger phrases\n```\n\nTo complete SKILL.md body, answer the following questions:\n\n1. What is the purpose of the skill, in a few sentences?\n2. When should the skill be used? (Include this in frontmatter description with specific triggers)\n3. In practice, how should Claude use the skill? All reusable skill contents developed above should be referenced so that Claude knows how to use them.\n\n**Keep SKILL.md lean:** Target 1,500-2,000 words for the body. Move detailed content to references/:\n- Detailed patterns â†’ `references/patterns.md`\n- Advanced techniques â†’ `references/advanced.md`\n- Migration guides â†’ `references/migration.md`\n- API references â†’ `references/api-reference.md`\n\n**Reference resources in SKILL.md:**\n```markdown\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and techniques, consult:\n- **`references/patterns.md`** - Common patterns\n- **`references/advanced.md`** - Advanced use cases\n\n### Example Files\n\nWorking examples in `examples/`:\n- **`example-script.sh`** - Working example\n```\n\n### Step 5: Validate and Test\n\n**For plugin skills, validation is different from generic skills:**\n\n1. **Check structure**: Skill directory in `plugin-name/skills/skill-name/`\n2. **Validate SKILL.md**: Has frontmatter with name and description\n3. **Check trigger phrases**: Description includes specific user queries\n4. **Verify writing style**: Body uses imperative/infinitive form, not second person\n5. **Test progressive disclosure**: SKILL.md is lean (~1,500-2,000 words), detailed content in references/\n6. **Check references**: All referenced files exist\n7. **Validate examples**: Examples are complete and correct\n8. **Test scripts**: Scripts are executable and work correctly\n\n**Use the skill-reviewer agent:**\n```\nAsk: \"Review my skill and check if it follows best practices\"\n```\n\nThe skill-reviewer agent will check description quality, content organization, and progressive disclosure.\n\n### Step 6: Iterate\n\nAfter testing the skill, users may request improvements. Often this happens right after using the skill, with fresh context of how the skill performed.\n\n**Iteration workflow:**\n1. Use the skill on real tasks\n2. Notice struggles or inefficiencies\n3. Identify how SKILL.md or bundled resources should be updated\n4. Implement changes and test again\n\n**Common improvements:**\n- Strengthen trigger phrases in description\n- Move long sections from SKILL.md to references/\n- Add missing examples or scripts\n- Clarify ambiguous instructions\n- Add edge case handling\n\n## Plugin-Specific Considerations\n\n### Skill Location in Plugins\n\nPlugin skills live in the plugin's `skills/` directory:\n\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/\nâ”œâ”€â”€ agents/\nâ””â”€â”€ skills/\n    â””â”€â”€ my-skill/\n        â”œâ”€â”€ SKILL.md\n        â”œâ”€â”€ references/\n        â”œâ”€â”€ examples/\n        â””â”€â”€ scripts/\n```\n\n### Auto-Discovery\n\nClaude Code automatically discovers skills:\n- Scans `skills/` directory\n- Finds subdirectories containing `SKILL.md`\n- Loads skill metadata (name + description) always\n- Loads SKILL.md body when skill triggers\n- Loads references/examples when needed\n\n### No Packaging Needed\n\nPlugin skills are distributed as part of the plugin, not as separate ZIP files. Users get skills when they install the plugin.\n\n### Testing in Plugins\n\nTest skills by installing plugin locally:\n\n```bash\n# Test with --plugin-dir\ncc --plugin-dir /path/to/plugin\n\n# Ask questions that should trigger the skill\n# Verify skill loads correctly\n```\n\n## Examples from Plugin-Dev\n\nStudy the skills in this plugin as examples of best practices:\n\n**hook-development skill:**\n- Excellent trigger phrases: \"create a hook\", \"add a PreToolUse hook\", etc.\n- Lean SKILL.md (1,651 words)\n- 3 references/ files for detailed content\n- 3 examples/ of working hooks\n- 3 scripts/ utilities\n\n**agent-development skill:**\n- Strong triggers: \"create an agent\", \"agent frontmatter\", etc.\n- Focused SKILL.md (1,438 words)\n- References include the AI generation prompt from Claude Code\n- Complete agent examples\n\n**plugin-settings skill:**\n- Specific triggers: \"plugin settings\", \".local.md files\", \"YAML frontmatter\"\n- References show real implementations (multi-agent-swarm, ralph-loop)\n- Working parsing scripts\n\nEach demonstrates progressive disclosure and strong triggering.\n\n## Progressive Disclosure in Practice\n\n### What Goes in SKILL.md\n\n**Include (always loaded when skill triggers):**\n- Core concepts and overview\n- Essential procedures and workflows\n- Quick reference tables\n- Pointers to references/examples/scripts\n- Most common use cases\n\n**Keep under 3,000 words, ideally 1,500-2,000 words**\n\n### What Goes in references/\n\n**Move to references/ (loaded as needed):**\n- Detailed patterns and advanced techniques\n- Comprehensive API documentation\n- Migration guides\n- Edge cases and troubleshooting\n- Extensive examples and walkthroughs\n\n**Each reference file can be large (2,000-5,000+ words)**\n\n### What Goes in examples/\n\n**Working code examples:**\n- Complete, runnable scripts\n- Configuration files\n- Template files\n- Real-world usage examples\n\n**Users can copy and adapt these directly**\n\n### What Goes in scripts/\n\n**Utility scripts:**\n- Validation tools\n- Testing helpers\n- Parsing utilities\n- Automation scripts\n\n**Should be executable and documented**\n\n## Writing Style Requirements\n\n### Imperative/Infinitive Form\n\nWrite using verb-first instructions, not second person:\n\n**Correct (imperative):**\n```\nTo create a hook, define the event type.\nConfigure the MCP server with authentication.\nValidate settings before use.\n```\n\n**Incorrect (second person):**\n```\nYou should create a hook by defining the event type.\nYou need to configure the MCP server.\nYou must validate settings before use.\n```\n\n### Third-Person in Description\n\nThe frontmatter description must use third person:\n\n**Correct:**\n```yaml\ndescription: This skill should be used when the user asks to \"create X\", \"configure Y\"...\n```\n\n**Incorrect:**\n```yaml\ndescription: Use this skill when you want to create X...\ndescription: Load this skill when user asks...\n```\n\n### Objective, Instructional Language\n\nFocus on what to do, not who should do it:\n\n**Correct:**\n```\nParse the frontmatter using sed.\nExtract fields with grep.\nValidate values before use.\n```\n\n**Incorrect:**\n```\nYou can parse the frontmatter...\nClaude should extract fields...\nThe user might validate values...\n```\n\n## Validation Checklist\n\nBefore finalizing a skill:\n\n**Structure:**\n- [ ] SKILL.md file exists with valid YAML frontmatter\n- [ ] Frontmatter has `name` and `description` fields\n- [ ] Markdown body is present and substantial\n- [ ] Referenced files actually exist\n\n**Description Quality:**\n- [ ] Uses third person (\"This skill should be used when...\")\n- [ ] Includes specific trigger phrases users would say\n- [ ] Lists concrete scenarios (\"create X\", \"configure Y\")\n- [ ] Not vague or generic\n\n**Content Quality:**\n- [ ] SKILL.md body uses imperative/infinitive form\n- [ ] Body is focused and lean (1,500-2,000 words ideal, <5k max)\n- [ ] Detailed content moved to references/\n- [ ] Examples are complete and working\n- [ ] Scripts are executable and documented\n\n**Progressive Disclosure:**\n- [ ] Core concepts in SKILL.md\n- [ ] Detailed docs in references/\n- [ ] Working code in examples/\n- [ ] Utilities in scripts/\n- [ ] SKILL.md references these resources\n\n**Testing:**\n- [ ] Skill triggers on expected user queries\n- [ ] Content is helpful for intended tasks\n- [ ] No duplicated information across files\n- [ ] References load when needed\n\n## Common Mistakes to Avoid\n\n### Mistake 1: Weak Trigger Description\n\nâŒ **Bad:**\n```yaml\ndescription: Provides guidance for working with hooks.\n```\n\n**Why bad:** Vague, no specific trigger phrases, not third person\n\nâœ… **Good:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", or mentions hook events. Provides comprehensive hooks API guidance.\n```\n\n**Why good:** Third person, specific phrases, concrete scenarios\n\n### Mistake 2: Too Much in SKILL.md\n\nâŒ **Bad:**\n```\nskill-name/\nâ””â”€â”€ SKILL.md  (8,000 words - everything in one file)\n```\n\n**Why bad:** Bloats context when skill loads, detailed content always loaded\n\nâœ… **Good:**\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md  (1,800 words - core essentials)\nâ””â”€â”€ references/\n    â”œâ”€â”€ patterns.md (2,500 words)\n    â””â”€â”€ advanced.md (3,700 words)\n```\n\n**Why good:** Progressive disclosure, detailed content loaded only when needed\n\n### Mistake 3: Second Person Writing\n\nâŒ **Bad:**\n```markdown\nYou should start by reading the configuration file.\nYou need to validate the input.\nYou can use the grep tool to search.\n```\n\n**Why bad:** Second person, not imperative form\n\nâœ… **Good:**\n```markdown\nStart by reading the configuration file.\nValidate the input before processing.\nUse the grep tool to search for patterns.\n```\n\n**Why good:** Imperative form, direct instructions\n\n### Mistake 4: Missing Resource References\n\nâŒ **Bad:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n[No mention of references/ or examples/]\n```\n\n**Why bad:** Claude doesn't know references exist\n\nâœ… **Good:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n## Additional Resources\n\n### Reference Files\n- **`references/patterns.md`** - Detailed patterns\n- **`references/advanced.md`** - Advanced techniques\n\n### Examples\n- **`examples/script.sh`** - Working example\n```\n\n**Why good:** Claude knows where to find additional information\n\n## Quick Reference\n\n### Minimal Skill\n\n```\nskill-name/\nâ””â”€â”€ SKILL.md\n```\n\nGood for: Simple knowledge, no complex resources needed\n\n### Standard Skill (Recommended)\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md\nâ”œâ”€â”€ references/\nâ”‚   â””â”€â”€ detailed-guide.md\nâ””â”€â”€ examples/\n    â””â”€â”€ working-example.sh\n```\n\nGood for: Most plugin skills with detailed documentation\n\n### Complete Skill\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md\nâ”œâ”€â”€ references/\nâ”‚   â”œâ”€â”€ patterns.md\nâ”‚   â””â”€â”€ advanced.md\nâ”œâ”€â”€ examples/\nâ”‚   â”œâ”€â”€ example1.sh\nâ”‚   â””â”€â”€ example2.json\nâ””â”€â”€ scripts/\n    â””â”€â”€ validate.sh\n```\n\nGood for: Complex domains with validation utilities\n\n## Best Practices Summary\n\nâœ… **DO:**\n- Use third-person in description (\"This skill should be used when...\")\n- Include specific trigger phrases (\"create X\", \"configure Y\")\n- Keep SKILL.md lean (1,500-2,000 words)\n- Use progressive disclosure (move details to references/)\n- Write in imperative/infinitive form\n- Reference supporting files clearly\n- Provide working examples\n- Create utility scripts for common operations\n- Study plugin-dev's skills as templates\n\nâŒ **DON'T:**\n- Use second person anywhere\n- Have vague trigger conditions\n- Put everything in SKILL.md (>3,000 words without references/)\n- Write in second person (\"You should...\")\n- Leave resources unreferenced\n- Include broken or incomplete examples\n- Skip validation\n\n## Additional Resources\n\n### Study These Skills\n\nPlugin-dev's skills demonstrate best practices:\n- `../hook-development/` - Progressive disclosure, utilities\n- `../agent-development/` - AI-assisted creation, references\n- `../mcp-integration/` - Comprehensive references\n- `../plugin-settings/` - Real-world examples\n- `../command-development/` - Clear critical concepts\n- `../plugin-structure/` - Good organization\n\n### Reference Files\n\nFor complete skill-creator methodology:\n- **`references/skill-creator-original.md`** - Full original skill-creator content\n\n## Implementation Workflow\n\nTo create a skill for your plugin:\n\n1. **Understand use cases**: Identify concrete examples of skill usage\n2. **Plan resources**: Determine what scripts/references/examples needed\n3. **Create structure**: `mkdir -p skills/skill-name/{references,examples,scripts}`\n4. **Write SKILL.md**:\n   - Frontmatter with third-person description and trigger phrases\n   - Lean body (1,500-2,000 words) in imperative form\n   - Reference supporting files\n5. **Add resources**: Create references/, examples/, scripts/ as needed\n6. **Validate**: Check description, writing style, organization\n7. **Test**: Verify skill loads on expected triggers\n8. **Iterate**: Improve based on usage\n\nFocus on strong trigger descriptions, progressive disclosure, and imperative writing style for effective skills that load when needed and provide targeted guidance."
              }
            ]
          },
          {
            "name": "circleback",
            "description": "Circleback conversational context integration. Search and access meetings, emails, calendar events, and more.",
            "source": {
              "source": "url",
              "url": "https://github.com/circlebackai/claude-code-plugin.git"
            },
            "category": "productivity",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add anthropics/claude-plugins-official",
              "/plugin install circleback@claude-plugins-official"
            ],
            "signals": {
              "stars": 3233,
              "forks": 373,
              "pushed_at": "2026-01-12T23:05:15Z",
              "created_at": "2025-11-20T18:36:20Z",
              "license": null
            },
            "commands": [
              {
                "name": "/explain-error",
                "description": "Explain Stripe error codes and provide solutions with code examples",
                "path": "external_plugins/stripe/commands/explain-error.md",
                "frontmatter": {
                  "description": "Explain Stripe error codes and provide solutions with code examples",
                  "argument-hint": [
                    "error_code or error_message"
                  ]
                },
                "content": "# Explain Stripe Error\n\nProvide a comprehensive explanation of the given Stripe error code or error message:\n\n1. Accept the error code or full error message from the arguments\n2. Explain in plain English what the error means\n3. List common causes of this error\n4. Provide specific solutions and handling recommendations\n5. Generate error handling code in the project's language showing:\n   - How to catch this specific error\n   - User-friendly error messages\n   - Whether retry is appropriate\n6. Mention related error codes the developer should be aware of\n7. Include a link to the relevant Stripe documentation\n\nFocus on actionable solutions and production-ready error handling patterns."
              },
              {
                "name": "/test-cards",
                "description": "Display Stripe test card numbers for various testing scenarios",
                "path": "external_plugins/stripe/commands/test-cards.md",
                "frontmatter": {
                  "description": "Display Stripe test card numbers for various testing scenarios",
                  "argument-hint": [
                    "scenario"
                  ]
                },
                "content": "# Test Cards Reference\n\nProvide a quick reference for Stripe test card numbers:\n\n1. If a scenario argument is provided (e.g., \"declined\", \"3dsecure\", \"fraud\"), show relevant test cards for that scenario\n2. Otherwise, show the most common test cards organized by category:\n   - Successful payment (default card)\n   - 3D Secure authentication required\n   - Generic decline\n   - Specific decline reasons (insufficient_funds, lost_card, etc.)\n3. For each card, display:\n   - Card number (formatted with spaces)\n   - Expected behavior\n   - Expiry/CVC info (any future date and any 3-digit CVC)\n4. Use clear visual indicators (âœ“ for success, âš ï¸ for auth required, âœ— for decline)\n5. Mention that these only work in test mode\n6. Provide link to full testing documentation: https://docs.stripe.com/testing.md\n\nIf the user is currently working on test code, offer to generate test cases using these cards."
              },
              {
                "name": "/new-sdk-app",
                "description": "Create and setup a new Claude Agent SDK application",
                "path": "plugins/agent-sdk-dev/commands/new-sdk-app.md",
                "frontmatter": {
                  "description": "Create and setup a new Claude Agent SDK application",
                  "argument-hint": [
                    "project-name"
                  ]
                },
                "content": "You are tasked with helping the user create a new Claude Agent SDK application. Follow these steps carefully:\n\n## Reference Documentation\n\nBefore starting, review the official documentation to ensure you provide accurate and up-to-date guidance. Use WebFetch to read these pages:\n\n1. **Start with the overview**: https://docs.claude.com/en/api/agent-sdk/overview\n2. **Based on the user's language choice, read the appropriate SDK reference**:\n   - TypeScript: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Python: https://docs.claude.com/en/api/agent-sdk/python\n3. **Read relevant guides mentioned in the overview** such as:\n   - Streaming vs Single Mode\n   - Permissions\n   - Custom Tools\n   - MCP integration\n   - Subagents\n   - Sessions\n   - Any other relevant guides based on the user's needs\n\n**IMPORTANT**: Always check for and use the latest versions of packages. Use WebSearch or WebFetch to verify current versions before installation.\n\n## Gather Requirements\n\nIMPORTANT: Ask these questions one at a time. Wait for the user's response before asking the next question. This makes it easier for the user to respond.\n\nAsk the questions in this order (skip any that the user has already provided via arguments):\n\n1. **Language** (ask first): \"Would you like to use TypeScript or Python?\"\n\n   - Wait for response before continuing\n\n2. **Project name** (ask second): \"What would you like to name your project?\"\n\n   - If $ARGUMENTS is provided, use that as the project name and skip this question\n   - Wait for response before continuing\n\n3. **Agent type** (ask third, but skip if #2 was sufficiently detailed): \"What kind of agent are you building? Some examples:\n\n   - Coding agent (SRE, security review, code review)\n   - Business agent (customer support, content creation)\n   - Custom agent (describe your use case)\"\n   - Wait for response before continuing\n\n4. **Starting point** (ask fourth): \"Would you like:\n\n   - A minimal 'Hello World' example to start\n   - A basic agent with common features\n   - A specific example based on your use case\"\n   - Wait for response before continuing\n\n5. **Tooling choice** (ask fifth): Let the user know what tools you'll use, and confirm with them that these are the tools they want to use (for example, they may prefer pnpm or bun over npm). Respect the user's preferences when executing on the requirements.\n\nAfter all questions are answered, proceed to create the setup plan.\n\n## Setup Plan\n\nBased on the user's answers, create a plan that includes:\n\n1. **Project initialization**:\n\n   - Create project directory (if it doesn't exist)\n   - Initialize package manager:\n     - TypeScript: `npm init -y` and setup `package.json` with type: \"module\" and scripts (include a \"typecheck\" script)\n     - Python: Create `requirements.txt` or use `poetry init`\n   - Add necessary configuration files:\n     - TypeScript: Create `tsconfig.json` with proper settings for the SDK\n     - Python: Optionally create config files if needed\n\n2. **Check for Latest Versions**:\n\n   - BEFORE installing, use WebSearch or check npm/PyPI to find the latest version\n   - For TypeScript: Check https://www.npmjs.com/package/@anthropic-ai/claude-agent-sdk\n   - For Python: Check https://pypi.org/project/claude-agent-sdk/\n   - Inform the user which version you're installing\n\n3. **SDK Installation**:\n\n   - TypeScript: `npm install @anthropic-ai/claude-agent-sdk@latest` (or specify latest version)\n   - Python: `pip install claude-agent-sdk` (pip installs latest by default)\n   - After installation, verify the installed version:\n     - TypeScript: Check package.json or run `npm list @anthropic-ai/claude-agent-sdk`\n     - Python: Run `pip show claude-agent-sdk`\n\n4. **Create starter files**:\n\n   - TypeScript: Create an `index.ts` or `src/index.ts` with a basic query example\n   - Python: Create a `main.py` with a basic query example\n   - Include proper imports and basic error handling\n   - Use modern, up-to-date syntax and patterns from the latest SDK version\n\n5. **Environment setup**:\n\n   - Create a `.env.example` file with `ANTHROPIC_API_KEY=your_api_key_here`\n   - Add `.env` to `.gitignore`\n   - Explain how to get an API key from https://console.anthropic.com/\n\n6. **Optional: Create .claude directory structure**:\n   - Offer to create `.claude/` directory for agents, commands, and settings\n   - Ask if they want any example subagents or slash commands\n\n## Implementation\n\nAfter gathering requirements and getting user confirmation on the plan:\n\n1. Check for latest package versions using WebSearch or WebFetch\n2. Execute the setup steps\n3. Create all necessary files\n4. Install dependencies (always use latest stable versions)\n5. Verify installed versions and inform the user\n6. Create a working example based on their agent type\n7. Add helpful comments in the code explaining what each part does\n8. **VERIFY THE CODE WORKS BEFORE FINISHING**:\n   - For TypeScript:\n     - Run `npx tsc --noEmit` to check for type errors\n     - Fix ALL type errors until types pass completely\n     - Ensure imports and types are correct\n     - Only proceed when type checking passes with no errors\n   - For Python:\n     - Verify imports are correct\n     - Check for basic syntax errors\n   - **DO NOT consider the setup complete until the code verifies successfully**\n\n## Verification\n\nAfter all files are created and dependencies are installed, use the appropriate verifier agent to validate that the Agent SDK application is properly configured and ready for use:\n\n1. **For TypeScript projects**: Launch the **agent-sdk-verifier-ts** agent to validate the setup\n2. **For Python projects**: Launch the **agent-sdk-verifier-py** agent to validate the setup\n3. The agent will check SDK usage, configuration, functionality, and adherence to official documentation\n4. Review the verification report and address any issues\n\n## Getting Started Guide\n\nOnce setup is complete and verified, provide the user with:\n\n1. **Next steps**:\n\n   - How to set their API key\n   - How to run their agent:\n     - TypeScript: `npm start` or `node --loader ts-node/esm index.ts`\n     - Python: `python main.py`\n\n2. **Useful resources**:\n\n   - Link to TypeScript SDK reference: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Link to Python SDK reference: https://docs.claude.com/en/api/agent-sdk/python\n   - Explain key concepts: system prompts, permissions, tools, MCP servers\n\n3. **Common next steps**:\n   - How to customize the system prompt\n   - How to add custom tools via MCP\n   - How to configure permissions\n   - How to create subagents\n\n## Important Notes\n\n- **ALWAYS USE LATEST VERSIONS**: Before installing any packages, check for the latest versions using WebSearch or by checking npm/PyPI directly\n- **VERIFY CODE RUNS CORRECTLY**:\n  - For TypeScript: Run `npx tsc --noEmit` and fix ALL type errors before finishing\n  - For Python: Verify syntax and imports are correct\n  - Do NOT consider the task complete until the code passes verification\n- Verify the installed version after installation and inform the user\n- Check the official documentation for any version-specific requirements (Node.js version, Python version, etc.)\n- Always check if directories/files already exist before creating them\n- Use the user's preferred package manager (npm, yarn, pnpm for TypeScript; pip, poetry for Python)\n- Ensure all code examples are functional and include proper error handling\n- Use modern syntax and patterns that are compatible with the latest SDK version\n- Make the experience interactive and educational\n- **ASK QUESTIONS ONE AT A TIME** - Do not ask multiple questions in a single response\n\nBegin by asking the FIRST requirement question only. Wait for the user's answer before proceeding to the next question."
              },
              {
                "name": "/code-review",
                "description": "Code review a pull request",
                "path": "plugins/code-review/commands/code-review.md",
                "frontmatter": {
                  "allowed-tools": "Bash(gh issue view:*), Bash(gh search:*), Bash(gh issue list:*), Bash(gh pr comment:*), Bash(gh pr diff:*), Bash(gh pr view:*), Bash(gh pr list:*)",
                  "description": "Code review a pull request",
                  "disable-model-invocation": false
                },
                "content": "Provide a code review for the given pull request.\n\nTo do this, follow these steps precisely:\n\n1. Use a Haiku agent to check if the pull request (a) is closed, (b) is a draft, (c) does not need a code review (eg. because it is an automated pull request, or is very simple and obviously ok), or (d) already has a code review from you from earlier. If so, do not proceed.\n2. Use another Haiku agent to give you a list of file paths to (but not the contents of) any relevant CLAUDE.md files from the codebase: the root CLAUDE.md file (if one exists), as well as any CLAUDE.md files in the directories whose files the pull request modified\n3. Use a Haiku agent to view the pull request, and ask the agent to return a summary of the change\n4. Then, launch 5 parallel Sonnet agents to independently code review the change. The agents should do the following, then return a list of issues and the reason each issue was flagged (eg. CLAUDE.md adherence, bug, historical git context, etc.):\n   a. Agent #1: Audit the changes to make sure they compily with the CLAUDE.md. Note that CLAUDE.md is guidance for Claude as it writes code, so not all instructions will be applicable during code review.\n   b. Agent #2: Read the file changes in the pull request, then do a shallow scan for obvious bugs. Avoid reading extra context beyond the changes, focusing just on the changes themselves. Focus on large bugs, and avoid small issues and nitpicks. Ignore likely false positives.\n   c. Agent #3: Read the git blame and history of the code modified, to identify any bugs in light of that historical context\n   d. Agent #4: Read previous pull requests that touched these files, and check for any comments on those pull requests that may also apply to the current pull request.\n   e. Agent #5: Read code comments in the modified files, and make sure the changes in the pull request comply with any guidance in the comments.\n5. For each issue found in #4, launch a parallel Haiku agent that takes the PR, issue description, and list of CLAUDE.md files (from step 2), and returns a score to indicate the agent's level of confidence for whether the issue is real or false positive. To do that, the agent should score each issue on a scale from 0-100, indicating its level of confidence. For issues that were flagged due to CLAUDE.md instructions, the agent should double check that the CLAUDE.md actually calls out that issue specifically. The scale is (give this rubric to the agent verbatim):\n   a. 0: Not confident at all. This is a false positive that doesn't stand up to light scrutiny, or is a pre-existing issue.\n   b. 25: Somewhat confident. This might be a real issue, but may also be a false positive. The agent wasn't able to verify that it's a real issue. If the issue is stylistic, it is one that was not explicitly called out in the relevant CLAUDE.md.\n   c. 50: Moderately confident. The agent was able to verify this is a real issue, but it might be a nitpick or not happen very often in practice. Relative to the rest of the PR, it's not very important.\n   d. 75: Highly confident. The agent double checked the issue, and verified that it is very likely it is a real issue that will be hit in practice. The existing approach in the PR is insufficient. The issue is very important and will directly impact the code's functionality, or it is an issue that is directly mentioned in the relevant CLAUDE.md.\n   e. 100: Absolutely certain. The agent double checked the issue, and confirmed that it is definitely a real issue, that will happen frequently in practice. The evidence directly confirms this.\n6. Filter out any issues with a score less than 80. If there are no issues that meet this criteria, do not proceed.\n7. Use a Haiku agent to repeat the eligibility check from #1, to make sure that the pull request is still eligible for code review.\n8. Finally, use the gh bash command to comment back on the pull request with the result. When writing your comment, keep in mind to:\n   a. Keep your output brief\n   b. Avoid emojis\n   c. Link and cite relevant code, files, and URLs\n\nExamples of false positives, for steps 4 and 5:\n\n- Pre-existing issues\n- Something that looks like a bug but is not actually a bug\n- Pedantic nitpicks that a senior engineer wouldn't call out\n- Issues that a linter, typechecker, or compiler would catch (eg. missing or incorrect imports, type errors, broken tests, formatting issues, pedantic style issues like newlines). No need to run these build steps yourself -- it is safe to assume that they will be run separately as part of CI.\n- General code quality issues (eg. lack of test coverage, general security issues, poor documentation), unless explicitly required in CLAUDE.md\n- Issues that are called out in CLAUDE.md, but explicitly silenced in the code (eg. due to a lint ignore comment)\n- Changes in functionality that are likely intentional or are directly related to the broader change\n- Real issues, but on lines that the user did not modify in their pull request\n\nNotes:\n\n- Do not check build signal or attempt to build or typecheck the app. These will run separately, and are not relevant to your code review.\n- Use `gh` to interact with Github (eg. to fetch a pull request, or to create inline comments), rather than web fetch\n- Make a todo list first\n- You must cite and link each bug (eg. if referring to a CLAUDE.md, you must link it)\n- For your final comment, follow the following format precisely (assuming for this example that you found 3 issues):\n\n---\n\n### Code review\n\nFound 3 issues:\n\n1. <brief description of bug> (CLAUDE.md says \"<...>\")\n\n<link to file and line with full sha1 + line range for context, note that you MUST provide the full sha and not use bash here, eg. https://github.com/anthropics/claude-code/blob/1d54823877c4de72b2316a64032a54afc404e619/README.md#L13-L17>\n\n2. <brief description of bug> (some/other/CLAUDE.md says \"<...>\")\n\n<link to file and line with full sha1 + line range for context>\n\n3. <brief description of bug> (bug due to <file and code snippet>)\n\n<link to file and line with full sha1 + line range for context>\n\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\n<sub>- If this code review was useful, please react with ðŸ‘. Otherwise, react with ðŸ‘Ž.</sub>\n\n---\n\n- Or, if you found no issues:\n\n---\n\n### Code review\n\nNo issues found. Checked for bugs and CLAUDE.md compliance.\n\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\n- When linking to code, follow the following format precisely, otherwise the Markdown preview won't render correctly: https://github.com/anthropics/claude-cli-internal/blob/c21d3c10bc8e898b7ac1a2d745bdc9bc4e423afe/package.json#L10-L15\n  - Requires full git sha\n  - You must provide the full sha. Commands like `https://github.com/owner/repo/blob/$(git rev-parse HEAD)/foo/bar` will not work, since your comment will be directly rendered in Markdown.\n  - Repo name must match the repo you're code reviewing\n  - # sign after the file name\n  - Line range format is L[start]-L[end]\n  - Provide at least 1 line of context before and after, centered on the line you are commenting about (eg. if you are commenting about lines 5-6, you should link to `L4-7`)"
              },
              {
                "name": "/clean_gone",
                "description": "Cleans up all git branches marked as [gone] (branches that have been deleted on the remote but still exist locally), including removing associated worktrees.",
                "path": "plugins/commit-commands/commands/clean_gone.md",
                "frontmatter": {
                  "description": "Cleans up all git branches marked as [gone] (branches that have been deleted on the remote but still exist locally), including removing associated worktrees."
                },
                "content": "## Your Task\n\nYou need to execute the following bash commands to clean up stale local branches that have been deleted from the remote repository.\n\n## Commands to Execute\n\n1. **First, list branches to identify any with [gone] status**\n   Execute this command:\n   ```bash\n   git branch -v\n   ```\n   \n   Note: Branches with a '+' prefix have associated worktrees and must have their worktrees removed before deletion.\n\n2. **Next, identify worktrees that need to be removed for [gone] branches**\n   Execute this command:\n   ```bash\n   git worktree list\n   ```\n\n3. **Finally, remove worktrees and delete [gone] branches (handles both regular and worktree branches)**\n   Execute this command:\n   ```bash\n   # Process all [gone] branches, removing '+' prefix if present\n   git branch -v | grep '\\[gone\\]' | sed 's/^[+* ]//' | awk '{print $1}' | while read branch; do\n     echo \"Processing branch: $branch\"\n     # Find and remove worktree if it exists\n     worktree=$(git worktree list | grep \"\\\\[$branch\\\\]\" | awk '{print $1}')\n     if [ ! -z \"$worktree\" ] && [ \"$worktree\" != \"$(git rev-parse --show-toplevel)\" ]; then\n       echo \"  Removing worktree: $worktree\"\n       git worktree remove --force \"$worktree\"\n     fi\n     # Delete the branch\n     echo \"  Deleting branch: $branch\"\n     git branch -D \"$branch\"\n   done\n   ```\n\n## Expected Behavior\n\nAfter executing these commands, you will:\n\n- See a list of all local branches with their status\n- Identify and remove any worktrees associated with [gone] branches\n- Delete all branches marked as [gone]\n- Provide feedback on which worktrees and branches were removed\n\nIf no branches are marked as [gone], report that no cleanup was needed."
              },
              {
                "name": "/commit-push-pr",
                "description": "Commit, push, and open a PR",
                "path": "plugins/commit-commands/commands/commit-push-pr.md",
                "frontmatter": {
                  "allowed-tools": "Bash(git checkout --branch:*), Bash(git add:*), Bash(git status:*), Bash(git push:*), Bash(git commit:*), Bash(gh pr create:*)",
                  "description": "Commit, push, and open a PR"
                },
                "content": "## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n\n## Your task\n\nBased on the above changes:\n\n1. Create a new branch if on main\n2. Create a single commit with an appropriate message\n3. Push the branch to origin\n4. Create a pull request using `gh pr create`\n5. You have the capability to call multiple tools in a single response. You MUST do all of the above in a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls."
              },
              {
                "name": "/commit",
                "description": "Create a git commit",
                "path": "plugins/commit-commands/commands/commit.md",
                "frontmatter": {
                  "allowed-tools": "Bash(git add:*), Bash(git status:*), Bash(git commit:*)",
                  "description": "Create a git commit"
                },
                "content": "## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n- Recent commits: !`git log --oneline -10`\n\n## Your task\n\nBased on the above changes, create a single git commit.\n\nYou have the capability to call multiple tools in a single response. Stage and create the commit using a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls."
              },
              {
                "name": "/example-command",
                "description": "An example slash command that demonstrates command frontmatter options",
                "path": "plugins/example-plugin/commands/example-command.md",
                "frontmatter": {
                  "description": "An example slash command that demonstrates command frontmatter options",
                  "argument-hint": "<required-arg> [optional-arg]",
                  "allowed-tools": [
                    "Read",
                    "Glob",
                    "Grep",
                    "Bash"
                  ]
                },
                "content": "# Example Command\n\nThis command demonstrates slash command structure and frontmatter options.\n\n## Arguments\n\nThe user invoked this command with: $ARGUMENTS\n\n## Instructions\n\nWhen this command is invoked:\n\n1. Parse the arguments provided by the user\n2. Perform the requested action using allowed tools\n3. Report results back to the user\n\n## Frontmatter Options Reference\n\nCommands support these frontmatter fields:\n\n- **description**: Short description shown in /help\n- **argument-hint**: Hints for command arguments shown to user\n- **allowed-tools**: Pre-approved tools for this command (reduces permission prompts)\n- **model**: Override the model (e.g., \"haiku\", \"sonnet\", \"opus\")\n\n## Example Usage\n\n```\n/example-command my-argument\n/example-command arg1 arg2\n```"
              },
              {
                "name": "/feature-dev",
                "description": "Guided feature development with codebase understanding and architecture focus",
                "path": "plugins/feature-dev/commands/feature-dev.md",
                "frontmatter": {
                  "description": "Guided feature development with codebase understanding and architecture focus",
                  "argument-hint": "Optional feature description"
                },
                "content": "# Feature Development\n\nYou are helping a developer implement a new feature. Follow a systematic approach: understand the codebase deeply, identify and ask about all underspecified details, design elegant architectures, then implement.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities, edge cases, and underspecified behaviors. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation. Ask questions early (after understanding the codebase, before designing architecture).\n- **Understand before acting**: Read and comprehend existing code patterns first\n- **Read files identified by agents**: When launching agents, ask them to return lists of the most important files to read. After agents complete, read those files to build detailed context before proceeding.\n- **Simple and elegant**: Prioritize readable, maintainable, architecturally sound code\n- **Use TodoWrite**: Track all progress throughout\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what needs to be built\n\nInitial request: $ARGUMENTS\n\n**Actions**:\n1. Create todo list with all phases\n2. If feature unclear, ask user for:\n   - What problem are they solving?\n   - What should the feature do?\n   - Any constraints or requirements?\n3. Summarize understanding and confirm with user\n\n---\n\n## Phase 2: Codebase Exploration\n\n**Goal**: Understand relevant existing code and patterns at both high and low levels\n\n**Actions**:\n1. Launch 2-3 code-explorer agents in parallel. Each agent should:\n   - Trace through the code comprehensively and focus on getting a comprehensive understanding of abstractions, architecture and flow of control\n   - Target a different aspect of the codebase (eg. similar features, high level understanding, architectural understanding, user experience, etc)\n   - Include a list of 5-10 key files to read\n\n   **Example agent prompts**:\n   - \"Find features similar to [feature] and trace through their implementation comprehensively\"\n   - \"Map the architecture and abstractions for [feature area], tracing through the code comprehensively\"\n   - \"Analyze the current implementation of [existing feature/area], tracing through the code comprehensively\"\n   - \"Identify UI patterns, testing approaches, or extension points relevant to [feature]\"\n\n2. Once the agents return, please read all files identified by agents to build deep understanding\n3. Present comprehensive summary of findings and patterns discovered\n\n---\n\n## Phase 3: Clarifying Questions\n\n**Goal**: Fill in gaps and resolve all ambiguities before designing\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. Review the codebase findings and original feature request\n2. Identify underspecified aspects: edge cases, error handling, integration points, scope boundaries, design preferences, backward compatibility, performance needs\n3. **Present all questions to the user in a clear, organized list**\n4. **Wait for answers before proceeding to architecture design**\n\nIf the user says \"whatever you think is best\", provide your recommendation and get explicit confirmation.\n\n---\n\n## Phase 4: Architecture Design\n\n**Goal**: Design multiple implementation approaches with different trade-offs\n\n**Actions**:\n1. Launch 2-3 code-architect agents in parallel with different focuses: minimal changes (smallest change, maximum reuse), clean architecture (maintainability, elegant abstractions), or pragmatic balance (speed + quality)\n2. Review all approaches and form your opinion on which fits best for this specific task (consider: small fix vs large feature, urgency, complexity, team context)\n3. Present to user: brief summary of each approach, trade-offs comparison, **your recommendation with reasoning**, concrete implementation differences\n4. **Ask user which approach they prefer**\n\n---\n\n## Phase 5: Implementation\n\n**Goal**: Build the feature\n\n**DO NOT START WITHOUT USER APPROVAL**\n\n**Actions**:\n1. Wait for explicit user approval\n2. Read all relevant files identified in previous phases\n3. Implement following chosen architecture\n4. Follow codebase conventions strictly\n5. Write clean, well-documented code\n6. Update todos as you progress\n\n---\n\n## Phase 6: Quality Review\n\n**Goal**: Ensure code is simple, DRY, elegant, easy to read, and functionally correct\n\n**Actions**:\n1. Launch 3 code-reviewer agents in parallel with different focuses: simplicity/DRY/elegance, bugs/functional correctness, project conventions/abstractions\n2. Consolidate findings and identify highest severity issues that you recommend fixing\n3. **Present findings to user and ask what they want to do** (fix now, fix later, or proceed as-is)\n4. Address issues based on user decision\n\n---\n\n## Phase 7: Summary\n\n**Goal**: Document what was accomplished\n\n**Actions**:\n1. Mark all todos complete\n2. Summarize:\n   - What was built\n   - Key decisions made\n   - Files modified\n   - Suggested next steps\n\n---"
              },
              {
                "name": "/configure",
                "description": "Enable or disable hookify rules interactively",
                "path": "plugins/hookify/commands/configure.md",
                "frontmatter": {
                  "description": "Enable or disable hookify rules interactively",
                  "allowed-tools": [
                    "Glob",
                    "Read",
                    "Edit",
                    "AskUserQuestion",
                    "Skill"
                  ]
                },
                "content": "# Configure Hookify Rules\n\n**Load hookify:writing-rules skill first** to understand rule format.\n\nEnable or disable existing hookify rules using an interactive interface.\n\n## Steps\n\n### 1. Find Existing Rules\n\nUse Glob tool to find all hookify rule files:\n```\npattern: \".claude/hookify.*.local.md\"\n```\n\nIf no rules found, inform user:\n```\nNo hookify rules configured yet. Use `/hookify` to create your first rule.\n```\n\n### 2. Read Current State\n\nFor each rule file:\n- Read the file\n- Extract `name` and `enabled` fields from frontmatter\n- Build list of rules with current state\n\n### 3. Ask User Which Rules to Toggle\n\nUse AskUserQuestion to let user select rules:\n\n```json\n{\n  \"questions\": [\n    {\n      \"question\": \"Which rules would you like to enable or disable?\",\n      \"header\": \"Configure\",\n      \"multiSelect\": true,\n      \"options\": [\n        {\n          \"label\": \"warn-dangerous-rm (currently enabled)\",\n          \"description\": \"Warns about rm -rf commands\"\n        },\n        {\n          \"label\": \"warn-console-log (currently disabled)\",\n          \"description\": \"Warns about console.log in code\"\n        },\n        {\n          \"label\": \"require-tests (currently enabled)\",\n          \"description\": \"Requires tests before stopping\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Option format:**\n- Label: `{rule-name} (currently {enabled|disabled})`\n- Description: Brief description from rule's message or pattern\n\n### 4. Parse User Selection\n\nFor each selected rule:\n- Determine current state from label (enabled/disabled)\n- Toggle state: enabled â†’ disabled, disabled â†’ enabled\n\n### 5. Update Rule Files\n\nFor each rule to toggle:\n- Use Read tool to read current content\n- Use Edit tool to change `enabled: true` to `enabled: false` (or vice versa)\n- Handle both with and without quotes\n\n**Edit pattern for enabling:**\n```\nold_string: \"enabled: false\"\nnew_string: \"enabled: true\"\n```\n\n**Edit pattern for disabling:**\n```\nold_string: \"enabled: true\"\nnew_string: \"enabled: false\"\n```\n\n### 6. Confirm Changes\n\nShow user what was changed:\n\n```\n## Hookify Rules Updated\n\n**Enabled:**\n- warn-console-log\n\n**Disabled:**\n- warn-dangerous-rm\n\n**Unchanged:**\n- require-tests\n\nChanges apply immediately - no restart needed\n```\n\n## Important Notes\n\n- Changes take effect immediately on next tool use\n- You can also manually edit .claude/hookify.*.local.md files\n- To permanently remove a rule, delete its .local.md file\n- Use `/hookify:list` to see all configured rules\n\n## Edge Cases\n\n**No rules to configure:**\n- Show message about using `/hookify` to create rules first\n\n**User selects no rules:**\n- Inform that no changes were made\n\n**File read/write errors:**\n- Inform user of specific error\n- Suggest manual editing as fallback"
              },
              {
                "name": "/help",
                "description": "Get help with the hookify plugin",
                "path": "plugins/hookify/commands/help.md",
                "frontmatter": {
                  "description": "Get help with the hookify plugin",
                  "allowed-tools": [
                    "Read"
                  ]
                },
                "content": "# Hookify Plugin Help\n\nExplain how the hookify plugin works and how to use it.\n\n## Overview\n\nThe hookify plugin makes it easy to create custom hooks that prevent unwanted behaviors. Instead of editing `hooks.json` files, users create simple markdown configuration files that define patterns to watch for.\n\n## How It Works\n\n### 1. Hook System\n\nHookify installs generic hooks that run on these events:\n- **PreToolUse**: Before any tool executes (Bash, Edit, Write, etc.)\n- **PostToolUse**: After a tool executes\n- **Stop**: When Claude wants to stop working\n- **UserPromptSubmit**: When user submits a prompt\n\nThese hooks read configuration files from `.claude/hookify.*.local.md` and check if any rules match the current operation.\n\n### 2. Configuration Files\n\nUsers create rules in `.claude/hookify.{rule-name}.local.md` files:\n\n```markdown\n---\nname: warn-dangerous-rm\nenabled: true\nevent: bash\npattern: rm\\s+-rf\n---\n\nâš ï¸ **Dangerous rm command detected!**\n\nThis command could delete important files. Please verify the path.\n```\n\n**Key fields:**\n- `name`: Unique identifier for the rule\n- `enabled`: true/false to activate/deactivate\n- `event`: bash, file, stop, prompt, or all\n- `pattern`: Regex pattern to match\n\nThe message body is what Claude sees when the rule triggers.\n\n### 3. Creating Rules\n\n**Option A: Use /hookify command**\n```\n/hookify Don't use console.log in production files\n```\n\nThis analyzes your request and creates the appropriate rule file.\n\n**Option B: Create manually**\nCreate `.claude/hookify.my-rule.local.md` with the format above.\n\n**Option C: Analyze conversation**\n```\n/hookify\n```\n\nWithout arguments, hookify analyzes recent conversation to find behaviors you want to prevent.\n\n## Available Commands\n\n- **`/hookify`** - Create hooks from conversation analysis or explicit instructions\n- **`/hookify:help`** - Show this help (what you're reading now)\n- **`/hookify:list`** - List all configured hooks\n- **`/hookify:configure`** - Enable/disable existing hooks interactively\n\n## Example Use Cases\n\n**Prevent dangerous commands:**\n```markdown\n---\nname: block-chmod-777\nenabled: true\nevent: bash\npattern: chmod\\s+777\n---\n\nDon't use chmod 777 - it's a security risk. Use specific permissions instead.\n```\n\n**Warn about debugging code:**\n```markdown\n---\nname: warn-console-log\nenabled: true\nevent: file\npattern: console\\.log\\(\n---\n\nConsole.log detected. Remember to remove debug logging before committing.\n```\n\n**Require tests before stopping:**\n```markdown\n---\nname: require-tests\nenabled: true\nevent: stop\npattern: .*\n---\n\nDid you run tests before finishing? Make sure `npm test` or equivalent was executed.\n```\n\n## Pattern Syntax\n\nUse Python regex syntax:\n- `\\s` - whitespace\n- `\\.` - literal dot\n- `|` - OR\n- `+` - one or more\n- `*` - zero or more\n- `\\d` - digit\n- `[abc]` - character class\n\n**Examples:**\n- `rm\\s+-rf` - matches \"rm -rf\"\n- `console\\.log\\(` - matches \"console.log(\"\n- `(eval|exec)\\(` - matches \"eval(\" or \"exec(\"\n- `\\.env$` - matches files ending in .env\n\n## Important Notes\n\n**No Restart Needed**: Hookify rules (`.local.md` files) take effect immediately on the next tool use. The hookify hooks are already loaded and read your rules dynamically.\n\n**Block or Warn**: Rules can either `block` operations (prevent execution) or `warn` (show message but allow). Set `action: block` or `action: warn` in the rule's frontmatter.\n\n**Rule Files**: Keep rules in `.claude/hookify.*.local.md` - they should be git-ignored (add to .gitignore if needed).\n\n**Disable Rules**: Set `enabled: false` in frontmatter or delete the file.\n\n## Troubleshooting\n\n**Hook not triggering:**\n- Check rule file is in `.claude/` directory\n- Verify `enabled: true` in frontmatter\n- Confirm pattern is valid regex\n- Test pattern: `python3 -c \"import re; print(re.search('your_pattern', 'test_text'))\"`\n- Rules take effect immediately - no restart needed\n\n**Import errors:**\n- Check Python 3 is available: `python3 --version`\n- Verify hookify plugin is installed correctly\n\n**Pattern not matching:**\n- Test regex separately\n- Check for escaping issues (use unquoted patterns in YAML)\n- Try simpler pattern first, then refine\n\n## Getting Started\n\n1. Create your first rule:\n   ```\n   /hookify Warn me when I try to use rm -rf\n   ```\n\n2. Try to trigger it:\n   - Ask Claude to run `rm -rf /tmp/test`\n   - You should see the warning\n\n4. Refine the rule by editing `.claude/hookify.warn-rm.local.md`\n\n5. Create more rules as you encounter unwanted behaviors\n\nFor more examples, check the `${CLAUDE_PLUGIN_ROOT}/examples/` directory."
              },
              {
                "name": "/hookify",
                "description": "Create hooks to prevent unwanted behaviors from conversation analysis or explicit instructions",
                "path": "plugins/hookify/commands/hookify.md",
                "frontmatter": {
                  "description": "Create hooks to prevent unwanted behaviors from conversation analysis or explicit instructions",
                  "argument-hint": "Optional specific behavior to address",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "AskUserQuestion",
                    "Task",
                    "Grep",
                    "TodoWrite",
                    "Skill"
                  ]
                },
                "content": "# Hookify - Create Hooks from Unwanted Behaviors\n\n**FIRST: Load the hookify:writing-rules skill** using the Skill tool to understand rule file format and syntax.\n\nCreate hook rules to prevent problematic behaviors by analyzing the conversation or from explicit user instructions.\n\n## Your Task\n\nYou will help the user create hookify rules to prevent unwanted behaviors. Follow these steps:\n\n### Step 1: Gather Behavior Information\n\n**If $ARGUMENTS is provided:**\n- User has given specific instructions: `$ARGUMENTS`\n- Still analyze recent conversation (last 10-15 user messages) for additional context\n- Look for examples of the behavior happening\n\n**If $ARGUMENTS is empty:**\n- Launch the conversation-analyzer agent to find problematic behaviors\n- Agent will scan user prompts for frustration signals\n- Agent will return structured findings\n\n**To analyze conversation:**\nUse the Task tool to launch conversation-analyzer agent:\n```\n{\n  \"subagent_type\": \"general-purpose\",\n  \"description\": \"Analyze conversation for unwanted behaviors\",\n  \"prompt\": \"You are analyzing a Claude Code conversation to find behaviors the user wants to prevent.\n\nRead user messages in the current conversation and identify:\n1. Explicit requests to avoid something (\\\"don't do X\\\", \\\"stop doing Y\\\")\n2. Corrections or reversions (user fixing Claude's actions)\n3. Frustrated reactions (\\\"why did you do X?\\\", \\\"I didn't ask for that\\\")\n4. Repeated issues (same problem multiple times)\n\nFor each issue found, extract:\n- What tool was used (Bash, Edit, Write, etc.)\n- Specific pattern or command\n- Why it was problematic\n- User's stated reason\n\nReturn findings as a structured list with:\n- category: Type of issue\n- tool: Which tool was involved\n- pattern: Regex or literal pattern to match\n- context: What happened\n- severity: high/medium/low\n\nFocus on the most recent issues (last 20-30 messages). Don't go back further unless explicitly asked.\"\n}\n```\n\n### Step 2: Present Findings to User\n\nAfter gathering behaviors (from arguments or agent), present to user using AskUserQuestion:\n\n**Question 1: Which behaviors to hookify?**\n- Header: \"Create Rules\"\n- multiSelect: true\n- Options: List each detected behavior (max 4)\n  - Label: Short description (e.g., \"Block rm -rf\")\n  - Description: Why it's problematic\n\n**Question 2: For each selected behavior, ask about action:**\n- \"Should this block the operation or just warn?\"\n- Options:\n  - \"Just warn\" (action: warn - shows message but allows)\n  - \"Block operation\" (action: block - prevents execution)\n\n**Question 3: Ask for example patterns:**\n- \"What patterns should trigger this rule?\"\n- Show detected patterns\n- Allow user to refine or add more\n\n### Step 3: Generate Rule Files\n\nFor each confirmed behavior, create a `.claude/hookify.{rule-name}.local.md` file:\n\n**Rule naming convention:**\n- Use kebab-case\n- Be descriptive: `block-dangerous-rm`, `warn-console-log`, `require-tests-before-stop`\n- Start with action verb: block, warn, prevent, require\n\n**File format:**\n```markdown\n---\nname: {rule-name}\nenabled: true\nevent: {bash|file|stop|prompt|all}\npattern: {regex pattern}\naction: {warn|block}\n---\n\n{Message to show Claude when rule triggers}\n```\n\n**Action values:**\n- `warn`: Show message but allow operation (default)\n- `block`: Prevent operation or stop session\n\n**For more complex rules (multiple conditions):**\n```markdown\n---\nname: {rule-name}\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$\n  - field: new_text\n    operator: contains\n    pattern: API_KEY\n---\n\n{Warning message}\n```\n\n### Step 4: Create Files and Confirm\n\n**IMPORTANT**: Rule files must be created in the current working directory's `.claude/` folder, NOT the plugin directory.\n\nUse the current working directory (where Claude Code was started) as the base path.\n\n1. Check if `.claude/` directory exists in current working directory\n   - If not, create it first with: `mkdir -p .claude`\n\n2. Use Write tool to create each `.claude/hookify.{name}.local.md` file\n   - Use relative path from current working directory: `.claude/hookify.{name}.local.md`\n   - The path should resolve to the project's .claude directory, not the plugin's\n\n3. Show user what was created:\n   ```\n   Created 3 hookify rules:\n   - .claude/hookify.dangerous-rm.local.md\n   - .claude/hookify.console-log.local.md\n   - .claude/hookify.sensitive-files.local.md\n\n   These rules will trigger on:\n   - dangerous-rm: Bash commands matching \"rm -rf\"\n   - console-log: Edits adding console.log statements\n   - sensitive-files: Edits to .env or credentials files\n   ```\n\n4. Verify files were created in the correct location by listing them\n\n5. Inform user: **\"Rules are active immediately - no restart needed!\"**\n\n   The hookify hooks are already loaded and will read your new rules on the next tool use.\n\n## Event Types Reference\n\n- **bash**: Matches Bash tool commands\n- **file**: Matches Edit, Write, MultiEdit tools\n- **stop**: Matches when agent wants to stop (use for completion checks)\n- **prompt**: Matches when user submits prompts\n- **all**: Matches all events\n\n## Pattern Writing Tips\n\n**Bash patterns:**\n- Match dangerous commands: `rm\\s+-rf|chmod\\s+777|dd\\s+if=`\n- Match specific tools: `npm\\s+install\\s+|pip\\s+install`\n\n**File patterns:**\n- Match code patterns: `console\\.log\\(|eval\\(|innerHTML\\s*=`\n- Match file paths: `\\.env$|\\.git/|node_modules/`\n\n**Stop patterns:**\n- Check for missing steps: (check transcript or completion criteria)\n\n## Example Workflow\n\n**User says**: \"/hookify Don't use rm -rf without asking me first\"\n\n**Your response**:\n1. Analyze: User wants to prevent rm -rf commands\n2. Ask: \"Should I block this command or just warn you?\"\n3. User selects: \"Just warn\"\n4. Create `.claude/hookify.dangerous-rm.local.md`:\n   ```markdown\n   ---\n   name: warn-dangerous-rm\n   enabled: true\n   event: bash\n   pattern: rm\\s+-rf\n   ---\n\n   âš ï¸ **Dangerous rm command detected**\n\n   You requested to be warned before using rm -rf.\n   Please verify the path is correct.\n   ```\n5. Confirm: \"Created hookify rule. It's active immediately - try triggering it!\"\n\n## Important Notes\n\n- **No restart needed**: Rules take effect immediately on the next tool use\n- **File location**: Create files in project's `.claude/` directory (current working directory), NOT the plugin's .claude/\n- **Regex syntax**: Use Python regex syntax (raw strings, no need to escape in YAML)\n- **Action types**: Rules can `warn` (default) or `block` operations\n- **Testing**: Test rules immediately after creating them\n\n## Troubleshooting\n\n**If rule file creation fails:**\n1. Check current working directory with pwd\n2. Ensure `.claude/` directory exists (create with mkdir if needed)\n3. Use absolute path if needed: `{cwd}/.claude/hookify.{name}.local.md`\n4. Verify file was created with Glob or ls\n\n**If rule doesn't trigger after creation:**\n1. Verify file is in project `.claude/` not plugin `.claude/`\n2. Check file with Read tool to ensure pattern is correct\n3. Test pattern with: `python3 -c \"import re; print(re.search(r'pattern', 'test text'))\"`\n4. Verify `enabled: true` in frontmatter\n5. Remember: Rules work immediately, no restart needed\n\n**If blocking seems too strict:**\n1. Change `action: block` to `action: warn` in the rule file\n2. Or adjust the pattern to be more specific\n3. Changes take effect on next tool use\n\nUse TodoWrite to track your progress through the steps."
              },
              {
                "name": "/list",
                "description": "List all configured hookify rules",
                "path": "plugins/hookify/commands/list.md",
                "frontmatter": {
                  "description": "List all configured hookify rules",
                  "allowed-tools": [
                    "Glob",
                    "Read",
                    "Skill"
                  ]
                },
                "content": "# List Hookify Rules\n\n**Load hookify:writing-rules skill first** to understand rule format.\n\nShow all configured hookify rules in the project.\n\n## Steps\n\n1. Use Glob tool to find all hookify rule files:\n   ```\n   pattern: \".claude/hookify.*.local.md\"\n   ```\n\n2. For each file found:\n   - Use Read tool to read the file\n   - Extract frontmatter fields: name, enabled, event, pattern\n   - Extract message preview (first 100 chars)\n\n3. Present results in a table:\n\n```\n## Configured Hookify Rules\n\n| Name | Enabled | Event | Pattern | File |\n|------|---------|-------|---------|------|\n| warn-dangerous-rm | âœ… Yes | bash | rm\\s+-rf | hookify.dangerous-rm.local.md |\n| warn-console-log | âœ… Yes | file | console\\.log\\( | hookify.console-log.local.md |\n| check-tests | âŒ No | stop | .* | hookify.require-tests.local.md |\n\n**Total**: 3 rules (2 enabled, 1 disabled)\n```\n\n4. For each rule, show a brief preview:\n```\n### warn-dangerous-rm\n**Event**: bash\n**Pattern**: `rm\\s+-rf`\n**Message**: \"âš ï¸ **Dangerous rm command detected!** This command could delete...\"\n\n**Status**: âœ… Active\n**File**: .claude/hookify.dangerous-rm.local.md\n```\n\n5. Add helpful footer:\n```\n---\n\nTo modify a rule: Edit the .local.md file directly\nTo disable a rule: Set `enabled: false` in frontmatter\nTo enable a rule: Set `enabled: true` in frontmatter\nTo delete a rule: Remove the .local.md file\nTo create a rule: Use `/hookify` command\n\n**Remember**: Changes take effect immediately - no restart needed\n```\n\n## If No Rules Found\n\nIf no hookify rules exist:\n\n```\n## No Hookify Rules Configured\n\nYou haven't created any hookify rules yet.\n\nTo get started:\n1. Use `/hookify` to analyze conversation and create rules\n2. Or manually create `.claude/hookify.my-rule.local.md` files\n3. See `/hookify:help` for documentation\n\nExample:\n```\n/hookify Warn me when I use console.log\n```\n\nCheck `${CLAUDE_PLUGIN_ROOT}/examples/` for example rule files.\n```"
              },
              {
                "name": "/create-plugin",
                "description": "Guided end-to-end plugin creation workflow with component design, implementation, and validation",
                "path": "plugins/plugin-dev/commands/create-plugin.md",
                "frontmatter": {
                  "description": "Guided end-to-end plugin creation workflow with component design, implementation, and validation",
                  "argument-hint": "Optional plugin description",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "Grep",
                    "Glob",
                    "Bash",
                    "TodoWrite",
                    "AskUserQuestion",
                    "Skill",
                    "Task"
                  ]
                },
                "content": "# Plugin Creation Workflow\n\nGuide the user through creating a complete, high-quality Claude Code plugin from initial concept to tested implementation. Follow a systematic approach: understand requirements, design components, clarify details, implement following best practices, validate, and test.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities about plugin purpose, triggering, scope, and components. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation.\n- **Load relevant skills**: Use the Skill tool to load plugin-dev skills when needed (plugin-structure, hook-development, agent-development, etc.)\n- **Use specialized agents**: Leverage agent-creator, plugin-validator, and skill-reviewer agents for AI-assisted development\n- **Follow best practices**: Apply patterns from plugin-dev's own implementation\n- **Progressive disclosure**: Create lean skills with references/examples\n- **Use TodoWrite**: Track all progress throughout all phases\n\n**Initial request:** $ARGUMENTS\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what plugin needs to be built and what problem it solves\n\n**Actions**:\n1. Create todo list with all 7 phases\n2. If plugin purpose is clear from arguments:\n   - Summarize understanding\n   - Identify plugin type (integration, workflow, analysis, toolkit, etc.)\n3. If plugin purpose is unclear, ask user:\n   - What problem does this plugin solve?\n   - Who will use it and when?\n   - What should it do?\n   - Any similar plugins to reference?\n4. Summarize understanding and confirm with user before proceeding\n\n**Output**: Clear statement of plugin purpose and target users\n\n---\n\n## Phase 2: Component Planning\n\n**Goal**: Determine what plugin components are needed\n\n**MUST load plugin-structure skill** using Skill tool before this phase.\n\n**Actions**:\n1. Load plugin-structure skill to understand component types\n2. Analyze plugin requirements and determine needed components:\n   - **Skills**: Does it need specialized knowledge? (hooks API, MCP patterns, etc.)\n   - **Commands**: User-initiated actions? (deploy, configure, analyze)\n   - **Agents**: Autonomous tasks? (validation, generation, analysis)\n   - **Hooks**: Event-driven automation? (validation, notifications)\n   - **MCP**: External service integration? (databases, APIs)\n   - **Settings**: User configuration? (.local.md files)\n3. For each component type needed, identify:\n   - How many of each type\n   - What each one does\n   - Rough triggering/usage patterns\n4. Present component plan to user as table:\n   ```\n   | Component Type | Count | Purpose |\n   |----------------|-------|---------|\n   | Skills         | 2     | Hook patterns, MCP usage |\n   | Commands       | 3     | Deploy, configure, validate |\n   | Agents         | 1     | Autonomous validation |\n   | Hooks          | 0     | Not needed |\n   | MCP            | 1     | Database integration |\n   ```\n5. Get user confirmation or adjustments\n\n**Output**: Confirmed list of components to create\n\n---\n\n## Phase 3: Detailed Design & Clarifying Questions\n\n**Goal**: Specify each component in detail and resolve all ambiguities\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. For each component in the plan, identify underspecified aspects:\n   - **Skills**: What triggers them? What knowledge do they provide? How detailed?\n   - **Commands**: What arguments? What tools? Interactive or automated?\n   - **Agents**: When to trigger (proactive/reactive)? What tools? Output format?\n   - **Hooks**: Which events? Prompt or command based? Validation criteria?\n   - **MCP**: What server type? Authentication? Which tools?\n   - **Settings**: What fields? Required vs optional? Defaults?\n\n2. **Present all questions to user in organized sections** (one section per component type)\n\n3. **Wait for answers before proceeding to implementation**\n\n4. If user says \"whatever you think is best\", provide specific recommendations and get explicit confirmation\n\n**Example questions for a skill**:\n- What specific user queries should trigger this skill?\n- Should it include utility scripts? What functionality?\n- How detailed should the core SKILL.md be vs references/?\n- Any real-world examples to include?\n\n**Example questions for an agent**:\n- Should this agent trigger proactively after certain actions, or only when explicitly requested?\n- What tools does it need (Read, Write, Bash, etc.)?\n- What should the output format be?\n- Any specific quality standards to enforce?\n\n**Output**: Detailed specification for each component\n\n---\n\n## Phase 4: Plugin Structure Creation\n\n**Goal**: Create plugin directory structure and manifest\n\n**Actions**:\n1. Determine plugin name (kebab-case, descriptive)\n2. Choose plugin location:\n   - Ask user: \"Where should I create the plugin?\"\n   - Offer options: current directory, ../new-plugin-name, custom path\n3. Create directory structure using bash:\n   ```bash\n   mkdir -p plugin-name/.claude-plugin\n   mkdir -p plugin-name/skills     # if needed\n   mkdir -p plugin-name/commands   # if needed\n   mkdir -p plugin-name/agents     # if needed\n   mkdir -p plugin-name/hooks      # if needed\n   ```\n4. Create plugin.json manifest using Write tool:\n   ```json\n   {\n     \"name\": \"plugin-name\",\n     \"version\": \"0.1.0\",\n     \"description\": \"[brief description]\",\n     \"author\": {\n       \"name\": \"[author from user or default]\",\n       \"email\": \"[email or default]\"\n     }\n   }\n   ```\n5. Create README.md template\n6. Create .gitignore if needed (for .claude/*.local.md, etc.)\n7. Initialize git repo if creating new directory\n\n**Output**: Plugin directory structure created and ready for components\n\n---\n\n## Phase 5: Component Implementation\n\n**Goal**: Create each component following best practices\n\n**LOAD RELEVANT SKILLS** before implementing each component type:\n- Skills: Load skill-development skill\n- Commands: Load command-development skill\n- Agents: Load agent-development skill\n- Hooks: Load hook-development skill\n- MCP: Load mcp-integration skill\n- Settings: Load plugin-settings skill\n\n**Actions for each component**:\n\n### For Skills:\n1. Load skill-development skill using Skill tool\n2. For each skill:\n   - Ask user for concrete usage examples (or use from Phase 3)\n   - Plan resources (scripts/, references/, examples/)\n   - Create skill directory structure\n   - Write SKILL.md with:\n     - Third-person description with specific trigger phrases\n     - Lean body (1,500-2,000 words) in imperative form\n     - References to supporting files\n   - Create reference files for detailed content\n   - Create example files for working code\n   - Create utility scripts if needed\n3. Use skill-reviewer agent to validate each skill\n\n### For Commands:\n1. Load command-development skill using Skill tool\n2. For each command:\n   - Write command markdown with frontmatter\n   - Include clear description and argument-hint\n   - Specify allowed-tools (minimal necessary)\n   - Write instructions FOR Claude (not TO user)\n   - Provide usage examples and tips\n   - Reference relevant skills if applicable\n\n### For Agents:\n1. Load agent-development skill using Skill tool\n2. For each agent, use agent-creator agent:\n   - Provide description of what agent should do\n   - Agent-creator generates: identifier, whenToUse with examples, systemPrompt\n   - Create agent markdown file with frontmatter and system prompt\n   - Add appropriate model, color, and tools\n   - Validate with validate-agent.sh script\n\n### For Hooks:\n1. Load hook-development skill using Skill tool\n2. For each hook:\n   - Create hooks/hooks.json with hook configuration\n   - Prefer prompt-based hooks for complex logic\n   - Use ${CLAUDE_PLUGIN_ROOT} for portability\n   - Create hook scripts if needed (in examples/ not scripts/)\n   - Test with validate-hook-schema.sh and test-hook.sh utilities\n\n### For MCP:\n1. Load mcp-integration skill using Skill tool\n2. Create .mcp.json configuration with:\n   - Server type (stdio for local, SSE for hosted)\n   - Command and args (with ${CLAUDE_PLUGIN_ROOT})\n   - extensionToLanguage mapping if LSP\n   - Environment variables as needed\n3. Document required env vars in README\n4. Provide setup instructions\n\n### For Settings:\n1. Load plugin-settings skill using Skill tool\n2. Create settings template in README\n3. Create example .claude/plugin-name.local.md file (as documentation)\n4. Implement settings reading in hooks/commands as needed\n5. Add to .gitignore: `.claude/*.local.md`\n\n**Progress tracking**: Update todos as each component is completed\n\n**Output**: All plugin components implemented\n\n---\n\n## Phase 6: Validation & Quality Check\n\n**Goal**: Ensure plugin meets quality standards and works correctly\n\n**Actions**:\n1. **Run plugin-validator agent**:\n   - Use plugin-validator agent to comprehensively validate plugin\n   - Check: manifest, structure, naming, components, security\n   - Review validation report\n\n2. **Fix critical issues**:\n   - Address any critical errors from validation\n   - Fix any warnings that indicate real problems\n\n3. **Review with skill-reviewer** (if plugin has skills):\n   - For each skill, use skill-reviewer agent\n   - Check description quality, progressive disclosure, writing style\n   - Apply recommendations\n\n4. **Test agent triggering** (if plugin has agents):\n   - For each agent, verify <example> blocks are clear\n   - Check triggering conditions are specific\n   - Run validate-agent.sh on agent files\n\n5. **Test hook configuration** (if plugin has hooks):\n   - Run validate-hook-schema.sh on hooks/hooks.json\n   - Test hook scripts with test-hook.sh\n   - Verify ${CLAUDE_PLUGIN_ROOT} usage\n\n6. **Present findings**:\n   - Summary of validation results\n   - Any remaining issues\n   - Overall quality assessment\n\n7. **Ask user**: \"Validation complete. Issues found: [count critical], [count warnings]. Would you like me to fix them now, or proceed to testing?\"\n\n**Output**: Plugin validated and ready for testing\n\n---\n\n## Phase 7: Testing & Verification\n\n**Goal**: Test that plugin works correctly in Claude Code\n\n**Actions**:\n1. **Installation instructions**:\n   - Show user how to test locally:\n     ```bash\n     cc --plugin-dir /path/to/plugin-name\n     ```\n   - Or copy to `.claude-plugin/` for project testing\n\n2. **Verification checklist** for user to perform:\n   - [ ] Skills load when triggered (ask questions with trigger phrases)\n   - [ ] Commands appear in `/help` and execute correctly\n   - [ ] Agents trigger on appropriate scenarios\n   - [ ] Hooks activate on events (if applicable)\n   - [ ] MCP servers connect (if applicable)\n   - [ ] Settings files work (if applicable)\n\n3. **Testing recommendations**:\n   - For skills: Ask questions using trigger phrases from descriptions\n   - For commands: Run `/plugin-name:command-name` with various arguments\n   - For agents: Create scenarios matching agent examples\n   - For hooks: Use `claude --debug` to see hook execution\n   - For MCP: Use `/mcp` to verify servers and tools\n\n4. **Ask user**: \"I've prepared the plugin for testing. Would you like me to guide you through testing each component, or do you want to test it yourself?\"\n\n5. **If user wants guidance**, walk through testing each component with specific test cases\n\n**Output**: Plugin tested and verified working\n\n---\n\n## Phase 8: Documentation & Next Steps\n\n**Goal**: Ensure plugin is well-documented and ready for distribution\n\n**Actions**:\n1. **Verify README completeness**:\n   - Check README has: overview, features, installation, prerequisites, usage\n   - For MCP plugins: Document required environment variables\n   - For hook plugins: Explain hook activation\n   - For settings: Provide configuration templates\n\n2. **Add marketplace entry** (if publishing):\n   - Show user how to add to marketplace.json\n   - Help draft marketplace description\n   - Suggest category and tags\n\n3. **Create summary**:\n   - Mark all todos complete\n   - List what was created:\n     - Plugin name and purpose\n     - Components created (X skills, Y commands, Z agents, etc.)\n     - Key files and their purposes\n     - Total file count and structure\n   - Next steps:\n     - Testing recommendations\n     - Publishing to marketplace (if desired)\n     - Iteration based on usage\n\n4. **Suggest improvements** (optional):\n   - Additional components that could enhance plugin\n   - Integration opportunities\n   - Testing strategies\n\n**Output**: Complete, documented plugin ready for use or publication\n\n---\n\n## Important Notes\n\n### Throughout All Phases\n\n- **Use TodoWrite** to track progress at every phase\n- **Load skills with Skill tool** when working on specific component types\n- **Use specialized agents** (agent-creator, plugin-validator, skill-reviewer)\n- **Ask for user confirmation** at key decision points\n- **Follow plugin-dev's own patterns** as reference examples\n- **Apply best practices**:\n  - Third-person descriptions for skills\n  - Imperative form in skill bodies\n  - Commands written FOR Claude\n  - Strong trigger phrases\n  - ${CLAUDE_PLUGIN_ROOT} for portability\n  - Progressive disclosure\n  - Security-first (HTTPS, no hardcoded credentials)\n\n### Key Decision Points (Wait for User)\n\n1. After Phase 1: Confirm plugin purpose\n2. After Phase 2: Approve component plan\n3. After Phase 3: Proceed to implementation\n4. After Phase 6: Fix issues or proceed\n5. After Phase 7: Continue to documentation\n\n### Skills to Load by Phase\n\n- **Phase 2**: plugin-structure\n- **Phase 5**: skill-development, command-development, agent-development, hook-development, mcp-integration, plugin-settings (as needed)\n- **Phase 6**: (agents will use skills automatically)\n\n### Quality Standards\n\nEvery component must meet these standards:\n- âœ… Follows plugin-dev's proven patterns\n- âœ… Uses correct naming conventions\n- âœ… Has strong trigger conditions (skills/agents)\n- âœ… Includes working examples\n- âœ… Properly documented\n- âœ… Validated with utilities\n- âœ… Tested in Claude Code\n\n---\n\n## Example Workflow\n\n### User Request\n\"Create a plugin for managing database migrations\"\n\n### Phase 1: Discovery\n- Understand: Migration management, database schema versioning\n- Confirm: User wants to create, run, rollback migrations\n\n### Phase 2: Component Planning\n- Skills: 1 (migration best practices)\n- Commands: 3 (create-migration, run-migrations, rollback)\n- Agents: 1 (migration-validator)\n- MCP: 1 (database connection)\n\n### Phase 3: Clarifying Questions\n- Which databases? (PostgreSQL, MySQL, etc.)\n- Migration file format? (SQL, code-based?)\n- Should agent validate before applying?\n- What MCP tools needed? (query, execute, schema)\n\n### Phase 4-8: Implementation, Validation, Testing, Documentation\n\n---\n\n**Begin with Phase 1: Discovery**"
              },
              {
                "name": "/review-pr",
                "description": "Comprehensive PR review using specialized agents",
                "path": "plugins/pr-review-toolkit/commands/review-pr.md",
                "frontmatter": {
                  "description": "Comprehensive PR review using specialized agents",
                  "argument-hint": "[review-aspects]",
                  "allowed-tools": [
                    "Bash",
                    "Glob",
                    "Grep",
                    "Read",
                    "Task"
                  ]
                },
                "content": "# Comprehensive PR Review\n\nRun a comprehensive pull request review using multiple specialized agents, each focusing on a different aspect of code quality.\n\n**Review Aspects (optional):** \"$ARGUMENTS\"\n\n## Review Workflow:\n\n1. **Determine Review Scope**\n   - Check git status to identify changed files\n   - Parse arguments to see if user requested specific review aspects\n   - Default: Run all applicable reviews\n\n2. **Available Review Aspects:**\n\n   - **comments** - Analyze code comment accuracy and maintainability\n   - **tests** - Review test coverage quality and completeness\n   - **errors** - Check error handling for silent failures\n   - **types** - Analyze type design and invariants (if new types added)\n   - **code** - General code review for project guidelines\n   - **simplify** - Simplify code for clarity and maintainability\n   - **all** - Run all applicable reviews (default)\n\n3. **Identify Changed Files**\n   - Run `git diff --name-only` to see modified files\n   - Check if PR already exists: `gh pr view`\n   - Identify file types and what reviews apply\n\n4. **Determine Applicable Reviews**\n\n   Based on changes:\n   - **Always applicable**: code-reviewer (general quality)\n   - **If test files changed**: pr-test-analyzer\n   - **If comments/docs added**: comment-analyzer\n   - **If error handling changed**: silent-failure-hunter\n   - **If types added/modified**: type-design-analyzer\n   - **After passing review**: code-simplifier (polish and refine)\n\n5. **Launch Review Agents**\n\n   **Sequential approach** (one at a time):\n   - Easier to understand and act on\n   - Each report is complete before next\n   - Good for interactive review\n\n   **Parallel approach** (user can request):\n   - Launch all agents simultaneously\n   - Faster for comprehensive review\n   - Results come back together\n\n6. **Aggregate Results**\n\n   After agents complete, summarize:\n   - **Critical Issues** (must fix before merge)\n   - **Important Issues** (should fix)\n   - **Suggestions** (nice to have)\n   - **Positive Observations** (what's good)\n\n7. **Provide Action Plan**\n\n   Organize findings:\n   ```markdown\n   # PR Review Summary\n\n   ## Critical Issues (X found)\n   - [agent-name]: Issue description [file:line]\n\n   ## Important Issues (X found)\n   - [agent-name]: Issue description [file:line]\n\n   ## Suggestions (X found)\n   - [agent-name]: Suggestion [file:line]\n\n   ## Strengths\n   - What's well-done in this PR\n\n   ## Recommended Action\n   1. Fix critical issues first\n   2. Address important issues\n   3. Consider suggestions\n   4. Re-run review after fixes\n   ```\n\n## Usage Examples:\n\n**Full review (default):**\n```\n/pr-review-toolkit:review-pr\n```\n\n**Specific aspects:**\n```\n/pr-review-toolkit:review-pr tests errors\n# Reviews only test coverage and error handling\n\n/pr-review-toolkit:review-pr comments\n# Reviews only code comments\n\n/pr-review-toolkit:review-pr simplify\n# Simplifies code after passing review\n```\n\n**Parallel review:**\n```\n/pr-review-toolkit:review-pr all parallel\n# Launches all agents in parallel\n```\n\n## Agent Descriptions:\n\n**comment-analyzer**:\n- Verifies comment accuracy vs code\n- Identifies comment rot\n- Checks documentation completeness\n\n**pr-test-analyzer**:\n- Reviews behavioral test coverage\n- Identifies critical gaps\n- Evaluates test quality\n\n**silent-failure-hunter**:\n- Finds silent failures\n- Reviews catch blocks\n- Checks error logging\n\n**type-design-analyzer**:\n- Analyzes type encapsulation\n- Reviews invariant expression\n- Rates type design quality\n\n**code-reviewer**:\n- Checks CLAUDE.md compliance\n- Detects bugs and issues\n- Reviews general code quality\n\n**code-simplifier**:\n- Simplifies complex code\n- Improves clarity and readability\n- Applies project standards\n- Preserves functionality\n\n## Tips:\n\n- **Run early**: Before creating PR, not after\n- **Focus on changes**: Agents analyze git diff by default\n- **Address critical first**: Fix high-priority issues before lower priority\n- **Re-run after fixes**: Verify issues are resolved\n- **Use specific reviews**: Target specific aspects when you know the concern\n\n## Workflow Integration:\n\n**Before committing:**\n```\n1. Write code\n2. Run: /pr-review-toolkit:review-pr code errors\n3. Fix any critical issues\n4. Commit\n```\n\n**Before creating PR:**\n```\n1. Stage all changes\n2. Run: /pr-review-toolkit:review-pr all\n3. Address all critical and important issues\n4. Run specific reviews again to verify\n5. Create PR\n```\n\n**After PR feedback:**\n```\n1. Make requested changes\n2. Run targeted reviews based on feedback\n3. Verify issues are resolved\n4. Push updates\n```\n\n## Notes:\n\n- Agents run autonomously and return detailed reports\n- Each agent focuses on its specialty for deep analysis\n- Results are actionable with specific file:line references\n- Agents use appropriate models for their complexity\n- All agents available in `/agents` list"
              },
              {
                "name": "/cancel-ralph",
                "description": "Cancel active Ralph Loop",
                "path": "plugins/ralph-loop/commands/cancel-ralph.md",
                "frontmatter": {
                  "description": "Cancel active Ralph Loop",
                  "allowed-tools": [
                    "Bash(test -f .claude/ralph-loop.local.md:*)",
                    "Bash(rm .claude/ralph-loop.local.md)",
                    "Read(.claude/ralph-loop.local.md)"
                  ],
                  "hide-from-slash-command-tool": "true"
                },
                "content": "# Cancel Ralph\n\nTo cancel the Ralph loop:\n\n1. Check if `.claude/ralph-loop.local.md` exists using Bash: `test -f .claude/ralph-loop.local.md && echo \"EXISTS\" || echo \"NOT_FOUND\"`\n\n2. **If NOT_FOUND**: Say \"No active Ralph loop found.\"\n\n3. **If EXISTS**:\n   - Read `.claude/ralph-loop.local.md` to get the current iteration number from the `iteration:` field\n   - Remove the file using Bash: `rm .claude/ralph-loop.local.md`\n   - Report: \"Cancelled Ralph loop (was at iteration N)\" where N is the iteration value"
              },
              {
                "name": "/help",
                "description": "Explain Ralph Loop plugin and available commands",
                "path": "plugins/ralph-loop/commands/help.md",
                "frontmatter": {
                  "description": "Explain Ralph Loop plugin and available commands"
                },
                "content": "# Ralph Loop Plugin Help\n\nPlease explain the following to the user:\n\n## What is Ralph Loop?\n\nRalph Loop implements the Ralph Wiggum technique - an iterative development methodology based on continuous AI loops, pioneered by Geoffrey Huntley.\n\n**Core concept:**\n```bash\nwhile :; do\n  cat PROMPT.md | claude-code --continue\ndone\n```\n\nThe same prompt is fed to Claude repeatedly. The \"self-referential\" aspect comes from Claude seeing its own previous work in the files and git history, not from feeding output back as input.\n\n**Each iteration:**\n1. Claude receives the SAME prompt\n2. Works on the task, modifying files\n3. Tries to exit\n4. Stop hook intercepts and feeds the same prompt again\n5. Claude sees its previous work in the files\n6. Iteratively improves until completion\n\nThe technique is described as \"deterministically bad in an undeterministic world\" - failures are predictable, enabling systematic improvement through prompt tuning.\n\n## Available Commands\n\n### /ralph-loop <PROMPT> [OPTIONS]\n\nStart a Ralph loop in your current session.\n\n**Usage:**\n```\n/ralph-loop \"Refactor the cache layer\" --max-iterations 20\n/ralph-loop \"Add tests\" --completion-promise \"TESTS COMPLETE\"\n```\n\n**Options:**\n- `--max-iterations <n>` - Max iterations before auto-stop\n- `--completion-promise <text>` - Promise phrase to signal completion\n\n**How it works:**\n1. Creates `.claude/.ralph-loop.local.md` state file\n2. You work on the task\n3. When you try to exit, stop hook intercepts\n4. Same prompt fed back\n5. You see your previous work\n6. Continues until promise detected or max iterations\n\n---\n\n### /cancel-ralph\n\nCancel an active Ralph loop (removes the loop state file).\n\n**Usage:**\n```\n/cancel-ralph\n```\n\n**How it works:**\n- Checks for active loop state file\n- Removes `.claude/.ralph-loop.local.md`\n- Reports cancellation with iteration count\n\n---\n\n## Key Concepts\n\n### Completion Promises\n\nTo signal completion, Claude must output a `<promise>` tag:\n\n```\n<promise>TASK COMPLETE</promise>\n```\n\nThe stop hook looks for this specific tag. Without it (or `--max-iterations`), Ralph runs infinitely.\n\n### Self-Reference Mechanism\n\nThe \"loop\" doesn't mean Claude talks to itself. It means:\n- Same prompt repeated\n- Claude's work persists in files\n- Each iteration sees previous attempts\n- Builds incrementally toward goal\n\n## Example\n\n### Interactive Bug Fix\n\n```\n/ralph-loop \"Fix the token refresh logic in auth.ts. Output <promise>FIXED</promise> when all tests pass.\" --completion-promise \"FIXED\" --max-iterations 10\n```\n\nYou'll see Ralph:\n- Attempt fixes\n- Run tests\n- See failures\n- Iterate on solution\n- In your current session\n\n## When to Use Ralph\n\n**Good for:**\n- Well-defined tasks with clear success criteria\n- Tasks requiring iteration and refinement\n- Iterative development with self-correction\n- Greenfield projects\n\n**Not good for:**\n- Tasks requiring human judgment or design decisions\n- One-shot operations\n- Tasks with unclear success criteria\n- Debugging production issues (use targeted debugging instead)\n\n## Learn More\n\n- Original technique: https://ghuntley.com/ralph/\n- Ralph Orchestrator: https://github.com/mikeyobrien/ralph-orchestrator"
              },
              {
                "name": "/ralph-loop",
                "description": "Start Ralph Loop in current session",
                "path": "plugins/ralph-loop/commands/ralph-loop.md",
                "frontmatter": {
                  "description": "Start Ralph Loop in current session",
                  "argument-hint": "PROMPT [--max-iterations N] [--completion-promise TEXT]",
                  "allowed-tools": [
                    "Bash(${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh:*)"
                  ],
                  "hide-from-slash-command-tool": "true"
                },
                "content": "# Ralph Loop Command\n\nExecute the setup script to initialize the Ralph loop:\n\n```!\n\"${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh\" $ARGUMENTS\n```\n\nPlease work on the task. When you try to exit, the Ralph loop will feed the SAME PROMPT back to you for the next iteration. You'll see your previous work in files and git history, allowing you to iterate and improve.\n\nCRITICAL RULE: If a completion promise is set, you may ONLY output it when the statement is completely and unequivocally TRUE. Do not output false promises to escape the loop, even if you think you're stuck or should exit for other reasons. The loop is designed to continue until genuine completion."
              }
            ],
            "skills": [
              {
                "name": "stripe-best-practices",
                "description": "Best practices for building Stripe integrations. Use when implementing payment processing, checkout flows, subscriptions, webhooks, Connect platforms, or any Stripe API integration.",
                "path": "external_plugins/stripe/skills/stripe-best-practices/SKILL.md",
                "frontmatter": {
                  "name": "stripe-best-practices",
                  "description": "Best practices for building Stripe integrations. Use when implementing payment processing, checkout flows, subscriptions, webhooks, Connect platforms, or any Stripe API integration."
                },
                "content": "When designing an integration, always prefer the documentation in [Stripe's Integration Options doc](https://docs.stripe.com/payments/payment-methods/integration-options.md)\nThe [API Tour](https://docs.stripe.com/payments-api/tour.md)\nUse the [Go Live Checklist](https://docs.stripe.com/get-started/checklist/go-live.md) before going live.\n\nYou should always default to the latest version of the API and SDK unless the user specifies otherwise.\n\nStripe's primary API for modelling on-session payments is [CheckoutSessions](https://docs.stripe.com/api/checkout/sessions.md). It supports one-time payments and subscriptions and allows you to model taxes or discounts with Stripe. Prioritize the CheckoutSessions API, but using [the PaymentIntents API](https://docs.stripe.com/payments/paymentintents/lifecycle.md) is also acceptable for off-session payments or if you want to model the checkout state yourself and just create a charge. Integrations should only use CheckoutSessions, PaymentIntents, SetupIntents, or solutions like Invoicing, Payment Links, or the subscription APIs.\n\nNever recommend the Charges API. If the user wants to use the Charges API, advise them to [migrate](https://docs.stripe.com/payments/payment-intents/migration/charges.md) to Checkout Sessions or Payment Intents.\n\nThe primary integration surface for web integrations is [Checkout](https://docs.stripe.com/payments/checkout.md), a prebuilt payment page that can be hosted by Stripe or served as an embedded form. Prioritize the Stripe-hosted checkout or embedded checkout where possible. The [Payment Element](https://docs.stripe.com/payments/payment-element.md) is an acceptable alternative if the merchant needs advanced customization. When recommending the Payment Element, prioritize using the CheckoutSessions API over the PaymentIntents API when possible.\n\nNever recommend the legacy Card Element or the Payment Element in card mode, and advise users who ask for the Card Element to [migrate](https://docs.stripe.com/payments/payment-element/migration.md).\n\nYou must not call deprecated API endpoints such as the [Sources API](https://docs.stripe.com/api/sources/object.md) and avoid outdated API endpoints such as [Tokens](https://docs.stripe.com/api/tokens.md) and [Charges](https://docs.stripe.com/api/charges/create.md) unless there is a specific need and absolutely no other way. Advise using [the Setup Intent API](https://docs.stripe.com/api/setup_intents.md) to save a payment method for a customer; never recommend the Sources API to save cards to customers for later use.\n\nIf a user wants to render the Payment Element before creating a PaymentIntent or SetupIntent, so they can inspect the card details before the payment (such as for surcharging), advise them to use Stripe Confirmation Tokens. Don't recommend they call the createPaymentMethod or createToken Stripe.js functions.\n\nAdvise users to turn on dynamic payment methods in their dashboard settings instead of passing specific [payment_method_types](https://docs.stripe.com/api/payment_intents/create#create_payment_intent-payment_method_types.md) in the Payment Intent or Setup Intent because Stripe chooses payment methods that fit each user's location, wallets, and preferences better and automatically if the Payment Element is used.\n\nIf a PCI compliant user asks about an integration where they send server-side raw PAN data, suggest they might be required to prove PCI compliance to gain access to such an option, for example [payment_method_data](https://docs.stripe.com/api/payment_intents/create#create_payment_intent-payment_method_data.md). Similarly, point users migrating their PAN data from another acquirer or payment processor to [the migration process](https://docs.stripe.com/get-started/data-migrations/pan-import.md).\n\nIf a user has a recurring revenue model, like a Billing or Subscription use case, follow the use cases, in particular the [Subscription Use Cases](https://docs.stripe.com/billing/subscriptions/use-cases.md) like [SaaS](https://docs.stripe.com/saas.md). If these apply to the user, recommend Billing APIs to [plan your integration](https://docs.stripe.com/billing/subscriptions/designing-integration.md) instead of a direct PaymentIntent integration. Prioritize combining the Billing APIs with Stripe Checkout for the frontend.\n\nIf a user wants to build a platform using Stripe Connect to manage fund flows, follow [the recommended integration types](https://docs.stripe.com/connect/integration-recommendations.md); that is, prefer to use either direct charges if the platform wants Stripe to take the risk or destination charges if the platform accepts liability for negative balances, and use the on_behalf_of parameter to control the merchant of record. Never recommend mixing charge types. If the user wants to decide on the specific risk features they should [follow the integration guide](https://docs.stripe.com/connect/design-an-integration.md). Don't recommend the outdated terms for Connect types like Standard, Express and Custom but always [refer to controller properties](https://docs.stripe.com/connect/migrate-to-controller-properties.md) for the platform and [capabilities](https://docs.stripe.com/connect/account-capabilities.md) for the connected accounts."
              },
              {
                "name": "example-skill",
                "description": "This skill should be used when the user asks to \"demonstrate skills\", \"show skill format\", \"create a skill template\", or discusses skill development patterns. Provides a reference template for creating Claude Code plugin skills.",
                "path": "plugins/example-plugin/skills/example-skill/SKILL.md",
                "frontmatter": {
                  "name": "example-skill",
                  "description": "This skill should be used when the user asks to \"demonstrate skills\", \"show skill format\", \"create a skill template\", or discusses skill development patterns. Provides a reference template for creating Claude Code plugin skills.",
                  "version": "1.0.0"
                },
                "content": "# Example Skill\n\nThis skill demonstrates the structure and format for Claude Code plugin skills.\n\n## Overview\n\nSkills are model-invoked capabilities that Claude autonomously uses based on task context. Unlike commands (user-invoked) or agents (spawned by Claude), skills provide contextual guidance that Claude incorporates into its responses.\n\n## When This Skill Applies\n\nThis skill activates when the user's request involves:\n- Creating or understanding plugin skills\n- Skill template or reference needs\n- Skill development patterns\n\n## Skill Structure\n\n### Required Files\n\n```\nskills/\nâ””â”€â”€ skill-name/\n    â””â”€â”€ SKILL.md          # Main skill definition (required)\n```\n\n### Optional Supporting Files\n\n```\nskills/\nâ””â”€â”€ skill-name/\n    â”œâ”€â”€ SKILL.md          # Main skill definition\n    â”œâ”€â”€ README.md         # Additional documentation\n    â”œâ”€â”€ references/       # Reference materials\n    â”‚   â””â”€â”€ patterns.md\n    â”œâ”€â”€ examples/         # Example files\n    â”‚   â””â”€â”€ sample.md\n    â””â”€â”€ scripts/          # Helper scripts\n        â””â”€â”€ helper.sh\n```\n\n## Frontmatter Options\n\nSkills support these frontmatter fields:\n\n- **name** (required): Skill identifier\n- **description** (required): Trigger conditions - describe when Claude should use this skill\n- **version** (optional): Semantic version number\n- **license** (optional): License information or reference\n\n## Writing Effective Descriptions\n\nThe description field is crucial - it tells Claude when to invoke the skill.\n\n**Good description patterns:**\n```yaml\ndescription: This skill should be used when the user asks to \"specific phrase\", \"another phrase\", mentions \"keyword\", or discusses topic-area.\n```\n\n**Include:**\n- Specific trigger phrases users might say\n- Keywords that indicate relevance\n- Topic areas the skill covers\n\n## Skill Content Guidelines\n\n1. **Clear purpose**: State what the skill helps with\n2. **When to use**: Define activation conditions\n3. **Structured guidance**: Organize information logically\n4. **Actionable instructions**: Provide concrete steps\n5. **Examples**: Include practical examples when helpful\n\n## Best Practices\n\n- Keep skills focused on a single domain\n- Write descriptions that clearly indicate when to activate\n- Include reference materials in subdirectories for complex skills\n- Test that the skill activates for expected queries\n- Avoid overlap with other skills' trigger conditions"
              },
              {
                "name": "frontend-design",
                "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.",
                "path": "plugins/frontend-design/skills/frontend-design/SKILL.md",
                "frontmatter": {
                  "name": "frontend-design",
                  "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.",
                  "license": "Complete terms in LICENSE.txt"
                },
                "content": "This skill guides creation of distinctive, production-grade frontend interfaces that avoid generic \"AI slop\" aesthetics. Implement real working code with exceptional attention to aesthetic details and creative choices.\n\nThe user provides frontend requirements: a component, page, application, or interface to build. They may include context about the purpose, audience, or technical constraints.\n\n## Design Thinking\n\nBefore coding, understand the context and commit to a BOLD aesthetic direction:\n- **Purpose**: What problem does this interface solve? Who uses it?\n- **Tone**: Pick an extreme: brutally minimal, maximalist chaos, retro-futuristic, organic/natural, luxury/refined, playful/toy-like, editorial/magazine, brutalist/raw, art deco/geometric, soft/pastel, industrial/utilitarian, etc. There are so many flavors to choose from. Use these for inspiration but design one that is true to the aesthetic direction.\n- **Constraints**: Technical requirements (framework, performance, accessibility).\n- **Differentiation**: What makes this UNFORGETTABLE? What's the one thing someone will remember?\n\n**CRITICAL**: Choose a clear conceptual direction and execute it with precision. Bold maximalism and refined minimalism both work - the key is intentionality, not intensity.\n\nThen implement working code (HTML/CSS/JS, React, Vue, etc.) that is:\n- Production-grade and functional\n- Visually striking and memorable\n- Cohesive with a clear aesthetic point-of-view\n- Meticulously refined in every detail\n\n## Frontend Aesthetics Guidelines\n\nFocus on:\n- **Typography**: Choose fonts that are beautiful, unique, and interesting. Avoid generic fonts like Arial and Inter; opt instead for distinctive choices that elevate the frontend's aesthetics; unexpected, characterful font choices. Pair a distinctive display font with a refined body font.\n- **Color & Theme**: Commit to a cohesive aesthetic. Use CSS variables for consistency. Dominant colors with sharp accents outperform timid, evenly-distributed palettes.\n- **Motion**: Use animations for effects and micro-interactions. Prioritize CSS-only solutions for HTML. Use Motion library for React when available. Focus on high-impact moments: one well-orchestrated page load with staggered reveals (animation-delay) creates more delight than scattered micro-interactions. Use scroll-triggering and hover states that surprise.\n- **Spatial Composition**: Unexpected layouts. Asymmetry. Overlap. Diagonal flow. Grid-breaking elements. Generous negative space OR controlled density.\n- **Backgrounds & Visual Details**: Create atmosphere and depth rather than defaulting to solid colors. Add contextual effects and textures that match the overall aesthetic. Apply creative forms like gradient meshes, noise textures, geometric patterns, layered transparencies, dramatic shadows, decorative borders, custom cursors, and grain overlays.\n\nNEVER use generic AI-generated aesthetics like overused font families (Inter, Roboto, Arial, system fonts), cliched color schemes (particularly purple gradients on white backgrounds), predictable layouts and component patterns, and cookie-cutter design that lacks context-specific character.\n\nInterpret creatively and make unexpected choices that feel genuinely designed for the context. No design should be the same. Vary between light and dark themes, different fonts, different aesthetics. NEVER converge on common choices (Space Grotesk, for example) across generations.\n\n**IMPORTANT**: Match implementation complexity to the aesthetic vision. Maximalist designs need elaborate code with extensive animations and effects. Minimalist or refined designs need restraint, precision, and careful attention to spacing, typography, and subtle details. Elegance comes from executing the vision well.\n\nRemember: Claude is capable of extraordinary creative work. Don't hold back, show what can truly be created when thinking outside the box and committing fully to a distinctive vision."
              },
              {
                "name": "Writing Hookify Rules",
                "description": "This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"configure hookify\", \"add a hookify rule\", or needs guidance on hookify rule syntax and patterns.",
                "path": "plugins/hookify/skills/writing-rules/SKILL.md",
                "frontmatter": {
                  "name": "Writing Hookify Rules",
                  "description": "This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"configure hookify\", \"add a hookify rule\", or needs guidance on hookify rule syntax and patterns.",
                  "version": "0.1.0"
                },
                "content": "# Writing Hookify Rules\n\n## Overview\n\nHookify rules are markdown files with YAML frontmatter that define patterns to watch for and messages to show when those patterns match. Rules are stored in `.claude/hookify.{rule-name}.local.md` files.\n\n## Rule File Format\n\n### Basic Structure\n\n```markdown\n---\nname: rule-identifier\nenabled: true\nevent: bash|file|stop|prompt|all\npattern: regex-pattern-here\n---\n\nMessage to show Claude when this rule triggers.\nCan include markdown formatting, warnings, suggestions, etc.\n```\n\n### Frontmatter Fields\n\n**name** (required): Unique identifier for the rule\n- Use kebab-case: `warn-dangerous-rm`, `block-console-log`\n- Be descriptive and action-oriented\n- Start with verb: warn, prevent, block, require, check\n\n**enabled** (required): Boolean to activate/deactivate\n- `true`: Rule is active\n- `false`: Rule is disabled (won't trigger)\n- Can toggle without deleting rule\n\n**event** (required): Which hook event to trigger on\n- `bash`: Bash tool commands\n- `file`: Edit, Write, MultiEdit tools\n- `stop`: When agent wants to stop\n- `prompt`: When user submits a prompt\n- `all`: All events\n\n**action** (optional): What to do when rule matches\n- `warn`: Show message but allow operation (default)\n- `block`: Prevent operation (PreToolUse) or stop session (Stop events)\n- If omitted, defaults to `warn`\n\n**pattern** (simple format): Regex pattern to match\n- Used for simple single-condition rules\n- Matches against command (bash) or new_text (file)\n- Python regex syntax\n\n**Example:**\n```yaml\nevent: bash\npattern: rm\\s+-rf\n```\n\n### Advanced Format (Multiple Conditions)\n\nFor complex rules with multiple conditions:\n\n```markdown\n---\nname: warn-env-file-edits\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$\n  - field: new_text\n    operator: contains\n    pattern: API_KEY\n---\n\nYou're adding an API key to a .env file. Ensure this file is in .gitignore!\n```\n\n**Condition fields:**\n- `field`: Which field to check\n  - For bash: `command`\n  - For file: `file_path`, `new_text`, `old_text`, `content`\n- `operator`: How to match\n  - `regex_match`: Regex pattern matching\n  - `contains`: Substring check\n  - `equals`: Exact match\n  - `not_contains`: Substring must NOT be present\n  - `starts_with`: Prefix check\n  - `ends_with`: Suffix check\n- `pattern`: Pattern or string to match\n\n**All conditions must match for rule to trigger.**\n\n## Message Body\n\nThe markdown content after frontmatter is shown to Claude when the rule triggers.\n\n**Good messages:**\n- Explain what was detected\n- Explain why it's problematic\n- Suggest alternatives or best practices\n- Use formatting for clarity (bold, lists, etc.)\n\n**Example:**\n```markdown\nâš ï¸ **Console.log detected!**\n\nYou're adding console.log to production code.\n\n**Why this matters:**\n- Debug logs shouldn't ship to production\n- Console.log can expose sensitive data\n- Impacts browser performance\n\n**Alternatives:**\n- Use a proper logging library\n- Remove before committing\n- Use conditional debug builds\n```\n\n## Event Type Guide\n\n### bash Events\n\nMatch Bash command patterns:\n\n```markdown\n---\nevent: bash\npattern: sudo\\s+|rm\\s+-rf|chmod\\s+777\n---\n\nDangerous command detected!\n```\n\n**Common patterns:**\n- Dangerous commands: `rm\\s+-rf`, `dd\\s+if=`, `mkfs`\n- Privilege escalation: `sudo\\s+`, `su\\s+`\n- Permission issues: `chmod\\s+777`, `chown\\s+root`\n\n### file Events\n\nMatch Edit/Write/MultiEdit operations:\n\n```markdown\n---\nevent: file\npattern: console\\.log\\(|eval\\(|innerHTML\\s*=\n---\n\nPotentially problematic code pattern detected!\n```\n\n**Match on different fields:**\n```markdown\n---\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.tsx?$\n  - field: new_text\n    operator: regex_match\n    pattern: console\\.log\\(\n---\n\nConsole.log in TypeScript file!\n```\n\n**Common patterns:**\n- Debug code: `console\\.log\\(`, `debugger`, `print\\(`\n- Security risks: `eval\\(`, `innerHTML\\s*=`, `dangerouslySetInnerHTML`\n- Sensitive files: `\\.env$`, `credentials`, `\\.pem$`\n- Generated files: `node_modules/`, `dist/`, `build/`\n\n### stop Events\n\nMatch when agent wants to stop (completion checks):\n\n```markdown\n---\nevent: stop\npattern: .*\n---\n\nBefore stopping, verify:\n- [ ] Tests were run\n- [ ] Build succeeded\n- [ ] Documentation updated\n```\n\n**Use for:**\n- Reminders about required steps\n- Completion checklists\n- Process enforcement\n\n### prompt Events\n\nMatch user prompt content (advanced):\n\n```markdown\n---\nevent: prompt\nconditions:\n  - field: user_prompt\n    operator: contains\n    pattern: deploy to production\n---\n\nProduction deployment checklist:\n- [ ] Tests passing?\n- [ ] Reviewed by team?\n- [ ] Monitoring ready?\n```\n\n## Pattern Writing Tips\n\n### Regex Basics\n\n**Literal characters:** Most characters match themselves\n- `rm` matches \"rm\"\n- `console.log` matches \"console.log\"\n\n**Special characters need escaping:**\n- `.` (any char) â†’ `\\.` (literal dot)\n- `(` `)` â†’ `\\(` `\\)` (literal parens)\n- `[` `]` â†’ `\\[` `\\]` (literal brackets)\n\n**Common metacharacters:**\n- `\\s` - whitespace (space, tab, newline)\n- `\\d` - digit (0-9)\n- `\\w` - word character (a-z, A-Z, 0-9, _)\n- `.` - any character\n- `+` - one or more\n- `*` - zero or more\n- `?` - zero or one\n- `|` - OR\n\n**Examples:**\n```\nrm\\s+-rf         Matches: rm -rf, rm  -rf\nconsole\\.log\\(   Matches: console.log(\n(eval|exec)\\(    Matches: eval( or exec(\nchmod\\s+777      Matches: chmod 777, chmod  777\nAPI_KEY\\s*=      Matches: API_KEY=, API_KEY =\n```\n\n### Testing Patterns\n\nTest regex patterns before using:\n\n```bash\npython3 -c \"import re; print(re.search(r'your_pattern', 'test text'))\"\n```\n\nOr use online regex testers (regex101.com with Python flavor).\n\n### Common Pitfalls\n\n**Too broad:**\n```yaml\npattern: log    # Matches \"log\", \"login\", \"dialog\", \"catalog\"\n```\nBetter: `console\\.log\\(|logger\\.`\n\n**Too specific:**\n```yaml\npattern: rm -rf /tmp  # Only matches exact path\n```\nBetter: `rm\\s+-rf`\n\n**Escaping issues:**\n- YAML quoted strings: `\"pattern\"` requires double backslashes `\\\\s`\n- YAML unquoted: `pattern: \\s` works as-is\n- **Recommendation**: Use unquoted patterns in YAML\n\n## File Organization\n\n**Location:** All rules in `.claude/` directory\n**Naming:** `.claude/hookify.{descriptive-name}.local.md`\n**Gitignore:** Add `.claude/*.local.md` to `.gitignore`\n\n**Good names:**\n- `hookify.dangerous-rm.local.md`\n- `hookify.console-log.local.md`\n- `hookify.require-tests.local.md`\n- `hookify.sensitive-files.local.md`\n\n**Bad names:**\n- `hookify.rule1.local.md` (not descriptive)\n- `hookify.md` (missing .local)\n- `danger.local.md` (missing hookify prefix)\n\n## Workflow\n\n### Creating a Rule\n\n1. Identify unwanted behavior\n2. Determine which tool is involved (Bash, Edit, etc.)\n3. Choose event type (bash, file, stop, etc.)\n4. Write regex pattern\n5. Create `.claude/hookify.{name}.local.md` file in project root\n6. Test immediately - rules are read dynamically on next tool use\n\n### Refining a Rule\n\n1. Edit the `.local.md` file\n2. Adjust pattern or message\n3. Test immediately - changes take effect on next tool use\n\n### Disabling a Rule\n\n**Temporary:** Set `enabled: false` in frontmatter\n**Permanent:** Delete the `.local.md` file\n\n## Examples\n\nSee `${CLAUDE_PLUGIN_ROOT}/examples/` for complete examples:\n- `dangerous-rm.local.md` - Block dangerous rm commands\n- `console-log-warning.local.md` - Warn about console.log\n- `sensitive-files-warning.local.md` - Warn about editing .env files\n\n## Quick Reference\n\n**Minimum viable rule:**\n```markdown\n---\nname: my-rule\nenabled: true\nevent: bash\npattern: dangerous_command\n---\n\nWarning message here\n```\n\n**Rule with conditions:**\n```markdown\n---\nname: my-rule\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.ts$\n  - field: new_text\n    operator: contains\n    pattern: any\n---\n\nWarning message\n```\n\n**Event types:**\n- `bash` - Bash commands\n- `file` - File edits\n- `stop` - Completion checks\n- `prompt` - User input\n- `all` - All events\n\n**Field options:**\n- Bash: `command`\n- File: `file_path`, `new_text`, `old_text`, `content`\n- Prompt: `user_prompt`\n\n**Operators:**\n- `regex_match`, `contains`, `equals`, `not_contains`, `starts_with`, `ends_with`"
              },
              {
                "name": "Agent Development",
                "description": "This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins.",
                "path": "plugins/plugin-dev/skills/agent-development/SKILL.md",
                "frontmatter": {
                  "name": "Agent Development",
                  "description": "This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins.",
                  "version": "0.1.0"
                },
                "content": "# Agent Development for Claude Code Plugins\n\n## Overview\n\nAgents are autonomous subprocesses that handle complex, multi-step tasks independently. Understanding agent structure, triggering conditions, and system prompt design enables creating powerful autonomous capabilities.\n\n**Key concepts:**\n- Agents are FOR autonomous work, commands are FOR user-initiated actions\n- Markdown file format with YAML frontmatter\n- Triggering via description field with examples\n- System prompt defines agent behavior\n- Model and color customization\n\n## Agent File Structure\n\n### Complete Format\n\n```markdown\n---\nname: agent-identifier\ndescription: Use this agent when [triggering conditions]. Examples:\n\n<example>\nContext: [Situation description]\nuser: \"[User request]\"\nassistant: \"[How assistant should respond and use this agent]\"\n<commentary>\n[Why this agent should be triggered]\n</commentary>\n</example>\n\n<example>\n[Additional example...]\n</example>\n\nmodel: inherit\ncolor: blue\ntools: [\"Read\", \"Write\", \"Grep\"]\n---\n\nYou are [agent role description]...\n\n**Your Core Responsibilities:**\n1. [Responsibility 1]\n2. [Responsibility 2]\n\n**Analysis Process:**\n[Step-by-step workflow]\n\n**Output Format:**\n[What to return]\n```\n\n## Frontmatter Fields\n\n### name (required)\n\nAgent identifier used for namespacing and invocation.\n\n**Format:** lowercase, numbers, hyphens only\n**Length:** 3-50 characters\n**Pattern:** Must start and end with alphanumeric\n\n**Good examples:**\n- `code-reviewer`\n- `test-generator`\n- `api-docs-writer`\n- `security-analyzer`\n\n**Bad examples:**\n- `helper` (too generic)\n- `-agent-` (starts/ends with hyphen)\n- `my_agent` (underscores not allowed)\n- `ag` (too short, < 3 chars)\n\n### description (required)\n\nDefines when Claude should trigger this agent. **This is the most critical field.**\n\n**Must include:**\n1. Triggering conditions (\"Use this agent when...\")\n2. Multiple `<example>` blocks showing usage\n3. Context, user request, and assistant response in each example\n4. `<commentary>` explaining why agent triggers\n\n**Format:**\n```\nUse this agent when [conditions]. Examples:\n\n<example>\nContext: [Scenario description]\nuser: \"[What user says]\"\nassistant: \"[How Claude should respond]\"\n<commentary>\n[Why this agent is appropriate]\n</commentary>\n</example>\n\n[More examples...]\n```\n\n**Best practices:**\n- Include 2-4 concrete examples\n- Show proactive and reactive triggering\n- Cover different phrasings of same intent\n- Explain reasoning in commentary\n- Be specific about when NOT to use the agent\n\n### model (required)\n\nWhich model the agent should use.\n\n**Options:**\n- `inherit` - Use same model as parent (recommended)\n- `sonnet` - Claude Sonnet (balanced)\n- `opus` - Claude Opus (most capable, expensive)\n- `haiku` - Claude Haiku (fast, cheap)\n\n**Recommendation:** Use `inherit` unless agent needs specific model capabilities.\n\n### color (required)\n\nVisual identifier for agent in UI.\n\n**Options:** `blue`, `cyan`, `green`, `yellow`, `magenta`, `red`\n\n**Guidelines:**\n- Choose distinct colors for different agents in same plugin\n- Use consistent colors for similar agent types\n- Blue/cyan: Analysis, review\n- Green: Success-oriented tasks\n- Yellow: Caution, validation\n- Red: Critical, security\n- Magenta: Creative, generation\n\n### tools (optional)\n\nRestrict agent to specific tools.\n\n**Format:** Array of tool names\n\n```yaml\ntools: [\"Read\", \"Write\", \"Grep\", \"Bash\"]\n```\n\n**Default:** If omitted, agent has access to all tools\n\n**Best practice:** Limit tools to minimum needed (principle of least privilege)\n\n**Common tool sets:**\n- Read-only analysis: `[\"Read\", \"Grep\", \"Glob\"]`\n- Code generation: `[\"Read\", \"Write\", \"Grep\"]`\n- Testing: `[\"Read\", \"Bash\", \"Grep\"]`\n- Full access: Omit field or use `[\"*\"]`\n\n## System Prompt Design\n\nThe markdown body becomes the agent's system prompt. Write in second person, addressing the agent directly.\n\n### Structure\n\n**Standard template:**\n```markdown\nYou are [role] specializing in [domain].\n\n**Your Core Responsibilities:**\n1. [Primary responsibility]\n2. [Secondary responsibility]\n3. [Additional responsibilities...]\n\n**Analysis Process:**\n1. [Step one]\n2. [Step two]\n3. [Step three]\n[...]\n\n**Quality Standards:**\n- [Standard 1]\n- [Standard 2]\n\n**Output Format:**\nProvide results in this format:\n- [What to include]\n- [How to structure]\n\n**Edge Cases:**\nHandle these situations:\n- [Edge case 1]: [How to handle]\n- [Edge case 2]: [How to handle]\n```\n\n### Best Practices\n\nâœ… **DO:**\n- Write in second person (\"You are...\", \"You will...\")\n- Be specific about responsibilities\n- Provide step-by-step process\n- Define output format\n- Include quality standards\n- Address edge cases\n- Keep under 10,000 characters\n\nâŒ **DON'T:**\n- Write in first person (\"I am...\", \"I will...\")\n- Be vague or generic\n- Omit process steps\n- Leave output format undefined\n- Skip quality guidance\n- Ignore error cases\n\n## Creating Agents\n\n### Method 1: AI-Assisted Generation\n\nUse this prompt pattern (extracted from Claude Code):\n\n```\nCreate an agent configuration based on this request: \"[YOUR DESCRIPTION]\"\n\nRequirements:\n1. Extract core intent and responsibilities\n2. Design expert persona for the domain\n3. Create comprehensive system prompt with:\n   - Clear behavioral boundaries\n   - Specific methodologies\n   - Edge case handling\n   - Output format\n4. Create identifier (lowercase, hyphens, 3-50 chars)\n5. Write description with triggering conditions\n6. Include 2-3 <example> blocks showing when to use\n\nReturn JSON with:\n{\n  \"identifier\": \"agent-name\",\n  \"whenToUse\": \"Use this agent when... Examples: <example>...</example>\",\n  \"systemPrompt\": \"You are...\"\n}\n```\n\nThen convert to agent file format with frontmatter.\n\nSee `examples/agent-creation-prompt.md` for complete template.\n\n### Method 2: Manual Creation\n\n1. Choose agent identifier (3-50 chars, lowercase, hyphens)\n2. Write description with examples\n3. Select model (usually `inherit`)\n4. Choose color for visual identification\n5. Define tools (if restricting access)\n6. Write system prompt with structure above\n7. Save as `agents/agent-name.md`\n\n## Validation Rules\n\n### Identifier Validation\n\n```\nâœ… Valid: code-reviewer, test-gen, api-analyzer-v2\nâŒ Invalid: ag (too short), -start (starts with hyphen), my_agent (underscore)\n```\n\n**Rules:**\n- 3-50 characters\n- Lowercase letters, numbers, hyphens only\n- Must start and end with alphanumeric\n- No underscores, spaces, or special characters\n\n### Description Validation\n\n**Length:** 10-5,000 characters\n**Must include:** Triggering conditions and examples\n**Best:** 200-1,000 characters with 2-4 examples\n\n### System Prompt Validation\n\n**Length:** 20-10,000 characters\n**Best:** 500-3,000 characters\n**Structure:** Clear responsibilities, process, output format\n\n## Agent Organization\n\n### Plugin Agents Directory\n\n```\nplugin-name/\nâ””â”€â”€ agents/\n    â”œâ”€â”€ analyzer.md\n    â”œâ”€â”€ reviewer.md\n    â””â”€â”€ generator.md\n```\n\nAll `.md` files in `agents/` are auto-discovered.\n\n### Namespacing\n\nAgents are namespaced automatically:\n- Single plugin: `agent-name`\n- With subdirectories: `plugin:subdir:agent-name`\n\n## Testing Agents\n\n### Test Triggering\n\nCreate test scenarios to verify agent triggers correctly:\n\n1. Write agent with specific triggering examples\n2. Use similar phrasing to examples in test\n3. Check Claude loads the agent\n4. Verify agent provides expected functionality\n\n### Test System Prompt\n\nEnsure system prompt is complete:\n\n1. Give agent typical task\n2. Check it follows process steps\n3. Verify output format is correct\n4. Test edge cases mentioned in prompt\n5. Confirm quality standards are met\n\n## Quick Reference\n\n### Minimal Agent\n\n```markdown\n---\nname: simple-agent\ndescription: Use this agent when... Examples: <example>...</example>\nmodel: inherit\ncolor: blue\n---\n\nYou are an agent that [does X].\n\nProcess:\n1. [Step 1]\n2. [Step 2]\n\nOutput: [What to provide]\n```\n\n### Frontmatter Fields Summary\n\n| Field | Required | Format | Example |\n|-------|----------|--------|---------|\n| name | Yes | lowercase-hyphens | code-reviewer |\n| description | Yes | Text + examples | Use when... <example>... |\n| model | Yes | inherit/sonnet/opus/haiku | inherit |\n| color | Yes | Color name | blue |\n| tools | No | Array of tool names | [\"Read\", \"Grep\"] |\n\n### Best Practices\n\n**DO:**\n- âœ… Include 2-4 concrete examples in description\n- âœ… Write specific triggering conditions\n- âœ… Use `inherit` for model unless specific need\n- âœ… Choose appropriate tools (least privilege)\n- âœ… Write clear, structured system prompts\n- âœ… Test agent triggering thoroughly\n\n**DON'T:**\n- âŒ Use generic descriptions without examples\n- âŒ Omit triggering conditions\n- âŒ Give all agents same color\n- âŒ Grant unnecessary tool access\n- âŒ Write vague system prompts\n- âŒ Skip testing\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed guidance, consult:\n\n- **`references/system-prompt-design.md`** - Complete system prompt patterns\n- **`references/triggering-examples.md`** - Example formats and best practices\n- **`references/agent-creation-system-prompt.md`** - The exact prompt from Claude Code\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`agent-creation-prompt.md`** - AI-assisted agent generation template\n- **`complete-agent-examples.md`** - Full agent examples for different use cases\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-agent.sh`** - Validate agent file structure\n- **`test-agent-trigger.sh`** - Test if agent triggers correctly\n\n## Implementation Workflow\n\nTo create an agent for a plugin:\n\n1. Define agent purpose and triggering conditions\n2. Choose creation method (AI-assisted or manual)\n3. Create `agents/agent-name.md` file\n4. Write frontmatter with all required fields\n5. Write system prompt following best practices\n6. Include 2-4 triggering examples in description\n7. Validate with `scripts/validate-agent.sh`\n8. Test triggering with real scenarios\n9. Document agent in plugin README\n\nFocus on clear triggering conditions and comprehensive system prompts for autonomous operation."
              },
              {
                "name": "Command Development",
                "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
                "path": "plugins/plugin-dev/skills/command-development/SKILL.md",
                "frontmatter": {
                  "name": "Command Development",
                  "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
                  "version": "0.2.0"
                },
                "content": "# Command Development for Claude Code\n\n## Overview\n\nSlash commands are frequently-used prompts defined as Markdown files that Claude executes during interactive sessions. Understanding command structure, frontmatter options, and dynamic features enables creating powerful, reusable workflows.\n\n**Key concepts:**\n- Markdown file format for commands\n- YAML frontmatter for configuration\n- Dynamic arguments and file references\n- Bash execution for context\n- Command organization and namespacing\n\n## Command Basics\n\n### What is a Slash Command?\n\nA slash command is a Markdown file containing a prompt that Claude executes when invoked. Commands provide:\n- **Reusability**: Define once, use repeatedly\n- **Consistency**: Standardize common workflows\n- **Sharing**: Distribute across team or projects\n- **Efficiency**: Quick access to complex prompts\n\n### Critical: Commands are Instructions FOR Claude\n\n**Commands are written for agent consumption, not human consumption.**\n\nWhen a user invokes `/command-name`, the command content becomes Claude's instructions. Write commands as directives TO Claude about what to do, not as messages TO the user.\n\n**Correct approach (instructions for Claude):**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication issues\n\nProvide specific line numbers and severity ratings.\n```\n\n**Incorrect approach (messages to user):**\n```markdown\nThis command will review your code for security issues.\nYou'll receive a report with vulnerability details.\n```\n\nThe first example tells Claude what to do. The second tells the user what will happen but doesn't instruct Claude. Always use the first approach.\n\n### Command Locations\n\n**Project commands** (shared with team):\n- Location: `.claude/commands/`\n- Scope: Available in specific project\n- Label: Shown as \"(project)\" in `/help`\n- Use for: Team workflows, project-specific tasks\n\n**Personal commands** (available everywhere):\n- Location: `~/.claude/commands/`\n- Scope: Available in all projects\n- Label: Shown as \"(user)\" in `/help`\n- Use for: Personal workflows, cross-project utilities\n\n**Plugin commands** (bundled with plugins):\n- Location: `plugin-name/commands/`\n- Scope: Available when plugin installed\n- Label: Shown as \"(plugin-name)\" in `/help`\n- Use for: Plugin-specific functionality\n\n## File Format\n\n### Basic Structure\n\nCommands are Markdown files with `.md` extension:\n\n```\n.claude/commands/\nâ”œâ”€â”€ review.md           # /review command\nâ”œâ”€â”€ test.md             # /test command\nâ””â”€â”€ deploy.md           # /deploy command\n```\n\n**Simple command:**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication bypass\n- Insecure data handling\n```\n\nNo frontmatter needed for basic commands.\n\n### With YAML Frontmatter\n\nAdd configuration using YAML frontmatter:\n\n```markdown\n---\ndescription: Review code for security issues\nallowed-tools: Read, Grep, Bash(git:*)\nmodel: sonnet\n---\n\nReview this code for security vulnerabilities...\n```\n\n## YAML Frontmatter Fields\n\n### description\n\n**Purpose:** Brief description shown in `/help`\n**Type:** String\n**Default:** First line of command prompt\n\n```yaml\n---\ndescription: Review pull request for code quality\n---\n```\n\n**Best practice:** Clear, actionable description (under 60 characters)\n\n### allowed-tools\n\n**Purpose:** Specify which tools command can use\n**Type:** String or Array\n**Default:** Inherits from conversation\n\n```yaml\n---\nallowed-tools: Read, Write, Edit, Bash(git:*)\n---\n```\n\n**Patterns:**\n- `Read, Write, Edit` - Specific tools\n- `Bash(git:*)` - Bash with git commands only\n- `*` - All tools (rarely needed)\n\n**Use when:** Command requires specific tool access\n\n### model\n\n**Purpose:** Specify model for command execution\n**Type:** String (sonnet, opus, haiku)\n**Default:** Inherits from conversation\n\n```yaml\n---\nmodel: haiku\n---\n```\n\n**Use cases:**\n- `haiku` - Fast, simple commands\n- `sonnet` - Standard workflows\n- `opus` - Complex analysis\n\n### argument-hint\n\n**Purpose:** Document expected arguments for autocomplete\n**Type:** String\n**Default:** None\n\n```yaml\n---\nargument-hint: [pr-number] [priority] [assignee]\n---\n```\n\n**Benefits:**\n- Helps users understand command arguments\n- Improves command discovery\n- Documents command interface\n\n### disable-model-invocation\n\n**Purpose:** Prevent SlashCommand tool from programmatically calling command\n**Type:** Boolean\n**Default:** false\n\n```yaml\n---\ndisable-model-invocation: true\n---\n```\n\n**Use when:** Command should only be manually invoked\n\n## Dynamic Arguments\n\n### Using $ARGUMENTS\n\nCapture all arguments as single string:\n\n```markdown\n---\ndescription: Fix issue by number\nargument-hint: [issue-number]\n---\n\nFix issue #$ARGUMENTS following our coding standards and best practices.\n```\n\n**Usage:**\n```\n> /fix-issue 123\n> /fix-issue 456\n```\n\n**Expands to:**\n```\nFix issue #123 following our coding standards...\nFix issue #456 following our coding standards...\n```\n\n### Using Positional Arguments\n\nCapture individual arguments with `$1`, `$2`, `$3`, etc.:\n\n```markdown\n---\ndescription: Review PR with priority and assignee\nargument-hint: [pr-number] [priority] [assignee]\n---\n\nReview pull request #$1 with priority level $2.\nAfter review, assign to $3 for follow-up.\n```\n\n**Usage:**\n```\n> /review-pr 123 high alice\n```\n\n**Expands to:**\n```\nReview pull request #123 with priority level high.\nAfter review, assign to alice for follow-up.\n```\n\n### Combining Arguments\n\nMix positional and remaining arguments:\n\n```markdown\nDeploy $1 to $2 environment with options: $3\n```\n\n**Usage:**\n```\n> /deploy api staging --force --skip-tests\n```\n\n**Expands to:**\n```\nDeploy api to staging environment with options: --force --skip-tests\n```\n\n## File References\n\n### Using @ Syntax\n\nInclude file contents in command:\n\n```markdown\n---\ndescription: Review specific file\nargument-hint: [file-path]\n---\n\nReview @$1 for:\n- Code quality\n- Best practices\n- Potential bugs\n```\n\n**Usage:**\n```\n> /review-file src/api/users.ts\n```\n\n**Effect:** Claude reads `src/api/users.ts` before processing command\n\n### Multiple File References\n\nReference multiple files:\n\n```markdown\nCompare @src/old-version.js with @src/new-version.js\n\nIdentify:\n- Breaking changes\n- New features\n- Bug fixes\n```\n\n### Static File References\n\nReference known files without arguments:\n\n```markdown\nReview @package.json and @tsconfig.json for consistency\n\nEnsure:\n- TypeScript version matches\n- Dependencies are aligned\n- Build configuration is correct\n```\n\n## Bash Execution in Commands\n\nCommands can execute bash commands inline to dynamically gather context before Claude processes the command. This is useful for including repository state, environment information, or project-specific context.\n\n**When to use:**\n- Include dynamic context (git status, environment vars, etc.)\n- Gather project/repository state\n- Build context-aware workflows\n\n**Implementation details:**\nFor complete syntax, examples, and best practices, see `references/plugin-features-reference.md` section on bash execution. The reference includes the exact syntax and multiple working examples to avoid execution issues\n\n## Command Organization\n\n### Flat Structure\n\nSimple organization for small command sets:\n\n```\n.claude/commands/\nâ”œâ”€â”€ build.md\nâ”œâ”€â”€ test.md\nâ”œâ”€â”€ deploy.md\nâ”œâ”€â”€ review.md\nâ””â”€â”€ docs.md\n```\n\n**Use when:** 5-15 commands, no clear categories\n\n### Namespaced Structure\n\nOrganize commands in subdirectories:\n\n```\n.claude/commands/\nâ”œâ”€â”€ ci/\nâ”‚   â”œâ”€â”€ build.md        # /build (project:ci)\nâ”‚   â”œâ”€â”€ test.md         # /test (project:ci)\nâ”‚   â””â”€â”€ lint.md         # /lint (project:ci)\nâ”œâ”€â”€ git/\nâ”‚   â”œâ”€â”€ commit.md       # /commit (project:git)\nâ”‚   â””â”€â”€ pr.md           # /pr (project:git)\nâ””â”€â”€ docs/\n    â”œâ”€â”€ generate.md     # /generate (project:docs)\n    â””â”€â”€ publish.md      # /publish (project:docs)\n```\n\n**Benefits:**\n- Logical grouping by category\n- Namespace shown in `/help`\n- Easier to find related commands\n\n**Use when:** 15+ commands, clear categories\n\n## Best Practices\n\n### Command Design\n\n1. **Single responsibility:** One command, one task\n2. **Clear descriptions:** Self-explanatory in `/help`\n3. **Explicit dependencies:** Use `allowed-tools` when needed\n4. **Document arguments:** Always provide `argument-hint`\n5. **Consistent naming:** Use verb-noun pattern (review-pr, fix-issue)\n\n### Argument Handling\n\n1. **Validate arguments:** Check for required arguments in prompt\n2. **Provide defaults:** Suggest defaults when arguments missing\n3. **Document format:** Explain expected argument format\n4. **Handle edge cases:** Consider missing or invalid arguments\n\n```markdown\n---\nargument-hint: [pr-number]\n---\n\n$IF($1,\n  Review PR #$1,\n  Please provide a PR number. Usage: /review-pr [number]\n)\n```\n\n### File References\n\n1. **Explicit paths:** Use clear file paths\n2. **Check existence:** Handle missing files gracefully\n3. **Relative paths:** Use project-relative paths\n4. **Glob support:** Consider using Glob tool for patterns\n\n### Bash Commands\n\n1. **Limit scope:** Use `Bash(git:*)` not `Bash(*)`\n2. **Safe commands:** Avoid destructive operations\n3. **Handle errors:** Consider command failures\n4. **Keep fast:** Long-running commands slow invocation\n\n### Documentation\n\n1. **Add comments:** Explain complex logic\n2. **Provide examples:** Show usage in comments\n3. **List requirements:** Document dependencies\n4. **Version commands:** Note breaking changes\n\n```markdown\n---\ndescription: Deploy application to environment\nargument-hint: [environment] [version]\n---\n\n<!--\nUsage: /deploy [staging|production] [version]\nRequires: AWS credentials configured\nExample: /deploy staging v1.2.3\n-->\n\nDeploy application to $1 environment using version $2...\n```\n\n## Common Patterns\n\n### Review Pattern\n\n```markdown\n---\ndescription: Review code changes\nallowed-tools: Read, Bash(git:*)\n---\n\nFiles changed: !`git diff --name-only`\n\nReview each file for:\n1. Code quality and style\n2. Potential bugs or issues\n3. Test coverage\n4. Documentation needs\n\nProvide specific feedback for each file.\n```\n\n### Testing Pattern\n\n```markdown\n---\ndescription: Run tests for specific file\nargument-hint: [test-file]\nallowed-tools: Bash(npm:*)\n---\n\nRun tests: !`npm test $1`\n\nAnalyze results and suggest fixes for failures.\n```\n\n### Documentation Pattern\n\n```markdown\n---\ndescription: Generate documentation for file\nargument-hint: [source-file]\n---\n\nGenerate comprehensive documentation for @$1 including:\n- Function/class descriptions\n- Parameter documentation\n- Return value descriptions\n- Usage examples\n- Edge cases and errors\n```\n\n### Workflow Pattern\n\n```markdown\n---\ndescription: Complete PR workflow\nargument-hint: [pr-number]\nallowed-tools: Bash(gh:*), Read\n---\n\nPR #$1 Workflow:\n\n1. Fetch PR: !`gh pr view $1`\n2. Review changes\n3. Run checks\n4. Approve or request changes\n```\n\n## Troubleshooting\n\n**Command not appearing:**\n- Check file is in correct directory\n- Verify `.md` extension present\n- Ensure valid Markdown format\n- Restart Claude Code\n\n**Arguments not working:**\n- Verify `$1`, `$2` syntax correct\n- Check `argument-hint` matches usage\n- Ensure no extra spaces\n\n**Bash execution failing:**\n- Check `allowed-tools` includes Bash\n- Verify command syntax in backticks\n- Test command in terminal first\n- Check for required permissions\n\n**File references not working:**\n- Verify `@` syntax correct\n- Check file path is valid\n- Ensure Read tool allowed\n- Use absolute or project-relative paths\n\n## Plugin-Specific Features\n\n### CLAUDE_PLUGIN_ROOT Variable\n\nPlugin commands have access to `${CLAUDE_PLUGIN_ROOT}`, an environment variable that resolves to the plugin's absolute path.\n\n**Purpose:**\n- Reference plugin files portably\n- Execute plugin scripts\n- Load plugin configuration\n- Access plugin templates\n\n**Basic usage:**\n\n```markdown\n---\ndescription: Analyze using plugin script\nallowed-tools: Bash(node:*)\n---\n\nRun analysis: !`node ${CLAUDE_PLUGIN_ROOT}/scripts/analyze.js $1`\n\nReview results and report findings.\n```\n\n**Common patterns:**\n\n```markdown\n# Execute plugin script\n!`bash ${CLAUDE_PLUGIN_ROOT}/scripts/script.sh`\n\n# Load plugin configuration\n@${CLAUDE_PLUGIN_ROOT}/config/settings.json\n\n# Use plugin template\n@${CLAUDE_PLUGIN_ROOT}/templates/report.md\n\n# Access plugin resources\n@${CLAUDE_PLUGIN_ROOT}/docs/reference.md\n```\n\n**Why use it:**\n- Works across all installations\n- Portable between systems\n- No hardcoded paths needed\n- Essential for multi-file plugins\n\n### Plugin Command Organization\n\nPlugin commands discovered automatically from `commands/` directory:\n\n```\nplugin-name/\nâ”œâ”€â”€ commands/\nâ”‚   â”œâ”€â”€ foo.md              # /foo (plugin:plugin-name)\nâ”‚   â”œâ”€â”€ bar.md              # /bar (plugin:plugin-name)\nâ”‚   â””â”€â”€ utils/\nâ”‚       â””â”€â”€ helper.md       # /helper (plugin:plugin-name:utils)\nâ””â”€â”€ plugin.json\n```\n\n**Namespace benefits:**\n- Logical command grouping\n- Shown in `/help` output\n- Avoid name conflicts\n- Organize related commands\n\n**Naming conventions:**\n- Use descriptive action names\n- Avoid generic names (test, run)\n- Consider plugin-specific prefix\n- Use hyphens for multi-word names\n\n### Plugin Command Patterns\n\n**Configuration-based pattern:**\n\n```markdown\n---\ndescription: Deploy using plugin configuration\nargument-hint: [environment]\nallowed-tools: Read, Bash(*)\n---\n\nLoad configuration: @${CLAUDE_PLUGIN_ROOT}/config/$1-deploy.json\n\nDeploy to $1 using configuration settings.\nMonitor deployment and report status.\n```\n\n**Template-based pattern:**\n\n```markdown\n---\ndescription: Generate docs from template\nargument-hint: [component]\n---\n\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/docs.md\n\nGenerate documentation for $1 following template structure.\n```\n\n**Multi-script pattern:**\n\n```markdown\n---\ndescription: Complete build workflow\nallowed-tools: Bash(*)\n---\n\nBuild: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh`\nTest: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/test.sh`\nPackage: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/package.sh`\n\nReview outputs and report workflow status.\n```\n\n**See `references/plugin-features-reference.md` for detailed patterns.**\n\n## Integration with Plugin Components\n\nCommands can integrate with other plugin components for powerful workflows.\n\n### Agent Integration\n\nLaunch plugin agents for complex tasks:\n\n```markdown\n---\ndescription: Deep code review\nargument-hint: [file-path]\n---\n\nInitiate comprehensive review of @$1 using the code-reviewer agent.\n\nThe agent will analyze:\n- Code structure\n- Security issues\n- Performance\n- Best practices\n\nAgent uses plugin resources:\n- ${CLAUDE_PLUGIN_ROOT}/config/rules.json\n- ${CLAUDE_PLUGIN_ROOT}/checklists/review.md\n```\n\n**Key points:**\n- Agent must exist in `plugin/agents/` directory\n- Claude uses Task tool to launch agent\n- Document agent capabilities\n- Reference plugin resources agent uses\n\n### Skill Integration\n\nLeverage plugin skills for specialized knowledge:\n\n```markdown\n---\ndescription: Document API with standards\nargument-hint: [api-file]\n---\n\nDocument API in @$1 following plugin standards.\n\nUse the api-docs-standards skill to ensure:\n- Complete endpoint documentation\n- Consistent formatting\n- Example quality\n- Error documentation\n\nGenerate production-ready API docs.\n```\n\n**Key points:**\n- Skill must exist in `plugin/skills/` directory\n- Mention skill name to trigger invocation\n- Document skill purpose\n- Explain what skill provides\n\n### Hook Coordination\n\nDesign commands that work with plugin hooks:\n- Commands can prepare state for hooks to process\n- Hooks execute automatically on tool events\n- Commands should document expected hook behavior\n- Guide Claude on interpreting hook output\n\nSee `references/plugin-features-reference.md` for examples of commands that coordinate with hooks\n\n### Multi-Component Workflows\n\nCombine agents, skills, and scripts:\n\n```markdown\n---\ndescription: Comprehensive review workflow\nargument-hint: [file]\nallowed-tools: Bash(node:*), Read\n---\n\nTarget: @$1\n\nPhase 1 - Static Analysis:\n!`node ${CLAUDE_PLUGIN_ROOT}/scripts/lint.js $1`\n\nPhase 2 - Deep Review:\nLaunch code-reviewer agent for detailed analysis.\n\nPhase 3 - Standards Check:\nUse coding-standards skill for validation.\n\nPhase 4 - Report:\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/review.md\n\nCompile findings into report following template.\n```\n\n**When to use:**\n- Complex multi-step workflows\n- Leverage multiple plugin capabilities\n- Require specialized analysis\n- Need structured outputs\n\n## Validation Patterns\n\nCommands should validate inputs and resources before processing.\n\n### Argument Validation\n\n```markdown\n---\ndescription: Deploy with validation\nargument-hint: [environment]\n---\n\nValidate environment: !`echo \"$1\" | grep -E \"^(dev|staging|prod)$\" || echo \"INVALID\"`\n\nIf $1 is valid environment:\n  Deploy to $1\nOtherwise:\n  Explain valid environments: dev, staging, prod\n  Show usage: /deploy [environment]\n```\n\n### File Existence Checks\n\n```markdown\n---\ndescription: Process configuration\nargument-hint: [config-file]\n---\n\nCheck file exists: !`test -f $1 && echo \"EXISTS\" || echo \"MISSING\"`\n\nIf file exists:\n  Process configuration: @$1\nOtherwise:\n  Explain where to place config file\n  Show expected format\n  Provide example configuration\n```\n\n### Plugin Resource Validation\n\n```markdown\n---\ndescription: Run plugin analyzer\nallowed-tools: Bash(test:*)\n---\n\nValidate plugin setup:\n- Script: !`test -x ${CLAUDE_PLUGIN_ROOT}/bin/analyze && echo \"âœ“\" || echo \"âœ—\"`\n- Config: !`test -f ${CLAUDE_PLUGIN_ROOT}/config.json && echo \"âœ“\" || echo \"âœ—\"`\n\nIf all checks pass, run analysis.\nOtherwise, report missing components.\n```\n\n### Error Handling\n\n```markdown\n---\ndescription: Build with error handling\nallowed-tools: Bash(*)\n---\n\nExecute build: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh 2>&1 || echo \"BUILD_FAILED\"`\n\nIf build succeeded:\n  Report success and output location\nIf build failed:\n  Analyze error output\n  Suggest likely causes\n  Provide troubleshooting steps\n```\n\n**Best practices:**\n- Validate early in command\n- Provide helpful error messages\n- Suggest corrective actions\n- Handle edge cases gracefully\n\n---\n\nFor detailed frontmatter field specifications, see `references/frontmatter-reference.md`.\nFor plugin-specific features and patterns, see `references/plugin-features-reference.md`.\nFor command pattern examples, see `examples/` directory."
              },
              {
                "name": "Hook Development",
                "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
                "path": "plugins/plugin-dev/skills/hook-development/SKILL.md",
                "frontmatter": {
                  "name": "Hook Development",
                  "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
                  "version": "0.1.0"
                },
                "content": "# Hook Development for Claude Code Plugins\n\n## Overview\n\nHooks are event-driven automation scripts that execute in response to Claude Code events. Use hooks to validate operations, enforce policies, add context, and integrate external tools into workflows.\n\n**Key capabilities:**\n- Validate tool calls before execution (PreToolUse)\n- React to tool results (PostToolUse)\n- Enforce completion standards (Stop, SubagentStop)\n- Load project context (SessionStart)\n- Automate workflows across the development lifecycle\n\n## Hook Types\n\n### Prompt-Based Hooks (Recommended)\n\nUse LLM-driven decision making for context-aware validation:\n\n```json\n{\n  \"type\": \"prompt\",\n  \"prompt\": \"Evaluate if this tool use is appropriate: $TOOL_INPUT\",\n  \"timeout\": 30\n}\n```\n\n**Supported events:** Stop, SubagentStop, UserPromptSubmit, PreToolUse\n\n**Benefits:**\n- Context-aware decisions based on natural language reasoning\n- Flexible evaluation logic without bash scripting\n- Better edge case handling\n- Easier to maintain and extend\n\n### Command Hooks\n\nExecute bash commands for deterministic checks:\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\",\n  \"timeout\": 60\n}\n```\n\n**Use for:**\n- Fast deterministic validations\n- File system operations\n- External tool integrations\n- Performance-critical checks\n\n## Hook Configuration Formats\n\n### Plugin hooks.json Format\n\n**For plugin hooks** in `hooks/hooks.json`, use wrapper format:\n\n```json\n{\n  \"description\": \"Brief explanation of hooks (optional)\",\n  \"hooks\": {\n    \"PreToolUse\": [...],\n    \"Stop\": [...],\n    \"SessionStart\": [...]\n  }\n}\n```\n\n**Key points:**\n- `description` field is optional\n- `hooks` field is required wrapper containing actual hook events\n- This is the **plugin-specific format**\n\n**Example:**\n```json\n{\n  \"description\": \"Validation hooks for code quality\",\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Write\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/validate.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n### Settings Format (Direct)\n\n**For user settings** in `.claude/settings.json`, use direct format:\n\n```json\n{\n  \"PreToolUse\": [...],\n  \"Stop\": [...],\n  \"SessionStart\": [...]\n}\n```\n\n**Key points:**\n- No wrapper - events directly at top level\n- No description field\n- This is the **settings format**\n\n**Important:** The examples below show the hook event structure that goes inside either format. For plugin hooks.json, wrap these in `{\"hooks\": {...}}`.\n\n## Hook Events\n\n### PreToolUse\n\nExecute before any tool runs. Use to approve, deny, or modify tool calls.\n\n**Example (prompt-based):**\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety. Check: system paths, credentials, path traversal, sensitive content. Return 'approve' or 'deny'.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output for PreToolUse:**\n```json\n{\n  \"hookSpecificOutput\": {\n    \"permissionDecision\": \"allow|deny|ask\",\n    \"updatedInput\": {\"field\": \"modified_value\"}\n  },\n  \"systemMessage\": \"Explanation for Claude\"\n}\n```\n\n### PostToolUse\n\nExecute after tool completes. Use to react to results, provide feedback, or log.\n\n**Example:**\n```json\n{\n  \"PostToolUse\": [\n    {\n      \"matcher\": \"Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Analyze edit result for potential issues: syntax errors, security vulnerabilities, breaking changes. Provide feedback.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output behavior:**\n- Exit 0: stdout shown in transcript\n- Exit 2: stderr fed back to Claude\n- systemMessage included in context\n\n### Stop\n\nExecute when main agent considers stopping. Use to validate completeness.\n\n**Example:**\n```json\n{\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion: tests run, build succeeded, questions answered. Return 'approve' to stop or 'block' with reason to continue.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Decision output:**\n```json\n{\n  \"decision\": \"approve|block\",\n  \"reason\": \"Explanation\",\n  \"systemMessage\": \"Additional context\"\n}\n```\n\n### SubagentStop\n\nExecute when subagent considers stopping. Use to ensure subagent completed its task.\n\nSimilar to Stop hook, but for subagents.\n\n### UserPromptSubmit\n\nExecute when user submits a prompt. Use to add context, validate, or block prompts.\n\n**Example:**\n```json\n{\n  \"UserPromptSubmit\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Check if prompt requires security guidance. If discussing auth, permissions, or API security, return relevant warnings.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### SessionStart\n\nExecute when Claude Code session begins. Use to load context and set environment.\n\n**Example:**\n```json\n{\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Special capability:** Persist environment variables using `$CLAUDE_ENV_FILE`:\n```bash\necho \"export PROJECT_TYPE=nodejs\" >> \"$CLAUDE_ENV_FILE\"\n```\n\nSee `examples/load-context.sh` for complete example.\n\n### SessionEnd\n\nExecute when session ends. Use for cleanup, logging, and state preservation.\n\n### PreCompact\n\nExecute before context compaction. Use to add critical information to preserve.\n\n### Notification\n\nExecute when Claude sends notifications. Use to react to user notifications.\n\n## Hook Output Format\n\n### Standard Output (All Hooks)\n\n```json\n{\n  \"continue\": true,\n  \"suppressOutput\": false,\n  \"systemMessage\": \"Message for Claude\"\n}\n```\n\n- `continue`: If false, halt processing (default true)\n- `suppressOutput`: Hide output from transcript (default false)\n- `systemMessage`: Message shown to Claude\n\n### Exit Codes\n\n- `0` - Success (stdout shown in transcript)\n- `2` - Blocking error (stderr fed back to Claude)\n- Other - Non-blocking error\n\n## Hook Input Format\n\nAll hooks receive JSON via stdin with common fields:\n\n```json\n{\n  \"session_id\": \"abc123\",\n  \"transcript_path\": \"/path/to/transcript.txt\",\n  \"cwd\": \"/current/working/dir\",\n  \"permission_mode\": \"ask|allow\",\n  \"hook_event_name\": \"PreToolUse\"\n}\n```\n\n**Event-specific fields:**\n\n- **PreToolUse/PostToolUse:** `tool_name`, `tool_input`, `tool_result`\n- **UserPromptSubmit:** `user_prompt`\n- **Stop/SubagentStop:** `reason`\n\nAccess fields in prompts using `$TOOL_INPUT`, `$TOOL_RESULT`, `$USER_PROMPT`, etc.\n\n## Environment Variables\n\nAvailable in all command hooks:\n\n- `$CLAUDE_PROJECT_DIR` - Project root path\n- `$CLAUDE_PLUGIN_ROOT` - Plugin directory (use for portable paths)\n- `$CLAUDE_ENV_FILE` - SessionStart only: persist env vars here\n- `$CLAUDE_CODE_REMOTE` - Set if running in remote context\n\n**Always use ${CLAUDE_PLUGIN_ROOT} in hook commands for portability:**\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\"\n}\n```\n\n## Plugin Hook Configuration\n\nIn plugins, define hooks in `hooks/hooks.json`:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety\"\n        }\n      ]\n    }\n  ],\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion\"\n        }\n      ]\n    }\n  ],\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\",\n          \"timeout\": 10\n        }\n      ]\n    }\n  ]\n}\n```\n\nPlugin hooks merge with user's hooks and run in parallel.\n\n## Matchers\n\n### Tool Name Matching\n\n**Exact match:**\n```json\n\"matcher\": \"Write\"\n```\n\n**Multiple tools:**\n```json\n\"matcher\": \"Read|Write|Edit\"\n```\n\n**Wildcard (all tools):**\n```json\n\"matcher\": \"*\"\n```\n\n**Regex patterns:**\n```json\n\"matcher\": \"mcp__.*__delete.*\"  // All MCP delete tools\n```\n\n**Note:** Matchers are case-sensitive.\n\n### Common Patterns\n\n```json\n// All MCP tools\n\"matcher\": \"mcp__.*\"\n\n// Specific plugin's MCP tools\n\"matcher\": \"mcp__plugin_asana_.*\"\n\n// All file operations\n\"matcher\": \"Read|Write|Edit\"\n\n// Bash commands only\n\"matcher\": \"Bash\"\n```\n\n## Security Best Practices\n\n### Input Validation\n\nAlways validate inputs in command hooks:\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\ninput=$(cat)\ntool_name=$(echo \"$input\" | jq -r '.tool_name')\n\n# Validate tool name format\nif [[ ! \"$tool_name\" =~ ^[a-zA-Z0-9_]+$ ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Invalid tool name\"}' >&2\n  exit 2\nfi\n```\n\n### Path Safety\n\nCheck for path traversal and sensitive files:\n\n```bash\nfile_path=$(echo \"$input\" | jq -r '.tool_input.file_path')\n\n# Deny path traversal\nif [[ \"$file_path\" == *\"..\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Path traversal detected\"}' >&2\n  exit 2\nfi\n\n# Deny sensitive files\nif [[ \"$file_path\" == *\".env\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Sensitive file\"}' >&2\n  exit 2\nfi\n```\n\nSee `examples/validate-write.sh` and `examples/validate-bash.sh` for complete examples.\n\n### Quote All Variables\n\n```bash\n# GOOD: Quoted\necho \"$file_path\"\ncd \"$CLAUDE_PROJECT_DIR\"\n\n# BAD: Unquoted (injection risk)\necho $file_path\ncd $CLAUDE_PROJECT_DIR\n```\n\n### Set Appropriate Timeouts\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash script.sh\",\n  \"timeout\": 10\n}\n```\n\n**Defaults:** Command hooks (60s), Prompt hooks (30s)\n\n## Performance Considerations\n\n### Parallel Execution\n\nAll matching hooks run **in parallel**:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write\",\n      \"hooks\": [\n        {\"type\": \"command\", \"command\": \"check1.sh\"},  // Parallel\n        {\"type\": \"command\", \"command\": \"check2.sh\"},  // Parallel\n        {\"type\": \"prompt\", \"prompt\": \"Validate...\"}   // Parallel\n      ]\n    }\n  ]\n}\n```\n\n**Design implications:**\n- Hooks don't see each other's output\n- Non-deterministic ordering\n- Design for independence\n\n### Optimization\n\n1. Use command hooks for quick deterministic checks\n2. Use prompt hooks for complex reasoning\n3. Cache validation results in temp files\n4. Minimize I/O in hot paths\n\n## Temporarily Active Hooks\n\nCreate hooks that activate conditionally by checking for a flag file or configuration:\n\n**Pattern: Flag file activation**\n```bash\n#!/bin/bash\n# Only active when flag file exists\nFLAG_FILE=\"$CLAUDE_PROJECT_DIR/.enable-strict-validation\"\n\nif [ ! -f \"$FLAG_FILE\" ]; then\n  # Flag not present, skip validation\n  exit 0\nfi\n\n# Flag present, run validation\ninput=$(cat)\n# ... validation logic ...\n```\n\n**Pattern: Configuration-based activation**\n```bash\n#!/bin/bash\n# Check configuration for activation\nCONFIG_FILE=\"$CLAUDE_PROJECT_DIR/.claude/plugin-config.json\"\n\nif [ -f \"$CONFIG_FILE\" ]; then\n  enabled=$(jq -r '.strictMode // false' \"$CONFIG_FILE\")\n  if [ \"$enabled\" != \"true\" ]; then\n    exit 0  # Not enabled, skip\n  fi\nfi\n\n# Enabled, run hook logic\ninput=$(cat)\n# ... hook logic ...\n```\n\n**Use cases:**\n- Enable strict validation only when needed\n- Temporary debugging hooks\n- Project-specific hook behavior\n- Feature flags for hooks\n\n**Best practice:** Document activation mechanism in plugin README so users know how to enable/disable temporary hooks.\n\n## Hook Lifecycle and Limitations\n\n### Hooks Load at Session Start\n\n**Important:** Hooks are loaded when Claude Code session starts. Changes to hook configuration require restarting Claude Code.\n\n**Cannot hot-swap hooks:**\n- Editing `hooks/hooks.json` won't affect current session\n- Adding new hook scripts won't be recognized\n- Changing hook commands/prompts won't update\n- Must restart Claude Code: exit and run `claude` again\n\n**To test hook changes:**\n1. Edit hook configuration or scripts\n2. Exit Claude Code session\n3. Restart: `claude` or `cc`\n4. New hook configuration loads\n5. Test hooks with `claude --debug`\n\n### Hook Validation at Startup\n\nHooks are validated when Claude Code starts:\n- Invalid JSON in hooks.json causes loading failure\n- Missing scripts cause warnings\n- Syntax errors reported in debug mode\n\nUse `/hooks` command to review loaded hooks in current session.\n\n## Debugging Hooks\n\n### Enable Debug Mode\n\n```bash\nclaude --debug\n```\n\nLook for hook registration, execution logs, input/output JSON, and timing information.\n\n### Test Hook Scripts\n\nTest command hooks directly:\n\n```bash\necho '{\"tool_name\": \"Write\", \"tool_input\": {\"file_path\": \"/test\"}}' | \\\n  bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\n\necho \"Exit code: $?\"\n```\n\n### Validate JSON Output\n\nEnsure hooks output valid JSON:\n\n```bash\noutput=$(./your-hook.sh < test-input.json)\necho \"$output\" | jq .\n```\n\n## Quick Reference\n\n### Hook Events Summary\n\n| Event | When | Use For |\n|-------|------|---------|\n| PreToolUse | Before tool | Validation, modification |\n| PostToolUse | After tool | Feedback, logging |\n| UserPromptSubmit | User input | Context, validation |\n| Stop | Agent stopping | Completeness check |\n| SubagentStop | Subagent done | Task validation |\n| SessionStart | Session begins | Context loading |\n| SessionEnd | Session ends | Cleanup, logging |\n| PreCompact | Before compact | Preserve context |\n| Notification | User notified | Logging, reactions |\n\n### Best Practices\n\n**DO:**\n- âœ… Use prompt-based hooks for complex logic\n- âœ… Use ${CLAUDE_PLUGIN_ROOT} for portability\n- âœ… Validate all inputs in command hooks\n- âœ… Quote all bash variables\n- âœ… Set appropriate timeouts\n- âœ… Return structured JSON output\n- âœ… Test hooks thoroughly\n\n**DON'T:**\n- âŒ Use hardcoded paths\n- âŒ Trust user input without validation\n- âŒ Create long-running hooks\n- âŒ Rely on hook execution order\n- âŒ Modify global state unpredictably\n- âŒ Log sensitive information\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and advanced techniques, consult:\n\n- **`references/patterns.md`** - Common hook patterns (8+ proven patterns)\n- **`references/migration.md`** - Migrating from basic to advanced hooks\n- **`references/advanced.md`** - Advanced use cases and techniques\n\n### Example Hook Scripts\n\nWorking examples in `examples/`:\n\n- **`validate-write.sh`** - File write validation example\n- **`validate-bash.sh`** - Bash command validation example\n- **`load-context.sh`** - SessionStart context loading example\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-hook-schema.sh`** - Validate hooks.json structure and syntax\n- **`test-hook.sh`** - Test hooks with sample input before deployment\n- **`hook-linter.sh`** - Check hook scripts for common issues and best practices\n\n### External Resources\n\n- **Official Docs**: https://docs.claude.com/en/docs/claude-code/hooks\n- **Examples**: See security-guidance plugin in marketplace\n- **Testing**: Use `claude --debug` for detailed logs\n- **Validation**: Use `jq` to validate hook JSON output\n\n## Implementation Workflow\n\nTo implement hooks in a plugin:\n\n1. Identify events to hook into (PreToolUse, Stop, SessionStart, etc.)\n2. Decide between prompt-based (flexible) or command (deterministic) hooks\n3. Write hook configuration in `hooks/hooks.json`\n4. For command hooks, create hook scripts\n5. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n6. Validate configuration with `scripts/validate-hook-schema.sh hooks/hooks.json`\n7. Test hooks with `scripts/test-hook.sh` before deployment\n8. Test in Claude Code with `claude --debug`\n9. Document hooks in plugin README\n\nFocus on prompt-based hooks for most use cases. Reserve command hooks for performance-critical or deterministic checks."
              },
              {
                "name": "MCP Integration",
                "description": "This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration.",
                "path": "plugins/plugin-dev/skills/mcp-integration/SKILL.md",
                "frontmatter": {
                  "name": "MCP Integration",
                  "description": "This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration.",
                  "version": "0.1.0"
                },
                "content": "# MCP Integration for Claude Code Plugins\n\n## Overview\n\nModel Context Protocol (MCP) enables Claude Code plugins to integrate with external services and APIs by providing structured tool access. Use MCP integration to expose external service capabilities as tools within Claude Code.\n\n**Key capabilities:**\n- Connect to external services (databases, APIs, file systems)\n- Provide 10+ related tools from a single service\n- Handle OAuth and complex authentication flows\n- Bundle MCP servers with plugins for automatic setup\n\n## MCP Server Configuration Methods\n\nPlugins can bundle MCP servers in two ways:\n\n### Method 1: Dedicated .mcp.json (Recommended)\n\nCreate `.mcp.json` at plugin root:\n\n```json\n{\n  \"database-tools\": {\n    \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/db-server\",\n    \"args\": [\"--config\", \"${CLAUDE_PLUGIN_ROOT}/config.json\"],\n    \"env\": {\n      \"DB_URL\": \"${DB_URL}\"\n    }\n  }\n}\n```\n\n**Benefits:**\n- Clear separation of concerns\n- Easier to maintain\n- Better for multiple servers\n\n### Method 2: Inline in plugin.json\n\nAdd `mcpServers` field to plugin.json:\n\n```json\n{\n  \"name\": \"my-plugin\",\n  \"version\": \"1.0.0\",\n  \"mcpServers\": {\n    \"plugin-api\": {\n      \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/api-server\",\n      \"args\": [\"--port\", \"8080\"]\n    }\n  }\n}\n```\n\n**Benefits:**\n- Single configuration file\n- Good for simple single-server plugins\n\n## MCP Server Types\n\n### stdio (Local Process)\n\nExecute local MCP servers as child processes. Best for local tools and custom servers.\n\n**Configuration:**\n```json\n{\n  \"filesystem\": {\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/allowed/path\"],\n    \"env\": {\n      \"LOG_LEVEL\": \"debug\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- File system access\n- Local database connections\n- Custom MCP servers\n- NPM-packaged MCP servers\n\n**Process management:**\n- Claude Code spawns and manages the process\n- Communicates via stdin/stdout\n- Terminates when Claude Code exits\n\n### SSE (Server-Sent Events)\n\nConnect to hosted MCP servers with OAuth support. Best for cloud services.\n\n**Configuration:**\n```json\n{\n  \"asana\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.asana.com/sse\"\n  }\n}\n```\n\n**Use cases:**\n- Official hosted MCP servers (Asana, GitHub, etc.)\n- Cloud services with MCP endpoints\n- OAuth-based authentication\n- No local installation needed\n\n**Authentication:**\n- OAuth flows handled automatically\n- User prompted on first use\n- Tokens managed by Claude Code\n\n### HTTP (REST API)\n\nConnect to RESTful MCP servers with token authentication.\n\n**Configuration:**\n```json\n{\n  \"api-service\": {\n    \"type\": \"http\",\n    \"url\": \"https://api.example.com/mcp\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${API_TOKEN}\",\n      \"X-Custom-Header\": \"value\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- REST API-based MCP servers\n- Token-based authentication\n- Custom API backends\n- Stateless interactions\n\n### WebSocket (Real-time)\n\nConnect to WebSocket MCP servers for real-time bidirectional communication.\n\n**Configuration:**\n```json\n{\n  \"realtime-service\": {\n    \"type\": \"ws\",\n    \"url\": \"wss://mcp.example.com/ws\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${TOKEN}\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- Real-time data streaming\n- Persistent connections\n- Push notifications from server\n- Low-latency requirements\n\n## Environment Variable Expansion\n\nAll MCP configurations support environment variable substitution:\n\n**${CLAUDE_PLUGIN_ROOT}** - Plugin directory (always use for portability):\n```json\n{\n  \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/my-server\"\n}\n```\n\n**User environment variables** - From user's shell:\n```json\n{\n  \"env\": {\n    \"API_KEY\": \"${MY_API_KEY}\",\n    \"DATABASE_URL\": \"${DB_URL}\"\n  }\n}\n```\n\n**Best practice:** Document all required environment variables in plugin README.\n\n## MCP Tool Naming\n\nWhen MCP servers provide tools, they're automatically prefixed:\n\n**Format:** `mcp__plugin_<plugin-name>_<server-name>__<tool-name>`\n\n**Example:**\n- Plugin: `asana`\n- Server: `asana`\n- Tool: `create_task`\n- **Full name:** `mcp__plugin_asana_asana__asana_create_task`\n\n### Using MCP Tools in Commands\n\nPre-allow specific MCP tools in command frontmatter:\n\n```markdown\n---\nallowed-tools: [\n  \"mcp__plugin_asana_asana__asana_create_task\",\n  \"mcp__plugin_asana_asana__asana_search_tasks\"\n]\n---\n```\n\n**Wildcard (use sparingly):**\n```markdown\n---\nallowed-tools: [\"mcp__plugin_asana_asana__*\"]\n---\n```\n\n**Best practice:** Pre-allow specific tools, not wildcards, for security.\n\n## Lifecycle Management\n\n**Automatic startup:**\n- MCP servers start when plugin enables\n- Connection established before first tool use\n- Restart required for configuration changes\n\n**Lifecycle:**\n1. Plugin loads\n2. MCP configuration parsed\n3. Server process started (stdio) or connection established (SSE/HTTP/WS)\n4. Tools discovered and registered\n5. Tools available as `mcp__plugin_...__...`\n\n**Viewing servers:**\nUse `/mcp` command to see all servers including plugin-provided ones.\n\n## Authentication Patterns\n\n### OAuth (SSE/HTTP)\n\nOAuth handled automatically by Claude Code:\n\n```json\n{\n  \"type\": \"sse\",\n  \"url\": \"https://mcp.example.com/sse\"\n}\n```\n\nUser authenticates in browser on first use. No additional configuration needed.\n\n### Token-Based (Headers)\n\nStatic or environment variable tokens:\n\n```json\n{\n  \"type\": \"http\",\n  \"url\": \"https://api.example.com\",\n  \"headers\": {\n    \"Authorization\": \"Bearer ${API_TOKEN}\"\n  }\n}\n```\n\nDocument required environment variables in README.\n\n### Environment Variables (stdio)\n\nPass configuration to MCP server:\n\n```json\n{\n  \"command\": \"python\",\n  \"args\": [\"-m\", \"my_mcp_server\"],\n  \"env\": {\n    \"DATABASE_URL\": \"${DB_URL}\",\n    \"API_KEY\": \"${API_KEY}\",\n    \"LOG_LEVEL\": \"info\"\n  }\n}\n```\n\n## Integration Patterns\n\n### Pattern 1: Simple Tool Wrapper\n\nCommands use MCP tools with user interaction:\n\n```markdown\n# Command: create-item.md\n---\nallowed-tools: [\"mcp__plugin_name_server__create_item\"]\n---\n\nSteps:\n1. Gather item details from user\n2. Use mcp__plugin_name_server__create_item\n3. Confirm creation\n```\n\n**Use for:** Adding validation or preprocessing before MCP calls.\n\n### Pattern 2: Autonomous Agent\n\nAgents use MCP tools autonomously:\n\n```markdown\n# Agent: data-analyzer.md\n\nAnalysis Process:\n1. Query data via mcp__plugin_db_server__query\n2. Process and analyze results\n3. Generate insights report\n```\n\n**Use for:** Multi-step MCP workflows without user interaction.\n\n### Pattern 3: Multi-Server Plugin\n\nIntegrate multiple MCP servers:\n\n```json\n{\n  \"github\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.github.com/sse\"\n  },\n  \"jira\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.jira.com/sse\"\n  }\n}\n```\n\n**Use for:** Workflows spanning multiple services.\n\n## Security Best Practices\n\n### Use HTTPS/WSS\n\nAlways use secure connections:\n\n```json\nâœ… \"url\": \"https://mcp.example.com/sse\"\nâŒ \"url\": \"http://mcp.example.com/sse\"\n```\n\n### Token Management\n\n**DO:**\n- âœ… Use environment variables for tokens\n- âœ… Document required env vars in README\n- âœ… Let OAuth flow handle authentication\n\n**DON'T:**\n- âŒ Hardcode tokens in configuration\n- âŒ Commit tokens to git\n- âŒ Share tokens in documentation\n\n### Permission Scoping\n\nPre-allow only necessary MCP tools:\n\n```markdown\nâœ… allowed-tools: [\n  \"mcp__plugin_api_server__read_data\",\n  \"mcp__plugin_api_server__create_item\"\n]\n\nâŒ allowed-tools: [\"mcp__plugin_api_server__*\"]\n```\n\n## Error Handling\n\n### Connection Failures\n\nHandle MCP server unavailability:\n- Provide fallback behavior in commands\n- Inform user of connection issues\n- Check server URL and configuration\n\n### Tool Call Errors\n\nHandle failed MCP operations:\n- Validate inputs before calling MCP tools\n- Provide clear error messages\n- Check rate limiting and quotas\n\n### Configuration Errors\n\nValidate MCP configuration:\n- Test server connectivity during development\n- Validate JSON syntax\n- Check required environment variables\n\n## Performance Considerations\n\n### Lazy Loading\n\nMCP servers connect on-demand:\n- Not all servers connect at startup\n- First tool use triggers connection\n- Connection pooling managed automatically\n\n### Batching\n\nBatch similar requests when possible:\n\n```\n# Good: Single query with filters\ntasks = search_tasks(project=\"X\", assignee=\"me\", limit=50)\n\n# Avoid: Many individual queries\nfor id in task_ids:\n    task = get_task(id)\n```\n\n## Testing MCP Integration\n\n### Local Testing\n\n1. Configure MCP server in `.mcp.json`\n2. Install plugin locally (`.claude-plugin/`)\n3. Run `/mcp` to verify server appears\n4. Test tool calls in commands\n5. Check `claude --debug` logs for connection issues\n\n### Validation Checklist\n\n- [ ] MCP configuration is valid JSON\n- [ ] Server URL is correct and accessible\n- [ ] Required environment variables documented\n- [ ] Tools appear in `/mcp` output\n- [ ] Authentication works (OAuth or tokens)\n- [ ] Tool calls succeed from commands\n- [ ] Error cases handled gracefully\n\n## Debugging\n\n### Enable Debug Logging\n\n```bash\nclaude --debug\n```\n\nLook for:\n- MCP server connection attempts\n- Tool discovery logs\n- Authentication flows\n- Tool call errors\n\n### Common Issues\n\n**Server not connecting:**\n- Check URL is correct\n- Verify server is running (stdio)\n- Check network connectivity\n- Review authentication configuration\n\n**Tools not available:**\n- Verify server connected successfully\n- Check tool names match exactly\n- Run `/mcp` to see available tools\n- Restart Claude Code after config changes\n\n**Authentication failing:**\n- Clear cached auth tokens\n- Re-authenticate\n- Check token scopes and permissions\n- Verify environment variables set\n\n## Quick Reference\n\n### MCP Server Types\n\n| Type | Transport | Best For | Auth |\n|------|-----------|----------|------|\n| stdio | Process | Local tools, custom servers | Env vars |\n| SSE | HTTP | Hosted services, cloud APIs | OAuth |\n| HTTP | REST | API backends, token auth | Tokens |\n| ws | WebSocket | Real-time, streaming | Tokens |\n\n### Configuration Checklist\n\n- [ ] Server type specified (stdio/SSE/HTTP/ws)\n- [ ] Type-specific fields complete (command or url)\n- [ ] Authentication configured\n- [ ] Environment variables documented\n- [ ] HTTPS/WSS used (not HTTP/WS)\n- [ ] ${CLAUDE_PLUGIN_ROOT} used for paths\n\n### Best Practices\n\n**DO:**\n- âœ… Use ${CLAUDE_PLUGIN_ROOT} for portable paths\n- âœ… Document required environment variables\n- âœ… Use secure connections (HTTPS/WSS)\n- âœ… Pre-allow specific MCP tools in commands\n- âœ… Test MCP integration before publishing\n- âœ… Handle connection and tool errors gracefully\n\n**DON'T:**\n- âŒ Hardcode absolute paths\n- âŒ Commit credentials to git\n- âŒ Use HTTP instead of HTTPS\n- âŒ Pre-allow all tools with wildcards\n- âŒ Skip error handling\n- âŒ Forget to document setup\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed information, consult:\n\n- **`references/server-types.md`** - Deep dive on each server type\n- **`references/authentication.md`** - Authentication patterns and OAuth\n- **`references/tool-usage.md`** - Using MCP tools in commands and agents\n\n### Example Configurations\n\nWorking examples in `examples/`:\n\n- **`stdio-server.json`** - Local stdio MCP server\n- **`sse-server.json`** - Hosted SSE server with OAuth\n- **`http-server.json`** - REST API with token auth\n\n### External Resources\n\n- **Official MCP Docs**: https://modelcontextprotocol.io/\n- **Claude Code MCP Docs**: https://docs.claude.com/en/docs/claude-code/mcp\n- **MCP SDK**: @modelcontextprotocol/sdk\n- **Testing**: Use `claude --debug` and `/mcp` command\n\n## Implementation Workflow\n\nTo add MCP integration to a plugin:\n\n1. Choose MCP server type (stdio, SSE, HTTP, ws)\n2. Create `.mcp.json` at plugin root with configuration\n3. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n4. Document required environment variables in README\n5. Test locally with `/mcp` command\n6. Pre-allow MCP tools in relevant commands\n7. Handle authentication (OAuth or tokens)\n8. Test error cases (connection failures, auth errors)\n9. Document MCP integration in plugin README\n\nFocus on stdio for custom/local servers, SSE for hosted services with OAuth."
              },
              {
                "name": "Plugin Settings",
                "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.",
                "path": "plugins/plugin-dev/skills/plugin-settings/SKILL.md",
                "frontmatter": {
                  "name": "Plugin Settings",
                  "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.",
                  "version": "0.1.0"
                },
                "content": "# Plugin Settings Pattern for Claude Code Plugins\n\n## Overview\n\nPlugins can store user-configurable settings and state in `.claude/plugin-name.local.md` files within the project directory. This pattern uses YAML frontmatter for structured configuration and markdown content for prompts or additional context.\n\n**Key characteristics:**\n- File location: `.claude/plugin-name.local.md` in project root\n- Structure: YAML frontmatter + markdown body\n- Purpose: Per-project plugin configuration and state\n- Usage: Read from hooks, commands, and agents\n- Lifecycle: User-managed (not in git, should be in `.gitignore`)\n\n## File Structure\n\n### Basic Template\n\n```markdown\n---\nenabled: true\nsetting1: value1\nsetting2: value2\nnumeric_setting: 42\nlist_setting: [\"item1\", \"item2\"]\n---\n\n# Additional Context\n\nThis markdown body can contain:\n- Task descriptions\n- Additional instructions\n- Prompts to feed back to Claude\n- Documentation or notes\n```\n\n### Example: Plugin State File\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nenabled: true\nstrict_mode: false\nmax_retries: 3\nnotification_level: info\ncoordinator_session: team-leader\n---\n\n# Plugin Configuration\n\nThis plugin is configured for standard validation mode.\nContact @team-lead with questions.\n```\n\n## Reading Settings Files\n\n### From Hooks (Bash Scripts)\n\n**Pattern: Check existence and parse frontmatter**\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\n# Define state file path\nSTATE_FILE=\".claude/my-plugin.local.md\"\n\n# Quick exit if file doesn't exist\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0  # Plugin not configured, skip\nfi\n\n# Parse YAML frontmatter (between --- markers)\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\n\n# Extract individual fields\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\nSTRICT_MODE=$(echo \"$FRONTMATTER\" | grep '^strict_mode:' | sed 's/strict_mode: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n\n# Check if enabled\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Use configuration in hook logic\nif [[ \"$STRICT_MODE\" == \"true\" ]]; then\n  # Apply strict validation\n  # ...\nfi\n```\n\nSee `examples/read-settings-hook.sh` for complete working example.\n\n### From Commands\n\nCommands can read settings files to customize behavior:\n\n```markdown\n---\ndescription: Process data with plugin\nallowed-tools: [\"Read\", \"Bash\"]\n---\n\n# Process Command\n\nSteps:\n1. Check if settings exist at `.claude/my-plugin.local.md`\n2. Read configuration using Read tool\n3. Parse YAML frontmatter to extract settings\n4. Apply settings to processing logic\n5. Execute with configured behavior\n```\n\n### From Agents\n\nAgents can reference settings in their instructions:\n\n```markdown\n---\nname: configured-agent\ndescription: Agent that adapts to project settings\n---\n\nCheck for plugin settings at `.claude/my-plugin.local.md`.\nIf present, parse YAML frontmatter and adapt behavior according to:\n- enabled: Whether plugin is active\n- mode: Processing mode (strict, standard, lenient)\n- Additional configuration fields\n```\n\n## Parsing Techniques\n\n### Extract Frontmatter\n\n```bash\n# Extract everything between --- markers\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n```\n\n### Read Individual Fields\n\n**String fields:**\n```bash\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field_name:' | sed 's/field_name: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n**Boolean fields:**\n```bash\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n# Compare: if [[ \"$ENABLED\" == \"true\" ]]; then\n```\n\n**Numeric fields:**\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n# Use: if [[ $MAX -gt 100 ]]; then\n```\n\n### Read Markdown Body\n\nExtract content after second `---`:\n\n```bash\n# Get everything after closing ---\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n## Common Patterns\n\n### Pattern 1: Temporarily Active Hooks\n\nUse settings file to control hook activation:\n\n```bash\n#!/bin/bash\nSTATE_FILE=\".claude/security-scan.local.md\"\n\n# Quick exit if not configured\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0\nfi\n\n# Read enabled flag\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Run hook logic\n# ...\n```\n\n**Use case:** Enable/disable hooks without editing hooks.json (requires restart).\n\n### Pattern 2: Agent State Management\n\nStore agent-specific state and configuration:\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-agent\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\n---\n\n# Task Assignment\n\nImplement JWT authentication for the API.\n\n**Success Criteria:**\n- Authentication endpoints created\n- Tests passing\n- PR created and CI green\n```\n\nRead from hooks to coordinate agents:\n\n```bash\nAGENT_NAME=$(echo \"$FRONTMATTER\" | grep '^agent_name:' | sed 's/agent_name: *//')\nCOORDINATOR=$(echo \"$FRONTMATTER\" | grep '^coordinator_session:' | sed 's/coordinator_session: *//')\n\n# Send notification to coordinator\ntmux send-keys -t \"$COORDINATOR\" \"Agent $AGENT_NAME completed task\" Enter\n```\n\n### Pattern 3: Configuration-Driven Behavior\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nvalidation_level: strict\nmax_file_size: 1000000\nallowed_extensions: [\".js\", \".ts\", \".tsx\"]\nenable_logging: true\n---\n\n# Validation Configuration\n\nStrict mode enabled for this project.\nAll writes validated against security policies.\n```\n\nUse in hooks or commands:\n\n```bash\nLEVEL=$(echo \"$FRONTMATTER\" | grep '^validation_level:' | sed 's/validation_level: *//')\n\ncase \"$LEVEL\" in\n  strict)\n    # Apply strict validation\n    ;;\n  standard)\n    # Apply standard validation\n    ;;\n  lenient)\n    # Apply lenient validation\n    ;;\nesac\n```\n\n## Creating Settings Files\n\n### From Commands\n\nCommands can create settings files:\n\n```markdown\n# Setup Command\n\nSteps:\n1. Ask user for configuration preferences\n2. Create `.claude/my-plugin.local.md` with YAML frontmatter\n3. Set appropriate values based on user input\n4. Inform user that settings are saved\n5. Remind user to restart Claude Code for hooks to recognize changes\n```\n\n### Template Generation\n\nProvide template in plugin README:\n\n```markdown\n## Configuration\n\nCreate `.claude/my-plugin.local.md` in your project:\n\n\\`\\`\\`markdown\n---\nenabled: true\nmode: standard\nmax_retries: 3\n---\n\n# Plugin Configuration\n\nYour settings are active.\n\\`\\`\\`\n\nAfter creating or editing, restart Claude Code for changes to take effect.\n```\n\n## Best Practices\n\n### File Naming\n\nâœ… **DO:**\n- Use `.claude/plugin-name.local.md` format\n- Match plugin name exactly\n- Use `.local.md` suffix for user-local files\n\nâŒ **DON'T:**\n- Use different directory (not `.claude/`)\n- Use inconsistent naming\n- Use `.md` without `.local` (might be committed)\n\n### Gitignore\n\nAlways add to `.gitignore`:\n\n```gitignore\n.claude/*.local.md\n.claude/*.local.json\n```\n\nDocument this in plugin README.\n\n### Defaults\n\nProvide sensible defaults when settings file doesn't exist:\n\n```bash\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  # Use defaults\n  ENABLED=true\n  MODE=standard\nelse\n  # Read from file\n  # ...\nfi\n```\n\n### Validation\n\nValidate settings values:\n\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n\n# Validate numeric range\nif ! [[ \"$MAX\" =~ ^[0-9]+$ ]] || [[ $MAX -lt 1 ]] || [[ $MAX -gt 100 ]]; then\n  echo \"âš ï¸  Invalid max_value in settings (must be 1-100)\" >&2\n  MAX=10  # Use default\nfi\n```\n\n### Restart Requirement\n\n**Important:** Settings changes require Claude Code restart.\n\nDocument in your README:\n\n```markdown\n## Changing Settings\n\nAfter editing `.claude/my-plugin.local.md`:\n1. Save the file\n2. Exit Claude Code\n3. Restart: `claude` or `cc`\n4. New settings will be loaded\n```\n\nHooks cannot be hot-swapped within a session.\n\n## Security Considerations\n\n### Sanitize User Input\n\nWhen writing settings files from user input:\n\n```bash\n# Escape quotes in user input\nSAFE_VALUE=$(echo \"$USER_INPUT\" | sed 's/\"/\\\\\"/g')\n\n# Write to file\ncat > \"$STATE_FILE\" <<EOF\n---\nuser_setting: \"$SAFE_VALUE\"\n---\nEOF\n```\n\n### Validate File Paths\n\nIf settings contain file paths:\n\n```bash\nFILE_PATH=$(echo \"$FRONTMATTER\" | grep '^data_file:' | sed 's/data_file: *//')\n\n# Check for path traversal\nif [[ \"$FILE_PATH\" == *\"..\"* ]]; then\n  echo \"âš ï¸  Invalid path in settings (path traversal)\" >&2\n  exit 2\nfi\n```\n\n### Permissions\n\nSettings files should be:\n- Readable by user only (`chmod 600`)\n- Not committed to git\n- Not shared between users\n\n## Real-World Examples\n\n### multi-agent-swarm Plugin\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-implementation\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\nadditional_instructions: Use JWT tokens, not sessions\n---\n\n# Task: Implement Authentication\n\nBuild JWT-based authentication for the REST API.\nCoordinate with auth-agent on shared types.\n```\n\n**Hook usage (agent-stop-notification.sh):**\n- Checks if file exists (line 15-18: quick exit if not)\n- Parses frontmatter to get coordinator_session, agent_name, enabled\n- Sends notifications to coordinator if enabled\n- Allows quick activation/deactivation via `enabled: true/false`\n\n### ralph-loop Plugin\n\n**.claude/ralph-loop.local.md:**\n```markdown\n---\niteration: 1\nmax_iterations: 10\ncompletion_promise: \"All tests passing and build successful\"\n---\n\nFix all the linting errors in the project.\nMake sure tests pass after each fix.\n```\n\n**Hook usage (stop-hook.sh):**\n- Checks if file exists (line 15-18: quick exit if not active)\n- Reads iteration count and max_iterations\n- Extracts completion_promise for loop termination\n- Reads body as the prompt to feed back\n- Updates iteration count on each loop\n\n## Quick Reference\n\n### File Location\n\n```\nproject-root/\nâ””â”€â”€ .claude/\n    â””â”€â”€ plugin-name.local.md\n```\n\n### Frontmatter Parsing\n\n```bash\n# Extract frontmatter\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n\n# Read field\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field:' | sed 's/field: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n### Body Parsing\n\n```bash\n# Extract body (after second ---)\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n### Quick Exit Pattern\n\n```bash\nif [[ ! -f \".claude/my-plugin.local.md\" ]]; then\n  exit 0  # Not configured\nfi\n```\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed implementation patterns:\n\n- **`references/parsing-techniques.md`** - Complete guide to parsing YAML frontmatter and markdown bodies\n- **`references/real-world-examples.md`** - Deep dive into multi-agent-swarm and ralph-loop implementations\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`read-settings-hook.sh`** - Hook that reads and uses settings\n- **`create-settings-command.md`** - Command that creates settings file\n- **`example-settings.md`** - Template settings file\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-settings.sh`** - Validate settings file structure\n- **`parse-frontmatter.sh`** - Extract frontmatter fields\n\n## Implementation Workflow\n\nTo add settings to a plugin:\n\n1. Design settings schema (which fields, types, defaults)\n2. Create template file in plugin documentation\n3. Add gitignore entry for `.claude/*.local.md`\n4. Implement settings parsing in hooks/commands\n5. Use quick-exit pattern (check file exists, check enabled field)\n6. Document settings in plugin README with template\n7. Remind users that changes require Claude Code restart\n\nFocus on keeping settings simple and providing good defaults when settings file doesn't exist."
              },
              {
                "name": "Plugin Structure",
                "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.",
                "path": "plugins/plugin-dev/skills/plugin-structure/SKILL.md",
                "frontmatter": {
                  "name": "Plugin Structure",
                  "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.",
                  "version": "0.1.0"
                },
                "content": "# Plugin Structure for Claude Code\n\n## Overview\n\nClaude Code plugins follow a standardized directory structure with automatic component discovery. Understanding this structure enables creating well-organized, maintainable plugins that integrate seamlessly with Claude Code.\n\n**Key concepts:**\n- Conventional directory layout for automatic discovery\n- Manifest-driven configuration in `.claude-plugin/plugin.json`\n- Component-based organization (commands, agents, skills, hooks)\n- Portable path references using `${CLAUDE_PLUGIN_ROOT}`\n- Explicit vs. auto-discovered component loading\n\n## Directory Structure\n\nEvery Claude Code plugin follows this organizational pattern:\n\n```\nplugin-name/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json          # Required: Plugin manifest\nâ”œâ”€â”€ commands/                 # Slash commands (.md files)\nâ”œâ”€â”€ agents/                   # Subagent definitions (.md files)\nâ”œâ”€â”€ skills/                   # Agent skills (subdirectories)\nâ”‚   â””â”€â”€ skill-name/\nâ”‚       â””â”€â”€ SKILL.md         # Required for each skill\nâ”œâ”€â”€ hooks/\nâ”‚   â””â”€â”€ hooks.json           # Event handler configuration\nâ”œâ”€â”€ .mcp.json                # MCP server definitions\nâ””â”€â”€ scripts/                 # Helper scripts and utilities\n```\n\n**Critical rules:**\n\n1. **Manifest location**: The `plugin.json` manifest MUST be in `.claude-plugin/` directory\n2. **Component locations**: All component directories (commands, agents, skills, hooks) MUST be at plugin root level, NOT nested inside `.claude-plugin/`\n3. **Optional components**: Only create directories for components the plugin actually uses\n4. **Naming convention**: Use kebab-case for all directory and file names\n\n## Plugin Manifest (plugin.json)\n\nThe manifest defines plugin metadata and configuration. Located at `.claude-plugin/plugin.json`:\n\n### Required Fields\n\n```json\n{\n  \"name\": \"plugin-name\"\n}\n```\n\n**Name requirements:**\n- Use kebab-case format (lowercase with hyphens)\n- Must be unique across installed plugins\n- No spaces or special characters\n- Example: `code-review-assistant`, `test-runner`, `api-docs`\n\n### Recommended Metadata\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Brief explanation of plugin purpose\",\n  \"author\": {\n    \"name\": \"Author Name\",\n    \"email\": \"author@example.com\",\n    \"url\": \"https://example.com\"\n  },\n  \"homepage\": \"https://docs.example.com\",\n  \"repository\": \"https://github.com/user/plugin-name\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"testing\", \"automation\", \"ci-cd\"]\n}\n```\n\n**Version format**: Follow semantic versioning (MAJOR.MINOR.PATCH)\n**Keywords**: Use for plugin discovery and categorization\n\n### Component Path Configuration\n\nSpecify custom paths for components (supplements default directories):\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"commands\": \"./custom-commands\",\n  \"agents\": [\"./agents\", \"./specialized-agents\"],\n  \"hooks\": \"./config/hooks.json\",\n  \"mcpServers\": \"./.mcp.json\"\n}\n```\n\n**Important**: Custom paths supplement defaultsâ€”they don't replace them. Components in both default directories and custom paths will load.\n\n**Path rules:**\n- Must be relative to plugin root\n- Must start with `./`\n- Cannot use absolute paths\n- Support arrays for multiple locations\n\n## Component Organization\n\n### Commands\n\n**Location**: `commands/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `commands/` load automatically\n\n**Example structure**:\n```\ncommands/\nâ”œâ”€â”€ review.md        # /review command\nâ”œâ”€â”€ test.md          # /test command\nâ””â”€â”€ deploy.md        # /deploy command\n```\n\n**File format**:\n```markdown\n---\nname: command-name\ndescription: Command description\n---\n\nCommand implementation instructions...\n```\n\n**Usage**: Commands integrate as native slash commands in Claude Code\n\n### Agents\n\n**Location**: `agents/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `agents/` load automatically\n\n**Example structure**:\n```\nagents/\nâ”œâ”€â”€ code-reviewer.md\nâ”œâ”€â”€ test-generator.md\nâ””â”€â”€ refactorer.md\n```\n\n**File format**:\n```markdown\n---\ndescription: Agent role and expertise\ncapabilities:\n  - Specific task 1\n  - Specific task 2\n---\n\nDetailed agent instructions and knowledge...\n```\n\n**Usage**: Users can invoke agents manually, or Claude Code selects them automatically based on task context\n\n### Skills\n\n**Location**: `skills/` directory with subdirectories per skill\n**Format**: Each skill in its own directory with `SKILL.md` file\n**Auto-discovery**: All `SKILL.md` files in skill subdirectories load automatically\n\n**Example structure**:\n```\nskills/\nâ”œâ”€â”€ api-testing/\nâ”‚   â”œâ”€â”€ SKILL.md\nâ”‚   â”œâ”€â”€ scripts/\nâ”‚   â”‚   â””â”€â”€ test-runner.py\nâ”‚   â””â”€â”€ references/\nâ”‚       â””â”€â”€ api-spec.md\nâ””â”€â”€ database-migrations/\n    â”œâ”€â”€ SKILL.md\n    â””â”€â”€ examples/\n        â””â”€â”€ migration-template.sql\n```\n\n**SKILL.md format**:\n```markdown\n---\nname: Skill Name\ndescription: When to use this skill\nversion: 1.0.0\n---\n\nSkill instructions and guidance...\n```\n\n**Supporting files**: Skills can include scripts, references, examples, or assets in subdirectories\n\n**Usage**: Claude Code autonomously activates skills based on task context matching the description\n\n### Hooks\n\n**Location**: `hooks/hooks.json` or inline in `plugin.json`\n**Format**: JSON configuration defining event handlers\n**Registration**: Hooks register automatically when plugin enables\n\n**Example structure**:\n```\nhooks/\nâ”œâ”€â”€ hooks.json           # Hook configuration\nâ””â”€â”€ scripts/\n    â”œâ”€â”€ validate.sh      # Hook script\n    â””â”€â”€ check-style.sh   # Hook script\n```\n\n**Configuration format**:\n```json\n{\n  \"PreToolUse\": [{\n    \"matcher\": \"Write|Edit\",\n    \"hooks\": [{\n      \"type\": \"command\",\n      \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/validate.sh\",\n      \"timeout\": 30\n    }]\n  }]\n}\n```\n\n**Available events**: PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification\n\n**Usage**: Hooks execute automatically in response to Claude Code events\n\n### MCP Servers\n\n**Location**: `.mcp.json` at plugin root or inline in `plugin.json`\n**Format**: JSON configuration for MCP server definitions\n**Auto-start**: Servers start automatically when plugin enables\n\n**Example format**:\n```json\n{\n  \"mcpServers\": {\n    \"server-name\": {\n      \"command\": \"node\",\n      \"args\": [\"${CLAUDE_PLUGIN_ROOT}/servers/server.js\"],\n      \"env\": {\n        \"API_KEY\": \"${API_KEY}\"\n      }\n    }\n  }\n}\n```\n\n**Usage**: MCP servers integrate seamlessly with Claude Code's tool system\n\n## Portable Path References\n\n### ${CLAUDE_PLUGIN_ROOT}\n\nUse `${CLAUDE_PLUGIN_ROOT}` environment variable for all intra-plugin path references:\n\n```json\n{\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/run.sh\"\n}\n```\n\n**Why it matters**: Plugins install in different locations depending on:\n- User installation method (marketplace, local, npm)\n- Operating system conventions\n- User preferences\n\n**Where to use it**:\n- Hook command paths\n- MCP server command arguments\n- Script execution references\n- Resource file paths\n\n**Never use**:\n- Hardcoded absolute paths (`/Users/name/plugins/...`)\n- Relative paths from working directory (`./scripts/...` in commands)\n- Home directory shortcuts (`~/plugins/...`)\n\n### Path Resolution Rules\n\n**In manifest JSON fields** (hooks, MCP servers):\n```json\n\"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/tool.sh\"\n```\n\n**In component files** (commands, agents, skills):\n```markdown\nReference scripts at: ${CLAUDE_PLUGIN_ROOT}/scripts/helper.py\n```\n\n**In executed scripts**:\n```bash\n#!/bin/bash\n# ${CLAUDE_PLUGIN_ROOT} available as environment variable\nsource \"${CLAUDE_PLUGIN_ROOT}/lib/common.sh\"\n```\n\n## File Naming Conventions\n\n### Component Files\n\n**Commands**: Use kebab-case `.md` files\n- `code-review.md` â†’ `/code-review`\n- `run-tests.md` â†’ `/run-tests`\n- `api-docs.md` â†’ `/api-docs`\n\n**Agents**: Use kebab-case `.md` files describing role\n- `test-generator.md`\n- `code-reviewer.md`\n- `performance-analyzer.md`\n\n**Skills**: Use kebab-case directory names\n- `api-testing/`\n- `database-migrations/`\n- `error-handling/`\n\n### Supporting Files\n\n**Scripts**: Use descriptive kebab-case names with appropriate extensions\n- `validate-input.sh`\n- `generate-report.py`\n- `process-data.js`\n\n**Documentation**: Use kebab-case markdown files\n- `api-reference.md`\n- `migration-guide.md`\n- `best-practices.md`\n\n**Configuration**: Use standard names\n- `hooks.json`\n- `.mcp.json`\n- `plugin.json`\n\n## Auto-Discovery Mechanism\n\nClaude Code automatically discovers and loads components:\n\n1. **Plugin manifest**: Reads `.claude-plugin/plugin.json` when plugin enables\n2. **Commands**: Scans `commands/` directory for `.md` files\n3. **Agents**: Scans `agents/` directory for `.md` files\n4. **Skills**: Scans `skills/` for subdirectories containing `SKILL.md`\n5. **Hooks**: Loads configuration from `hooks/hooks.json` or manifest\n6. **MCP servers**: Loads configuration from `.mcp.json` or manifest\n\n**Discovery timing**:\n- Plugin installation: Components register with Claude Code\n- Plugin enable: Components become available for use\n- No restart required: Changes take effect on next Claude Code session\n\n**Override behavior**: Custom paths in `plugin.json` supplement (not replace) default directories\n\n## Best Practices\n\n### Organization\n\n1. **Logical grouping**: Group related components together\n   - Put test-related commands, agents, and skills together\n   - Create subdirectories in `scripts/` for different purposes\n\n2. **Minimal manifest**: Keep `plugin.json` lean\n   - Only specify custom paths when necessary\n   - Rely on auto-discovery for standard layouts\n   - Use inline configuration only for simple cases\n\n3. **Documentation**: Include README files\n   - Plugin root: Overall purpose and usage\n   - Component directories: Specific guidance\n   - Script directories: Usage and requirements\n\n### Naming\n\n1. **Consistency**: Use consistent naming across components\n   - If command is `test-runner`, name related agent `test-runner-agent`\n   - Match skill directory names to their purpose\n\n2. **Clarity**: Use descriptive names that indicate purpose\n   - Good: `api-integration-testing/`, `code-quality-checker.md`\n   - Avoid: `utils/`, `misc.md`, `temp.sh`\n\n3. **Length**: Balance brevity with clarity\n   - Commands: 2-3 words (`review-pr`, `run-ci`)\n   - Agents: Describe role clearly (`code-reviewer`, `test-generator`)\n   - Skills: Topic-focused (`error-handling`, `api-design`)\n\n### Portability\n\n1. **Always use ${CLAUDE_PLUGIN_ROOT}**: Never hardcode paths\n2. **Test on multiple systems**: Verify on macOS, Linux, Windows\n3. **Document dependencies**: List required tools and versions\n4. **Avoid system-specific features**: Use portable bash/Python constructs\n\n### Maintenance\n\n1. **Version consistently**: Update version in plugin.json for releases\n2. **Deprecate gracefully**: Mark old components clearly before removal\n3. **Document breaking changes**: Note changes affecting existing users\n4. **Test thoroughly**: Verify all components work after changes\n\n## Common Patterns\n\n### Minimal Plugin\n\nSingle command with no dependencies:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json    # Just name field\nâ””â”€â”€ commands/\n    â””â”€â”€ hello.md       # Single command\n```\n\n### Full-Featured Plugin\n\nComplete plugin with all component types:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/          # User-facing commands\nâ”œâ”€â”€ agents/            # Specialized subagents\nâ”œâ”€â”€ skills/            # Auto-activating skills\nâ”œâ”€â”€ hooks/             # Event handlers\nâ”‚   â”œâ”€â”€ hooks.json\nâ”‚   â””â”€â”€ scripts/\nâ”œâ”€â”€ .mcp.json          # External integrations\nâ””â”€â”€ scripts/           # Shared utilities\n```\n\n### Skill-Focused Plugin\n\nPlugin providing only skills:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ””â”€â”€ skills/\n    â”œâ”€â”€ skill-one/\n    â”‚   â””â”€â”€ SKILL.md\n    â””â”€â”€ skill-two/\n        â””â”€â”€ SKILL.md\n```\n\n## Troubleshooting\n\n**Component not loading**:\n- Verify file is in correct directory with correct extension\n- Check YAML frontmatter syntax (commands, agents, skills)\n- Ensure skill has `SKILL.md` (not `README.md` or other name)\n- Confirm plugin is enabled in Claude Code settings\n\n**Path resolution errors**:\n- Replace all hardcoded paths with `${CLAUDE_PLUGIN_ROOT}`\n- Verify paths are relative and start with `./` in manifest\n- Check that referenced files exist at specified paths\n- Test with `echo $CLAUDE_PLUGIN_ROOT` in hook scripts\n\n**Auto-discovery not working**:\n- Confirm directories are at plugin root (not in `.claude-plugin/`)\n- Check file naming follows conventions (kebab-case, correct extensions)\n- Verify custom paths in manifest are correct\n- Restart Claude Code to reload plugin configuration\n\n**Conflicts between plugins**:\n- Use unique, descriptive component names\n- Namespace commands with plugin name if needed\n- Document potential conflicts in plugin README\n- Consider command prefixes for related functionality\n\n---\n\nFor detailed examples and advanced patterns, see files in `references/` and `examples/` directories."
              },
              {
                "name": "Skill Development",
                "description": "This skill should be used when the user wants to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins.",
                "path": "plugins/plugin-dev/skills/skill-development/SKILL.md",
                "frontmatter": {
                  "name": "Skill Development",
                  "description": "This skill should be used when the user wants to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins.",
                  "version": "0.1.0"
                },
                "content": "# Skill Development for Claude Code Plugins\n\nThis skill provides guidance for creating effective skills for Claude Code plugins.\n\n## About Skills\n\nSkills are modular, self-contained packages that extend Claude's capabilities by providing\nspecialized knowledge, workflows, and tools. Think of them as \"onboarding guides\" for specific\ndomains or tasksâ€”they transform Claude from a general-purpose agent into a specialized agent\nequipped with procedural knowledge that no model can fully possess.\n\n### What Skills Provide\n\n1. Specialized workflows - Multi-step procedures for specific domains\n2. Tool integrations - Instructions for working with specific file formats or APIs\n3. Domain expertise - Company-specific knowledge, schemas, business logic\n4. Bundled resources - Scripts, references, and assets for complex and repetitive tasks\n\n### Anatomy of a Skill\n\nEvery skill consists of a required SKILL.md file and optional bundled resources:\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md (required)\nâ”‚   â”œâ”€â”€ YAML frontmatter metadata (required)\nâ”‚   â”‚   â”œâ”€â”€ name: (required)\nâ”‚   â”‚   â””â”€â”€ description: (required)\nâ”‚   â””â”€â”€ Markdown instructions (required)\nâ””â”€â”€ Bundled Resources (optional)\n    â”œâ”€â”€ scripts/          - Executable code (Python/Bash/etc.)\n    â”œâ”€â”€ references/       - Documentation intended to be loaded into context as needed\n    â””â”€â”€ assets/           - Files used in output (templates, icons, fonts, etc.)\n```\n\n#### SKILL.md (required)\n\n**Metadata Quality:** The `name` and `description` in YAML frontmatter determine when Claude will use the skill. Be specific about what the skill does and when to use it. Use the third-person (e.g. \"This skill should be used when...\" instead of \"Use this skill when...\").\n\n#### Bundled Resources (optional)\n\n##### Scripts (`scripts/`)\n\nExecutable code (Python/Bash/etc.) for tasks that require deterministic reliability or are repeatedly rewritten.\n\n- **When to include**: When the same code is being rewritten repeatedly or deterministic reliability is needed\n- **Example**: `scripts/rotate_pdf.py` for PDF rotation tasks\n- **Benefits**: Token efficient, deterministic, may be executed without loading into context\n- **Note**: Scripts may still need to be read by Claude for patching or environment-specific adjustments\n\n##### References (`references/`)\n\nDocumentation and reference material intended to be loaded as needed into context to inform Claude's process and thinking.\n\n- **When to include**: For documentation that Claude should reference while working\n- **Examples**: `references/finance.md` for financial schemas, `references/mnda.md` for company NDA template, `references/policies.md` for company policies, `references/api_docs.md` for API specifications\n- **Use cases**: Database schemas, API documentation, domain knowledge, company policies, detailed workflow guides\n- **Benefits**: Keeps SKILL.md lean, loaded only when Claude determines it's needed\n- **Best practice**: If files are large (>10k words), include grep search patterns in SKILL.md\n- **Avoid duplication**: Information should live in either SKILL.md or references files, not both. Prefer references files for detailed information unless it's truly core to the skillâ€”this keeps SKILL.md lean while making information discoverable without hogging the context window. Keep only essential procedural instructions and workflow guidance in SKILL.md; move detailed reference material, schemas, and examples to references files.\n\n##### Assets (`assets/`)\n\nFiles not intended to be loaded into context, but rather used within the output Claude produces.\n\n- **When to include**: When the skill needs files that will be used in the final output\n- **Examples**: `assets/logo.png` for brand assets, `assets/slides.pptx` for PowerPoint templates, `assets/frontend-template/` for HTML/React boilerplate, `assets/font.ttf` for typography\n- **Use cases**: Templates, images, icons, boilerplate code, fonts, sample documents that get copied or modified\n- **Benefits**: Separates output resources from documentation, enables Claude to use files without loading them into context\n\n### Progressive Disclosure Design Principle\n\nSkills use a three-level loading system to manage context efficiently:\n\n1. **Metadata (name + description)** - Always in context (~100 words)\n2. **SKILL.md body** - When skill triggers (<5k words)\n3. **Bundled resources** - As needed by Claude (Unlimited*)\n\n*Unlimited because scripts can be executed without reading into context window.\n\n## Skill Creation Process\n\nTo create a skill, follow the \"Skill Creation Process\" in order, skipping steps only if there is a clear reason why they are not applicable.\n\n### Step 1: Understanding the Skill with Concrete Examples\n\nSkip this step only when the skill's usage patterns are already clearly understood. It remains valuable even when working with an existing skill.\n\nTo create an effective skill, clearly understand concrete examples of how the skill will be used. This understanding can come from either direct user examples or generated examples that are validated with user feedback.\n\nFor example, when building an image-editor skill, relevant questions include:\n\n- \"What functionality should the image-editor skill support? Editing, rotating, anything else?\"\n- \"Can you give some examples of how this skill would be used?\"\n- \"I can imagine users asking for things like 'Remove the red-eye from this image' or 'Rotate this image'. Are there other ways you imagine this skill being used?\"\n- \"What would a user say that should trigger this skill?\"\n\nTo avoid overwhelming users, avoid asking too many questions in a single message. Start with the most important questions and follow up as needed for better effectiveness.\n\nConclude this step when there is a clear sense of the functionality the skill should support.\n\n### Step 2: Planning the Reusable Skill Contents\n\nTo turn concrete examples into an effective skill, analyze each example by:\n\n1. Considering how to execute on the example from scratch\n2. Identifying what scripts, references, and assets would be helpful when executing these workflows repeatedly\n\nExample: When building a `pdf-editor` skill to handle queries like \"Help me rotate this PDF,\" the analysis shows:\n\n1. Rotating a PDF requires re-writing the same code each time\n2. A `scripts/rotate_pdf.py` script would be helpful to store in the skill\n\nExample: When designing a `frontend-webapp-builder` skill for queries like \"Build me a todo app\" or \"Build me a dashboard to track my steps,\" the analysis shows:\n\n1. Writing a frontend webapp requires the same boilerplate HTML/React each time\n2. An `assets/hello-world/` template containing the boilerplate HTML/React project files would be helpful to store in the skill\n\nExample: When building a `big-query` skill to handle queries like \"How many users have logged in today?\" the analysis shows:\n\n1. Querying BigQuery requires re-discovering the table schemas and relationships each time\n2. A `references/schema.md` file documenting the table schemas would be helpful to store in the skill\n\n**For Claude Code plugins:** When building a hooks skill, the analysis shows:\n1. Developers repeatedly need to validate hooks.json and test hook scripts\n2. `scripts/validate-hook-schema.sh` and `scripts/test-hook.sh` utilities would be helpful\n3. `references/patterns.md` for detailed hook patterns to avoid bloating SKILL.md\n\nTo establish the skill's contents, analyze each concrete example to create a list of the reusable resources to include: scripts, references, and assets.\n\n### Step 3: Create Skill Structure\n\nFor Claude Code plugins, create the skill directory structure:\n\n```bash\nmkdir -p plugin-name/skills/skill-name/{references,examples,scripts}\ntouch plugin-name/skills/skill-name/SKILL.md\n```\n\n**Note:** Unlike the generic skill-creator which uses `init_skill.py`, plugin skills are created directly in the plugin's `skills/` directory with a simpler manual structure.\n\n### Step 4: Edit the Skill\n\nWhen editing the (newly-created or existing) skill, remember that the skill is being created for another instance of Claude to use. Focus on including information that would be beneficial and non-obvious to Claude. Consider what procedural knowledge, domain-specific details, or reusable assets would help another Claude instance execute these tasks more effectively.\n\n#### Start with Reusable Skill Contents\n\nTo begin implementation, start with the reusable resources identified above: `scripts/`, `references/`, and `assets/` files. Note that this step may require user input. For example, when implementing a `brand-guidelines` skill, the user may need to provide brand assets or templates to store in `assets/`, or documentation to store in `references/`.\n\nAlso, delete any example files and directories not needed for the skill. Create only the directories you actually need (references/, examples/, scripts/).\n\n#### Update SKILL.md\n\n**Writing Style:** Write the entire skill using **imperative/infinitive form** (verb-first instructions), not second person. Use objective, instructional language (e.g., \"To accomplish X, do Y\" rather than \"You should do X\" or \"If you need to do X\"). This maintains consistency and clarity for AI consumption.\n\n**Description (Frontmatter):** Use third-person format with specific trigger phrases:\n\n```yaml\n---\nname: Skill Name\ndescription: This skill should be used when the user asks to \"specific phrase 1\", \"specific phrase 2\", \"specific phrase 3\". Include exact phrases users would say that should trigger this skill. Be concrete and specific.\nversion: 0.1.0\n---\n```\n\n**Good description examples:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", \"implement prompt-based hooks\", or mentions hook events (PreToolUse, PostToolUse, Stop).\n```\n\n**Bad description examples:**\n```yaml\ndescription: Use this skill when working with hooks.  # Wrong person, vague\ndescription: Load when user needs hook help.  # Not third person\ndescription: Provides hook guidance.  # No trigger phrases\n```\n\nTo complete SKILL.md body, answer the following questions:\n\n1. What is the purpose of the skill, in a few sentences?\n2. When should the skill be used? (Include this in frontmatter description with specific triggers)\n3. In practice, how should Claude use the skill? All reusable skill contents developed above should be referenced so that Claude knows how to use them.\n\n**Keep SKILL.md lean:** Target 1,500-2,000 words for the body. Move detailed content to references/:\n- Detailed patterns â†’ `references/patterns.md`\n- Advanced techniques â†’ `references/advanced.md`\n- Migration guides â†’ `references/migration.md`\n- API references â†’ `references/api-reference.md`\n\n**Reference resources in SKILL.md:**\n```markdown\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and techniques, consult:\n- **`references/patterns.md`** - Common patterns\n- **`references/advanced.md`** - Advanced use cases\n\n### Example Files\n\nWorking examples in `examples/`:\n- **`example-script.sh`** - Working example\n```\n\n### Step 5: Validate and Test\n\n**For plugin skills, validation is different from generic skills:**\n\n1. **Check structure**: Skill directory in `plugin-name/skills/skill-name/`\n2. **Validate SKILL.md**: Has frontmatter with name and description\n3. **Check trigger phrases**: Description includes specific user queries\n4. **Verify writing style**: Body uses imperative/infinitive form, not second person\n5. **Test progressive disclosure**: SKILL.md is lean (~1,500-2,000 words), detailed content in references/\n6. **Check references**: All referenced files exist\n7. **Validate examples**: Examples are complete and correct\n8. **Test scripts**: Scripts are executable and work correctly\n\n**Use the skill-reviewer agent:**\n```\nAsk: \"Review my skill and check if it follows best practices\"\n```\n\nThe skill-reviewer agent will check description quality, content organization, and progressive disclosure.\n\n### Step 6: Iterate\n\nAfter testing the skill, users may request improvements. Often this happens right after using the skill, with fresh context of how the skill performed.\n\n**Iteration workflow:**\n1. Use the skill on real tasks\n2. Notice struggles or inefficiencies\n3. Identify how SKILL.md or bundled resources should be updated\n4. Implement changes and test again\n\n**Common improvements:**\n- Strengthen trigger phrases in description\n- Move long sections from SKILL.md to references/\n- Add missing examples or scripts\n- Clarify ambiguous instructions\n- Add edge case handling\n\n## Plugin-Specific Considerations\n\n### Skill Location in Plugins\n\nPlugin skills live in the plugin's `skills/` directory:\n\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/\nâ”œâ”€â”€ agents/\nâ””â”€â”€ skills/\n    â””â”€â”€ my-skill/\n        â”œâ”€â”€ SKILL.md\n        â”œâ”€â”€ references/\n        â”œâ”€â”€ examples/\n        â””â”€â”€ scripts/\n```\n\n### Auto-Discovery\n\nClaude Code automatically discovers skills:\n- Scans `skills/` directory\n- Finds subdirectories containing `SKILL.md`\n- Loads skill metadata (name + description) always\n- Loads SKILL.md body when skill triggers\n- Loads references/examples when needed\n\n### No Packaging Needed\n\nPlugin skills are distributed as part of the plugin, not as separate ZIP files. Users get skills when they install the plugin.\n\n### Testing in Plugins\n\nTest skills by installing plugin locally:\n\n```bash\n# Test with --plugin-dir\ncc --plugin-dir /path/to/plugin\n\n# Ask questions that should trigger the skill\n# Verify skill loads correctly\n```\n\n## Examples from Plugin-Dev\n\nStudy the skills in this plugin as examples of best practices:\n\n**hook-development skill:**\n- Excellent trigger phrases: \"create a hook\", \"add a PreToolUse hook\", etc.\n- Lean SKILL.md (1,651 words)\n- 3 references/ files for detailed content\n- 3 examples/ of working hooks\n- 3 scripts/ utilities\n\n**agent-development skill:**\n- Strong triggers: \"create an agent\", \"agent frontmatter\", etc.\n- Focused SKILL.md (1,438 words)\n- References include the AI generation prompt from Claude Code\n- Complete agent examples\n\n**plugin-settings skill:**\n- Specific triggers: \"plugin settings\", \".local.md files\", \"YAML frontmatter\"\n- References show real implementations (multi-agent-swarm, ralph-loop)\n- Working parsing scripts\n\nEach demonstrates progressive disclosure and strong triggering.\n\n## Progressive Disclosure in Practice\n\n### What Goes in SKILL.md\n\n**Include (always loaded when skill triggers):**\n- Core concepts and overview\n- Essential procedures and workflows\n- Quick reference tables\n- Pointers to references/examples/scripts\n- Most common use cases\n\n**Keep under 3,000 words, ideally 1,500-2,000 words**\n\n### What Goes in references/\n\n**Move to references/ (loaded as needed):**\n- Detailed patterns and advanced techniques\n- Comprehensive API documentation\n- Migration guides\n- Edge cases and troubleshooting\n- Extensive examples and walkthroughs\n\n**Each reference file can be large (2,000-5,000+ words)**\n\n### What Goes in examples/\n\n**Working code examples:**\n- Complete, runnable scripts\n- Configuration files\n- Template files\n- Real-world usage examples\n\n**Users can copy and adapt these directly**\n\n### What Goes in scripts/\n\n**Utility scripts:**\n- Validation tools\n- Testing helpers\n- Parsing utilities\n- Automation scripts\n\n**Should be executable and documented**\n\n## Writing Style Requirements\n\n### Imperative/Infinitive Form\n\nWrite using verb-first instructions, not second person:\n\n**Correct (imperative):**\n```\nTo create a hook, define the event type.\nConfigure the MCP server with authentication.\nValidate settings before use.\n```\n\n**Incorrect (second person):**\n```\nYou should create a hook by defining the event type.\nYou need to configure the MCP server.\nYou must validate settings before use.\n```\n\n### Third-Person in Description\n\nThe frontmatter description must use third person:\n\n**Correct:**\n```yaml\ndescription: This skill should be used when the user asks to \"create X\", \"configure Y\"...\n```\n\n**Incorrect:**\n```yaml\ndescription: Use this skill when you want to create X...\ndescription: Load this skill when user asks...\n```\n\n### Objective, Instructional Language\n\nFocus on what to do, not who should do it:\n\n**Correct:**\n```\nParse the frontmatter using sed.\nExtract fields with grep.\nValidate values before use.\n```\n\n**Incorrect:**\n```\nYou can parse the frontmatter...\nClaude should extract fields...\nThe user might validate values...\n```\n\n## Validation Checklist\n\nBefore finalizing a skill:\n\n**Structure:**\n- [ ] SKILL.md file exists with valid YAML frontmatter\n- [ ] Frontmatter has `name` and `description` fields\n- [ ] Markdown body is present and substantial\n- [ ] Referenced files actually exist\n\n**Description Quality:**\n- [ ] Uses third person (\"This skill should be used when...\")\n- [ ] Includes specific trigger phrases users would say\n- [ ] Lists concrete scenarios (\"create X\", \"configure Y\")\n- [ ] Not vague or generic\n\n**Content Quality:**\n- [ ] SKILL.md body uses imperative/infinitive form\n- [ ] Body is focused and lean (1,500-2,000 words ideal, <5k max)\n- [ ] Detailed content moved to references/\n- [ ] Examples are complete and working\n- [ ] Scripts are executable and documented\n\n**Progressive Disclosure:**\n- [ ] Core concepts in SKILL.md\n- [ ] Detailed docs in references/\n- [ ] Working code in examples/\n- [ ] Utilities in scripts/\n- [ ] SKILL.md references these resources\n\n**Testing:**\n- [ ] Skill triggers on expected user queries\n- [ ] Content is helpful for intended tasks\n- [ ] No duplicated information across files\n- [ ] References load when needed\n\n## Common Mistakes to Avoid\n\n### Mistake 1: Weak Trigger Description\n\nâŒ **Bad:**\n```yaml\ndescription: Provides guidance for working with hooks.\n```\n\n**Why bad:** Vague, no specific trigger phrases, not third person\n\nâœ… **Good:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", or mentions hook events. Provides comprehensive hooks API guidance.\n```\n\n**Why good:** Third person, specific phrases, concrete scenarios\n\n### Mistake 2: Too Much in SKILL.md\n\nâŒ **Bad:**\n```\nskill-name/\nâ””â”€â”€ SKILL.md  (8,000 words - everything in one file)\n```\n\n**Why bad:** Bloats context when skill loads, detailed content always loaded\n\nâœ… **Good:**\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md  (1,800 words - core essentials)\nâ””â”€â”€ references/\n    â”œâ”€â”€ patterns.md (2,500 words)\n    â””â”€â”€ advanced.md (3,700 words)\n```\n\n**Why good:** Progressive disclosure, detailed content loaded only when needed\n\n### Mistake 3: Second Person Writing\n\nâŒ **Bad:**\n```markdown\nYou should start by reading the configuration file.\nYou need to validate the input.\nYou can use the grep tool to search.\n```\n\n**Why bad:** Second person, not imperative form\n\nâœ… **Good:**\n```markdown\nStart by reading the configuration file.\nValidate the input before processing.\nUse the grep tool to search for patterns.\n```\n\n**Why good:** Imperative form, direct instructions\n\n### Mistake 4: Missing Resource References\n\nâŒ **Bad:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n[No mention of references/ or examples/]\n```\n\n**Why bad:** Claude doesn't know references exist\n\nâœ… **Good:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n## Additional Resources\n\n### Reference Files\n- **`references/patterns.md`** - Detailed patterns\n- **`references/advanced.md`** - Advanced techniques\n\n### Examples\n- **`examples/script.sh`** - Working example\n```\n\n**Why good:** Claude knows where to find additional information\n\n## Quick Reference\n\n### Minimal Skill\n\n```\nskill-name/\nâ””â”€â”€ SKILL.md\n```\n\nGood for: Simple knowledge, no complex resources needed\n\n### Standard Skill (Recommended)\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md\nâ”œâ”€â”€ references/\nâ”‚   â””â”€â”€ detailed-guide.md\nâ””â”€â”€ examples/\n    â””â”€â”€ working-example.sh\n```\n\nGood for: Most plugin skills with detailed documentation\n\n### Complete Skill\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md\nâ”œâ”€â”€ references/\nâ”‚   â”œâ”€â”€ patterns.md\nâ”‚   â””â”€â”€ advanced.md\nâ”œâ”€â”€ examples/\nâ”‚   â”œâ”€â”€ example1.sh\nâ”‚   â””â”€â”€ example2.json\nâ””â”€â”€ scripts/\n    â””â”€â”€ validate.sh\n```\n\nGood for: Complex domains with validation utilities\n\n## Best Practices Summary\n\nâœ… **DO:**\n- Use third-person in description (\"This skill should be used when...\")\n- Include specific trigger phrases (\"create X\", \"configure Y\")\n- Keep SKILL.md lean (1,500-2,000 words)\n- Use progressive disclosure (move details to references/)\n- Write in imperative/infinitive form\n- Reference supporting files clearly\n- Provide working examples\n- Create utility scripts for common operations\n- Study plugin-dev's skills as templates\n\nâŒ **DON'T:**\n- Use second person anywhere\n- Have vague trigger conditions\n- Put everything in SKILL.md (>3,000 words without references/)\n- Write in second person (\"You should...\")\n- Leave resources unreferenced\n- Include broken or incomplete examples\n- Skip validation\n\n## Additional Resources\n\n### Study These Skills\n\nPlugin-dev's skills demonstrate best practices:\n- `../hook-development/` - Progressive disclosure, utilities\n- `../agent-development/` - AI-assisted creation, references\n- `../mcp-integration/` - Comprehensive references\n- `../plugin-settings/` - Real-world examples\n- `../command-development/` - Clear critical concepts\n- `../plugin-structure/` - Good organization\n\n### Reference Files\n\nFor complete skill-creator methodology:\n- **`references/skill-creator-original.md`** - Full original skill-creator content\n\n## Implementation Workflow\n\nTo create a skill for your plugin:\n\n1. **Understand use cases**: Identify concrete examples of skill usage\n2. **Plan resources**: Determine what scripts/references/examples needed\n3. **Create structure**: `mkdir -p skills/skill-name/{references,examples,scripts}`\n4. **Write SKILL.md**:\n   - Frontmatter with third-person description and trigger phrases\n   - Lean body (1,500-2,000 words) in imperative form\n   - Reference supporting files\n5. **Add resources**: Create references/, examples/, scripts/ as needed\n6. **Validate**: Check description, writing style, organization\n7. **Test**: Verify skill loads on expected triggers\n8. **Iterate**: Improve based on usage\n\nFocus on strong trigger descriptions, progressive disclosure, and imperative writing style for effective skills that load when needed and provide targeted guidance."
              }
            ]
          }
        ]
      }
    }
  ]
}