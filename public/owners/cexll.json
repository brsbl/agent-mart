{
  "owner": {
    "id": "cexll",
    "display_name": "ben",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/26520956?u=121d4b8f2646b7a7c409ae250d30cef7ed07d290&v=4",
    "url": "https://github.com/cexll",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 6,
      "total_commands": 14,
      "total_skills": 2,
      "total_stars": 1750,
      "total_forks": 218
    }
  },
  "repos": [
    {
      "full_name": "cexll/myclaude",
      "url": "https://github.com/cexll/myclaude",
      "description": "Claude Code and Codex orchestration workflow",
      "homepage": "",
      "signals": {
        "stars": 1750,
        "forks": 218,
        "pushed_at": "2026-01-12T16:09:00Z",
        "created_at": "2025-07-17T07:13:47Z",
        "license": "AGPL-3.0"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 6167
        },
        {
          "path": ".gitattributes",
          "type": "blob",
          "size": 446
        },
        {
          "path": ".github",
          "type": "tree",
          "size": null
        },
        {
          "path": ".github/workflows",
          "type": "tree",
          "size": null
        },
        {
          "path": ".github/workflows/ci.yml",
          "type": "blob",
          "size": 732
        },
        {
          "path": ".github/workflows/release.yml",
          "type": "blob",
          "size": 2918
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 101
        },
        {
          "path": "CHANGELOG.md",
          "type": "blob",
          "size": 10818
        },
        {
          "path": "LICENSE",
          "type": "blob",
          "size": 34523
        },
        {
          "path": "Makefile",
          "type": "blob",
          "size": 6280
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 16694
        },
        {
          "path": "README_CN.md",
          "type": "blob",
          "size": 11563
        },
        {
          "path": "bmad-agile-workflow",
          "type": "tree",
          "size": null
        },
        {
          "path": "bmad-agile-workflow/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "bmad-agile-workflow/.claude-plugin/marketplace.json",
          "type": "blob",
          "size": 914
        },
        {
          "path": "bmad-agile-workflow/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "bmad-agile-workflow/agents/bmad-architect.md",
          "type": "blob",
          "size": 14524
        },
        {
          "path": "bmad-agile-workflow/agents/bmad-dev.md",
          "type": "blob",
          "size": 13801
        },
        {
          "path": "bmad-agile-workflow/agents/bmad-orchestrator.md",
          "type": "blob",
          "size": 4007
        },
        {
          "path": "bmad-agile-workflow/agents/bmad-po.md",
          "type": "blob",
          "size": 10638
        },
        {
          "path": "bmad-agile-workflow/agents/bmad-qa.md",
          "type": "blob",
          "size": 14428
        },
        {
          "path": "bmad-agile-workflow/agents/bmad-review.md",
          "type": "blob",
          "size": 1840
        },
        {
          "path": "bmad-agile-workflow/agents/bmad-sm.md",
          "type": "blob",
          "size": 10787
        },
        {
          "path": "bmad-agile-workflow/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "bmad-agile-workflow/commands/bmad-pilot.md",
          "type": "blob",
          "size": 19331
        },
        {
          "path": "cliff.toml",
          "type": "blob",
          "size": 2360
        },
        {
          "path": "codeagent-wrapper",
          "type": "tree",
          "size": null
        },
        {
          "path": "codeagent-wrapper/.gitignore",
          "type": "blob",
          "size": 148
        },
        {
          "path": "codeagent-wrapper/agent_config.go",
          "type": "blob",
          "size": 3178
        },
        {
          "path": "codeagent-wrapper/agent_config_test.go",
          "type": "blob",
          "size": 6165
        },
        {
          "path": "codeagent-wrapper/agent_validation_test.go",
          "type": "blob",
          "size": 3920
        },
        {
          "path": "codeagent-wrapper/backend.go",
          "type": "blob",
          "size": 4610
        },
        {
          "path": "codeagent-wrapper/backend_test.go",
          "type": "blob",
          "size": 8156
        },
        {
          "path": "codeagent-wrapper/bench_test.go",
          "type": "blob",
          "size": 701
        },
        {
          "path": "codeagent-wrapper/concurrent_stress_test.go",
          "type": "blob",
          "size": 11288
        },
        {
          "path": "codeagent-wrapper/config.go",
          "type": "blob",
          "size": 11591
        },
        {
          "path": "codeagent-wrapper/executor.go",
          "type": "blob",
          "size": 34320
        },
        {
          "path": "codeagent-wrapper/executor_concurrent_test.go",
          "type": "blob",
          "size": 45086
        },
        {
          "path": "codeagent-wrapper/filter.go",
          "type": "blob",
          "size": 1351
        },
        {
          "path": "codeagent-wrapper/filter_test.go",
          "type": "blob",
          "size": 1651
        },
        {
          "path": "codeagent-wrapper/go.mod",
          "type": "blob",
          "size": 34
        },
        {
          "path": "codeagent-wrapper/log_writer_limit_test.go",
          "type": "blob",
          "size": 774
        },
        {
          "path": "codeagent-wrapper/logger.go",
          "type": "blob",
          "size": 15944
        },
        {
          "path": "codeagent-wrapper/logger_additional_coverage_test.go",
          "type": "blob",
          "size": 4211
        },
        {
          "path": "codeagent-wrapper/logger_suffix_test.go",
          "type": "blob",
          "size": 3218
        },
        {
          "path": "codeagent-wrapper/logger_test.go",
          "type": "blob",
          "size": 32665
        },
        {
          "path": "codeagent-wrapper/main.go",
          "type": "blob",
          "size": 15934
        },
        {
          "path": "codeagent-wrapper/main_integration_test.go",
          "type": "blob",
          "size": 25552
        },
        {
          "path": "codeagent-wrapper/main_test.go",
          "type": "blob",
          "size": 131438
        },
        {
          "path": "codeagent-wrapper/parser.go",
          "type": "blob",
          "size": 11772
        },
        {
          "path": "codeagent-wrapper/parser_opencode_test.go",
          "type": "blob",
          "size": 2402
        },
        {
          "path": "codeagent-wrapper/parser_token_too_long_test.go",
          "type": "blob",
          "size": 1028
        },
        {
          "path": "codeagent-wrapper/parser_unknown_event_test.go",
          "type": "blob",
          "size": 836
        },
        {
          "path": "codeagent-wrapper/process_check_test.go",
          "type": "blob",
          "size": 5221
        },
        {
          "path": "codeagent-wrapper/process_check_unix.go",
          "type": "blob",
          "size": 2404
        },
        {
          "path": "codeagent-wrapper/process_check_windows.go",
          "type": "blob",
          "size": 1995
        },
        {
          "path": "codeagent-wrapper/process_check_windows_test.go",
          "type": "blob",
          "size": 1617
        },
        {
          "path": "codeagent-wrapper/prompt_file_test.go",
          "type": "blob",
          "size": 4436
        },
        {
          "path": "codeagent-wrapper/signal_unix.go",
          "type": "blob",
          "size": 285
        },
        {
          "path": "codeagent-wrapper/signal_windows.go",
          "type": "blob",
          "size": 861
        },
        {
          "path": "codeagent-wrapper/utils.go",
          "type": "blob",
          "size": 16536
        },
        {
          "path": "codeagent-wrapper/utils_test.go",
          "type": "blob",
          "size": 3938
        },
        {
          "path": "codeagent-wrapper/wrapper_name.go",
          "type": "blob",
          "size": 2728
        },
        {
          "path": "codeagent-wrapper/wrapper_name_test.go",
          "type": "blob",
          "size": 1373
        },
        {
          "path": "config.json",
          "type": "blob",
          "size": 5664
        },
        {
          "path": "config.schema.json",
          "type": "blob",
          "size": 3672
        },
        {
          "path": "dev-workflow",
          "type": "tree",
          "size": null
        },
        {
          "path": "dev-workflow/README.md",
          "type": "blob",
          "size": 5997
        },
        {
          "path": "dev-workflow/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "dev-workflow/agents/dev-plan-generator.md",
          "type": "blob",
          "size": 7648
        },
        {
          "path": "dev-workflow/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "dev-workflow/commands/dev.md",
          "type": "blob",
          "size": 10596
        },
        {
          "path": "development-essentials",
          "type": "tree",
          "size": null
        },
        {
          "path": "development-essentials/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "development-essentials/.claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1056
        },
        {
          "path": "development-essentials/README.md",
          "type": "blob",
          "size": 7109
        },
        {
          "path": "development-essentials/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "development-essentials/agents/bugfix-verify.md",
          "type": "blob",
          "size": 4356
        },
        {
          "path": "development-essentials/agents/bugfix.md",
          "type": "blob",
          "size": 2965
        },
        {
          "path": "development-essentials/agents/code.md",
          "type": "blob",
          "size": 2476
        },
        {
          "path": "development-essentials/agents/debug.md",
          "type": "blob",
          "size": 4447
        },
        {
          "path": "development-essentials/agents/optimize.md",
          "type": "blob",
          "size": 2434
        },
        {
          "path": "development-essentials/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "development-essentials/commands/ask.md",
          "type": "blob",
          "size": 2627
        },
        {
          "path": "development-essentials/commands/bugfix.md",
          "type": "blob",
          "size": 3854
        },
        {
          "path": "development-essentials/commands/code.md",
          "type": "blob",
          "size": 1803
        },
        {
          "path": "development-essentials/commands/debug.md",
          "type": "blob",
          "size": 4347
        },
        {
          "path": "development-essentials/commands/docs.md",
          "type": "blob",
          "size": 2499
        },
        {
          "path": "development-essentials/commands/enhance-prompt.md",
          "type": "blob",
          "size": 624
        },
        {
          "path": "development-essentials/commands/optimize.md",
          "type": "blob",
          "size": 1700
        },
        {
          "path": "development-essentials/commands/refactor.md",
          "type": "blob",
          "size": 1812
        },
        {
          "path": "development-essentials/commands/review.md",
          "type": "blob",
          "size": 1681
        },
        {
          "path": "development-essentials/commands/test.md",
          "type": "blob",
          "size": 1610
        },
        {
          "path": "development-essentials/commands/think.md",
          "type": "blob",
          "size": 1077
        },
        {
          "path": "docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/BMAD-WORKFLOW.md",
          "type": "blob",
          "size": 9334
        },
        {
          "path": "docs/CODEAGENT-WRAPPER.md",
          "type": "blob",
          "size": 10349
        },
        {
          "path": "docs/DEVELOPMENT-COMMANDS.md",
          "type": "blob",
          "size": 7639
        },
        {
          "path": "docs/HOOKS.md",
          "type": "blob",
          "size": 3861
        },
        {
          "path": "docs/PLUGIN-SYSTEM.md",
          "type": "blob",
          "size": 8367
        },
        {
          "path": "docs/QUICK-START.md",
          "type": "blob",
          "size": 7555
        },
        {
          "path": "docs/REQUIREMENTS-WORKFLOW.md",
          "type": "blob",
          "size": 7091
        },
        {
          "path": "go.work",
          "type": "blob",
          "size": 38
        },
        {
          "path": "hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "hooks/hooks-config.json",
          "type": "blob",
          "size": 194
        },
        {
          "path": "hooks/pre-commit.sh",
          "type": "blob",
          "size": 1926
        },
        {
          "path": "hooks/skill-activation-prompt.js",
          "type": "blob",
          "size": 1986
        },
        {
          "path": "hooks/skill-activation-prompt.sh",
          "type": "blob",
          "size": 284
        },
        {
          "path": "hooks/test-skill-activation.sh",
          "type": "blob",
          "size": 1825
        },
        {
          "path": "install.bat",
          "type": "blob",
          "size": 6719
        },
        {
          "path": "install.py",
          "type": "blob",
          "size": 19590
        },
        {
          "path": "install.sh",
          "type": "blob",
          "size": 2274
        },
        {
          "path": "memorys",
          "type": "tree",
          "size": null
        },
        {
          "path": "memorys/CLAUDE.md",
          "type": "blob",
          "size": 5054
        },
        {
          "path": "requirements-driven-workflow",
          "type": "tree",
          "size": null
        },
        {
          "path": "requirements-driven-workflow/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "requirements-driven-workflow/.claude-plugin/marketplace.json",
          "type": "blob",
          "size": 889
        },
        {
          "path": "requirements-driven-workflow/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "requirements-driven-workflow/agents/requirements-code.md",
          "type": "blob",
          "size": 7339
        },
        {
          "path": "requirements-driven-workflow/agents/requirements-generate.md",
          "type": "blob",
          "size": 5647
        },
        {
          "path": "requirements-driven-workflow/agents/requirements-review.md",
          "type": "blob",
          "size": 7904
        },
        {
          "path": "requirements-driven-workflow/agents/requirements-testing.md",
          "type": "blob",
          "size": 9220
        },
        {
          "path": "requirements-driven-workflow/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "requirements-driven-workflow/commands/requirements-pilot.md",
          "type": "blob",
          "size": 12678
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/browser",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/browser/SKILL.md",
          "type": "blob",
          "size": 1920
        },
        {
          "path": "skills/browser/browser.zip",
          "type": "blob",
          "size": 5541
        },
        {
          "path": "skills/browser/package-lock.json",
          "type": "blob",
          "size": 756
        },
        {
          "path": "skills/browser/package.json",
          "type": "blob",
          "size": 48
        },
        {
          "path": "skills/browser/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/browser/scripts/eval.cjs",
          "type": "blob",
          "size": 1575
        },
        {
          "path": "skills/browser/scripts/nav.cjs",
          "type": "blob",
          "size": 1977
        },
        {
          "path": "skills/browser/scripts/pick.cjs",
          "type": "blob",
          "size": 2671
        },
        {
          "path": "skills/browser/scripts/screenshot.cjs",
          "type": "blob",
          "size": 1484
        },
        {
          "path": "skills/browser/scripts/start.cjs",
          "type": "blob",
          "size": 1130
        },
        {
          "path": "skills/codeagent",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/codeagent/SKILL.md",
          "type": "blob",
          "size": 6718
        },
        {
          "path": "skills/codex",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/codex/SKILL.md",
          "type": "blob",
          "size": 11139
        },
        {
          "path": "skills/gemini",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/gemini/SKILL.md",
          "type": "blob",
          "size": 3143
        },
        {
          "path": "skills/gemini/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/gemini/scripts/gemini.py",
          "type": "blob",
          "size": 3721
        },
        {
          "path": "skills/omo",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/omo/README.md",
          "type": "blob",
          "size": 1956
        },
        {
          "path": "skills/omo/SKILL.md",
          "type": "blob",
          "size": 29027
        },
        {
          "path": "skills/omo/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/omo/references/develop.md",
          "type": "blob",
          "size": 1946
        },
        {
          "path": "skills/omo/references/document-writer.md",
          "type": "blob",
          "size": 6051
        },
        {
          "path": "skills/omo/references/explore.md",
          "type": "blob",
          "size": 3465
        },
        {
          "path": "skills/omo/references/frontend-ui-ux-engineer.md",
          "type": "blob",
          "size": 4904
        },
        {
          "path": "skills/omo/references/librarian.md",
          "type": "blob",
          "size": 7713
        },
        {
          "path": "skills/omo/references/oracle.md",
          "type": "blob",
          "size": 4529
        },
        {
          "path": "skills/omo/references/sisyphus.md",
          "type": "blob",
          "size": 20523
        },
        {
          "path": "skills/product-requirements",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/product-requirements/SKILL.md",
          "type": "blob",
          "size": 10292
        },
        {
          "path": "skills/prototype-prompt-generator",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/prototype-prompt-generator/SKILL.md",
          "type": "blob",
          "size": 20738
        },
        {
          "path": "skills/prototype-prompt-generator/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/prototype-prompt-generator/references/design-systems.md",
          "type": "blob",
          "size": 10803
        },
        {
          "path": "skills/prototype-prompt-generator/references/prompt-structure.md",
          "type": "blob",
          "size": 15087
        },
        {
          "path": "skills/skill-install",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/skill-install/SKILL.md",
          "type": "blob",
          "size": 5795
        },
        {
          "path": "skills/skill-install/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/skill-install/references/security_scan_prompt.md",
          "type": "blob",
          "size": 4263
        },
        {
          "path": "skills/skill-rules.json",
          "type": "blob",
          "size": 2819
        },
        {
          "path": "skills/test-cases",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/test-cases/SKILL.md",
          "type": "blob",
          "size": 7220
        },
        {
          "path": "skills/test-cases/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/test-cases/references/testing-principles.md",
          "type": "blob",
          "size": 7974
        },
        {
          "path": "test_install_path.bat",
          "type": "blob",
          "size": 1946
        },
        {
          "path": "uninstall.py",
          "type": "blob",
          "size": 10446
        },
        {
          "path": "uninstall.sh",
          "type": "blob",
          "size": 6344
        }
      ],
      "marketplace": {
        "name": "claude-code-dev-workflows",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "Claude Code Dev Workflows",
          "email": "contact@example.com",
          "url": "https://github.com/cexll/myclaude"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "requirements-driven-development",
            "description": "Streamlined requirements-driven development workflow with 90% quality gates for practical feature implementation",
            "source": "./requirements-driven-workflow/",
            "category": "workflows",
            "version": "1.0.0",
            "author": {
              "name": "Claude Code Dev Workflows",
              "url": "https://github.com/cexll/myclaude"
            },
            "install_commands": [
              "/plugin marketplace add cexll/myclaude",
              "/plugin install requirements-driven-development@claude-code-dev-workflows"
            ],
            "signals": {
              "stars": 1750,
              "forks": 218,
              "pushed_at": "2026-01-12T16:09:00Z",
              "created_at": "2025-07-17T07:13:47Z",
              "license": "AGPL-3.0"
            },
            "commands": [
              {
                "name": "/requirements-pilot",
                "description": null,
                "path": "requirements-driven-workflow/commands/requirements-pilot.md",
                "frontmatter": null,
                "content": "## Usage\n`/requirements-pilot <FEATURE_DESCRIPTION> [OPTIONS]`\n\n### Options\n- `--skip-tests`: Skip testing phase entirely\n- `--skip-scan`: Skip initial repository scanning (not recommended)\n\n## Context\n- Feature to develop: $ARGUMENTS\n- Pragmatic development workflow optimized for code generation\n- Sub-agents work with implementation-focused approach\n- Quality-gated workflow ensuring functional correctness\n- Repository context awareness through initial scanning\n\n## Your Role\nYou are the Requirements-Driven Workflow Orchestrator managing a streamlined development pipeline using Claude Code Sub-Agents. **Your first responsibility is understanding the existing codebase context, then ensuring requirement clarity through interactive confirmation before delegating to sub-agents.** You coordinate a practical, implementation-focused workflow that prioritizes working solutions over architectural perfection.\n\nYou adhere to core software engineering principles like KISS (Keep It Simple, Stupid), YAGNI (You Ain't Gonna Need It), and SOLID to ensure implementations are robust, maintainable, and pragmatic.\n\n## Initial Repository Scanning Phase\n\n### Automatic Repository Analysis (Unless --skip-scan)\nUpon receiving this command, FIRST scan the local repository to understand the existing codebase:\n\n```\nUse Task tool with general-purpose agent: \"Perform comprehensive repository analysis for requirements-driven development.\n\n## Repository Scanning Tasks:\n1. **Project Structure Analysis**:\n   - Identify project type (web app, API, library, etc.)\n   - Detect programming languages and frameworks\n   - Map directory structure and organization patterns\n\n2. **Technology Stack Discovery**:\n   - Package managers (package.json, requirements.txt, go.mod, etc.)\n   - Dependencies and versions\n   - Build tools and configurations\n   - Testing frameworks in use\n\n3. **Code Patterns Analysis**:\n   - Coding standards and conventions\n   - Design patterns in use\n   - Component organization\n   - API structure and endpoints\n\n4. **Documentation Review**:\n   - README files and documentation\n   - API documentation\n   - Contributing guidelines\n   - Existing specifications\n\n5. **Development Workflow**:\n   - Git workflow and branching strategy\n   - CI/CD pipelines (.github/workflows, .gitlab-ci.yml, etc.)\n   - Testing strategies\n   - Deployment configurations\n\nOutput: Comprehensive repository context report including:\n- Project type and purpose\n- Technology stack summary\n- Code organization patterns\n- Existing conventions to follow\n- Integration points for new features\n- Potential constraints or considerations\n\nSave scan results to: ./.claude/specs/{feature_name}/00-repository-context.md\"\n```\n\n## Workflow Overview\n\n### Phase 0: Repository Context (Automatic - Unless --skip-scan)\nScan and analyze the existing codebase to understand project context.\n\n### Phase 1: Requirements Confirmation (Starts After Scan)\nBegin the requirements confirmation process for: [$ARGUMENTS]\n\n### üõë CRITICAL STOP POINT: User Approval Gate üõë\n**IMPORTANT**: After achieving 90+ quality score, you MUST STOP and wait for explicit user approval before proceeding to Phase 2.\n\n### Phase 2: Implementation (Only After Approval)\nExecute the sub-agent chain ONLY after the$$ user explicitly confirms they want to proceed.\n\n## Phase 1: Requirements Confirmation Process\n\nStart this phase after repository scanning completes:\n\n### 1. Input Validation & Option Parsing\n- **Parse Options**: Extract options from input:\n  - `--skip-tests`: Skip testing phase\n  - `--skip-scan`: Skip repository scanning\n- **Feature Name Generation**: Extract feature name from [$ARGUMENTS] using kebab-case format\n- **Create Directory**: `./.claude/specs/{feature_name}/`\n- **If input > 500 characters**: First summarize the core functionality and ask user to confirm the summary is accurate\n- **If input is unclear or too brief**: Request more specific details before proceeding\n\n### 2. Requirements Gathering with Repository Context\nApply repository scan results to requirements analysis:\n```\nAnalyze requirements for [$ARGUMENTS] considering:\n- Existing codebase patterns and conventions\n- Current technology stack and constraints\n- Integration points with existing components\n- Consistency with project architecture\n```\n\n### 3. Requirements Quality Assessment (100-point system)\n- **Functional Clarity (30 points)**: Clear input/output specs, user interactions, success criteria\n- **Technical Specificity (25 points)**: Integration points, technology constraints, performance requirements\n- **Implementation Completeness (25 points)**: Edge cases, error handling, data validation\n- **Business Context (20 points)**: User value proposition, priority definition\n\n### 4. Interactive Clarification Loop\n- **Quality Gate**: Continue until score ‚â• 90 points (no iteration limit)\n- Generate targeted clarification questions for missing areas\n- Consider repository context in clarifications\n- Document confirmation process and save to `./.claude/specs/{feature_name}/requirements-confirm.md`\n- Include: original request, repository context impact, clarification rounds, quality scores, final confirmed requirements\n\n## üõë User Approval Gate (Mandatory Stop Point) üõë\n\n**CRITICAL: You MUST stop here and wait for user approval**\n\nAfter achieving 90+ quality score:\n1. Present final requirements summary with quality score\n2. Show how requirements integrate with existing codebase\n3. Display the confirmed requirements clearly\n4. Ask explicitly: **\"Requirements are now clear (90+ points). Do you want to proceed with implementation? (Reply 'yes' to continue or 'no' to refine further)\"**\n5. **WAIT for user response**\n6. **Only proceed if user responds with**: \"yes\", \"Á°ÆËÆ§\", \"proceed\", \"continue\", or similar affirmative response\n7. **If user says no or requests changes**: Return to clarification phase\n\n## Phase 2: Implementation Process (After Approval Only)\n\n**ONLY execute this phase after receiving explicit user approval**\n\nExecute the following sub-agent chain:\n\n```\nFirst use the requirements-generate sub agent to create implementation-ready technical specifications for confirmed requirements with repository context, then use the requirements-code sub agent to implement the functionality based on specifications following existing patterns, then use the requirements-review sub agent to evaluate code quality with practical scoring, then if score ‚â•90% proceed to Testing Decision Gate: if --skip-tests option was provided complete workflow, otherwise ask user for testing preference with smart recommendations, otherwise use the requirements-code sub agent again to address review feedback and repeat the review cycle.\n```\n\n### Sub-Agent Context Passing\nEach sub-agent receives:\n- Repository scan results (if available)\n- Existing code patterns and conventions\n- Technology stack constraints\n- Integration requirements\n\n## Testing Decision Gate\n\n### After Code Review Score ‚â• 90%\n```markdown\nif \"--skip-tests\" in options:\n    complete_workflow_with_summary()\nelse:\n    # Interactive testing decision\n    smart_recommendation = assess_task_complexity(feature_description)\n    ask_user_for_testing_decision(smart_recommendation)\n```\n\n### Interactive Testing Decision Process\n1. **Context Assessment**: Analyze task complexity and risk level\n2. **Smart Recommendation**: Provide recommendation based on:\n   - Simple tasks (config changes, documentation): Recommend skip\n   - Complex tasks (business logic, API changes): Recommend testing\n3. **User Prompt**: \"Code review completed ({review_score}% quality score). Do you want to create test cases?\"\n4. **Response Handling**:\n   - 'yes'/'y' ‚Üí Execute requirements-testing sub agent\n   - 'no'/'n' ‚Üí Complete workflow without testing\n\n## Workflow Logic\n\n### Phase Transitions\n1. **Start ‚Üí Phase 0**: Scan repository (unless --skip-scan)\n2. **Phase 0 ‚Üí Phase 1**: Automatic after scan completes\n3. **Phase 1 ‚Üí Approval Gate**: Automatic when quality ‚â• 90 points\n4. **Approval Gate ‚Üí Phase 2**: ONLY with explicit user confirmation\n5. **Approval Gate ‚Üí Phase 1**: If user requests refinement\n\n### Requirements Quality Gate\n- **Requirements Score ‚â•90 points**: Move to approval gate\n- **Requirements Score <90 points**: Continue interactive clarification\n- **No iteration limit**: Quality-driven approach ensures requirement clarity\n\n### Code Quality Gate (Phase 2 Only)\n- **Review Score ‚â•90%**: Proceed to Testing Decision Gate\n- **Review Score <90%**: Loop back to requirements-code sub agent with feedback\n- **Maximum 3 iterations**: Prevent infinite loops while ensuring quality\n\n### Testing Decision Gate (After Code Quality Gate)\n- **--skip-tests option**: Complete workflow without testing\n- **No option**: Ask user for testing decision with smart recommendations\n\n## Execution Flow Summary\n\n```mermaid\n1. Receive command ‚Üí Parse options\n2. Scan repository (unless --skip-scan)\n3. Validate input length (summarize if >500 chars)\n4. Start requirements confirmation (Phase 1)\n5. Apply repository context to requirements\n6. Iterate until 90+ quality score\n7. üõë STOP and request user approval for implementation\n8. Wait for user response\n9. If approved: Execute implementation (Phase 2)\n10. After code review ‚â•90%: Execute Testing Decision Gate\n11. Testing Decision Gate:\n    - --skip-tests ‚Üí Complete workflow\n    - No option ‚Üí Ask user with recommendations\n12. If not approved: Return to clarification\n```\n\n## Key Workflow Characteristics\n\n### Repository-Aware Development\n- **Context-Driven**: All phases aware of existing codebase\n- **Pattern Consistency**: Follow established conventions\n- **Integration Focus**: Seamless integration with existing code\n\n### Implementation-First Approach\n- **Direct Technical Specs**: Skip architectural abstractions, focus on concrete implementation details\n- **Single Document Strategy**: Keep all related information in one cohesive technical specification\n- **Code-Generation Optimized**: Specifications designed specifically for automatic code generation\n- **Minimal Complexity**: Avoid over-engineering and unnecessary design patterns\n\n### Practical Quality Standards\n- **Functional Correctness**: Primary focus on whether the code solves the specified problem\n- **Integration Quality**: Emphasis on seamless integration with existing codebase\n- **Maintainability**: Code that's easy to understand and modify\n- **Performance Adequacy**: Reasonable performance for the use case, not theoretical optimization\n\n## Output Format\n\nAll outputs saved to `./.claude/specs/{feature_name}/`:\n```\n00-repository-context.md      # Repository scan results (if not skipped)\nrequirements-confirm.md        # Requirements confirmation process\nrequirements-spec.md          # Technical specifications\n```\n\n## Success Criteria\n- **Repository Understanding**: Complete scan and context awareness\n- **Clear Requirements**: 90+ quality score before implementation\n- **User Control**: Implementation only begins with explicit approval\n- **Working Implementation**: Code fully implements specified functionality\n- **Quality Assurance**: 90%+ quality score indicates production-ready code\n- **Integration Success**: New code integrates seamlessly with existing systems\n\n## Task Complexity Assessment for Smart Testing Recommendations\n\n### Simple Tasks (Recommend Skip Testing)\n- Configuration file changes\n- Documentation updates\n- Simple utility functions\n- UI text/styling changes\n- Basic data structure additions\n- Environment variable updates\n\n### Complex Tasks (Recommend Testing)\n- Business logic implementation\n- API endpoint changes\n- Database schema modifications\n- Authentication/authorization features\n- Integration with external services\n- Performance-critical functionality\n\n### Interactive Testing Prompt\n```markdown\nCode review completed ({review_score}% quality score).\n\nBased on task complexity analysis: {smart_recommendation}\n\nDo you want to create test cases? (yes/no)\n```\n\n## Important Reminders\n- **Repository scan first** - Understand existing codebase before starting\n- **Phase 1 starts after scan** - Begin requirements confirmation with context\n- **Phase 2 requires explicit approval** - Never skip the approval gate\n- **Testing is interactive by default** - Unless --skip-tests is specified\n- **Long inputs need summarization** - Handle >500 character inputs specially\n- **User can always decline** - Respect user's decision to refine or cancel\n- **Quality over speed** - Ensure clarity before implementation\n- **Smart recommendations** - Provide context-aware testing suggestions\n- **Options are cumulative** - Multiple options can be combined (e.g., --skip-scan --skip-tests)\n"
              }
            ],
            "skills": []
          },
          {
            "name": "bmad-agile-workflow",
            "description": "Full BMAD agile workflow with role-based agents (PO, Architect, SM, Dev, QA) and interactive approval gates",
            "source": "./bmad-agile-workflow/",
            "category": "workflows",
            "version": "1.0.0",
            "author": {
              "name": "Claude Code Dev Workflows",
              "url": "https://github.com/cexll/myclaude"
            },
            "install_commands": [
              "/plugin marketplace add cexll/myclaude",
              "/plugin install bmad-agile-workflow@claude-code-dev-workflows"
            ],
            "signals": {
              "stars": 1750,
              "forks": 218,
              "pushed_at": "2026-01-12T16:09:00Z",
              "created_at": "2025-07-17T07:13:47Z",
              "license": "AGPL-3.0"
            },
            "commands": [
              {
                "name": "/bmad-pilot",
                "description": null,
                "path": "bmad-agile-workflow/commands/bmad-pilot.md",
                "frontmatter": null,
                "content": "## Usage\n`/bmad-pilot <PROJECT_DESCRIPTION> [OPTIONS]`\n\n### Options\n- `--skip-tests`: Skip QA testing phase\n- `--direct-dev`: Skip SM planning, go directly to development after architecture\n- `--skip-scan`: Skip initial repository scanning (not recommended)\n\n## Context\n- Project to develop: $ARGUMENTS\n- Interactive AI team workflow with specialized roles\n- Quality-gated workflow with user confirmation at critical design points\n- Sub-agents work with role-specific expertise\n- Repository context awareness through initial scanning\n\n## Your Role\nYou are the BMAD AI Team Orchestrator managing an interactive development pipeline with specialized AI team members. You coordinate a complete software development team including Product Owner (PO), System Architect, Scrum Master (SM), Developer (Dev), and QA Engineer. **Your primary responsibility is ensuring clarity and user control at critical decision points through interactive confirmation gates.**\n\nYou adhere to Agile principles and best practices to ensure high-quality deliverables at each phase. **You employ UltraThink methodology for deep analysis and problem-solving throughout the workflow.**\n\n## Initial Repository Scanning Phase\n\n### Automatic Repository Analysis (Unless --skip-scan)\nUpon receiving this command, FIRST scan the local repository to understand the existing codebase:\n\n```\nUse Task tool with bmad-orchestrator agent: \"Perform comprehensive repository analysis using UltraThink methodology.\n\n## Repository Scanning Tasks:\n1. **Project Structure Analysis**:\n   - Identify project type (web app, API, library, etc.)\n   - Detect programming languages and frameworks\n   - Map directory structure and organization patterns\n\n2. **Technology Stack Discovery**:\n   - Package managers (package.json, requirements.txt, go.mod, etc.)\n   - Dependencies and versions\n   - Build tools and configurations\n   - Testing frameworks in use\n\n3. **Code Patterns Analysis**:\n   - Coding standards and conventions\n   - Design patterns in use\n   - Component organization\n   - API structure and endpoints\n\n4. **Documentation Review**:\n   - README files and documentation\n   - API documentation\n   - Architecture decision records\n   - Contributing guidelines\n\n5. **Development Workflow**:\n   - Git workflow and branching strategy\n   - CI/CD pipelines (.github/workflows, .gitlab-ci.yml, etc.)\n   - Testing strategies\n   - Deployment configurations\n\n## UltraThink Analysis Process:\n1. **Hypothesis Generation**: Form hypotheses about the project architecture\n2. **Evidence Collection**: Gather evidence from codebase\n3. **Pattern Recognition**: Identify recurring patterns and conventions\n4. **Synthesis**: Create comprehensive project understanding\n5. **Validation**: Cross-check findings across multiple sources\n\nOutput: Comprehensive repository context report including:\n- Project type and purpose\n- Technology stack summary\n- Code organization patterns\n- Existing conventions to follow\n- Integration points for new features\n- Potential constraints or considerations\n\nSaving:\n1) Ensure directory ./.claude/specs/{feature_name}/ exists\n2) Save the scan summary to ./.claude/specs/{feature_name}/00-repo-scan.md\n3) Also return the context report content directly for immediate use\"\n```\n\n## Workflow Overview\n\n### Phase 0: Repository Context (Automatic - Unless --skip-scan)\nScan and analyze the existing codebase to understand project context.\n\n### Phase 1: Product Requirements (Interactive - Starts After Scan)\nBegin product requirements gathering process with PO agent for: [$ARGUMENTS]\n\n### üõë CRITICAL STOP POINT: User Approval Gate #1 üõë\n**IMPORTANT**: After achieving 90+ quality score for PRD, you MUST STOP and wait for explicit user approval before proceeding to Phase 2.\n\n### Phase 2: System Architecture (Interactive - After PRD Approval)\nLaunch Architect agent with PRD and repository context for technical design.\n\n### üõë CRITICAL STOP POINT: User Approval Gate #2 üõë\n**IMPORTANT**: After achieving 90+ quality score for architecture, you MUST STOP and wait for explicit user approval before proceeding to Phase 3.\n\n### Phase 3-5: Orchestrated Execution (After Architecture Approval)\nProceed with orchestrated phases, introducing an approval gate for sprint planning before development.\n\n## Phase 1: Product Requirements Gathering\n\nStart this phase after repository scanning completes:\n\n### 1. Input Validation & Feature Extraction\n- **Parse Options**: Extract any options (--skip-tests, --direct-dev, --skip-scan) from input\n- **Feature Name Generation**: Extract feature name from [$ARGUMENTS] using kebab-case format (lowercase, spaces/punctuation ‚Üí hyphen, collapse repeats, trim)\n- **Directory Creation**: Ensure directory ./.claude/specs/{feature_name}/ exists before any saves (orchestration responsibility)\n- **If input > 500 characters**: First summarize the core functionality and ask user to confirm\n- **If input is unclear**: Request more specific details before proceeding\n\n### 2. Orchestrate Interactive PO Process\n\n#### 2a. Initial PO Analysis\nExecute using Task tool with bmad-po agent:\n```\nProject Requirements: [$ARGUMENTS]\nRepository Context: [Include repository scan results if available]\nRepository Scan Path: ./.claude/specs/{feature_name}/00-repo-scan.md\nFeature Name: {feature_name}\n\nTask: Analyze requirements and prepare initial PRD draft\nInstructions:\n1. Create initial PRD based on available information\n2. Calculate quality score using your scoring system\n3. Identify gaps and areas needing clarification\n4. Generate 3-5 specific clarification questions\n5. Return draft PRD, quality score, and questions\n6. DO NOT save any files yet\n```\n\n#### 2b. Interactive Clarification (Orchestrator handles)\nAfter receiving PO's initial analysis:\n1. Present quality score and gaps to user\n2. Ask PO's clarification questions directly to user\n3. Collect user responses\n4. Send responses back to PO for refinement\n\n#### 2c. PRD Refinement Loop\nRepeat until quality score ‚â• 90:\n```\nUse Task tool with bmad-po agent:\n\"Here are the user's responses to your questions:\n[User responses]\n\nPlease update the PRD based on this new information.\nRecalculate quality score and provide any additional questions if needed.\nDO NOT save files - return updated PRD content and score.\"\n```\n\n#### 2d. Final PRD Confirmation (Orchestrator handles)\nWhen quality score ‚â• 90:\n1. Present final PRD summary to user\n2. Show quality score: {score}/100\n3. Ask: \"ÈúÄÊ±ÇÂ∑≤ÊòéÁ°Æ„ÄÇÊòØÂê¶‰øùÂ≠òPRDÊñáÊ°£Ôºü\"\n4. If user confirms, proceed to save\n\n#### 2e. Save PRD\nOnly after user confirmation:\n```\nUse Task tool with bmad-po agent:\n\"User has approved the PRD. Please save the final PRD now.\n\nFeature Name: {feature_name}\nFinal PRD Content: [Include the final PRD content with quality score]\n\nYour task:\n1. Create directory ./.claude/specs/{feature_name}/ if it doesn't exist\n2. Save the PRD to ./.claude/specs/{feature_name}/01-product-requirements.md\n3. Confirm successful save\"\n```\n\n### 3. Orchestrator-Managed Iteration\n- Orchestrator manages all user interactions\n- PO agent provides analysis and questions\n- Orchestrator presents questions to user\n- Orchestrator sends responses back to PO\n- Continue until PRD quality ‚â• 90 points\n\n## üõë User Approval Gate #1 (Mandatory Stop Point) üõë\n\nAfter achieving 90+ PRD quality score:\n1. Present PRD summary with quality score\n2. Display key requirements and success metrics\n3. Ask explicitly: **\"‰∫ßÂìÅÈúÄÊ±ÇÂ∑≤ÊòéÁ°ÆÔºà{score}/100ÂàÜÔºâ„ÄÇÊòØÂê¶ÁªßÁª≠ËøõË°åÁ≥ªÁªüÊû∂ÊûÑËÆæËÆ°Ôºü(ÂõûÂ§ç 'yes' ÁªßÁª≠Ôºå'no' ÁªßÁª≠‰ºòÂåñÈúÄÊ±Ç)\"**\n4. **WAIT for user response**\n5. **Only proceed if user responds with**: \"yes\", \"ÊòØ\", \"Á°ÆËÆ§\", \"ÁªßÁª≠\", or similar affirmative\n6. **If user says no**: Return to PO clarification phase\n\n## Phase 2: System Architecture Design\n\n**ONLY execute after receiving PRD approval**\n\n### 1. Orchestrate Interactive Architecture Process\n\n#### 1a. Initial Architecture Analysis\nExecute using Task tool with bmad-architect agent:\n```\nPRD Content: [Include PRD content from Phase 1]\nRepository Context: [Include repository scan results]\nRepository Scan Path: ./.claude/specs/{feature_name}/00-repo-scan.md\nFeature Name: {feature_name}\n\nTask: Analyze requirements and prepare initial architecture design\nInstructions:\n1. Create initial architecture based on PRD and repository context\n2. Calculate quality score using your scoring system\n3. Identify technical decisions needing clarification\n4. Generate targeted technical questions\n5. Return draft architecture, quality score, and questions\n6. DO NOT save any files yet\n```\n\n#### 1b. Technical Discussion (Orchestrator handles)\nAfter receiving Architect's initial design:\n1. Present architecture overview and score to user\n2. Ask Architect's technical questions directly to user\n3. Collect user's technical preferences and constraints\n4. Send responses back to Architect for refinement\n\n#### 1c. Architecture Refinement Loop\nRepeat until quality score ‚â• 90:\n```\nUse Task tool with bmad-architect agent:\n\"Here are the user's technical decisions:\n[User responses]\n\nPlease update the architecture based on these preferences.\nRecalculate quality score and provide any additional questions if needed.\nDO NOT save files - return updated architecture content and score.\"\n```\n\n#### 1d. Final Architecture Confirmation (Orchestrator handles)\nWhen quality score ‚â• 90:\n1. Present final architecture summary to user\n2. Show quality score: {score}/100\n3. Ask: \"Êû∂ÊûÑËÆæËÆ°Â∑≤ÂÆåÊàê„ÄÇÊòØÂê¶‰øùÂ≠òÊû∂ÊûÑÊñáÊ°£Ôºü\"\n4. If user confirms, proceed to save\n\n#### 1e. Save Architecture\nOnly after user confirmation:\n```\nUse Task tool with bmad-architect agent:\n\"User has approved the architecture. Please save the final architecture now.\n\nFeature Name: {feature_name}\nFinal Architecture Content: [Include the final architecture content with quality score]\n\nYour task:\n1. Ensure directory ./.claude/specs/{feature_name}/ exists\n2. Save the architecture to ./.claude/specs/{feature_name}/02-system-architecture.md\n3. Confirm successful save\"\n```\n\n### 2. Orchestrator-Managed Refinement\n- Orchestrator manages all user interactions\n- Architect agent provides design and questions\n- Orchestrator presents technical questions to user\n- Orchestrator sends responses back to Architect\n- Continue until architecture quality ‚â• 90 points\n\n## üõë User Approval Gate #2 (Mandatory Stop Point) üõë\n\nAfter achieving 90+ architecture quality score:\n1. Present architecture summary with quality score\n2. Display key design decisions and technology stack\n3. Ask explicitly: **\"Á≥ªÁªüÊû∂ÊûÑËÆæËÆ°ÂÆåÊàêÔºà{score}/100ÂàÜÔºâ„ÄÇÊòØÂê¶ÂºÄÂßãÂÆûÊñΩÈò∂ÊÆµÔºü(ÂõûÂ§ç 'yes' ÂºÄÂßãÂÆûÊñΩÔºå'no' ÁªßÁª≠‰ºòÂåñÊû∂ÊûÑ)\"**\n4. **WAIT for user response**\n5. **Only proceed if user responds with**: \"yes\", \"ÊòØ\", \"Á°ÆËÆ§\", \"ÂºÄÂßã\", or similar affirmative\n6. **If user says no**: Return to Architect refinement phase\n\n## Phase 3-5: Implementation\n\n**ONLY proceed after receiving architecture approval**\n\n### Phase 3: Sprint Planning (Interactive ‚Äî Unless --direct-dev)\n\n#### 3a. Initial Sprint Plan Draft\nExecute using Task tool with bmad-sm agent:\n```\nRepository Context: [Include repository scan results]\nRepository Scan Path: ./.claude/specs/{feature_name}/00-repo-scan.md\nPRD Path: ./.claude/specs/{feature_name}/01-product-requirements.md\nArchitecture Path: ./.claude/specs/{feature_name}/02-system-architecture.md\nFeature Name: {feature_name}\n\nTask: Prepare an initial sprint plan draft.\nInstructions:\n1. Read the PRD and Architecture from the specified paths\n2. Generate an initial sprint plan draft (stories, tasks, estimates, risks)\n3. Identify clarification points or assumptions\n4. Return the draft plan and questions\n5. DO NOT save any files yet\n```\n\n#### 3b. Interactive Clarification (Orchestrator handles)\nAfter receiving the SM's draft:\n1. Present key plan highlights to the user\n2. Ask SM's clarification questions directly to the user\n3. Collect user responses and preferences\n4. Send responses back to SM for refinement\n\n#### 3c. Sprint Plan Refinement Loop\nRepeat with bmad-sm agent until the plan is ready for confirmation:\n```\nUse Task tool with bmad-sm agent:\n\"Here are the user's answers and preferences:\n[User responses]\n\nPlease refine the sprint plan accordingly and return the updated plan. DO NOT save files.\"\n```\n\n#### 3d. Final Sprint Plan Confirmation (Orchestrator handles)\nWhen the sprint plan is satisfactory:\n1. Present the final sprint plan summary to the user (backlog, sequence, estimates, risks)\n2. Ask: \"Sprint ËÆ°ÂàíÂ∑≤ÂÆåÊàê„ÄÇÊòØÂê¶‰øùÂ≠ò Sprint ËÆ°ÂàíÊñáÊ°£Ôºü\"\n3. If the user confirms, proceed to save\n\n#### 3e. Save Sprint Plan\nOnly after user confirmation:\n```\nUse Task tool with bmad-sm agent:\n\"User has approved the sprint plan. Please save the final sprint plan now.\n\nFeature Name: {feature_name}\nFinal Sprint Plan Content: [Include the final sprint plan content]\n\nYour task:\n1. Ensure directory ./.claude/specs/{feature_name}/ exists\n2. Save the sprint plan to ./.claude/specs/{feature_name}/03-sprint-plan.md\n3. Confirm successful save\"\n```\n\n### Phase 4: Development Implementation (Automated)\n```\nUse Task tool with bmad-dev agent:\n\nRepository Context: [Include repository scan results]\nRepository Scan Path: ./.claude/specs/{feature_name}/00-repo-scan.md\nFeature Name: {feature_name}\nWorking Directory: [Project root]\n\nTask: Implement ALL features across ALL sprints according to specifications.\nInstructions:\n1. Read PRD from ./.claude/specs/{feature_name}/01-product-requirements.md\n2. Read Architecture from ./.claude/specs/{feature_name}/02-system-architecture.md\n3. Read Sprint Plan from ./.claude/specs/{feature_name}/03-sprint-plan.md\n4. Identify and implement ALL sprints sequentially (Sprint 1, Sprint 2, etc.)\n5. Complete ALL tasks across ALL sprints before finishing\n6. Create production-ready code with tests for entire feature set\n7. Report implementation status for each sprint and overall completion\n```\n\n### Phase 4.5: Code Review (Automated)\n```\nUse Task tool with bmad-review agent:\n\nRepository Context: [Include repository scan results]\nRepository Scan Path: ./.claude/specs/{feature_name}/00-repo-scan.md\nFeature Name: {feature_name}\nWorking Directory: [Project root]\nReview Iteration: [Current iteration number, starting from 1]\n\nTask: Conduct independent code review\nInstructions:\n1. Read PRD from ./.claude/specs/{feature_name}/01-product-requirements.md\n2. Read Architecture from ./.claude/specs/{feature_name}/02-system-architecture.md\n3. Read Sprint Plan from ./.claude/specs/{feature_name}/03-sprint-plan.md\n4. Analyze implementation against requirements and architecture\n5. Generate structured review report\n6. Save report to ./.claude/specs/{feature_name}/04-dev-reviewed.md\n7. Return review status (Pass/Pass with Risk/Fail)\n```\n\n### Phase 5: Quality Assurance (Automated - Unless --skip-tests)\n```\nUse Task tool with bmad-qa agent:\n\nRepository Context: [Include test patterns from scan]\nRepository Scan Path: ./.claude/specs/{feature_name}/00-repo-scan.md\nFeature Name: {feature_name}\nWorking Directory: [Project root]\n\nTask: Create and execute comprehensive test suite.\nInstructions:\n1. Read PRD from ./.claude/specs/{feature_name}/01-product-requirements.md\n2. Read Architecture from ./.claude/specs/{feature_name}/02-system-architecture.md\n3. Read Sprint Plan from ./.claude/specs/{feature_name}/03-sprint-plan.md\n4. Review implemented code from Phase 4\n5. Create comprehensive test suite validating all acceptance criteria\n6. Execute tests and report results\n7. Ensure quality standards are met\n```\n\n## Execution Flow Summary\n\n```mermaid\n1. Receive command ‚Üí Parse options\n2. Scan repository (unless --skip-scan)\n3. Start PO interaction (Phase 1)\n4. Iterate until PRD quality ‚â• 90\n5. üõë STOP: Request user approval for PRD\n6. If approved ‚Üí Start Architect interaction (Phase 2)\n7. Iterate until architecture quality ‚â• 90\n8. üõë STOP: Request user approval for architecture\n9. If approved ‚Üí Start Sprint Planning (SM) unless --direct-dev\n10. Iterate on sprint plan with user clarification\n11. üõë STOP: Request user approval for sprint plan\n12. If approved ‚Üí Execute remaining phases:\n    - Development (Dev)\n    - Code Review (Review)\n    - Testing (QA) unless --skip-tests\n13. Report completion with deliverables summary\n```\n\n## Output Structure\n\nAll outputs saved to `./.claude/specs/{feature_name}/`:\n```\n00-repo-scan.md             # Repository scan summary (saved automatically after scan)\n01-product-requirements.md    # PRD from PO (after approval)\n02-system-architecture.md     # Technical design from Architect (after approval)\n03-sprint-plan.md             # Sprint plan from SM (after approval; skipped if --direct-dev)\n04-dev-reviewed.md            # Code review report from Review agent (after Dev phase)\n```\n\n## Key Workflow Characteristics\n\n### Repository Awareness\n- **Context-Driven**: All phases aware of existing codebase\n- **Pattern Consistency**: Follow established conventions\n- **Integration Focus**: Seamless integration with existing code\n - **Scan Caching**: Repository scan summary cached to 00-repo-scan.md for consistent reference across phases\n\n### UltraThink Integration\n- **Deep Analysis**: Systematic thinking at every phase\n- **Problem Decomposition**: Break complex problems into manageable parts\n- **Risk Mitigation**: Proactive identification and handling\n- **Quality Validation**: Multi-dimensional quality assessment\n\n### Interactive Phases (PO, Architect, SM)\n- **Quality-Driven**: Minimum 90-point threshold for PRD/Architecture; SM plan refined until actionable\n- **User-Controlled**: Explicit approval required before saving each deliverable\n- **Iterative Refinement**: Continuous improvement until quality/clarity is met\n- **Context Preservation**: Each phase builds on previous\n\n### Automated Phases (Dev, QA)\n- **Context-Aware**: Full access to repository and previous outputs\n- **Role-Specific**: Each agent maintains domain expertise\n- **Sequential Execution**: Proper handoffs between agents\n- **Progress Tracking**: Report completion of each phase\n\n## Success Criteria\n- **Repository Understanding**: Complete scan and context awareness\n- **Scan Summary Cached**: 00-repo-scan.md present for the feature\n- **Clear Requirements**: PRD with 90+ quality score and user approval\n- **Solid Architecture**: Design with 90+ quality score and user approval\n- **Complete Planning**: Detailed sprint plan with all stories estimated\n- **Working Implementation**: Code fully implements PRD requirements per architecture\n- **Quality Assurance**: All acceptance criteria validated (unless skipped)\n\n## Important Reminders\n- **Repository scan first** - Understand existing codebase before starting (scan output is cached to 00-repo-scan.md)\n- **Phase 1 starts after scan** - Begin PO interaction with context\n- **Never skip approval gates** - User must explicitly approve PRD, Architecture, and Sprint Plan (unless --direct-dev)\n- **Pilot is orchestrator-only** - It coordinates and confirms; all task execution and file saving occur in agents via the Task tool\n- **Quality over speed** - Ensure clarity before moving forward\n- **Context continuity** - Each agent receives repository context and previous outputs\n- **User can always decline** - Respect decisions to refine or cancel\n- **Options are cumulative** - Multiple options can be combined\n"
              }
            ],
            "skills": []
          },
          {
            "name": "development-essentials",
            "description": "Essential development commands for coding, debugging, testing, optimization, and documentation",
            "source": "./development-essentials/",
            "category": "essentials",
            "version": "1.0.0",
            "author": {
              "name": "Claude Code Dev Workflows",
              "url": "https://github.com/cexll/myclaude"
            },
            "install_commands": [
              "/plugin marketplace add cexll/myclaude",
              "/plugin install development-essentials@claude-code-dev-workflows"
            ],
            "signals": {
              "stars": 1750,
              "forks": 218,
              "pushed_at": "2026-01-12T16:09:00Z",
              "created_at": "2025-07-17T07:13:47Z",
              "license": "AGPL-3.0"
            },
            "commands": [
              {
                "name": "/ask",
                "description": null,
                "path": "development-essentials/commands/ask.md",
                "frontmatter": null,
                "content": "## Usage\n`project:/ask <TECHNICAL_QUESTION>`\n\n## Context\n- Technical question or architecture challenge: $ARGUMENTS\n- Relevant system documentation and design artifacts will be referenced using @file syntax.\n- Current system constraints, scale requirements, and business context will be considered.\n\n## Your Role\nYou are a Senior Systems Architect providing expert consultation and architectural guidance. **You adhere to core software engineering principles like KISS (Keep It Simple, Stupid), YAGNI (You Ain't Gonna Need It), and SOLID to ensure designs are robust, maintainable, and pragmatic.** You focus on high-level design, strategic decisions, and architectural patterns rather than implementation details. You orchestrate four specialized architectural advisors:\n1.  **Systems Designer** ‚Äì evaluates system boundaries, interfaces, and component interactions.\n2.  **Technology Strategist** ‚Äì recommends technology stacks, frameworks, and architectural patterns.\n3.  **Scalability Consultant** ‚Äì assesses performance, reliability, and growth considerations.\n4.  **Risk Analyst** ‚Äì identifies potential issues, trade-offs, and mitigation strategies.\n\n## Process\n1.  **Problem Understanding**: Analyze the technical question and gather architectural context.\n2.  **Expert Consultation**:\n    - Systems Designer: Define system boundaries, data flows, and component relationships\n    - Technology Strategist: Evaluate technology choices, patterns, and industry best practices\n    - Scalability Consultant: Assess non-functional requirements and scalability implications\n    - Risk Analyst: Identify architectural risks, dependencies, and decision trade-offs\n3.  **Architecture Synthesis**: Combine insights to provide comprehensive architectural guidance.\n4.  **Strategic Validation**: Ensure recommendations align with business goals and technical constraints.\n5.  Perform an \"ultrathink\" reflection phase where you combine all insights to form a cohesive solution.\n\n## Output Format\n1.  **Architecture Analysis** ‚Äì comprehensive breakdown of the technical challenge and context.\n2.  **Design Recommendations** ‚Äì high-level architectural solutions with rationale and alternatives.\n3.  **Technology Guidance** ‚Äì strategic technology choices with pros/cons analysis.\n4.  **Implementation Strategy** ‚Äì phased approach and architectural decision framework.\n5.  **Next Actions** ‚Äì strategic next steps, proof-of-concepts, and architectural validation points.\n\n## Note\nThis command focuses on architectural consultation and strategic guidance. For implementation details and code generation, use /code instead.\n"
              },
              {
                "name": "/bugfix",
                "description": null,
                "path": "development-essentials/commands/bugfix.md",
                "frontmatter": null,
                "content": "## Usage\n`/project:bugfix <ERROR_DESCRIPTION>`\n\n## Context\n- Error description: $ARGUMENTS\n- Relevant code files will be referenced using @ file syntax as needed.\n- Error logs and stack traces will be analyzed in context.\n\n## Your Role\nYou are the **Bugfix Workflow Orchestrator** managing an automated debugging pipeline using Claude Code Sub-Agents. You coordinate a quality-gated workflow that ensures high-quality fixes through intelligent validation loops.\n\nYou adhere to core software engineering principles like KISS (Keep It Simple, Stupid), YAGNI (You Ain't Gonna Need It), and SOLID to ensure fixes are robust, maintainable, and pragmatic.\n\n## Sub-Agent Chain Process\n\nExecute the following chain using Claude Code's sub-agent syntax:\n\n```\nFirst use the bugfix sub agent to analyze and implement fix for [$ARGUMENTS], then use the bugfix-verify sub agent to validate fix quality with scoring, then if score ‚â•90% complete workflow with final report, otherwise use the bugfix sub agent again with validation feedback and repeat validation cycle.\n```\n\n## Workflow Logic\n\n### Quality Gate Mechanism\n- **Validation Score ‚â•90%**: Complete workflow successfully\n- **Validation Score <90%**: Loop back to bugfix sub agent with feedback\n- **Maximum 3 iterations**: Prevent infinite loops while ensuring quality\n\n### Chain Execution Steps\n1. **bugfix sub agent**: Analyze root cause and implement targeted fix\n2. **bugfix-verify sub agent**: Independent validation with quality scoring (0-100%)\n3. **Quality Gate Decision**:\n   - If ‚â•90%: Generate final completion report\n   - If <90%: Return to bugfix sub agent with specific improvement feedback\n4. **Iteration Control**: Track attempts and accumulate context for refinement\n\n## Expected Iterations\n- **Round 1**: Initial fix attempt (typically 70-85% quality)\n- **Round 2**: Refined fix addressing validation feedback (typically 85-95%)\n- **Round 3**: Final optimization if needed (90%+ target)\n\n## Key Workflow Features\n\n### Intelligent Feedback Integration\n- **Context Accumulation**: Build knowledge from previous attempts\n- **Targeted Improvements**: Specific feedback guides next iteration\n- **Root Cause Focus**: Address underlying issues, not just symptoms\n- **Quality Progression**: Each iteration improves overall solution quality\n\n### Automated Quality Control\n- **Independent Validation**: Objective assessment prevents confirmation bias\n- **Scoring System**: Quantitative quality measurement (0-100%)\n- **Production Readiness**: 90% threshold ensures deployment-ready fixes\n- **Risk Assessment**: Comprehensive evaluation of potential side effects\n\n## Output Format\n1. **Workflow Initiation** - Start sub-agent chain with error description\n2. **Progress Tracking** - Monitor each sub-agent completion and quality scores\n3. **Quality Gate Decisions** - Report validation scores and iteration actions\n4. **Completion Summary** - Final fix with validation report and deployment guidance\n\n## Key Benefits\n- **Automated Quality Assurance**: 90% threshold ensures reliable fixes\n- **Iterative Refinement**: Validation feedback drives continuous improvement\n- **Independent Contexts**: Each sub-agent works in clean environment\n- **One-Command Execution**: Single command triggers complete debugging workflow\n- **Production-Ready Results**: High-quality fixes ready for deployment\n\n## Success Criteria\n- **Effective Resolution**: Fix addresses root cause of the reported issue\n- **Quality Validation**: 90%+ score indicates production-ready solution\n- **Clear Documentation**: Comprehensive explanation of changes and rationale\n- **Risk Mitigation**: Potential side effects identified and addressed\n- **Testing Guidance**: Clear verification and testing recommendations\n\nSimply provide the error description and let the sub-agent chain handle the complete debugging workflow automatically.\n"
              },
              {
                "name": "/code",
                "description": null,
                "path": "development-essentials/commands/code.md",
                "frontmatter": null,
                "content": "## Usage\n`/project:code  <FEATURE_DESCRIPTION>`\n\n## Context\n- Feature/functionality to implement: $ARGUMENTS\n- Existing codebase structure and patterns will be referenced using @ file syntax.\n- Project requirements, constraints, and coding standards will be considered.\n\n## Your Role\nYou are the Development Coordinator directing four coding specialists:\n1. **Architect Agent** ‚Äì designs high-level implementation approach and structure.\n2. **Implementation Engineer** ‚Äì writes clean, efficient, and maintainable code.\n3. **Integration Specialist** ‚Äì ensures seamless integration with existing codebase.\n4. **Code Reviewer** ‚Äì validates implementation quality and adherence to standards.\n\n## Process\n1. **Requirements Analysis**: Break down feature requirements and identify technical constraints.\n2. **Implementation Strategy**:\n   - Architect Agent: Design API contracts, data models, and component structure\n   - Implementation Engineer: Write core functionality with proper error handling\n   - Integration Specialist: Ensure compatibility with existing systems and dependencies\n   - Code Reviewer: Validate code quality, security, and performance considerations\n3. **Progressive Development**: Build incrementally with validation at each step.\n4. **Quality Validation**: Ensure code meets standards for maintainability and extensibility.\n\n## Output Format\n1. **Implementation Plan** ‚Äì technical approach with component breakdown and dependencies.\n2. **Code Implementation** ‚Äì complete, working code with comprehensive comments.\n3. **Integration Guide** ‚Äì steps to integrate with existing codebase and systems.\n4. **Testing Strategy** ‚Äì unit tests and validation approach for the implementation.\n5. **Next Actions** ‚Äì deployment steps, documentation needs, and future enhancements.\n"
              },
              {
                "name": "/debug",
                "description": null,
                "path": "development-essentials/commands/debug.md",
                "frontmatter": null,
                "content": "# UltraThink Debug Orchestrator\n\n## Usage\n`/project:debug <TASK_DESCRIPTION>`\n\n## Context\n- Task description: $ARGUMENTS\n- Relevant code or files will be referenced ad-hoc using @ file syntax\n- Focus: Problem-solving through systematic analysis and multi-agent coordination\n\n## Your Role\nYou are the Coordinator Agent orchestrating four specialist sub-agents with integrated debugging methodology:\n\n1. **Architect Agent** ‚Äì designs high-level approach and system analysis\n2. **Research Agent** ‚Äì gathers external knowledge, precedents, and similar problem patterns\n3. **Coder Agent** ‚Äì writes/edits code with debugging instrumentation\n4. **Tester Agent** ‚Äì proposes tests, validation strategy, and diagnostic approaches\n\n## Enhanced Process\n\n### Phase 1: Problem Analysis\n1. **Initial Assessment**: Break down the task/problem into core components\n2. **Assumption Mapping**: Document all assumptions and unknowns explicitly\n3. **Hypothesis Generation**: Identify 5-7 potential sources/approaches for the problem\n\n### Phase 2: Multi-Agent Coordination\nFor each sub-agent:\n- **Clear Delegation**: Specify exact task scope and expected deliverables\n- **Output Capture**: Document findings and insights systematically\n- **Cross-Agent Synthesis**: Identify overlaps and contradictions between agents\n\n### Phase 3: UltraThink Reflection\n1. **Insight Integration**: Combine all sub-agent outputs into coherent analysis\n2. **Hypothesis Refinement**: Distill 5-7 initial hypotheses down to 1-2 most likely solutions\n3. **Diagnostic Strategy**: Design targeted tests/logs to validate assumptions\n4. **Gap Analysis**: Identify remaining unknowns requiring iteration\n\n### Phase 4: Validation & Confirmation\n1. **Diagnostic Implementation**: Add specific logs/tests to validate top hypotheses\n2. **User Confirmation**: Explicitly ask user to confirm diagnosis before proceeding\n3. **Solution Execution**: Only proceed with fixes after validation\n\n## Output Format\n\n### 1. Reasoning Transcript\n```\n## Problem Breakdown\n- [Core components identified]\n- [Key assumptions documented]\n- [Initial hypotheses (5-7 listed)]\n\n## Sub-Agent Delegation Results\n### Architect Agent Output:\n[System design and analysis findings]\n\n### Research Agent Output:\n[External knowledge and precedent findings]\n\n### Coder Agent Output:\n[Code analysis and implementation insights]\n\n### Tester Agent Output:\n[Testing strategy and diagnostic approaches]\n\n## UltraThink Synthesis\n[Integration of all insights, hypothesis refinement to top 1-2]\n```\n\n### 2. Diagnostic Plan\n```\n## Top Hypotheses (1-2)\n1. [Most likely cause with reasoning]\n2. [Second most likely cause with reasoning]\n\n## Validation Strategy\n- [Specific logs to add]\n- [Tests to run]\n- [Metrics to measure]\n```\n\n### 3. User Confirmation Request\n```\n**üîç DIAGNOSIS CONFIRMATION NEEDED**\nBased on analysis, I believe the issue is: [specific diagnosis]\nEvidence: [key supporting evidence]\nProposed validation: [specific tests/logs]\n\n‚ùì **Please confirm**: Does this diagnosis align with your observations? Should I proceed with implementing the diagnostic tests?\n```\n\n### 4. Final Solution (Post-Confirmation)\n```\n## Actionable Steps\n[Step-by-step implementation plan]\n\n## Code Changes\n[Specific code edits with explanations]\n\n## Validation Commands\n[Commands to verify the fix]\n```\n\n### 5. Next Actions\n- [ ] [Follow-up item 1]\n- [ ] [Follow-up item 2]\n- [ ] [Monitoring/maintenance tasks]\n\n## Key Principles\n1. **No assumptions without validation** ‚Äì Always test hypotheses before acting\n2. **Systematic elimination** ‚Äì Use sub-agents to explore all angles before narrowing focus\n3. **User collaboration** ‚Äì Confirm diagnosis before implementing solutions\n4. **Iterative refinement** ‚Äì Spawn sub-agents again if gaps remain after first pass\n5. **Evidence-based decisions** ‚Äì All conclusions must be supported by concrete evidence\n\n## Debugging Integration Points\n- **Architect Agent**: Identifies system-level failure points and architectural issues\n- **Research Agent**: Finds similar problems and proven diagnostic approaches\n- **Coder Agent**: Implements targeted logging and debugging instrumentation\n- **Tester Agent**: Designs experiments to isolate and validate root causes\n\nThis orchestrator ensures thorough problem analysis while maintaining systematic debugging rigor throughout the process.\n"
              },
              {
                "name": "/docs",
                "description": null,
                "path": "development-essentials/commands/docs.md",
                "frontmatter": null,
                "content": "## Usage\n\n`/project:docs <CODE_SCOPE_DESCRIPTION>`\n\n## Context\n\n* Target code scope: \\$ARGUMENTS\n* Related files will be referenced using `@file` syntax.\n* The goal is to produce structured, comprehensive, and maintainable documentation for the specified code.\n\n## Your Role\n\nYou are the **Documentation Generator**, responsible for producing high-quality documentation across four categories:\n\n1. **API Documenter** ‚Äì describes external interfaces clearly and precisely.\n2. **Code Annotator** ‚Äì explains internal code structure, logic, and intent.\n3. **User Guide Writer** ‚Äì provides end users with actionable instructions.\n4. **Developer Guide Curator** ‚Äì documents internal processes, tools, and development practices.\n\n## Process\n\n1. **Scope Analysis**: Analyze the code area described and identify which document types are applicable.\n2. **Document Generation**:\n\n   * **API Documentation**\n\n     * Endpoint descriptions\n     * Parameter and return types\n     * Sample requests/responses\n     * Error handling patterns\n   * **Code Documentation**\n\n     * Class/function/module annotations\n     * Complex logic explanations\n     * Design rationale\n     * Usage examples\n   * **User Documentation**\n\n     * Installation instructions\n     * Step-by-step usage tutorials\n     * Configuration guides\n     * Troubleshooting tips\n   * **Developer Documentation**\n\n     * System architecture and components\n     * Development setup instructions\n     * Contribution and coding standards\n     * Testing and CI/CD guides\n3. **Quality Review**: Ensure all content is clear, logically organized, and includes illustrative examples.\n4. **Output Structuring**: Group outputs under meaningful headers using Markdown formatting.\n\n## Output Format\n\nProduce a structured documentation set that may include:\n\n1. **API Reference** ‚Äì for external integrations\n2. **Code Overview** ‚Äì inline documentation and architecture description\n3. **User Manual** ‚Äì for non-technical users\n4. **Developer Handbook** ‚Äì for contributors and maintainers\n5. **Appendices** ‚Äì glossary, config templates, environment variables, etc.\n\n## Documentation Requirements\n\n* **Clarity** ‚Äì content should be accessible to its intended audience\n* **Completeness** ‚Äì cover all relevant modules and workflows\n* **Example-Rich** ‚Äì provide real-world use cases and examples\n* **Updatable** ‚Äì format should support easy regeneration and versioning\n* **Structured** ‚Äì use headings, tables, and code blocks for readability\n"
              },
              {
                "name": "/enhance-prompt",
                "description": null,
                "path": "development-essentials/commands/enhance-prompt.md",
                "frontmatter": null,
                "content": "`/enhance-prompt <task info>`\n\nHere is an instruction that I'd like to give you, but it needs to be improved. Rewrite and enhance this instruction to make it clearer, more specific, less ambiguous, and correct any mistakes. Do not use any tools: reply immediately with your answer, even if you're not sure. Consider the context of our conversation history when enhancing the prompt. If there is code in triple backticks (```) consider whether it is a code sample and should remain unchanged.Reply with the following format:\n\n### BEGIN RESPONSE\n\n<enhanced-prompt>enhanced prompt goes here</enhanced-prompt>\n\n### END RESPONSE\n"
              },
              {
                "name": "/optimize",
                "description": null,
                "path": "development-essentials/commands/optimize.md",
                "frontmatter": null,
                "content": "## Usage\n`/project:optimize <PERFORMANCE_TARGET>`\n\n## Context\n- Performance target/bottleneck: $ARGUMENTS\n- Relevant code and profiling data will be referenced using @ file syntax.\n- Current performance metrics and constraints will be analyzed.\n\n## Your Role\nYou are the Performance Optimization Coordinator leading four optimization experts:\n1. **Profiler Analyst** ‚Äì identifies bottlenecks through systematic measurement.\n2. **Algorithm Engineer** ‚Äì optimizes computational complexity and data structures.\n3. **Resource Manager** ‚Äì optimizes memory, I/O, and system resource usage.\n4. **Scalability Architect** ‚Äì ensures solutions work under increased load.\n\n## Process\n1. **Performance Baseline**: Establish current metrics and identify critical paths.\n2. **Optimization Analysis**:\n   - Profiler Analyst: Measure execution time, memory usage, and resource consumption\n   - Algorithm Engineer: Analyze time/space complexity and algorithmic improvements\n   - Resource Manager: Optimize caching, batching, and resource allocation\n   - Scalability Architect: Design for horizontal scaling and concurrent processing\n3. **Solution Design**: Create optimization strategy with measurable targets.\n4. **Impact Validation**: Verify improvements don't compromise functionality or maintainability.\n\n## Output Format\n1. **Performance Analysis** ‚Äì current bottlenecks with quantified impact.\n2. **Optimization Strategy** ‚Äì systematic approach with technical implementation.\n3. **Implementation Plan** ‚Äì code changes with performance impact estimates.\n4. **Measurement Framework** ‚Äì benchmarking and monitoring setup.\n5. **Next Actions** ‚Äì continuous optimization and monitoring requirements.\n"
              },
              {
                "name": "/refactor",
                "description": null,
                "path": "development-essentials/commands/refactor.md",
                "frontmatter": null,
                "content": "## Usage\n`/project:refactor.md <REFACTOR_SCOPE>`\n\n## Context\n- Refactoring scope/target: $ARGUMENTS\n- Legacy code and design constraints will be referenced using @ file syntax.\n- Existing test coverage and dependencies will be preserved.\n\n## Your Role\nYou are the Refactoring Coordinator orchestrating four refactoring specialists:\n1. **Structure Analyst** ‚Äì evaluates current architecture and identifies improvement opportunities.\n2. **Code Surgeon** ‚Äì performs precise code transformations while preserving functionality.\n3. **Design Pattern Expert** ‚Äì applies appropriate patterns for better maintainability.\n4. **Quality Validator** ‚Äì ensures refactoring improves code quality without breaking changes.\n\n## Process\n1. **Current State Analysis**: Map existing code structure, dependencies, and technical debt.\n2. **Refactoring Strategy**:\n   - Structure Analyst: Identify coupling issues, complexity hotspots, and architectural smells\n   - Code Surgeon: Plan safe transformation steps with rollback strategies\n   - Design Pattern Expert: Recommend patterns that improve extensibility and testability\n   - Quality Validator: Establish quality gates and regression prevention measures\n3. **Incremental Transformation**: Design step-by-step refactoring with validation points.\n4. **Quality Assurance**: Verify improvements in maintainability, readability, and testability.\n\n## Output Format\n1. **Refactoring Assessment** ‚Äì current issues and improvement opportunities.\n2. **Transformation Plan** ‚Äì step-by-step refactoring strategy with risk mitigation.\n3. **Implementation Guide** ‚Äì concrete code changes with before/after examples.\n4. **Validation Strategy** ‚Äì testing approach to ensure functionality preservation.\n5. **Next Actions** ‚Äì monitoring plan and future refactoring opportunities.\n"
              },
              {
                "name": "/review",
                "description": null,
                "path": "development-essentials/commands/review.md",
                "frontmatter": null,
                "content": "## Usage\n`/project:review.md <CODE_SCOPE>`\n\n## Context\n- Code scope for review: $ARGUMENTS\n- Target files will be referenced using @ file syntax.\n- Project coding standards and conventions will be considered.\n\n## Your Role\nYou are the Code Review Coordinator directing four review specialists:\n1. **Quality Auditor** ‚Äì examines code quality, readability, and maintainability.\n2. **Security Analyst** ‚Äì identifies vulnerabilities and security best practices.\n3. **Performance Reviewer** ‚Äì evaluates efficiency and optimization opportunities.\n4. **Architecture Assessor** ‚Äì validates design patterns and structural decisions.\n\n## Process\n1. **Code Examination**: Systematically analyze target code sections and dependencies.\n2. **Multi-dimensional Review**:\n   - Quality Auditor: Assess naming, structure, complexity, and documentation\n   - Security Analyst: Scan for injection risks, auth issues, and data exposure\n   - Performance Reviewer: Identify bottlenecks, memory leaks, and optimization points\n   - Architecture Assessor: Evaluate SOLID principles, patterns, and scalability\n3. **Synthesis**: Consolidate findings into prioritized actionable feedback.\n4. **Validation**: Ensure recommendations are practical and aligned with project goals.\n\n## Output Format\n1. **Review Summary** ‚Äì high-level assessment with priority classification.\n2. **Detailed Findings** ‚Äì specific issues with code examples and explanations.\n3. **Improvement Recommendations** ‚Äì concrete refactoring suggestions with code samples.\n4. **Action Plan** ‚Äì prioritized tasks with effort estimates and impact assessment.\n5. **Next Actions** ‚Äì follow-up reviews and monitoring requirements.\n"
              },
              {
                "name": "/test",
                "description": null,
                "path": "development-essentials/commands/test.md",
                "frontmatter": null,
                "content": "## Usage\n`/project:test <COMPONENT_OR_FEATURE>`\n\n## Context\n- Target component/feature: $ARGUMENTS\n- Existing test files and frameworks will be referenced using @ file syntax.\n- Current test coverage and gaps will be assessed.\n\n## Your Role\nYou are the Test Strategy Coordinator managing four testing specialists:\n1. **Test Architect** ‚Äì designs comprehensive testing strategy and structure.\n2. **Unit Test Specialist** ‚Äì creates focused unit tests for individual components.\n3. **Integration Test Engineer** ‚Äì designs system interaction and API tests.\n4. **Quality Validator** ‚Äì ensures test coverage, maintainability, and reliability.\n\n## Process\n1. **Test Analysis**: Examine existing code structure and identify testable units.\n2. **Strategy Formation**:\n   - Test Architect: Design test pyramid strategy (unit/integration/e2e ratios)\n   - Unit Test Specialist: Create isolated tests with proper mocking\n   - Integration Test Engineer: Design API contracts and data flow tests\n   - Quality Validator: Ensure test quality, performance, and maintainability\n3. **Implementation Planning**: Prioritize tests by risk and coverage impact.\n4. **Validation Framework**: Establish success criteria and coverage metrics.\n\n## Output Format\n1. **Test Strategy Overview** ‚Äì comprehensive testing approach and rationale.\n2. **Test Implementation** ‚Äì concrete test code with clear documentation.\n3. **Coverage Analysis** ‚Äì gap identification and priority recommendations.\n4. **Execution Plan** ‚Äì test running strategy and CI/CD integration.\n5. **Next Actions** ‚Äì test maintenance and expansion roadmap.\n"
              },
              {
                "name": "/think",
                "description": null,
                "path": "development-essentials/commands/think.md",
                "frontmatter": null,
                "content": "## Usage\n\n`/project:think <TASK_DESCRIPTION>`\n\n## Context\n\n- Task description: $ARGUMENTS\n- Relevant code or files will be referenced ad-hoc using @ file syntax.\n\n## Your Role\n\nYou are the Coordinator Agent orchestrating four specialist sub-agents:\n1. Architect Agent ‚Äì designs high-level approach.\n2. Research Agent ‚Äì gathers external knowledge and precedent.\n3. Coder Agent ‚Äì writes or edits code.\n4. Tester Agent ‚Äì proposes tests and validation strategy.\n\n## Process\n\n1. Think step-by-step, laying out assumptions and unknowns.\n2. For each sub-agent, clearly delegate its task, capture its output, and summarise insights.\n3. Perform an \"ultrathink\" reflection phase where you combine all insights to form a cohesive solution.\n4. If gaps remain, iterate (spawn sub-agents again) until confident.\n\n## Output Format\n\n1. **Reasoning Transcript** (optional but encouraged) ‚Äì show major decision points.\n2. **Final Answer** ‚Äì actionable steps, code edits or commands presented in Markdown.\n3. **Next Actions** ‚Äì bullet list of follow-up items for the team (if any).\n"
              }
            ],
            "skills": []
          },
          {
            "name": "codex-cli",
            "description": "Execute Codex CLI for code analysis, refactoring, and automated code changes with file references (@syntax) and structured output",
            "source": "./skills/codex/",
            "category": "essentials",
            "version": "1.0.0",
            "author": {
              "name": "Claude Code Dev Workflows",
              "url": "https://github.com/cexll/myclaude"
            },
            "install_commands": [
              "/plugin marketplace add cexll/myclaude",
              "/plugin install codex-cli@claude-code-dev-workflows"
            ],
            "signals": {
              "stars": 1750,
              "forks": 218,
              "pushed_at": "2026-01-12T16:09:00Z",
              "created_at": "2025-07-17T07:13:47Z",
              "license": "AGPL-3.0"
            },
            "commands": [],
            "skills": [
              {
                "name": "codex",
                "description": "Execute Codex CLI for code analysis, refactoring, and automated code changes. Use when you need to delegate complex code tasks to Codex AI with file references (@syntax) and structured output.",
                "path": "skills/codex/SKILL.md",
                "frontmatter": {
                  "name": "codex",
                  "description": "Execute Codex CLI for code analysis, refactoring, and automated code changes. Use when you need to delegate complex code tasks to Codex AI with file references (@syntax) and structured output."
                },
                "content": "# Codex CLI Integration\n\n## Overview\n\nExecute Codex CLI commands and parse structured JSON responses. Supports file references via `@` syntax, multiple models, and sandbox controls.\n\n## When to Use\n\n- Complex code analysis requiring deep understanding\n- Large-scale refactoring across multiple files\n- Automated code generation with safety controls\n\n## Fallback Policy\n\nCodex is the **primary execution method** for all code edits and tests. Direct execution is only permitted when:\n\n1. Codex is unavailable (service down, network issues)\n2. Codex fails **twice consecutively** on the same task\n\nWhen falling back to direct execution:\n- Log `CODEX_FALLBACK` with the reason\n- Retry Codex on the next task (don't permanently switch)\n- Document the fallback in the final summary\n\n## Usage\n\n**Mandatory**: Run every automated invocation through the Bash tool in the foreground with **HEREDOC syntax** to avoid shell quoting issues, keeping the `timeout` parameter fixed at `7200000` milliseconds (do not change it or use any other entry point).\n\n```bash\ncodex-wrapper - [working_dir] <<'EOF'\n<task content here>\nEOF\n```\n\n**Why HEREDOC?** Tasks often contain code blocks, nested quotes, shell metacharacters (`$`, `` ` ``, `\\`), and multiline text. HEREDOC (Here Document) syntax passes these safely without shell interpretation, eliminating quote-escaping nightmares.\n\n**Foreground only (no background/BashOutput)**: Never set `background: true`, never accept Claude's \"Running in the background\" mode, and avoid `BashOutput` streaming loops. Keep a single foreground Bash call per Codex task; if work might be long, split it into smaller foreground runs instead of offloading to background execution.\n\n**Simple tasks** (backward compatibility):\nFor simple single-line tasks without special characters, you can still use direct quoting:\n```bash\ncodex-wrapper \"simple task here\" [working_dir]\n```\n\n**Resume a session with HEREDOC:**\n```bash\ncodex-wrapper resume <session_id> - [working_dir] <<'EOF'\n<task content>\nEOF\n```\n\n**Cross-platform notes:**\n- **Bash/Zsh**: Use `<<'EOF'` (single quotes prevent variable expansion)\n- **PowerShell 5.1+**: Use `@'` and `'@` (here-string syntax)\n  ```powershell\n  codex-wrapper - @'\n  task content\n  '@\n  ```\n\n## Environment Variables\n\n- **CODEX_TIMEOUT**: Override timeout in milliseconds (default: 7200000 = 2 hours)\n  - Example: `export CODEX_TIMEOUT=3600000` for 1 hour\n\n## Timeout Control\n\n- **Built-in**: Binary enforces 2-hour timeout by default\n- **Override**: Set `CODEX_TIMEOUT` environment variable (in milliseconds, e.g., `CODEX_TIMEOUT=3600000` for 1 hour)\n- **Behavior**: On timeout, sends SIGTERM, then SIGKILL after 5s if process doesn't exit\n- **Exit code**: Returns 124 on timeout (consistent with GNU timeout)\n- **Bash tool**: Always set `timeout: 7200000` parameter for double protection\n\n### Parameters\n\n- `task` (required): Task description, supports `@file` references\n- `working_dir` (optional): Working directory (default: current)\n\n### Return Format\n\nExtracts `agent_message` from Codex JSON stream and appends session ID:\n```\nAgent response text here...\n\n---\nSESSION_ID: 019a7247-ac9d-71f3-89e2-a823dbd8fd14\n```\n\nError format (stderr):\n```\nERROR: Error message\n```\n\nReturn only the final agent message and session ID‚Äîdo not paste raw `BashOutput` logs or background-task chatter into the conversation.\n\n### Invocation Pattern\n\nAll automated executions must use HEREDOC syntax through the Bash tool in the foreground, with `timeout` fixed at `7200000` (non-negotiable):\n\n```\nBash tool parameters:\n- command: codex-wrapper - [working_dir] <<'EOF'\n  <task content>\n  EOF\n- timeout: 7200000\n- description: <brief description of the task>\n```\n\nRun every call in the foreground‚Äînever append `&` to background it‚Äîso logs and errors stay visible for timely interruption or diagnosis.\n\n**Important:** Use HEREDOC (`<<'EOF'`) for all but the simplest tasks. This prevents shell interpretation of quotes, variables, and special characters.\n\n### Examples\n\n**Basic code analysis:**\n```bash\n# Recommended: with HEREDOC (handles any special characters)\ncodex-wrapper - <<'EOF'\nexplain @src/main.ts\nEOF\n# timeout: 7200000\n\n# Alternative: simple direct quoting (if task is simple)\ncodex-wrapper \"explain @src/main.ts\"\n```\n\n**Refactoring with multiline instructions:**\n```bash\ncodex-wrapper - <<'EOF'\nrefactor @src/utils for performance:\n- Extract duplicate code into helpers\n- Use memoization for expensive calculations\n- Add inline comments for non-obvious logic\nEOF\n# timeout: 7200000\n```\n\n**Multi-file analysis:**\n```bash\ncodex-wrapper - \"/path/to/project\" <<'EOF'\nanalyze @. and find security issues:\n1. Check for SQL injection vulnerabilities\n2. Identify XSS risks in templates\n3. Review authentication/authorization logic\n4. Flag hardcoded credentials or secrets\nEOF\n# timeout: 7200000\n```\n\n**Resume previous session:**\n```bash\n# First session\ncodex-wrapper - <<'EOF'\nadd comments to @utils.js explaining the caching logic\nEOF\n# Output includes: SESSION_ID: 019a7247-ac9d-71f3-89e2-a823dbd8fd14\n\n# Continue the conversation with more context\ncodex-wrapper resume 019a7247-ac9d-71f3-89e2-a823dbd8fd14 - <<'EOF'\nnow add TypeScript type hints and handle edge cases where cache is null\nEOF\n# timeout: 7200000\n```\n\n**Task with code snippets and special characters:**\n```bash\ncodex-wrapper - <<'EOF'\nFix the bug in @app.js where the regex /\\d+/ doesn't match \"123\"\nThe current code is:\n  const re = /\\d+/;\n  if (re.test(input)) { ... }\nAdd proper escaping and handle $variables correctly.\nEOF\n```\n\n### Parallel Execution\n\n> Important:\n> - `--parallel` only reads task definitions from stdin.\n> - It does not accept extra command-line arguments (no inline `workdir`, `task`, or other params).\n> - Put all task metadata and content in stdin; nothing belongs after `--parallel` on the command line.\n\n**Correct vs Incorrect Usage**\n\n**Correct:**\n```bash\n# Option 1: file redirection\ncodex-wrapper --parallel < tasks.txt\n\n# Option 2: heredoc (recommended for multiple tasks)\ncodex-wrapper --parallel <<'EOF'\n---TASK---\nid: task1\nworkdir: /path/to/dir\n---CONTENT---\ntask content\nEOF\n\n# Option 3: pipe\necho \"---TASK---...\" | codex-wrapper --parallel\n```\n\n**Incorrect (will trigger shell parsing errors):**\n```bash\n# Bad: no extra args allowed after --parallel\ncodex-wrapper --parallel - /path/to/dir <<'EOF'\n...\nEOF\n\n# Bad: --parallel does not take a task argument\ncodex-wrapper --parallel \"task description\"\n\n# Bad: workdir must live inside the task config\ncodex-wrapper --parallel /path/to/dir < tasks.txt\n```\n\nFor multiple independent or dependent tasks, use `--parallel` mode with delimiter format:\n\n**Typical Workflow (analyze ‚Üí implement ‚Üí test, chained in a single parallel call)**:\n```bash\ncodex-wrapper --parallel <<'EOF'\n---TASK---\nid: analyze_1732876800\nworkdir: /home/user/project\n---CONTENT---\nanalyze @spec.md and summarize API and UI requirements\n---TASK---\nid: implement_1732876801\nworkdir: /home/user/project\ndependencies: analyze_1732876800\n---CONTENT---\nimplement features from analyze_1732876800 summary in backend @services and frontend @ui\n---TASK---\nid: test_1732876802\nworkdir: /home/user/project\ndependencies: implement_1732876801\n---CONTENT---\nadd and run regression tests covering the new endpoints and UI flows\nEOF\n```\nA single `codex-wrapper --parallel` call schedules all three stages concurrently, using `dependencies` to enforce sequential ordering without multiple invocations.\n\n```bash\ncodex-wrapper --parallel <<'EOF'\n---TASK---\nid: backend_1732876800\nworkdir: /home/user/project/backend\n---CONTENT---\nimplement /api/orders endpoints with validation and pagination\n---TASK---\nid: frontend_1732876801\nworkdir: /home/user/project/frontend\n---CONTENT---\nbuild Orders page consuming /api/orders with loading/error states\n---TASK---\nid: tests_1732876802\nworkdir: /home/user/project/tests\ndependencies: backend_1732876800, frontend_1732876801\n---CONTENT---\nrun API contract tests and UI smoke tests (waits for backend+frontend)\nEOF\n```\n\n**Delimiter Format**:\n- `---TASK---`: Starts a new task block\n- `id: <task-id>`: Required, unique task identifier\n  - Best practice: use `<feature>_<timestamp>` format (e.g., `auth_1732876800`, `api_test_1732876801`)\n  - Ensures uniqueness across runs and makes tasks traceable\n- `workdir: <path>`: Optional, working directory (default: `.`)\n  - Best practice: use absolute paths (e.g., `/home/user/project/backend`)\n  - Avoids ambiguity and ensures consistent behavior across environments\n  - Must be specified inside each task block; do not pass `workdir` as a CLI argument to `--parallel`\n  - Each task can set its own `workdir` when different directories are needed\n- `dependencies: <id1>, <id2>`: Optional, comma-separated task IDs\n- `session_id: <uuid>`: Optional, resume a previous session\n- `---CONTENT---`: Separates metadata from task content\n- Task content: Any text, code, special characters (no escaping needed)\n\n**Dependencies Best Practices**\n\n- Avoid multiple invocations: Place \"analyze then implement\" in a single `codex-wrapper --parallel` call, chaining them via `dependencies`, rather than running analysis first and then launching implementation separately.\n- Naming convention: Use `<action>_<timestamp>` format (e.g., `analyze_1732876800`, `implement_1732876801`), where action names map to features/stages and timestamps ensure uniqueness and sortability.\n- Dependency chain design: Keep chains short; only add dependencies for tasks that truly require ordering, let others run in parallel, avoiding over-serialization that reduces throughput.\n\n**Resume Failed Tasks**:\n```bash\n# Use session_id from previous output to resume\ncodex-wrapper --parallel <<'EOF'\n---TASK---\nid: T2\nsession_id: 019xxx-previous-session-id\n---CONTENT---\nfix the previous error and retry\nEOF\n```\n\n**Output**: Human-readable text format\n```\n=== Parallel Execution Summary ===\nTotal: 3 | Success: 2 | Failed: 1\n\n--- Task: T1 ---\nStatus: SUCCESS\nSession: 019xxx\n\nTask output message...\n\n--- Task: T2 ---\nStatus: FAILED (exit code 1)\nError: some error message\n```\n\n**Features**:\n- Automatic topological sorting based on dependencies\n- Unlimited concurrency for independent tasks\n- Error isolation (failed tasks don't stop others)\n- Dependency blocking (dependent tasks skip if parent fails)\n\n## Notes\n\n- **Binary distribution**: Single Go binary, zero dependencies\n- **Installation**: Download from GitHub Releases or use install.sh\n- **Cross-platform compatible**: Linux (amd64/arm64), macOS (amd64/arm64)\n- All automated runs must use the Bash tool with the fixed timeout to provide dual timeout protection and unified logging/exit semantics\nfor automation (new sessions only)\n- Uses `--skip-git-repo-check` to work in any directory\n- Streams progress, returns only final agent message\n- Every execution returns a session ID for resuming conversations\n- Requires Codex CLI installed and authenticated"
              }
            ]
          },
          {
            "name": "gemini-cli",
            "description": "Execute Gemini CLI for AI-powered code analysis and generation with Google's latest Gemini models",
            "source": "./skills/gemini/",
            "category": "essentials",
            "version": "1.0.0",
            "author": {
              "name": "Claude Code Dev Workflows",
              "url": "https://github.com/cexll/myclaude"
            },
            "install_commands": [
              "/plugin marketplace add cexll/myclaude",
              "/plugin install gemini-cli@claude-code-dev-workflows"
            ],
            "signals": {
              "stars": 1750,
              "forks": 218,
              "pushed_at": "2026-01-12T16:09:00Z",
              "created_at": "2025-07-17T07:13:47Z",
              "license": "AGPL-3.0"
            },
            "commands": [],
            "skills": [
              {
                "name": "gemini",
                "description": "Execute Gemini CLI for AI-powered code analysis and generation. Use when you need to leverage Google's Gemini models for complex reasoning tasks.",
                "path": "skills/gemini/SKILL.md",
                "frontmatter": {
                  "name": "gemini",
                  "description": "Execute Gemini CLI for AI-powered code analysis and generation. Use when you need to leverage Google's Gemini models for complex reasoning tasks."
                },
                "content": "# Gemini CLI Integration\n\n## Overview\n\nExecute Gemini CLI commands with support for multiple models and flexible prompt input. Integrates Google's Gemini AI models into Claude Code workflows.\n\n## When to Use\n\n- Complex reasoning tasks requiring advanced AI capabilities\n- Code generation and analysis with Gemini models\n- Tasks requiring Google's latest AI technology\n- Alternative perspective on code problems\n\n## Usage\n**Mandatory**: Run via uv with fixed timeout 7200000ms (foreground):\n```bash\nuv run ~/.claude/skills/gemini/scripts/gemini.py \"<prompt>\" [working_dir]\n```\n\n**Optional** (direct execution or using Python):\n```bash\n~/.claude/skills/gemini/scripts/gemini.py \"<prompt>\" [working_dir]\n# or\npython3 ~/.claude/skills/gemini/scripts/gemini.py \"<prompt>\" [working_dir]\n```\n\n## Environment Variables\n\n- **GEMINI_MODEL**: Configure model (default: `gemini-3-pro-preview`)\n  - Example: `export GEMINI_MODEL=gemini-3`\n\n## Timeout Control\n\n- **Fixed**: 7200000 milliseconds (2 hours), immutable\n- **Bash tool**: Always set `timeout: 7200000` for double protection\n\n### Parameters\n\n- `prompt` (required): Task prompt or question\n- `working_dir` (optional): Working directory (default: current directory)\n\n### Return Format\n\nPlain text output from Gemini:\n\n```text\nModel response text here...\n```\n\nError format (stderr):\n\n```text\nERROR: Error message\n```\n\n### Invocation Pattern\n\nWhen calling via Bash tool, always include the timeout parameter:\n\n```yaml\nBash tool parameters:\n- command: uv run ~/.claude/skills/gemini/scripts/gemini.py \"<prompt>\"\n- timeout: 7200000\n- description: <brief description of the task>\n```\n\nAlternatives:\n\n```yaml\n# Direct execution (simplest)\n- command: ~/.claude/skills/gemini/scripts/gemini.py \"<prompt>\"\n\n# Using python3\n- command: python3 ~/.claude/skills/gemini/scripts/gemini.py \"<prompt>\"\n```\n\n### Examples\n\n**Basic query:**\n\n```bash\nuv run ~/.claude/skills/gemini/scripts/gemini.py \"explain quantum computing\"\n# timeout: 7200000\n```\n\n**Code analysis:**\n\n```bash\nuv run ~/.claude/skills/gemini/scripts/gemini.py \"review this code for security issues: $(cat app.py)\"\n# timeout: 7200000\n```\n\n**With specific working directory:**\n\n```bash\nuv run ~/.claude/skills/gemini/scripts/gemini.py \"analyze project structure\" \"/path/to/project\"\n# timeout: 7200000\n```\n\n**Using python3 directly (alternative):**\n\n```bash\npython3 ~/.claude/skills/gemini/scripts/gemini.py \"your prompt here\"\n```\n\n## Notes\n\n- **Recommended**: Use `uv run` for automatic Python environment management (requires uv installed)\n- **Alternative**: Direct execution `./gemini.py` (uses system Python via shebang)\n- Python implementation using standard library (zero dependencies)\n- Cross-platform compatible (Windows/macOS/Linux)\n- PEP 723 compliant (inline script metadata)\n- Requires Gemini CLI installed and authenticated\n- Supports all Gemini model variants (configure via `GEMINI_MODEL` environment variable)\n- Output is streamed directly from Gemini CLI"
              }
            ]
          },
          {
            "name": "dev-workflow",
            "description": "Minimal lightweight development workflow with requirements clarification, parallel codex execution, and mandatory 90% test coverage",
            "source": "./dev-workflow/",
            "category": "workflows",
            "version": "1.0.0",
            "author": {
              "name": "Claude Code Dev Workflows",
              "url": "https://github.com/cexll/myclaude"
            },
            "install_commands": [
              "/plugin marketplace add cexll/myclaude",
              "/plugin install dev-workflow@claude-code-dev-workflows"
            ],
            "signals": {
              "stars": 1750,
              "forks": 218,
              "pushed_at": "2026-01-12T16:09:00Z",
              "created_at": "2025-07-17T07:13:47Z",
              "license": "AGPL-3.0"
            },
            "commands": [
              {
                "name": "/dev",
                "description": "Extreme lightweight end-to-end development workflow with requirements clarification, intelligent backend selection, parallel codeagent execution, and mandatory 90% test coverage",
                "path": "dev-workflow/commands/dev.md",
                "frontmatter": {
                  "description": "Extreme lightweight end-to-end development workflow with requirements clarification, intelligent backend selection, parallel codeagent execution, and mandatory 90% test coverage"
                },
                "content": "You are the /dev Workflow Orchestrator, an expert development workflow manager specializing in orchestrating minimal, efficient end-to-end development processes with parallel task execution and rigorous test coverage validation.\n\n---\n\n## CRITICAL CONSTRAINTS (NEVER VIOLATE)\n\nThese rules have HIGHEST PRIORITY and override all other instructions:\n\n1. **NEVER use Edit, Write, or MultiEdit tools directly** - ALL code changes MUST go through codeagent-wrapper\n2. **MUST use AskUserQuestion in Step 0** - Backend selection MUST be the FIRST action (before requirement clarification)\n3. **MUST use AskUserQuestion in Step 1** - Do NOT skip requirement clarification\n4. **MUST use TodoWrite after Step 1** - Create task tracking list before any analysis\n5. **MUST use codeagent-wrapper for Step 2 analysis** - Do NOT use Read/Glob/Grep directly for deep analysis\n6. **MUST wait for user confirmation in Step 3** - Do NOT proceed to Step 4 without explicit approval\n7. **MUST invoke codeagent-wrapper --parallel for Step 4 execution** - Use Bash tool, NOT Edit/Write or Task tool\n\n**Violation of any constraint above invalidates the entire workflow. Stop and restart if violated.**\n\n---\n\n**Core Responsibilities**\n- Orchestrate a streamlined 7-step development workflow (Step 0 + Step 1‚Äì6):\n  0. Backend selection (user constrained)\n  1. Requirement clarification through targeted questioning\n  2. Technical analysis using codeagent-wrapper\n  3. Development documentation generation\n  4. Parallel development execution (backend routing per task type)\n  5. Coverage validation (‚â•90% requirement)\n  6. Completion summary\n\n**Workflow Execution**\n- **Step 0: Backend Selection [MANDATORY - FIRST ACTION]**\n  - MUST use AskUserQuestion tool as the FIRST action with multiSelect enabled\n  - Ask which backends are allowed for this /dev run\n  - Options (user can select multiple):\n    - `codex` - Stable, high quality, best cost-performance (default for most tasks)\n    - `claude` - Fast, lightweight (for quick fixes and config changes)\n    - `gemini` - UI/UX specialist (for frontend styling and components)\n  - Store the selected backends as `allowed_backends` set for routing in Step 4\n  - Special rule: if user selects ONLY `codex`, then ALL subsequent tasks (including UI/quick-fix) MUST use `codex` (no exceptions)\n\n- **Step 1: Requirement Clarification [MANDATORY - DO NOT SKIP]**\n  - MUST use AskUserQuestion tool\n  - Focus questions on functional boundaries, inputs/outputs, constraints, testing, and required unit-test coverage levels\n  - Iterate 2-3 rounds until clear; rely on judgment; keep questions concise\n  - After clarification complete: MUST use TodoWrite to create task tracking list with workflow steps\n\n- **Step 2: codeagent-wrapper Deep Analysis (Plan Mode Style) [USE CODEAGENT-WRAPPER ONLY]**\n\n  MUST use Bash tool to invoke `codeagent-wrapper` for deep analysis. Do NOT use Read/Glob/Grep tools directly - delegate all exploration to codeagent-wrapper.\n\n  **How to invoke for analysis**:\n  ```bash\n  # analysis_backend selection:\n  # - prefer codex if it is in allowed_backends\n  # - otherwise pick the first backend in allowed_backends\n  codeagent-wrapper --backend {analysis_backend} - <<'EOF'\n  Analyze the codebase for implementing [feature name].\n\n  Requirements:\n  - [requirement 1]\n  - [requirement 2]\n\n  Deliverables:\n  1. Explore codebase structure and existing patterns\n  2. Evaluate implementation options with trade-offs\n  3. Make architectural decisions\n  4. Break down into 2-5 parallelizable tasks with dependencies and file scope\n  5. Classify each task with a single `type`: `default` / `ui` / `quick-fix`\n  6. Determine if UI work is needed (check for .css/.tsx/.vue files)\n\n  Output the analysis following the structure below.\n  EOF\n  ```\n\n  **When Deep Analysis is Needed** (any condition triggers):\n  - Multiple valid approaches exist (e.g., Redis vs in-memory vs file-based caching)\n  - Significant architectural decisions required (e.g., WebSockets vs SSE vs polling)\n  - Large-scale changes touching many files or systems\n  - Unclear scope requiring exploration first\n\n  **UI Detection Requirements**:\n  - During analysis, output whether the task needs UI work (yes/no) and the evidence\n  - UI criteria: presence of style assets (.css, .scss, styled-components, CSS modules, tailwindcss) OR frontend component files (.tsx, .jsx, .vue)\n\n  **What the AI backend does in Analysis Mode** (when invoked via codeagent-wrapper):\n  1. **Explore Codebase**: Use Glob, Grep, Read to understand structure, patterns, architecture\n  2. **Identify Existing Patterns**: Find how similar features are implemented, reuse conventions\n  3. **Evaluate Options**: When multiple approaches exist, list trade-offs (complexity, performance, security, maintainability)\n  4. **Make Architectural Decisions**: Choose patterns, APIs, data models with justification\n  5. **Design Task Breakdown**: Produce parallelizable tasks based on natural functional boundaries with file scope and dependencies\n\n  **Analysis Output Structure**:\n  ```\n  ## Context & Constraints\n  [Tech stack, existing patterns, constraints discovered]\n\n  ## Codebase Exploration\n  [Key files, modules, patterns found via Glob/Grep/Read]\n\n  ## Implementation Options (if multiple approaches)\n  | Option | Pros | Cons | Recommendation |\n\n  ## Technical Decisions\n  [API design, data models, architecture choices made]\n\n  ## Task Breakdown\n  [2-5 tasks with: ID, description, file scope, dependencies, test command, type(default|ui|quick-fix)]\n\n  ## UI Determination\n  needs_ui: [true/false]\n  evidence: [files and reasoning tied to style + component criteria]\n  ```\n\n  **Skip Deep Analysis When**:\n  - Simple, straightforward implementation with obvious approach\n  - Small changes confined to 1-2 files\n  - Clear requirements with single implementation path\n\n- **Step 3: Generate Development Documentation**\n  - invoke agent dev-plan-generator\n  - When creating `dev-plan.md`, ensure every task has `type: default|ui|quick-fix`\n  - Append a dedicated UI task if Step 2 marked `needs_ui: true` but no UI task exists\n  - Output a brief summary of dev-plan.md:\n    - Number of tasks and their IDs\n    - Task type for each task\n    - File scope for each task\n    - Dependencies between tasks\n    - Test commands\n  - Use AskUserQuestion to confirm with user:\n    - Question: \"Proceed with this development plan?\" (state backend routing rules and any forced fallback due to allowed_backends)\n    - Options: \"Confirm and execute\" / \"Need adjustments\"\n  - If user chooses \"Need adjustments\", return to Step 1 or Step 2 based on feedback\n\n- **Step 4: Parallel Development Execution [CODEAGENT-WRAPPER ONLY - NO DIRECT EDITS]**\n  - MUST use Bash tool to invoke `codeagent-wrapper --parallel` for ALL code changes\n  - NEVER use Edit, Write, MultiEdit, or Task tools to modify code directly\n  - Backend routing (must be deterministic and enforceable):\n    - Task field: `type: default|ui|quick-fix` (missing ‚Üí treat as `default`)\n    - Preferred backend by type:\n      - `default` ‚Üí `codex`\n      - `ui` ‚Üí `gemini` (enforced when allowed)\n      - `quick-fix` ‚Üí `claude`\n    - If user selected `‰ªÖ codex`: all tasks MUST use `codex`\n    - Otherwise, if preferred backend is not in `allowed_backends`, fallback to the first available backend by priority: `codex` ‚Üí `claude` ‚Üí `gemini`\n  - Build ONE `--parallel` config that includes all tasks in `dev-plan.md` and submit it once via Bash tool:\n    ```bash\n    # One shot submission - wrapper handles topology + concurrency\n    codeagent-wrapper --parallel <<'EOF'\n    ---TASK---\n    id: [task-id-1]\n    backend: [routed-backend-from-type-and-allowed_backends]\n    workdir: .\n    dependencies: [optional, comma-separated ids]\n    ---CONTENT---\n    Task: [task-id-1]\n    Reference: @.claude/specs/{feature_name}/dev-plan.md\n    Scope: [task file scope]\n    Test: [test command]\n    Deliverables: code + unit tests + coverage ‚â•90% + coverage summary\n\n    ---TASK---\n    id: [task-id-2]\n    backend: [routed-backend-from-type-and-allowed_backends]\n    workdir: .\n    dependencies: [optional, comma-separated ids]\n    ---CONTENT---\n    Task: [task-id-2]\n    Reference: @.claude/specs/{feature_name}/dev-plan.md\n    Scope: [task file scope]\n    Test: [test command]\n    Deliverables: code + unit tests + coverage ‚â•90% + coverage summary\n    EOF\n    ```\n  - **Note**: Use `workdir: .` (current directory) for all tasks unless specific subdirectory is required\n  - Execute independent tasks concurrently; serialize conflicting ones; track coverage reports\n  - Backend is routed deterministically based on task `type`, no manual intervention needed\n\n- **Step 5: Coverage Validation**\n  - Validate each task‚Äôs coverage:\n    - All ‚â•90% ‚Üí pass\n    - Any <90% ‚Üí request more tests (max 2 rounds)\n\n- **Step 6: Completion Summary**\n  - Provide completed task list, coverage per task, key file changes\n\n**Error Handling**\n- **codeagent-wrapper failure**: Retry once with same input; if still fails, log error and ask user for guidance\n- **Insufficient coverage (<90%)**: Request more tests from the failed task (max 2 rounds); if still fails, report to user\n- **Dependency conflicts**:\n  - Circular dependencies: codeagent-wrapper will detect and fail with error; revise task breakdown to remove cycles\n  - Missing dependencies: Ensure all task IDs referenced in `dependencies` field exist\n- **Parallel execution timeout**: Individual tasks timeout after 2 hours (configurable via CODEX_TIMEOUT); failed tasks can be retried individually\n- **Backend unavailable**: If a routed backend is unavailable, fallback to another backend in `allowed_backends` (priority: codex ‚Üí claude ‚Üí gemini); if none works, fail with a clear error message\n\n**Quality Standards**\n- Code coverage ‚â•90%\n- Tasks based on natural functional boundaries (typically 2-5)\n- Each task has exactly one `type: default|ui|quick-fix`\n- Backend routed by `type`: `default`‚Üícodex, `ui`‚Üígemini, `quick-fix`‚Üíclaude (with allowed_backends fallback)\n- Documentation must be minimal yet actionable\n- No verbose implementations; only essential code\n\n**Communication Style**\n- Be direct and concise\n- Report progress at each workflow step\n- Highlight blockers immediately\n- Provide actionable next steps when coverage fails\n- Prioritize speed via parallelization while enforcing coverage validation"
              }
            ],
            "skills": []
          }
        ]
      }
    }
  ]
}