{
  "owner": {
    "id": "buzzdan",
    "display_name": "Dan Mordechay",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/18007791?u=4c179fbaa76dc78c58c9cf4b16f2fc6a6b359db6&v=4",
    "url": "https://github.com/buzzdan",
    "bio": "Go Backend developer @weka.\r\nyou can also find me at @danfromisrael",
    "stats": {
      "total_repos": 1,
      "total_plugins": 2,
      "total_commands": 5,
      "total_skills": 12,
      "total_stars": 2,
      "total_forks": 1
    }
  },
  "repos": [
    {
      "full_name": "buzzdan/ai-coding-rules",
      "url": "https://github.com/buzzdan/ai-coding-rules",
      "description": "ai coding rules for agents",
      "homepage": null,
      "signals": {
        "stars": 2,
        "forks": 1,
        "pushed_at": "2026-01-07T12:57:19Z",
        "created_at": "2025-10-13T09:02:48Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 687
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 161
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 18648
        },
        {
          "path": "coding_rules.md",
          "type": "blob",
          "size": 14521
        },
        {
          "path": "coding_rules_ts_react.md",
          "type": "blob",
          "size": 22422
        },
        {
          "path": "go-linter-driven-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "go-linter-driven-development/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "go-linter-driven-development/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 514
        },
        {
          "path": "go-linter-driven-development/README.md",
          "type": "blob",
          "size": 39902
        },
        {
          "path": "go-linter-driven-development/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "go-linter-driven-development/agents/go-code-reviewer.md",
          "type": "blob",
          "size": 12946
        },
        {
          "path": "go-linter-driven-development/agents/quality-analyzer.md",
          "type": "blob",
          "size": 19706
        },
        {
          "path": "go-linter-driven-development/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "go-linter-driven-development/commands/go-ldd-analyze.md",
          "type": "blob",
          "size": 5214
        },
        {
          "path": "go-linter-driven-development/commands/go-ldd-autopilot.md",
          "type": "blob",
          "size": 830
        },
        {
          "path": "go-linter-driven-development/commands/go-ldd-quickfix.md",
          "type": "blob",
          "size": 1239
        },
        {
          "path": "go-linter-driven-development/commands/go-ldd-review.md",
          "type": "blob",
          "size": 1188
        },
        {
          "path": "go-linter-driven-development/commands/go-ldd-status.md",
          "type": "blob",
          "size": 1008
        },
        {
          "path": "go-linter-driven-development/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "go-linter-driven-development/skills/code-designing",
          "type": "tree",
          "size": null
        },
        {
          "path": "go-linter-driven-development/skills/code-designing/SKILL.md",
          "type": "blob",
          "size": 7987
        },
        {
          "path": "go-linter-driven-development/skills/code-designing/reference.md",
          "type": "blob",
          "size": 11969
        },
        {
          "path": "go-linter-driven-development/skills/documentation",
          "type": "tree",
          "size": null
        },
        {
          "path": "go-linter-driven-development/skills/documentation/SKILL.md",
          "type": "blob",
          "size": 7784
        },
        {
          "path": "go-linter-driven-development/skills/documentation/reference.md",
          "type": "blob",
          "size": 9811
        },
        {
          "path": "go-linter-driven-development/skills/linter-driven-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "go-linter-driven-development/skills/linter-driven-development/SKILL.md",
          "type": "blob",
          "size": 7789
        },
        {
          "path": "go-linter-driven-development/skills/linter-driven-development/reference.md",
          "type": "blob",
          "size": 11148
        },
        {
          "path": "go-linter-driven-development/skills/pre-commit-review",
          "type": "tree",
          "size": null
        },
        {
          "path": "go-linter-driven-development/skills/pre-commit-review/SKILL.md",
          "type": "blob",
          "size": 12295
        },
        {
          "path": "go-linter-driven-development/skills/pre-commit-review/examples.md",
          "type": "blob",
          "size": 23082
        },
        {
          "path": "go-linter-driven-development/skills/pre-commit-review/reference.md",
          "type": "blob",
          "size": 31282
        },
        {
          "path": "go-linter-driven-development/skills/refactoring",
          "type": "tree",
          "size": null
        },
        {
          "path": "go-linter-driven-development/skills/refactoring/SKILL.md",
          "type": "blob",
          "size": 18975
        },
        {
          "path": "go-linter-driven-development/skills/refactoring/code-design-ref.md",
          "type": "blob",
          "size": 3497
        },
        {
          "path": "go-linter-driven-development/skills/refactoring/examples.md",
          "type": "blob",
          "size": 51227
        },
        {
          "path": "go-linter-driven-development/skills/refactoring/reference.md",
          "type": "blob",
          "size": 17651
        },
        {
          "path": "go-linter-driven-development/skills/testing",
          "type": "tree",
          "size": null
        },
        {
          "path": "go-linter-driven-development/skills/testing/SKILL.md",
          "type": "blob",
          "size": 12511
        },
        {
          "path": "go-linter-driven-development/skills/testing/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "go-linter-driven-development/skills/testing/examples/grpc-bufconn.md",
          "type": "blob",
          "size": 9908
        },
        {
          "path": "go-linter-driven-development/skills/testing/examples/httptest-dsl.md",
          "type": "blob",
          "size": 6393
        },
        {
          "path": "go-linter-driven-development/skills/testing/examples/integration-patterns.md",
          "type": "blob",
          "size": 6131
        },
        {
          "path": "go-linter-driven-development/skills/testing/examples/jsonrpc-mock.md",
          "type": "blob",
          "size": 8004
        },
        {
          "path": "go-linter-driven-development/skills/testing/examples/nats-in-memory.md",
          "type": "blob",
          "size": 4838
        },
        {
          "path": "go-linter-driven-development/skills/testing/examples/system-patterns.md",
          "type": "blob",
          "size": 6963
        },
        {
          "path": "go-linter-driven-development/skills/testing/examples/test-organization.md",
          "type": "blob",
          "size": 6094
        },
        {
          "path": "go-linter-driven-development/skills/testing/examples/victoria-metrics.md",
          "type": "blob",
          "size": 17556
        },
        {
          "path": "go-linter-driven-development/skills/testing/reference.md",
          "type": "blob",
          "size": 17584
        },
        {
          "path": "ts-react-linter-driven-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "ts-react-linter-driven-development/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "ts-react-linter-driven-development/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 600
        },
        {
          "path": "ts-react-linter-driven-development/README.md",
          "type": "blob",
          "size": 22166
        },
        {
          "path": "ts-react-linter-driven-development/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "ts-react-linter-driven-development/skills/component-designing",
          "type": "tree",
          "size": null
        },
        {
          "path": "ts-react-linter-driven-development/skills/component-designing/SKILL.md",
          "type": "blob",
          "size": 12512
        },
        {
          "path": "ts-react-linter-driven-development/skills/component-designing/reference.md",
          "type": "blob",
          "size": 21138
        },
        {
          "path": "ts-react-linter-driven-development/skills/documentation",
          "type": "tree",
          "size": null
        },
        {
          "path": "ts-react-linter-driven-development/skills/documentation/SKILL.md",
          "type": "blob",
          "size": 12605
        },
        {
          "path": "ts-react-linter-driven-development/skills/documentation/reference.md",
          "type": "blob",
          "size": 12638
        },
        {
          "path": "ts-react-linter-driven-development/skills/linter-driven-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "ts-react-linter-driven-development/skills/linter-driven-development/SKILL.md",
          "type": "blob",
          "size": 8687
        },
        {
          "path": "ts-react-linter-driven-development/skills/linter-driven-development/reference.md",
          "type": "blob",
          "size": 13686
        },
        {
          "path": "ts-react-linter-driven-development/skills/pre-commit-review",
          "type": "tree",
          "size": null
        },
        {
          "path": "ts-react-linter-driven-development/skills/pre-commit-review/SKILL.md",
          "type": "blob",
          "size": 14233
        },
        {
          "path": "ts-react-linter-driven-development/skills/pre-commit-review/reference.md",
          "type": "blob",
          "size": 12565
        },
        {
          "path": "ts-react-linter-driven-development/skills/refactoring",
          "type": "tree",
          "size": null
        },
        {
          "path": "ts-react-linter-driven-development/skills/refactoring/SKILL.md",
          "type": "blob",
          "size": 16210
        },
        {
          "path": "ts-react-linter-driven-development/skills/refactoring/reference.md",
          "type": "blob",
          "size": 30807
        },
        {
          "path": "ts-react-linter-driven-development/skills/testing",
          "type": "tree",
          "size": null
        },
        {
          "path": "ts-react-linter-driven-development/skills/testing/SKILL.md",
          "type": "blob",
          "size": 14260
        },
        {
          "path": "ts-react-linter-driven-development/skills/testing/reference.md",
          "type": "blob",
          "size": 26002
        }
      ],
      "marketplace": {
        "name": "ai-coding-rules",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "Dan Mordechay"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "go-linter-driven-development",
            "description": "Linter-driven development workflow for Go with 6 specialized skills: meta orchestrator, design, testing, refactoring, review, and documentation",
            "source": "./go-linter-driven-development",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add buzzdan/ai-coding-rules",
              "/plugin install go-linter-driven-development@ai-coding-rules"
            ],
            "signals": {
              "stars": 2,
              "forks": 1,
              "pushed_at": "2026-01-07T12:57:19Z",
              "created_at": "2025-10-13T09:02:48Z",
              "license": null
            },
            "commands": [
              {
                "name": "/go-ldd-analyze",
                "description": "Run quality analysis only - invoke quality-analyzer agent and display combined report without auto-fixing",
                "path": "go-linter-driven-development/commands/go-ldd-analyze.md",
                "frontmatter": {
                  "name": "go-ldd-analyze",
                  "description": "Run quality analysis only - invoke quality-analyzer agent and display combined report without auto-fixing",
                  "argument-hint": "[file_pattern]",
                  "allowed-tools": [
                    "Read",
                    "Grep",
                    "Bash",
                    "Task"
                  ]
                },
                "content": "Run comprehensive quality analysis with intelligent combining of test results, linter findings, and code review feedback.\n\n> **üîç READ-ONLY COMMAND**\n> This command performs analysis only and makes NO changes to your code.\n> For auto-fix capability, use `/go-ldd-quickfix` instead.\n\nExecute these steps:\n\n## Step 1: Discover Project Commands\n\nSearch project documentation to find test and lint commands:\n\n1. **Read project files** in order of preference:\n   - `CLAUDE.md` (project-specific instructions)\n   - `README.md` (project documentation)\n   - `Makefile` (look for `test:` and `lint:` targets)\n   - `Taskfile.yaml` (look for `test:` and `lintwithfix:` tasks)\n   - `.golangci.yaml` (linter configuration)\n\n2. **Extract commands**:\n   - **Test command**: Look for patterns like:\n     - `go test ./... -v -cover`\n     - `make test`\n     - `task test`\n   - **Lint command**: Look for patterns like:\n     - `golangci-lint run --fix`\n     - `golangci-lint run --config .golangci.yaml --new-from-rev=origin/dev --fix ./...`\n     - `make lint`\n     - `task lintwithfix`\n\n3. **Fallback to defaults** if not found:\n   - Test: `go test ./...`\n   - Lint: `golangci-lint run --fix`\n\n## Step 2: Identify Files to Analyze\n\n!`git status --porcelain`\n!`git diff --name-only --diff-filter=ACMR HEAD`\n\n**If arguments provided** (`$ARGUMENTS`):\n- Use as file pattern (e.g., `./pkg/parser/*.go`, `./pkg/parser/`)\n- Validate files exist with glob/ls\n\n**Otherwise** (default behavior):\n- Use git to find changed files:\n  ```bash\n  git diff --name-only --diff-filter=ACMR HEAD | grep '\\.go$'\n  ```\n- If no git repository or no changes, analyze all `.go` files in the project (excluding vendor/, testdata/)\n\n## Step 3: Invoke Quality Analyzer Agent\n\nCall the quality-analyzer agent with discovered commands and files:\n\n```\nTask(subagent_type: \"quality-analyzer\")\n\nPrompt:\n\"Analyze code quality for this Go project.\n\nMode: full\n\nProject commands:\n- Test: [discovered test command]\n- Lint: [discovered lint command]\n\nFiles to analyze:\n[list of changed .go files, one per line]\n\nRun all quality gates in parallel and return combined analysis.\"\n```\n\n## Step 4: Display Report\n\nThe agent will return a structured report with one of four statuses:\n\n**TOOLS_UNAVAILABLE**: Display the report and suggest installing missing tools\n**TEST_FAILURE**: Display test failures and suggest fixing them before quality analysis\n**ISSUES_FOUND**: Display combined report with overlapping issues analysis and prioritized fix order\n**CLEAN_STATE**: Display success message - all quality gates passed\n\n## Report Format\n\nThe agent returns:\n- ‚úÖ/‚ùå **Tests**: Pass/fail status with coverage\n- ‚úÖ/‚ùå **Linter**: Clean/errors count\n- ‚úÖ/‚ö†Ô∏è **Review**: Clean/findings (bugs, design debt, readability debt, polish)\n- üéØ **Overlapping Issues**: Multiple issues at same file:line with root cause analysis\n- üìã **Isolated Issues**: Single issues that don't overlap\n- üî¢ **Prioritized Fix Order**: Which issues to tackle first based on impact\n\n## Example Usage\n\n```bash\n# Analyze all changed files (default)\n/go-ldd-analyze\n\n# Analyze specific package\n/go-ldd-analyze ./pkg/parser/\n\n# Analyze specific file\n/go-ldd-analyze ./pkg/parser/parser.go\n```\n\nThis will:\n1. Discover test and lint commands from your project docs\n2. Find changed Go files from git\n3. Run tests, linter, and code review in parallel\n4. Display intelligent combined analysis with overlapping issue detection\n\n## Use Cases\n\n- ‚úÖ Quick quality check before committing\n- ‚úÖ Understand what issues exist without making changes\n- ‚úÖ Get intelligent combined view of tests + linter + review findings\n- ‚úÖ See overlapping issues with root cause analysis\n- ‚úÖ Identify high-impact fixes (multiple issues at same location)\n\n## Comparison with Other Commands\n\n| Command | Purpose | Auto-Fix | Agent |\n|---------|---------|----------|-------|\n| `/go-ldd-autopilot` | Complete workflow (Phase 1-6) | ‚úÖ Yes | No |\n| `/go-ldd-quickfix` | Quality gates loop with auto-fix | ‚úÖ Yes | No |\n| `/go-ldd-review` | Final verification, no auto-fix | ‚ùå No | No |\n| `/go-ldd-analyze` | Quality analysis with intelligent combining | ‚ùå No | ‚úÖ Yes |\n| `/go-ldd-status` | Show workflow status | N/A | No |\n\n## Key Benefits\n\n1. **Parallel Execution**: Runs tests, linter, and code review simultaneously\n2. **Intelligent Combining**: Identifies overlapping issues at same file:line\n3. **Root Cause Analysis**: Explains why multiple issues occur at same location\n4. **Prioritized Fixes**: Suggests fix order based on impact (issues resolved)\n5. **Read-Only**: No auto-fix, just analysis and reporting\n6. **Autonomous**: Discovers commands automatically from project docs\n\n## Notes\n\n- This command is equivalent to running the quality-analyzer agent standalone\n- For auto-fix capability, use `/go-ldd-quickfix` instead\n- For final commit-ready verification, use `/go-ldd-review` instead\n- For complete workflow with implementation, use `/go-ldd-autopilot` instead"
              },
              {
                "name": "/go-ldd-autopilot",
                "description": "Start complete linter-driven autopilot workflow (Phase 1-5)",
                "path": "go-linter-driven-development/commands/go-ldd-autopilot.md",
                "frontmatter": {
                  "name": "go-ldd-autopilot",
                  "description": "Start complete linter-driven autopilot workflow (Phase 1-5)",
                  "argument-hint": "",
                  "allowed-tools": [
                    "Skill(go-linter-driven-development:linter-driven-development)"
                  ]
                },
                "content": "Invoke the @linter-driven-development skill to run the complete autopilot workflow from design through commit-ready.\n\n‚è±Ô∏è **Estimated Duration**: 5-15 minutes (depends on feature complexity and issues found)\n\nThe skill will automatically:\n1. Run Pre-Flight Check (detect intent, find commands, verify Go project)\n2. Execute all 5 phases with 2 quality gates\n3. Use parallel analysis (tests + linter + go-code-reviewer agent)\n4. Generate intelligent combined reports\n5. Auto-fix all issues iteratively\n6. Prepare commit-ready summary\n\nThis is the full workflow - use for implementing features or fixes from start to finish."
              },
              {
                "name": "/go-ldd-quickfix",
                "description": "Run quality gates loop until all green (tests+linter+review ‚Üí fix ‚Üí repeat)",
                "path": "go-linter-driven-development/commands/go-ldd-quickfix.md",
                "frontmatter": {
                  "name": "go-ldd-quickfix",
                  "description": "Run quality gates loop until all green (tests+linter+review ‚Üí fix ‚Üí repeat)",
                  "argument-hint": "[file_pattern]",
                  "allowed-tools": [
                    "Skill(go-linter-driven-development:linter-driven-development)"
                  ]
                },
                "content": "Execute the quality gates loop for already-implemented code that needs cleanup.\n\n‚è±Ô∏è **Estimated Duration**: 2-5 minutes (depends on number of issues found)\n\nRun these phases from @linter-driven-development skill:\n\n**Phase 2**: Parallel Analysis\n- Discover project test/lint commands\n- Launch 3 tools simultaneously: tests, linter, go-code-reviewer agent\n- Wait for all results\n\n**Phase 3**: Intelligent Combined Report\n- Merge findings from linter + review\n- Identify overlapping issues at same file:line\n- Analyze root causes\n- Generate unified fix strategies\n- Prioritize: Impact √ó Effort √ó Risk\n\n**Phase 4**: Iterative Fix Loop\n- Apply fixes using @refactoring skill (auto, no confirmation)\n- Re-verify with parallel analysis (incremental review mode)\n- Repeat until all green\n\n**Loop until**:\n‚úÖ Tests pass | ‚úÖ Linter clean | ‚úÖ Review clean\n\nUse this when code is already written but needs to pass quality gates.\nSkip the implementation phase (Phase 1) and go straight to fixing issues."
              },
              {
                "name": "/go-ldd-review",
                "description": "Check if code is commit-ready (final verification, no auto-fix)",
                "path": "go-linter-driven-development/commands/go-ldd-review.md",
                "frontmatter": {
                  "name": "go-ldd-review",
                  "description": "Check if code is commit-ready (final verification, no auto-fix)",
                  "argument-hint": "[file_pattern]",
                  "allowed-tools": [
                    "Read",
                    "Grep",
                    "Bash",
                    "Task"
                  ]
                },
                "content": "Run final verification checks **without** the auto-fix loop.\n\n> **üîç READ-ONLY COMMAND**\n> This command performs verification only and makes NO changes to your code.\n> For auto-fix capability, use `/go-ldd-quickfix` instead.\n\n!`git status --porcelain`\n!`git diff --stat`\n\nExecute these steps:\n\n1. **Discover commands** from project docs (README, CLAUDE.md, Makefile, etc.)\n2. **Run in parallel**:\n   - Tests: Bash([PROJECT_TEST_COMMAND])\n   - Linter: Bash([PROJECT_LINT_COMMAND])\n   - Review: Task(subagent_type: \"go-code-reviewer\") with mode: full\n3. **Generate commit readiness report**:\n   - ‚úÖ/‚ùå Tests: [pass/fail] + coverage\n   - ‚úÖ/‚ùå Linter: [clean/errors]\n   - ‚úÖ/‚ùå Review: [clean/findings]\n   - üìù Files in scope: [list with +/- lines]\n   - üí° Suggested commit message\n\n**Does NOT auto-fix anything** - just reports current state.\n\nUse when you want to verify code is ready without making changes.\nEquivalent to Phase 2 (Parallel Analysis) + Gate 2 (Final Verification) only."
              },
              {
                "name": "/go-ldd-status",
                "description": "Show current workflow status and progress",
                "path": "go-linter-driven-development/commands/go-ldd-status.md",
                "frontmatter": {
                  "name": "go-ldd-status",
                  "description": "Show current workflow status and progress",
                  "argument-hint": "",
                  "allowed-tools": [
                    "Read",
                    "Bash(git *)"
                  ]
                },
                "content": "!`git status --porcelain`\n!`git diff --stat`\n\nDisplay current implementation status:\n\nüìç Current Context:\n  - Active plan: [file path or \"conversation\"]\n  - Current step: [step number]\n  - Phase: [design/testing/linting/refactoring/review/docs/commit]\n\nüìä Last Results:\n  Tests: [status + coverage]\n  Linter: [status + error count]\n  Review: [status + finding count]\n\nüìù Files Modified:\n  [list with +/- lines]\n\nüéØ Next Action:\n  [What happens next in the workflow]\n\n## Suggested Next Steps\n\nBased on current status:\n- **Tests failing?** ‚Üí Fix tests, then run `/go-ldd-analyze`\n- **Linter errors?** ‚Üí Run `/go-ldd-quickfix` for auto-fix loop\n- **Code complete?** ‚Üí Run `/go-ldd-review` for commit readiness check\n- **Starting new work?** ‚Üí Run `/go-ldd-autopilot` for full workflow\n\nPerfect for: \"where are we?\", \"what's the status?\", \"what's next?\""
              }
            ],
            "skills": [
              {
                "name": "code-designing",
                "description": "Domain type design and architectural planning for Go code.\nUse when planning new features, designing self-validating types, preventing primitive obsession, or when refactoring reveals need for new types.\nFocuses on vertical slice architecture and type safety.\n",
                "path": "go-linter-driven-development/skills/code-designing/SKILL.md",
                "frontmatter": {
                  "name": "code-designing",
                  "description": "Domain type design and architectural planning for Go code.\nUse when planning new features, designing self-validating types, preventing primitive obsession, or when refactoring reveals need for new types.\nFocuses on vertical slice architecture and type safety.\n",
                  "allowed-tools": [
                    "Skill(go-linter-driven-development:testing)"
                  ]
                },
                "content": "<objective>\nDomain type design and architectural planning for Go code.\nUse when planning new features or identifying need for new types during refactoring.\n\n**Reference**: See `reference.md` for complete design principles and examples.\n</objective>\n\n<quick_start>\n1. **Analyze Architecture**: Check for vertical vs horizontal slicing\n2. **Understand Domain**: Identify problem domain, concepts, invariants\n3. **Identify Core Types**: Find primitives that need type wrappers\n4. **Design Self-Validating Types**: Create types with validating constructors\n5. **Plan Package Structure**: Vertical slices by feature\n6. **Output Design Plan**: Present structured plan before implementation\n\nReady to implement? Use @testing skill for test structure.\n</quick_start>\n\n<when_to_use>\n- Planning a new feature (before writing code)\n- Refactoring reveals need for new types (complexity extraction)\n- Linter failures suggest types should be introduced\n- When you need to think through domain modeling\n</when_to_use>\n\n<purpose>\nDesign clean, self-validating types that:\n- Prevent primitive obsession\n- Ensure type safety\n- Make validation explicit\n- Follow vertical slice architecture\n</purpose>\n\n<workflow>\n\n<architecture_pattern_analysis priority=\"FIRST_STEP\">\n**Default: Always use vertical slice architecture** (feature-first, not layer-first).\n\nScan codebase structure:\n- **Vertical slicing**: `internal/feature/{handler,service,repository,models}.go`\n- **Horizontal layering**: `internal/{handlers,services,domain}/feature.go`\n\n<decision_flow>\n1. **Pure vertical** ‚Üí Continue pattern, implement as `internal/[new-feature]/`\n2. **Pure horizontal** ‚Üí Propose: Start migration with `docs/architecture/vertical-slice-migration.md`, implement new feature as first vertical slice\n3. **Mixed (migrating)** ‚Üí Check for migration docs, continue pattern as vertical slice\n</decision_flow>\n\n**Always ask user approval with options:**\n- Option A: Vertical slice (recommended for cohesion/maintainability)\n- Option B: Match existing pattern (if time-constrained)\n- Acknowledge: Time pressure, team decisions, consistency needs are valid\n\n**If migration needed**, create/update `docs/architecture/vertical-slice-migration.md`:\n```markdown\n# Vertical Slice Migration Plan\n## Current State: [horizontal/mixed]\n## Target: Vertical slices in internal/[feature]/\n## Strategy: New features vertical, migrate existing incrementally\n## Progress: [x] [new-feature] (this PR), [ ] existing features\n```\n\nSee reference.md section #3 for detailed patterns.\n</architecture_pattern_analysis>\n\n<understand_domain>\n- What is the problem domain?\n- What are the main concepts/entities?\n- What are the invariants and rules?\n- How does this fit into existing architecture?\n</understand_domain>\n\n<identify_core_types>\nAsk for each concept:\n- Is this currently a primitive (string, int, float)?\n- Does it have validation rules?\n- Does it have behavior beyond simple data?\n- Is it used across multiple places?\n\nIf yes to any ‚Üí Consider creating a type\n</identify_core_types>\n\n<design_self_validating_types>\nFor each type:\n```go\n// Type definition\ntype TypeName underlyingType\n\n// Validating constructor\nfunc NewTypeName(input underlyingType) (TypeName, error) {\n    // Validate input\n    if /* validation fails */ {\n        return zero, errors.New(\"why it failed\")\n    }\n    return TypeName(input), nil\n}\n\n// Methods on type (if behavior needed)\nfunc (t TypeName) SomeMethod() result {\n    // Type-specific logic\n}\n```\n</design_self_validating_types>\n\n<plan_package_structure>\n- **Vertical slices**: Group by feature, not layer\n- Each feature gets its own package\n- Within package: separate by role (service, repository, handler)\n\nGood structure:\n```\nuser/\n‚îú‚îÄ‚îÄ user.go          # Domain types\n‚îú‚îÄ‚îÄ service.go       # Business logic\n‚îú‚îÄ‚îÄ repository.go    # Persistence\n‚îî‚îÄ‚îÄ handler.go       # HTTP/API\n```\n\nBad structure:\n```\ndomain/user.go\nservices/user_service.go\nrepository/user_repository.go\n```\n</plan_package_structure>\n\n<design_orchestrating_types>\nFor types that coordinate others:\n- Make fields private\n- Validate dependencies in constructor\n- No nil checks in methods (constructor guarantees validity)\n\n```go\ntype Service struct {\n    repo        Repository  // private\n    notifier    Notifier    // private\n}\n\nfunc NewService(repo Repository, notifier Notifier) (*Service, error) {\n    if repo == nil {\n        return nil, errors.New(\"repo required\")\n    }\n    if notifier == nil {\n        return nil, errors.New(\"notifier required\")\n    }\n    return &Service{\n        repo:     repo,\n        notifier: notifier,\n    }, nil\n}\n\n// Methods can trust fields are valid\nfunc (s *Service) DoSomething() error {\n    // No nil checks needed\n    return s.repo.Save(...)\n}\n```\n</design_orchestrating_types>\n\n<review_against_principles>\nCheck design against (see reference.md):\n- [ ] No primitive obsession\n- [ ] Types are self-validating\n- [ ] Vertical slice architecture\n- [ ] Types designed around intent, not just shape\n- [ ] Clear separation of concerns\n</review_against_principles>\n\n</workflow>\n\n<output_format>\nAfter design phase:\n\n```\nDESIGN PLAN\n\nFeature: [Feature Name]\n\nCore Domain Types:\n- UserID (string) - Self-validating, prevents empty IDs\n- Email (string) - Self-validating, RFC 5322 validation\n- Age (int) - Self-validating, range 0-150\n\nOrchestrating Types:\n- UserService - Coordinates user operations\n   Dependencies: Repository, Notifier\n   Methods: CreateUser, GetUser, UpdateUser\n\nPackage Structure:\nuser/\n  ‚îú‚îÄ‚îÄ user.go          # UserID, Email, Age, User\n  ‚îú‚îÄ‚îÄ service.go       # UserService\n  ‚îú‚îÄ‚îÄ repository.go    # Repository interface + implementations\n  ‚îú‚îÄ‚îÄ notifier.go      # Notifier interface + implementations\n  ‚îî‚îÄ‚îÄ handler.go       # HTTP handlers\n\nDesign Decisions:\n- UserID is custom type to prevent passing empty/invalid IDs\n- Email validation centralized in NewEmail constructor\n- Vertical slice keeps all user logic in one package\n- Repository as interface allows multiple backends (Postgres, in-memory for tests)\n\nIntegration Points:\n- Consumed by: HTTP API (/users endpoints)\n- Depends on: Database, Email service\n- Events: UserCreated event published after creation\n\nNext Steps:\n1. Create types with validating constructors\n2. Write unit tests for each type\n3. Implement UserService\n4. Write integration tests\n\nReady to implement? Use @testing skill for test structure.\n```\n</output_format>\n\n<key_principles>\nSee reference.md for detailed principles:\n- Primitive obsession prevention (Yoke design strategy)\n- Self-validating types\n- Vertical slice architecture\n- Types around intent and behavior, not just shape\n- Single responsibility per type\n</key_principles>\n\n<pre_code_review>\nBefore writing code, ask:\n- Can logic be moved into smaller custom types?\n- Is this type designed around intent and behavior?\n- Have I avoided primitive obsession?\n- Is validation in the right place (constructor)?\n- Does this follow vertical slice architecture?\n\nOnly after satisfactory answers, proceed to implementation.\n\nSee reference.md for complete design principles and examples.\n</pre_code_review>\n\n<success_criteria>\nDesign phase is complete when ALL of the following are true:\n\n- [ ] Architecture pattern analyzed (vertical/horizontal/mixed)\n- [ ] Core domain types identified with validation rules\n- [ ] Self-validating type design documented\n- [ ] Package structure follows vertical slice pattern\n- [ ] Design decisions documented with rationale\n- [ ] Pre-code review questions answered satisfactorily\n- [ ] Design plan output presented to user\n</success_criteria>"
              },
              {
                "name": "documentation",
                "description": "Creates comprehensive feature documentation for humans and AI to understand features, resolve bugs, and extend functionality.\nUse after complete feature implementation (may span multiple commits).\nGenerates feature docs, updates godoc, and creates testable examples.\n",
                "path": "go-linter-driven-development/skills/documentation/SKILL.md",
                "frontmatter": {
                  "name": "documentation",
                  "description": "Creates comprehensive feature documentation for humans and AI to understand features, resolve bugs, and extend functionality.\nUse after complete feature implementation (may span multiple commits).\nGenerates feature docs, updates godoc, and creates testable examples.\n"
                },
                "content": "<objective>\nCreates comprehensive feature documentation for humans and AI to use for\nfuture bug resolution, feature extensions, and codebase understanding.\n\nThis is NOT a changelog - it's an introduction to the feature.\n\n**Reference**: See `reference.md` for complete documentation checklist and examples.\n</objective>\n\n<quick_start>\n1. **Understand feature scope** - Review all commits related to the feature\n2. **Analyze architecture** - Identify core types, data flow, design decisions\n3. **Generate docs/[feature-name].md** - Problem/solution, architecture, usage\n4. **Update package godoc** - Reflect feature's role\n5. **Add type documentation** - Explain purpose and design decisions\n6. **Create testable examples** - Example_* functions for complex types\n7. **Validate** - Can future you/AI understand the feature without reading all code?\n</quick_start>\n\n<when_to_use>\n- After a complete feature is implemented (may span multiple commits)\n- When adding significant new functionality to the codebase\n- NOT for: individual commits, bug fixes, minor refactors\n</when_to_use>\n\n<purpose>\nGenerate documentation that helps:\n- **Humans**: Understand what the feature does and how to use it\n- **AI**: Context for future bug fixes and feature extensions\n- **Team**: Onboarding and knowledge sharing\n</purpose>\n\n<workflow>\n\n<understand_feature_scope>\n- Review all commits related to the feature\n- Identify all modified/new files\n- Understand the problem being solved\n- Map out integration points with existing system\n</understand_feature_scope>\n\n<analyze_architecture>\n- Identify core domain types\n- Map data/control flow\n- Document design decisions (WHY choices were made)\n- Note patterns used (vertical slice, self-validating types, etc.)\n</analyze_architecture>\n\n<generate_documentation_artifacts>\n**Primary: Feature Documentation** (`docs/[feature-name].md`)\n- Problem & solution: What problem does this solve?\n- Architecture: How does it work?\n- Usage examples: How do I use it?\n- Integration: How does it fit into the system?\n\n**Secondary: Code Comments**\n- Update package godoc to reflect feature's role\n- Add godoc to key types explaining their purpose\n- Create testable examples (Example_* functions) when helpful\n</generate_documentation_artifacts>\n\n<validate_documentation>\n- Can someone unfamiliar understand the feature?\n- Can AI use this for bug fixes without reading all code?\n- Are design decisions clearly explained?\n- Are integration points documented?\n</validate_documentation>\n\n</workflow>\n\n<documentation_template>\n```markdown\n# [Feature Name]\n\n## Problem & Solution\n**Problem**: [What user/system problem does this solve?]\n\n**Solution**: [High-level approach taken]\n\n## Architecture\n\n### Core Types\n- `TypeName` - [Purpose, why it exists, key responsibility]\n- `AnotherType` - [Purpose, why it exists, key responsibility]\n\n### Design Decisions\n- **Why [Decision]**: [Rationale - connects to coding principles]\n  - Example: \"UserID is a custom type (not string) to avoid primitive obsession and ensure validation\"\n- **Why [Pattern]**: [Rationale]\n  - Example: \"Vertical slice structure groups all user logic together for easier maintenance\"\n\n### Data Flow\n[Step-by-step flow diagram or description]\nInput ‚Üí Validation ‚Üí Processing ‚Üí Storage ‚Üí Output\n\n### Integration Points\n- **Consumed by**: [What uses this feature]\n- **Depends on**: [What this feature uses]\n- **Events/Hooks**: [If applicable]\n\n## Usage\n\n### Basic Usage\n[Common case example with real, runnable code]\n\n### Advanced Scenarios\n[Complex case example showing edge cases]\n\n## Testing Strategy\n- **Unit Tests**: [What's covered, approach]\n- **Integration Tests**: [What's covered, approach]\n- **Coverage**: [Percentage and rationale]\n\n## Future Considerations\n- [Known limitations]\n- [Potential extensions]\n- [Related features that might be built on this]\n\n## References\n- [Related packages]\n- [External documentation]\n- [Design patterns used]\n```\n</documentation_template>\n\n<code_comment_guidelines>\n\n<package_level_documentation>\n```go\n// Package [name] provides [high-level purpose].\n//\n// [2-3 sentences about what problem this solves and how]\n//\n// Core types:\n//   - Type1: [Purpose]\n//   - Type2: [Purpose]\n//\n// Example usage:\n//   [Simple example showing typical usage]\n//\n// Design notes:\n//   - [Key design decision]\n//   - [Why certain patterns were used]\npackage name\n```\n</package_level_documentation>\n\n<type_level_documentation>\n```go\n// TypeName represents [domain concept].\n//\n// [Explain why this type exists - design decision]\n// [Explain validation rules if self-validating]\n// [Explain thread-safety if relevant]\n//\n// Example:\n//   id, err := NewUserID(\"usr_123\")\n//   if err != nil {\n//       // handle validation error\n//   }\ntype TypeName struct {\n    // ...\n}\n```\n</type_level_documentation>\n\n<testable_examples>\n```go\n// Example_TypeName_Usage demonstrates typical usage of TypeName.\nfunc Example_TypeName_Usage() {\n    id, _ := NewUserID(\"usr_123\")\n    fmt.Println(id)\n    // Output: usr_123\n}\n\n// Example_TypeName_Validation shows validation behavior.\nfunc Example_TypeName_Validation() {\n    _, err := NewUserID(\"\")\n    fmt.Println(err != nil)\n    // Output: true\n}\n```\n</testable_examples>\n\n</code_comment_guidelines>\n\n<output_format>\nAfter generating documentation:\n\n```\nFEATURE DOCUMENTATION COMPLETE\n\nFeature: [Feature Name]\n\nGenerated Artifacts:\n- docs/[feature-name].md (created)\n- Package godoc updated in [package]/[file].go\n- Type documentation for:\n   - TypeName1 ([file]:line)\n   - TypeName2 ([file]:line)\n- Testable examples:\n   - Example_TypeName1_Usage\n   - Example_TypeName2_Validation\n\nDocumentation covers:\n- Problem & Solution overview\n- Architecture with design decisions\n- Core types: [list]\n- Data flow diagram\n- Integration points: [list]\n- Usage examples (basic + advanced)\n- Testing strategy\n- Future considerations\n\nNext Steps:\n1. Review docs/[feature-name].md for accuracy\n2. Run `go test` to verify testable examples execute correctly\n3. Consider: Does this help future you/AI understand the feature?\n\nWould you like to:\n1. Commit documentation as-is\n2. Refine specific sections\n3. Add more examples\n4. Add testable examples to code\n```\n</output_format>\n\n<key_principles>\n**Documentation is NOT:**\n- A changelog of commits\n- Implementation details without context\n- API reference without explanation\n- Generated automatically without understanding\n\n**Documentation IS:**\n- Explaining WHY decisions were made\n- Providing context for future changes\n- Showing how pieces fit together\n- Helping both humans and AI understand intent\n\n**AI-Friendly Documentation:**\nWhen AI tools read this documentation for bug fixes or extensions:\n- They should understand the problem domain\n- They should know which types are central\n- They should understand design constraints\n- They should see how it integrates with the system\n\nSee reference.md for complete documentation checklist and examples.\n</key_principles>\n\n<success_criteria>\nDocumentation is complete when ALL of the following are true:\n\n- [ ] Feature doc created at docs/[feature-name].md with all sections\n- [ ] Package godoc updated to reflect feature's role\n- [ ] Key types have godoc explaining purpose and design decisions\n- [ ] Testable examples created for complex/core types\n- [ ] Someone unfamiliar can understand the feature\n- [ ] AI can use this for bug fixes without reading all code\n- [ ] Design decisions are clearly explained with rationale\n</success_criteria>"
              },
              {
                "name": "linter-driven-development",
                "description": "WHEN: User requests Go code work (implement, fix, add, refactor) or mentions @ldd in a Go project.\nOrchestrates complete workflow (Phases 1-5): design ‚Üí test ‚Üí implement ‚Üí lint ‚Üí fix ‚Üí documentation.\nAuto-triggers parallel quality analysis and iterative fix loop until code is commit-ready.\n",
                "path": "go-linter-driven-development/skills/linter-driven-development/SKILL.md",
                "frontmatter": {
                  "name": "linter-driven-development",
                  "description": "WHEN: User requests Go code work (implement, fix, add, refactor) or mentions @ldd in a Go project.\nOrchestrates complete workflow (Phases 1-5): design ‚Üí test ‚Üí implement ‚Üí lint ‚Üí fix ‚Üí documentation.\nAuto-triggers parallel quality analysis and iterative fix loop until code is commit-ready.\n",
                  "allowed-tools": [
                    "Skill(go-linter-driven-development:code-designing)",
                    "Skill(go-linter-driven-development:testing)",
                    "Skill(go-linter-driven-development:refactoring)",
                    "Skill(go-linter-driven-development:documentation)",
                    "Task"
                  ]
                },
                "content": "<objective>\nMeta orchestrator for Go implementation workflow: design ‚Üí test ‚Üí lint ‚Üí refactor ‚Üí review ‚Üí commit.\nUse for any commit: features, bug fixes, refactors.\n\n**Reference**: See `reference.md` for agent prompt templates, example reports, and output formats.\n</objective>\n\n<essential_principles>\n**Auto-Pilot Behavior**: This skill triggers automatically when Go code work is detected. After permission is granted, announce: **\"Using go-ldd workflow for this Go code work\"** and proceed to pre-flight check.\n\n**Trigger Conditions**:\n- User requests Go code work (implement, fix, add, refactor, update, change, modify, etc.)\n- User mentions \"ldd\" or \"@ldd\" (shorthand for linter-driven-development)\n- Working directory contains Go project (go.mod or .go files)\n</essential_principles>\n\n<quick_start>\n**Immediate Action**: Run Pre-Flight Check, then execute phases sequentially until commit-ready.\n\n1. **Pre-Flight**: Verify Go project, find test/lint commands, identify plan context\n2. **Phase 1**: Design types (if needed) ‚Üí Write tests ‚Üí Implement code\n3. **Phase 2**: Run quality-analyzer agent ‚Üí Route based on status\n4. **Phase 3**: Fix loop until CLEAN_STATE\n5. **Phase 4**: Documentation\n6. **Phase 5**: Present commit summary with options\n</quick_start>\n\n<workflow>\n\n<pre_flight_check>\n**ALWAYS RUN FIRST**\n\n<step name=\"confirm_intent\">\nLook for keywords: \"implement\", \"ready\", \"execute\", \"do\", \"start\", \"continue\", \"next\", \"build\", \"create\", \"step 1\", \"task 2\", or explicit \"@linter-driven-development\", \"@ldd\", \"ldd\"\n</step>\n\n<step name=\"verify_go_project\">\nCheck that `go.mod` exists in the project root or parent directories.\n</step>\n\n<step name=\"find_commands\">\n**Search locations** (in order):\n1. Project docs: `README.md`, `CLAUDE.md`, `agents.md`\n2. Build configs: `Makefile`, `Taskfile.yaml`, `.golangci.yaml`\n3. Git repository root for workspace-level commands\n\n**Extract commands**:\n- **Test command**: `go test`, `make test`, `task test`\n- **Lint command**: `golangci-lint run --fix`, `make lint`, `task lintwithfix`\n- **Fallbacks**: `go test ./...` and `golangci-lint run --fix`\n</step>\n\n<step name=\"identify_plan\">\nScan conversation history (last 50 messages) for step-by-step plan and which step to implement.\n</step>\n\n<decision_tree>\n<decision condition=\"All conditions met\" action=\"Announce 'Engaging autopilot mode for [description]' ‚Üí Phase 1\" />\n<decision condition=\"Unclear intent\" action=\"Ask for confirmation\" />\n<decision condition=\"No plan found\" action=\"Suggest creating plan first (offer @code-designing)\" />\n<decision condition=\"Not Go project\" action=\"Explain limitation\" />\n</decision_tree>\n</pre_flight_check>\n\n<phase name=\"1\" title=\"Implementation Foundation\">\n**Design Architecture** (if new types/functions needed):\n- Invoke @code-designing skill\n- Output: Type design plan with self-validating domain types\n\n**Write Tests First**:\n- Invoke @testing skill for guidance\n- Write table-driven tests or testify suites\n- Target: 100% coverage on new leaf types\n\n**Implement Code**:\n- Follow coding principles from coding_rules.md\n- Keep functions <50 LOC, max 2 nesting levels\n- Use self-validating types, prevent primitive obsession\n</phase>\n\n<phase name=\"2\" title=\"Quality Analysis\">\n**Invoke quality-analyzer agent** for parallel quality analysis.\nSee `reference.md` ‚Üí \"Agent Prompt Templates\" for full prompt.\n\nThe agent automatically:\n- Executes tests, linter, and code review in parallel (40-50% faster)\n- Identifies overlapping issues with root cause analysis\n- Returns structured report with prioritized fixes\n\n<routing>\n<route status=\"TEST_FAILURE\" action=\"Enter Test Focus Mode (fix tests, retry)\" />\n<route status=\"CLEAN_STATE\" action=\"Skip to Phase 4 (Documentation)\" />\n<route status=\"ISSUES_FOUND\" action=\"Continue to Phase 3 (Fix Loop)\" />\n<route status=\"TOOLS_UNAVAILABLE\" action=\"Report error, ask user to install tools\" />\n</routing>\n\n<test_focus_mode>\nLoop until tests pass:\n1. Analyze failure root cause\n2. Apply fix to implementation or tests\n3. Re-run quality-analyzer (mode: \"full\")\n4. Check status ‚Üí continue or exit loop\n\nMax 10 iterations. If stuck, ask user for guidance.\n</test_focus_mode>\n</phase>\n\n<phase name=\"3\" title=\"Iterative Fix Loop\">\n**For each prioritized fix** (from agent's report):\n\n1. **Apply Fix**:\n   - Invoke @refactoring skill with file, function, issues, and root cause\n   - @refactoring applies patterns: early returns, extract function, storifying, extract type, switch extraction, extract constant\n\n2. **Verify Fix** (Incremental Mode):\n   - Re-run quality-analyzer with `mode: incremental`\n   - See `reference.md` ‚Üí \"Agent Prompt Templates\" for prompt\n   - Agent returns delta report: fixed, remaining, new issues\n\n3. **Route Based on Status**:\n   - `TEST_FAILURE` ‚Üí Enter Test Focus Mode\n   - `CLEAN_STATE` ‚Üí Break loop, go to Phase 4\n   - `ISSUES_FOUND` ‚Üí Continue to next fix (or retry if no progress)\n\n4. **Safety Limits**:\n   - Max 10 iterations per fix loop\n   - If stuck after 3 attempts ‚Üí show status, ask user\n\n**Loop until agent returns CLEAN_STATE**.\n</phase>\n\n<phase name=\"4\" title=\"Documentation\">\nInvoke @documentation skill:\n1. Add/update package-level godoc\n2. Add/update type and function documentation (WHY not WHAT)\n3. Add godoc testable examples (Example_* functions)\n4. If last plan step ‚Üí add feature documentation to docs/\n\n**Verify**: Run `go doc -all ./...` and ensure examples compile.\n</phase>\n\n<phase name=\"5\" title=\"Commit Ready\">\nGenerate comprehensive summary. See `reference.md` ‚Üí \"Commit Readiness Output Format\" for template.\n\nPresent user with options:\n1. Commit as-is\n2. Fix design debt only, then commit\n3. Fix design + readability debt, then commit\n4. Fix all findings, then commit\n5. Refactor entire file, then commit\n</phase>\n\n</workflow>\n\n<workflow_control>\n<control aspect=\"Phases\" behavior=\"Sequential: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5\" />\n<control aspect=\"Routing\" behavior=\"Agent status determines path\" />\n<control aspect=\"Parallelism\" behavior=\"Phase 2 runs 3 tools simultaneously\" />\n<control aspect=\"Incremental\" behavior=\"After first run, agent analyzes only changed files\" />\n</workflow_control>\n\n<integration>\n**Skills invoked**:\n- @code-designing (Phase 1, if needed)\n- @testing (Phase 1)\n- @refactoring (Phase 3)\n- @documentation (Phase 4)\n\n**Agents invoked**:\n- `go-linter-driven-development:quality-analyzer` (Phase 2 and Phase 3 verification)\n  - Internally delegates to `go-linter-driven-development:go-code-reviewer` for design analysis\n\n**After committing**:\n- Feature complete ‚Üí Already documented in Phase 4\n- More work needed ‚Üí Run this workflow again for next commit\n</integration>\n\n<success_criteria>\nWorkflow is complete when ALL of the following are true:\n\n- [ ] Pre-flight check passed (Go project verified, commands discovered)\n- [ ] Phase 1 complete (tests written, code implemented)\n- [ ] Quality-analyzer returns `CLEAN_STATE`:\n  - [ ] Tests pass\n  - [ ] Linter passes (0 errors)\n  - [ ] Code review clean (0 findings)\n- [ ] Phase 4 complete (documentation added/updated)\n- [ ] Commit summary presented to user with options\n- [ ] User has chosen commit action (or deferred)\n</success_criteria>"
              },
              {
                "name": "pre-commit-review",
                "description": "ADVISORY validation of code against design principles that linters cannot enforce.\nLoaded by go-code-reviewer agent for design analysis guidance. Also invoked by @refactoring (after pattern application).\nCan be manually invoked for standalone code review.\nCategorizes findings as Design Debt, Readability Debt, or Polish Opportunities. Does NOT block commits.\n",
                "path": "go-linter-driven-development/skills/pre-commit-review/SKILL.md",
                "frontmatter": {
                  "name": "pre-commit-review",
                  "description": "ADVISORY validation of code against design principles that linters cannot enforce.\nLoaded by go-code-reviewer agent for design analysis guidance. Also invoked by @refactoring (after pattern application).\nCan be manually invoked for standalone code review.\nCategorizes findings as Design Debt, Readability Debt, or Polish Opportunities. Does NOT block commits.\n"
                },
                "content": "<objective>\nExpert design analysis that detects issues linters can't catch.\nReturns detailed report to caller with categorized findings and fix recommendations.\n\n**Pure Analysis & Reporting** - Generates report, doesn't fix anything or invoke skills.\n\n**Reference**: See `reference.md` for complete detection checklist with examples.\n**Examples**: See `examples.md` for real-world review scenarios.\n</objective>\n\n<quick_start>\n1. **Read files** under review (all staged or specific files)\n2. **Apply design principles** checklist from reference.md (LLM reasoning)\n3. **Search usage patterns** with Grep tool\n4. **Categorize findings**: Bugs, Design Debt, Readability Debt, Polish\n5. **Generate structured report** with file:line locations and fix recommendations\n6. **Return report** to caller (no fixes, no skill invocations)\n</quick_start>\n\n<input_output>\n<input>\n- Files to review (specific files or all staged changes)\n- Review mode: `full` (first run) or `incremental` (subsequent runs)\n- Previous findings (optional, for incremental mode)\n- Context (invoked by refactoring, orchestrator, subagent, or user)\n</input>\n\n<output>\n- Structured report with categorized findings\n- Each finding: `file:line`, issue, why it matters, fix strategy, effort estimate\n- Prioritized by impact and effort\n- Format: Parseable for combined analysis (when invoked by orchestrator)\n</output>\n</input_output>\n\n<invocation_modes>\n<direct_skill_invocation context=\"User or Orchestrator\">\n- Full control, can invoke other skills\n- Can make changes based on findings\n- Interactive mode with user feedback\n</direct_skill_invocation>\n\n<subagent_mode context=\"Task tool with go-code-reviewer\">\n- Read-only analysis, returns report only\n- Cannot invoke other skills\n- Used for parallel execution by orchestrator\n- Designed for speed and focused analysis\n</subagent_mode>\n</invocation_modes>\n\n<who_invokes>\n1. **go-code-reviewer agent** - Loads this skill for design analysis guidance during parallel quality analysis\n2. **@refactoring skill** - After applying patterns, validates design quality remains high\n3. **User** - Manual code review before commit\n</who_invokes>\n\n<detection_capabilities>\n**What Reviewer Detects (That Linters Can't):**\n- Primitive obsession (with juiciness scoring)\n- Unstorified functions (mixed abstraction levels)\n- Missing domain concepts (implicit types that should be explicit)\n- Non-self-validating types (defensive code in methods)\n- Poor comment quality (explaining what instead of why)\n- File structure issues (too long, too many types)\n- Generic package extraction opportunities\n- Design bugs (nil deref, ignored errors, resource leaks)\n- Test quality (weak assertions, missing use cases, mock overuse, conditionals in tests)\n\n**Division of Labor:**\n- **Linter handles**: Complexity metrics, line counts, formatting, syntax\n- **Reviewer handles**: Design patterns, domain modeling, conceptual issues\n\nSee [reference.md](./reference.md) for complete detection checklist with examples.\n</detection_capabilities>\n\n<workflow>\n\n<full_review_mode context=\"First Run\">\n1. Read all files under review (using Read tool)\n2. Apply design principles checklist from reference.md (LLM reasoning)\n3. Search for usage patterns across codebase (using Grep tool)\n4. Categorize findings:\n   - Bugs (nil deref, ignored errors, resource leaks)\n   - Design Debt (types, architecture, validation)\n   - Readability Debt (abstraction, flow, clarity)\n   - Polish (naming, docs, minor improvements)\n5. Generate structured report with recommendations\n6. Return report to caller (doesn't invoke other skills or make fixes)\n</full_review_mode>\n\n<incremental_review_mode context=\"Subsequent Runs\">\nUsed after fixes have been applied to verify resolution and detect new issues.\n\n1. Read ONLY changed files since last review (using git diff)\n2. Compare against previous findings:\n   - Mark resolved issues as Fixed\n   - Identify issues that still exist\n3. Analyze changed code for NEW issues introduced by fixes\n4. Generate delta report:\n   - Fixed: Issues from previous run that are now resolved\n   - Remaining: Issues that still need attention\n   - New: Issues introduced by recent changes\n5. Return concise delta report (not full analysis)\n\n**When to Use Incremental Mode:**\n- After @refactoring skill applies fixes\n- During iterative fix loop in Phase 4 of autopilot workflow\n- User requests re-review after making changes\n\n**Benefits:**\n- Faster execution (only analyzes changed files)\n- Clear feedback on what was fixed vs what remains\n- Detects regressions introduced by fixes\n</incremental_review_mode>\n\n</workflow>\n\n<detection_approach>\n**LLM-Powered Analysis** (not AST parsing or metrics calculation):\n\nThe reviewer reads code like a senior developer and applies design principles:\n- Reads files with Read tool\n- Searches patterns with Grep tool (find usages, duplications)\n- Applies checklist from reference.md using LLM reasoning\n- Pattern matches against anti-patterns\n- Counts occurrences and calculates juiciness scores\n- Generates findings with specific locations and fix guidance\n</detection_approach>\n\n<report_format>\n\n<full_report context=\"First Run\">\n```\nüìä CODE REVIEW REPORT\nScope: [files reviewed]\nMode: FULL\n\nSUMMARY\n\nTotal findings: 18\nüêõ Bugs: 2 (fix immediately)\nüî¥ Design Debt: 5 (fix before commit)\nüü° Readability Debt: 8 (improves maintainability)\nüü¢ Polish: 3 (nice to have)\n\nEstimated fix effort: 3.5 hours\n\n[Detailed findings by category]\n[Recommendations by priority]\n[Skills to use for fixes]\n```\n</full_report>\n\n<incremental_report context=\"Subsequent Runs\">\n```\nüìä CODE REVIEW DELTA REPORT\nScope: [changed files only]\nMode: INCREMENTAL\n\nSUMMARY\n\n‚úÖ Fixed: 4 (resolved from previous run)\n‚ö†Ô∏è Remaining: 2 (still need attention)\nüÜï New: 1 (introduced by recent changes)\n\n[Detailed delta findings]\n```\n</incremental_report>\n\n<structured_output context=\"For Orchestrator Parsing\">\nWhen invoked as subagent for combined analysis, output follows strict format:\n\n```\nüêõ BUGS\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nfile:line | Issue description | Why it matters | Fix strategy | Effort: [Trivial/Moderate/Significant]\n\nüî¥ DESIGN DEBT\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nfile:line | Issue description | Why it matters | Fix strategy | Effort: [Trivial/Moderate/Significant]\n\nüü° READABILITY DEBT\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nfile:line | Issue description | Why it matters | Fix strategy | Effort: [Trivial/Moderate/Significant]\n\nüü¢ POLISH\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nfile:line | Issue description | Why it matters | Fix strategy | Effort: [Trivial/Moderate/Significant]\n```\n\n**Effort Estimates:**\n- **Trivial**: <5 minutes (extract constant, rename variable)\n- **Moderate**: 5-20 minutes (extract function, storifying, create simple type)\n- **Significant**: >20 minutes (architectural refactoring, complex type extraction)\n\n**file:line Format:** Must be exact for orchestrator to correlate with linter errors\n- Example: `pkg/parser.go:45`\n- NOT: `parser.go line 45` or `pkg/parser.go (line 45)`\n</structured_output>\n\n</report_format>\n\n<constraints>\nThis skill MUST NOT:\n- Invoke other skills (@refactoring, @code-designing, @testing)\n- Fix anything or make code changes\n- Make decisions on behalf of user\n- Parse AST or calculate complexity metrics (linter does this)\n- Run linter (caller does this)\n- Iterate or loop (caller decides whether to re-invoke)\n- Block commits (findings are advisory)\n</constraints>\n\n<integration>\n\n<invoked_by_refactoring>\nRefactoring completes ‚Üí invoke reviewer ‚Üí analyze report:\n- Bugs found? ‚Üí Fix immediately, re-run linter\n- Design debt found? ‚Üí Apply another refactoring pattern\n- All clean? ‚Üí Return success to orchestrator\n</invoked_by_refactoring>\n\n<invoked_by_go_code_reviewer>\nDuring Phase 2 (Parallel Quality Analysis):\n1. go-code-reviewer agent automatically loads this skill for guidance\n2. Agent applies detection checklist from this skill\n3. Agent returns structured report to quality-analyzer\n4. quality-analyzer combines with linter/test results\n5. Orchestrator routes based on combined findings\n</invoked_by_go_code_reviewer>\n\n<invoked_by_user>\nManual review request:\n1. User invokes: @pre-commit-review on path/to/file.go\n2. Receive detailed report\n3. User decides how to proceed\n4. User may invoke @refactoring or @code-designing for fixes\n</invoked_by_user>\n\n</integration>\n\n<review_scope>\n**Primary Scope**: Changed code in commit\n- All modified lines\n- All new files\n- Specific focus on design principle adherence\n\n**Secondary Scope**: Context around changes\n- Entire files containing modifications\n- Flag patterns/issues outside commit scope (in BROADER CONTEXT section)\n- Suggest broader refactoring opportunities if valuable\n</review_scope>\n\n<advisory_nature>\n**This review does NOT block commits.**\n\nPurpose:\n- Provide visibility into design quality\n- Offer concrete improvement suggestions with examples\n- Help maintain coding principles\n- Guide refactoring decisions\n\nCaller (or user) decides:\n- Commit as-is (accept debt knowingly)\n- Fix critical debt before commit (bugs, major design issues)\n- Fix all debt before commit (comprehensive cleanup)\n- Expand scope to broader refactor (when broader context issues found)\n</advisory_nature>\n\n<finding_categories>\n\n<bugs severity=\"critical\">\n**Will cause runtime failures or correctness issues**\n- Nil dereferences, ignored errors, resource leaks\n- Invalid nil returns, race conditions\n- Fix immediately before any other work\n</bugs>\n\n<design_debt severity=\"high\">\n**Will cause pain when extending/modifying code**\n- Primitive obsession, missing domain types\n- Non-self-validating types\n- Wrong architecture (horizontal vs vertical)\n- Fix before commit recommended\n</design_debt>\n\n<readability_debt severity=\"medium\">\n**Makes code harder to understand and work with**\n- Mixed abstraction levels, not storified\n- Functions too long or complex\n- Poor naming, unclear intent\n- Fix improves team productivity\n</readability_debt>\n\n<polish severity=\"low\">\n**Minor improvements for consistency and quality**\n- Non-idiomatic naming, missing examples\n- Comment improvements, minor refactoring\n- Low priority, nice to have\n</polish>\n\nSee [reference.md](./reference.md) for detailed principles and examples for each category.\n</finding_categories>\n\n<success_criteria>\n**Code Quality Analysis Performed:**\n- [ ] Read every function - does it read like a story? (single abstraction level)\n- [ ] Checked all functions for mixed abstraction levels (storifying needed?)\n- [ ] Evaluated primitives for primitive obsession (juiciness test applied)\n- [ ] Assessed types for self-validation (defensive code in methods?)\n- [ ] Reviewed comment quality (explaining WHY not WHAT?)\n- [ ] Checked file structure (too long? too many types?)\n- [ ] Searched for missing domain concepts (implicit types that should be explicit)\n- [ ] Validated test quality (weak assertions? conditionals in tests? mock overuse?)\n- [ ] Scanned for design bugs (nil deref, ignored errors, resource leaks)\n\n**Report Quality:**\n- [ ] All findings categorized by severity (Bugs, Design Debt, Readability Debt, Polish)\n- [ ] Each finding includes: file:line, issue, why it matters, fix strategy, effort estimate\n- [ ] Structured format parseable by orchestrator\n- [ ] Clear distinction between bugs (fix immediately) and advisory findings\n- [ ] Incremental mode accurately tracks fixed, remaining, and new issues\n</success_criteria>"
              },
              {
                "name": "refactoring",
                "description": "Linter-driven refactoring patterns to reduce complexity and improve code quality.\nUse when linter fails with complexity issues (cyclomatic, cognitive, maintainability) or when code feels hard to read/maintain.\nApplies storifying, type extraction, and function extraction patterns.\n",
                "path": "go-linter-driven-development/skills/refactoring/SKILL.md",
                "frontmatter": {
                  "name": "refactoring",
                  "description": "Linter-driven refactoring patterns to reduce complexity and improve code quality.\nUse when linter fails with complexity issues (cyclomatic, cognitive, maintainability) or when code feels hard to read/maintain.\nApplies storifying, type extraction, and function extraction patterns.\n",
                  "allowed-tools": [
                    "Skill(go-linter-driven-development:code-designing)",
                    "Skill(go-linter-driven-development:testing)",
                    "Skill(go-linter-driven-development:pre-commit-review)"
                  ]
                },
                "content": "<objective>\nLinter-driven refactoring patterns to reduce complexity and improve code quality.\nOperates autonomously - no user confirmation needed during execution.\n\n**Reference**: See `reference.md` for complete decision tree and all patterns.\n**Examples**: See `examples.md` for real-world refactoring case studies.\n</objective>\n\n<quick_start>\n1. **Receive linter failures** from @linter-driven-development\n2. **Analyze root cause** - Does it read like a story? Can it be broken down?\n3. **Apply patterns** in priority order (early returns ‚Üí extract function ‚Üí storifying ‚Üí extract type)\n4. **Verify** - Re-run linter automatically\n5. **Iterate** until linter passes\n\n**IMPORTANT**: This skill operates autonomously - no user confirmation needed.\n</quick_start>\n\n<when_to_use>\n- **Automatically invoked** by @linter-driven-development when linter fails\n- **Automatically invoked** by @pre-commit-review when design issues detected\n- **Complexity failures**: cyclomatic, cognitive, maintainability index\n- **Architectural failures**: noglobals, gochecknoinits, gochecknoglobals\n- **Design smell failures**: dupl (duplication), goconst (magic strings), ineffassign\n- Functions > 50 LOC or nesting > 2 levels\n- Mixed abstraction levels in functions\n- Manual invocation when code feels hard to read/maintain\n</when_to_use>\n\n<learning_resources>\nChoose your learning path:\n- **Quick Start**: Use the patterns below for common refactoring cases\n- **Complete Reference**: See [reference.md](./reference.md) for full decision tree and all patterns\n- **Real-World Examples**: See [examples.md](./examples.md) to learn the refactoring thought process\n  - [Example 1](./examples.md#example-1-storifying-mixed-abstractions-and-extracting-logic-into-leaf-types): Storifying and extracting a single leaf type\n  - [Example 2](./examples.md#example-2-primitive-obsession-with-multiple-types-and-storifying-switch-statements): Primitive obsession with multiple types and switch elimination\n</learning_resources>\n\n<analysis_phase>\nBefore applying any refactoring patterns, automatically analyze the context:\n\n<system_context_analysis>\nAUTOMATICALLY ANALYZE:\n1. Find all callers of the failing function\n2. Identify which flows/features depend on it\n3. Determine primary responsibility\n4. Check for similar functions revealing patterns\n5. Spot potential refactoring opportunities\n</system_context_analysis>\n\n<type_discovery>\nProactively identify hidden types in the code:\n\nPOTENTIAL TYPES TO DISCOVER:\n1. Data being parsed from strings ‚Üí Parse* types\n   Example: ParseCommandResult(), ParseLogEntry()\n\n2. Scattered validation logic ‚Üí Validated types\n   Example: Email, Port, IPAddress types\n\n3. Data that always travels together ‚Üí Aggregate types\n   Example: UserCredentials, ServerConfig\n\n4. Complex conditions ‚Üí State/status types\n   Example: DeploymentStatus with IsReady(), CanProceed()\n\n5. Repeated string manipulation ‚Üí Types with methods\n   Example: FilePath with Dir(), Base(), Ext()\n</type_discovery>\n\n<analysis_output>\nThe analysis produces a refactoring plan identifying:\n- Function's role in the system\n- Potential domain types to extract\n- Recommended refactoring approach\n- Expected complexity reduction\n</analysis_output>\n</analysis_phase>\n\n<refactoring_signals>\n<linter_failures>\n**Complexity Issues:**\n- **Cyclomatic Complexity**: Too many decision points ‚Üí Extract functions, simplify logic\n- **Cognitive Complexity**: Hard to understand ‚Üí Storifying, reduce nesting\n- **Maintainability Index**: Hard to maintain ‚Üí Break into smaller pieces\n\n**Architectural Issues:**\n- **noglobals/gochecknoglobals**: Global variable usage ‚Üí Dependency rejection pattern\n- **gochecknoinits**: Init function usage ‚Üí Extract initialization logic\n- **Static/singleton patterns**: Hidden dependencies ‚Üí Inject dependencies\n\n**Design Smells:**\n- **dupl**: Code duplication ‚Üí Extract common logic/types\n- **goconst**: Magic strings/numbers ‚Üí Extract constants or types\n- **ineffassign**: Ineffective assignments ‚Üí Simplify logic\n</linter_failures>\n\n<code_smells>\n- Functions > 50 LOC\n- Nesting > 2 levels\n- Mixed abstraction levels\n- Unclear flow/purpose\n- Primitive obsession\n- Global variable access scattered throughout code\n</code_smells>\n</refactoring_signals>\n\n<automation_flow>\nThis skill operates completely autonomously once invoked:\n\n<iteration_loop>\nAUTOMATED PROCESS:\n1. Receive trigger:\n   - From @linter-driven-development (linter failures)\n   - From @pre-commit-review (design debt/readability debt)\n2. Apply refactoring pattern (start with least invasive)\n3. Run linter immediately (no user confirmation)\n4. If linter still fails OR review finds more issues:\n   - Try next pattern in priority order\n   - Repeat until both linter and review pass\n5. If patterns exhausted and still failing:\n   - Report what was tried\n   - Suggest file splitting or architectural changes\n</iteration_loop>\n\n<pattern_priority>\n**For Complexity Failures** (cyclomatic, cognitive, maintainability):\n1. Early Returns ‚Üí Reduce nesting quickly\n2. Extract Function ‚Üí Break up long functions\n3. Storifying ‚Üí Improve abstraction levels\n4. Extract Type ‚Üí Create domain types (only if \"juicy\")\n5. Switch Extraction ‚Üí Categorize switch cases\n\n**For Architectural Failures** (noglobals, singletons):\n1. Dependency Rejection ‚Üí Incremental bottom-up approach\n2. Extract Type with dependency injection\n3. Push global access up call chain one level\n4. Iterate until globals only at entry points (main, handlers)\n\n**For Design Smells** (dupl, goconst):\n1. Extract Type ‚Üí For repeated values or validation\n2. Extract Function ‚Üí For code duplication\n3. Extract Constant ‚Üí For magic strings/numbers\n</pattern_priority>\n\n<no_manual_intervention>\n- **NO** asking for confirmation between patterns\n- **NO** waiting for user input\n- **NO** manual linter runs\n- **AUTOMATIC** progression through patterns\n- **ONLY** report results at the end\n</no_manual_intervention>\n</automation_flow>\n\n<refactoring_patterns>\n\n<pattern name=\"storifying\" signal=\"Mixed abstraction levels\">\n```go\n// BEFORE - Mixed abstractions\nfunc ProcessOrder(order Order) error {\n    // Validation\n    if order.ID == \"\" {\n        return errors.New(\"invalid\")\n    }\n    // Low-level DB setup\n    db, err := sql.Open(\"postgres\", connStr)\n    if err != nil { return err }\n    defer db.Close()\n    // SQL construction\n    query := \"INSERT INTO...\"\n    // ... many lines\n    return nil\n}\n\n// AFTER - Story-like\nfunc ProcessOrder(order Order) error {\n    if err := validateOrder(order); err != nil {\n        return err\n    }\n    if err := saveToDatabase(order); err != nil {\n        return err\n    }\n    return notifyCustomer(order)\n}\n\nfunc validateOrder(order Order) error { /* ... */ }\nfunc saveToDatabase(order Order) error { /* ... */ }\nfunc notifyCustomer(order Order) error { /* ... */ }\n```\n</pattern>\n\n<pattern name=\"extract_type\" signal=\"Primitive obsession or unstructured data\">\n<juiciness_test version=\"2\">\n**BEHAVIORAL JUICINESS** (rich behavior):\n- Complex validation rules (regex, ranges, business rules)\n- Multiple meaningful methods (‚â•2 methods)\n- State transitions or transformations\n- Format conversions (different representations)\n\n**STRUCTURAL JUICINESS** (organizing complexity):\n- Parsing unstructured data into fields\n- Grouping related data that travels together\n- Making implicit structure explicit\n- Replacing map[string]interface{} with typed fields\n\n**USAGE JUICINESS** (simplifies code):\n- Used in multiple places\n- Significantly simplifies calling code\n- Makes tests cleaner and more focused\n\n**Score**: Need \"yes\" in at least ONE category to create the type\n</juiciness_test>\n\n```go\n// NOT JUICY - Don't create type\nfunc ValidateUserID(id string) error {\n    if id == \"\" {\n        return errors.New(\"empty id\")\n    }\n    return nil\n}\n// Just use: if userID == \"\"\n\n// JUICY (Behavioral) - Complex validation\ntype Email string\n\nfunc ParseEmail(s string) (Email, error) {\n    if s == \"\" {\n        return \"\", errors.New(\"empty email\")\n    }\n    if !emailRegex.MatchString(s) {\n        return \"\", errors.New(\"invalid format\")\n    }\n    if len(s) > 255 {\n        return \"\", errors.New(\"too long\")\n    }\n    return Email(s), nil\n}\n\nfunc (e Email) Domain() string { /* extract domain */ }\nfunc (e Email) LocalPart() string { /* extract local */ }\n\n// JUICY (Structural) - Parsing complex data\ntype CommandResult struct {\n    FailedFiles  []string\n    SuccessFiles []string\n    Message      string\n    ExitCode     int\n}\n\nfunc ParseCommandResult(output string) (CommandResult, error) {\n    // Parse unstructured output into structured fields\n}\n```\n\n**Warning Signs of Over-Engineering:**\n- Type with only one trivial method\n- Simple validation (just empty check)\n- Type that's just a wrapper without behavior\n- Good variable naming would be clearer\n\nSee [Example 2](./examples.md#first-refactoring-attempt-the-over-abstraction-trap) for complete case study.\n</pattern>\n\n<pattern name=\"extract_function\" signal=\"Function > 50 LOC or multiple responsibilities\">\n```go\n// BEFORE - Long function\nfunc CreateUser(data map[string]interface{}) error {\n    // Validation (15 lines)\n    // Database operations (20 lines)\n    // Email notification (10 lines)\n    // Logging (5 lines)\n    return nil\n}\n\n// AFTER - Extracted functions\nfunc CreateUser(data map[string]interface{}) error {\n    user, err := validateAndParseUser(data)\n    if err != nil {\n        return err\n    }\n    if err := saveUser(user); err != nil {\n        return err\n    }\n    if err := sendWelcomeEmail(user); err != nil {\n        return err\n    }\n    logUserCreation(user)\n    return nil\n}\n```\n</pattern>\n\n<pattern name=\"early_returns\" signal=\"Deep nesting > 2 levels\">\n```go\n// BEFORE - Deeply nested\nfunc ProcessItem(item Item) error {\n    if item.IsValid() {\n        if item.IsReady() {\n            if item.HasPermission() {\n                // Process\n                return nil\n            } else {\n                return errors.New(\"no permission\")\n            }\n        } else {\n            return errors.New(\"not ready\")\n        }\n    } else {\n        return errors.New(\"invalid\")\n    }\n}\n\n// AFTER - Early returns\nfunc ProcessItem(item Item) error {\n    if !item.IsValid() {\n        return errors.New(\"invalid\")\n    }\n    if !item.IsReady() {\n        return errors.New(\"not ready\")\n    }\n    if !item.HasPermission() {\n        return errors.New(\"no permission\")\n    }\n    // Process\n    return nil\n}\n```\n</pattern>\n\n<pattern name=\"switch_extraction\" signal=\"Switch statement with complex cases\">\n```go\n// BEFORE - Long switch in one function\nfunc HandleRequest(reqType string, data interface{}) error {\n    switch reqType {\n    case \"create\":\n        // 20 lines of creation logic\n    case \"update\":\n        // 20 lines of update logic\n    case \"delete\":\n        // 15 lines of delete logic\n    default:\n        return errors.New(\"unknown type\")\n    }\n    return nil\n}\n\n// AFTER - Extracted handlers\nfunc HandleRequest(reqType string, data interface{}) error {\n    switch reqType {\n    case \"create\":\n        return handleCreate(data)\n    case \"update\":\n        return handleUpdate(data)\n    case \"delete\":\n        return handleDelete(data)\n    default:\n        return errors.New(\"unknown type\")\n    }\n}\n\nfunc handleCreate(data interface{}) error { /* ... */ }\nfunc handleUpdate(data interface{}) error { /* ... */ }\nfunc handleDelete(data interface{}) error { /* ... */ }\n```\n</pattern>\n\n<pattern name=\"dependency_rejection\" signal=\"noglobals linter fails or global/singleton usage\">\n**Goal**: Create \"islands of clean code\" by incrementally pushing dependencies up the call chain\n\n**Strategy**: Work from bottom-up, rejecting dependencies one level at a time\n- DON'T do massive refactoring all at once\n- Start at deepest level (furthest from main)\n- Extract clean type with dependency injected\n- Push global access up one level\n- Repeat until global only at entry points\n\n```go\n// BEFORE - Global accessed deep in code\nfunc PublishEvent(event Event) error {\n    conn, err := nats.Connect(env.Configs.NATsAddress)\n    // ... complex logic\n}\n\n// AFTER - Dependency rejected up one level\ntype EventPublisher struct {\n    natsAddress string  // injected, not global\n}\n\nfunc NewEventPublisher(natsAddress string) *EventPublisher {\n    return &EventPublisher{natsAddress: natsAddress}\n}\n\nfunc (p *EventPublisher) Publish(event Event) error {\n    conn, err := nats.Connect(p.natsAddress)\n    // ... same logic, now testable\n}\n\n// Caller pushed up (closer to main)\nfunc SetupMessaging() *EventPublisher {\n    return NewEventPublisher(env.Configs.NATsAddress)  // Global only here\n}\n```\n\n**Result**: EventPublisher is now 100% testable without globals\n\n**Key Principles**:\n- **Incremental**: One type at a time, one level at a time\n- **Bottom-up**: Start at deepest code, work toward main\n- **Pragmatic**: Accept globals at entry points (main, handlers)\n- **Testability**: Each extracted type is an island (testable in isolation)\n\nSee [Example 3](./examples.md#example-3-dependency-rejection-pattern) for complete case study.\n</pattern>\n\n</refactoring_patterns>\n\n<decision_tree>\nWhen linter fails, ask these questions (see reference.md for details):\n\n1. **Does this read like a story?**\n   - No ‚Üí Extract functions for different abstraction levels\n\n2. **Can this be broken into smaller pieces?**\n   - By responsibility? ‚Üí Extract functions\n   - By task? ‚Üí Extract functions\n   - By category? ‚Üí Extract functions\n\n3. **Does logic run on primitives?**\n   - Yes ‚Üí Is this primitive obsession? ‚Üí Extract type\n\n4. **Is function long due to switch statement?**\n   - Yes ‚Üí Extract case handlers\n\n5. **Are there deeply nested if/else?**\n   - Yes ‚Üí Use early returns or extract functions\n</decision_tree>\n\n<testing_integration>\nWhen creating new types or extracting functions during refactoring:\n\n**ALWAYS invoke @testing skill** to write tests for:\n- **Isolated types**: Types with injected dependencies (testable islands)\n- **Value object types**: Types that may depend on other value objects but are still isolated\n- **Extracted functions**: New functions created during refactoring\n- **Parse functions**: Functions that transform unstructured data\n\n<island_definition>\nA type is an \"island of clean code\" if:\n- Dependencies are explicit (injected via constructor)\n- No global or static dependencies\n- Can be tested in isolation\n- Has 100% testable public API\n\n**Examples of testable islands:**\n- `NATSClient` with injected `natsAddress` string (no other dependencies)\n- `Email` type with validation logic (no dependencies)\n- `ServiceEndpoint` that uses `Port` value object (both are testable islands)\n- `OrderService` with injected `Repository` and `EventPublisher` (all testable)\n\n**Note**: Islands can depend on other value objects and still be isolated!\n</island_definition>\n\n<workflow>\nREFACTORING ‚Üí TESTING:\n1. Extract type during refactoring\n2. Immediately invoke @testing skill\n3. @testing skill writes appropriate tests\n4. Verify tests pass\n5. Continue refactoring\n</workflow>\n</testing_integration>\n\n<stopping_criteria>\n**STOP when ALL of these are met:**\n- Linter passes\n- All functions < 50 LOC\n- Nesting ‚â§ 2 levels\n- Code reads like a story\n- No more \"juicy\" abstractions to extract\n\n**Warning Signs of Over-Engineering:**\n- Creating types with only one method\n- Functions that just call another function\n- More abstraction layers than necessary\n- Code becomes harder to understand\n- Diminishing returns on complexity reduction\n\n**Pragmatic Approach:**\nIF linter passes AND code is readable:\n    STOP - Don't extract more\nEVEN IF you could theoretically extract more:\n    STOP - Avoid abstraction bloat\n</stopping_criteria>\n\n<output_format>\n```\nCONTEXT ANALYSIS\n\nFunction: CreateUser (user/service.go:45)\nRole: Core user creation orchestration\nCalled by:\n- api/handler.go:89 (HTTP endpoint)\n- cmd/user.go:34 (CLI command)\n\nPotential types spotted:\n- Email: Complex validation logic scattered\n- UserID: Generation and validation logic\n\nREFACTORING APPLIED\n\nPatterns Successfully Applied:\n1. Early Returns: Reduced nesting from 4 to 2 levels\n2. Storifying: Extracted validate(), save(), notify()\n3. Extract Type: Created Email and PhoneNumber types\n\nPatterns Tried but Insufficient:\n- Extract Function alone: Still too complex, needed types\n\nTypes Created (with Juiciness Score):\n\nEmail type (JUICY - Behavioral + Usage):\n- Behavioral: ParseEmail(), Domain(), LocalPart() methods\n- Usage: Used in 5+ places across codebase\n- Island: Testable in isolation\n- ‚Üí Invoke @testing skill to write tests\n\nTypes Considered but Rejected (NOT JUICY):\n- UserID: Only empty check, good naming sufficient\n- Status: Just string constants, enum adequate\n\nMETRICS\n\nComplexity Reduction:\n- Cyclomatic: 18 ‚Üí 7\n- Cognitive: 25 ‚Üí 8\n- LOC: 120 ‚Üí 45\n- Nesting: 4 ‚Üí 2\n\nFILES MODIFIED\n\nModified:\n- user/service.go (+15, -75 lines)\n\nCreated (Islands of Clean Code):\n- user/email.go (new, +45 lines) ‚Üí Ready for @testing skill\n\nAUTOMATION COMPLETE\n\nStopping Criteria Met:\n- Linter passes (0 issues)\n- All functions < 50 LOC\n- Max nesting = 2 levels\n- Code reads like a story\n- No more juicy abstractions\n\nReady for: @pre-commit-review phase\n```\n</output_format>\n\n<integration>\n**Invoked By (Automatic Triggering)**:\n- **@linter-driven-development**: Automatically invokes when linter fails (Phase 3)\n- **@pre-commit-review**: Automatically invokes when design issues detected (Phase 4)\n\n**Iterative Loop**:\n1. Linter fails ‚Üí invoke @refactoring\n2. Refactoring complete ‚Üí re-run linter\n3. Linter passes ‚Üí invoke @pre-commit-review\n4. Review finds design debt ‚Üí invoke @refactoring again\n5. Repeat until both linter AND review pass\n\n**Invokes (When Needed)**:\n- **@code-designing**: When refactoring creates new types, validate design\n- **@testing**: Automatically invoked to write tests for new types/functions\n- **@pre-commit-review**: Validates design quality after linting passes\n\nSee [reference.md](./reference.md) for complete refactoring patterns and decision tree.\n</integration>\n\n<success_criteria>\nRefactoring is complete when ALL of the following are true:\n\n- [ ] Linter passes (0 issues)\n- [ ] All functions < 50 LOC\n- [ ] Max nesting ‚â§ 2 levels\n- [ ] Code reads like a story (single abstraction level per function)\n- [ ] No more \"juicy\" abstractions to extract\n- [ ] Tests written for new types/functions (via @testing skill)\n- [ ] Ready for @pre-commit-review phase\n</success_criteria>"
              },
              {
                "name": "testing",
                "description": "Use when creating leaf types, after refactoring, during implementation, or when testing advice is needed.\nAutomatically invoked to write tests for new types, or use as testing expert advisor.\nCovers unit, integration, and system tests with emphasis on in-memory dependencies.\nEnsures 100% coverage on leaf types with public API testing.\n",
                "path": "go-linter-driven-development/skills/testing/SKILL.md",
                "frontmatter": {
                  "name": "testing",
                  "description": "Use when creating leaf types, after refactoring, during implementation, or when testing advice is needed.\nAutomatically invoked to write tests for new types, or use as testing expert advisor.\nCovers unit, integration, and system tests with emphasis on in-memory dependencies.\nEnsures 100% coverage on leaf types with public API testing.\n"
                },
                "content": "<objective>\nPrinciples and patterns for writing effective Go tests.\nWrites tests autonomously based on code structure and type design, and serves as testing expert advisor.\n\n**Reference**: See `reference.md` for comprehensive testutils patterns and DSL examples.\n</objective>\n\n<quick_start>\n1. **Identify test level** needed (unit/integration/system)\n2. **Choose structure**: table-driven (simple) or testify suites (complex setup)\n3. **Write in pkg_test package** - test public API only\n4. **Use in-memory implementations** from testutils\n5. **Avoid pitfalls**: No time.Sleep, no conditionals in test cases\n\nReady after tests? Run linter: `task lintwithfix`\n</quick_start>\n\n<when_to_use>\n<automatic_invocation>\n- **Automatically invoked** by @linter-driven-development during Phase 2 (Implementation)\n- **Automatically invoked** by @refactoring when new isolated types are created\n- **Automatically invoked** by @code-designing after designing new types\n- **After creating new leaf types** - Types that should have 100% unit test coverage\n- **After extracting functions** during refactoring that create testable units\n</automatic_invocation>\n\n<manual_invocation>\n- User explicitly requests tests to be written\n- User asks for testing advice, recommendations, or \"what to do\"\n- When testing strategy is unclear (table-driven vs testify suites)\n- When choosing between dependency levels (in-memory vs binary vs test-containers)\n- When adding tests to existing untested code\n- When user needs testing expert guidance or consultation\n</manual_invocation>\n</when_to_use>\n\n<philosophy>\n**Test only the public API**\n- Use `pkg_test` package name\n- Test types through their constructors\n- No testing private methods/functions\n\n**Prefer real implementations over mocks**\n- Use in-memory implementations (fastest, no external deps)\n- Use HTTP test servers (httptest)\n- Use temp files/directories\n- Test with actual dependencies when beneficial\n\n**Coverage targets**\n- Leaf types: 100% unit test coverage\n- Orchestrating types: Integration tests\n- Critical workflows: System tests\n</philosophy>\n\n<test_pyramid>\nThree levels of testing, each serving a specific purpose:\n\n<unit_tests level=\"base\">\n- Test leaf types in isolation\n- Fast, focused, no external dependencies\n- 100% coverage target for leaf types\n- Use `pkg_test` package, test public API only\n</unit_tests>\n\n<integration_tests level=\"middle\">\n- Test seams between components\n- Test workflows across package boundaries\n- Use real or in-memory implementations\n- Verify components work together correctly\n</integration_tests>\n\n<system_tests level=\"top\">\n- Black box testing from `tests/` folder\n- Test entire system via CLI/API\n- Test critical end-to-end workflows\n- **Dependency options**: in-memory mocks, binaries (exec.Command), or test-containers\n- Prefer in-memory when possible, but use appropriate level for the test\n</system_tests>\n</test_pyramid>\n\n<reusable_infrastructure>\nBuild shared test infrastructure in `internal/testutils/`:\n- In-memory mock servers with DSL (HTTP, DB, file system)\n- Reusable across all test levels\n- Test the infrastructure itself!\n- Can expose as CLI tools for manual testing\n\n**Dependency Priority** (choose appropriate level):\n1. **In-memory** (fastest): Pure Go, httptest, in-memory DB - use when testing your code's logic\n2. **Binary** (isolated): Standalone executable via exec.Command - use when testing against real service\n3. **Test-containers** (realistic): Programmatic Docker from Go - use when you need real external services\n4. **Docker-compose** (full stack): For complex multi-service scenarios\n\nChoose based on what you're testing, not dogmatically. In-memory is fastest but sometimes you need real services.\n\nSee reference.md for comprehensive testutils patterns and DSL examples.\n</reusable_infrastructure>\n\n<workflow>\n\n<unit_tests_workflow>\n**Purpose**: Test leaf types in isolation, 100% coverage target\n\n1. **Identify leaf types** - Self-contained types with logic\n2. **Choose structure** - Table-driven (simple) or testify suites (complex setup)\n3. **Write in pkg_test package** - Test public API only\n4. **Use in-memory implementations** - From testutils or local implementations\n5. **Avoid pitfalls** - No time.Sleep, no conditionals in cases, no private method tests\n\n**Test structure:**\n- Table-driven: Separate success/error test functions (complexity = 1)\n- Testify suites: Only for complex infrastructure setup (HTTP servers, DBs)\n- Always use named struct fields (linter reorders fields)\n\nSee reference.md for detailed patterns and examples.\n</unit_tests_workflow>\n\n<integration_tests_workflow>\n**Purpose**: Test seams between components, verify they work together\n\n1. **Identify integration points** - Where packages/components interact\n2. **Choose dependencies** - Prefer: in-memory > binary > test-containers\n3. **Write tests** - In `pkg_test` or `integration_test.go` with build tags\n4. **Test workflows** - Cover happy path and error scenarios across boundaries\n5. **Use real or testutils implementations** - Avoid heavy mocking\n\n**File organization:**\n```go\n//go:build integration\n\npackage user_test\n\n// Test Service + Repository + real/mock dependencies\n```\n\nSee reference.md for integration test patterns with dependencies.\n</integration_tests_workflow>\n\n<system_tests_workflow>\n**Purpose**: Black box test entire system, critical end-to-end workflows\n\n1. **Place in tests/ folder** - At project root, separate from packages\n2. **Test via CLI/API** - exec.Command for CLI, HTTP client for APIs\n3. **Choose dependency level** based on what you're testing:\n   - **In-memory**: Fastest, use when testing your code's behavior\n   - **Binary**: exec.Command to run real executables in separate process\n   - **Test-containers**: When you need real external services (DB, message queue)\n4. **Test critical workflows** - User journeys, not every edge case\n\n**Example with in-memory mock:**\n```go\n// tests/cli_test.go - Testing CLI against mock API\nfunc TestCLI_UserWorkflow(t *testing.T) {\n    mockAPI := testutils.NewMockServer().\n        OnGET(\"/users/1\").RespondJSON(200, user).\n        Build() // In-memory httptest.Server\n    defer mockAPI.Close()\n\n    cmd := exec.Command(\"./myapp\", \"get-user\", \"1\",\n        \"--api-url\", mockAPI.URL())\n    output, err := cmd.CombinedOutput()\n    // Assert on output\n}\n```\n\n**Example with binary executable:**\n```go\n// tests/integration_test.go - Testing against real service binary\nfunc TestSystem_WithRealService(t *testing.T) {\n    // Start service binary in background\n    svc := exec.Command(\"./myservice\", \"--port\", \"8080\")\n    svc.Start()\n    defer svc.Process.Kill()\n\n    // Wait for service to be ready\n    waitForHealthy(t, \"http://localhost:8080/health\")\n\n    // Run tests against real service\n    resp, err := http.Get(\"http://localhost:8080/api/users\")\n    // Assert on response\n}\n```\n\nSee reference.md for comprehensive system test patterns including test-containers.\n</system_tests_workflow>\n\n</workflow>\n\n<key_patterns>\n**Table-Driven Tests (Cyclomatic Complexity = 1):**\n- **NEVER use wantErr bool** - Splits test logic, adds conditionals\n- **Max complexity = 1 inside t.Run()** - No if/else, no switch, no conditionals\n- Separate success and error test functions (TestFoo_Success, TestFoo_Error)\n- Always use named struct fields (linter reorders fields)\n\n```go\n// BAD - wantErr adds conditional, complexity > 1\ntests := []struct {\n    input   string\n    want    string\n    wantErr bool  // NEVER DO THIS\n}{...}\nfor _, tt := range tests {\n    t.Run(tt.name, func(t *testing.T) {\n        got, err := Parse(tt.input)\n        if tt.wantErr {  // <- Conditional! Complexity > 1\n            require.Error(t, err)\n        } else {\n            require.NoError(t, err)\n            require.Equal(t, tt.want, got)\n        }\n    })\n}\n\n// GOOD - Separate functions, complexity = 1\nfunc TestParse_Success(t *testing.T) {\n    tests := []struct {\n        name  string\n        input string\n        want  string\n    }{...}\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got, err := Parse(tt.input)\n            require.NoError(t, err)      // No conditionals\n            require.Equal(t, tt.want, got)\n        })\n    }\n}\n\nfunc TestParse_Error(t *testing.T) {\n    tests := []struct {\n        name  string\n        input string\n    }{...}\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            _, err := Parse(tt.input)\n            require.Error(t, err)  // No conditionals\n        })\n    }\n}\n```\n\n**Testify Suites:**\n- Only for complex infrastructure (HTTP servers, DBs, OpenTelemetry)\n- SetupSuite/TearDownSuite for expensive shared setup\n- SetupTest/TearDownTest for per-test isolation\n\n**Synchronization:**\n- Never use time.Sleep (flaky, slow)\n- Use channels with select/timeout for async operations\n- Use sync.WaitGroup for concurrent operations\n\nSee reference.md for complete patterns with code examples.\n</key_patterns>\n\n<output_format>\nAfter writing tests:\n\n```\nTESTING COMPLETE\n\nUnit Tests:\n- user/user_id_test.go: 100% (4 test cases)\n- user/email_test.go: 100% (6 test cases)\n- user/service_test.go: 100% (8 test cases)\n\nIntegration Tests:\n- user/integration_test.go: 3 workflows tested\n- Dependencies: In-memory DB, httptest mock server\n\nSystem Tests:\n- tests/cli_test.go: 2 end-to-end workflows (in-memory mocks)\n- tests/api_test.go: 1 full API workflow (binary executable)\n- tests/db_test.go: 1 database workflow (test-containers)\n\nTest Infrastructure:\n- internal/testutils/httpserver: In-memory mock API with DSL\n- internal/testutils/mockdb: In-memory database mock\n- internal/testutils/containers: Test-container helpers\n\nTest Execution:\n$ go test ./...                    # All tests (in-memory only)\n$ go test -tags=integration ./...  # Include integration tests\n$ go test ./tests/...              # System tests (may need containers)\n\nAll tests pass\n100% coverage on leaf types\n\nNext Steps:\n1. Run linter: task lintwithfix\n2. If linter fails ‚Üí use @refactoring skill\n3. If linter passes ‚Üí use @pre-commit-review skill\n```\n</output_format>\n\n<testing_checklist>\n<unit_tests_checklist>\n- [ ] All unit tests in pkg_test package\n- [ ] Testing public API only (no private methods)\n- [ ] Table-driven tests use named struct fields\n- [ ] No conditionals in test cases (complexity = 1)\n- [ ] Using in-memory implementations from testutils\n- [ ] No time.Sleep (using channels/waitgroups)\n- [ ] Leaf types have 100% coverage\n</unit_tests_checklist>\n\n<integration_tests_checklist>\n- [ ] Test seams between components\n- [ ] Use in-memory or binary dependencies (avoid Docker)\n- [ ] Build tags for optional execution (`//go:build integration`)\n- [ ] Cover happy path and error scenarios across boundaries\n- [ ] Real or testutils implementations (minimal mocking)\n</integration_tests_checklist>\n\n<system_tests_checklist>\n- [ ] Located in tests/ folder at project root\n- [ ] Black box testing via CLI/API\n- [ ] Appropriate dependency level chosen (in-memory, binary, or test-containers)\n- [ ] Tests critical end-to-end workflows\n- [ ] Dependencies documented (what's needed to run tests)\n- [ ] CI-compatible (either fast in-memory or containerized setup)\n</system_tests_checklist>\n\n<test_infrastructure_checklist>\n- [ ] Reusable mocks in internal/testutils/\n- [ ] Test infrastructure has its own tests\n- [ ] DSL provides readable test setup\n- [ ] Can be exposed as CLI for manual testing\n</test_infrastructure_checklist>\n\nSee reference.md for complete testing guidelines and examples.\n</testing_checklist>\n\n<success_criteria>\nTesting is complete when ALL of the following are true:\n\n- [ ] All unit tests in pkg_test package testing public API only\n- [ ] Table-driven tests use named struct fields\n- [ ] No wantErr bool - success and error cases in separate test functions\n- [ ] Cyclomatic complexity = 1 inside t.Run() (no if/else, no switch)\n- [ ] Leaf types have 100% coverage\n- [ ] Integration tests cover component seams\n- [ ] System tests in tests/ folder with appropriate dependency level\n- [ ] No time.Sleep (using channels/waitgroups)\n- [ ] Tests pass and linter approves\n</success_criteria>"
              }
            ]
          },
          {
            "name": "ts-react-linter-driven-development",
            "description": "Linter-driven development workflow for TypeScript + React with 6 specialized skills: meta orchestrator, component design, testing, refactoring, review, and documentation",
            "source": "./ts-react-linter-driven-development",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add buzzdan/ai-coding-rules",
              "/plugin install ts-react-linter-driven-development@ai-coding-rules"
            ],
            "signals": {
              "stars": 2,
              "forks": 1,
              "pushed_at": "2026-01-07T12:57:19Z",
              "created_at": "2025-10-13T09:02:48Z",
              "license": null
            },
            "commands": [],
            "skills": [
              {
                "name": "component-designing",
                "description": "Component and type design for TypeScript + React code. Use when planning new features, designing components and custom hooks, preventing primitive obsession, or when refactoring reveals need for new abstractions. Focuses on feature-based architecture and type safety.",
                "path": "ts-react-linter-driven-development/skills/component-designing/SKILL.md",
                "frontmatter": {
                  "name": "component-designing",
                  "description": "Component and type design for TypeScript + React code. Use when planning new features, designing components and custom hooks, preventing primitive obsession, or when refactoring reveals need for new abstractions. Focuses on feature-based architecture and type safety."
                },
                "content": "# Component Designing\n\nComponent and type design for TypeScript + React applications.\nUse when planning new features or identifying need for new abstractions during refactoring.\n\n## When to Use\n- Planning a new feature (before writing code)\n- Refactoring reveals need for new components/hooks\n- Linter failures suggest better abstractions\n- When you need to think through component architecture\n- Designing state management approach\n\n## Purpose\nDesign clean, well-composed components and types that:\n- Prevent primitive obsession (use branded types, Zod schemas)\n- Ensure type safety with TypeScript\n- Follow component composition patterns\n- Implement feature-based architecture\n- Create reusable custom hooks\n\n## Workflow\n\n### 0. Architecture Pattern Analysis (FIRST STEP)\n\n**Default: Always use feature-based architecture** (group by feature, not technical layer).\n\nScan codebase structure:\n- **Feature-based**: `src/features/auth/{LoginForm,useAuth,types,AuthContext}.tsx` ‚úÖ\n- **Technical layers**: `src/{components,hooks,contexts}/auth.tsx` ‚ö†Ô∏è\n\n**Decision Flow**:\n1. **Pure feature-based** ‚Üí Continue pattern, implement as `src/features/[new-feature]/`\n2. **Pure technical layers** ‚Üí Propose: Start migration with `docs/architecture/feature-based-migration.md`, implement new feature as first feature slice\n3. **Mixed (migrating)** ‚Üí Check for migration docs, continue pattern as feature-based\n\n**Always ask user approval with options:**\n- Option A: Feature-based (recommended for cohesion/maintainability)\n- Option B: Match existing pattern (if time-constrained)\n- Acknowledge: Time pressure, team decisions, consistency needs are valid\n\n**If migration needed**, create/update `docs/architecture/feature-based-migration.md`:\n```markdown\n# Feature-Based Architecture Migration Plan\n## Current State: [technical-layers/mixed]\n## Target: Feature-based structure in src/features/[feature]/\n## Strategy: New features feature-based, migrate existing incrementally\n## Progress: [x] [new-feature] (this PR), [ ] existing features\n```\n\nSee reference.md section #2 for detailed patterns.\n\n---\n\n### 1. Understand Domain\n\n- What is the problem domain?\n- What are the main UI concepts/interactions?\n- What state needs to be managed?\n- What are the user flows?\n- How does this fit into existing architecture?\n\n### 2. Identify Core Abstractions\n\nAsk for each concept:\n- Is this currently a primitive (string, number, boolean)?\n- Does it have validation rules?\n- Is it a UI concept (component)?\n- Is it reusable logic (custom hook)?\n- Is it shared state (context)?\n- Does it need type safety (branded type)?\n\n### 3. Design Self-Validating Types\n\nFor primitives with validation (Email, UserId, Port):\n\n**Option A: Zod Schemas (Recommended)**\n```typescript\nimport { z } from 'zod'\n\n// Schema definition with validation\nexport const EmailSchema = z.string().email().min(1)\nexport const UserIdSchema = z.string().uuid()\n\n// Extract type from schema\nexport type Email = z.infer<typeof EmailSchema>\nexport type UserId = z.infer<typeof UserIdSchema>\n\n// Validation function\nexport function validateEmail(value: unknown): Email {\n  return EmailSchema.parse(value) // Throws on invalid\n}\n```\n\n**Option B: Branded Types (TypeScript)**\n```typescript\n// Brand for nominal typing\ndeclare const __brand: unique symbol\ntype Brand<T, TBrand> = T & { [__brand]: TBrand }\n\nexport type Email = Brand<string, 'Email'>\nexport type UserId = Brand<string, 'UserId'>\n\n// Validating constructor\nexport function createEmail(value: string): Email {\n  if (!value.match(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/)) {\n    throw new Error('Invalid email format')\n  }\n  return value as Email\n}\n\nexport function createUserId(value: string): UserId {\n  if (!value || value.length === 0) {\n    throw new Error('UserId cannot be empty')\n  }\n  return value as UserId\n}\n```\n\n**When to use which:**\n- Zod: Form validation, API parsing, runtime validation\n- Branded types: Type safety without runtime overhead\n\n### 4. Design Component Structure\n\n**Component Types:**\n\n**A. Presentational Components (Pure UI)**\n- No state management\n- Props-driven\n- Reusable across features\n- 100% testable\n\n```typescript\ninterface ButtonProps {\n  label: string\n  onClick: () => void\n  variant?: 'primary' | 'secondary'\n  disabled?: boolean\n}\n\nexport function Button({ label, onClick, variant = 'primary', disabled = false }: ButtonProps) {\n  return (\n    <button\n      className={`btn btn-${variant}`}\n      onClick={onClick}\n      disabled={disabled}\n    >\n      {label}\n    </button>\n  )\n}\n```\n\n**B. Container Components (Logic + State)**\n- Manage state\n- Handle side effects\n- Coordinate data fetching\n- Compose presentational components\n\n```typescript\nexport function LoginContainer() {\n  const { login, isLoading, error } = useAuth()\n  const [email, setEmail] = useState('')\n  const [password, setPassword] = useState('')\n\n  const handleSubmit = async () => {\n    try {\n      const validEmail = EmailSchema.parse(email)\n      await login(validEmail, password)\n    } catch (error) {\n      // Handle error\n    }\n  }\n\n  return (\n    <LoginForm\n      email={email}\n      password={password}\n      onEmailChange={setEmail}\n      onPasswordChange={setPassword}\n      onSubmit={handleSubmit}\n      isLoading={isLoading}\n      error={error}\n    />\n  )\n}\n```\n\n### 5. Design Custom Hooks\n\nExtract reusable logic into custom hooks:\n\n```typescript\n// Single responsibility: Form state management\nexport function useFormState<T>(initialValues: T) {\n  const [values, setValues] = useState<T>(initialValues)\n  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({})\n\n  const setValue = <K extends keyof T>(key: K, value: T[K]) => {\n    setValues(prev => ({ ...prev, [key]: value }))\n    setErrors(prev => ({ ...prev, [key]: undefined }))\n  }\n\n  const reset = () => {\n    setValues(initialValues)\n    setErrors({})\n  }\n\n  return { values, errors, setValue, setErrors, reset }\n}\n\n// Single responsibility: Data fetching\nexport function useUsers() {\n  const [users, setUsers] = useState<User[]>([])\n  const [isLoading, setIsLoading] = useState(false)\n  const [error, setError] = useState<Error | null>(null)\n\n  useEffect(() => {\n    const fetchUsers = async () => {\n      setIsLoading(true)\n      try {\n        const data = await api.getUsers()\n        setUsers(data)\n      } catch (err) {\n        setError(err as Error)\n      } finally {\n        setIsLoading(false)\n      }\n    }\n    fetchUsers()\n  }, [])\n\n  return { users, isLoading, error }\n}\n```\n\n### 6. Design Context for Shared State\n\nWhen state is needed across 3+ component levels:\n\n```typescript\ninterface AuthContextValue {\n  user: User | null\n  login: (email: Email, password: string) => Promise<void>\n  logout: () => Promise<void>\n  isAuthenticated: boolean\n}\n\nconst AuthContext = createContext<AuthContextValue | null>(null)\n\nexport function AuthProvider({ children }: { children: ReactNode }) {\n  const [user, setUser] = useState<User | null>(null)\n\n  const login = async (email: Email, password: string) => {\n    const user = await api.login(email, password)\n    setUser(user)\n  }\n\n  const logout = async () => {\n    await api.logout()\n    setUser(null)\n  }\n\n  const value = useMemo(\n    () => ({ user, login, logout, isAuthenticated: !!user }),\n    [user]\n  )\n\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>\n}\n\nexport function useAuth() {\n  const context = useContext(AuthContext)\n  if (!context) {\n    throw new Error('useAuth must be used within AuthProvider')\n  }\n  return context\n}\n```\n\n### 7. Plan Feature Structure\n\n**Feature-based structure (Recommended)**:\n```\nsrc/features/auth/\n‚îú‚îÄ‚îÄ components/\n‚îÇ   ‚îú‚îÄ‚îÄ LoginForm.tsx          # Presentational\n‚îÇ   ‚îú‚îÄ‚îÄ LoginForm.test.tsx\n‚îÇ   ‚îú‚îÄ‚îÄ RegisterForm.tsx\n‚îÇ   ‚îî‚îÄ‚îÄ RegisterForm.test.tsx\n‚îú‚îÄ‚îÄ hooks/\n‚îÇ   ‚îú‚îÄ‚îÄ useAuth.ts             # Custom hook\n‚îÇ   ‚îú‚îÄ‚îÄ useAuth.test.ts\n‚îÇ   ‚îú‚îÄ‚îÄ useFormValidation.ts\n‚îÇ   ‚îî‚îÄ‚îÄ useFormValidation.test.ts\n‚îú‚îÄ‚îÄ context/\n‚îÇ   ‚îú‚îÄ‚îÄ AuthContext.tsx        # Shared state\n‚îÇ   ‚îî‚îÄ‚îÄ AuthContext.test.tsx\n‚îú‚îÄ‚îÄ types.ts                    # Email, UserId, etc.\n‚îú‚îÄ‚îÄ api.ts                      # API calls\n‚îî‚îÄ‚îÄ index.ts                    # Public exports\n```\n\n**Bad structure (Technical layers)**:\n```\nsrc/\n‚îú‚îÄ‚îÄ components/LoginForm.tsx\n‚îú‚îÄ‚îÄ hooks/useAuth.ts\n‚îú‚îÄ‚îÄ contexts/AuthContext.tsx\n‚îî‚îÄ‚îÄ types/auth.ts\n```\n\n### 8. Review Against Principles\n\nCheck design against (see reference.md):\n- [ ] No primitive obsession (use Zod/branded types)\n- [ ] Feature-based architecture\n- [ ] Component composition over prop drilling\n- [ ] Custom hooks for reusable logic\n- [ ] Context only when needed (3+ levels)\n- [ ] Clear separation: presentational vs container\n- [ ] Props interfaces well-defined\n\n## Output Format\n\nAfter design phase:\n\n```\nüé® DESIGN PLAN\n\nFeature: User Authentication\n\nCore Domain Types:\n‚úÖ Email (Zod schema) - RFC 5322 validation, used in login/register\n‚úÖ UserId (branded type) - Non-empty string, prevents invalid IDs\n‚úÖ User (interface) - { id: UserId, email: Email, name: string }\n\nComponents:\n‚úÖ LoginForm (Presentational)\n   Props: { email, password, onSubmit, isLoading, error }\n   Responsibility: UI only, no state\n\n‚úÖ LoginContainer (Container)\n   Responsibility: State management, form handling, validation\n   Uses: LoginForm, useAuth hook\n\n‚úÖ RegisterForm (Presentational)\n   Props: { formData, onSubmit, isLoading, errors }\n   Responsibility: UI only, no state\n\nCustom Hooks:\n‚úÖ useAuth\n   Returns: { user, login, logout, isAuthenticated, isLoading }\n   Responsibility: Auth operations and state\n\n‚úÖ useFormValidation\n   Returns: { values, errors, setValue, validate, reset }\n   Responsibility: Form state and validation logic\n\nContext:\n‚úÖ AuthContext\n   Provides: { user, login, logout, isAuthenticated }\n   Used by: Protected routes, user menu, profile pages\n   Reason: Auth state needed across entire app\n\nFeature Structure:\nüìÅ src/features/auth/\n  ‚îú‚îÄ‚îÄ components/\n  ‚îÇ   ‚îú‚îÄ‚îÄ LoginForm.tsx\n  ‚îÇ   ‚îú‚îÄ‚îÄ LoginForm.test.tsx\n  ‚îÇ   ‚îú‚îÄ‚îÄ RegisterForm.tsx\n  ‚îÇ   ‚îî‚îÄ‚îÄ RegisterForm.test.tsx\n  ‚îú‚îÄ‚îÄ hooks/\n  ‚îÇ   ‚îú‚îÄ‚îÄ useAuth.ts\n  ‚îÇ   ‚îú‚îÄ‚îÄ useAuth.test.ts\n  ‚îÇ   ‚îú‚îÄ‚îÄ useFormValidation.ts\n  ‚îÇ   ‚îî‚îÄ‚îÄ useFormValidation.test.ts\n  ‚îú‚îÄ‚îÄ context/\n  ‚îÇ   ‚îú‚îÄ‚îÄ AuthContext.tsx\n  ‚îÇ   ‚îî‚îÄ‚îÄ AuthContext.test.tsx\n  ‚îú‚îÄ‚îÄ types.ts\n  ‚îú‚îÄ‚îÄ api.ts\n  ‚îî‚îÄ‚îÄ index.ts\n\nDesign Decisions:\n- Email and UserId as validated types prevent runtime errors\n- Zod for Email (form validation), branded type for UserId (type safety)\n- LoginForm is presentational for reusability and testability\n- useAuth hook encapsulates auth logic for reuse across components\n- AuthContext provides auth state to avoid prop drilling\n- Feature-based structure keeps all auth code together\n\nIntegration Points:\n- Consumed by: App routes, protected route wrapper, user menu\n- Depends on: API client, token storage\n- Events: User login/logout events for analytics\n\nNext Steps:\n1. Create types with validation (Zod schemas + branded types)\n2. Write tests for types and hooks (Jest + RTL)\n3. Implement presentational components (LoginForm)\n4. Implement container components (LoginContainer)\n5. Add context provider (AuthContext)\n6. Integration tests for full flows\n\nReady to implement? Use @testing skill for test structure.\n```\n\n## Key Principles\n\nSee reference.md for detailed principles:\n- Primitive obsession prevention (Zod schemas, branded types)\n- Component composition patterns\n- Feature-based architecture\n- Custom hooks for reusable logic\n- Context for shared state (use sparingly)\n- Props interfaces and type safety\n\n## Pre-Code Review Questions\n\nBefore writing code, ask:\n- Can logic be moved into custom hooks?\n- Is this component presentational or container?\n- Should state be local or context?\n- Have I avoided primitive obsession?\n- Is validation in the right place?\n- Does this follow feature-based architecture?\n- Are components small and focused?\n\nOnly after satisfactory answers, proceed to implementation.\n\nSee reference.md for complete design principles and examples."
              },
              {
                "name": "documentation",
                "description": "Generate comprehensive feature documentation including Storybook stories, JSDoc comments, and feature guides. Use after completing a feature (may span multiple commits). Creates documentation for humans and AI to understand features, usage patterns, and design decisions.",
                "path": "ts-react-linter-driven-development/skills/documentation/SKILL.md",
                "frontmatter": {
                  "name": "documentation",
                  "description": "Generate comprehensive feature documentation including Storybook stories, JSDoc comments, and feature guides. Use after completing a feature (may span multiple commits). Creates documentation for humans and AI to understand features, usage patterns, and design decisions."
                },
                "content": "# Documentation (TypeScript + React)\n\nGenerate comprehensive documentation for features, components, and hooks.\n\n## When to Use\n- After completing a feature (may span multiple commits)\n- When a component/hook needs usage documentation\n- When design decisions need recording\n- For public/shared components and hooks\n\n## Documentation Types\n\n### 1. Storybook Stories (Component Documentation)\n**Purpose**: Visual documentation of component usage and variants\n\n**Creates**: `.stories.tsx` files alongside components\n\n### 2. JSDoc Comments (Code Documentation)\n**Purpose**: Inline documentation for types, props, complex functions\n\n**Location**: In source files (`.ts`, `.tsx`)\n\n### 3. Feature Documentation (Architectural Documentation)\n**Purpose**: WHY decisions were made, HOW feature works, WHAT to extend\n\n**Creates**: `docs/features/[feature-name].md`\n\n## Workflow\n\n### 1. Identify Documentation Needs\n\nAsk:\n- Is this a reusable component? ‚Üí Storybook story\n- Is this a custom hook? ‚Üí JSDoc + usage example\n- Is this a complete feature? ‚Üí Feature documentation\n- Are types/props complex? ‚Üí JSDoc comments\n\n### 2. Create Storybook Stories\n\n**For each component**, create stories showing:\n- Default state\n- All variants/props\n- Interactive states\n- Edge cases (loading, error, empty)\n\n**Example**:\n```typescript\n// src/components/Button/Button.stories.tsx\nimport type { Meta, StoryObj } from '@storybook/react'\nimport { Button } from './Button'\n\nconst meta: Meta<typeof Button> = {\n  title: 'Components/Button',\n  component: Button,\n  parameters: {\n    layout: 'centered'\n  },\n  tags: ['autodocs'],\n  argTypes: {\n    variant: {\n      control: 'select',\n      options: ['primary', 'secondary', 'danger']\n    }\n  }\n}\n\nexport default meta\ntype Story = StoryObj<typeof Button>\n\n// Default story\nexport const Primary: Story = {\n  args: {\n    label: 'Button',\n    variant: 'primary',\n    onClick: () => alert('clicked')\n  }\n}\n\n// Variants\nexport const Secondary: Story = {\n  args: {\n    ...Primary.args,\n    variant: 'secondary'\n  }\n}\n\nexport const Danger: Story = {\n  args: {\n    ...Primary.args,\n    variant: 'danger'\n  }\n}\n\n// States\nexport const Disabled: Story = {\n  args: {\n    ...Primary.args,\n    isDisabled: true\n  }\n}\n\nexport const Loading: Story = {\n  args: {\n    ...Primary.args,\n    isLoading: true\n  }\n}\n\n// Interactive example\nexport const WithIcon: Story = {\n  args: {\n    ...Primary.args,\n    icon: <IconCheck />\n  }\n}\n```\n\n### 3. Add JSDoc Comments\n\n**For public types and interfaces**:\n```typescript\n/**\n * Props for the Button component.\n *\n * @example\n * ```tsx\n * <Button\n *   label=\"Click me\"\n *   variant=\"primary\"\n *   onClick={() => console.log('clicked')}\n * />\n * ```\n */\nexport interface ButtonProps {\n  /** The text to display on the button */\n  label: string\n\n  /** The visual style variant of the button */\n  variant?: 'primary' | 'secondary' | 'danger'\n\n  /** Callback fired when the button is clicked */\n  onClick: () => void\n\n  /** If true, the button will be disabled */\n  isDisabled?: boolean\n\n  /** If true, the button will show a loading spinner */\n  isLoading?: boolean\n}\n```\n\n**For custom hooks**:\n```typescript\n/**\n * Custom hook for managing user authentication state.\n *\n * Handles login, logout, and persisting auth state to localStorage.\n * Automatically refreshes token when it expires.\n *\n * @param options - Configuration options for authentication\n * @returns Authentication state and methods\n *\n * @example\n * ```tsx\n * function LoginForm() {\n *   const { login, isLoading, error } = useAuth()\n *\n *   const handleSubmit = async (email: string, password: string) => {\n *     await login(email, password)\n *   }\n *\n *   return <Form onSubmit={handleSubmit} isLoading={isLoading} error={error} />\n * }\n * ```\n */\nexport function useAuth(options?: AuthOptions): UseAuthReturn {\n  // Implementation\n}\n```\n\n**For complex types**:\n```typescript\n/**\n * Represents the state of an asynchronous operation.\n *\n * Uses discriminated union to ensure invalid states are impossible\n * (e.g., cannot have both data and error simultaneously).\n *\n * @template T - The type of data returned on success\n *\n * @example\n * ```typescript\n * const [state, setState] = useState<AsyncState<User>>({ status: 'idle' })\n *\n * // Type narrowing works automatically\n * if (state.status === 'success') {\n *   console.log(state.data.name) // state.data is available and typed\n * }\n * ```\n */\nexport type AsyncState<T> =\n  | { status: 'idle' }\n  | { status: 'loading' }\n  | { status: 'success'; data: T }\n  | { status: 'error'; error: Error }\n```\n\n### 4. Create Feature Documentation\n\n**For completed features**, create `docs/features/[feature-name].md`:\n\n**Template**:\n```markdown\n# Feature: [Feature Name]\n\n## Overview\nBrief description of what the feature does and why it exists.\n\n## Problem\nWhat problem does this feature solve? What was the pain point?\n\n## Solution\nHow does this feature solve the problem? What approach was taken?\n\n## Architecture\n\n### Components\n- **ComponentName**: Purpose and responsibility\n- **AnotherComponent**: Purpose and responsibility\n\n### Hooks\n- **useFeatureHook**: What it does and why it's separate\n\n### Context\n- **FeatureContext**: What state it manages and why context was needed\n\n### Types\n- **KeyType**: What it represents and why it's a custom type\n\n## Key Design Decisions\n\n### 1. [Decision Title]\n**Decision**: What was decided\n**Rationale**: Why this approach was chosen\n**Alternatives**: What other approaches were considered\n**Trade-offs**: What we gained and what we gave up\n\n### 2. [Another Decision]\n...\n\n## Usage\n\n### Basic Usage\n```typescript\n// Simple example showing most common use case\n```\n\n### Advanced Usage\n```typescript\n// Example showing advanced features or edge cases\n```\n\n### Integration\nHow this feature integrates with other parts of the application.\n\n## API Reference\n\n### Components\n\n#### ComponentName\nProps:\n- `propName` (Type): Description\n\nEvents:\n- `onEvent`: When it fires and what it provides\n\n#### AnotherComponent\n...\n\n### Hooks\n\n#### useFeatureHook\nParameters:\n- `param` (Type): Description\n\nReturns:\n- `returnValue` (Type): Description\n\n### Types\n\n#### TypeName\n```typescript\ntype TypeName = ...\n```\n\nDescription of when and how to use this type.\n\n## Testing Strategy\n\n### Unit Tests\n- What is tested at the unit level (pure components, hooks)\n- Coverage expectations (100% for leaf components)\n\n### Integration Tests\n- What user flows are tested\n- How mocking is handled (MSW for APIs)\n\n## Accessibility\n\n### Compliance\n- WCAG level compliance (A, AA, AAA)\n- What accessibility features are implemented\n\n### Keyboard Navigation\n- What keyboard shortcuts are supported\n- How tab order works\n\n### Screen Reader Support\n- What ARIA attributes are used\n- What announcements are made\n\n## Performance Considerations\n\n### Optimizations\n- What performance optimizations are implemented\n- Use of memo, useMemo, useCallback\n\n### Bundle Impact\n- Approximate bundle size contribution\n- Any lazy loading or code splitting\n\n## Known Limitations\n\n### Current Limitations\n- What doesn't work yet\n- What edge cases aren't handled\n\n### Future Enhancements\n- What could be improved\n- What features could be added\n\n## Troubleshooting\n\n### Common Issues\n\n#### Issue: [Problem Description]\n**Symptom**: What users will see\n**Cause**: Why this happens\n**Solution**: How to fix it\n\n## Related Features\n- Links to related documentation\n- Dependencies on other features\n- Features that depend on this\n\n## Migration Guide\n(If replacing existing functionality)\n\n### Before\n```typescript\n// Old way\n```\n\n### After\n```typescript\n// New way\n```\n\n### Breaking Changes\n- What changed\n- How to update code\n\n## Changelog\n- v1.1.0 (2024-01-15): Added support for...\n- v1.0.0 (2024-01-01): Initial implementation\n```\n\n## Output Format\n\nAfter generating documentation:\n\n```\nüìö DOCUMENTATION GENERATED\n\nFeature: User Authentication\n\nGenerated Files:\n‚úÖ Storybook Stories (3 components)\n   - src/features/auth/components/LoginForm.stories.tsx\n   - src/features/auth/components/RegisterForm.stories.tsx\n   - src/features/auth/components/PasswordInput.stories.tsx\n\n‚úÖ JSDoc Comments Added\n   - src/features/auth/hooks/useAuth.ts (hook documentation)\n   - src/features/auth/types.ts (type definitions)\n   - src/features/auth/context/AuthContext.tsx (context API)\n\n‚úÖ Feature Documentation\n   - docs/features/authentication.md (complete guide)\n\nüìñ Documentation includes:\n   - Problem/solution overview\n   - Architecture and design decisions\n   - Usage examples (basic + advanced)\n   - API reference (components, hooks, types)\n   - Testing strategy\n   - Accessibility features\n   - Performance considerations\n   - Troubleshooting guide\n\nüéØ Next Steps:\n1. Review generated Storybook stories locally: npm run storybook\n2. Review feature documentation: docs/features/authentication.md\n3. Update any project-specific references or links\n4. Commit documentation with feature code\n\nüìù Maintenance:\n- Update Storybook stories when component props change\n- Update JSDoc when APIs change\n- Update feature docs when design decisions change\n- Keep examples working (they're testable!)\n```\n\n## Documentation Principles\n\n### For Humans AND AI\n\nDocumentation serves two audiences:\n1. **Human developers**: Need to understand and extend code\n2. **AI assistants**: Need context to help debug and extend features\n\nWrite documentation that helps both audiences understand:\n- **WHY** decisions were made (context for future changes)\n- **HOW** the feature works (architecture and flow)\n- **WHAT** can be extended (integration points)\n\n### Show, Don't Tell\n\nPrefer code examples over prose descriptions:\n\n**‚ùå Bad**:\n```\nThe Button component accepts a variant prop that can be primary,\nsecondary, or danger, and will style the button accordingly.\n```\n\n**‚úÖ Good**:\n```typescript\n<Button variant=\"primary\" label=\"Save\" />\n<Button variant=\"secondary\" label=\"Cancel\" />\n<Button variant=\"danger\" label=\"Delete\" />\n```\n\n### Keep Examples Executable\n\nStorybook stories and JSDoc examples should be real, working code that compiles and runs.\n\n### Document Design Decisions\n\nMost important: **WHY** decisions were made.\n\n**‚ùå Bad**:\n```\n// Uses context for state management\n```\n\n**‚úÖ Good**:\n```\n/**\n * Uses AuthContext for state management instead of prop drilling.\n *\n * Decision: Context chosen because auth state is needed in 10+\n * components across different nesting levels (nav, profile, settings,\n * protected routes). Prop drilling would be unmaintainable.\n *\n * Alternative considered: Redux - overkill for single feature state\n */\n```\n\n## When to Document\n\n### Always Document\n- Public/shared components\n- Custom hooks (except trivial ones)\n- Complex types (discriminated unions, branded types)\n- Completed features (spanning multiple commits)\n\n### Consider Documenting\n- Complex utility functions\n- Non-obvious algorithms\n- Performance-critical code\n- Edge cases and workarounds\n\n### Don't Over-Document\n- Trivial functions (self-explanatory)\n- Implementation details (private functions)\n- Obvious code (const user = getUser())\n\n## Best Practices\n\n### Storybook\n- One story file per component\n- Show all variants\n- Include interactive controls\n- Document props with argTypes\n- Add accessibility checks (a11y addon)\n\n### JSDoc\n- Use `@param`, `@returns`, `@example` tags\n- Include examples showing typical usage\n- Document complex types inline\n- Link related types with `@see`\n\n### Feature Docs\n- Start with problem/solution\n- Include architecture diagrams (mermaid)\n- Provide working code examples\n- Document WHY, not just WHAT\n- Keep updated as feature evolves\n\n## Tools\n\n### Storybook Commands\n```bash\n# Run Storybook locally\nnpm run storybook\n\n# Build static Storybook\nnpm run build-storybook\n\n# Test stories (interaction testing)\nnpm run test-storybook\n```\n\n### TypeDoc (Alternative to JSDoc)\n```bash\n# Generate API documentation from TypeScript\nnpx typedoc --entryPoints src/index.ts\n```\n\n## Key Principles\n\nSee reference.md for detailed principles:\n- Document WHY, not just WHAT\n- Show working code examples\n- Keep docs close to code\n- Update docs with code changes\n- Test examples (Storybook)\n- Document for humans AND AI\n- Focus on usage, not implementation\n\nSee reference.md for complete documentation templates and examples."
              },
              {
                "name": "linter-driven-development",
                "description": "META ORCHESTRATOR for complete implementation workflow - design, test, lint, refactor, review, commit. Use for any code change that should result in a commit (features, bug fixes, refactors). Ensures clean code with tests, linting passes, and design validation.",
                "path": "ts-react-linter-driven-development/skills/linter-driven-development/SKILL.md",
                "frontmatter": {
                  "name": "linter-driven-development",
                  "description": "META ORCHESTRATOR for complete implementation workflow - design, test, lint, refactor, review, commit. Use for any code change that should result in a commit (features, bug fixes, refactors). Ensures clean code with tests, linting passes, and design validation."
                },
                "content": "# Linter-Driven Development Workflow (TypeScript + React)\n\nMETA ORCHESTRATOR for implementation workflow: design ‚Üí test ‚Üí lint ‚Üí refactor ‚Üí review ‚Üí commit.\nUse for any commit: features, bug fixes, refactors.\n\n## When to Use\n- Implementing any code change that should result in a commit\n- Need automatic workflow management with quality gates\n- Want to ensure: clean code + tests + linting + design validation + accessibility\n\n## Workflow Phases\n\n### Phase 1: Design (if needed)\n- If new components/types/major changes needed ‚Üí invoke @component-designing skill\n- Output: Component design plan with types, hooks, and structure\n\n### Phase 2: Implementation\n- Follow @testing skill principles (Jest + React Testing Library)\n- Write tests + implementation in parallel (not necessarily test-first)\n- Aim for 100% coverage on new leaf components/hooks (pure logic with no external dependencies)\n  - Leaf types: Pure logic (can compose other leaf types), no API/DB/file system access\n  - Orchestrating types: Coordinate leaf types and external systems, need integration tests\n- Test from user perspective (public API only)\n\n### Phase 3: Linter Loop\nRun quality checks in this order:\n1. **Type Check**: `npm run typecheck` (TypeScript compiler)\n2. **Lint Check**: `npm run lintcheck` (ESLint validation)\n3. **Format Check**: `npm run formatcheck` (Prettier validation)\n4. **Style Check**: `npm run stylecheck` (Stylelint for SCSS)\n\nIf any failures detected:\n- Run auto-fixes:\n  - `npm run lint` (ESLint --fix)\n  - `npm run format` (Prettier --write)\n  - `npm run stylefix` (Stylelint --fix)\n- Re-run quality checks\n- If still failing (complexity, design issues):\n  - Interpret failures (cognitive complexity, cyclomatic complexity, etc.)\n  - Invoke @refactoring skill to fix (use storifying, extract functions/hooks, early returns)\n  - Re-run checks\n- Repeat until all checks pass clean\n\n**Alternative**: If project has combined commands:\n- Check: `npm run checkall` or `npm run check`\n- Fix: `npm run fix`\n\n### Phase 4: Pre-Commit Design Review (ADVISORY)\n- Invoke @pre-commit-review skill\n- Review validates design principles (not code correctness)\n- Includes accessibility checks (ARIA, semantic HTML, keyboard nav)\n- Categorized findings: Design Debt / Readability Debt / Polish Opportunities\n- If issues found in broader file context, flag for potential refactor\n- **User decides**: commit as-is, apply fixes, or expand scope\n\n### Phase 5: Commit Ready\n- Type checking passes ‚úÖ\n- ESLint passes ‚úÖ\n- Prettier passes ‚úÖ\n- Stylelint passes ‚úÖ\n- Tests pass with target coverage ‚úÖ\n- Design review complete (advisory) ‚úÖ\n- Present summary + commit message suggestion\n\n## Output Format\n\n```\nüìã COMMIT READINESS SUMMARY\n\n‚úÖ Type Check: Passed (0 errors)\n‚úÖ ESLint: Passed (0 issues)\n‚úÖ Prettier: Passed (all files formatted)\n‚úÖ Stylelint: Passed (0 style issues)\n‚úÖ Tests: 92% coverage (3 leaf hooks at 100%, 1 orchestrating component, 18 test cases)\n‚ö†Ô∏è  Design Review: 3 findings (see below)\n\nüéØ COMMIT SCOPE\nModified:\n- src/features/auth/LoginForm.tsx (+65, -20 lines)\n- src/features/auth/useAuth.ts (+30, -5 lines)\n\nAdded:\n- src/features/auth/types.ts (new: UserId, Email types)\n- src/features/auth/AuthContext.tsx (new context provider)\n\nTests:\n- src/features/auth/LoginForm.test.tsx (+95 lines)\n- src/features/auth/useAuth.test.ts (new)\n- src/features/auth/types.test.ts (new)\n\n‚ö†Ô∏è  DESIGN REVIEW FINDINGS\n\nüî¥ DESIGN DEBT (Recommended to fix):\n- src/features/auth/LoginForm.tsx:45 - Primitive obsession detected\n  Current: function validateEmail(email: string): boolean\n  Better:  Use Zod schema or branded Email type with validation\n  Why: Type safety, validation guarantee, prevents invalid emails\n  Fix: Use @component-designing to create self-validating Email type\n\n- src/features/auth/useAuth.ts:78 - Prop drilling detected\n  Auth state passed through 3+ component levels\n  Why: Tight coupling, hard to maintain\n  Fix: Extract AuthContext or use composition pattern\n\nüü° READABILITY DEBT (Consider fixing):\n- src/features/auth/LoginForm.tsx:120 - Mixed abstraction levels\n  Component mixes validation logic with UI rendering\n  Why: Harder to understand and test independently\n  Fix: Use @refactoring to extract custom hooks (useValidation)\n\n- src/features/auth/LoginForm.tsx:88 - Cognitive complexity: 18 (max: 15)\n  Nested conditionals for form validation\n  Why: Hard to understand logic flow\n  Fix: Use @refactoring to extract validation functions or use Zod\n\nüü¢ POLISH OPPORTUNITIES:\n- src/features/auth/types.ts:12 - Missing JSDoc comments\n  Public types should have documentation\n- src/features/auth/LoginForm.tsx:45 - Consider semantic HTML\n  Use <form> with proper ARIA labels for better accessibility\n- src/features/auth/useAuth.ts:34 - Missing error boundaries\n  Consider wrapping async operations with error handling\n\nüìù BROADER CONTEXT:\nWhile reviewing LoginForm.tsx, noticed similar validation patterns in\nRegisterForm.tsx and ProfileForm.tsx (src/features/user/). Consider\nextracting a shared validation hook or creating branded types for common\nfields (Email, Username, Password) used across the application.\n\nüí° SUGGESTED COMMIT MESSAGE\nAdd self-validating Email and UserId types to auth feature\n\n- Introduce Email type with RFC 5322 validation using Zod\n- Introduce UserId branded type for type safety\n- Refactor LoginForm to use validated types\n- Extract useAuth hook for auth state management\n- Add AuthContext to eliminate prop drilling\n- Achieve 92% test coverage with React Testing Library\n\nFollows component composition principles and reduces primitive obsession.\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nWould you like to:\n1. Commit as-is (ignore design findings)\n2. Fix design debt only (üî¥), then commit\n3. Fix design + readability debt (üî¥ + üü°), then commit\n4. Fix all findings (üî¥ üü° üü¢), then commit\n5. Refactor broader scope (address validation patterns across features), then commit\n```\n\n## Complexity Thresholds (SonarJS)\n\nThese metrics trigger @refactoring when exceeded:\n- **Cognitive Complexity**: max 15\n- **Cyclomatic Complexity**: max 10\n- **Expression Complexity**: max 5\n- **Function Length**: max 200 lines\n- **File Length**: max 600 lines\n- **Nesting Level**: max 4\n\n## Workflow Control\n\n**Sequential Phases**: Each phase depends on previous phase completion\n- Design must complete before implementation\n- Implementation must complete before linting\n- Linting must pass before review\n- Review must complete before commit\n\n**Iterative Linting**: Phase 3 loops until clean\n**Advisory Review**: Phase 4 never blocks, always asks user\n\n## Integration with Other Skills\n\nThis orchestrator **invokes** other skills automatically:\n- @component-designing (Phase 1, if needed)\n- @testing (Phase 2, principles applied)\n- @refactoring (Phase 3, when linter fails on complexity)\n- @pre-commit-review (Phase 4, always)\n\nAfter committing, consider:\n- If feature complete ‚Üí invoke @documentation skill\n- If more work needed ‚Üí run this workflow again for next commit\n\n## Common Linter Failures and Resolutions\n\n### TypeScript Errors (npm run typecheck)\n- Type mismatches ‚Üí Fix types or add proper type guards\n- Missing types ‚Üí Add explicit types or interfaces\n- Cannot fix automatically ‚Üí Manual intervention required\n\n### ESLint Failures (npm run lintcheck)\n**Auto-fixable**:\n- Import sorting (simple-import-sort)\n- Unused imports (unused-imports)\n- Formatting issues covered by Prettier\n- Simple style violations\n\n**Requires refactoring** (invoke @refactoring):\n- Cognitive/cyclomatic complexity\n- Max lines per function\n- Expression complexity\n- Nested control flow\n- React hooks violations\n- Component design issues\n\n### Prettier Failures (npm run formatcheck)\n- Always auto-fixable with `npm run format`\n- No manual intervention needed\n\n### Stylelint Failures (npm run stylecheck)\n- Most auto-fixable with `npm run stylefix`\n- Class naming violations may require manual fixes\n\n## Best Practices\n\n1. **Run checks frequently** during development\n2. **Fix one complexity issue at a time** (don't batch refactoring)\n3. **Trust the advisory review** (design debt causes future pain)\n4. **Test after each refactoring** (ensure behavior unchanged)\n5. **Commit frequently** (small, focused commits)"
              },
              {
                "name": "pre-commit-review",
                "description": "ADVISORY validation of code against design principles, accessibility, and best practices that linters cannot fully enforce. Use after linter passes and tests pass to validate design quality. Categorizes findings as Design Debt, Readability Debt, or Polish Opportunities. Does NOT block commits.",
                "path": "ts-react-linter-driven-development/skills/pre-commit-review/SKILL.md",
                "frontmatter": {
                  "name": "pre-commit-review",
                  "description": "ADVISORY validation of code against design principles, accessibility, and best practices that linters cannot fully enforce. Use after linter passes and tests pass to validate design quality. Categorizes findings as Design Debt, Readability Debt, or Polish Opportunities. Does NOT block commits."
                },
                "content": "# Pre-Commit Design Review (React/TypeScript)\n\nADVISORY validation of code against design principles, accessibility, and practices that linters cannot fully enforce.\nCategorizes findings as Design Debt, Readability Debt, or Polish Opportunities.\n\n## When to Use\n- Automatically invoked by @linter-driven-development (Phase 4)\n- Manually before committing (to validate design quality)\n- After linter passes and tests pass\n\n## What This Reviews\n- **NOT code correctness** (tests verify that)\n- **NOT syntax/style** (ESLint/Prettier enforce that)\n- **YES design principles** (primitive obsession, composition, architecture)\n- **YES maintainability** (readability, complexity, testability)\n- **YES accessibility** (semantic HTML, ARIA, keyboard nav)\n\n## Review Scope\n\n**Primary Scope**: Changed code in commit\n- All modified lines\n- All new components/hooks\n- Specific focus on design principle adherence\n- Accessibility compliance\n\n**Secondary Scope**: Context around changes\n- Entire files containing modifications\n- Flag patterns/issues outside commit scope\n- Suggest broader refactoring opportunities\n\n## Finding Categories (Debt-Based)\n\n### üî¥ Design Debt\n**Will cause pain when extending/modifying code**\n\nViolations:\n- **Primitive obsession**: string IDs, unvalidated inputs, no branded types\n- **Wrong architecture**: Technical layers instead of feature-based\n- **Prop drilling**: State passed through 3+ component levels\n- **Tight coupling**: Components tightly coupled to specific implementations\n- **Missing error boundaries**: No error handling for async operations\n- **No type validation**: Runtime data not validated (no Zod schemas)\n\nImpact: Future changes will require more work and introduce bugs\n\n### üü° Readability Debt\n**Makes code harder to understand and work with**\n\nViolations:\n- **Mixed abstractions**: Business logic mixed with UI in same component\n- **Complex conditions**: Deeply nested or complex boolean expressions\n- **Inline styles/logic**: Complex logic directly in JSX\n- **Poor naming**: Generic names (data, handler, manager, utils)\n- **God components**: Components doing too many things\n- **Missing extraction**: Logic that should be custom hooks\n\nImpact: Team members (and AI) will struggle to understand intent\n\n### üü¢ Polish Opportunities\n**Minor improvements for consistency and quality**\n\nViolations:\n- **Missing JSDoc**: Complex types/hooks without documentation\n- **Accessibility enhancements**: Could be more accessible (but not broken)\n- **Type improvements**: Could use more specific types (vs any/unknown)\n- **Better naming**: Non-idiomatic or unclear names\n- **Performance**: Unnecessary rerenders, missing memoization\n- **Bundle size**: Unused dependencies, large imports\n\nImpact: Low, but improves codebase quality\n\n## Review Workflow\n\n### 0. Architecture Pattern Validation (FIRST CHECK)\n\n**Expected: Feature-based architecture. Design Debt (ADVISORY) - never blocks commit.**\n\nCheck file patterns:\n- `src/features/[feature]/{components,hooks,context}/` ‚Üí ‚úÖ Feature-based\n- `src/{components,hooks,contexts}/[feature].tsx` ‚Üí üî¥ Technical layers (Design Debt)\n\n**Advisory Categories**:\n1. **‚úÖ Feature-based** ‚Üí Praise, note migration progress if applicable\n2. **üü¢ Mixed without docs** ‚Üí Suggest creating `docs/architecture/feature-based-migration.md`\n3. **üî¥ Technical layers (advisory)** ‚Üí Suggest feature-based alternative, respect constraints\n\n**Report Template**:\n```\nüî¥ Design Debt (Advisory): Technical Layer Architecture\n- Current: Code organized by technical type (components/, hooks/, etc.)\n- Preferred: Feature-based structure for better cohesion/maintainability\n- Alternative: Continue as-is (time constraints, team decision valid)\n- Offer: Create migration docs? Refactor? Proceed as-is?\n```\n\n**Always acknowledge**: Time pressure, consistency needs, team decisions are valid reasons to proceed.\n\n---\n\n### 1. Analyze Commit Scope\n```bash\n# Identify what changed\ngit diff --name-only\n\n# See actual changes\ngit diff\n```\n\n### 2. Review Design Principles\n\nCheck for each principle in changed code:\n\n#### Primitive Obsession\n**Look for**:\n- String types for domain concepts (email, userId, etc.)\n- Numbers without validation (age, price, quantity)\n- Booleans representing state (use discriminated unions)\n\n**Example violation**:\n```typescript\n// üî¥ Design Debt\ninterface User {\n  id: string  // What if empty? Not UUID?\n  email: string  // What if invalid?\n}\n\n// ‚úÖ Better\ntype UserId = Brand<string, 'UserId'>\nconst EmailSchema = z.string().email()\n```\n\n#### Component Composition\n**Look for**:\n- Prop drilling (state passed through 3+ levels)\n- Giant components (>200 lines)\n- Mixed UI and business logic\n- Inline complex logic in JSX\n\n**Example violation**:\n```typescript\n// üî¥ Design Debt: Prop drilling\n<Parent>\n  <Middle user={user} onUpdate={onUpdate}>\n    <Deep user={user} onUpdate={onUpdate}>\n      <VeryDeep user={user} onUpdate={onUpdate} />\n    </Deep>\n  </Middle>\n</Parent>\n\n// ‚úÖ Better: Use context or composition\n<UserProvider>\n  <Parent>\n    <Middle><Deep><VeryDeep /></Deep></Middle>\n  </Parent>\n</UserProvider>\n```\n\n#### Custom Hooks\n**Look for**:\n- Complex logic in components (should be in hooks)\n- Duplicated logic across components\n- useEffect with complex dependencies\n\n**Example violation**:\n```typescript\n// üü° Readability Debt: Logic in component\nfunction UserProfile() {\n  const [user, setUser] = useState(null)\n  const [loading, setLoading] = useState(false)\n  useEffect(() => {\n    // 50 lines of fetch logic\n  }, [])\n  // More logic...\n}\n\n// ‚úÖ Better: Extract to hook\nfunction useUser(id) { /* fetch logic */ }\nfunction UserProfile() {\n  const { user, loading } = useUser(userId)\n  return <UI user={user} loading={loading} />\n}\n```\n\n### 3. Review Accessibility\n\n**Check for each component** (jsx-a11y rules + manual review):\n\n#### Semantic HTML\n- Using correct HTML elements (<button>, <form>, <nav>, <main>)\n- Proper heading hierarchy (h1 ‚Üí h2 ‚Üí h3, no skipping)\n- Lists for list content (<ul>, <ol>)\n\n**Example violations**:\n```typescript\n// üî¥ Design Debt: Non-semantic\n<div onClick={handleClick}>Click me</div>  // Should be <button>\n\n// üü° Readability Debt: Wrong heading order\n<h1>Title</h1>\n<h3>Subtitle</h3>  // Skipped h2\n\n// ‚úÖ Better\n<button onClick={handleClick}>Click me</button>\n<h1>Title</h1>\n<h2>Subtitle</h2>\n```\n\n#### ARIA Attributes\n- Form inputs have labels\n- Interactive elements have accessible names\n- Images have alt text\n- Dialogs have proper roles and labels\n\n**Example violations**:\n```typescript\n// üî¥ Design Debt: Missing label\n<input type=\"text\" placeholder=\"Email\" />\n\n// üü¢ Polish: Could improve alt text\n<img src=\"avatar.jpg\" alt=\"image\" />  // Generic\n\n// ‚úÖ Better\n<label htmlFor=\"email\">Email</label>\n<input id=\"email\" type=\"text\" />\n\n<img src=\"avatar.jpg\" alt=\"John Doe's profile picture\" />\n```\n\n#### Keyboard Navigation\n- All interactive elements keyboard accessible\n- Focus styles visible\n- Logical tab order\n- Escape closes modals\n\n**Example violations**:\n```typescript\n// üî¥ Design Debt: No keyboard support\n<div onClick={handleClick}>Action</div>\n\n// ‚úÖ Better\n<button onClick={handleClick}>Action</button>\n\n// Or if div required:\n<div\n  role=\"button\"\n  tabIndex={0}\n  onClick={handleClick}\n  onKeyDown={(e) => e.key === 'Enter' && handleClick()}\n>\n  Action\n</div>\n```\n\n#### Color and Contrast\n- Text readable (sufficient contrast)\n- Not relying on color alone for meaning\n- Focus indicators visible\n\n**Example violations**:\n```typescript\n// üü° Readability Debt: Color only indicates error\n<Input style={{ borderColor: 'red' }} />\n\n// ‚úÖ Better: Visual + text indicator\n<Input\n  aria-invalid=\"true\"\n  aria-describedby=\"email-error\"\n  style={{ borderColor: 'red' }}\n/>\n<span id=\"email-error\">Email is invalid</span>\n```\n\n#### Screen Reader Support\n- Dynamic content announces updates (aria-live)\n- Loading states communicated\n- Error messages associated with fields\n\n**Example violations**:\n```typescript\n// üü¢ Polish: Loading not announced\n{isLoading && <Spinner />}\n\n// ‚úÖ Better\n{isLoading && (\n  <div role=\"status\" aria-live=\"polite\">\n    Loading user data...\n    <Spinner aria-hidden=\"true\" />\n  </div>\n)}\n```\n\n### 4. Review TypeScript Usage\n\n**Type safety**:\n- Using `any` or `unknown` without validation\n- Missing type definitions for props\n- Not using branded types for domain concepts\n- Not using Zod for runtime validation\n\n**Example violations**:\n```typescript\n// üî¥ Design Debt: Using any\nfunction processData(data: any) { }\n\n// üü° Readability Debt: Inline type\nfunction Button(props: { label: string; onClick: () => void }) { }\n\n// ‚úÖ Better\nconst DataSchema = z.object({ /* ... */ })\nfunction processData(data: z.infer<typeof DataSchema>) { }\n\ninterface ButtonProps {\n  label: string\n  onClick: () => void\n}\nfunction Button({ label, onClick }: ButtonProps) { }\n```\n\n### 5. Review Testing Implications\n\n**Testability**:\n- Components too complex to test\n- Logic not extracted to testable units\n- Testing implementation details (bad)\n\n**Example violations**:\n```typescript\n// üü° Readability Debt: Hard to test\nfunction ComplexForm() {\n  // 200 lines of intertwined logic and UI\n  // Would need to test implementation details\n}\n\n// ‚úÖ Better: Separated concerns\nfunction useFormLogic() { /* testable hook */ }\nfunction FormUI({ state, actions }) { /* testable UI */ }\n```\n\n### 6. Broader Context Review\n\nAfter reviewing changed code, scan entire modified files for:\n- Similar violations elsewhere in file\n- Patterns suggesting broader refactoring\n- Opportunities for consistency improvements\n\n**Report format**:\n```\nüìù BROADER CONTEXT:\nWhile reviewing LoginForm.tsx, noticed similar validation patterns in\nRegisterForm.tsx and ProfileForm.tsx (src/features/user/). Consider\nextracting shared validation logic to a useFormValidation hook or\ncreating branded types for Email, Password used across features.\n```\n\n## Output Format\n\nAfter review:\n\n```\n‚ö†Ô∏è  PRE-COMMIT REVIEW FINDINGS\n\nReviewed:\n- src/features/auth/LoginForm.tsx (+45, -20 lines)\n- src/features/auth/types.ts (+15, -0 lines)\n- src/features/auth/useAuth.ts (+30, -5 lines)\n\nüî¥ DESIGN DEBT (2 findings) - Recommended to fix:\n\n1. src/features/auth/LoginForm.tsx:45 - Primitive obsession\n   Current: email validation with regex inline\n   Better:  Use Zod schema or branded Email type\n   Why:     Type safety, validation guarantee, reusable across features\n   Fix:     Use @component-designing to create Email type\n\n2. src/features/auth/LoginForm.tsx:89 - Missing error boundary\n   Current: Async login can fail silently\n   Better:  Wrap with ErrorBoundary or add error handling\n   Why:     Better user experience, prevents broken UI\n   Fix:     Add ErrorBoundary or try-catch with user feedback\n\nüü° READABILITY DEBT (3 findings) - Consider fixing:\n\n1. src/features/auth/LoginForm.tsx:120 - Mixed abstractions\n   Component mixes validation logic with UI rendering\n   Why:     Harder to understand and test independently\n   Fix:     Extract validation to useFormValidation hook\n\n2. src/features/auth/LoginForm.tsx:67 - Complex condition\n   if (email && email.length > 0 && /regex/.test(email) && !isSubmitting && !error)\n   Why:     Hard to understand intent\n   Fix:     Extract to: const canSubmit = isFormValid(email, isSubmitting, error)\n\n3. src/features/auth/useAuth.ts:34 - Missing hook extraction\n   Complex useEffect with multiple concerns\n   Why:     Hard to test, hard to reuse\n   Fix:     Split into useLogin and useAuthState hooks\n\nüü¢ POLISH OPPORTUNITIES (4 findings) - Optional improvements:\n\n1. src/features/auth/types.ts:10 - Missing JSDoc\n   Public Email type should have documentation\n   Suggestion: Add JSDoc explaining validation rules\n\n2. src/features/auth/LoginForm.tsx:12 - Accessibility enhancement\n   Form could use aria-describedby for better screen reader support\n   Current:  <input type=\"email\" />\n   Better:   <input type=\"email\" aria-describedby=\"email-hint\" />\n   Impact:   Better accessibility for screen reader users\n\n3. src/features/auth/LoginForm.tsx:55 - Keyboard navigation\n   Close button could have Escape key handler\n   Suggestion: Add onKeyDown handler for Escape key\n\n4. src/features/auth/useAuth.ts:89 - Type improvement\n   Return type could be more specific than { user: User | null }\n   Suggestion: Use discriminated union for different states\n\nüìù BROADER CONTEXT:\nWhile reviewing LoginForm.tsx, noticed similar validation patterns in\nRegisterForm.tsx (lines 45-67) and ProfileForm.tsx (lines 89-110).\nConsider:\n- Extract shared validation to useFormValidation hook\n- Create branded Email and Password types used across auth feature\n- Add error boundaries to all auth forms consistently\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nüí° RECOMMENDATION:\nFix design debt (üî¥) before committing if possible. Design debt compounds\nover time and makes future changes harder. Readability and Polish can be\naddressed in follow-up commits.\n\nWould you like to:\n1. Commit as-is (accept debt)\n2. Fix design debt (üî¥), then commit\n3. Fix design + readability (üî¥ + üü°), then commit\n4. Fix all findings (üî¥ üü° üü¢), then commit\n5. Refactor broader scope (address validation patterns across features)\n```\n\n## Key Principles\n\nSee reference.md for detailed principles:\n- Primitive obsession prevention\n- Component composition over prop drilling\n- Custom hooks for reusable logic\n- Semantic HTML and ARIA\n- Type safety with TypeScript and Zod\n- Testability and separation of concerns\n- Accessibility is not optional\n\n## After Review\n\nThis is **ADVISORY** only. User decides:\n- Accept debt knowingly\n- Fix critical issues (design debt)\n- Fix all findings\n- Expand refactoring scope\n\nThe review never blocks commits. It informs decisions.\n\nSee reference.md for complete review checklist and examples."
              },
              {
                "name": "refactoring",
                "description": "Linter-driven refactoring patterns to reduce complexity and improve code quality in React/TypeScript. Use when ESLint fails with SonarJS complexity issues (cognitive, cyclomatic, expression) or when code feels hard to read/maintain. Applies component extraction, hook extraction, and simplification patterns.",
                "path": "ts-react-linter-driven-development/skills/refactoring/SKILL.md",
                "frontmatter": {
                  "name": "refactoring",
                  "description": "Linter-driven refactoring patterns to reduce complexity and improve code quality in React/TypeScript. Use when ESLint fails with SonarJS complexity issues (cognitive, cyclomatic, expression) or when code feels hard to read/maintain. Applies component extraction, hook extraction, and simplification patterns."
                },
                "content": "# Refactoring (React/TypeScript)\n\nLinter-driven refactoring patterns to reduce complexity and improve React code quality.\n\n## When to Use\n- ESLint fails with SonarJS complexity issues\n- Code feels hard to read or maintain\n- Components/functions are too long or deeply nested\n- Automatically invoked by @linter-driven-development when linter fails\n\n## Refactoring Signals\n\n### SonarJS Linter Failures\n- **sonarjs/cognitive-complexity** (max: 15) ‚Üí Simplify logic, extract functions/hooks\n- **sonarjs/cyclomatic-complexity** (max: 10) ‚Üí Reduce branches, early returns\n- **sonarjs/expression-complexity** (max: 5) ‚Üí Extract variables, simplify conditions\n- **sonarjs/max-lines-per-function** (max: 200) ‚Üí Extract components/hooks\n- **sonarjs/max-lines** (max: 600) ‚Üí Split file into multiple files\n- **sonarjs/nested-control-flow** (max: 4) ‚Üí Early returns, guard clauses\n\n### React-Specific Signals\n- **react/no-unstable-nested-components** ‚Üí Extract component definitions\n- **react/no-multi-comp** ‚Üí Split into separate files\n- **react-hooks/exhaustive-deps** ‚Üí Simplify dependencies, extract logic\n\n### Code Smells\n- Components > 200 LOC\n- Functions with > 4 levels of nesting\n- Mixed abstraction levels (UI + business logic)\n- Inline complex logic in JSX\n- Deeply nested conditionals\n\n## Workflow\n\n### 1. Interpret Linter Output\n\nRun `npm run lintcheck` and analyze failures:\n```\nsrc/features/auth/LoginForm.tsx:45:1: Cognitive Complexity of 18 exceeds max of 15\nsrc/features/users/UserList.tsx:120:5: Cyclomatic Complexity of 12 exceeds max of 10\nsrc/components/DataTable.tsx:89:1: Function has 250 lines, max is 200\n```\n\n### 2. Diagnose Root Cause\n\nFor each failure, ask:\n- **Mixed abstractions?** ‚Üí Extract custom hooks, extract components\n- **Complex conditionals?** ‚Üí Early returns, guard clauses, extract conditions\n- **Primitive obsession?** ‚Üí Create Zod schemas or branded types\n- **Long component?** ‚Üí Split into smaller components\n- **Nested components?** ‚Üí Extract to separate components\n- **Complex JSX logic?** ‚Üí Extract to helper functions or hooks\n\n### 3. Apply Refactoring Pattern\n\nChoose appropriate pattern:\n- **Extract Custom Hook**: Move logic out of component\n- **Extract Component**: Break down large components\n- **Extract Helper Function**: Simplify complex logic\n- **Early Returns/Guard Clauses**: Reduce nesting\n- **Simplify Conditions**: Extract to variables, use early returns\n- **Extract Validation**: Move to Zod schemas or validation functions\n\n### 4. Verify Improvement\n\n- Re-run linter: `npm run lintcheck`\n- Tests still pass: `npm test`\n- Code more readable?\n\n## Refactoring Patterns\n\n### Pattern 1: Extract Custom Hook (Business Logic)\n\n**Signal**: Component mixing UI with complex logic\n\n```typescript\n// ‚ùå Before - Complex logic in component (Cognitive Complexity: 18)\nfunction UserProfile({ userId }: { userId: string }) {\n  const [user, setUser] = useState<User | null>(null)\n  const [isLoading, setIsLoading] = useState(false)\n  const [error, setError] = useState<Error | null>(null)\n\n  useEffect(() => {\n    const fetchUser = async () => {\n      setIsLoading(true)\n      setError(null)\n      try {\n        const response = await fetch(`/api/users/${userId}`)\n        if (!response.ok) {\n          throw new Error('Failed to fetch user')\n        }\n        const data = await response.json()\n        setUser(data)\n      } catch (err) {\n        setError(err as Error)\n      } finally {\n        setIsLoading(false)\n      }\n    }\n    fetchUser()\n  }, [userId])\n\n  if (isLoading) return <Spinner />\n  if (error) return <ErrorMessage error={error} />\n  if (!user) return <NotFound />\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>{user.email}</p>\n    </div>\n  )\n}\n\n// ‚úÖ After - Logic extracted to hook (Component Complexity: 4)\nfunction useUser(userId: string) {\n  const [user, setUser] = useState<User | null>(null)\n  const [isLoading, setIsLoading] = useState(false)\n  const [error, setError] = useState<Error | null>(null)\n\n  useEffect(() => {\n    const fetchUser = async () => {\n      setIsLoading(true)\n      setError(null)\n      try {\n        const response = await fetch(`/api/users/${userId}`)\n        if (!response.ok) throw new Error('Failed to fetch user')\n        setUser(await response.json())\n      } catch (err) {\n        setError(err as Error)\n      } finally {\n        setIsLoading(false)\n      }\n    }\n    fetchUser()\n  }, [userId])\n\n  return { user, isLoading, error }\n}\n\nfunction UserProfile({ userId }: { userId: string }) {\n  const { user, isLoading, error } = useUser(userId)\n\n  if (isLoading) return <Spinner />\n  if (error) return <ErrorMessage error={error} />\n  if (!user) return <NotFound />\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>{user.email}</p>\n    </div>\n  )\n}\n```\n\n### Pattern 2: Extract Component (Break Down Large Components)\n\n**Signal**: Component > 200 lines, doing too much\n\n```typescript\n// ‚ùå Before - Large component (250 lines, Cognitive Complexity: 22)\nfunction UserDashboard() {\n  const [users, setUsers] = useState([])\n  const [selectedUser, setSelectedUser] = useState(null)\n  const [isEditing, setIsEditing] = useState(false)\n  const [searchTerm, setSearchTerm] = useState('')\n\n  // ... 200+ lines of logic and JSX\n\n  return (\n    <div>\n      {/* Search bar */}\n      <input value={searchTerm} onChange={e => setSearchTerm(e.target.value)} />\n\n      {/* User list */}\n      <ul>\n        {users.filter(u => u.name.includes(searchTerm)).map(user => (\n          <li key={user.id} onClick={() => setSelectedUser(user)}>\n            {user.name} - {user.email}\n            <button onClick={() => setIsEditing(true)}>Edit</button>\n            <button onClick={() => deleteUser(user.id)}>Delete</button>\n          </li>\n        ))}\n      </ul>\n\n      {/* User detail */}\n      {selectedUser && (\n        <div>\n          {isEditing ? (\n            <form>...</form>\n          ) : (\n            <div>...</div>\n          )}\n        </div>\n      )}\n    </div>\n  )\n}\n\n// ‚úÖ After - Broken into focused components\nfunction UserDashboard() {\n  const [selectedUser, setSelectedUser] = useState<User | null>(null)\n\n  return (\n    <div>\n      <UserSearch />\n      <UserList onSelectUser={setSelectedUser} />\n      {selectedUser && <UserDetail user={selectedUser} />}\n    </div>\n  )\n}\n\nfunction UserSearch() {\n  const [searchTerm, setSearchTerm] = useState('')\n  // Search logic\n  return <input value={searchTerm} onChange={...} />\n}\n\nfunction UserList({ onSelectUser }: { onSelectUser: (user: User) => void }) {\n  const { users } = useUsers()\n  return (\n    <ul>\n      {users.map(user => (\n        <UserListItem key={user.id} user={user} onSelect={onSelectUser} />\n      ))}\n    </ul>\n  )\n}\n\nfunction UserListItem({ user, onSelect }: UserListItemProps) {\n  return (\n    <li onClick={() => onSelect(user)}>\n      <span>{user.name}</span>\n      <UserActions user={user} />\n    </li>\n  )\n}\n```\n\n### Pattern 3: Early Returns / Guard Clauses (Reduce Nesting)\n\n**Signal**: Deeply nested conditionals, cyclomatic complexity high\n\n```typescript\n// ‚ùå Before - Deep nesting (Cyclomatic Complexity: 12, Nesting: 5)\nfunction validateAndSubmit(data: FormData) {\n  if (data) {\n    if (data.email) {\n      if (isValidEmail(data.email)) {\n        if (data.password) {\n          if (data.password.length >= 8) {\n            if (data.terms) {\n              return submitForm(data)\n            } else {\n              return { error: 'Must accept terms' }\n            }\n          } else {\n            return { error: 'Password too short' }\n          }\n        } else {\n          return { error: 'Password required' }\n        }\n      } else {\n        return { error: 'Invalid email' }\n      }\n    } else {\n      return { error: 'Email required' }\n    }\n  }\n  return { error: 'No data' }\n}\n\n// ‚úÖ After - Early returns (Cyclomatic Complexity: 7, Nesting: 1)\nfunction validateAndSubmit(data: FormData) {\n  if (!data) return { error: 'No data' }\n  if (!data.email) return { error: 'Email required' }\n  if (!isValidEmail(data.email)) return { error: 'Invalid email' }\n  if (!data.password) return { error: 'Password required' }\n  if (data.password.length < 8) return { error: 'Password too short' }\n  if (!data.terms) return { error: 'Must accept terms' }\n\n  return submitForm(data)\n}\n\n// ‚úÖ Even better - Use Zod schema\nconst FormDataSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(8),\n  terms: z.boolean().refine(val => val === true, 'Must accept terms')\n})\n\nfunction validateAndSubmit(data: unknown) {\n  const result = FormDataSchema.safeParse(data)\n  if (!result.success) {\n    return { error: result.error.errors[0].message }\n  }\n  return submitForm(result.data)\n}\n```\n\n### Pattern 4: Extract Complex Conditions (Simplify Expression Complexity)\n\n**Signal**: Complex boolean expressions, expression complexity > 5\n\n```typescript\n// ‚ùå Before - Complex condition (Expression Complexity: 8)\nif (\n  user &&\n  user.isActive &&\n  !user.isBanned &&\n  user.subscription &&\n  user.subscription.status === 'active' &&\n  user.subscription.expiresAt > Date.now() &&\n  (user.roles.includes('admin') || user.roles.includes('moderator'))\n) {\n  // Allow access\n}\n\n// ‚úÖ After - Extracted to helper functions\nfunction hasActiveSubscription(user: User): boolean {\n  return (\n    user.subscription?.status === 'active' &&\n    user.subscription.expiresAt > Date.now()\n  )\n}\n\nfunction hasModeratorAccess(user: User): boolean {\n  return user.roles.includes('admin') || user.roles.includes('moderator')\n}\n\nfunction canAccessFeature(user: User): boolean {\n  return (\n    user.isActive &&\n    !user.isBanned &&\n    hasActiveSubscription(user) &&\n    hasModeratorAccess(user)\n  )\n}\n\nif (user && canAccessFeature(user)) {\n  // Allow access\n}\n\n// ‚úÖ Or extract to variables\nconst isUserValid = user.isActive && !user.isBanned\nconst hasSubscription = hasActiveSubscription(user)\nconst isModerator = hasModeratorAccess(user)\n\nif (user && isUserValid && hasSubscription && isModerator) {\n  // Allow access\n}\n```\n\n### Pattern 5: Extract Unstable Nested Components\n\n**Signal**: react/no-unstable-nested-components\n\n```typescript\n// ‚ùå Before - Component defined inside component\nfunction UserList() {\n  const users = useUsers()\n\n  // ‚ùå Recreated on every render\n  const UserCard = ({ user }: { user: User }) => (\n    <div>\n      <h3>{user.name}</h3>\n      <p>{user.email}</p>\n    </div>\n  )\n\n  return (\n    <div>\n      {users.map(user => <UserCard key={user.id} user={user} />)}\n    </div>\n  )\n}\n\n// ‚úÖ After - Component extracted\nfunction UserCard({ user }: { user: User }) {\n  return (\n    <div>\n      <h3>{user.name}</h3>\n      <p>{user.email}</p>\n    </div>\n  )\n}\n\nfunction UserList() {\n  const users = useUsers()\n  return (\n    <div>\n      {users.map(user => <UserCard key={user.id} user={user} />)}\n    </div>\n  )\n}\n```\n\n### Pattern 6: Simplify Hook Dependencies\n\n**Signal**: react-hooks/exhaustive-deps warnings, complex useEffect\n\n```typescript\n// ‚ùå Before - Complex dependencies\nfunction SearchResults({ initialQuery, filters, sortBy }: Props) {\n  const [results, setResults] = useState([])\n\n  useEffect(() => {\n    const fetchResults = async () => {\n      const response = await api.search({\n        query: initialQuery,\n        filters: filters,\n        sort: sortBy,\n        page: 1\n      })\n      setResults(response.data)\n    }\n    fetchResults()\n  }, [initialQuery, filters, sortBy, filters.category, filters.price]) // ‚ùå Duplicates, object deps\n}\n\n// ‚úÖ After - Simplified with custom hook\nfunction useSearchResults(query: string, filters: Filters, sortBy: string) {\n  const [results, setResults] = useState([])\n\n  // Stable object reference\n  const searchParams = useMemo(\n    () => ({ query, filters, sort: sortBy, page: 1 }),\n    [query, filters, sortBy]\n  )\n\n  useEffect(() => {\n    api.search(searchParams).then(response => setResults(response.data))\n  }, [searchParams])\n\n  return results\n}\n\nfunction SearchResults({ initialQuery, filters, sortBy }: Props) {\n  const results = useSearchResults(initialQuery, filters, sortBy)\n  return <ResultsList results={results} />\n}\n```\n\n### Pattern 7: Extract Form Validation Logic\n\n**Signal**: Complex validation in components\n\n```typescript\n// ‚ùå Before - Validation scattered in component\nfunction LoginForm() {\n  const [email, setEmail] = useState('')\n  const [password, setPassword] = useState('')\n  const [errors, setErrors] = useState({})\n\n  const handleSubmit = () => {\n    const newErrors = {}\n\n    if (!email) {\n      newErrors.email = 'Email required'\n    } else if (!/\\S+@\\S+\\.\\S+/.test(email)) {\n      newErrors.email = 'Invalid email'\n    }\n\n    if (!password) {\n      newErrors.password = 'Password required'\n    } else if (password.length < 8) {\n      newErrors.password = 'Password too short'\n    }\n\n    if (Object.keys(newErrors).length > 0) {\n      setErrors(newErrors)\n      return\n    }\n\n    submitLogin(email, password)\n  }\n\n  // ...JSX\n}\n\n// ‚úÖ After - Validation with Zod\nimport { z } from 'zod'\n\nconst LoginSchema = z.object({\n  email: z.string().email('Invalid email'),\n  password: z.string().min(8, 'Password must be at least 8 characters')\n})\n\nfunction LoginForm() {\n  const { values, errors, setValue, handleSubmit } = useFormValidation(\n    LoginSchema,\n    { email: '', password: '' },\n    submitLogin\n  )\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <Input\n        label='Email'\n        value={values.email}\n        onChange={e => setValue('email', e.target.value)}\n        error={errors.email}\n      />\n      <Input\n        label='Password'\n        type='password'\n        value={values.password}\n        onChange={e => setValue('password', e.target.value)}\n        error={errors.password}\n      />\n      <button type='submit'>Login</button>\n    </form>\n  )\n}\n```\n\n## Refactoring Decision Tree\n\nWhen linter fails, follow this decision tree:\n\n```\nLinter Failure\n    ‚îú‚îÄ Cognitive Complexity > 15\n    ‚îÇ   ‚îú‚îÄ Mixed abstractions? ‚Üí Extract custom hooks\n    ‚îÇ   ‚îú‚îÄ Complex conditions? ‚Üí Extract to helper functions\n    ‚îÇ   ‚îî‚îÄ Deep nesting? ‚Üí Early returns, guard clauses\n    ‚îÇ\n    ‚îú‚îÄ Cyclomatic Complexity > 10\n    ‚îÇ   ‚îú‚îÄ Many branches? ‚Üí Early returns\n    ‚îÇ   ‚îú‚îÄ Complex switch? ‚Üí Use object mapping or extract functions\n    ‚îÇ   ‚îî‚îÄ Multiple &&/|| chains? ‚Üí Extract conditions to variables\n    ‚îÇ\n    ‚îú‚îÄ Expression Complexity > 5\n    ‚îÇ   ‚îú‚îÄ Long boolean expressions? ‚Üí Extract to variables\n    ‚îÇ   ‚îî‚îÄ Nested ternaries? ‚Üí Extract to function or if statements\n    ‚îÇ\n    ‚îú‚îÄ Max Lines Per Function > 200\n    ‚îÇ   ‚îú‚îÄ Large component? ‚Üí Extract smaller components\n    ‚îÇ   ‚îú‚îÄ Complex logic? ‚Üí Extract custom hooks\n    ‚îÇ   ‚îî‚îÄ Mixed concerns? ‚Üí Separate UI from business logic\n    ‚îÇ\n    ‚îú‚îÄ Nested Control Flow > 4\n    ‚îÇ   ‚îî‚îÄ Deep nesting? ‚Üí Early returns, guard clauses\n    ‚îÇ\n    ‚îî‚îÄ React-specific\n        ‚îú‚îÄ no-unstable-nested-components ‚Üí Extract component definition\n        ‚îú‚îÄ no-multi-comp ‚Üí Split into separate files\n        ‚îî‚îÄ exhaustive-deps ‚Üí Simplify dependencies, extract logic\n```\n\n## Key Principles\n\nSee reference.md for detailed principles:\n- Single Responsibility: Each component/hook does one thing\n- Extract Early, Extract Often: Don't wait for linter to fail\n- Composition Over Complexity: Combine simple pieces\n- Guard Clauses: Exit early, reduce nesting\n- Extract Helper Functions: Name complex logic\n- Custom Hooks: Reusable logic outside components\n- Zod for Validation: Move validation out of components\n\n## After Refactoring\n\n- [ ] Re-run linter: `npm run lintcheck`\n- [ ] Run tests: `npm test`\n- [ ] Verify behavior unchanged\n- [ ] Check if more readable\n- [ ] Consider broader refactoring if patterns repeat\n\nSee reference.md for complete refactoring patterns and decision trees."
              },
              {
                "name": "testing",
                "description": "Principles and patterns for writing effective React tests with Jest and React Testing Library. Use during implementation for test structure guidance, choosing test patterns, and deciding testing strategies. Emphasizes testing user behavior, not implementation details.",
                "path": "ts-react-linter-driven-development/skills/testing/SKILL.md",
                "frontmatter": {
                  "name": "testing",
                  "description": "Principles and patterns for writing effective React tests with Jest and React Testing Library. Use during implementation for test structure guidance, choosing test patterns, and deciding testing strategies. Emphasizes testing user behavior, not implementation details."
                },
                "content": "# Testing Principles (Jest + React Testing Library)\n\nPrinciples and patterns for writing effective TypeScript + React tests.\n\n## When to Use\n- During implementation (tests + code in parallel)\n- When testing strategy is unclear\n- When structuring component or hook tests\n- When choosing between test patterns\n\n## Testing Philosophy\n\n**Test user behavior, not implementation details**\n- Test what users see and do\n- Use accessible queries (getByRole, getByLabelText)\n- Avoid testing internal state or methods\n- Focus on public API\n\n**Prefer real implementations over mocks**\n- Use MSW (Mock Service Worker) for API mocking\n- Use real hooks and contexts\n- Test components with actual dependencies\n- Integration-style tests over unit tests\n\n**Coverage targets**\n- Pure components/hooks: 100% coverage\n- Container components: Integration tests for user flows\n- Custom hooks: Test all branches and edge cases\n\n## Workflow\n\n### 1. Identify What to Test\n\n**Pure Components/Hooks (Leaf types)**:\n- No external dependencies\n- Predictable output for given input\n- Test all branches, edge cases, errors\n- Aim for 100% coverage\n\nExamples:\n- Button, Input, Card (presentational components)\n- useDebounce, useLocalStorage (utility hooks)\n- Validation functions, formatters\n\n**Container Components (Orchestrating types)**:\n- Coordinate multiple components\n- Manage state and side effects\n- Test user workflows, not implementation\n- Integration tests with real dependencies\n\nExamples:\n- LoginContainer, UserProfileContainer\n- Feature-level components with data fetching\n\n### 2. Choose Test Structure\n\n**test.each() - Use when:**\n- Testing same logic with different inputs\n- Each test case is simple (no conditionals)\n- Type-safe with TypeScript\n\n**describe/it blocks - Use when:**\n- Testing complex user flows\n- Need setup/teardown per test\n- Testing different scenarios\n\n**React Testing Library Suite - Always use:**\n- render() for components\n- screen queries (getByRole, getByText, etc.)\n- user-event for interactions\n- waitFor for async operations\n\n### 3. Write Tests Next to Implementation\n\n```typescript\n// src/features/auth/components/LoginForm.tsx\n// src/features/auth/components/LoginForm.test.tsx\n```\n\n### 4. Use Real Implementations\n\n```typescript\n// ‚úÖ Good: Real implementations\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { AuthProvider } from '../context/AuthContext'\nimport { LoginForm } from './LoginForm'\n\n// MSW for API mocking (real HTTP)\nimport { rest } from 'msw'\nimport { setupServer } from 'msw/node'\n\nconst server = setupServer(\n  rest.post('/api/login', (req, res, ctx) => {\n    return res(ctx.json({ token: 'fake-token' }))\n  })\n)\n\nbeforeAll(() => server.listen())\nafterEach(() => server.resetHandlers())\nafterAll(() => server.close())\n\ntest('user can log in', async () => {\n  const user = userEvent.setup()\n\n  render(\n    <AuthProvider>\n      <LoginForm />\n    </AuthProvider>\n  )\n\n  // Real user interactions\n  await user.type(screen.getByLabelText(/email/i), 'test@example.com')\n  await user.type(screen.getByLabelText(/password/i), 'password123')\n  await user.click(screen.getByRole('button', { name: /log in/i }))\n\n  // Assert on user-visible changes\n  expect(await screen.findByText(/welcome/i)).toBeInTheDocument()\n})\n```\n\n### 5. Avoid Common Pitfalls\n\n- ‚ùå No waitFor(() => {}, { timeout: 5000 }) with arbitrary delays\n- ‚ùå No testing implementation details (state, internal methods)\n- ‚ùå No shallow rendering (use full render)\n- ‚ùå No excessive mocking (use MSW for APIs)\n- ‚ùå No getByTestId unless absolutely necessary (use accessibility queries)\n\n## Test Patterns\n\n### Pattern 1: Table-Driven Tests (test.each)\n\n```typescript\nimport { render, screen } from '@testing-library/react'\nimport { Button } from './Button'\n\ndescribe('Button', () => {\n  test.each([\n    { variant: 'primary', expectedClass: 'btn-primary' },\n    { variant: 'secondary', expectedClass: 'btn-secondary' },\n    { variant: 'danger', expectedClass: 'btn-danger' }\n  ])('renders $variant variant with class $expectedClass', ({ variant, expectedClass }) => {\n    render(<Button variant={variant} label='Click me' onClick={() => {}} />)\n\n    const button = screen.getByRole('button', { name: /click me/i })\n    expect(button).toHaveClass(expectedClass)\n  })\n\n  test.each([\n    { isDisabled: true, shouldBeDisabled: true },\n    { isDisabled: false, shouldBeDisabled: false }\n  ])('when isDisabled=$isDisabled, button is disabled=$shouldBeDisabled',\n    ({ isDisabled, shouldBeDisabled }) => {\n      render(<Button label='Click me' onClick={() => {}} isDisabled={isDisabled} />)\n\n      const button = screen.getByRole('button')\n      if (shouldBeDisabled) {\n        expect(button).toBeDisabled()\n      } else {\n        expect(button).toBeEnabled()\n      }\n    }\n  )\n})\n```\n\n### Pattern 2: Component with User Interactions\n\n```typescript\nimport { render, screen, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { SearchBox } from './SearchBox'\n\ndescribe('SearchBox', () => {\n  test('calls onSearch when user types and submits', async () => {\n    const user = userEvent.setup()\n    const onSearch = jest.fn()\n\n    render(<SearchBox onSearch={onSearch} />)\n\n    // Type in search box\n    const input = screen.getByRole('textbox', { name: /search/i })\n    await user.type(input, 'react testing')\n\n    // Submit form\n    await user.click(screen.getByRole('button', { name: /search/i }))\n\n    // Assert callback called\n    expect(onSearch).toHaveBeenCalledWith('react testing')\n    expect(onSearch).toHaveBeenCalledTimes(1)\n  })\n\n  test('shows validation error for empty search', async () => {\n    const user = userEvent.setup()\n    const onSearch = jest.fn()\n\n    render(<SearchBox onSearch={onSearch} />)\n\n    // Submit without typing\n    await user.click(screen.getByRole('button', { name: /search/i }))\n\n    // Assert error message\n    expect(screen.getByText(/search cannot be empty/i)).toBeInTheDocument()\n    expect(onSearch).not.toHaveBeenCalled()\n  })\n})\n```\n\n### Pattern 3: Testing Custom Hooks\n\n```typescript\nimport { renderHook, waitFor } from '@testing-library/react'\nimport { useUsers } from './useUsers'\n\n// MSW setup for API\nimport { rest } from 'msw'\nimport { setupServer } from 'msw/node'\n\nconst mockUsers = [\n  { id: '1', name: 'Alice', email: 'alice@example.com' },\n  { id: '2', name: 'Bob', email: 'bob@example.com' }\n]\n\nconst server = setupServer(\n  rest.get('/api/users', (req, res, ctx) => {\n    return res(ctx.json(mockUsers))\n  })\n)\n\nbeforeAll(() => server.listen())\nafterEach(() => server.resetHandlers())\nafterAll(() => server.close())\n\ndescribe('useUsers', () => {\n  test('fetches users successfully', async () => {\n    const { result } = renderHook(() => useUsers())\n\n    // Initially loading\n    expect(result.current.isLoading).toBe(true)\n    expect(result.current.users).toEqual([])\n\n    // Wait for data to load\n    await waitFor(() => {\n      expect(result.current.isLoading).toBe(false)\n    })\n\n    // Assert users loaded\n    expect(result.current.users).toEqual(mockUsers)\n    expect(result.current.error).toBeNull()\n  })\n\n  test('handles error when fetch fails', async () => {\n    // Override handler to return error\n    server.use(\n      rest.get('/api/users', (req, res, ctx) => {\n        return res(ctx.status(500), ctx.json({ message: 'Server error' }))\n      })\n    )\n\n    const { result } = renderHook(() => useUsers())\n\n    await waitFor(() => {\n      expect(result.current.isLoading).toBe(false)\n    })\n\n    expect(result.current.users).toEqual([])\n    expect(result.current.error).toBeTruthy()\n  })\n})\n```\n\n### Pattern 4: Testing with Context\n\n```typescript\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { AuthProvider } from '../context/AuthContext'\nimport { ProtectedRoute } from './ProtectedRoute'\n\n// Helper to render with providers\nfunction renderWithAuth(ui: React.ReactElement, { user = null } = {}) {\n  return render(\n    <AuthProvider initialUser={user}>\n      {ui}\n    </AuthProvider>\n  )\n}\n\ndescribe('ProtectedRoute', () => {\n  test('redirects to login when user is not authenticated', () => {\n    renderWithAuth(<ProtectedRoute><div>Protected Content</div></ProtectedRoute>)\n\n    expect(screen.queryByText(/protected content/i)).not.toBeInTheDocument()\n    expect(screen.getByText(/please log in/i)).toBeInTheDocument()\n  })\n\n  test('shows content when user is authenticated', () => {\n    const user = { id: '1', email: 'test@example.com', name: 'Test User' }\n\n    renderWithAuth(\n      <ProtectedRoute><div>Protected Content</div></ProtectedRoute>,\n      { user }\n    )\n\n    expect(screen.getByText(/protected content/i)).toBeInTheDocument()\n    expect(screen.queryByText(/please log in/i)).not.toBeInTheDocument()\n  })\n})\n```\n\n### Pattern 5: Async Operations (waitFor)\n\n```typescript\nimport { render, screen, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { UserProfile } from './UserProfile'\n\ntest('loads and displays user profile', async () => {\n  render(<UserProfile userId='123' />)\n\n  // Assert loading state\n  expect(screen.getByText(/loading/i)).toBeInTheDocument()\n\n  // Wait for content to appear\n  await waitFor(() => {\n    expect(screen.queryByText(/loading/i)).not.toBeInTheDocument()\n  })\n\n  // Assert loaded content\n  expect(screen.getByText(/john doe/i)).toBeInTheDocument()\n  expect(screen.getByText(/john@example.com/i)).toBeInTheDocument()\n})\n\ntest('displays error when load fails', async () => {\n  // Mock API to return error\n  server.use(\n    rest.get('/api/users/:id', (req, res, ctx) => {\n      return res(ctx.status(404), ctx.json({ message: 'User not found' }))\n    })\n  )\n\n  render(<UserProfile userId='999' />)\n\n  // Wait for error message\n  await waitFor(() => {\n    expect(screen.getByText(/user not found/i)).toBeInTheDocument()\n  })\n})\n```\n\n## Testing Queries Priority\n\nUse queries in this order (from most to least preferred):\n\n1. **getByRole** - Best for accessibility\n   ```typescript\n   screen.getByRole('button', { name: /submit/i })\n   screen.getByRole('textbox', { name: /email/i })\n   ```\n\n2. **getByLabelText** - Good for form fields\n   ```typescript\n   screen.getByLabelText(/email address/i)\n   ```\n\n3. **getByPlaceholderText** - When label isn't available\n   ```typescript\n   screen.getByPlaceholderText(/enter your email/i)\n   ```\n\n4. **getByText** - For non-interactive elements\n   ```typescript\n   screen.getByText(/welcome back/i)\n   ```\n\n5. **getByTestId** - Last resort only\n   ```typescript\n   screen.getByTestId('custom-component')\n   ```\n\n## MSW Setup\n\nMock Service Worker for realistic API mocking:\n\n```typescript\n// src/test/mocks/server.ts\nimport { setupServer } from 'msw/node'\nimport { handlers } from './handlers'\n\nexport const server = setupServer(...handlers)\n\n// src/test/mocks/handlers.ts\nimport { rest } from 'msw'\n\nexport const handlers = [\n  rest.get('/api/users', (req, res, ctx) => {\n    return res(\n      ctx.status(200),\n      ctx.json([\n        { id: '1', name: 'User 1' },\n        { id: '2', name: 'User 2' }\n      ])\n    )\n  }),\n\n  rest.post('/api/login', (req, res, ctx) => {\n    const { email, password } = req.body as any\n\n    if (email === 'test@example.com' && password === 'password') {\n      return res(\n        ctx.status(200),\n        ctx.json({ token: 'fake-token', user: { id: '1', email } })\n      )\n    }\n\n    return res(\n      ctx.status(401),\n      ctx.json({ message: 'Invalid credentials' })\n    )\n  })\n]\n\n// src/test/setup.ts (in Jest config)\nimport { server } from './mocks/server'\n\nbeforeAll(() => server.listen())\nafterEach(() => server.resetHandlers())\nafterAll(() => server.close())\n```\n\n## Key Principles\n\nSee reference.md for detailed principles:\n- Test user behavior, not implementation\n- Use accessibility queries (getByRole)\n- Prefer real implementations over mocks\n- MSW for API mocking\n- waitFor for async, avoid arbitrary timeouts\n- 100% coverage for pure components/hooks\n- Integration tests for user flows\n\n## Coverage Strategy\n\n**Pure components (100% coverage)**:\n- All prop combinations\n- All user interactions\n- All conditional renders\n- Error states\n\n**Container components (integration tests)**:\n- Complete user flows\n- Error scenarios\n- Loading states\n- Success paths\n\n**Custom hooks (100% coverage)**:\n- All return values\n- All branches\n- Error handling\n- Edge cases\n\n## Common Testing Patterns\n\n### Testing Forms\n```typescript\n// Fill form fields\nawait user.type(screen.getByLabelText(/email/i), 'test@example.com')\n\n// Submit form\nawait user.click(screen.getByRole('button', { name: /submit/i }))\n\n// Assert success\nexpect(await screen.findByText(/success/i)).toBeInTheDocument()\n```\n\n### Testing Lists\n```typescript\n// Assert list items\nconst items = screen.getAllByRole('listitem')\nexpect(items).toHaveLength(3)\n\n// Assert specific item\nexpect(screen.getByText(/item 1/i)).toBeInTheDocument()\n```\n\n### Testing Modals\n```typescript\n// Open modal\nawait user.click(screen.getByRole('button', { name: /open modal/i }))\n\n// Assert modal visible\nexpect(screen.getByRole('dialog')).toBeInTheDocument()\n\n// Close modal\nawait user.click(screen.getByRole('button', { name: /close/i }))\n\n// Assert modal hidden\nexpect(screen.queryByRole('dialog')).not.toBeInTheDocument()\n```\n\n### Testing Navigation\n```typescript\nimport { MemoryRouter } from 'react-router-dom'\n\nfunction renderWithRouter(ui: React.ReactElement, { initialEntries = ['/'] } = {}) {\n  return render(\n    <MemoryRouter initialEntries={initialEntries}>\n      {ui}\n    </MemoryRouter>\n  )\n}\n\ntest('navigates to user profile on click', async () => {\n  const user = userEvent.setup()\n  renderWithRouter(<UserList />)\n\n  await user.click(screen.getByText(/john doe/i))\n\n  expect(screen.getByText(/user profile/i)).toBeInTheDocument()\n})\n```\n\nSee reference.md for complete testing patterns and examples."
              }
            ]
          }
        ]
      }
    }
  ]
}