{
  "owner": {
    "id": "chkim-su",
    "display_name": "Chanho KIM",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/193336612?v=4",
    "url": "https://github.com/chkim-su",
    "bio": null,
    "stats": {
      "total_repos": 3,
      "total_plugins": 3,
      "total_commands": 0,
      "total_skills": 5,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "chkim-su/serena-refactor-marketplace",
      "url": "https://github.com/chkim-su/serena-refactor-marketplace",
      "description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-12-28T05:30:41Z",
        "created_at": "2025-12-25T12:23:34Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 2082
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 145
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 2541
        },
        {
          "path": "agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/code-injector.md",
          "type": "blob",
          "size": 7590
        },
        {
          "path": "agents/duplicate-detector.md",
          "type": "blob",
          "size": 6277
        },
        {
          "path": "agents/feature-planner.md",
          "type": "blob",
          "size": 6428
        },
        {
          "path": "agents/knowledge-extractor.md",
          "type": "blob",
          "size": 6035
        },
        {
          "path": "agents/refactor-auditor.md",
          "type": "blob",
          "size": 5625
        },
        {
          "path": "agents/refactor-planner.md",
          "type": "blob",
          "size": 5294
        },
        {
          "path": "agents/serena-gateway.md",
          "type": "blob",
          "size": 5586
        },
        {
          "path": "agents/serena-refactor-executor.md",
          "type": "blob",
          "size": 8279
        },
        {
          "path": "agents/serena-solid-analyzer.md",
          "type": "blob",
          "size": 6779
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/analyze.md",
          "type": "blob",
          "size": 1866
        },
        {
          "path": "commands/audit.md",
          "type": "blob",
          "size": 1134
        },
        {
          "path": "commands/detect-duplicates.md",
          "type": "blob",
          "size": 2771
        },
        {
          "path": "commands/extract.md",
          "type": "blob",
          "size": 4107
        },
        {
          "path": "commands/inject.md",
          "type": "blob",
          "size": 12799
        },
        {
          "path": "commands/plan.md",
          "type": "blob",
          "size": 1382
        },
        {
          "path": "commands/refactor.md",
          "type": "blob",
          "size": 9511
        },
        {
          "path": "commands/rename.md",
          "type": "blob",
          "size": 2433
        },
        {
          "path": "config",
          "type": "tree",
          "size": null
        },
        {
          "path": "config/serena.mcp.json",
          "type": "blob",
          "size": 167
        },
        {
          "path": "docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/mcp-isolation-solution.md",
          "type": "blob",
          "size": 3494
        },
        {
          "path": "hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "hooks/hooks.json",
          "type": "blob",
          "size": 25530
        },
        {
          "path": "scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "scripts/serena_gateway.py",
          "type": "blob",
          "size": 3124
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/duplicate-detection-rules",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/duplicate-detection-rules/SKILL.md",
          "type": "blob",
          "size": 2566
        },
        {
          "path": "skills/duplicate-detection-rules/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/duplicate-detection-rules/references/clone-patterns.md",
          "type": "blob",
          "size": 1114
        },
        {
          "path": "skills/duplicate-detection-rules/references/fix-patterns.md",
          "type": "blob",
          "size": 1404
        },
        {
          "path": "skills/feature-injection-rules",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/feature-injection-rules/SKILL.md",
          "type": "blob",
          "size": 2402
        },
        {
          "path": "skills/feature-injection-rules/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/feature-injection-rules/references/code-templates.md",
          "type": "blob",
          "size": 2191
        },
        {
          "path": "skills/feature-injection-rules/references/injection-templates.md",
          "type": "blob",
          "size": 2070
        },
        {
          "path": "skills/project-knowledge-graph",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/project-knowledge-graph/SKILL.md",
          "type": "blob",
          "size": 5383
        },
        {
          "path": "skills/serena-refactoring-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/serena-refactoring-patterns/SKILL.md",
          "type": "blob",
          "size": 4561
        },
        {
          "path": "skills/solid-design-rules",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/solid-design-rules/SKILL.md",
          "type": "blob",
          "size": 9323
        }
      ],
      "marketplace": {
        "name": "serena-refactor-marketplace",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "chanhokim"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "serena-refactor",
            "description": "Serena MCP-based symbolic refactoring plugin. Supports SOLID analysis, duplicate detection, auto-fix, reference tracking, safe renaming, and intelligent feature injection with project knowledge graphs. Provides context isolation via Serena Gateway and hook-based quality gates.",
            "source": "./",
            "category": null,
            "version": "2.3.0",
            "author": {
              "name": "chanhokim"
            },
            "install_commands": [
              "/plugin marketplace add chkim-su/serena-refactor-marketplace",
              "/plugin install serena-refactor@serena-refactor-marketplace"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-28T05:30:41Z",
              "created_at": "2025-12-25T12:23:34Z",
              "license": null
            },
            "commands": [],
            "skills": [
              {
                "name": "duplicate-detection-rules",
                "description": "Code duplication detection rules. Patterns and thresholds for identifying clone code, role duplication, and variable duplication. Guide for removing duplicates through refactoring.",
                "path": "skills/duplicate-detection-rules/SKILL.md",
                "frontmatter": {
                  "description": "Code duplication detection rules. Patterns and thresholds for identifying clone code, role duplication, and variable duplication. Guide for removing duplicates through refactoring.",
                  "name": "duplicate-detection-rules",
                  "allowed-tools": [
                    "Read",
                    "Grep",
                    "Glob",
                    "Task"
                  ]
                },
                "content": "# Duplicate Detection Rules\n\n## Core Principle\n\n**Duplication is the enemy of change.**\nWhen you change one, you must change all copies. Miss one, and you have a bug.\n\n---\n\n## Detection Categories\n\n### 1. Clone Code\n\n| Type | Definition | Similarity | Severity |\n|------|------------|------------|----------|\n| Type-1 | Exact clone (whitespace ignored) | 100% | CRITICAL |\n| Type-2 | Same structure, different names/literals | >90% | HIGH |\n| Type-3 | Similar with some modifications | >70% | MEDIUM |\n\n> **Details**: `Read(\"references/clone-patterns.md\")`\n\n### 2. Role Duplication\n\n**Detection Signals:**\n\n| Signal | Description | Probability |\n|--------|-------------|-------------|\n| Similar names | `*Manager`, `*Handler`, `*Service` | High |\n| Same interface | Implements same interface | Very High |\n| Similar methods | 3+ same method names | High |\n\n**Synonym Groups to Watch:**\n- Retrieve: `get`, `fetch`, `retrieve`, `find`, `load`\n- Create: `create`, `make`, `build`, `generate`, `new`\n- Validate: `validate`, `check`, `verify`, `ensure`\n\n### 3. Variable/Constant Duplication\n\n| Type | Detection Criteria |\n|------|--------------------|\n| Magic numbers | Same value used 2+ times |\n| Duplicate strings | Same string (5+ chars) used 3+ times |\n| Config values | Same config in multiple places |\n\n---\n\n## Detection Thresholds\n\n| Type | Threshold | Report |\n|------|-----------|--------|\n| Type-1 Clone | 5 lines | Always |\n| Type-2 Clone | 90% similar | Always |\n| Type-3 Clone | 70% similar | 10+ lines |\n| Role duplication | 3 same methods | Always |\n| Magic numbers | 2+ usages | Always |\n\n---\n\n## Exceptions (Allowed Duplication)\n\n| Situation | Reason |\n|-----------|--------|\n| Test code | Maintain test independence |\n| Generated code | Auto-generation tool responsibility |\n| External interface | Contract compliance required |\n| Performance code | Intentional inlining |\n\n**Not Considered Duplication:**\n- Code 2 lines or less\n- Idiomatic patterns (e.g., `if (err) return;`)\n- Language boilerplate\n\n---\n\n## Fix Strategies\n\n> **Detailed patterns**: `Read(\"references/fix-patterns.md\")`\n\n| Duplication Type | Strategy |\n|------------------|----------|\n| Clone code | Extract common function |\n| Role duplication | Consolidate classes |\n| Constants | Centralize config |"
              },
              {
                "name": "feature-injection-rules",
                "description": "Rules and patterns for safely injecting new features into existing codebases. Ensures consistency with project conventions and SOLID principles.",
                "path": "skills/feature-injection-rules/SKILL.md",
                "frontmatter": {
                  "description": "Rules and patterns for safely injecting new features into existing codebases. Ensures consistency with project conventions and SOLID principles.",
                  "name": "feature-injection-rules",
                  "allowed-tools": [
                    "Read",
                    "Grep",
                    "Glob",
                    "Edit",
                    "Write",
                    "Task"
                  ]
                },
                "content": "# Feature Injection Rules\n\n## Core Principle\n\n**Inject features that blend seamlessly with existing code while maintaining architectural integrity.**\n\n---\n\n## Pre-Injection Checklist\n\n| Check | Serena Tool | Required |\n|-------|-------------|----------|\n| Project knowledge loaded | `read_memory` | Yes |\n| Target location identified | `find_symbol` | Yes |\n| Conventions extracted | Knowledge graph | Yes |\n| Impact scope analyzed | `find_referencing_symbols` | Yes |\n| SOLID compliance verified | SOLID rules | Yes |\n\n---\n\n## Injection Types Summary\n\n| Type | Use Case | Key Tool |\n|------|----------|----------|\n| New Symbol | Add new class/function | `insert_after_symbol` |\n| Extension | Add method to class | `insert_after_symbol` |\n| Implementation | New interface impl | `insert_before_symbol` |\n| Modification | Change existing | `replace_symbol_body` |\n\n> **Detailed templates**: `Read(\"references/injection-templates.md\")`\n\n---\n\n## Convention Matching Rules\n\n### Naming Conventions\n\n| Element | Common Patterns |\n|---------|-----------------|\n| Class | PascalCase, suffix (Service, Controller) |\n| Method | camelCase, verb prefix (get, set, is) |\n| Variable | camelCase or snake_case |\n| Constant | UPPER_SNAKE_CASE |\n| Interface | I-prefix or -able/-er suffix |\n\n### Structure Conventions\n\n1. **Import Ordering**: External → Internal → Local\n2. **Method Ordering**: Constructor → Public → Private → Static\n3. **File Organization**: Match existing patterns\n\n---\n\n## SOLID Compliance for Injection\n\n| Principle | Injection Rule |\n|-----------|----------------|\n| SRP | One clear purpose per symbol |\n| OCP | Prefer new implementations over modifications |\n| LSP | Honor interface contracts |\n| ISP | Don't bloat existing interfaces |\n| DIP | Inject dependencies, depend on abstractions |\n\n---\n\n## Post-Injection Verification\n\n1. **Syntax Check**: Run linter/type checker\n2. **Import Resolution**: Verify all imports valid\n3. **Reference Check**: No broken references\n4. **SOLID Check**: Validate against SOLID rules\n5. **Test Suggestion**: Propose test cases\n\n> **Code templates**: `Read(\"references/code-templates.md\")`"
              },
              {
                "name": "project-knowledge-graph",
                "description": "Project knowledge extraction and graph structure rules. Defines how to analyze, document, and maintain project architecture knowledge using Serena MCP.",
                "path": "skills/project-knowledge-graph/SKILL.md",
                "frontmatter": {
                  "description": "Project knowledge extraction and graph structure rules. Defines how to analyze, document, and maintain project architecture knowledge using Serena MCP.",
                  "name": "project-knowledge-graph",
                  "allowed-tools": [
                    "Read",
                    "Grep",
                    "Glob",
                    "Task"
                  ]
                },
                "content": "# Project Knowledge Graph\n\n## Purpose\n\nDefine rules and patterns for extracting, structuring, and maintaining comprehensive project knowledge using Serena MCP's symbol-level analysis capabilities.\n\n---\n\n## Knowledge Graph Structure\n\n### Core Entities\n\n| Entity Type | Description | Serena Tool |\n|-------------|-------------|-------------|\n| `Module` | File or directory that groups related code | `list_dir`, `get_symbols_overview` |\n| `Symbol` | Class, function, method, variable | `find_symbol` |\n| `Dependency` | Import or reference relationship | `find_referencing_symbols` |\n| `Pattern` | Repeated design pattern or convention | Pattern analysis |\n| `Convention` | Naming, structure, or style rules | Convention extraction |\n\n### Graph Schema\n\n```yaml\nKnowledgeGraph:\n  project:\n    name: string\n    root_path: string\n    language: string[]\n\n  modules:\n    - path: string\n      type: \"file\" | \"directory\"\n      symbols: Symbol[]\n      dependencies: Dependency[]\n\n  symbols:\n    - name: string\n      type: \"class\" | \"function\" | \"method\" | \"variable\" | \"interface\"\n      file: string\n      line: number\n      visibility: \"public\" | \"private\" | \"protected\"\n      dependencies: string[]\n      dependents: string[]\n\n  patterns:\n    - name: string\n      type: \"structural\" | \"behavioral\" | \"creational\"\n      instances: SymbolRef[]\n\n  conventions:\n    - category: \"naming\" | \"structure\" | \"import\" | \"export\"\n      rule: string\n      examples: string[]\n```\n\n---\n\n## Extraction Rules\n\n### Phase 1: Structure Discovery\n\n1. **Directory Scan**\n   ```\n   Serena: list_dir with recursive=true\n   Output: File tree with types\n   ```\n\n2. **Entry Points Identification**\n   - Look for: `main`, `index`, `app`, `__init__`\n   - Configuration files: `*.config.*`, `*.json`, `*.yaml`\n\n### Phase 2: Symbol Extraction\n\n1. **Per-File Symbol Overview**\n   ```\n   Serena: get_symbols_overview for each file\n   Extract: Classes, functions, methods, variables\n   ```\n\n2. **Symbol Details**\n   ```\n   Serena: find_symbol with include_body=true\n   Extract: Full definition, parameters, return types\n   ```\n\n### Phase 3: Dependency Mapping\n\n1. **Outgoing Dependencies**\n   - Import statements analysis\n   - Reference tracking within symbols\n\n2. **Incoming Dependencies (Dependents)**\n   ```\n   Serena: find_referencing_symbols for key symbols\n   Map: Which symbols depend on this one\n   ```\n\n### Phase 4: Pattern Recognition\n\n| Pattern | Detection Method |\n|---------|-----------------|\n| Factory | Classes ending with `Factory`, methods named `create*` |\n| Repository | Classes ending with `Repository`, implementing CRUD |\n| Service | Classes ending with `Service`, with business logic |\n| Controller | Classes ending with `Controller`, handling requests |\n| Strategy | Interface + multiple implementations |\n| Observer | `subscribe`, `notify`, `emit` patterns |\n\n### Phase 5: Convention Extraction\n\n1. **Naming Conventions**\n   - Class naming: PascalCase, camelCase\n   - Function naming: verb prefixes (get, set, is, has)\n   - File naming: kebab-case, snake_case\n\n2. **Structure Conventions**\n   - Directory organization patterns\n   - Import grouping rules\n   - Export patterns\n\n---\n\n## Memory Storage\n\n### Using Serena Memory for Persistence\n\nStore extracted knowledge in Serena memories for future sessions:\n\n```\nSerena: write_memory\nKey: \"project-knowledge-graph.md\"\nContent: Serialized knowledge graph\n```\n\n### Memory Structure\n\n```markdown\n# Project Knowledge Graph\nGenerated: [timestamp]\n\n## Project Overview\n- Name: [project_name]\n- Languages: [languages]\n- Entry Points: [entry_points]\n\n## Module Map\n[Hierarchical module structure]\n\n## Key Symbols\n[Top-level classes and functions with roles]\n\n## Dependency Graph\n[Mermaid diagram or text representation]\n\n## Detected Patterns\n[Pattern instances with locations]\n\n## Conventions\n[Extracted naming and structure rules]\n```\n\n---\n\n## Query Interface\n\n### Common Queries\n\n| Query | Implementation |\n|-------|---------------|\n| \"Find all services\" | `search_for_pattern: \"class.*Service\"` |\n| \"Show dependencies of X\" | `find_referencing_symbols + find_symbol` |\n| \"List all entry points\" | Search for main/index patterns |\n| \"Get module structure\" | `list_dir + get_symbols_overview` |\n\n### Query Response Format\n\n```yaml\nQueryResult:\n  query: string\n  matches:\n    - symbol: string\n      file: string\n      line: number\n      relevance: number\n      context: string\n```\n\n---\n\n## Update Strategy\n\n### Incremental Updates\n\nWhen files change, update only affected portions:\n\n1. Detect changed files (git diff or file watcher)\n2. Re-extract symbols for changed files\n3. Update dependency edges\n4. Revalidate patterns\n\n### Full Refresh Triggers\n\n- Major refactoring\n- New module addition\n- Framework upgrade\n- User request\n\n---\n\n## Integration with Feature Injection\n\nThe knowledge graph enables intelligent feature injection by providing:\n\n1. **Insertion Points**: Know where to add new code based on patterns\n2. **Style Matching**: Follow existing conventions automatically\n3. **Dependency Awareness**: Understand import requirements\n4. **Impact Analysis**: Predict what will be affected by changes"
              },
              {
                "name": "serena-refactoring-patterns",
                "description": "Symbolic refactoring patterns using Serena MCP tools. Core patterns for safe code modification, reference tracking, and automated refactoring workflows.",
                "path": "skills/serena-refactoring-patterns/SKILL.md",
                "frontmatter": {
                  "description": "Symbolic refactoring patterns using Serena MCP tools. Core patterns for safe code modification, reference tracking, and automated refactoring workflows.",
                  "name": "serena-refactoring-patterns",
                  "allowed-tools": [
                    "Read",
                    "Grep",
                    "Glob",
                    "Bash",
                    "Task"
                  ]
                },
                "content": "# Serena Symbolic Refactoring Patterns\n\n## Core Principle\n\n**Understand and modify code at the symbol level.**\nEnsure safety through AST-based editing, not text replacement.\n\n---\n\n## 1. Symbol Navigation Patterns\n\n### 1.1 Hierarchical Symbol Navigation\n\n```\n1. get_symbols_overview to understand file structure (depth=0)\n2. When class of interest found, use depth=1 to check method list\n3. When specific method body needed, use find_symbol + include_body=True\n```\n\n### 1.2 Name Pattern Search\n\n| Pattern | Meaning | Example |\n|---------|---------|---------|\n| `ClassName` | All classes with that name | `UserService` |\n| `ClassName/method` | Method of specific class | `UserService/create` |\n| `/ClassName/method` | Exact path matching | `/UserService/create` |\n| `get*` (substring_matching=True) | Prefix matching | `getValue`, `getData` |\n\n### 1.3 Reference Tracking\n\n```\nUsing find_referencing_symbols:\n- Assess refactoring impact scope\n- Build dependency graph\n- Detect circular references\n```\n\n---\n\n## 2. Safe Modification Patterns\n\n### 2.1 Replace Symbol Body\n\n**When to Use:**\n- Rewriting entire function/method\n- Changing class definition\n- Modification including signature\n\n**Cautions:**\n- body excludes docstring/comments\n- Must include signature\n- Indentation must be exact\n\n### 2.2 Replace Content\n\n**When to Use:**\n- Modifying only some lines within a symbol\n- Regex-based bulk replacement\n- Simultaneous modification of multiple locations\n\n**Pattern:**\n```\nmode: \"regex\"\nneedle: \"old_pattern.*?end_marker\"\nrepl: \"new_content\"\nallow_multiple_occurrences: True/False\n```\n\n### 2.3 Insertion Patterns\n\n| Tool | Use Case |\n|------|----------|\n| `insert_before_symbol` | Adding imports, adding decorators |\n| `insert_after_symbol` | Adding new methods/classes |\n\n---\n\n## 3. Refactoring Workflows\n\n### 3.1 Extract Method\n\n```\n1. Read target method body with find_symbol\n2. Identify code block to extract\n3. Design new method signature\n4. Add new method with insert_after_symbol\n5. Replace original with call using replace_content\n6. Verify impact with find_referencing_symbols\n```\n\n### 3.2 Rename Symbol\n\n```\n1. Identify all usages with find_referencing_symbols\n2. Rename across entire codebase with rename_symbol\n3. Verify results (all references updated automatically)\n```\n\n### 3.3 Extract Interface\n\n```\n1. Get class method list with find_symbol + depth=1\n2. Identify common methods\n3. Write new interface definition\n4. Add interface with insert_before_symbol\n5. Modify class to implement interface with replace_symbol_body\n```\n\n### 3.4 Move Method\n\n```\n1. Read original method with find_symbol (include_body=True)\n2. Add method to target class with insert_after_symbol\n3. Identify all call sites with find_referencing_symbols\n4. Update call sites with replace_content\n5. Delete original method (replace_symbol_body with empty or remove)\n```\n\n---\n\n## 4. SOLID Violation Auto-fix\n\n### 4.1 SRP Violation → Class Split\n\n```\nDetection: Class has more than 10 methods\nFix:\n1. Group methods with get_symbols_overview\n2. Create new classes by responsibility\n3. Apply move method pattern\n4. Delegate from original class to new classes\n```\n\n### 4.2 DIP Violation → Extract Interface\n\n```\nDetection: Business logic directly depends on infrastructure\nFix:\n1. Map dependencies with find_referencing_symbols\n2. Apply extract interface pattern\n3. Change to constructor injection\n```\n\n### 4.3 OCP Violation → Strategy Pattern\n\n```\nDetection: Type-based switch/if chains\nFix:\n1. Detect switch statements with search_for_pattern\n2. Extract each case to strategy class\n3. Apply factory/registry pattern\n```\n\n---\n\n## 5. Verification Patterns\n\n### 5.1 Pre-modification Checklist\n\n- [ ] Verify target symbol exists with find_symbol\n- [ ] Assess impact scope with find_referencing_symbols\n- [ ] Verify test file exists\n\n### 5.2 Post-modification Verification\n\n- [ ] Symbol tools are reliable if no errors\n- [ ] Verify reference integrity with find_referencing_symbols\n- [ ] Run tests with execute_shell_command\n\n---\n\n## 6. Memory Utilization\n\n### Saving Project Context\n\n```\nwrite_memory:\n- Architecture decision records\n- Refactoring history\n- Coding conventions\n```\n\n### Cross-session Continuity\n\n```\nread_memory:\n- Previous refactoring progress\n- Known technical debt\n- High-priority fix targets\n```"
              },
              {
                "name": "solid-design-rules",
                "description": "SOLID principles and TDD enforcement rules. Reference for maintainable software design. Used for code quality analysis, refactoring planning, and architecture verification.",
                "path": "skills/solid-design-rules/SKILL.md",
                "frontmatter": {
                  "description": "SOLID principles and TDD enforcement rules. Reference for maintainable software design. Used for code quality analysis, refactoring planning, and architecture verification.",
                  "name": "solid-design-rules",
                  "allowed-tools": [
                    "Read",
                    "Grep",
                    "Glob"
                  ]
                },
                "content": "# SOLID Design Rules\n\n## Core Principle\n\n**Design for change isolation.**\nPredict what will change and strictly limit the propagation scope of those changes.\n\n---\n\n## 1. Single Responsibility Principle (SRP)\n\nEvery class, module, and function must have **exactly one reason to change**.\n\n**Prohibited:**\n- Mixing business rules, data persistence, and formatting in one class\n- \"God\" services that coordinate unrelated concerns\n- Methods exceeding 20 lines\n- Classes with more than 5 dependencies\n\n**Required:**\n- Explicit separation of policy, orchestration, and execution\n- Small, intent-revealing components\n\n**Example - Violation:**\n```typescript\n// ❌ SRP Violation: Handles business logic, DB, and email\nclass UserService {\n  async createUser(data: UserData) {\n    // Validation logic\n    if (!data.email.includes('@')) throw new Error('Invalid email');\n\n    // DB save\n    await db.query('INSERT INTO users...');\n\n    // Email sending\n    await smtp.send({ to: data.email, subject: 'Welcome!' });\n\n    // Logging\n    console.log('User created:', data.email);\n  }\n}\n```\n\n**Example - Fixed:**\n```typescript\n// ✓ SRP Compliant: Each responsibility separated\nclass UserValidator {\n  validate(data: UserData): ValidationResult { ... }\n}\n\nclass UserRepository {\n  async save(user: User): Promise<void> { ... }\n}\n\nclass WelcomeEmailSender {\n  async send(user: User): Promise<void> { ... }\n}\n\nclass UserCreationUseCase {\n  constructor(\n    private validator: UserValidator,\n    private repo: UserRepository,\n    private emailer: WelcomeEmailSender\n  ) {}\n\n  async execute(data: UserData): Promise<User> {\n    this.validator.validate(data);\n    const user = await this.repo.save(new User(data));\n    await this.emailer.send(user);\n    return user;\n  }\n}\n```\n\n---\n\n## 2. Open-Closed Principle (OCP)\n\nSystems must be **open for extension, closed for modification**.\n\n**Prohibited:**\n- `if/switch` chains that grow with types or enums\n- Feature flags embedded in core logic\n- Boolean parameters that branch behavior\n\n**Required:**\n- Interface-based extensibility\n- Strategy pattern and polymorphic dispatch\n\n**Example - Violation:**\n```typescript\n// ❌ OCP Violation: Adding new payment requires modifying switch\nfunction processPayment(type: string, amount: number) {\n  switch (type) {\n    case 'credit': return processCreditCard(amount);\n    case 'paypal': return processPaypal(amount);\n    case 'crypto': return processCrypto(amount);\n    // Adding new type requires case here...\n  }\n}\n```\n\n**Example - Fixed:**\n```typescript\n// ✓ OCP Compliant: New payment just implements interface\ninterface PaymentProcessor {\n  process(amount: number): Promise<PaymentResult>;\n}\n\nclass CreditCardProcessor implements PaymentProcessor { ... }\nclass PaypalProcessor implements PaymentProcessor { ... }\nclass CryptoProcessor implements PaymentProcessor { ... }\n\n// New method: Just add implementation without modifying existing code\nclass ApplePayProcessor implements PaymentProcessor { ... }\n\nclass PaymentService {\n  constructor(private processors: Map<string, PaymentProcessor>) {}\n\n  async process(type: string, amount: number) {\n    return this.processors.get(type)?.process(amount);\n  }\n}\n```\n\n---\n\n## 3. Liskov Substitution Principle (LSP)\n\nSubtypes must be **completely substitutable** for their base types.\n\n**Prohibited:**\n- Empty method implementations in subclasses\n- `instanceof` checks in calling code\n- Strengthening preconditions in subclasses\n- Throwing unexpected exceptions\n\n**Required:**\n- Behavioral contracts maintained across all implementations\n\n**Example - Violation:**\n```typescript\n// ❌ LSP Violation: Square breaks Rectangle contract\nclass Rectangle {\n  constructor(public width: number, public height: number) {}\n  setWidth(w: number) { this.width = w; }\n  setHeight(h: number) { this.height = h; }\n  area() { return this.width * this.height; }\n}\n\nclass Square extends Rectangle {\n  setWidth(w: number) { this.width = this.height = w; }  // Contract violation!\n  setHeight(h: number) { this.width = this.height = h; } // Contract violation!\n}\n\n// Client code doesn't work as expected\nfunction resize(rect: Rectangle) {\n  rect.setWidth(5);\n  rect.setHeight(10);\n  console.log(rect.area()); // Rectangle: 50, Square: 100 (!)\n}\n```\n\n**Example - Fixed:**\n```typescript\n// ✓ LSP Compliant: Separated with common interface\ninterface Shape {\n  area(): number;\n}\n\nclass Rectangle implements Shape {\n  constructor(public width: number, public height: number) {}\n  area() { return this.width * this.height; }\n}\n\nclass Square implements Shape {\n  constructor(public side: number) {}\n  area() { return this.side * this.side; }\n}\n```\n\n---\n\n## 4. Interface Segregation Principle (ISP)\n\nInterfaces must be designed from the **client's perspective**.\n\n**Prohibited:**\n- Interfaces with more than 5 methods\n- Forcing implementations to depend on methods they don't use\n\n**Required:**\n- Minimal interfaces per role\n- Separation of commands and queries\n\n**Example - Violation:**\n```typescript\n// ❌ ISP Violation: Fat interface\ninterface Worker {\n  work(): void;\n  eat(): void;\n  sleep(): void;\n  attendMeeting(): void;\n  writeReport(): void;\n}\n\n// Robot doesn't need eat, sleep but forced to implement\nclass Robot implements Worker {\n  work() { ... }\n  eat() { throw new Error('Not applicable'); }  // Meaningless implementation\n  sleep() { throw new Error('Not applicable'); }\n  ...\n}\n```\n\n**Example - Fixed:**\n```typescript\n// ✓ ISP Compliant: Separated by role\ninterface Workable {\n  work(): void;\n}\n\ninterface Feedable {\n  eat(): void;\n}\n\ninterface Sleepable {\n  sleep(): void;\n}\n\nclass Human implements Workable, Feedable, Sleepable { ... }\nclass Robot implements Workable { ... }  // Only implements what's needed\n```\n\n---\n\n## 5. Dependency Inversion Principle (DIP)\n\nHigh-level business logic must **not depend on low-level details**.\n\n**Prohibited:**\n- `new` keyword for infrastructure classes in business logic\n- Direct DB/HTTP client usage in domain services\n- Framework annotations on domain entities\n\n**Required:**\n- Constructor-based dependency injection\n- Interfaces owned by business layer\n\n**Example - Violation:**\n```typescript\n// ❌ DIP Violation: Business logic directly depends on concrete classes\nclass OrderService {\n  private db = new MySQLConnection();  // Direct creation!\n  private mailer = new SendGridClient(); // Direct creation!\n\n  async createOrder(data: OrderData) {\n    await this.db.query('INSERT INTO orders...');\n    await this.mailer.send(data.customerEmail, 'Order confirmed');\n  }\n}\n```\n\n**Example - Fixed:**\n```typescript\n// ✓ DIP Compliant: Depends on abstractions, injected\ninterface OrderRepository {\n  save(order: Order): Promise<void>;\n}\n\ninterface NotificationService {\n  notify(recipient: string, message: string): Promise<void>;\n}\n\nclass OrderService {\n  constructor(\n    private repo: OrderRepository,       // Interface injected\n    private notifier: NotificationService // Interface injected\n  ) {}\n\n  async createOrder(data: OrderData) {\n    const order = new Order(data);\n    await this.repo.save(order);\n    await this.notifier.notify(data.customerEmail, 'Order confirmed');\n  }\n}\n\n// Implementations injected from outside\nconst service = new OrderService(\n  new MySQLOrderRepository(),\n  new SendGridNotifier()\n);\n```\n\n---\n\n## 6. TDD Rules\n\n### Test Before Implementation\n\n1. Define failing test scenarios first\n2. Write only enough implementation to satisfy tests\n3. Refactor only after tests pass\n\n### Design Violation Signals\n\n| Signal | Violation |\n|--------|-----------|\n| Excessive mocking | SRP violation |\n| Need to test private methods | Wrong boundaries |\n| DB/Network needed for unit tests | DIP violation |\n\n**Example - Testable Design:**\n```typescript\n// ✓ Testable: Dependencies can be mocked via injection\ndescribe('OrderService', () => {\n  it('should save order and notify customer', async () => {\n    const mockRepo = { save: jest.fn() };\n    const mockNotifier = { notify: jest.fn() };\n    const service = new OrderService(mockRepo, mockNotifier);\n\n    await service.createOrder({ customerEmail: 'test@test.com' });\n\n    expect(mockRepo.save).toHaveBeenCalled();\n    expect(mockNotifier.notify).toHaveBeenCalledWith('test@test.com', expect.any(String));\n  });\n});\n```\n\n---\n\n## 7. Repository Pattern\n\n**Repository = Collection abstraction, not persistence mechanism**\n\n**Prohibited:**\n- SQL/query language in interfaces\n- Infrastructure terms in method names\n\n**Required:**\n- Domain-centric operations (`find`, `save`, `exists`)\n- Swappable with in-memory implementation for tests\n\n**Example:**\n```typescript\n// ✓ Domain-centric interface\ninterface UserRepository {\n  findById(id: UserId): Promise<User | null>;\n  findByEmail(email: Email): Promise<User | null>;\n  save(user: User): Promise<void>;\n  exists(id: UserId): Promise<boolean>;\n}\n\n// In-memory implementation for tests\nclass InMemoryUserRepository implements UserRepository {\n  private users: Map<string, User> = new Map();\n\n  async findById(id: UserId) {\n    return this.users.get(id.value) ?? null;\n  }\n  // ...\n}\n```"
              }
            ]
          }
        ]
      }
    },
    {
      "full_name": "chkim-su/obsidian-writer",
      "url": "https://github.com/chkim-su/obsidian-writer",
      "description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-02T05:41:58Z",
        "created_at": "2026-01-02T00:32:03Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 782
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 297
        },
        {
          "path": ".claude",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/hooks/paper-review-trigger.py",
          "type": "blob",
          "size": 1047
        },
        {
          "path": ".claude/hooks/workflow-enforcer.py",
          "type": "blob",
          "size": 6321
        },
        {
          "path": ".claude/hooks/workflow-state.json",
          "type": "blob",
          "size": 840
        },
        {
          "path": ".claude/plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/plugins/obsidian-writer",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/plugins/obsidian-writer/README.md",
          "type": "blob",
          "size": 7605
        },
        {
          "path": ".claude/plugins/obsidian-writer/manifest.json",
          "type": "blob",
          "size": 3697
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/background-document",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/background-document/SKILL.md",
          "type": "blob",
          "size": 1712
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/background-document/references",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/background-document/references/math-template.md",
          "type": "blob",
          "size": 1589
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/background-document/references/prerequisite-template.md",
          "type": "blob",
          "size": 1155
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/background-document/references/topic-template.md",
          "type": "blob",
          "size": 1125
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/obsidian-research.md",
          "type": "blob",
          "size": 1137
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/paper-analyze",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/paper-analyze/SKILL.md",
          "type": "blob",
          "size": 1900
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/paper-analyze/references",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/paper-analyze/references/artifact-types.md",
          "type": "blob",
          "size": 1297
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/paper-analyze/references/complete-block.md",
          "type": "blob",
          "size": 1071
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/paper-analyze/references/explanation-template.md",
          "type": "blob",
          "size": 2189
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/paper-review.md",
          "type": "blob",
          "size": 5301
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/paper-workflow",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/paper-workflow/SKILL.md",
          "type": "blob",
          "size": 1823
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/paper-workflow/references",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/paper-workflow/references/step1-analyze.md",
          "type": "blob",
          "size": 717
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/paper-workflow/references/step2-annotate.md",
          "type": "blob",
          "size": 1280
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/paper-workflow/references/step3-cite.md",
          "type": "blob",
          "size": 1089
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/paper-workflow/references/step4-expand.md",
          "type": "blob",
          "size": 1587
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/paper-workflow/references/step5-review.md",
          "type": "blob",
          "size": 1292
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/pdf-annotation-guide.md",
          "type": "blob",
          "size": 5860
        },
        {
          "path": ".claude/plugins/obsidian-writer/skills/pdf-figure-extract.md",
          "type": "blob",
          "size": 4599
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 213
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 1802
        }
      ],
      "marketplace": {
        "name": "obsidian-writer-marketplace",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "chkim-su"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "obsidian-writer",
            "description": null,
            "source": {
              "source": "github",
              "repo": "chkim-su/obsidian-writer"
            },
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add chkim-su/obsidian-writer",
              "/plugin install obsidian-writer@obsidian-writer-marketplace"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-02T05:41:58Z",
              "created_at": "2026-01-02T00:32:03Z",
              "license": null
            },
            "commands": [],
            "skills": []
          }
        ]
      }
    },
    {
      "full_name": "chkim-su/orchestrator",
      "url": "https://github.com/chkim-su/orchestrator",
      "description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-12-10T05:41:00Z",
        "created_at": "2025-12-10T05:31:10Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 379
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 393
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 111
        },
        {
          "path": "LICENSE",
          "type": "blob",
          "size": 1067
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 5480
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/fullauto",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/fullauto/auto.md",
          "type": "blob",
          "size": 13554
        },
        {
          "path": "commands/fullauto/edit.md",
          "type": "blob",
          "size": 17942
        },
        {
          "path": "commands/fullauto/explore.md",
          "type": "blob",
          "size": 8579
        },
        {
          "path": "commands/fullauto/plan.md",
          "type": "blob",
          "size": 15928
        },
        {
          "path": "commands/fullauto/research.md",
          "type": "blob",
          "size": 10867
        },
        {
          "path": "commands/fullauto/review.md",
          "type": "blob",
          "size": 10396
        },
        {
          "path": "scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "scripts/setup-oracle.sh",
          "type": "blob",
          "size": 2694
        }
      ],
      "marketplace": {
        "name": "orchestrator",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "Chanho Kim",
          "url": "https://github.com/chkim-su"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "fullauto",
            "description": "Oracle-powered autonomous development pipelines with Gemini-Claude orchestration",
            "source": ".",
            "category": null,
            "version": "1.0.0",
            "author": {
              "name": "Chanho Kim"
            },
            "install_commands": [
              "/plugin marketplace add chkim-su/orchestrator",
              "/plugin install fullauto@orchestrator"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-10T05:41:00Z",
              "created_at": "2025-12-10T05:31:10Z",
              "license": "MIT"
            },
            "commands": [],
            "skills": []
          }
        ]
      }
    }
  ]
}