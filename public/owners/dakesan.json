{
  "owner": {
    "id": "dakesan",
    "display_name": "Hiroyuki Odake",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/26640737?u=60f9c35a17c37043cf723e4f1736873ab86200c9&v=4",
    "url": "https://github.com/dakesan",
    "bio": "Biology, Bioinformatics, AI Biology.",
    "stats": {
      "total_repos": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 3,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "dakesan/marimo-cc",
      "url": "https://github.com/dakesan/marimo-cc",
      "description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-06T07:59:04Z",
        "created_at": "2026-01-06T02:19:52Z",
        "license": "Apache-2.0"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 623
        },
        {
          "path": "LICENSE",
          "type": "blob",
          "size": 11502
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 4255
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/edit.md",
          "type": "blob",
          "size": 135
        },
        {
          "path": "commands/init.md",
          "type": "blob",
          "size": 529
        },
        {
          "path": "commands/inspect.md",
          "type": "blob",
          "size": 136
        },
        {
          "path": "commands/serve.md",
          "type": "blob",
          "size": 180
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/marimo-editor",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/marimo-editor/SKILL.md",
          "type": "blob",
          "size": 8773
        },
        {
          "path": "skills/marimo-inspect",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/marimo-inspect/SKILL.md",
          "type": "blob",
          "size": 1468
        },
        {
          "path": "skills/marimo-serve",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/marimo-serve/SKILL.md",
          "type": "blob",
          "size": 1188
        }
      ],
      "marketplace": {
        "name": "cc-marimo",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "Hiroyuki Odake",
          "email": "odake@example.com"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "marimo-skills",
            "description": "Marimo reactive notebook skills for data science workflows",
            "source": "./",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add dakesan/marimo-cc",
              "/plugin install marimo-skills@cc-marimo"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-06T07:59:04Z",
              "created_at": "2026-01-06T02:19:52Z",
              "license": "Apache-2.0"
            },
            "commands": [],
            "skills": [
              {
                "name": "marimo-editor",
                "description": "This skill should be used when working with marimo reactive notebooks for data science and analytics.\n\nTriggers include:\n- Creating new marimo notebooks\n- Converting Jupyter notebooks to marimo\n- Editing existing marimo notebooks\n- Implementing reactive patterns and UI components\n- Building interactive data visualizations with marimo\n",
                "path": "skills/marimo-editor/SKILL.md",
                "frontmatter": {
                  "name": "marimo-editor",
                  "description": "This skill should be used when working with marimo reactive notebooks for data science and analytics.\n\nTriggers include:\n- Creating new marimo notebooks\n- Converting Jupyter notebooks to marimo\n- Editing existing marimo notebooks\n- Implementing reactive patterns and UI components\n- Building interactive data visualizations with marimo\n"
                },
                "content": "# Marimo Notebook Assistant\n\nThis skill provides specialized guidance for creating data science notebooks using marimo's reactive programming model. Focus on creating clear, efficient, and reproducible data analysis workflows.\n\n## Core Capabilities\n\n- Data science and analytics using marimo notebooks\n- Complete, runnable code that follows best practices\n- Reproducibility and clear documentation\n- Interactive data visualizations and analysis\n- Understanding of marimo's reactive programming model\n\n## Marimo Fundamentals\n\nMarimo is a reactive notebook that differs from traditional notebooks in key ways:\n- Cells execute automatically when their dependencies change\n- Variables cannot be redeclared across cells\n- The notebook forms a directed acyclic graph (DAG)\n- The last expression in a cell is automatically displayed\n- UI elements are reactive and update the notebook automatically\n\n## Code Requirements\n\n1. All code must be complete and runnable\n2. Follow consistent coding style throughout\n3. Include descriptive variable names and helpful comments\n4. Import all modules in the first cell, always including `import marimo as mo`\n5. Never redeclare variables across cells\n6. Ensure no cycles in notebook dependency graph\n7. The last expression in a cell is automatically displayed, just like in Jupyter notebooks\n8. Don't include comments in markdown cells\n9. Don't include comments in SQL cells\n\n## Reactivity\n\nMarimo's reactivity means:\n- When a variable changes, all cells that use that variable automatically re-execute\n- UI elements trigger updates when their values change without explicit callbacks\n- UI element values are accessed through `.value` attribute\n- Cannot access a UI element's value in the same cell where it's defined\n\n## Best Practices\n\n### Data Handling\n\n- Use pandas for data manipulation\n- Implement proper data validation\n- Handle missing values appropriately\n- Use efficient data structures\n- A variable in the last expression of a cell is automatically displayed as a table\n\n### Visualization\n\n- For matplotlib: use `plt.gca()` as the last expression instead of `plt.show()`\n- For plotly: return the figure object directly\n- For altair: return the chart object directly\n- Include proper labels, titles, and color schemes\n- Make visualizations interactive where appropriate\n\n### UI Elements\n\n- Access UI element values with `.value` attribute (e.g., `slider.value`)\n- Create UI elements in one cell and reference them in later cells\n- Create intuitive layouts with `mo.hstack()`, `mo.vstack()`, and `mo.tabs()`\n- Prefer reactive updates over callbacks (marimo handles reactivity automatically)\n- Group related UI elements for better organization\n\n### Data Sources\n\n- Prefer GitHub-hosted datasets (e.g., raw.githubusercontent.com)\n- Use CORS proxy for external URLs: https://corsproxy.marimo.app/<url>\n- Implement proper error handling for data loading\n- Consider using `vega_datasets` for common example datasets\n\n### SQL\n\n- When writing duckdb, prefer using marimo's SQL cells, which start with `_df = mo.sql(query)`\n- See the SQL with duckdb example for an example on how to do this\n- Don't add comments in cells that use `mo.sql()`\n- Consider using `vega_datasets` for common example datasets\n\n## Troubleshooting\n\nCommon issues and solutions:\n- Circular dependencies: Reorganize code to remove cycles in the dependency graph\n- UI element value access: Move access to a separate cell from definition\n- Visualization not showing: Ensure the visualization object is the last expression\n\n## Available UI Elements\n\n* `mo.ui.altair_chart(altair_chart)`\n* `mo.ui.button(value=None, kind='primary')`\n* `mo.ui.run_button(label=None, tooltip=None, kind='primary')`\n* `mo.ui.checkbox(label='', value=False)`\n* `mo.ui.date(value=None, label=None, full_width=False)`\n* `mo.ui.dropdown(options, value=None, label=None, full_width=False)`\n* `mo.ui.file(label='', multiple=False, full_width=False)`\n* `mo.ui.number(value=None, label=None, full_width=False)`\n* `mo.ui.radio(options, value=None, label=None, full_width=False)`\n* `mo.ui.refresh(options: List[str], default_interval: str)`\n* `mo.ui.slider(start, stop, value=None, label=None, full_width=False, step=None)`\n* `mo.ui.range_slider(start, stop, value=None, label=None, full_width=False, step=None)`\n* `mo.ui.table(data, columns=None, on_select=None, sortable=True, filterable=True)`\n* `mo.ui.text(value='', label=None, full_width=False)`\n* `mo.ui.text_area(value='', label=None, full_width=False)`\n* `mo.ui.data_explorer(df)`\n* `mo.ui.dataframe(df)`\n* `mo.ui.plotly(plotly_figure)`\n* `mo.ui.tabs(elements: dict[str, mo.ui.Element])`\n* `mo.ui.array(elements: list[mo.ui.Element])`\n* `mo.ui.form(element: mo.ui.Element, label='', bordered=True)`\n\n## Layout and Utility Functions\n\n* `mo.md(text)` - display markdown\n* `mo.stop(predicate, output=None)` - stop execution conditionally\n* `mo.Html(html)` - display HTML\n* `mo.image(image)` - display an image\n* `mo.hstack(elements)` - stack elements horizontally\n* `mo.vstack(elements)` - stack elements vertically\n* `mo.tabs(elements)` - create a tabbed interface\n\n## Examples\n\n### Basic UI with Reactivity\n\n```python\n# Cell 1\nimport marimo as mo\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Cell 2\n# Create a slider and display it\nn_points = mo.ui.slider(10, 100, value=50, label=\"Number of points\")\nn_points  # Display the slider\n\n# Cell 3\n# Generate random data based on slider value\n# This cell automatically re-executes when n_points.value changes\nx = np.random.rand(n_points.value)\ny = np.random.rand(n_points.value)\n\nplt.figure(figsize=(8, 6))\nplt.scatter(x, y, alpha=0.7)\nplt.title(f\"Scatter plot with {n_points.value} points\")\nplt.xlabel(\"X axis\")\nplt.ylabel(\"Y axis\")\nplt.gca()  # Return the current axes to display the plot\n```\n\n### Data Explorer\n\n```python\n# Cell 1\nimport marimo as mo\nimport pandas as pd\nfrom vega_datasets import data\n\n# Cell 2\n# Load and display dataset with interactive explorer\ncars_df = data.cars()\nmo.ui.data_explorer(cars_df)\n```\n\n### Multiple UI Elements\n\n```python\n# Cell 1\nimport marimo as mo\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Cell 2\n# Load dataset\niris = sns.load_dataset('iris')\n\n# Cell 3\n# Create UI elements\nspecies_selector = mo.ui.dropdown(\n    options=[\"All\"] + iris[\"species\"].unique().tolist(),\n    value=\"All\",\n    label=\"Species\"\n)\nx_feature = mo.ui.dropdown(\n    options=iris.select_dtypes('number').columns.tolist(),\n    value=\"sepal_length\",\n    label=\"X Feature\"\n)\ny_feature = mo.ui.dropdown(\n    options=iris.select_dtypes('number').columns.tolist(),\n    value=\"sepal_width\",\n    label=\"Y Feature\"\n)\n\n# Display UI elements in a horizontal stack\nmo.hstack([species_selector, x_feature, y_feature])\n\n# Cell 4\n# Filter data based on selection\nfiltered_data = iris if species_selector.value == \"All\" else iris[iris[\"species\"] == species_selector.value]\n\n# Create visualization based on UI selections\nplt.figure(figsize=(10, 6))\nsns.scatterplot(\n    data=filtered_data,\n    x=x_feature.value,\n    y=y_feature.value,\n    hue=\"species\"\n)\nplt.title(f\"{y_feature.value} vs {x_feature.value}\")\nplt.gca()\n```\n\n### Interactive Chart with Altair\n\n```python\n# Cell 1\nimport marimo as mo\nimport altair as alt\nimport pandas as pd\n\n# Cell 2\n# Load dataset\ncars_df = pd.read_csv('https://raw.githubusercontent.com/vega/vega-datasets/master/data/cars.json')\n_chart = alt.Chart(cars_df).mark_point().encode(\n    x='Horsepower',\n    y='Miles_per_Gallon',\n    color='Origin',\n)\n\nchart = mo.ui.altair_chart(_chart)\nchart\n\n# Cell 3\n# Display the selection\nchart.value\n```\n\n### Run Button Example\n\n```python\n# Cell 1\nimport marimo as mo\n\n# Cell 2\nfirst_button = mo.ui.run_button(label=\"Option 1\")\nsecond_button = mo.ui.run_button(label=\"Option 2\")\n[first_button, second_button]\n\n# Cell 3\nif first_button.value:\n    print(\"You chose option 1!\")\nelif second_button.value:\n    print(\"You chose option 2!\")\nelse:\n    print(\"Click a button!\")\n```\n\n### SQL with DuckDB\n\n```python\n# Cell 1\nimport marimo as mo\n\n# Cell 2\n# Load dataset\ncars_df = pd.read_csv('https://raw.githubusercontent.com/vega/vega-datasets/master/data/cars.json')\n\n# Cell 3\n_df = mo.sql(\"SELECT * from cars_df WHERE Miles_per_Gallon > 20\")\n```\n\n### Writing LaTeX in Markdown\n\n```python\n# Cell 1\nimport marimo as mo\n\n# Cell 2\nmo.md(r\"\"\"\n\nThe quadratic function $f$ is defined as\n\n$$f(x) = x^2.$$\n\"\"\")\n```"
              },
              {
                "name": "marimo-inspect",
                "description": "This skill should be used when inspecting marimo notebook execution results.\n\nTriggers include:\n- Checking notebook output\n- Viewing execution results\n- Reading __marimo__ HTML snapshots\n- Debugging notebook errors\n- Verifying cell outputs\n",
                "path": "skills/marimo-inspect/SKILL.md",
                "frontmatter": {
                  "name": "marimo-inspect",
                  "description": "This skill should be used when inspecting marimo notebook execution results.\n\nTriggers include:\n- Checking notebook output\n- Viewing execution results\n- Reading __marimo__ HTML snapshots\n- Debugging notebook errors\n- Verifying cell outputs\n"
                },
                "content": "# Marimo Notebook Inspector\n\nInspect marimo notebook execution results by reading HTML snapshots stored in the `__marimo__` directory.\n\n## Purpose\n\nMarimo automatically saves HTML snapshots during editing sessions. This skill reads those snapshots to verify:\n\n- Cell execution outputs\n- Error messages and tracebacks\n- Visualization renders\n- UI element states\n\n## Snapshot Location\n\nHTML snapshots are stored in:\n\n- `__marimo__/` directory (relative to notebook)\n- `.marimo/` directory (alternative location)\n\n## Workflow\n\n1. Locate the `__marimo__` or `.marimo/` directory using Glob\n2. List available HTML snapshots\n3. Read the HTML file with the Read tool\n4. Parse and analyze:\n   - Cell outputs (text, tables, plots)\n   - Error states and messages\n   - Console output\n5. Report findings to user\n\n## Usage Pattern\n\n```\n# Find snapshots\nGlob: **/__marimo__/*.html\n\n# Read snapshot\nRead: __marimo__/notebook_name.html\n```\n\n## Analysis Focus\n\nWhen inspecting HTML snapshots:\n\n- Look for `<div class=\"output\">` sections for cell outputs\n- Check for error indicators and stack traces\n- Identify visualization elements (plots, charts)\n- Note any warning or info messages"
              },
              {
                "name": "marimo-serve",
                "description": "This skill should be used when starting a marimo development server with hot reload.\n\nTriggers include:\n- Starting marimo server\n- Running marimo notebooks locally\n- Launching marimo development environment\n- Setting up hot reload for notebooks\n",
                "path": "skills/marimo-serve/SKILL.md",
                "frontmatter": {
                  "name": "marimo-serve",
                  "description": "This skill should be used when starting a marimo development server with hot reload.\n\nTriggers include:\n- Starting marimo server\n- Running marimo notebooks locally\n- Launching marimo development environment\n- Setting up hot reload for notebooks\n"
                },
                "content": "# Marimo Development Server\n\nStart a marimo development server with hot reload for interactive notebook development.\n\n## Server Command\n\nTo start the server in background:\n\n```bash\nuv run marimo run --watch {filename} --port 2818\n```\n\nUse the Bash tool with `run_in_background: true` parameter to keep the server running.\n\n## Configuration\n\n- Default port: 2818\n- Access URL: `http://localhost:2818`\n- Hot reload: Enabled with `--watch` flag\n\n## Verification\n\nAfter starting the server:\n\n1. Check running tasks with `/tasks` command\n2. Verify server is accessible via WebFetch to `http://localhost:2818`\n3. Use `lsof -i :2818` to confirm port is in use\n\n## Workflow\n\n1. Ensure the target notebook file exists\n2. Start server with `run_in_background: true`\n3. Edit notebook files with the Edit tool\n4. Server automatically reloads on file changes\n5. Fetch results via WebFetch when needed"
              }
            ]
          }
        ]
      }
    }
  ]
}