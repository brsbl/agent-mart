{
  "owner": {
    "id": "anexpn",
    "display_name": "Jun",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/23271612?u=cf9c1dc4198afa7fa5424e54f61caba33fa5d072&v=4",
    "url": "https://github.com/anexpn",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 5,
      "total_stars": 1,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "anexpn/claude-plugins",
      "url": "https://github.com/anexpn/claude-plugins",
      "description": "Jun's development workflow commands and skills for Claude Code",
      "homepage": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2025-12-01T10:17:48Z",
        "created_at": "2025-10-24T19:55:41Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 463
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 230
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 68
        },
        {
          "path": "CLAUDE.md",
          "type": "blob",
          "size": 3276
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 1025
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/explore.md",
          "type": "blob",
          "size": 1153
        },
        {
          "path": "commands/refresh.md",
          "type": "blob",
          "size": 1193
        },
        {
          "path": "commands/tour.md",
          "type": "blob",
          "size": 8018
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/dev-auto",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/dev-auto/SKILL.md",
          "type": "blob",
          "size": 8057
        },
        {
          "path": "skills/dev-auto/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/dev-auto/references/phase-impl.md",
          "type": "blob",
          "size": 6023
        },
        {
          "path": "skills/dev-auto/references/phase-plan.md",
          "type": "blob",
          "size": 6871
        },
        {
          "path": "skills/dev-auto/references/phase-review.md",
          "type": "blob",
          "size": 7734
        },
        {
          "path": "skills/dev-auto/references/phase-spec.md",
          "type": "blob",
          "size": 4035
        },
        {
          "path": "skills/dev-auto/references/phase-tasks.md",
          "type": "blob",
          "size": 4818
        },
        {
          "path": "skills/dev-auto/references/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/dev-auto/references/templates/subagent-impl.md",
          "type": "blob",
          "size": 1315
        },
        {
          "path": "skills/dev-auto/references/templates/subagent-plan.md",
          "type": "blob",
          "size": 1186
        },
        {
          "path": "skills/dev-auto/references/templates/subagent-tasks.md",
          "type": "blob",
          "size": 831
        },
        {
          "path": "skills/dev-guided",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/dev-guided/SKILL.md",
          "type": "blob",
          "size": 9452
        },
        {
          "path": "skills/dev-guided/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/dev-guided/references/implementation-session.md",
          "type": "blob",
          "size": 2823
        },
        {
          "path": "skills/dev-guided/references/initial-setup.md",
          "type": "blob",
          "size": 2736
        },
        {
          "path": "skills/dev-guided/references/template-decisions.md",
          "type": "blob",
          "size": 1550
        },
        {
          "path": "skills/dev-guided/references/template-problem_statement.md",
          "type": "blob",
          "size": 687
        },
        {
          "path": "skills/dev-guided/references/template-progress.md",
          "type": "blob",
          "size": 862
        },
        {
          "path": "skills/dev-guided/references/template-runbook.md",
          "type": "blob",
          "size": 1986
        },
        {
          "path": "skills/nb-notes",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/nb-notes/SKILL.md",
          "type": "blob",
          "size": 6523
        },
        {
          "path": "skills/nb-notes/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/nb-notes/references/nb_commands.md",
          "type": "blob",
          "size": 2613
        },
        {
          "path": "skills/session-learner",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/session-learner/SKILL.md",
          "type": "blob",
          "size": 3323
        },
        {
          "path": "skills/systematic-debugging",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/systematic-debugging/SKILL.md",
          "type": "blob",
          "size": 5453
        }
      ],
      "marketplace": {
        "name": "jun-workflows",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "Jun",
          "url": "https://github.com/anexpn"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "jun-dev-workflows",
            "description": "Jun's development workflow commands and skills for Claude Code",
            "source": "./",
            "category": "development",
            "version": "1.0.0",
            "author": {
              "name": "Jun"
            },
            "install_commands": [
              "/plugin marketplace add anexpn/claude-plugins",
              "/plugin install jun-dev-workflows@jun-workflows"
            ],
            "signals": {
              "stars": 1,
              "forks": 0,
              "pushed_at": "2025-12-01T10:17:48Z",
              "created_at": "2025-10-24T19:55:41Z",
              "license": null
            },
            "commands": [],
            "skills": [
              {
                "name": "dev-auto",
                "description": "Autonomous development workflow. Generate detailed specs, plans, and tasks for autonomous agent execution with session memory tracking.",
                "path": "skills/dev-auto/SKILL.md",
                "frontmatter": {
                  "name": "dev-auto",
                  "description": "Autonomous development workflow. Generate detailed specs, plans, and tasks for autonomous agent execution with session memory tracking."
                },
                "content": "# Autonomous Development Workflow\n\n## Overview\n\nGenerate comprehensive documentation that enables autonomous agents to implement features, fixes, or changes without constant human supervision. All work is tracked in session docs (spec, plan, tasks) that serve as long-term memory across implementation sessions.\n\n## When to Use This Skill\n\nUse this skill when:\n- Working on well-defined features or fixes\n- Work can be fully specified upfront\n- Implementation can proceed autonomously with minimal supervision\n- Long-term session memory is desired for tracking progress\n\n**Do NOT use for:**\n- Exploratory work requiring human decisions at each step (use dev-guided instead)\n- Trivial changes that don't require planning\n- Quick iterations where formal documentation is overhead\n\n## Workflow Phases\n\nThis workflow consists of 5 phases. Some run interactively in the main conversation (requiring user input), while others can run as autonomous subagents.\n\n### Phase 1: Specification (Interactive)\n\nGenerate a comprehensive design specification through iterative questioning.\n\n**Process:**\n1. Examine the project to understand current state\n2. Ask ONE question at a time (preferring multiple choice)\n3. Refine understanding through Q&A until certain\n4. Present specification in 200-300 word sections\n5. Get approval for each section before proceeding\n6. Write final spec to `docs/development/NNN-<name>/spec.md`\n\n**Reference:** See `references/phase-spec.md` for detailed guidance\n\n**User involvement:** Answer questions, approve spec sections\n\n### Phase 2: Planning (Interactive or Subagent)\n\nCreate detailed implementation plan assuming implementer has minimal context.\n\n**Approach:**\n1. **Tech stack selection** (when needed) - Research and document library/framework choices\n2. **File/module mapping** - Exact paths for new/modified code\n3. **Dependency order** - Build sequence so later pieces have foundations\n4. **Integration points** - How new code connects to existing code\n5. **Risk flags** - Potentially tricky parts\n6. **Testing guidance** - What to test, where tests go\n\n**CRITICAL:** No code in the plan. Describe what needs to be built, not how to code it.\n\n**Reference:** See `references/phase-plan.md` for detailed requirements\n\n**For subagent implementation:** See `references/templates/subagent-plan.md` for prompt template\n\n**Output:** `docs/development/NNN-<name>/plan.md`\n\n**User involvement:** Review and approve the plan\n\n### Phase 3: Task Extraction (Interactive or Subagent)\n\nBreak down the plan into trackable tasks.\n\n**Task format:**\n```markdown\n- [ ] Task description (Plan lines: XX-YY)\n```\n\n**Task granularity:** Each task should deliver coherent, testable functionality. NOT file operations or single-line changes.\n\n**Reference:** See `references/phase-tasks.md` for extraction rules\n\n**For subagent implementation:** See `references/templates/subagent-tasks.md` for prompt template\n\n**Output:** `docs/development/NNN-<name>/tasks.md`\n\n**User involvement:** Review task list\n\n### Phase 4: Implementation (Autonomous - Subagent or External Agent)\n\nImplement tasks one at a time in isolated sessions.\n\n**Implementation Options:**\n\n**Option A: Claude Subagent**\n- Spawn fresh subagent for each task\n- Embed full context in prompt (spec sections, plan section, project context)\n- Subagent implements according to plan (NO deviation)\n- Follows TDD/DRY/YAGNI\n- Reports completion but does NOT mark complete or commit yet\n\n**Reference:** See `references/phase-impl.md` for implementation constraints\n\n**For subagent implementation:** See `references/templates/subagent-impl.md` for prompt template\n\n**Option B: External Coding Agent**\n- Provide agent with task list, spec, plan file paths\n- Provide agent with `references/phase-impl.md` instructions\n- Agent implements next uncompleted task\n- Agent reports completion (does NOT mark complete or commit)\n\n**Option C: Human Implementation**\n- Read next task from tasks.md\n- Read corresponding spec and plan sections\n- Implement according to plan\n- Report completion for review\n\n**User involvement:** Choose implementation method, trigger each task\n\n### Phase 5: Review (Interactive)\n\nReview completed work before marking complete.\n\n**Process:**\n1. Read the spec, plan section, and implementation\n2. Check against requirements, code quality, tests\n3. Provide specific feedback OR sign-off\n4. Route feedback to implementer if issues found\n5. After sign-off, authorize task completion and commit\n\n**Reference:** See `references/phase-review.md` for review checklist\n\n**User involvement:**\n- Trigger review after implementation completes\n- Authorize task completion and commit after sign-off\n\n## Session Memory\n\nAll artifacts in `docs/development/NNN-<name>/` serve as long-term memory:\n\n```\ndocs/development/NNN-<name>/\n├── spec.md       # What we're building (design specification)\n├── plan.md       # How we're building it (implementation plan)\n└── tasks.md      # Implementation checklist with progress tracking\n```\n\nThese files enable:\n- Resuming work after interruption (check tasks.md for progress)\n- Context for autonomous agents (read spec + plan + task)\n- Historical record of implementation decisions\n- Progress tracking across multiple sessions\n\n## Using This Skill\n\n### Full Workflow\n\nInvoke this skill and say:\n> \"I want to implement [feature/fix description]\"\n\nThe skill will guide through all 5 phases.\n\n### Individual Phases\n\nInvoke specific phases when needed:\n- **\"Start spec phase\"** - Begin specification\n- **\"Generate plan from spec\"** - Create plan (provide spec path)\n- **\"Extract tasks from plan\"** - Create task list (provide plan path)\n- **\"Implement next task\"** - Implement next uncompleted task (provide task list path)\n- **\"Review implementation\"** - Review completed work (provide task number)\n\n### Resuming After Interruption\n\nIf interrupted mid-workflow:\n1. Read `docs/development/NNN-<name>/tasks.md` to see completed tasks\n2. Continue with next uncompleted task\n3. The autonomous agent will pick up from current progress\n\n### Modifying the Plan\n\nIf plan needs adjustment during implementation:\n1. Edit `docs/development/NNN-<name>/plan.md`\n2. Update affected tasks in `tasks.md`\n3. Continue implementation with updated plan\n\n## For Autonomous Agents\n\nWhen implementing tasks autonomously (subagents or external agents), follow this critical principle:\n\n**Subagents start with NO context.** They cannot discover information on their own. For reliable results, embed all necessary content directly in the prompt:\n\n1. Full content of relevant reference files (not just paths)\n2. Full content of spec sections (not just the file path)\n3. Specific plan sections extracted by line number\n4. Project context (test commands, file locations, patterns)\n\n**Templates:** Use the prompt templates in `references/templates/` which show exactly what content to embed for each phase.\n\n## Key Principles\n\n1. **Separation of concerns** - Design, implementation, and review are distinct phases\n2. **Plan adherence** - Autonomous implementers follow the plan strictly\n3. **Rich context for agents** - Embed content in prompts, not just file paths\n4. **Incremental commits** - Each task gets its own commit after review sign-off\n5. **Session memory** - All artifacts persist for long-term tracking\n6. **Quality gates** - Nothing marked complete without review sign-off\n\n## Resources\n\nDetailed phase instructions in `references/`:\n- `phase-spec.md` - Specification generation guidance\n- `phase-plan.md` - Planning requirements and format\n- `phase-tasks.md` - Task extraction rules\n- `phase-impl.md` - Implementation constraints\n- `phase-review.md` - Review checklist\n\nSubagent prompt templates in `references/templates/`:\n- `subagent-plan.md` - Planning subagent template\n- `subagent-tasks.md` - Task extraction subagent template\n- `subagent-impl.md` - Implementation subagent template"
              },
              {
                "name": "dev-guided",
                "description": "Human-in-the-loop iterative development. Use when requirements will emerge during implementation, decisions need human approval at each step, or work will span multiple sessions with frequent feedback loops. Creates problem statement, decisions log, runbook, and progress tracking.",
                "path": "skills/dev-guided/SKILL.md",
                "frontmatter": {
                  "name": "dev-guided",
                  "description": "Human-in-the-loop iterative development. Use when requirements will emerge during implementation, decisions need human approval at each step, or work will span multiple sessions with frequent feedback loops. Creates problem statement, decisions log, runbook, and progress tracking."
                },
                "content": "# Guided Development\n\n## Overview\n\nGuided development is a workflow designed for iterative, human-in-the-loop software development. Unlike traditional planning approaches that create detailed upfront plans, this workflow establishes problem boundaries, captures explicit human decisions, and enables incremental implementation with continuous feedback.\n\n**Use this skill when:**\n- The problem is exploratory and not fully understood upfront\n- Human input is needed for key technical decisions\n- Development will proceed iteratively across multiple sessions\n- The human wants to maintain control rather than delegate to autonomous execution\n\n## Workflow Decision Tree\n\nWhen the skill is invoked, determine which phase to enter:\n\n```\nDoes docs/development/NNN-<name>/ exist with materials?\n├─ NO  → Initial Setup Phase (create problem_statement, decisions, runbook, progress)\n└─ YES → Implementation Session Phase (load context, plan, implement, update progress)\n```\n\n## Initial Setup Phase\n\nWhen no materials exist, guide the human through creating foundational documents via structured Q&A.\n\n### Process\n\n1. **Determine folder location**\n   - Check for existing development session folders: `docs/development/`\n   - Determine next number: `NNN` (e.g., 001, 002, etc.)\n   - Ask human for feature name\n   - Create folder: `docs/development/NNN-<name>/`\n\n2. **Create problem_statement.md**\n   - Load the template from `references/template-problem_statement.md`\n   - Ask questions to understand the problem:\n     - \"What problem are you trying to solve?\"\n     - \"What is the scope of this work? What's explicitly out of scope?\"\n     - \"What does success look like?\"\n     - \"Are there any constraints or requirements?\"\n   - Fill in the template with responses\n   - Save as `problem_statement.md`\n\n3. **Create decisions.md**\n   - Load the template from `references/template-decisions.md`\n   - **CRITICAL RULE:** MUST ask about every unclear aspect. MUST NOT assume \"sensible defaults\" or \"de facto standards\"\n   - Probe for decisions on:\n     - Language/framework choices\n     - Library/dependency choices\n     - Architectural patterns\n     - Data storage approaches\n     - Testing strategies\n     - Error handling approaches\n     - Security considerations\n   - For each unclear aspect:\n     - Explain why a decision is needed\n     - Present options if helpful (without bias)\n     - Ask for the human's choice\n     - Record the decision with rationale\n   - Save as `decisions.md`\n\n4. **Create runbook.md**\n   - Load the template from `references/template-runbook.md`\n   - Ask questions:\n     - \"How should this code be built/compiled?\"\n     - \"How should this code be run/tested?\"\n     - \"Are there any other validation steps?\"\n     - \"At what points during implementation should I pause and ask for your feedback?\"\n   - Fill in build, test, run, and validation instructions\n   - Create structured feedback points\n   - Save as `runbook.md`\n\n5. **Create empty progress.md**\n   - Load the template from `references/template-progress.md`\n   - Create empty file (will be populated after first implementation session)\n   - Save as `progress.md`\n\n6. **Complete setup**\n   - Inform human that setup is complete\n   - Ask if they want to start the first implementation session now or later\n   - If now, proceed to Implementation Session Phase\n\n### Reference Materials\n\nFor detailed guidance on the initial setup phase, read `references/initial-setup.md`.\n\n## Implementation Session Phase\n\nWhen materials already exist, start an implementation session to continue development work.\n\n### Process\n\n1. **Load context**\n   - Read `problem_statement.md` to understand the problem scope\n   - Read `decisions.md` to understand what choices have been made\n   - Read `runbook.md` to understand validation and feedback points\n   - Read `progress.md` to understand what's been done and what's outstanding\n   - Check for existing `plan-N.md` files to understand previous approaches\n\n2. **Determine session number**\n   - List existing `plan-N.md` files\n   - Next session number = max(N) + 1\n   - If no plan files exist, this is session 1\n\n3. **Enter plan mode**\n   - Based on loaded context, create a plan for this session\n   - Plan should include:\n     - What will be accomplished\n     - Specific steps to take\n     - Dependencies between steps\n     - Expected validation points from runbook\n     - Outstanding questions or uncertainties\n   - Present plan to human for approval\n\n4. **Save approved plan**\n   - After human approves the plan, save as `plan-N.md` where N is the session number\n   - Proceed with implementation\n\n5. **Implement according to plan**\n   - Follow the approved plan\n   - **Respect feedback points:** When reaching a feedback point in runbook.md, MUST pause and ask for human input\n   - **Document new decisions:** If new unclear aspects arise, update decisions.md and ask for human input\n   - **Update runbook if needed:** If build/test/validation steps change, update runbook.md\n   - **Follow existing decisions:** Use the choices recorded in decisions.md\n   - Perform validation steps from runbook.md\n   - Ensure all tests pass\n\n6. **Update progress.md**\n   - Add a new session entry using this format:\n   ```markdown\n   ## Session N (YYYY-MM-DD)\n\n   ### Accomplished\n   - [What was implemented/completed]\n   - [Tests that now pass]\n   - [Issues that were resolved]\n\n   ### Outstanding\n   - [What still needs to be done]\n   - [Known issues or blockers]\n\n   ### Questions\n   - [New unclear aspects that need decisions]\n   - [Uncertainties or concerns]\n   ```\n\n7. **Session completion**\n   - Verify all changes are recorded in progress.md\n   - Verify any new decisions are in decisions.md\n   - Verify runbook.md is current\n   - Inform human that session is complete\n   - Summarize what was accomplished and what's next\n\n### Reference Materials\n\nFor detailed guidance on implementation sessions, read `references/implementation-session.md`.\n\n## Key Principles\n\n### Workflow Principles\n\n1. **No Assumptions**: Never assume \"sensible defaults\" or \"de facto standards\". Always ask for explicit human decisions.\n\n2. **Respect Feedback Points**: Feedback points in runbook.md are mandatory pause points. Never skip them.\n\n3. **Living Documents**: decisions.md, runbook.md, and progress.md are living documents that evolve throughout the development session.\n\n4. **Session-Scoped Plans**: Each implementation session gets its own plan file. Plans are ephemeral and session-specific, not long-term roadmaps.\n\n5. **Problem-Focused**: problem_statement.md defines the problem and scope, not the solution. It provides boundaries, not prescriptions.\n\n### Engineering Principles\n\n1. **Test Driven Development (TDD)**: For every new feature or bugfix, you MUST:\n   - Write a failing test that correctly validates the desired functionality\n   - Run the test to confirm it fails as expected\n   - Write ONLY enough code to make the failing test pass\n   - Run the test to confirm success\n   - Refactor if needed while keeping tests green\n\n2. **YAGNI (You Aren't Gonna Need It)**: The best code is no code. Don't add features we don't need right now. When it doesn't conflict with YAGNI, architect for extensibility and flexibility.\n\n3. **DRY (Don't Repeat Yourself)**: Work hard to reduce code duplication, even if the refactoring takes extra effort.\n\n4. **Minimal Changes**: Make the SMALLEST reasonable changes to achieve the desired outcome. Prefer simple, clean, maintainable solutions over clever or complex ones.\n\n5. **Fix Broken Things Immediately**: All test failures are your responsibility, even if they're not your fault. Fix broken things immediately when you find them.\n\n6. **Never Skip Tests**: Never delete a test because it's failing. Never write tests that \"test\" mocked behavior. Test output must be pristine to pass.\n\n## Example Usage\n\n**Starting new work:**\n```\nHuman: \"I want to add OAuth authentication to the app\"\nAgent: [Invokes dev-guided skill]\nAgent: [Creates docs/development/001-oauth-auth/ folder]\nAgent: [Guides through creating problem_statement, decisions, runbook, progress]\nAgent: \"Setup complete. Ready to start first implementation session?\"\n```\n\n**Continuing existing work:**\n```\nHuman: \"Continue working on OAuth\" [in directory with existing materials]\nAgent: [Invokes dev-guided skill]\nAgent: [Loads problem_statement, decisions, runbook, progress]\nAgent: [Enters plan mode]\nAgent: \"Based on progress, I plan to implement token storage. Here's my plan...\"\nAgent: [After approval, saves as plan-2.md and implements]\nAgent: [Updates progress.md with session 2 summary]\n```\n\n## Resources\n\nThis skill includes reference materials with detailed phase guidance and templates:\n\n### references/\n- `initial-setup.md` - Detailed guidance for the initial setup phase\n- `implementation-session.md` - Detailed guidance for implementation sessions\n- `template-problem_statement.md` - Template for problem statements\n- `template-decisions.md` - Template for decisions with examples\n- `template-runbook.md` - Template for runbook with feedback point examples\n- `template-progress.md` - Template for progress tracking"
              },
              {
                "name": "nb-notes",
                "description": "Manage persistent notes and todos using the nb note-taking system. This skill should be used when capturing cross-session learnings, technical decisions, deferred tasks, or codebase patterns that should persist beyond the current conversation. Use proactively after solving bugs, making architectural decisions, or discovering important patterns. Triggers on requests like \"what did I learn yesterday\", \"check my notes\", \"what learnings do I have about X\", or \"capture insights\". Do NOT use for tracking current work-in-progress (use TodoWrite for that).",
                "path": "skills/nb-notes/SKILL.md",
                "frontmatter": {
                  "name": "nb-notes",
                  "description": "Manage persistent notes and todos using the nb note-taking system. This skill should be used when capturing cross-session learnings, technical decisions, deferred tasks, or codebase patterns that should persist beyond the current conversation. Use proactively after solving bugs, making architectural decisions, or discovering important patterns. Triggers on requests like \"what did I learn yesterday\", \"check my notes\", \"what learnings do I have about X\", or \"capture insights\". Do NOT use for tracking current work-in-progress (use TodoWrite for that)."
                },
                "content": "# nb Notes\n\n## Overview\n\nManage persistent notes and todos using `nb`, a command-line note-taking system. This skill enables Claude to capture insights, decisions, and deferred tasks that should persist across sessions, while keeping current work-in-progress tracked separately in TodoWrite.\n\n**Notebook Access:**\n- **Write access:** Only the `claude` notebook (for persisting information across Claude sessions)\n- **Read access:** All notebooks (for understanding user's recent learnings, reference materials, and context)\n- Users may organize their nb notebooks differently - check available notebooks with `nb notebooks` or look for organizational notes in the `claude` notebook\n\n## When to Use This Skill\n\n### Use nb for Persistent Information\n\n**Proactively create nb notes when:**\n- Solving a bug and understanding the root cause (tag: `#bug-fix`)\n- Making architectural or technical decisions (tag: `#technical-decision`)\n- Discovering patterns, conventions, or antipatterns in a codebase (tag: `#code-pattern`)\n- Learning about user preferences or working style (tag: `#preference`)\n- Finding workflow improvements or process discoveries (tag: `#workflow`)\n- Capturing insights that will be valuable in future sessions (tag: `#session-insight`)\n\n**Use nb todo/tasks for deferred work:**\n- Issues discovered during work that should be addressed later (tag: `#deferred-task`)\n- Follow-up tasks or improvements to make when time permits\n- Technical debt to track\n\n### Use TodoWrite for Current Work\n\nKeep using TodoWrite for:\n- Breaking down the current task into steps\n- Tracking work-in-progress during the active session\n- Managing what you're actively working on right now\n\n**Key distinction:** nb is for persistence across sessions, TodoWrite is for tracking active work within the current session.\n\n## Creating Notes\n\n### Standard Notes\n\nCreate markdown notes in the `claude` notebook with appropriate tags:\n\n```bash\nnb claude:add --type md --title \"Note Title\" --tags tag1,tag2 --content \"Note content here\"\n```\n\n**Example - Technical Decision:**\n```bash\nnb claude:add --type md \\\n  --title \"Use factory pattern for tool instantiation\" \\\n  --tags technical-decision,code-pattern \\\n  --content \"Decision: Implement factory pattern for creating tools in the MCP server.\n\nRationale:\n- Allows dynamic tool registration\n- Easier to test individual tools in isolation\n- Follows existing patterns in codebase\n\nImplementation: See ToolFactory in src/tools/factory.ts\"\n```\n\n**Example - Bug Fix:**\n```bash\nnb claude:add --type md \\\n  --title \"Race condition in async file watcher\" \\\n  --tags bug-fix,session-insight \\\n  --content \"Root cause: File watcher callbacks fired before initialization completed.\n\nSolution: Added initialization lock using async mutex. Files are queued during init and processed after lock is released.\n\nLocation: src/watchers/file-watcher.ts:145\"\n```\n\n**Example - Codebase Pattern:**\n```bash\nnb claude:add --type md \\\n  --title \"Error handling pattern: wrap with context\" \\\n  --tags code-pattern,preference \\\n  --content \"This codebase wraps errors with additional context rather than throwing new errors.\n\nPattern:\ncatch (err) {\n  throw Object.assign(err, { context: 'additional info' })\n}\n\nNOT:\ncatch (err) {\n  throw new Error(\\`Failed: \\${err.message}\\`)\n}\"\n```\n\n### Deferred Tasks\n\nUse `nb todo` or `nb tasks` for deferred work:\n\n```bash\n# Add a deferred task\nnb claude:todo add \"Refactor authentication module to use new JWT library\" --tags deferred-task,technical-decision\n\n# List deferred tasks\nnb claude:todo list\n\n# Complete a task\nnb claude:todo do <id>\n```\n\n## Searching Notes\n\nBefore creating a note, search to avoid duplicates and to leverage existing knowledge:\n\n```bash\n# Search by keyword\nnb claude:search \"authentication\"\n\n# Search by tag\nnb claude:search --tags technical-decision\n\n# List recent notes\nnb claude:list --limit 10\n\n# List notes with specific tags\nnb claude:list --tags code-pattern,preference\n```\n\n**When to search:**\n- Before starting work on a new area of the codebase\n- When encountering a familiar problem\n- When making decisions (check if similar decisions were made before)\n\n## Editing Notes\n\nUpdate existing notes when information changes or needs clarification:\n\n```bash\n# Edit a note\nnb claude:edit <id>\n\n# Show a note first to see its content\nnb claude:show <id>\n```\n\n## Note Quality Guidelines\n\n**Good notes are:**\n- **Specific**: Include file paths, line numbers, concrete examples\n- **Actionable**: Explain not just what, but why and how\n- **Searchable**: Use clear titles and appropriate tags\n- **Concise**: Focus on the essential information\n- **Evergreen**: Avoid temporal references (\"recently\", \"new\", \"old\")\n\n**Title conventions:**\n- 5-10 words\n- Present tense verbs for actions: \"Use factory pattern for tool creation\"\n- Nouns for concepts: \"Authentication flow in API layer\"\n- Include context: \"React components: Prefer composition over inheritance\"\n\n**Content structure:**\n- Start with the key insight or decision\n- Include rationale/context\n- Add implementation details or location references\n- Use code examples when helpful\n\n## Tag Reference\n\nStandard tags for organization:\n\n- `#technical-decision` - Architectural choices, framework decisions, design rationale\n- `#session-insight` - Important learnings or patterns discovered during work\n- `#deferred-task` - Issues or improvements to address later\n- `#code-pattern` - Common patterns, antipatterns, or conventions found in codebases\n- `#bug-fix` - Solutions to bugs and their root causes\n- `#workflow` - Process improvements or workflow discoveries\n- `#preference` - User preferences and working style notes\n\nApply multiple tags when appropriate.\n\n## Resources\n\n### references/nb_commands.md\n\nComplete reference for all nb commands, including detailed syntax for creating notes, todos, tasks, searching, and editing. Consult this file for command-line syntax details and additional examples."
              },
              {
                "name": "session-learner",
                "description": "Extract and persist learnings from the current session. This skill should be used when the user wants Claude to analyze the conversation and capture insights, patterns, preferences, or knowledge discovered during work. Triggers on requests like \"learn from this session\", \"what did we learn\", or \"capture insights\".",
                "path": "skills/session-learner/SKILL.md",
                "frontmatter": {
                  "name": "session-learner",
                  "description": "Extract and persist learnings from the current session. This skill should be used when the user wants Claude to analyze the conversation and capture insights, patterns, preferences, or knowledge discovered during work. Triggers on requests like \"learn from this session\", \"what did we learn\", or \"capture insights\"."
                },
                "content": "# Session Learner\n\nAnalyze the current session to extract learnings and persist them to appropriate locations.\n\n## Workflow\n\n### Step 1: Analyze Session\n\nReview the entire conversation to identify learnings in these categories:\n\n1. **User Preferences** - Working style, communication preferences, tool preferences\n2. **Agent Failure Patterns** - Mistakes Claude made, misunderstandings, approaches that didn't work\n3. **Project Technical Patterns** - Code patterns, architecture decisions, project-specific conventions\n4. **Reusable Workflows** - Multi-step procedures that could become skills\n5. **Reference Knowledge** - Architectural decisions, domain knowledge, API behaviors\n\n### Step 2: Categorize by Destination\n\nMap each learning to its appropriate destination:\n\n| Learning Type | Destination | Rationale |\n|---------------|-------------|-----------|\n| User preferences | `~/.claude/CLAUDE.md` | Applies across all projects |\n| Agent failure patterns | `~/.claude/CLAUDE.md` | Prevents repeating mistakes globally |\n| Project technical patterns | Project `CLAUDE.md` | Project-specific guidance |\n| Reusable workflows | New skill | Procedural knowledge for reuse |\n| Reference knowledge | Project `docs/` folder | Documentation for future reference |\n\n### Step 3: Check for Conflicts\n\nBefore presenting findings, check if any learning contradicts existing content:\n\n1. Read the target file (user CLAUDE.md, project CLAUDE.md, or relevant docs)\n2. Identify any conflicts between new learnings and existing content\n3. Flag conflicts explicitly for user decision\n\n### Step 4: Present Findings\n\nPresent findings grouped by destination. For each group:\n\n1. State the destination file path\n2. List each learning with a brief description (1-2 sentences)\n3. If conflicts exist, show:\n   - The existing content\n   - The proposed new content\n   - Ask user to choose: keep existing, replace with new, or merge\n\nFormat:\n\n```\n## Learnings for ~/.claude/CLAUDE.md\n\n1. [Brief description of learning]\n2. [Brief description of learning]\n\n⚠️ CONFLICT: [description]\n   Existing: [current content]\n   Proposed: [new content]\n   Keep existing / Replace / Merge?\n\n## Learnings for [project]/CLAUDE.md\n\n1. [Brief description of learning]\n\n## Learnings for [project]/docs/\n\n1. [Brief description] → docs/[filename].md\n\n## Potential New Skill\n\n1. [Workflow name]: [brief description]\n```\n\n### Step 5: Apply Approved Learnings\n\nAfter user approves (or modifies) findings:\n\n1. For CLAUDE.md files: Append to appropriate section, or create section if needed\n2. For docs/: Create or update the markdown file\n3. For new skills: Offer to create using the skill-creator skill\n\n## Guidelines\n\n- Keep learnings concise and actionable\n- Prefer specific examples over abstract principles\n- Do not duplicate information already in target files\n- When uncertain about destination, ask the user to choose\n- Learnings should be evergreen - no temporal references like \"today we learned\""
              },
              {
                "name": "systematic-debugging",
                "description": "Structured debugging methodology for investigating and resolving technical issues. Use this skill when debugging any technical problem, investigating errors, or troubleshooting unexpected behavior to ensure root cause analysis rather than symptom treatment.",
                "path": "skills/systematic-debugging/SKILL.md",
                "frontmatter": {
                  "name": "systematic-debugging",
                  "description": "Structured debugging methodology for investigating and resolving technical issues. Use this skill when debugging any technical problem, investigating errors, or troubleshooting unexpected behavior to ensure root cause analysis rather than symptom treatment."
                },
                "content": "# Systematic Debugging Process\n\n## Overview\n\nThis skill provides a disciplined, phase-based approach to debugging that ensures root cause identification rather than symptom treatment. The methodology emphasizes systematic investigation, hypothesis testing, and minimal incremental fixes.\n\n## When to Use This Skill\n\nUse this skill whenever:\n- Debugging a technical issue or error\n- Investigating unexpected behavior\n- Troubleshooting test failures\n- Resolving performance problems\n- Analyzing system failures\n\n## Core Principle\n\n**ALWAYS find the root cause of any issue. NEVER fix a symptom or add a workaround instead of finding the root cause, even if it appears faster or more expedient.**\n\n## Four-Phase Debugging Framework\n\n### Phase 1: Root Cause Investigation\n\n**Perform BEFORE attempting any fixes.** This phase focuses on understanding the problem completely.\n\n#### Read Error Messages Carefully\n- Don't skip past errors or warnings\n- Error messages often contain the exact solution\n- Note stack traces, line numbers, and context\n- Look for patterns in multiple error occurrences\n\n#### Reproduce Consistently\n- Ensure the issue can be reliably reproduced\n- Identify the minimal steps to trigger the problem\n- Note any conditions that affect reproducibility\n- Document the exact environment and context\n\n#### Check Recent Changes\n- Review what changed that could have caused this\n- Use `git diff` to examine recent modifications\n- Check recent commits and their impact\n- Consider dependency updates or configuration changes\n\n### Phase 2: Pattern Analysis\n\nThis phase involves comparing working and non-working states to identify differences.\n\n#### Find Working Examples\n- Locate similar working code in the same codebase\n- Identify what makes the working example successful\n- Note the context and dependencies of working code\n\n#### Compare Against References\n- If implementing a pattern, read the reference implementation completely\n- Don't skim documentation—read it thoroughly\n- Understand the intended usage and requirements\n- Identify any prerequisites or setup steps\n\n#### Identify Differences\n- What's different between working and broken code?\n- Compare structure, dependencies, and configuration\n- Look for missing imports, incorrect types, or wrong parameters\n- Check for environmental differences\n\n#### Understand Dependencies\n- What other components does this code depend on?\n- Are there configuration files or settings required?\n- What initialization or setup is needed?\n- Are there version compatibility issues?\n\n### Phase 3: Hypothesis and Testing\n\nThis phase requires forming clear hypotheses and testing them methodically.\n\n#### 1. Form Single Hypothesis\n- State clearly what you think is the root cause\n- Base the hypothesis on evidence from previous phases\n- Be specific about the suspected problem\n- Example: \"The error occurs because X is undefined when Y runs\"\n\n#### 2. Test Minimally\n- Make the smallest possible change to test the hypothesis\n- Change only ONE thing at a time\n- Avoid adding multiple fixes simultaneously\n- Keep changes reversible and isolated\n\n#### 3. Verify Before Continuing\n- Did the test work? Did it fix the problem?\n- If not, form a new hypothesis—don't add more fixes\n- Understand why the hypothesis was wrong\n- Learn from failed hypotheses to refine the investigation\n\n#### 4. When You Don't Know\n- Say \"I don't understand X\" rather than pretending to know\n- Ask for clarification or additional information\n- Admit knowledge gaps honestly\n- Seek help when needed\n\n### Phase 4: Implementation Rules\n\nOnce the root cause is confirmed, follow these rules during implementation:\n\n#### Always Have a Failing Test Case\n- Create the simplest possible test that reproduces the issue\n- If there's no test framework, write a one-off test script\n- The test should fail before the fix and pass after\n- Keep the test case minimal and focused\n\n#### Never Add Multiple Fixes at Once\n- Fix one thing at a time\n- Test after each change\n- Understand the impact of each modification\n- Avoid the temptation to \"fix everything\"\n\n#### Never Claim to Implement a Pattern Without Reading It\n- Read reference implementations completely first\n- Understand the pattern thoroughly before implementing\n- Don't guess at how something should work\n- Follow documented patterns exactly\n\n#### Always Test After Each Change\n- Run tests immediately after each modification\n- Verify the fix works as expected\n- Check for regressions in other functionality\n- Confirm the original error is resolved\n\n#### If First Fix Doesn't Work, STOP and Re-analyze\n- Don't pile on additional fixes\n- Return to Phase 1 or Phase 2\n- Form a new hypothesis based on new information\n- Avoid the \"shotgun debugging\" anti-pattern\n\n## Anti-Patterns to Avoid\n\n- **Symptom Treatment**: Fixing what appears broken without understanding why\n- **Shotgun Debugging**: Making multiple changes hoping something works\n- **Assumption-Based Fixes**: Guessing at solutions without investigation\n- **Workaround Mentality**: Adding code to bypass problems rather than fixing them\n- **Impatient Debugging**: Rushing to fix without understanding the root cause"
              }
            ]
          }
        ]
      }
    }
  ]
}