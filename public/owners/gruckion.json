{
  "owner": {
    "id": "gruckion",
    "display_name": "Stephen Rayner",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/4559650?u=77dd1cec419817e50dfaa8dddc194e261d2b2d81&v=4",
    "url": "https://github.com/gruckion",
    "bio": "Fullstack developer Typescript, React, C#.Net, Python, AWS and Azure",
    "stats": {
      "total_repos": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 7,
      "total_stars": 7,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "gruckion/marathon-ralph",
      "url": "https://github.com/gruckion/marathon-ralph",
      "description": null,
      "homepage": null,
      "signals": {
        "stars": 7,
        "forks": 0,
        "pushed_at": "2026-01-08T06:02:47Z",
        "created_at": "2026-01-03T19:45:01Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 614
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 555
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 171
        },
        {
          "path": ".mcp.json",
          "type": "blob",
          "size": 217
        },
        {
          "path": "AGENTS.md",
          "type": "blob",
          "size": 3795
        },
        {
          "path": "CLAUDE.md",
          "type": "blob",
          "size": 29
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 7729
        },
        {
          "path": "agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/code.md",
          "type": "blob",
          "size": 7148
        },
        {
          "path": "agents/exit.md",
          "type": "blob",
          "size": 3867
        },
        {
          "path": "agents/init.md",
          "type": "blob",
          "size": 6286
        },
        {
          "path": "agents/plan.md",
          "type": "blob",
          "size": 4630
        },
        {
          "path": "agents/qa.md",
          "type": "blob",
          "size": 13532
        },
        {
          "path": "agents/setup.md",
          "type": "blob",
          "size": 3681
        },
        {
          "path": "agents/test.md",
          "type": "blob",
          "size": 11504
        },
        {
          "path": "agents/verify.md",
          "type": "blob",
          "size": 6417
        },
        {
          "path": "assets",
          "type": "tree",
          "size": null
        },
        {
          "path": "assets/banner.jpg",
          "type": "blob",
          "size": 209431
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/cancel.md",
          "type": "blob",
          "size": 3359
        },
        {
          "path": "commands/run.md",
          "type": "blob",
          "size": 17184
        },
        {
          "path": "commands/status.md",
          "type": "blob",
          "size": 5171
        },
        {
          "path": "examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "examples/small_todo_app_spec.txt",
          "type": "blob",
          "size": 2836
        },
        {
          "path": "examples/todo_app_spec.txt",
          "type": "blob",
          "size": 26140
        },
        {
          "path": "hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "hooks/hooks.json",
          "type": "blob",
          "size": 323
        },
        {
          "path": "hooks/stop-hook.sh",
          "type": "blob",
          "size": 6282
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/database",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/database/sqlite",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/database/sqlite/SKILL.md",
          "type": "blob",
          "size": 10144
        },
        {
          "path": "skills/marathon-ralph",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/marathon-ralph/SKILL.md",
          "type": "blob",
          "size": 3318
        },
        {
          "path": "skills/project-detection",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/project-detection/SKILL.md",
          "type": "blob",
          "size": 4410
        },
        {
          "path": "skills/project-detection/monorepo.md",
          "type": "blob",
          "size": 3950
        },
        {
          "path": "skills/project-detection/node.md",
          "type": "blob",
          "size": 2571
        },
        {
          "path": "skills/project-detection/python.md",
          "type": "blob",
          "size": 3060
        },
        {
          "path": "skills/project-detection/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/project-detection/scripts/detect.sh",
          "type": "blob",
          "size": 10550
        },
        {
          "path": "skills/setup-playwright",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/setup-playwright/SKILL.md",
          "type": "blob",
          "size": 9629
        },
        {
          "path": "skills/setup-vitest",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/setup-vitest/SKILL.md",
          "type": "blob",
          "size": 8230
        },
        {
          "path": "skills/update-state",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/update-state/SKILL.md",
          "type": "blob",
          "size": 6560
        },
        {
          "path": "skills/update-state/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/update-state/scripts/update-state.sh",
          "type": "blob",
          "size": 14146
        },
        {
          "path": "skills/visual-verification",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/visual-verification/SKILL.md",
          "type": "blob",
          "size": 1290
        },
        {
          "path": "skills/visual-verification/browser-verification.md",
          "type": "blob",
          "size": 2023
        },
        {
          "path": "skills/visual-verification/mobile-verification.md",
          "type": "blob",
          "size": 424
        },
        {
          "path": "skills/write-playwright-test",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/write-playwright-test/SKILL.md",
          "type": "blob",
          "size": 12814
        }
      ],
      "marketplace": {
        "name": "marathon-ralph",
        "version": "1.0.0",
        "description": "Persistent marathon development sessions for Linear issues",
        "owner_info": {
          "name": "gruckion",
          "email": ""
        },
        "keywords": [],
        "plugins": [
          {
            "name": "marathon-ralph",
            "description": "Persistent marathon development sessions for Linear issues - continue working on the same task across multiple Claude sessions with automatic state management and progress tracking",
            "source": "./",
            "category": "productivity",
            "version": "1.0.0",
            "author": null,
            "install_commands": [
              "/plugin marketplace add gruckion/marathon-ralph",
              "/plugin install marathon-ralph@marathon-ralph"
            ],
            "signals": {
              "stars": 7,
              "forks": 0,
              "pushed_at": "2026-01-08T06:02:47Z",
              "created_at": "2026-01-03T19:45:01Z",
              "license": null
            },
            "commands": [],
            "skills": [
              {
                "name": "marathon-ralph",
                "description": "Autonomous long-running development from specifications. Use when user wants to build an application from a spec file, run continuous development, or automate feature implementation. Triggers on phrases like \"marathon this\", \"build from spec\", \"autonomous development\", \"keep coding until done\".",
                "path": "skills/marathon-ralph/SKILL.md",
                "frontmatter": {
                  "name": "marathon-ralph",
                  "description": "Autonomous long-running development from specifications. Use when user wants to build an application from a spec file, run continuous development, or automate feature implementation. Triggers on phrases like \"marathon this\", \"build from spec\", \"autonomous development\", \"keep coding until done\"."
                },
                "content": "# Marathon Ralph - Autonomous Development\n\nThis skill enables autonomous, long-running development sessions that:\n\n- Create Linear projects from specification files\n- Work through issues systematically with verification\n- Continue across multiple sessions via Stop hook\n- Produce fully tested applications\n\n## Triggers\n\nActivate this skill when the user:\n\n- Wants to build an application from a specification\n- Says \"marathon this [spec]\" or \"build from [spec]\"\n- Asks for autonomous/continuous development\n- Wants to \"keep coding until done\"\n- Provides a spec file and wants it implemented\n- Mentions \"marathon development\" or \"marathon session\"\n- Wants to implement multiple features from a spec without stopping\n\n## Usage\n\n### Resume Existing Marathon\n\n```\n/marathon-ralph:run\n```\n\nOr naturally: \"Continue the marathon\" or \"Keep going\"\n\n### Start New Marathon\n\n```\n/marathon-ralph:run path/to/spec.md\n```\n\nOr naturally: \"Marathon this spec.md until complete\"\n\n### Check Progress\n\n```\n/marathon-ralph:status\n```\n\nOr naturally: \"How's the marathon going?\"\n\n### Cancel\n\n```\n/marathon-ralph:cancel\n```\n\nOr naturally: \"Stop the marathon\"\n\n## Prerequisites\n\nUser must have Linear MCP configured:\n\n1. `claude mcp add --transport http linear https://mcp.linear.app/mcp`\n2. `/mcp` - Select Linear and authenticate via OAuth\n\n## How It Works\n\n1. **Setup**: Verifies Linear MCP connection is active\n2. **Init**: Creates Linear project and issues from the spec file\n3. **Loop**: For each issue in priority order:\n   - Verify (tests, lint, types) - ensures codebase is healthy\n   - Plan implementation - creates detailed implementation strategy\n   - Code the feature - implements according to plan\n   - Write tests - unit and integration tests\n   - Write E2E tests - for web projects only\n   - Commit and mark Done in Linear\n4. **Continue**: Stop hook automatically restarts for next issue until all complete\n\n## Example Workflows\n\n### Starting a New Project\n\nUser: \"Marathon this todo-app-spec.md until it's done\"\n\n1. Skill triggers on \"marathon\" + spec file reference\n2. Runs `/marathon-ralph:run --spec-file todo-app-spec.md`\n3. Creates Linear project with issues from spec\n4. Begins autonomous coding loop\n\n### Checking Progress\n\nUser: \"How far along is the marathon?\"\n\n1. Skill triggers on marathon progress query\n2. Runs `/marathon-ralph:status`\n3. Reports current phase, issue, and completion percentage\n\n### Stopping Early\n\nUser: \"Stop the marathon, I need to change the spec\"\n\n1. Skill triggers on stop/cancel request\n2. Runs `/marathon-ralph:cancel`\n3. Confirms with user and cleanly stops\n4. Linear project preserved for later\n\n## State Management\n\nMarathon state is stored in `.claude/marathon-ralph.json` in the project root. This tracks:\n\n- Current phase (setup, init, coding, complete)\n- Linear project and issue information\n- Progress statistics\n- Timestamps for tracking\n\nThe Stop hook reads this state to determine whether to continue autonomous operation or allow exit."
              },
              {
                "name": "project-detection",
                "description": "Detects project type, package manager, and monorepo structure. Returns correct commands for test/build/lint/dev. Run at project initialization and cache results in state. Use before running any build/test commands.",
                "path": "skills/project-detection/SKILL.md",
                "frontmatter": {
                  "name": "project-detection",
                  "description": "Detects project type, package manager, and monorepo structure. Returns correct commands for test/build/lint/dev. Run at project initialization and cache results in state. Use before running any build/test commands."
                },
                "content": "# Project Detection\n\nDetects project configuration and provides standardized commands. Run once at init, cache in state file.\n\n## Usage\n\nRun the detection script from the project root:\n\n```bash\n./marathon-ralph/skills/project-detection/scripts/detect.sh /path/to/project\n```\n\nReturns JSON:\n\n```json\n{\n  \"language\": \"node\",\n  \"packageManager\": \"bun\",\n  \"monorepo\": {\n    \"type\": \"turbo\",\n    \"workspaces\": [\"apps/web\", \"apps/api\", \"packages/shared\"]\n  },\n  \"commands\": {\n    \"install\": \"bun install\",\n    \"dev\": \"bun run dev\",\n    \"build\": \"bun run build\",\n    \"test\": \"bun run test\",\n    \"testWorkspace\": \"bun run --filter={workspace} test\",\n    \"lint\": \"bun run lint\",\n    \"typecheck\": \"bun run check-types\"\n  }\n}\n```\n\n## Caching Results\n\nAfter detection, store in marathon state file under `project` key:\n\n```json\n{\n  \"project\": {\n    \"language\": \"node\",\n    \"packageManager\": \"bun\",\n    \"monorepo\": { \"type\": \"turbo\", \"workspaces\": [...] },\n    \"commands\": { ... },\n    \"detectedAt\": \"2024-01-03T12:00:00Z\"\n  }\n}\n```\n\n## Using Cached Commands\n\nWhen running commands, always check state first:\n\n1. Read `project.commands` from state  \n2. If not present, run detection script  \n3. Use the appropriate command from the cache  \n\n### For Monorepos\n\nWhen tests/builds need to target a specific workspace:\n\n```bash\n# Use testWorkspace with the workspace name\nbun run --filter=web test\n\n# Or for all workspaces\nturbo run test\n```\n\n### Command Selection Priority\n\n1. Use cached command from state  \n2. If no cache, run detection  \n3. If detection fails, fall back to reference patterns  \n\n## Detection Logic\n\n### Package Manager Detection (by lock file)\n\n| Lock File                      | Package Manager | Install               | Run        |\n|--------------------------------|-----------------|-----------------------|------------|\n| `bun.lock` or `bun.lockb`      | bun             | `bun install`         | `bun run`  |\n| `pnpm-lock.yaml`               | pnpm            | `pnpm install`        | `pnpm run` |\n| `yarn.lock`                    | yarn            | `yarn install`        | `yarn`     |\n| `package-lock.json`            | npm             | `npm install`         | `npm run`  |\n\n### Monorepo Detection\n\n| Config File                        | Monorepo Type         |\n|------------------------------------|-----------------------|\n| `turbo.json`                       | Turborepo             |\n| `nx.json`                          | Nx                    |\n| `lerna.json`                       | Lerna                 |\n| `pnpm-workspace.yaml`              | pnpm workspaces       |\n| `package.json` with `workspaces`   | npm/yarn workspaces   |\n\n### Language Detection\n\n| Indicator                             | Language |\n|---------------------------------------|----------|\n| `package.json`                        | Node.js  |\n| `pyproject.toml`, `setup.py`          | Python   |\n| `go.mod`                              | Go       |\n| `Cargo.toml`                          | Rust     |\n| `build.gradle`, `pom.xml`             | Java     |\n\n## Python Project Commands\n\nFor Python projects:\n\n| Tool        | Install                                   | Run Script              | Test                  |\n|-------------|-------------------------------------------|-------------------------|-----------------------|\n| poetry      | `poetry install`                          | `poetry run {script}`   | `poetry run pytest`   |\n| poetry+poe  | `poetry install`                          | `poe {task}`            | `poe test`            |\n| pip + venv  | `pip install -r requirements.txt`         | `python -m {module}`    | `pytest`              |\n| uv          | `uv pip install -r requirements.txt`      | `uv run {script}`       | `uv run pytest`       |\n| pipenv      | `pipenv install`                          | `pipenv run {script}`   | `pipenv run pytest`   |\n\n**Note:** If `[tool.poe.tasks]` exists in `pyproject.toml`, poe commands are preferred.\n\n## Reference Files\n\n- [node.md](node.md) - Node.js patterns and commands\n- [python.md](python.md) - Python patterns and commands\n- [monorepo.md](monorepo.md) - Monorepo-specific patterns"
              },
              {
                "name": "setup-playwright",
                "description": "Configure Playwright for E2E testing. Use when setting up end-to-end tests, when no E2E framework is detected, or when the user asks to configure browser testing.",
                "path": "skills/setup-playwright/SKILL.md",
                "frontmatter": {
                  "name": "setup-playwright",
                  "description": "Configure Playwright for E2E testing. Use when setting up end-to-end tests, when no E2E framework is detected, or when the user asks to configure browser testing.",
                  "allowed-tools": "Read, Write, Edit, Bash, Glob, Grep"
                },
                "content": "# Setup Playwright\n\nConfigure Playwright as the end-to-end testing framework with fixtures and best practices.\n\n## When to Use This Skill\n\n- No E2E framework is configured in the project\n- User requests to set up E2E testing\n- Project is a web application needing browser testing\n- Migrating from Cypress to Playwright\n\n## Installation\n\nUse `ni` to auto-detect the package manager. Get the exec command from `.claude/marathon-ralph.json` under `project.commands.exec`:\n\n```bash\n# Install Playwright\nni -D @playwright/test\n\n# Install browsers (use exec command from project state: bunx, pnpm exec, npx, etc.)\n# Examples:\nbunx playwright install --with-deps\n# or: pnpm exec playwright install --with-deps\n# or: npx playwright install --with-deps\n\n# For CI optimization, install only needed browsers\nbunx playwright install chromium --with-deps\n```\n\n## Configuration\n\n### playwright.config.ts\n\nCreate `playwright.config.ts` at the project root:\n\n```typescript\nimport { defineConfig, devices } from '@playwright/test'\n\nexport default defineConfig({\n  // Test directory\n  testDir: './tests/e2e',\n\n  // Run tests in parallel\n  fullyParallel: true,\n\n  // Fail build on CI if test.only is left in code\n  forbidOnly: !!process.env.CI,\n\n  // Retry failed tests (more on CI)\n  retries: process.env.CI ? 2 : 0,\n\n  // Parallel workers\n  workers: process.env.CI ? 1 : undefined,\n\n  // Reporter configuration\n  reporter: process.env.CI\n    ? [['github'], ['html', { open: 'never' }]]\n    : [['list'], ['html']],\n\n  // Timeouts\n  timeout: 30000,\n  expect: {\n    timeout: 5000,\n  },\n\n  // Shared settings for all projects\n  use: {\n    // Base URL for page.goto('/')\n    baseURL: process.env.BASE_URL || 'http://localhost:3000',\n\n    // Collect trace on first retry\n    trace: 'on-first-retry',\n\n    // Screenshot on failure\n    screenshot: 'only-on-failure',\n\n    // Video on first retry\n    video: 'on-first-retry',\n  },\n\n  // Browser projects\n  projects: [\n    // Setup project for authentication\n    {\n      name: 'setup',\n      testMatch: /.*\\.setup\\.ts/,\n    },\n\n    // Desktop Chrome\n    {\n      name: 'chromium',\n      use: {\n        ...devices['Desktop Chrome'],\n        storageState: 'playwright/.auth/user.json',\n      },\n      dependencies: ['setup'],\n    },\n\n    // Desktop Firefox (optional)\n    {\n      name: 'firefox',\n      use: {\n        ...devices['Desktop Firefox'],\n        storageState: 'playwright/.auth/user.json',\n      },\n      dependencies: ['setup'],\n    },\n\n    // Desktop Safari (optional)\n    {\n      name: 'webkit',\n      use: {\n        ...devices['Desktop Safari'],\n        storageState: 'playwright/.auth/user.json',\n      },\n      dependencies: ['setup'],\n    },\n\n    // Mobile Chrome (optional)\n    {\n      name: 'Mobile Chrome',\n      use: {\n        ...devices['Pixel 5'],\n        storageState: 'playwright/.auth/user.json',\n      },\n      dependencies: ['setup'],\n    },\n  ],\n\n  // Run dev server before tests\n  // IMPORTANT: Use the dev command from your package manager\n  // Get from project state: project.commands.dev\n  webServer: {\n    command: process.env.DEV_COMMAND || 'bun run dev', // Adjust based on package manager\n    url: 'http://localhost:3000',\n    reuseExistingServer: !process.env.CI,\n    timeout: 120 * 1000,\n  },\n})\n```\n\n### Directory Structure\n\nCreate the recommended directory structure:\n\n```\nproject/\n├── tests/\n│   └── e2e/\n│       ├── fixtures/\n│       │   └── test-fixtures.ts    # Custom fixtures\n│       ├── pages/\n│       │   ├── login.page.ts       # Page objects\n│       │   └── home.page.ts\n│       ├── auth.setup.ts           # Authentication setup\n│       ├── home.spec.ts            # Test files\n│       └── login.spec.ts\n├── playwright/\n│   └── .auth/\n│       └── .gitkeep                # Auth state storage\n├── playwright.config.ts\n└── package.json\n```\n\nCreate the directories:\n\n```bash\nmkdir -p tests/e2e/fixtures tests/e2e/pages playwright/.auth\ntouch playwright/.auth/.gitkeep\n```\n\n### .gitignore\n\nAdd to `.gitignore`:\n\n```gitignore\n# Playwright\nplaywright-report/\ntest-results/\nplaywright/.auth/\n!playwright/.auth/.gitkeep\n```\n\n### Package.json Scripts\n\nAdd test scripts:\n\n```json\n{\n  \"scripts\": {\n    \"test:e2e\": \"playwright test\",\n    \"test:e2e:ui\": \"playwright test --ui\",\n    \"test:e2e:headed\": \"playwright test --headed\",\n    \"test:e2e:debug\": \"playwright test --debug\",\n    \"test:e2e:report\": \"playwright show-report\"\n  }\n}\n```\n\n## Authentication Setup\n\nCreate `tests/e2e/auth.setup.ts` for shared authentication:\n\n```typescript\nimport { test as setup, expect } from '@playwright/test'\n\nconst authFile = 'playwright/.auth/user.json'\n\nsetup('authenticate', async ({ page }) => {\n  // Navigate to login\n  await page.goto('/login')\n\n  // Fill credentials\n  await page.getByLabel(/email/i).fill('test@example.com')\n  await page.getByLabel(/password/i).fill('password123')\n  await page.getByRole('button', { name: /sign in/i }).click()\n\n  // Wait for authentication to complete\n  await expect(page).toHaveURL('/dashboard')\n\n  // Save authentication state\n  await page.context().storageState({ path: authFile })\n})\n```\n\n## Custom Fixtures\n\nCreate `tests/e2e/fixtures/test-fixtures.ts`:\n\n```typescript\nimport { test as base, expect } from '@playwright/test'\nimport { LoginPage } from '../pages/login.page'\nimport { HomePage } from '../pages/home.page'\n\n// Declare fixture types\ntype MyFixtures = {\n  loginPage: LoginPage\n  homePage: HomePage\n}\n\n// Extend base test with custom fixtures\nexport const test = base.extend<MyFixtures>({\n  loginPage: async ({ page }, use) => {\n    const loginPage = new LoginPage(page)\n    await use(loginPage)\n  },\n\n  homePage: async ({ page }, use) => {\n    const homePage = new HomePage(page)\n    await use(homePage)\n  },\n})\n\nexport { expect }\n```\n\n## Page Object Model\n\nCreate `tests/e2e/pages/login.page.ts`:\n\n```typescript\nimport { type Page, type Locator } from '@playwright/test'\n\nexport class LoginPage {\n  readonly page: Page\n  readonly emailInput: Locator\n  readonly passwordInput: Locator\n  readonly submitButton: Locator\n  readonly errorMessage: Locator\n\n  constructor(page: Page) {\n    this.page = page\n    this.emailInput = page.getByLabel(/email/i)\n    this.passwordInput = page.getByLabel(/password/i)\n    this.submitButton = page.getByRole('button', { name: /sign in/i })\n    this.errorMessage = page.getByRole('alert')\n  }\n\n  async goto() {\n    await this.page.goto('/login')\n  }\n\n  async login(email: string, password: string) {\n    await this.emailInput.fill(email)\n    await this.passwordInput.fill(password)\n    await this.submitButton.click()\n  }\n}\n```\n\n## GitHub Actions CI\n\nCreate `.github/workflows/playwright.yml`:\n\n**Adjust commands based on your package manager** (get from `project.commands`):\n\n```yaml\nname: Playwright Tests\n\non:\n  push:\n    branches: [main, master]\n  pull_request:\n    branches: [main, master]\n\njobs:\n  test:\n    timeout-minutes: 60\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: actions/setup-node@v4\n        with:\n          node-version: lts/*\n\n      # For bun projects\n      - uses: oven-sh/setup-bun@v2\n        # if using bun\n\n      # Install dependencies - adjust for your package manager\n      # bun: bun install\n      # pnpm: pnpm install\n      # yarn: yarn install\n      # npm: npm ci\n      - name: Install dependencies\n        run: bun install\n\n      # Install Playwright browsers - use your exec command\n      - name: Install Playwright Browsers\n        run: bunx playwright install chromium --with-deps\n\n      # Run tests - use your exec command\n      - name: Run Playwright tests\n        run: bunx playwright test\n\n      - uses: actions/upload-artifact@v4\n        if: ${{ !cancelled() }}\n        with:\n          name: playwright-report\n          path: playwright-report/\n          retention-days: 30\n```\n\n## Verification\n\nAfter setup, verify with:\n\n```bash\n# Run all tests\nnr test:e2e\n\n# Run in UI mode\nnr test:e2e:ui\n\n# Run headed (visible browser)\nnr test:e2e:headed\n\n# Debug mode\nnr test:e2e:debug\n\n# View report\nnr test:e2e:report\n```\n\n## Key Configuration Options\n\n| Option | Description | Default |\n|--------|-------------|---------|\n| `testDir` | Directory containing tests | `./tests` |\n| `fullyParallel` | Run tests in parallel | `true` |\n| `retries` | Retry failed tests | `0` |\n| `workers` | Parallel workers | Auto |\n| `timeout` | Test timeout (ms) | `30000` |\n| `trace` | Trace collection | `'on-first-retry'` |\n| `screenshot` | Screenshot capture | `'only-on-failure'` |\n| `video` | Video recording | `'off'` |\n| `baseURL` | Base URL for navigation | Required |\n\n## CLI Commands Reference\n\nUse your exec command from project state (`bunx`, `pnpm exec`, `npx`, etc.):\n\n| Command | Description |\n|---------|-------------|\n| `{exec} playwright test` | Run all tests |\n| `{exec} playwright test --ui` | UI mode |\n| `{exec} playwright test --headed` | Visible browser |\n| `{exec} playwright test --debug` | Debug mode |\n| `{exec} playwright test file.spec.ts` | Run specific file |\n| `{exec} playwright test --project=chromium` | Run specific project |\n| `{exec} playwright codegen` | Generate tests |\n| `{exec} playwright show-report` | Open HTML report |\n\nReplace `{exec}` with your package manager's exec command (e.g., `bunx`, `pnpm exec`, `npx`)."
              },
              {
                "name": "setup-vitest",
                "description": "Configure Vitest for unit and integration testing. Use when setting up a test framework, when no test runner is detected, or when the user asks to configure testing.",
                "path": "skills/setup-vitest/SKILL.md",
                "frontmatter": {
                  "name": "setup-vitest",
                  "description": "Configure Vitest for unit and integration testing. Use when setting up a test framework, when no test runner is detected, or when the user asks to configure testing.",
                  "allowed-tools": "Read, Write, Edit, Bash, Glob, Grep"
                },
                "content": "# Setup Vitest\n\nConfigure Vitest as the unit and integration test framework with Testing Library integration.\n\n## When to Use This Skill\n\n- No test framework is configured in the project\n- User requests to set up unit testing\n- Migrating from Jest to Vitest\n- Setting up a new project that needs testing\n\n## Installation\n\nUse `ni` to auto-detect the package manager:\n\n```bash\n# Core Vitest packages\nni -D vitest @vitest/ui @vitest/coverage-v8\n\n# For React projects\nni -D @testing-library/react @testing-library/dom @testing-library/user-event @testing-library/jest-dom\n\n# For Vue projects\nni -D @testing-library/vue @testing-library/dom @testing-library/user-event @testing-library/jest-dom\n\n# For Svelte projects\nni -D @testing-library/svelte @testing-library/dom @testing-library/user-event @testing-library/jest-dom\n```\n\n## Configuration\n\n### vitest.config.ts\n\nCreate or update `vitest.config.ts` at the project root:\n\n```typescript\nimport { defineConfig } from 'vitest/config'\nimport react from '@vitejs/plugin-react' // For React projects\n\nexport default defineConfig({\n  plugins: [react()], // Add framework plugin as needed\n  test: {\n    // Test file patterns\n    include: ['**/*.{test,spec}.{js,ts,jsx,tsx}'],\n    exclude: ['**/node_modules/**', '**/dist/**', '**/e2e/**'],\n\n    // Environment - use 'jsdom' or 'happy-dom' for DOM testing\n    environment: 'jsdom',\n\n    // Enable global test APIs (describe, it, expect)\n    globals: true,\n\n    // Setup files run before each test file\n    setupFiles: ['./tests/setup.ts'],\n\n    // Mock behavior\n    clearMocks: true,\n    restoreMocks: true,\n\n    // Coverage configuration\n    coverage: {\n      provider: 'v8',\n      reporter: ['text', 'json', 'html', 'lcov'],\n      reportsDirectory: './coverage',\n      include: ['src/**/*.{ts,tsx}'],\n      exclude: [\n        '**/*.test.{ts,tsx}',\n        '**/*.spec.{ts,tsx}',\n        '**/*.d.ts',\n        '**/types/**',\n      ],\n      thresholds: {\n        lines: 80,\n        functions: 80,\n        branches: 80,\n        statements: 80,\n      },\n    },\n\n    // Timeouts\n    testTimeout: 5000,\n    hookTimeout: 10000,\n  },\n})\n```\n\n### TypeScript Configuration\n\nAdd Vitest types to `tsconfig.json`:\n\n```json\n{\n  \"compilerOptions\": {\n    \"types\": [\"vitest/globals\"]\n  }\n}\n```\n\n### Setup File\n\nCreate `tests/setup.ts` for global test configuration:\n\n```typescript\nimport '@testing-library/jest-dom/vitest'\nimport { cleanup } from '@testing-library/react'\nimport { afterEach, vi } from 'vitest'\n\n// Cleanup after each test\nafterEach(() => {\n  cleanup()\n})\n\n// Mock window.matchMedia (common requirement)\nObject.defineProperty(window, 'matchMedia', {\n  writable: true,\n  value: vi.fn().mockImplementation((query: string) => ({\n    matches: false,\n    media: query,\n    onchange: null,\n    addListener: vi.fn(),\n    removeListener: vi.fn(),\n    addEventListener: vi.fn(),\n    removeEventListener: vi.fn(),\n    dispatchEvent: vi.fn(),\n  })),\n})\n```\n\n### Package.json Scripts\n\nAdd test scripts to the **workspace** package.json (where the code lives):\n\n```json\n{\n  \"scripts\": {\n    \"test\": \"vitest\",\n    \"test:run\": \"vitest run\",\n    \"test:ui\": \"vitest --ui\",\n    \"test:coverage\": \"vitest run --coverage\"\n  }\n}\n```\n\n## Monorepo Configuration\n\nFor monorepo projects (Turborepo, Nx, Lerna, etc.), additional setup is required.\n\n### 1. Check Project State\n\nRead `.claude/marathon-ralph.json` to get the project configuration:\n- `project.monorepo.type` - The monorepo type (turbo, nx, lerna, etc.)\n- `project.packageManager` - The package manager (bun, pnpm, yarn, npm)\n\n### 2. Turborepo Setup\n\nIf using Turborepo (`turbo.json` exists), add the test task to the pipeline:\n\n**turbo.json:**\n```json\n{\n  \"$schema\": \"https://turbo.build/schema.json\",\n  \"pipeline\": {\n    \"test\": {\n      \"dependsOn\": [\"^build\"],\n      \"outputs\": [],\n      \"cache\": false\n    },\n    \"test:run\": {\n      \"dependsOn\": [\"^build\"],\n      \"outputs\": [],\n      \"cache\": false\n    }\n  }\n}\n```\n\n**Root package.json - add script to run tests across all workspaces:**\n```json\n{\n  \"scripts\": {\n    \"test\": \"turbo run test\",\n    \"test:run\": \"turbo run test:run\"\n  }\n}\n```\n\n### 3. pnpm Workspaces Setup\n\nFor pnpm workspaces without Turborepo:\n\n**Root package.json:**\n```json\n{\n  \"scripts\": {\n    \"test\": \"pnpm -r test\",\n    \"test:run\": \"pnpm -r test:run\"\n  }\n}\n```\n\n### 4. npm/yarn Workspaces Setup\n\nFor npm or yarn workspaces:\n\n**Root package.json:**\n```json\n{\n  \"scripts\": {\n    \"test\": \"npm run test --workspaces\",\n    \"test:run\": \"npm run test:run --workspaces\"\n  }\n}\n```\n\n### 5. Workspace-Specific Testing\n\nTo run tests for a specific workspace, use the package manager's filter:\n\n```bash\n# Turborepo + bun\nbun run --filter=web test\n\n# pnpm\npnpm --filter web test\n\n# npm workspaces\nnpm run test --workspace=web\n```\n\n## Writing Tests\n\n### Query Priority (Most Accessible First)\n\nFollow Testing Library's query priority:\n\n1. **`getByRole`** - Best choice, tests accessibility\n2. **`getByLabelText`** - For form fields\n3. **`getByPlaceholderText`** - If no label available\n4. **`getByText`** - For non-interactive elements\n5. **`getByDisplayValue`** - For filled form values\n6. **`getByAltText`** - For images\n7. **`getByTitle`** - Rarely needed\n8. **`getByTestId`** - Last resort only\n\n### Example Test\n\n```typescript\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { describe, it, expect, vi } from 'vitest'\nimport { LoginForm } from './LoginForm'\n\ndescribe('LoginForm', () => {\n  it('submits with valid credentials', async () => {\n    const user = userEvent.setup()\n    const onSubmit = vi.fn()\n\n    render(<LoginForm onSubmit={onSubmit} />)\n\n    // Use accessible queries\n    await user.type(screen.getByLabelText(/email/i), 'user@example.com')\n    await user.type(screen.getByLabelText(/password/i), 'password123')\n    await user.click(screen.getByRole('button', { name: /sign in/i }))\n\n    expect(onSubmit).toHaveBeenCalledWith({\n      email: 'user@example.com',\n      password: 'password123',\n    })\n  })\n\n  it('shows error for invalid email', async () => {\n    const user = userEvent.setup()\n    render(<LoginForm onSubmit={vi.fn()} />)\n\n    await user.type(screen.getByLabelText(/email/i), 'invalid')\n    await user.click(screen.getByRole('button', { name: /sign in/i }))\n\n    expect(screen.getByRole('alert')).toHaveTextContent(/valid email/i)\n  })\n})\n```\n\n## Testing Philosophy\n\nFollow Kent C. Dodds' testing principles:\n\n### DO\n\n- Test user behavior, not implementation details\n- Use `screen` for all queries\n- Prefer `getByRole` with accessible names\n- Use `userEvent` over `fireEvent`\n- Use `findBy*` for async elements\n- Use `queryBy*` ONLY for asserting non-existence\n\n### DON'T\n\n- Test internal state or methods\n- Use `container.querySelector`\n- Use test IDs when better queries exist\n- Add unnecessary accessibility attributes\n- Mock everything (test real behavior where possible)\n\n## Mocking\n\n### Mock Functions\n\n```typescript\nimport { vi } from 'vitest'\n\nconst mockFn = vi.fn()\nmockFn.mockReturnValue('value')\nmockFn.mockResolvedValue('async value')\n```\n\n### Mock Modules\n\n```typescript\n// Automatic mock\nvi.mock('./api')\n\n// Manual mock with factory\nvi.mock('./api', () => ({\n  fetchUser: vi.fn(() => ({ id: 1, name: 'Test' })),\n}))\n\n// Partial mock\nvi.mock('./utils', async (importOriginal) => {\n  const actual = await importOriginal()\n  return {\n    ...actual,\n    specificFunction: vi.fn(),\n  }\n})\n```\n\n## Verification\n\nAfter setup, verify with:\n\n```bash\n# Run tests\nnr test\n\n# Run with coverage\nnr test:coverage\n\n# Open UI mode\nnr test:ui\n```\n\n## Directory Structure\n\n```\nproject/\n├── src/\n│   ├── components/\n│   │   ├── Button.tsx\n│   │   └── Button.test.tsx    # Colocated tests\n│   └── utils/\n│       ├── helpers.ts\n│       └── helpers.test.ts\n├── tests/\n│   └── setup.ts               # Global setup\n├── vitest.config.ts\n└── package.json\n```"
              },
              {
                "name": "update-state",
                "description": "Programmatically update marathon-ralph state file using deterministic jq commands. Use this instead of manually editing the JSON file.",
                "path": "skills/update-state/SKILL.md",
                "frontmatter": {
                  "name": "update-state",
                  "description": "Programmatically update marathon-ralph state file using deterministic jq commands. Use this instead of manually editing the JSON file.",
                  "allowed-tools": "Bash"
                },
                "content": "# Update Marathon State\n\nThis skill provides deterministic state file updates using jq. **Always use this skill instead of manually editing `.claude/marathon-ralph.json`.**\n\n## Why Use This Skill\n\n- **Deterministic**: jq commands are atomic and predictable\n- **Zero token overhead**: Script executes without loading into context\n- **Consistent**: Same operation always produces same result\n- **Safe**: Prevents malformed JSON from manual edits\n\n## Available Commands\n\n### Complete an Issue\n\nMarks an issue as done: increments completed count, decrements todo, clears current_issue.\n\n```bash\nbash \"${CLAUDE_PLUGIN_ROOT}/skills/update-state/scripts/update-state.sh\" complete-issue\n```\n\n### Start an Issue\n\nSets the current issue being worked on.\n\n```bash\nbash \"${CLAUDE_PLUGIN_ROOT}/skills/update-state/scripts/update-state.sh\" start-issue \"<issue_id>\" \"<issue_title>\"\n```\n\n### Set Phase\n\nUpdates the marathon phase (setup, init, coding, complete).\n\n```bash\nbash \"${CLAUDE_PLUGIN_ROOT}/skills/update-state/scripts/update-state.sh\" set-phase \"<phase>\"\n```\n\n### Mark Complete\n\nMarks the entire marathon as complete (sets active=false, phase=complete).\n\n```bash\nbash \"${CLAUDE_PLUGIN_ROOT}/skills/update-state/scripts/update-state.sh\" mark-complete\n```\n\n### Update Stats\n\nManually update the stats object.\n\n```bash\nbash \"${CLAUDE_PLUGIN_ROOT}/skills/update-state/scripts/update-state.sh\" update-stats <completed> <in_progress> <todo>\n```\n\n### Clear Session\n\nClears the session_id (used when --force takeover is needed).\n\n```bash\nbash \"${CLAUDE_PLUGIN_ROOT}/skills/update-state/scripts/update-state.sh\" clear-session\n```\n\n### Reset Iterations\n\nResets the stop_hook_iterations counter to 0.\n\n```bash\nbash \"${CLAUDE_PLUGIN_ROOT}/skills/update-state/scripts/update-state.sh\" reset-iterations\n```\n\n## Failure Tracking Commands\n\nThese commands support the circuit breaker system that prevents infinite loops.\n\n### Initialize Failure Tracking\n\nSets up the failure tracking structure with default limits.\n\n```bash\nbash \"${CLAUDE_PLUGIN_ROOT}/skills/update-state/scripts/update-state.sh\" init-failure-tracking\n```\n\n### Increment Phase Attempt\n\nIncrements the attempt counter for a specific phase of an issue.\n\n```bash\nbash \"${CLAUDE_PLUGIN_ROOT}/skills/update-state/scripts/update-state.sh\" increment-phase-attempt \"<issue_id>\" \"<phase>\"\n```\n\nExample:\n\n```bash\nbash \"${CLAUDE_PLUGIN_ROOT}/skills/update-state/scripts/update-state.sh\" increment-phase-attempt \"GRU-220\" \"qa\"\n```\n\n### Get Phase Attempts\n\nReturns the current attempt count for a phase.\n\n```bash\nbash \"${CLAUDE_PLUGIN_ROOT}/skills/update-state/scripts/update-state.sh\" get-phase-attempts \"<issue_id>\" \"<phase>\"\n```\n\nReturns a number (e.g., \"3\").\n\n### Record Error\n\nRecords an error with signature detection for repeated error tracking.\n\n```bash\nbash \"${CLAUDE_PLUGIN_ROOT}/skills/update-state/scripts/update-state.sh\" record-error \"<issue_id>\" \"<phase>\" \"[error_message]\"\n```\n\nThe script normalizes the error message and creates a signature to detect if the same error is repeating.\n\n### Skip Phase\n\nMarks a phase as skipped with a reason.\n\n```bash\nbash \"${CLAUDE_PLUGIN_ROOT}/skills/update-state/scripts/update-state.sh\" skip-phase \"<issue_id>\" \"<phase>\" \"[reason]\"\n```\n\nExample:\n\n```bash\nbash \"${CLAUDE_PLUGIN_ROOT}/skills/update-state/scripts/update-state.sh\" skip-phase \"GRU-220\" \"qa\" \"oRPC detected - REST URL mocking incompatible\"\n```\n\n### Skip Issue\n\nSkips an entire issue with a reason.\n\n```bash\nbash \"${CLAUDE_PLUGIN_ROOT}/skills/update-state/scripts/update-state.sh\" skip-issue \"<issue_id>\" \"[reason]\"\n```\n\n### Reset Issue Tracking\n\nResets all failure tracking for a specific issue.\n\n```bash\nbash \"${CLAUDE_PLUGIN_ROOT}/skills/update-state/scripts/update-state.sh\" reset-issue-tracking \"<issue_id>\"\n```\n\n### Reset on Success\n\nResets global failure counters after successful issue completion.\n\n```bash\nbash \"${CLAUDE_PLUGIN_ROOT}/skills/update-state/scripts/update-state.sh\" reset-on-success\n```\n\nThis resets:\n\n- consecutive_failures to 0\n- repeated_error_count to 0\n- last_failure_signature to null\n- stop_hook_iterations to 0\n\n### Get Skipped Phases\n\nReturns the list of skipped phases for an issue.\n\n```bash\nbash \"${CLAUDE_PLUGIN_ROOT}/skills/update-state/scripts/update-state.sh\" get-skipped-phases \"<issue_id>\"\n```\n\nReturns a JSON array like:\n\n```json\n[{\"phase\": \"qa\", \"reason\": \"oRPC detected\", \"timestamp\": \"2024-01-15T10:30:00.000Z\"}]\n```\n\n### Check Limits\n\nChecks if any failure limits have been exceeded.\n\n```bash\nbash \"${CLAUDE_PLUGIN_ROOT}/skills/update-state/scripts/update-state.sh\" check-limits \"<issue_id>\" \"[phase]\"\n```\n\nReturns JSON with limit status:\n\n```json\n{\n  \"issue_id\": \"GRU-220\",\n  \"should_skip_issue\": false,\n  \"should_abort\": false,\n  \"same_error_repeating\": false,\n  \"should_skip_phase\": false,\n  \"phase_attempts\": 2,\n  \"max_phase_attempts\": 5,\n  \"issue_attempts\": 3,\n  \"max_issue_attempts\": 5,\n  \"consecutive_failures\": 1,\n  \"repeated_errors\": 1\n}\n```\n\n## Default Failure Limits\n\n| Limit | Default | Description |\n|-------|---------|-------------|\n| max_phase_attempts.verify | 3 | Max attempts for verify phase |\n| max_phase_attempts.plan | 3 | Max attempts for plan phase |\n| max_phase_attempts.code | 3 | Max attempts for code phase |\n| max_phase_attempts.test | 5 | Max attempts for test phase |\n| max_phase_attempts.qa | 5 | Max attempts for QA phase |\n| max_issue_attempts | 5 | Max total attempts per issue |\n| max_consecutive_failures | 5 | Max failures before aborting marathon |\n| max_repeated_errors | 3 | Max same error before skipping |\n| max_stop_hook_iterations | 25 | Max stop hook cycles |\n\n## Usage Examples\n\nAfter completing the verify-plan-code-test-qa cycle for an issue:\n\n```bash\n# Mark the issue complete in state file\nbash \"${CLAUDE_PLUGIN_ROOT}/skills/update-state/scripts/update-state.sh\" complete-issue\n```\n\nWhen starting work on a new issue:\n\n```bash\n# Set current issue\nbash \"${CLAUDE_PLUGIN_ROOT}/skills/update-state/scripts/update-state.sh\" start-issue \"GRU-220\" \"Step 5: Toggle Completion\"\n```\n\nWhen all issues are done:\n\n```bash\n# Mark marathon complete\nbash \"${CLAUDE_PLUGIN_ROOT}/skills/update-state/scripts/update-state.sh\" mark-complete\n```\n\n## State File Location\n\nThe script uses `${CLAUDE_PROJECT_DIR:-.}/.claude/marathon-ralph.json`\n\n## Exit Codes\n\n- `0`: Success\n- `1`: Invalid arguments or missing state file\n- `2`: jq command failed"
              },
              {
                "name": "visual-verification",
                "description": "Visually verify implemented features work correctly before marking complete. Use when testing UI changes, verifying web features, or checking user flows work in the browser.",
                "path": "skills/visual-verification/SKILL.md",
                "frontmatter": {
                  "name": "visual-verification",
                  "description": "Visually verify implemented features work correctly before marking complete. Use when testing UI changes, verifying web features, or checking user flows work in the browser."
                },
                "content": "# Visual Verification\n\nVerify implemented features work correctly through actual user interaction, not just automated tests.\n\n## When to Use\n\n- After implementing any UI feature\n- Before marking an issue as complete\n- When acceptance criteria involve user-visible behavior\n- After fixing UI bugs\n\n## Approaches\n\n**Web Applications**: See [browser-verification.md](browser-verification.md) for Playwright MCP workflow.\n\n**Mobile Applications**: See [mobile-verification.md](mobile-verification.md) *(Coming soon)*\n\n## Verification Checklist\n\nBefore marking any UI task complete:\n\n- [ ] Dev server is running and accessible\n- [ ] Feature renders without console errors\n- [ ] Elements render correctly and do not incorrectly overlap\n- [ ] User interactions work as expected\n- [ ] Edge cases handled (empty states, loading, errors)\n- [ ] Screenshot captured as evidence\n\n## What NOT to Do\n\n- Skip visual verification because \"tests pass\"\n- Mark issues complete without browser testing\n- Assume dev mode catches all errors (run `npm run build` too)\n- Test only happy paths"
              },
              {
                "name": "write-playwright-test",
                "description": "Write Playwright E2E tests using fixtures and best practices. Use when creating E2E tests, writing browser automation tests, or testing user flows.",
                "path": "skills/write-playwright-test/SKILL.md",
                "frontmatter": {
                  "name": "write-playwright-test",
                  "description": "Write Playwright E2E tests using fixtures and best practices. Use when creating E2E tests, writing browser automation tests, or testing user flows.",
                  "allowed-tools": "Read, Write, Edit, Bash, Glob, Grep"
                },
                "content": "# Write Playwright Tests\n\nWrite end-to-end tests using Playwright fixtures, Page Object Model, and accessibility-first queries.\n\n## Core Principles\n\nFollow Kent C. Dodds' testing philosophy:\n\n> \"The more your tests resemble the way your software is used, the more confidence they can give you.\"\n\n### Test User Behavior, Not Implementation\n\n- Test what users see and do\n- Avoid testing internal state or methods\n- Focus on outcomes, not mechanisms\n\n## Query Priority (Accessibility-First)\n\nUse queries in this order of preference:\n\n### 1. Role Queries (Best)\n\n```typescript\n// Buttons, links, headings\nawait page.getByRole('button', { name: /submit/i })\nawait page.getByRole('link', { name: /home/i })\nawait page.getByRole('heading', { level: 1 })\n\n// Form elements\nawait page.getByRole('textbox', { name: /email/i })\nawait page.getByRole('checkbox', { name: /remember me/i })\nawait page.getByRole('combobox', { name: /country/i })\n\n// With state\nawait page.getByRole('checkbox', { checked: true })\nawait page.getByRole('tab', { selected: true })\n```\n\n### 2. Label Queries (Forms)\n\n```typescript\nawait page.getByLabel(/email address/i)\nawait page.getByLabel(/password/i)\nawait page.getByLabel(/phone number/i)\n```\n\n### 3. Text Queries (Content)\n\n```typescript\nawait page.getByText(/welcome back/i)\nawait page.getByText('Exact Match')\n```\n\n### 4. Placeholder Queries (Fallback)\n\n```typescript\nawait page.getByPlaceholder('Search...')\n```\n\n### 5. Test ID (Last Resort)\n\n```typescript\n// Only when no accessible alternative exists\nawait page.getByTestId('complex-widget')\n```\n\n## Fixtures\n\n### Why Use Fixtures?\n\n- **Encapsulation**: Setup and teardown in one place\n- **Reusability**: Share across all tests\n- **Isolation**: Fresh state per test\n- **Auto-cleanup**: Teardown runs automatically\n\n### Basic Custom Fixture\n\n```typescript\n// tests/e2e/fixtures/test-fixtures.ts\nimport { test as base } from '@playwright/test'\n\ntype MyFixtures = {\n  testUser: { email: string; password: string }\n}\n\nexport const test = base.extend<MyFixtures>({\n  testUser: async ({}, use) => {\n    // Setup: Create test data\n    const user = {\n      email: `test-${Date.now()}@example.com`,\n      password: 'TestPassword123!',\n    }\n\n    // Provide to test\n    await use(user)\n\n    // Teardown: Cleanup (runs after test)\n    // await deleteUser(user.email)\n  },\n})\n\nexport { expect } from '@playwright/test'\n```\n\n### Authentication Fixture\n\n```typescript\n// tests/e2e/fixtures/auth-fixtures.ts\nimport { test as base, type Page } from '@playwright/test'\n\ntype AuthFixtures = {\n  authenticatedPage: Page\n}\n\nexport const test = base.extend<AuthFixtures>({\n  authenticatedPage: async ({ page }, use) => {\n    // Login before test\n    await page.goto('/login')\n    await page.getByLabel(/email/i).fill('user@example.com')\n    await page.getByLabel(/password/i).fill('password123')\n    await page.getByRole('button', { name: /sign in/i }).click()\n    await page.waitForURL('/dashboard')\n\n    // Provide authenticated page\n    await use(page)\n\n    // Logout after test (optional)\n    // await page.goto('/logout')\n  },\n})\n```\n\n### Database Fixture with Cleanup\n\n```typescript\n// tests/e2e/fixtures/db-fixtures.ts\nimport { test as base } from '@playwright/test'\n\ntype DbFixtures = {\n  insertTestData: (data: TestData) => Promise<string>\n}\n\nexport const test = base.extend<DbFixtures>({\n  insertTestData: async ({ request }, use) => {\n    const createdIds: string[] = []\n\n    // Provide factory function\n    await use(async (data) => {\n      const response = await request.post('/api/test-data', { data })\n      const { id } = await response.json()\n      createdIds.push(id)\n      return id\n    })\n\n    // Cleanup all created data\n    for (const id of createdIds) {\n      await request.delete(`/api/test-data/${id}`)\n    }\n  },\n})\n```\n\n### Worker-Scoped Fixture (Shared Across Tests)\n\n```typescript\n// tests/e2e/fixtures/worker-fixtures.ts\nimport { test as base } from '@playwright/test'\n\ntype WorkerFixtures = {\n  sharedAccount: { username: string; token: string }\n}\n\nexport const test = base.extend<{}, WorkerFixtures>({\n  sharedAccount: [\n    async ({ browser }, use, workerInfo) => {\n      // Create unique account per worker\n      const username = `worker-${workerInfo.workerIndex}`\n\n      // Setup runs once per worker\n      const page = await browser.newPage()\n      await page.goto('/signup')\n      // ... create account ...\n      await page.close()\n\n      await use({ username, token: 'token' })\n\n      // Teardown when worker shuts down\n      // await deleteAccount(username)\n    },\n    { scope: 'worker' },\n  ],\n})\n```\n\n### Combining Multiple Fixtures\n\n```typescript\n// tests/e2e/fixtures/index.ts\nimport { mergeTests } from '@playwright/test'\nimport { test as authTest } from './auth-fixtures'\nimport { test as dbTest } from './db-fixtures'\nimport { test as pageTest } from './page-fixtures'\n\nexport const test = mergeTests(authTest, dbTest, pageTest)\nexport { expect } from '@playwright/test'\n```\n\n## Page Object Model\n\n### Page Object Structure\n\n```typescript\n// tests/e2e/pages/checkout.page.ts\nimport { type Page, type Locator, expect } from '@playwright/test'\n\nexport class CheckoutPage {\n  readonly page: Page\n\n  // Locators\n  readonly cartItems: Locator\n  readonly subtotal: Locator\n  readonly checkoutButton: Locator\n  readonly promoCodeInput: Locator\n  readonly applyPromoButton: Locator\n  readonly errorMessage: Locator\n\n  constructor(page: Page) {\n    this.page = page\n    this.cartItems = page.getByRole('list', { name: /cart items/i })\n    this.subtotal = page.getByTestId('subtotal')\n    this.checkoutButton = page.getByRole('button', { name: /checkout/i })\n    this.promoCodeInput = page.getByLabel(/promo code/i)\n    this.applyPromoButton = page.getByRole('button', { name: /apply/i })\n    this.errorMessage = page.getByRole('alert')\n  }\n\n  async goto() {\n    await this.page.goto('/checkout')\n  }\n\n  async applyPromoCode(code: string) {\n    await this.promoCodeInput.fill(code)\n    await this.applyPromoButton.click()\n  }\n\n  async proceedToCheckout() {\n    await this.checkoutButton.click()\n  }\n\n  async expectItemCount(count: number) {\n    await expect(this.cartItems.getByRole('listitem')).toHaveCount(count)\n  }\n\n  async expectSubtotal(amount: string) {\n    await expect(this.subtotal).toHaveText(amount)\n  }\n}\n```\n\n### Using Page Objects with Fixtures\n\n```typescript\n// tests/e2e/fixtures/page-fixtures.ts\nimport { test as base } from '@playwright/test'\nimport { CheckoutPage } from '../pages/checkout.page'\nimport { LoginPage } from '../pages/login.page'\n\ntype PageFixtures = {\n  checkoutPage: CheckoutPage\n  loginPage: LoginPage\n}\n\nexport const test = base.extend<PageFixtures>({\n  checkoutPage: async ({ page }, use) => {\n    await use(new CheckoutPage(page))\n  },\n\n  loginPage: async ({ page }, use) => {\n    await use(new LoginPage(page))\n  },\n})\n```\n\n## Writing Tests\n\n### Basic Test Structure\n\n```typescript\n// tests/e2e/checkout.spec.ts\nimport { test, expect } from './fixtures'\n\ntest.describe('Checkout Flow', () => {\n  test('user can complete purchase', async ({ page, checkoutPage }) => {\n    // Given: User has items in cart\n    await checkoutPage.goto()\n    await checkoutPage.expectItemCount(2)\n\n    // When: User proceeds to checkout\n    await checkoutPage.proceedToCheckout()\n\n    // Then: User sees payment form\n    await expect(page).toHaveURL('/payment')\n    await expect(\n      page.getByRole('heading', { name: /payment/i })\n    ).toBeVisible()\n  })\n\n  test('user can apply valid promo code', async ({ checkoutPage }) => {\n    await checkoutPage.goto()\n\n    await checkoutPage.applyPromoCode('SAVE20')\n\n    await expect(\n      checkoutPage.page.getByText(/20% discount applied/i)\n    ).toBeVisible()\n  })\n\n  test('user sees error for invalid promo code', async ({ checkoutPage }) => {\n    await checkoutPage.goto()\n\n    await checkoutPage.applyPromoCode('INVALID')\n\n    await expect(checkoutPage.errorMessage).toHaveText(/invalid promo code/i)\n  })\n})\n```\n\n### Test with Authentication Fixture\n\n```typescript\nimport { test, expect } from './fixtures'\n\ntest.describe('Dashboard', () => {\n  test('authenticated user sees dashboard', async ({ authenticatedPage }) => {\n    await authenticatedPage.goto('/dashboard')\n\n    await expect(\n      authenticatedPage.getByRole('heading', { name: /dashboard/i })\n    ).toBeVisible()\n    await expect(\n      authenticatedPage.getByText(/welcome back/i)\n    ).toBeVisible()\n  })\n})\n```\n\n### Test with Data Fixture\n\n```typescript\nimport { test, expect } from './fixtures'\n\ntest.describe('Products', () => {\n  test('user can view product details', async ({ page, insertTestData }) => {\n    // Create test product (auto-cleaned up after test)\n    const productId = await insertTestData({\n      name: 'Test Product',\n      price: 99.99,\n    })\n\n    await page.goto(`/products/${productId}`)\n\n    await expect(page.getByRole('heading')).toHaveText('Test Product')\n    await expect(page.getByText('$99.99')).toBeVisible()\n  })\n})\n```\n\n## Web-First Assertions\n\nAlways use web-first assertions that auto-wait:\n\n```typescript\n// GOOD - Auto-waits and retries\nawait expect(page.getByText('Success')).toBeVisible()\nawait expect(page.getByRole('button')).toBeEnabled()\nawait expect(page).toHaveURL('/dashboard')\nawait expect(page).toHaveTitle(/Dashboard/)\n\n// BAD - Manual check, no retry\nconst isVisible = await page.getByText('Success').isVisible()\nexpect(isVisible).toBe(true)\n```\n\n### Common Assertions\n\n```typescript\n// Visibility\nawait expect(locator).toBeVisible()\nawait expect(locator).toBeHidden()\n\n// Text content\nawait expect(locator).toHaveText('exact text')\nawait expect(locator).toContainText('partial')\n\n// Attributes\nawait expect(locator).toHaveAttribute('href', '/path')\nawait expect(locator).toHaveClass(/active/)\n\n// Form state\nawait expect(locator).toBeEnabled()\nawait expect(locator).toBeDisabled()\nawait expect(locator).toBeChecked()\nawait expect(locator).toHaveValue('input value')\n\n// Count\nawait expect(locator).toHaveCount(5)\n\n// Page\nawait expect(page).toHaveURL('/path')\nawait expect(page).toHaveTitle('Page Title')\n```\n\n## Soft Assertions\n\nContinue test even if assertion fails:\n\n```typescript\ntest('multiple checks', async ({ page }) => {\n  await page.goto('/dashboard')\n\n  // Soft assertions don't stop the test\n  await expect.soft(page.getByTestId('status')).toHaveText('Active')\n  await expect.soft(page.getByTestId('count')).toHaveText('10')\n\n  // Test continues even if above fail\n  await page.getByRole('link', { name: /settings/i }).click()\n})\n```\n\n## Common Patterns\n\n### Wait for Network\n\n```typescript\n// Wait for specific API response\nawait page.goto('/dashboard')\nawait page.waitForResponse((response) =>\n  response.url().includes('/api/data') && response.status() === 200\n)\n```\n\n### File Upload\n\n```typescript\nconst fileInput = page.getByLabel(/upload file/i)\nawait fileInput.setInputFiles('./test-data/file.pdf')\n```\n\n### Handling Dialogs\n\n```typescript\npage.on('dialog', (dialog) => dialog.accept())\nawait page.getByRole('button', { name: /delete/i }).click()\n```\n\n### Screenshot on Specific Step\n\n```typescript\nawait page.goto('/dashboard')\nawait page.screenshot({ path: 'dashboard.png' })\n```\n\n## What NOT to Do\n\n- **DON'T** use `page.locator('.class-name')` - prefer role/label queries\n- **DON'T** use `page.waitForTimeout(1000)` - use web-first assertions\n- **DON'T** test implementation details - test user behavior\n- **DON'T** repeat login flow in every test - use fixtures\n- **DON'T** hardcode test data - generate unique data\n- **DON'T** skip error scenarios - test unhappy paths\n\n## Test Organization\n\n```\ntests/e2e/\n├── fixtures/\n│   ├── index.ts              # Combined fixtures export\n│   ├── auth-fixtures.ts      # Authentication\n│   ├── db-fixtures.ts        # Database operations\n│   └── page-fixtures.ts      # Page objects\n├── pages/\n│   ├── login.page.ts\n│   ├── dashboard.page.ts\n│   └── checkout.page.ts\n├── auth.setup.ts             # Auth setup project\n├── auth.spec.ts              # Auth tests (one login flow)\n├── dashboard.spec.ts\n├── checkout.spec.ts\n└── search.spec.ts\n```\n\n## Tips for Reliable Tests\n\n1. **Use unique test data** - Avoid conflicts between parallel tests\n2. **Clean up after tests** - Use fixture teardown\n3. **Wait for stability** - Use web-first assertions\n4. **Isolate tests** - Each test should work independently\n5. **Test one thing** - Keep tests focused\n6. **Use descriptive names** - `user can complete checkout` not `test1`"
              }
            ]
          }
        ]
      }
    }
  ]
}