{
  "owner": {
    "id": "SSiertsema",
    "display_name": "sven-siertsema",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/9604824?v=4",
    "url": "https://github.com/SSiertsema",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 14,
      "total_commands": 12,
      "total_skills": 1,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "SSiertsema/claude-code-plugins",
      "url": "https://github.com/SSiertsema/claude-code-plugins",
      "description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-12-15T20:31:45Z",
        "created_at": "2025-11-29T16:44:48Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 3465
        },
        {
          "path": ".devcontainer",
          "type": "tree",
          "size": null
        },
        {
          "path": ".devcontainer/devcontainer.json",
          "type": "blob",
          "size": 1587
        },
        {
          "path": ".devcontainer/setup.sh",
          "type": "blob",
          "size": 710
        },
        {
          "path": "CLAUDE.md",
          "type": "blob",
          "size": 2053
        },
        {
          "path": "agent-meeting-room",
          "type": "tree",
          "size": null
        },
        {
          "path": "agent-meeting-room/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "agent-meeting-room/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 387
        },
        {
          "path": "agent-meeting-room/README.md",
          "type": "blob",
          "size": 2141
        },
        {
          "path": "agent-meeting-room/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "agent-meeting-room/hooks/hooks.json",
          "type": "blob",
          "size": 1249
        },
        {
          "path": "agent-meeting-room/hooks/post-tool-use.sh",
          "type": "blob",
          "size": 1088
        },
        {
          "path": "agent-meeting-room/hooks/pre-compact.sh",
          "type": "blob",
          "size": 461
        },
        {
          "path": "agent-meeting-room/hooks/pre-tool-use.sh",
          "type": "blob",
          "size": 3295
        },
        {
          "path": "agent-meeting-room/hooks/session-end.sh",
          "type": "blob",
          "size": 524
        },
        {
          "path": "agent-meeting-room/hooks/session-start.sh",
          "type": "blob",
          "size": 953
        },
        {
          "path": "agent-meeting-room/hooks/stop.sh",
          "type": "blob",
          "size": 5405
        },
        {
          "path": "agent-meeting-room/hooks/subagent-stop.sh",
          "type": "blob",
          "size": 6548
        },
        {
          "path": "agent-meeting-room/hooks/user-prompt-required.sh",
          "type": "blob",
          "size": 1257
        },
        {
          "path": "agent-meeting-room/hooks/user-prompt-submit.sh",
          "type": "blob",
          "size": 3180
        },
        {
          "path": "documentation-generator",
          "type": "tree",
          "size": null
        },
        {
          "path": "documentation-generator/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "documentation-generator/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 409
        },
        {
          "path": "documentation-generator/README.md",
          "type": "blob",
          "size": 2492
        },
        {
          "path": "documentation-generator/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "documentation-generator/commands/generate-docs.md",
          "type": "blob",
          "size": 4007
        },
        {
          "path": "documentation-generator/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "documentation-generator/templates/api-reference.md",
          "type": "blob",
          "size": 2260
        },
        {
          "path": "documentation-generator/templates/architecture.md",
          "type": "blob",
          "size": 2269
        },
        {
          "path": "documentation-generator/templates/changelog.md",
          "type": "blob",
          "size": 1485
        },
        {
          "path": "documentation-generator/templates/configuration.md",
          "type": "blob",
          "size": 3978
        },
        {
          "path": "documentation-generator/templates/contributing.md",
          "type": "blob",
          "size": 3492
        },
        {
          "path": "documentation-generator/templates/data-models.md",
          "type": "blob",
          "size": 1997
        },
        {
          "path": "documentation-generator/templates/deployment.md",
          "type": "blob",
          "size": 2980
        },
        {
          "path": "documentation-generator/templates/development-setup.md",
          "type": "blob",
          "size": 2577
        },
        {
          "path": "documentation-generator/templates/security.md",
          "type": "blob",
          "size": 3038
        },
        {
          "path": "documentation-generator/templates/testing.md",
          "type": "blob",
          "size": 3018
        },
        {
          "path": "documentation-generator/templates/troubleshooting.md",
          "type": "blob",
          "size": 4294
        },
        {
          "path": "functional-specifications",
          "type": "tree",
          "size": null
        },
        {
          "path": "functional-specifications/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "functional-specifications/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 491
        },
        {
          "path": "functional-specifications/README.md",
          "type": "blob",
          "size": 3993
        },
        {
          "path": "functional-specifications/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "functional-specifications/commands/generate-functional-specifications.md",
          "type": "blob",
          "size": 8675
        },
        {
          "path": "functional-specifications/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "functional-specifications/templates/functional-specifications-template.md",
          "type": "blob",
          "size": 4422
        },
        {
          "path": "git-commit",
          "type": "tree",
          "size": null
        },
        {
          "path": "git-commit/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "git-commit/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 365
        },
        {
          "path": "git-commit/README.md",
          "type": "blob",
          "size": 1599
        },
        {
          "path": "git-commit/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "git-commit/commands/commit.md",
          "type": "blob",
          "size": 2908
        },
        {
          "path": "js-refactor-logic",
          "type": "tree",
          "size": null
        },
        {
          "path": "js-refactor-logic/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "js-refactor-logic/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 402
        },
        {
          "path": "js-refactor-logic/README.md",
          "type": "blob",
          "size": 1542
        },
        {
          "path": "js-refactor-logic/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "js-refactor-logic/commands/refactor.md",
          "type": "blob",
          "size": 8420
        },
        {
          "path": "ncsc-security-audit",
          "type": "tree",
          "size": null
        },
        {
          "path": "ncsc-security-audit/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "ncsc-security-audit/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 431
        },
        {
          "path": "ncsc-security-audit/README.md",
          "type": "blob",
          "size": 7162
        },
        {
          "path": "ncsc-security-audit/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "ncsc-security-audit/commands/ncsc-security-audit.md",
          "type": "blob",
          "size": 7247
        },
        {
          "path": "ncsc-security-audit/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "ncsc-security-audit/templates/ncsc-guidelines.md",
          "type": "blob",
          "size": 22329
        },
        {
          "path": "ncsc-security-audit/templates/stakeholder-report.md",
          "type": "blob",
          "size": 8652
        },
        {
          "path": "ncsc-security-audit/templates/technical-report.md",
          "type": "blob",
          "size": 7939
        },
        {
          "path": "owasp-security-audit",
          "type": "tree",
          "size": null
        },
        {
          "path": "owasp-security-audit/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "owasp-security-audit/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 401
        },
        {
          "path": "owasp-security-audit/README.md",
          "type": "blob",
          "size": 5095
        },
        {
          "path": "owasp-security-audit/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "owasp-security-audit/commands/owasp-security-audit.md",
          "type": "blob",
          "size": 12531
        },
        {
          "path": "owasp-security-audit/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "owasp-security-audit/templates/owasp-guidelines.md",
          "type": "blob",
          "size": 12592
        },
        {
          "path": "owasp-security-audit/templates/stakeholder-report.md",
          "type": "blob",
          "size": 6224
        },
        {
          "path": "owasp-security-audit/templates/technical-report.md",
          "type": "blob",
          "size": 4662
        },
        {
          "path": "package-lock.json",
          "type": "blob",
          "size": 98
        },
        {
          "path": "persona-generator",
          "type": "tree",
          "size": null
        },
        {
          "path": "persona-generator/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "persona-generator/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 400
        },
        {
          "path": "persona-generator/README.md",
          "type": "blob",
          "size": 4534
        },
        {
          "path": "persona-generator/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "persona-generator/commands/generate-personas.md",
          "type": "blob",
          "size": 11555
        },
        {
          "path": "persona-generator/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "persona-generator/templates/persona-template.md",
          "type": "blob",
          "size": 3950
        },
        {
          "path": "qa-checklist.md",
          "type": "blob",
          "size": 3360
        },
        {
          "path": "technical-specifications",
          "type": "tree",
          "size": null
        },
        {
          "path": "technical-specifications/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "technical-specifications/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 421
        },
        {
          "path": "technical-specifications/README.md",
          "type": "blob",
          "size": 2274
        },
        {
          "path": "technical-specifications/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "technical-specifications/commands/refine-technical-specifications.md",
          "type": "blob",
          "size": 7086
        },
        {
          "path": "technical-specifications/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "technical-specifications/templates/technical-specifications-template.md",
          "type": "blob",
          "size": 4443
        },
        {
          "path": "ts-refactor-logic",
          "type": "tree",
          "size": null
        },
        {
          "path": "ts-refactor-logic/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "ts-refactor-logic/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 403
        },
        {
          "path": "ts-refactor-logic/README.md",
          "type": "blob",
          "size": 1868
        },
        {
          "path": "ts-refactor-logic/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "ts-refactor-logic/commands/refactor.md",
          "type": "blob",
          "size": 10285
        },
        {
          "path": "user-story-generator",
          "type": "tree",
          "size": null
        },
        {
          "path": "user-story-generator/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "user-story-generator/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 405
        },
        {
          "path": "user-story-generator/README.md",
          "type": "blob",
          "size": 3857
        },
        {
          "path": "user-story-generator/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "user-story-generator/commands/generate-user-stories.md",
          "type": "blob",
          "size": 8905
        },
        {
          "path": "user-story-generator/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "user-story-generator/templates/epic.md",
          "type": "blob",
          "size": 2216
        },
        {
          "path": "user-story-generator/templates/persona-extraction.md",
          "type": "blob",
          "size": 4029
        },
        {
          "path": "user-story-generator/templates/spec-analysis.md",
          "type": "blob",
          "size": 6277
        },
        {
          "path": "user-story-generator/templates/user-story.md",
          "type": "blob",
          "size": 2696
        },
        {
          "path": "vue-development-skill",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-development-skill/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-development-skill/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 412
        },
        {
          "path": "vue-development-skill/README.md",
          "type": "blob",
          "size": 6915
        },
        {
          "path": "vue-development-skill/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-development-skill/skills/vue-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-development-skill/skills/vue-development/SKILL.md",
          "type": "blob",
          "size": 11461
        },
        {
          "path": "vue-development-skill/skills/vue-development/debugging",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-development-skill/skills/vue-development/debugging/common-issues.md",
          "type": "blob",
          "size": 8260
        },
        {
          "path": "vue-development-skill/skills/vue-development/e2e",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-development-skill/skills/vue-development/e2e/acceptance-criteria.md",
          "type": "blob",
          "size": 7768
        },
        {
          "path": "vue-development-skill/skills/vue-development/e2e/playwright-patterns.md",
          "type": "blob",
          "size": 10169
        },
        {
          "path": "vue-development-skill/skills/vue-development/patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-development-skill/skills/vue-development/patterns/composition-api.md",
          "type": "blob",
          "size": 8424
        },
        {
          "path": "vue-development-skill/skills/vue-development/patterns/nuxt3.md",
          "type": "blob",
          "size": 8943
        },
        {
          "path": "vue-development-skill/skills/vue-development/patterns/typescript.md",
          "type": "blob",
          "size": 8435
        },
        {
          "path": "vue-development-skill/skills/vue-development/qa",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-development-skill/skills/vue-development/qa/report-template.json",
          "type": "blob",
          "size": 7868
        },
        {
          "path": "vue-development-skill/skills/vue-development/qa/vue-checklist.md",
          "type": "blob",
          "size": 5356
        },
        {
          "path": "vue-development-skill/skills/vue-development/tdd",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-development-skill/skills/vue-development/tdd/testing-patterns.md",
          "type": "blob",
          "size": 8928
        },
        {
          "path": "vue-development-skill/skills/vue-development/tdd/workflow.md",
          "type": "blob",
          "size": 6586
        },
        {
          "path": "vue-refactor-logic",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-refactor-logic/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-refactor-logic/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 412
        },
        {
          "path": "vue-refactor-logic/README.md",
          "type": "blob",
          "size": 2536
        },
        {
          "path": "vue-refactor-logic/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-refactor-logic/commands/refactor.md",
          "type": "blob",
          "size": 11301
        },
        {
          "path": "vue-reorder",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-reorder/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-reorder/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 398
        },
        {
          "path": "vue-reorder/README.md",
          "type": "blob",
          "size": 2024
        },
        {
          "path": "vue-reorder/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-reorder/commands/reorder.md",
          "type": "blob",
          "size": 6520
        }
      ],
      "marketplace": {
        "name": "svens-claude-plugins",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "Sven Siertsema"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "agent-meeting-room",
            "description": "Tracks Claude Code sessions and agent processes in the Agent Meeting Room system",
            "source": "./agent-meeting-room",
            "category": "integration",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add SSiertsema/claude-code-plugins",
              "/plugin install agent-meeting-room@svens-claude-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-15T20:31:45Z",
              "created_at": "2025-11-29T16:44:48Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "documentation-generator",
            "description": "Generate comprehensive project documentation through interactive dialog with templates",
            "source": "./documentation-generator",
            "category": "productivity",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add SSiertsema/claude-code-plugins",
              "/plugin install documentation-generator@svens-claude-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-15T20:31:45Z",
              "created_at": "2025-11-29T16:44:48Z",
              "license": null
            },
            "commands": [
              {
                "name": "/generate-docs",
                "description": "Generate comprehensive project documentation through interactive dialog",
                "path": "documentation-generator/commands/generate-docs.md",
                "frontmatter": {
                  "description": "Generate comprehensive project documentation through interactive dialog"
                },
                "content": "You are a documentation generator assistant. Your task is to help create comprehensive project documentation through an interactive dialog.\n\n## Phase 1: Project Analysis\n\nFirst, analyze the codebase to understand what exists:\n\n1. **Check for existing documentation**:\n   - Look for a `documentation/` folder\n   - Check for README.md, CONTRIBUTING.md, or other docs in the root\n   - Note what documentation already exists\n\n2. **Identify project type and structure**:\n   - Check package.json, Cargo.toml, go.mod, requirements.txt, etc. for project type\n   - Look for common patterns: src/, lib/, api/, tests/, etc.\n   - Identify the primary language and framework\n\n3. **Detect what components exist**:\n   - API routes (Express, FastAPI, etc.)\n   - Database/ORM (Prisma, TypeORM, SQLAlchemy, etc.)\n   - Deployment config (Dockerfile, kubernetes/, .github/workflows/)\n   - Test setup (jest.config, pytest.ini, etc.)\n   - Environment config (.env.example, config/)\n\n## Phase 2: Documentation Proposal\n\nBased on your analysis, propose which documentation files make sense for this project. Use the templates in `${CLAUDE_PLUGIN_ROOT}/templates/` as reference for available categories:\n\n| Template | Propose when... |\n|----------|----------------|\n| architecture.md | Always - every project benefits from architectural overview |\n| api-reference.md | Project has API routes, REST endpoints, or GraphQL |\n| data-models.md | Project has database, ORM, or significant data structures |\n| development-setup.md | Always - helps onboarding new developers |\n| testing.md | Project has test files or test configuration |\n| deployment.md | Project has Dockerfile, CI/CD, or deployment configs |\n| contributing.md | Open source project or team collaboration expected |\n| security.md | Project handles auth, sensitive data, or external APIs |\n| troubleshooting.md | Complex project with potential failure modes |\n| configuration.md | Project has environment variables or config files |\n| changelog.md | Project needs version tracking |\n\nPresent your proposal with reasoning:\n```\nBased on my analysis of your project, I recommend creating these documentation files:\n\n**Recommended:**\n- architecture.md - [reason based on what you found]\n- development-setup.md - [reason]\n- [other relevant docs]\n\n**Optional (you may want to consider):**\n- [docs that might be useful but aren't essential]\n\n**Not applicable:**\n- [docs that don't make sense for this project, e.g., \"api-reference.md - no API endpoints found\"]\n```\n\n## Phase 3: User Dialog\n\nAsk the user for feedback:\n- Do they want to add any documentation from the \"optional\" or \"not applicable\" lists?\n- Do they want to remove any from the recommended list?\n- Are there any specific aspects they want documented?\n\nContinue the dialog until the user approves the final list.\n\n## Phase 4: Documentation Generation\n\nFor each approved documentation file:\n\n1. **Read the template** from `${CLAUDE_PLUGIN_ROOT}/templates/[filename].md`\n2. **Analyze the codebase** to gather information for each section\n3. **Generate content** following the template structure\n4. **Handle existing docs** with smart merge:\n   - If the file exists in `documentation/`, read it first\n   - Preserve custom sections not in the template\n   - Update sections that appear outdated (reference removed files, old APIs, etc.)\n   - Add missing sections from the template\n   - Show the user what will change before writing\n\n5. **Write to `documentation/`** folder in the project root\n\n## Important Guidelines\n\n- Use the templates as structural guides, but adapt content to what actually exists\n- Be thorough in your codebase analysis - read key files to understand the architecture\n- When merging with existing docs, be conservative - preserve user content when in doubt\n- Ask clarifying questions if you're unsure about project specifics\n- Generate documentation that is specific and useful, not generic boilerplate"
              }
            ],
            "skills": []
          },
          {
            "name": "git-commit",
            "description": "Streamlined git commit and push with auto-generated commit messages",
            "source": "./git-commit",
            "category": "productivity",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add SSiertsema/claude-code-plugins",
              "/plugin install git-commit@svens-claude-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-15T20:31:45Z",
              "created_at": "2025-11-29T16:44:48Z",
              "license": null
            },
            "commands": [
              {
                "name": "/commit",
                "description": "Commit and push changes with auto-generated commit messages",
                "path": "git-commit/commands/commit.md",
                "frontmatter": {
                  "description": "Commit and push changes with auto-generated commit messages"
                },
                "content": "You are a git commit assistant. Your task is to commit and push changes efficiently.\n\n## Mode Detection\n\nCheck the command arguments:\n- No arguments or `--auto`: **Auto mode** (default) - commit and push immediately\n- `--safe`: **Safe mode** - interactive approval flow\n\nAlso check environment variable `CLAUDE_COMMIT_MODE` if no flag provided:\n- `auto` (default): Auto mode\n- `safe`: Safe mode\n\n## Step 1: Analyze Changes\n\nRun these commands to understand what will be committed:\n\n```bash\ngit status\ngit diff --staged\ngit diff\ngit log --oneline -5\n```\n\n## Step 2: Safety Checks\n\nBefore proceeding, verify:\n\n1. **No secrets**: Skip files that look like secrets:\n   - `.env`, `.env.*` (except `.env.example`)\n   - `*credentials*`, `*secrets*`, `*.pem`, `*.key`\n   - If found, warn the user and exclude from commit\n\n2. **Branch check**: Note if on `main` or `master` branch (will warn before push)\n\n3. **No changes**: If nothing to commit, inform user and stop\n\n## Step 3: Generate Commit Message\n\nAnalyze the changes and generate a commit message:\n\n1. Look at recent commits (`git log --oneline -5`) to match the repository's style\n2. If no clear style, use conventional commits format:\n   - `feat:` - New feature\n   - `fix:` - Bug fix\n   - `docs:` - Documentation changes\n   - `refactor:` - Code refactoring\n   - `test:` - Test changes\n   - `chore:` - Maintenance tasks\n\n3. Keep the message concise but descriptive (1-2 sentences)\n4. Focus on the \"why\" not just the \"what\"\n\n## Step 4: Execute Based on Mode\n\n### Auto Mode (default)\n\n1. Stage all changes:\n   ```bash\n   git add -A\n   ```\n\n2. Commit with generated message (include Claude Code footer):\n   ```bash\n   git commit -m \"$(cat <<'EOF'\n   [Your commit message here]\n\n   ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)\n\n   Co-Authored-By: Claude <noreply@anthropic.com>\n   EOF\n   )\"\n   ```\n\n3. Check if on main/master and warn briefly, then push:\n   ```bash\n   git push\n   ```\n\n4. Report success:\n   ```\n   âœ“ Committed and pushed: [short hash] [message summary]\n   ```\n\n### Safe Mode (`--safe`)\n\n1. Show the user what will be committed:\n   ```\n   Files to be committed:\n   - modified: file1.ts\n   - new file: file2.ts\n   - deleted: file3.ts\n   ```\n\n2. Present the proposed commit message:\n   ```\n   Proposed commit message:\n\n   feat: Add user authentication flow\n\n   Would you like to commit with this message?\n   ```\n\n3. Use AskUserQuestion to get approval or edits\n\n4. After commit, ask: \"Push to remote?\" before pushing\n\n## Important Guidelines\n\n- **Never force push** (`git push --force` is forbidden)\n- **Never skip hooks** (no `--no-verify`)\n- **Never amend** unless explicitly asked\n- If push fails (e.g., remote has new commits), inform the user and suggest `git pull --rebase`\n- If there are merge conflicts, stop and explain the situation"
              }
            ],
            "skills": []
          },
          {
            "name": "vue-reorder",
            "description": "Refactor Vue 3 SFCs for readability: reorder sections, organize script, improve naming",
            "source": "./vue-reorder",
            "category": "vue",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add SSiertsema/claude-code-plugins",
              "/plugin install vue-reorder@svens-claude-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-15T20:31:45Z",
              "created_at": "2025-11-29T16:44:48Z",
              "license": null
            },
            "commands": [
              {
                "name": "/reorder",
                "description": "Refactor Vue 3 SFC for readability - reorder sections, organize script, improve naming",
                "path": "vue-reorder/commands/reorder.md",
                "frontmatter": {
                  "description": "Refactor Vue 3 SFC for readability - reorder sections, organize script, improve naming"
                },
                "content": "You are a Vue.js refactoring assistant. Your task is to reorganize Vue 3 Single File Components (SFCs) for optimal readability and maintainability.\n\n## Step 1: Identify Target File\n\n1. Check if a `.vue` file is currently open in the editor\n2. If yes, propose to refactor that file\n3. If no file is open or user provides a path argument, use that instead\n4. Validate the file:\n   - Must be a `.vue` file\n   - Must use Composition API (`<script setup>`)\n   - If Options API detected, inform user this command only supports Composition API\n\n## Step 2: Read and Analyze\n\nRead the file and analyze:\n- Current order of SFC sections (template/script/style)\n- Script content organization\n- Variable and function naming\n- File name vs component purpose\n\n## Step 3: Plan Refactoring\n\n### Section Order (enforce this order):\n1. `<template>`\n2. `<script setup>` (add `lang=\"ts\"` if TypeScript is used)\n3. `<style scoped>` (add `scoped` if not present)\n\n### Script Organization (enforce this order):\n1. **Imports** - External packages first (vue, vue-router, pinia), then internal (@/, ../)\n2. **Props & Emits** - `defineProps()`, `defineEmits()`, `defineModel()`, `defineExpose()`\n3. **Injections** - `inject()`, composables (`useRouter()`, `useStore()`, custom `use*`)\n4. **Reactive State** - `ref()`, `reactive()`, `shallowRef()`, `shallowReactive()`\n5. **Computed** - `computed()` properties\n6. **Functions** - Helper functions and event handlers\n7. **Watchers** - `watch()`, `watchEffect()`, `watchPostEffect()`\n8. **Lifecycle** - `onBeforeMount()`, `onMounted()`, `onBeforeUpdate()`, `onUpdated()`, `onBeforeUnmount()`, `onUnmounted()`\n\n### Naming Conventions:\n- **File name**: PascalCase matching component purpose (e.g., `UserProfile.vue`)\n- **Variables/refs**: camelCase, descriptive (e.g., `userData`, `selectedItem`)\n- **Boolean refs**: prefix with is/has/can/should (e.g., `isLoading`, `hasError`, `canSubmit`)\n- **Functions**: camelCase with verb prefix:\n  - Event handlers: `handle*` or `on*` (e.g., `handleClick`, `onSubmit`)\n  - Data fetching: `fetch*`, `load*`, `get*` (e.g., `fetchUsers`, `loadData`)\n  - State changes: `set*`, `update*`, `toggle*` (e.g., `setActive`, `toggleMenu`)\n  - Async operations: consider `async` prefix clarity (e.g., `async function fetchData()`)\n- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_ITEMS`, `API_BASE_URL`)\n- **Composables**: `use*` prefix (e.g., `useAuth`, `useFormValidation`)\n\n### Comments:\n- Do NOT add routine section comments like \"// Imports\" or \"// State\"\n- Only add comments when:\n  - Logic is complex and not self-evident\n  - Something important needs highlighting\n  - Functions/variables are exported for use by others\n\n## Step 4: Present Changes\n\nShow the user:\n\n1. **Issues Found** - List what needs improvement:\n   ```\n   Issues found:\n   - Section order: script before template (should be template â†’ script â†’ style)\n   - Variable 'x' has unclear name (suggest: 'items' or more descriptive)\n   - Function 'load' should have verb prefix (suggest: 'fetchData' or 'loadItems')\n   - Style tag missing 'scoped' attribute\n   ```\n\n2. **Proposed Changes** - Show the refactored code or a diff\n\n3. **File Rename** - If applicable:\n   ```\n   Suggested file rename: myComponent.vue â†’ UserDashboard.vue\n   (to match PascalCase convention and component purpose)\n   ```\n\n## Step 5: Apply Changes\n\nApply all changes automatically:\n1. Reorder SFC sections (template â†’ script â†’ style)\n2. Reorganize script content according to the ordering convention\n3. Apply naming improvements\n4. Rename file if needed (ensure imports in other files are updated if possible)\n\n## Step 6: Report Completion\n\nAfter applying changes, report:\n```\nâœ“ Refactored: ComponentName.vue\n  - Reordered sections: template â†’ script â†’ style\n  - Reorganized script content\n  - Renamed 3 variables, 2 functions\n  - File renamed: oldName.vue â†’ NewName.vue (if applicable)\n```\n\n## Important Guidelines\n\n- **Preserve functionality** - Never change logic, only organization and naming\n- **Preserve comments** - Keep existing meaningful comments, move them with their code\n- **Preserve formatting** - Match existing indentation style (spaces/tabs)\n- **Be conservative with naming** - Only suggest renames for clearly problematic names\n- **Don't over-engineer** - If the file is already well-organized, say so and suggest minor improvements only\n\n## Verification Checklist (MANDATORY)\n\n**IMPORTANT: You MUST complete this checklist before finishing. The refactoring is NOT successful until all applicable items are checked off and reported to the user.**\n\nBefore completing, verify each item has been addressed:\n\n### File & Validation\n- [ ] Target `.vue` file identified (open file or user-specified path)\n- [ ] File uses Composition API (`<script setup>`) - not Options API\n- [ ] File has been read and analyzed\n\n### Section Order\n- [ ] `<template>` is first section\n- [ ] `<script setup>` is second section\n- [ ] `<style>` is last section\n- [ ] `scoped` attribute added to `<style>` if missing\n\n### Script Organization\n- [ ] Imports are at the top (external before internal)\n- [ ] Props/Emits (`defineProps`, `defineEmits`, `defineModel`) follow imports\n- [ ] Composables and injections follow props/emits\n- [ ] Reactive state (`ref`, `reactive`) follows injections\n- [ ] Computed properties follow reactive state\n- [ ] Functions follow computed\n- [ ] Watchers follow functions\n- [ ] Lifecycle hooks are at the end\n\n### Naming Conventions\n- [ ] File name is PascalCase (or rename suggested)\n- [ ] Variables use camelCase\n- [ ] Boolean refs have is/has/can/should prefix\n- [ ] Functions have appropriate verb prefix (handle/fetch/toggle/etc.)\n- [ ] Constants use UPPER_SNAKE_CASE\n\n### Completion\n- [ ] Changes applied successfully\n- [ ] Summary of changes reported\n- [ ] Completed checklist shown\n\n**You MUST show the completed checklist to the user with [x] for completed items and [ ] for skipped items (with explanation).**\n\nExample output:\n```\nVerification Checklist:\n[x] Target file identified: UserList.vue\n[x] Composition API confirmed\n[x] File analyzed\n[x] Template is first section\n[x] Script is second section\n[x] Style is last section\n[x] Scoped attribute added\n[x] Imports organized\n[x] Props/Emits in correct position\n[ ] No composables/injections present (skipped)\n[x] Reactive state organized\n...\n```\n\nThe refactoring is only complete when this checklist is shown to the user."
              }
            ],
            "skills": []
          },
          {
            "name": "js-refactor-logic",
            "description": "Refactor JavaScript logic: code splitting, design patterns, ES6+ modernization",
            "source": "./js-refactor-logic",
            "category": "javascript",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add SSiertsema/claude-code-plugins",
              "/plugin install js-refactor-logic@svens-claude-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-15T20:31:45Z",
              "created_at": "2025-11-29T16:44:48Z",
              "license": null
            },
            "commands": [
              {
                "name": "/refactor",
                "description": "Refactor JavaScript logic - code splitting, patterns, ES6+ modernization",
                "path": "js-refactor-logic/commands/refactor.md",
                "frontmatter": {
                  "description": "Refactor JavaScript logic - code splitting, patterns, ES6+ modernization"
                },
                "content": "You are a JavaScript refactoring assistant. Your task is to autonomously refactor JavaScript code for improved readability, maintainability, and modern best practices.\n\n## Step 1: Identify Target File\n\n1. Check if a `.js` or `.jsx` file is currently open in the editor\n2. If yes, use that file\n3. If no file is open or user provides a path argument, use that instead\n4. Validate the file is JavaScript (`.js` or `.jsx`)\n\n## Step 2: Analyze Code\n\nAnalyze the entire file for:\n\n### Code Splitting Issues\n- Functions exceeding 50 lines\n- Cyclomatic complexity > 10 (many conditionals/branches)\n- Nesting depth > 3 levels\n- Functions with > 4 parameters\n- Duplicate code patterns (2+ occurrences)\n\n### Anti-Patterns\n- Magic numbers/strings (unnamed constants)\n- Missing error handling in async code\n- Callback hell / Promise chains that could use async/await\n- Deep nesting instead of guard clauses\n- Long switch statements without abstraction\n\n### Modernization Opportunities\n- `var` declarations (should be `const`/`let`)\n- `.then()/.catch()` chains (should be async/await)\n- Old-style functions where arrow functions fit better\n- Missing destructuring opportunities\n- Missing spread operator usage\n\n## Step 3: Plan Refactoring\n\nFor each issue found, apply the appropriate resolution technique:\n\n---\n\n### Resolving High Cyclomatic Complexity (> 10)\n\n**Technique A: Extract Conditional Logic to Lookup Object**\n```javascript\n// BEFORE: complexity = 12\nfunction process(data) {\n  if (data.type === 'A') { /* 20 lines */ }\n  else if (data.type === 'B') { /* 20 lines */ }\n  else if (data.type === 'C') { /* 20 lines */ }\n}\n\n// AFTER: complexity = 3 per function\nconst processors = {\n  A: processTypeA,\n  B: processTypeB,\n  C: processTypeC\n}\nfunction process(data) {\n  return processors[data.type]?.(data)\n}\n```\n\n**Technique B: Strategy Pattern for Conditionals**\n```javascript\n// BEFORE\nfunction calculatePrice(item) {\n  if (item.type === 'book') return item.price * 0.9\n  if (item.type === 'electronics') return item.price * 1.1\n}\n\n// AFTER\nconst pricingStrategies = {\n  book: (item) => item.price * 0.9,\n  electronics: (item) => item.price * 1.1\n}\nconst calculatePrice = (item) => pricingStrategies[item.type](item)\n```\n\n**Technique C: Decompose Boolean Expressions**\n```javascript\n// BEFORE\nif (user.age > 18 && user.hasLicense && !user.isSuspended && user.balance > 0) {}\n\n// AFTER\nconst isEligibleDriver = (user) =>\n  user.age > 18 && user.hasLicense && !user.isSuspended && user.balance > 0\n\nif (isEligibleDriver(user)) {}\n```\n\n---\n\n### Resolving Deep Nesting (> 3 levels)\n\n**Technique A: Guard Clauses (Early Returns)**\n```javascript\n// BEFORE: 4 levels deep\nfunction process(data) {\n  if (data) {\n    if (data.isValid) {\n      if (data.items.length > 0) {\n        if (data.status === 'active') {\n          // actual logic\n        }\n      }\n    }\n  }\n}\n\n// AFTER: 0 levels deep\nfunction process(data) {\n  if (!data) return\n  if (!data.isValid) return\n  if (data.items.length === 0) return\n  if (data.status !== 'active') return\n\n  // actual logic\n}\n```\n\n**Technique B: Extract Nested Blocks**\n```javascript\n// BEFORE\nfunction handleOrder(order) {\n  if (order.isPaid) {\n    if (order.items.length > 0) {\n      for (const item of order.items) {\n        if (item.inStock) { /* complex */ }\n      }\n    }\n  }\n}\n\n// AFTER\nfunction handleOrder(order) {\n  if (!order.isPaid || order.items.length === 0) return\n  order.items.filter(item => item.inStock).forEach(processItem)\n}\n```\n\n**Technique C: Use Array Methods**\n```javascript\n// BEFORE: nested loops\nfor (const user of users) {\n  for (const order of user.orders) {\n    if (order.status === 'pending') { /* process */ }\n  }\n}\n\n// AFTER: flat\nusers\n  .flatMap(user => user.orders)\n  .filter(order => order.status === 'pending')\n  .forEach(processOrder)\n```\n\n---\n\n### Resolving Long Functions (> 50 lines)\n\n**Technique A: Extract by Responsibility**\n```javascript\n// BEFORE: 100 line function\nfunction submitForm(data) {\n  // validation (20 lines)\n  // formatting (15 lines)\n  // API call (25 lines)\n  // UI update (20 lines)\n}\n\n// AFTER: focused functions\nfunction submitForm(data) {\n  const errors = validateFormData(data)\n  if (errors.length) return handleErrors(errors)\n\n  const formatted = formatFormData(data)\n  const result = await sendToApi(formatted)\n  updateUI(result)\n}\n```\n\n**Technique B: Extract Setup/Teardown**\n```javascript\n// AFTER\nfunction processData() {\n  const context = setupProcessing()\n  try {\n    return executeProcessing(context)\n  } finally {\n    cleanupProcessing(context)\n  }\n}\n```\n\n---\n\n### Resolving Too Many Parameters (> 4)\n\n**Technique: Object Parameter Pattern**\n```javascript\n// BEFORE\nfunction createUser(name, email, age, role, department, manager, startDate) {}\n\n// AFTER\nfunction createUser({ name, email, age, role, department, manager, startDate }) {}\n\ncreateUser({ name: 'John', email: 'john@example.com', role: 'developer' })\n```\n\n---\n\n### Resolving Duplicate Code\n\n**Technique: Extract and Parameterize**\n```javascript\n// BEFORE: duplicated\nfunction fetchUsers() {\n  setLoading(true)\n  const data = await api.get('/users')\n  setLoading(false)\n  return data\n}\nfunction fetchProducts() {\n  setLoading(true)\n  const data = await api.get('/products')\n  setLoading(false)\n  return data\n}\n\n// AFTER: parameterized\nasync function fetchData(endpoint) {\n  setLoading(true)\n  try { return await api.get(endpoint) }\n  finally { setLoading(false) }\n}\nconst fetchUsers = () => fetchData('/users')\nconst fetchProducts = () => fetchData('/products')\n```\n\n---\n\n### File Extraction\nWhen extracting to new files, analyze the project structure:\n- Look for existing `utils/`, `helpers/`, `lib/` folders\n- If none exist, propose creating in appropriate location\n- Keep related utilities together\n\n## Step 4: Apply Changes\n\nApply all refactoring changes:\n\n1. Extract long functions into smaller pieces\n2. Apply guard clauses to reduce nesting\n3. Convert var to const/let\n4. Convert Promise chains to async/await\n5. Extract magic values to named constants\n6. Add try/catch for unhandled async errors\n7. Create new utility files if needed\n8. Update imports as needed\n\n## Step 5: Report Completion\n\nReport all changes made:\n```\nRefactored: filename.js\n\nChanges applied:\n- Extracted 3 functions from processData (was 120 lines)\n- Converted 5 var declarations to const/let\n- Refactored 2 Promise chains to async/await\n- Added error handling to fetchUser()\n- Extracted magic numbers to constants: MAX_RETRIES, TIMEOUT_MS\n- Created utils/dataHelpers.js with 2 utility functions\n\nNew files created:\n- utils/dataHelpers.js\n```\n\n## Verification Checklist (MANDATORY)\n\n**You MUST complete and display this checklist. The refactoring is NOT complete until shown.**\n\n### Analysis\n- [ ] Target .js/.jsx file identified\n- [ ] Code analyzed for complexity metrics\n- [ ] Anti-patterns identified\n- [ ] Modernization opportunities found\n\n### Code Splitting\n- [ ] Functions > 50 lines: addressed or N/A\n- [ ] Nesting > 3 levels: addressed or N/A\n- [ ] Complexity > 10: addressed or N/A\n- [ ] Parameters > 4: addressed or N/A\n- [ ] Duplicate code: extracted or N/A\n\n### Patterns & Modernization\n- [ ] Guard clauses applied where beneficial\n- [ ] var converted to const/let\n- [ ] Promise chains converted to async/await\n- [ ] Magic values extracted to constants\n- [ ] Error handling added where needed\n\n### File Organization\n- [ ] New files created in appropriate locations\n- [ ] Imports updated correctly\n\n### Completion\n- [ ] All changes applied successfully\n- [ ] Summary reported\n- [ ] This checklist displayed with [x] marks\n\n**Example output:**\n```\nVerification Checklist:\n[x] Target file: src/utils/dataProcessor.js\n[x] Code analyzed\n[x] Anti-patterns found: 3\n[x] Functions > 50 lines: 2 extracted\n[x] Nesting > 3 levels: 1 fixed with guard clauses\n[ ] Complexity > 10: N/A (none found)\n[x] var â†’ const/let: 8 converted\n[x] Promise â†’ async/await: 2 converted\n[x] Error handling added: 1 function\n[x] Changes applied successfully\n```\n\n## Important Guidelines\n\n- **Preserve functionality**: Never change logic, only structure\n- **Preserve tests**: If tests exist, ensure they still pass\n- **Be conservative**: Only refactor clear improvements\n- **Naming matters**: Use descriptive function/variable names\n- **No over-engineering**: Don't add unnecessary abstractions"
              }
            ],
            "skills": []
          },
          {
            "name": "ts-refactor-logic",
            "description": "Refactor TypeScript logic: code splitting, type improvements, design patterns",
            "source": "./ts-refactor-logic",
            "category": "typescript",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add SSiertsema/claude-code-plugins",
              "/plugin install ts-refactor-logic@svens-claude-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-15T20:31:45Z",
              "created_at": "2025-11-29T16:44:48Z",
              "license": null
            },
            "commands": [
              {
                "name": "/refactor",
                "description": "Refactor TypeScript logic - code splitting, type improvements, design patterns",
                "path": "ts-refactor-logic/commands/refactor.md",
                "frontmatter": {
                  "description": "Refactor TypeScript logic - code splitting, type improvements, design patterns"
                },
                "content": "You are a TypeScript refactoring assistant. Your task is to autonomously refactor TypeScript code for improved readability, maintainability, type safety, and best practices.\n\n## Step 1: Identify Target File\n\n1. Check if a `.ts` or `.tsx` file is currently open in the editor\n2. If yes, use that file\n3. If no file is open or user provides a path argument, use that instead\n4. Validate the file is TypeScript (`.ts` or `.tsx`)\n\n## Step 2: Analyze Code\n\nAnalyze the entire file for:\n\n### Code Splitting Issues\n- Functions exceeding 50 lines\n- Cyclomatic complexity > 10 (many conditionals/branches)\n- Nesting depth > 3 levels\n- Functions with > 4 parameters\n- Duplicate code patterns (2+ occurrences)\n\n### Anti-Patterns\n- Magic numbers/strings (unnamed constants)\n- Missing error handling in async code\n- Callback hell / Promise chains that could use async/await\n- Deep nesting instead of guard clauses\n- Long switch statements without abstraction\n\n### Type Issues\n- Use of `any` type\n- Missing return type annotations\n- Missing parameter type annotations\n- Inline object types that should be interfaces\n- Repeated type definitions (should be shared)\n- String literals that should be enums or union types\n- Missing generic types where applicable\n\n## Step 3: Plan Refactoring\n\nFor each issue found, apply the appropriate resolution technique:\n\n---\n\n### Resolving High Cyclomatic Complexity (> 10)\n\n**Technique A: Extract Conditional Logic to Typed Lookup Object**\n```typescript\n// BEFORE: complexity = 12\nfunction process(data: Data): Result {\n  if (data.type === 'A') { /* 20 lines */ }\n  else if (data.type === 'B') { /* 20 lines */ }\n  else if (data.type === 'C') { /* 20 lines */ }\n}\n\n// AFTER: complexity = 3 per function\ntype ProcessorMap = Record<DataType, (data: Data) => Result>\n\nconst processors: ProcessorMap = {\n  A: processTypeA,\n  B: processTypeB,\n  C: processTypeC\n}\n\nfunction process(data: Data): Result | undefined {\n  return processors[data.type]?.(data)\n}\n```\n\n**Technique B: Strategy Pattern with Type Safety**\n```typescript\n// BEFORE\nfunction calculatePrice(item: Item): number {\n  if (item.type === 'book') return item.price * 0.9\n  if (item.type === 'electronics') return item.price * 1.1\n}\n\n// AFTER\ntype PricingStrategy = (item: Item) => number\n\nconst pricingStrategies: Record<ItemType, PricingStrategy> = {\n  book: (item) => item.price * 0.9,\n  electronics: (item) => item.price * 1.1\n}\n\nconst calculatePrice = (item: Item): number => pricingStrategies[item.type](item)\n```\n\n**Technique C: Decompose Boolean Expressions**\n```typescript\n// BEFORE\nif (user.age > 18 && user.hasLicense && !user.isSuspended && user.balance > 0) {}\n\n// AFTER\nconst isEligibleDriver = (user: User): boolean =>\n  user.age > 18 && user.hasLicense && !user.isSuspended && user.balance > 0\n\nif (isEligibleDriver(user)) {}\n```\n\n---\n\n### Resolving Deep Nesting (> 3 levels)\n\n**Technique A: Guard Clauses (Early Returns)**\n```typescript\n// BEFORE: 4 levels deep\nfunction process(data: Data | null): Result | null {\n  if (data) {\n    if (data.isValid) {\n      if (data.items.length > 0) {\n        if (data.status === 'active') {\n          // actual logic\n        }\n      }\n    }\n  }\n}\n\n// AFTER: 0 levels deep\nfunction process(data: Data | null): Result | null {\n  if (!data) return null\n  if (!data.isValid) return null\n  if (data.items.length === 0) return null\n  if (data.status !== 'active') return null\n\n  // actual logic\n}\n```\n\n**Technique B: Extract Nested Blocks**\n```typescript\n// BEFORE\nfunction handleOrder(order: Order): void {\n  if (order.isPaid) {\n    if (order.items.length > 0) {\n      for (const item of order.items) {\n        if (item.inStock) { /* complex */ }\n      }\n    }\n  }\n}\n\n// AFTER\nfunction handleOrder(order: Order): void {\n  if (!order.isPaid || order.items.length === 0) return\n  order.items.filter(item => item.inStock).forEach(processItem)\n}\n\nfunction processItem(item: OrderItem): void {\n  // complex processing - now at top level\n}\n```\n\n**Technique C: Use Array Methods**\n```typescript\n// BEFORE: nested loops\nfor (const user of users) {\n  for (const order of user.orders) {\n    if (order.status === 'pending') { /* process */ }\n  }\n}\n\n// AFTER: flat\nusers\n  .flatMap(user => user.orders)\n  .filter(order => order.status === 'pending')\n  .forEach(processOrder)\n```\n\n---\n\n### Resolving Long Functions (> 50 lines)\n\n**Technique A: Extract by Responsibility**\n```typescript\n// BEFORE: 100 line function\nasync function submitForm(data: FormData): Promise<void> {\n  // validation (20 lines)\n  // formatting (15 lines)\n  // API call (25 lines)\n  // UI update (20 lines)\n}\n\n// AFTER: focused functions\nasync function submitForm(data: FormData): Promise<void> {\n  const errors = validateFormData(data)\n  if (errors.length) return handleErrors(errors)\n\n  const formatted = formatFormData(data)\n  const result = await sendToApi(formatted)\n  updateUI(result)\n}\n```\n\n**Technique B: Extract Setup/Teardown**\n```typescript\n// AFTER\nfunction processData<T>(input: T): Result {\n  const context = setupProcessing(input)\n  try {\n    return executeProcessing(context)\n  } finally {\n    cleanupProcessing(context)\n  }\n}\n```\n\n---\n\n### Resolving Too Many Parameters (> 4)\n\n**Technique: Object Parameter Pattern with Interface**\n```typescript\n// BEFORE\nfunction createUser(name: string, email: string, age: number, role: string, department: string): User {}\n\n// AFTER\ninterface CreateUserParams {\n  name: string\n  email: string\n  age: number\n  role: UserRole\n  department?: string\n}\n\nfunction createUser({ name, email, age, role, department }: CreateUserParams): User {}\n\ncreateUser({ name: 'John', email: 'john@example.com', age: 30, role: 'developer' })\n```\n\n---\n\n### Resolving Duplicate Code\n\n**Technique: Extract and Parameterize with Generics**\n```typescript\n// BEFORE: duplicated\nasync function fetchUsers(): Promise<User[]> {\n  setLoading(true)\n  const data = await api.get('/users')\n  setLoading(false)\n  return data\n}\nasync function fetchProducts(): Promise<Product[]> {\n  setLoading(true)\n  const data = await api.get('/products')\n  setLoading(false)\n  return data\n}\n\n// AFTER: generic parameterized function\nasync function fetchData<T>(endpoint: string): Promise<T> {\n  setLoading(true)\n  try {\n    return await api.get<T>(endpoint)\n  } finally {\n    setLoading(false)\n  }\n}\n\nconst fetchUsers = () => fetchData<User[]>('/users')\nconst fetchProducts = () => fetchData<Product[]>('/products')\n```\n\n---\n\n### Type Improvements\n| Issue | Solution |\n|-------|----------|\n| `any` type | Specific type or `unknown` |\n| Inline object | Interface or type alias |\n| Repeated types | Shared interface/type |\n| String literals | Enum or union type |\n| Missing generics | Add type parameters |\n\n### File Extraction\nWhen extracting to new files, analyze the project structure:\n- Look for existing `utils/`, `helpers/`, `lib/`, `types/` folders\n- If none exist, propose creating in appropriate location\n- Keep related utilities together\n- Create `types.ts` for shared interfaces\n\n## Step 4: Apply Changes\n\nApply all refactoring changes:\n\n1. Extract long functions into smaller pieces\n2. Apply guard clauses to reduce nesting\n3. Replace `any` with specific types\n4. Add missing type annotations\n5. Create interfaces for object types\n6. Convert string literals to enums/unions\n7. Add generics where beneficial\n8. Convert Promise chains to async/await\n9. Extract magic values to typed constants\n10. Add try/catch for unhandled async errors\n11. Create new utility/type files if needed\n12. Update imports as needed\n\n## Step 5: Report Completion\n\nReport all changes made:\n```\nRefactored: filename.ts\n\nChanges applied:\n- Extracted 3 functions from processData (was 120 lines)\n- Replaced 5 `any` types with specific types\n- Created interface UserData for repeated object shape\n- Converted Status string literals to enum\n- Added generics to fetchData<T>()\n- Refactored 2 Promise chains to async/await\n- Added error handling to fetchUser()\n\nNew files created:\n- types/user.ts (UserData, UserStatus interfaces)\n- utils/dataHelpers.ts\n```\n\n## Verification Checklist (MANDATORY)\n\n**You MUST complete and display this checklist. The refactoring is NOT complete until shown.**\n\n### Analysis\n- [ ] Target .ts/.tsx file identified\n- [ ] Code analyzed for complexity metrics\n- [ ] Anti-patterns identified\n- [ ] Type issues identified\n\n### Code Splitting\n- [ ] Functions > 50 lines: addressed or N/A\n- [ ] Nesting > 3 levels: addressed or N/A\n- [ ] Complexity > 10: addressed or N/A\n- [ ] Parameters > 4: addressed or N/A\n- [ ] Duplicate code: extracted or N/A\n\n### Type Improvements\n- [ ] `any` types: replaced or justified\n- [ ] Missing annotations: added\n- [ ] Inline objects: interfaces created\n- [ ] String literals: enums/unions where appropriate\n- [ ] Generics: added where beneficial\n\n### Patterns & Fixes\n- [ ] Guard clauses applied where beneficial\n- [ ] Promise chains converted to async/await\n- [ ] Magic values extracted to constants/enums\n- [ ] Error handling added where needed\n\n### File Organization\n- [ ] New files created in appropriate locations\n- [ ] Types in dedicated files if shared\n- [ ] Imports updated correctly\n\n### Completion\n- [ ] All changes applied successfully\n- [ ] Summary reported\n- [ ] This checklist displayed with [x] marks\n\n**Example output:**\n```\nVerification Checklist:\n[x] Target file: src/services/userService.ts\n[x] Code analyzed\n[x] Type issues found: 8\n[x] Functions > 50 lines: 1 extracted\n[x] any types: 5 replaced with specific types\n[x] Interfaces created: UserData, ApiResponse\n[x] Enum created: UserStatus\n[x] Generics added: fetchData<T>\n[x] Promise â†’ async/await: 3 converted\n[x] New file: types/user.ts\n[x] Changes applied successfully\n```\n\n## Important Guidelines\n\n- **Preserve functionality**: Never change logic, only structure and types\n- **Preserve tests**: If tests exist, ensure they still pass\n- **Be conservative with types**: Don't over-constrain; use `unknown` over `any`\n- **Naming matters**: Use descriptive names for types, interfaces, and functions\n- **No over-engineering**: Don't add unnecessary type complexity\n- **Prefer interfaces**: Use interfaces over type aliases for object shapes (better error messages, extensibility)"
              }
            ],
            "skills": []
          },
          {
            "name": "vue-refactor-logic",
            "description": "Refactor Vue 3 script logic: composables extraction, code splitting, Vue patterns",
            "source": "./vue-refactor-logic",
            "category": "vue",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add SSiertsema/claude-code-plugins",
              "/plugin install vue-refactor-logic@svens-claude-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-15T20:31:45Z",
              "created_at": "2025-11-29T16:44:48Z",
              "license": null
            },
            "commands": [
              {
                "name": "/refactor",
                "description": "Refactor Vue 3 script logic - composables extraction, code splitting, Vue patterns",
                "path": "vue-refactor-logic/commands/refactor.md",
                "frontmatter": {
                  "description": "Refactor Vue 3 script logic - composables extraction, code splitting, Vue patterns"
                },
                "content": "You are a Vue 3 refactoring assistant. Your task is to autonomously refactor Vue component script logic for improved readability, maintainability, and Vue best practices. This focuses on the `<script setup>` section only (use vue-reorder for full SFC restructuring).\n\n## Step 1: Identify Target File\n\n1. Check if a `.vue` file is currently open in the editor\n2. If yes, use that file\n3. If no file is open or user provides a path argument, use that instead\n4. Validate the file is Vue (`.vue`) with Composition API (`<script setup>`)\n5. If Options API detected, inform user this command supports Composition API only\n\n## Step 2: Analyze Script Logic\n\nAnalyze the `<script setup>` section for:\n\n### Code Splitting Issues\n- Functions exceeding 50 lines\n- Cyclomatic complexity > 10 (many conditionals/branches)\n- Nesting depth > 3 levels\n- Functions with > 4 parameters\n- Duplicate code patterns (2+ occurrences)\n\n### Vue Anti-Patterns\n- Direct prop mutation (should emit)\n- Side effects in computed properties (should use watchers)\n- `v-if` and `v-for` on same element (should use computed filter)\n- Missing lifecycle cleanup (onUnmounted)\n- Unhandled async errors in lifecycle hooks\n\n### Extraction Opportunities\n- Reusable stateful logic â†’ Extract to composable\n- Pure utility functions â†’ Extract to utils file\n- Shared state patterns â†’ Suggest Pinia store\n- Complex reactive logic â†’ Extract to composable\n\n### General Issues\n- Magic numbers/strings\n- Missing error handling\n- Callback chains instead of async/await\n\n## Step 3: Plan Refactoring\n\nFor each issue found, apply the appropriate resolution technique:\n\n---\n\n### Resolving High Cyclomatic Complexity (> 10)\n\n**Technique A: Extract Conditional Logic to Composable**\n```typescript\n// BEFORE: complex component logic\n<script setup>\nconst handleAction = (type: string) => {\n  if (type === 'create') { /* 15 lines */ }\n  else if (type === 'update') { /* 15 lines */ }\n  else if (type === 'delete') { /* 15 lines */ }\n}\n</script>\n\n// AFTER: extracted to composable with lookup\n// composables/useActions.ts\nexport function useActions() {\n  const actions = {\n    create: handleCreate,\n    update: handleUpdate,\n    delete: handleDelete\n  }\n\n  const handleAction = (type: ActionType) => actions[type]?.()\n\n  return { handleAction }\n}\n```\n\n**Technique B: Decompose Boolean Expressions**\n```typescript\n// BEFORE\nconst canSubmit = computed(() =>\n  form.name && form.email && !isLoading.value && !hasError.value && isValid.value\n)\n\n// AFTER\nconst hasRequiredFields = computed(() => form.name && form.email)\nconst isReady = computed(() => !isLoading.value && !hasError.value)\nconst canSubmit = computed(() => hasRequiredFields.value && isReady.value && isValid.value)\n```\n\n---\n\n### Resolving Deep Nesting (> 3 levels)\n\n**Technique A: Guard Clauses (Early Returns)**\n```typescript\n// BEFORE: 4 levels deep\nconst processData = (data) => {\n  if (data) {\n    if (data.isValid) {\n      if (data.items.length > 0) {\n        // actual logic\n      }\n    }\n  }\n}\n\n// AFTER: flat with guards\nconst processData = (data) => {\n  if (!data) return\n  if (!data.isValid) return\n  if (data.items.length === 0) return\n\n  // actual logic\n}\n```\n\n**Technique B: Extract to Composable**\n```typescript\n// BEFORE: nested in component\n<script setup>\nonMounted(async () => {\n  if (props.userId) {\n    try {\n      const user = await fetchUser(props.userId)\n      if (user.posts) {\n        for (const post of user.posts) {\n          // process posts\n        }\n      }\n    } catch (e) { /* ... */ }\n  }\n})\n</script>\n\n// AFTER: clean component + composable\n<script setup>\nconst { user, posts, isLoading, error } = useUserData(props.userId)\n</script>\n\n// composables/useUserData.ts - handles complexity internally\n```\n\n**Technique C: Use Array Methods**\n```typescript\n// BEFORE: nested loops in setup\nfor (const category of categories.value) {\n  for (const item of category.items) {\n    if (item.isActive) { /* process */ }\n  }\n}\n\n// AFTER: flat\nconst activeItems = computed(() =>\n  categories.value\n    .flatMap(cat => cat.items)\n    .filter(item => item.isActive)\n)\n```\n\n---\n\n### Resolving Long Functions (> 50 lines)\n\n**Technique A: Extract to Composable by Feature**\n```typescript\n// BEFORE: 100+ line setup\n<script setup>\n// user data logic (30 lines)\n// form validation logic (25 lines)\n// submission logic (25 lines)\n// error handling (20 lines)\n</script>\n\n// AFTER: composed from focused composables\n<script setup>\nconst { user, isLoading } = useUserData(props.userId)\nconst { errors, validate } = useFormValidation(formRules)\nconst { submit, isSubmitting } = useFormSubmission(apiEndpoint)\n</script>\n```\n\n**Technique B: Extract Setup/Teardown Pattern**\n```typescript\n// composables/useEventListener.ts\nexport function useEventListener(target, event, handler) {\n  onMounted(() => target.addEventListener(event, handler))\n  onUnmounted(() => target.removeEventListener(event, handler))\n}\n\n// Usage - clean and reusable\nuseEventListener(window, 'resize', handleResize)\nuseEventListener(document, 'keydown', handleKeydown)\n```\n\n---\n\n### Resolving Too Many Parameters (> 4)\n\n**Technique: Options Object Pattern**\n```typescript\n// BEFORE\nfunction useDataFetcher(url, method, headers, body, timeout, retries) {}\n\n// AFTER\ninterface FetcherOptions {\n  url: string\n  method?: 'GET' | 'POST'\n  headers?: Record<string, string>\n  body?: unknown\n  timeout?: number\n  retries?: number\n}\n\nfunction useDataFetcher(options: FetcherOptions) {\n  const { url, method = 'GET', timeout = 5000 } = options\n  // ...\n}\n```\n\n---\n\n### Resolving Duplicate Code\n\n**Technique: Extract to Composable**\n```typescript\n// BEFORE: duplicated in multiple components\n// ComponentA.vue\nconst isLoading = ref(false)\nconst error = ref(null)\nconst data = ref(null)\nonMounted(async () => {\n  isLoading.value = true\n  try { data.value = await fetchUsers() }\n  catch (e) { error.value = e }\n  finally { isLoading.value = false }\n})\n\n// ComponentB.vue - same pattern for products\n\n// AFTER: single composable\n// composables/useFetch.ts\nexport function useFetch<T>(fetcher: () => Promise<T>) {\n  const isLoading = ref(false)\n  const error = ref<Error | null>(null)\n  const data = ref<T | null>(null)\n\n  const execute = async () => {\n    isLoading.value = true\n    error.value = null\n    try { data.value = await fetcher() }\n    catch (e) { error.value = e as Error }\n    finally { isLoading.value = false }\n  }\n\n  onMounted(execute)\n\n  return { data, isLoading, error, refetch: execute }\n}\n\n// Usage\nconst { data: users, isLoading } = useFetch(fetchUsers)\nconst { data: products } = useFetch(fetchProducts)\n```\n\n---\n\n### Composable Extraction Guidelines\n\nExtract to composable (`composables/useX.ts`) when logic:\n- Uses Vue reactivity (ref, reactive, computed)\n- Uses lifecycle hooks (onMounted, onUnmounted)\n- Uses watchers (watch, watchEffect)\n- Is reusable across components\n- Groups related functionality\n\n**Composable structure:**\n```typescript\n// composables/useExample.ts\nexport function useExample(props) {\n  // Reactive state\n  const data = ref(null)\n\n  // Computed\n  const computed = computed(() => /* ... */)\n\n  // Methods\n  const doSomething = () => { /* ... */ }\n\n  // Lifecycle\n  onMounted(() => { /* ... */ })\n  onUnmounted(() => { /* cleanup */ })\n\n  // Return refs (not values) to maintain reactivity\n  return { data, computed, doSomething }\n}\n```\n\n### Utility Extraction\nExtract to utils (`utils/helpers.ts`) when:\n- Pure function (input â†’ output, no side effects)\n- No Vue reactivity needed\n- Framework-agnostic logic\n\n### Vue Anti-Pattern Fixes\n\n| Anti-Pattern | Fix |\n|--------------|-----|\n| `props.x = value` | `emit('update:x', value)` |\n| Side effect in computed | Move to `watch()` or `watchEffect()` |\n| v-if + v-for together | Use computed to filter first |\n| No cleanup | Add `onUnmounted()` for listeners/timers |\n| Async without catch | Add try/catch with error state |\n\n### File Location\nWhen creating new files, analyze project structure:\n- Look for existing `composables/`, `utils/`, `hooks/` folders\n- Follow existing naming conventions\n- If no convention exists, use `src/composables/` and `src/utils/`\n\n## Step 4: Apply Changes\n\nApply all refactoring changes:\n\n1. Extract reusable logic to composables\n2. Extract pure utilities to utils files\n3. Fix prop mutations â†’ emit pattern\n4. Move computed side effects â†’ watchers\n5. Add lifecycle cleanup (onUnmounted)\n6. Add error handling to async operations\n7. Apply guard clauses for deep nesting\n8. Extract magic values to constants\n9. Update component to use new composables/utils\n10. Update imports\n\n## Step 5: Report Completion\n\nReport all changes made:\n```\nRefactored: ComponentName.vue\n\nChanges applied:\n- Extracted useUserData composable (state + fetch logic)\n- Extracted useFormValidation composable\n- Fixed prop mutation: emit('update:selectedId') instead of direct assignment\n- Moved API call side effect from computed to watchEffect\n- Added onUnmounted cleanup for event listeners\n- Created utils/formatters.ts for pure formatting functions\n\nNew files created:\n- composables/useUserData.ts\n- composables/useFormValidation.ts\n- utils/formatters.ts\n```\n\n## Verification Checklist (MANDATORY)\n\n**You MUST complete and display this checklist. The refactoring is NOT complete until shown.**\n\n### Analysis\n- [ ] Target .vue file identified\n- [ ] Script uses Composition API (`<script setup>`)\n- [ ] Code analyzed for complexity metrics\n- [ ] Vue anti-patterns identified\n- [ ] Extraction opportunities found\n\n### Code Splitting\n- [ ] Functions > 50 lines: addressed or N/A\n- [ ] Nesting > 3 levels: addressed or N/A\n- [ ] Complexity > 10: addressed or N/A\n- [ ] Duplicate code: extracted or N/A\n\n### Vue-Specific Fixes\n- [ ] Prop mutations: fixed or N/A\n- [ ] Computed side effects: moved to watchers or N/A\n- [ ] Lifecycle cleanup: added or N/A\n- [ ] Async error handling: added or N/A\n\n### Extractions\n- [ ] Composables created for reusable stateful logic\n- [ ] Utils created for pure functions\n- [ ] Files in appropriate locations\n- [ ] Imports updated correctly\n\n### Completion\n- [ ] All changes applied successfully\n- [ ] Summary reported\n- [ ] This checklist displayed with [x] marks\n\n**Example output:**\n```\nVerification Checklist:\n[x] Target file: src/components/UserDashboard.vue\n[x] Composition API confirmed\n[x] Code analyzed\n[x] Vue anti-patterns found: 2\n[x] Functions > 50 lines: 1 extracted to composable\n[x] Prop mutation fixed: emit pattern\n[x] Lifecycle cleanup added: onUnmounted for resize listener\n[x] Composable created: useUserData\n[x] Utils created: formatters.ts\n[x] Changes applied successfully\n```\n\n## Important Guidelines\n\n- **Preserve functionality**: Never change logic, only structure\n- **Preserve template**: This command does not modify `<template>` section\n- **Return refs from composables**: Maintain reactivity\n- **Naming conventions**:\n  - Composables: `useXxx` (e.g., `useUserData`, `useFetch`)\n  - Boolean refs: `isXxx`, `hasXxx` (e.g., `isLoading`, `hasError`)\n  - Event handlers: `handleXxx`, `onXxx` (e.g., `handleSubmit`)\n- **No over-extraction**: Don't create composables for single-use logic\n- **Test composables**: Extracted composables should be independently testable"
              }
            ],
            "skills": []
          },
          {
            "name": "vue-development-skill",
            "description": "Vue 3/Nuxt 3 development skill with TDD workflow and QA-first approach. Produces JSON reports for agent handoff.",
            "source": "./vue-development-skill",
            "category": "vue",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add SSiertsema/claude-code-plugins",
              "/plugin install vue-development-skill@svens-claude-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-15T20:31:45Z",
              "created_at": "2025-11-29T16:44:48Z",
              "license": null
            },
            "commands": [],
            "skills": [
              {
                "name": "vue-development",
                "description": "Vue 3 and Nuxt 3 development with TDD workflow, QA gates, and E2E test generation. Enforces unit testing before implementation, generates Playwright E2E tests from Gherkin acceptance criteria, and produces JSON reports.",
                "path": "vue-development-skill/skills/vue-development/SKILL.md",
                "frontmatter": {
                  "name": "vue-development",
                  "description": "Vue 3 and Nuxt 3 development with TDD workflow, QA gates, and E2E test generation. Enforces unit testing before implementation, generates Playwright E2E tests from Gherkin acceptance criteria, and produces JSON reports."
                },
                "content": "# Vue Development Skill\n\nThis skill guides development of Vue 3 and Nuxt 3 applications using a **test-driven development** approach with **quality assurance gates** and **E2E test generation from acceptance criteria**.\n\n## When This Skill Activates\n\nUse this skill when:\n- Creating or modifying `.vue` files\n- Writing composables (`use*.ts`)\n- Working with Nuxt-specific files (`pages/`, `layouts/`, `middleware/`, `composables/`)\n- User mentions Vue, Nuxt, or component development\n- Building reactive UI components\n- **Implementing user stories with Gherkin acceptance criteria**\n\n## Core Workflow: TDD + QA + E2E\n\n**ALWAYS follow this workflow:**\n\n```\n1. UNDERSTAND  â†’ Parse user story + Gherkin acceptance criteria\n2. TEST FIRST  â†’ Write failing unit tests (Vitest + Vue Test Utils)\n3. IMPLEMENT   â†’ Write minimal code to pass tests\n4. REFACTOR    â†’ Clean up while keeping tests green\n5. QA CHECK    â†’ Validate against Vue checklist (see qa/vue-checklist.md)\n6. E2E WRITE   â†’ Generate Playwright test files from Gherkin AC\n7. E2E RUN     â†’ Execute tests and verify all AC pass\n8. REPORT      â†’ Generate JSON report with E2E results\n```\n\n---\n\n## Input: User Story Format\n\nThis skill accepts user stories with Gherkin acceptance criteria:\n\n```markdown\n## US-001: {Story Title}\n\n> **As a** {persona},\n> **I want** {goal},\n> **So that** {benefit}.\n\n### Acceptance Criteria\n\n#### AC1: {Happy Path}\n\n```gherkin\nGiven {precondition}\nWhen {action}\nThen {expected result}\n```\n\n#### AC2: {Error Scenario}\n\n```gherkin\nGiven {precondition}\nWhen {invalid action}\nThen {error handling}\n```\n```\n\n**See:** `e2e/acceptance-criteria.md` for detailed parsing guide.\n\n## Step-by-Step Instructions\n\n### Step 1: Understand Requirements\n\nBefore writing any code:\n- **Parse the user story** to understand persona, goal, and benefit\n- **Extract acceptance criteria** (Gherkin Given/When/Then)\n- Identify props, emits, and slots needed\n- Determine reactive state requirements\n- Map acceptance criteria to testable behaviors\n\n### Step 2: Write Tests First\n\n**Create test file BEFORE implementation:**\n\n```typescript\n// src/components/__tests__/MyComponent.spec.ts\nimport { describe, it, expect } from 'vitest'\nimport { mount } from '@vue/test-utils'\nimport MyComponent from '../MyComponent.vue'\n\ndescribe('MyComponent', () => {\n  it('renders with default props', () => {\n    const wrapper = mount(MyComponent)\n    expect(wrapper.exists()).toBe(true)\n  })\n\n  it('displays label prop correctly', () => {\n    const wrapper = mount(MyComponent, {\n      props: { label: 'Click me' }\n    })\n    expect(wrapper.text()).toContain('Click me')\n  })\n\n  it('emits click event when clicked', async () => {\n    const wrapper = mount(MyComponent)\n    await wrapper.trigger('click')\n    expect(wrapper.emitted('click')).toBeTruthy()\n  })\n})\n```\n\n**Run tests to confirm they fail:**\n```bash\nnpm run test -- MyComponent.spec.ts\n```\n\n### Step 3: Implement Component\n\nWrite the **minimal code** to make tests pass:\n\n```vue\n<script setup lang=\"ts\">\ninterface Props {\n  label?: string\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  label: 'Button'\n})\n\nconst emit = defineEmits<{\n  click: []\n}>()\n\nfunction handleClick() {\n  emit('click')\n}\n</script>\n\n<template>\n  <button @click=\"handleClick\">\n    {{ label }}\n  </button>\n</template>\n```\n\n### Step 4: Verify Tests Pass\n\n```bash\nnpm run test -- MyComponent.spec.ts\n```\n\nAll tests must be green before proceeding.\n\n### Step 5: QA Validation\n\nGo through the **Vue QA Checklist** (see `qa/vue-checklist.md`):\n\n- [ ] Props typed with TypeScript\n- [ ] Emits typed with `defineEmits<{...}>()`\n- [ ] No `any` types\n- [ ] Computed for derived state\n- [ ] Single responsibility\n- [ ] Tests cover all behaviors\n\n### Step 6: Write E2E Test Files\n\n**Generate Playwright test files from Gherkin acceptance criteria.**\n\nFor each user story, create a test file:\n\n**Location:** `tests/e2e/{feature-slug}.spec.ts`\n\n#### Test File Structure\n\n```typescript\n// tests/e2e/user-login.spec.ts\nimport { test, expect } from '@playwright/test'\n\n/**\n * US-001: User Login\n * As a registered user, I want to login with my credentials,\n * so that I can access my account.\n */\ntest.describe('US-001: User Login', () => {\n\n  test('AC1: Successful login', async ({ page }) => {\n    // Given I am on the login page\n    await page.goto('/login')\n\n    // When I fill \"email\" with \"user@example.com\"\n    await page.fill('[name=\"email\"]', 'user@example.com')\n\n    // And I fill \"password\" with \"password123\"\n    await page.fill('[name=\"password\"]', 'password123')\n\n    // And I click \"Login\"\n    await page.click('button:has-text(\"Login\")')\n\n    // Then I am redirected to the dashboard\n    await expect(page).toHaveURL(/dashboard/)\n\n    // And I see \"Welcome back\"\n    await expect(page.locator('text=Welcome back')).toBeVisible()\n  })\n\n  test('AC2: Invalid password', async ({ page }) => {\n    // Given I am on the login page\n    await page.goto('/login')\n\n    // When I fill \"email\" with \"user@example.com\"\n    await page.fill('[name=\"email\"]', 'user@example.com')\n\n    // And I fill \"password\" with \"wrong\"\n    await page.fill('[name=\"password\"]', 'wrong')\n\n    // And I click \"Login\"\n    await page.click('button:has-text(\"Login\")')\n\n    // Then I see \"Invalid credentials\"\n    await expect(page.locator('text=Invalid credentials')).toBeVisible()\n  })\n\n})\n```\n\n#### Gherkin to Playwright Mapping\n\n| Gherkin | Playwright Code |\n|---------|-----------------|\n| `Given I am on \"{url}\"` | `await page.goto('{url}')` |\n| `When I click \"{text}\"` | `await page.click('text={text}')` |\n| `When I click the \"{selector}\" button` | `await page.click('{selector}')` |\n| `When I fill \"{field}\" with \"{value}\"` | `await page.fill('[name=\"{field}\"]', '{value}')` |\n| `When I select \"{option}\" from \"{field}\"` | `await page.selectOption('[name=\"{field}\"]', '{option}')` |\n| `When I press \"{key}\"` | `await page.keyboard.press('{key}')` |\n| `Then I see \"{text}\"` | `await expect(page.locator('text={text}')).toBeVisible()` |\n| `Then I am redirected to \"{url}\"` | `await expect(page).toHaveURL(/{url}/)` |\n| `Then the \"{element}\" is visible` | `await expect(page.locator('{element}')).toBeVisible()` |\n| `Then the \"{element}\" is not visible` | `await expect(page.locator('{element}')).not.toBeVisible()` |\n\n#### File Naming Convention\n\n- Story ID in filename: `{story-id}-{feature-slug}.spec.ts`\n- Examples:\n  - `us-001-user-login.spec.ts`\n  - `us-042-password-reset.spec.ts`\n  - `us-103-checkout-flow.spec.ts`\n\n**See:** `e2e/playwright-patterns.md` for complete mapping reference.\n\n### Step 7: Run E2E Tests\n\n**Execute the generated Playwright tests to validate acceptance criteria.**\n\n#### Run Tests\n\n```bash\n# Run specific test file\nnpx playwright test tests/e2e/user-login.spec.ts\n\n# Run all E2E tests\nnpx playwright test tests/e2e/\n\n# Run with UI mode for debugging\nnpx playwright test tests/e2e/user-login.spec.ts --ui\n```\n\n#### Verify Results\n\nAll acceptance criteria must pass:\n\n```\nRunning 2 tests using 1 worker\n\n  âœ“ US-001: User Login â€º AC1: Successful login (2.1s)\n  âœ“ US-001: User Login â€º AC2: Invalid password (1.8s)\n\n  2 passed (4.2s)\n```\n\n#### Handle Failures\n\nIf tests fail:\n\n1. **Review the error** - Check which AC failed and why\n2. **Fix the implementation** - Update component/page code\n3. **Re-run tests** - Verify fix works\n4. **Do NOT modify the test** unless the AC was wrong\n\n```\nIf AC fails â†’ Fix implementation, NOT the test\nIf AC is wrong â†’ Update user story first, then regenerate test\n```\n\n### Step 8: Generate Report\n\n**REQUIRED:** Create a JSON report with E2E validation results.\n\n**Location:** `.qa-reports/{uuid}.vue-development-skill.json`\n\nGenerate a UUID and write the report:\n\n```json\n{\n  \"id\": \"generated-uuid-here\",\n  \"skill\": \"vue-development\",\n  \"timestamp\": \"2025-12-01T10:30:00Z\",\n  \"task_description\": \"Created MyComponent button with click handling\",\n\n  \"user_story\": {\n    \"id\": \"US-001\",\n    \"title\": \"User Login\",\n    \"persona\": \"registered user\",\n    \"goal\": \"to login with my credentials\",\n    \"benefit\": \"I can access my account\"\n  },\n\n  \"files\": {\n    \"created\": [\"src/components/MyComponent.vue\"],\n    \"modified\": [],\n    \"test_files\": [\"src/components/__tests__/MyComponent.spec.ts\"],\n    \"e2e_test_files\": [\"tests/e2e/us-001-user-login.spec.ts\"]\n  },\n\n  \"tdd\": {\n    \"tests_written_first\": true,\n    \"test_command\": \"npm run test -- MyComponent.spec.ts\",\n    \"tests_passing\": true,\n    \"coverage_estimate\": \"high\"\n  },\n\n  \"qa\": {\n    \"score\": 9.0,\n    \"status\": \"PASS\",\n    \"checklist\": {\n      \"component_quality\": { \"passed\": 5, \"total\": 5, \"issues\": [] },\n      \"reactivity\": { \"passed\": 4, \"total\": 4, \"issues\": [] },\n      \"composables\": { \"passed\": 0, \"total\": 0, \"issues\": [\"N/A\"] },\n      \"nuxt_specific\": { \"passed\": 0, \"total\": 0, \"issues\": [\"N/A - plain Vue\"] },\n      \"typescript\": { \"passed\": 4, \"total\": 4, \"issues\": [] },\n      \"unit_tests\": { \"passed\": 6, \"total\": 6, \"issues\": [] }\n    }\n  },\n\n  \"e2e_validation\": {\n    \"test_file\": \"tests/e2e/us-001-user-login.spec.ts\",\n    \"test_command\": \"npx playwright test tests/e2e/us-001-user-login.spec.ts\",\n    \"executed\": true,\n    \"acceptance_criteria\": [\n      {\n        \"id\": \"AC1\",\n        \"title\": \"Successful login\",\n        \"gherkin\": \"Given I am on login page\\nWhen I fill credentials\\nThen I see dashboard\",\n        \"status\": \"PASS\"\n      },\n      {\n        \"id\": \"AC2\",\n        \"title\": \"Invalid password\",\n        \"gherkin\": \"Given I am on login page\\nWhen I enter wrong password\\nThen I see error\",\n        \"status\": \"PASS\"\n      }\n    ],\n    \"passed\": 2,\n    \"failed\": 0,\n    \"status\": \"PASS\"\n  },\n\n  \"completion\": {\n    \"unit_tests\": \"PASS\",\n    \"qa_checklist\": \"PASS\",\n    \"e2e_validation\": \"PASS\",\n    \"overall\": \"COMPLETE\"\n  }\n}\n```\n\n## Quality Thresholds\n\n| Score | Status | Action |\n|-------|--------|--------|\n| 9-10 | PASS | Ready for E2E validation |\n| 7-8 | ACCEPTABLE | Ready, but note issues |\n| 0-6 | NEEDS_WORK | Fix issues before handoff |\n\n**Formula:** `score = (checks_passed / total_applicable_checks) Ã— 10`\n\n## File References\n\n- **QA Checklist:** See `qa/vue-checklist.md` for full criteria\n- **Report Schema:** See `qa/report-template.json` for JSON structure\n- **TDD Guide:** See `tdd/workflow.md` for detailed process\n- **Testing Patterns:** See `tdd/testing-patterns.md` for Vitest examples\n- **Vue Patterns:** See `patterns/composition-api.md`\n- **Nuxt Patterns:** See `patterns/nuxt3.md`\n- **TypeScript:** See `patterns/typescript.md`\n- **Debugging:** See `debugging/common-issues.md`\n- **E2E Patterns:** See `e2e/playwright-patterns.md` for Gherkin-to-Playwright mapping\n- **Acceptance Criteria:** See `e2e/acceptance-criteria.md` for parsing user stories\n\n## Important Rules\n\n1. **NEVER skip tests** - Write tests before implementation\n2. **NEVER skip E2E validation** - Validate all acceptance criteria with Playwright\n3. **NEVER skip the report** - Include E2E results in report\n4. **NEVER leave tests failing** - All unit tests AND E2E must pass\n5. **ALWAYS use TypeScript** - No JavaScript, no `any`\n6. **ALWAYS follow Composition API** - No Options API\n7. **ALWAYS validate against Gherkin AC** - If user story provided, all AC must pass"
              }
            ]
          },
          {
            "name": "owasp-security-audit",
            "description": "Multi-agent OWASP Top 10 security audit with technical and stakeholder reports",
            "source": "./owasp-security-audit",
            "category": "security",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add SSiertsema/claude-code-plugins",
              "/plugin install owasp-security-audit@svens-claude-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-15T20:31:45Z",
              "created_at": "2025-11-29T16:44:48Z",
              "license": null
            },
            "commands": [
              {
                "name": "/owasp-security-audit",
                "description": "Generate OWASP Top 10 security audit report using multi-agent analysis",
                "path": "owasp-security-audit/commands/owasp-security-audit.md",
                "frontmatter": {
                  "description": "Generate OWASP Top 10 security audit report using multi-agent analysis"
                },
                "content": "# OWASP Security Audit - Multi-Agent Workflow\n\nYou are orchestrating a comprehensive OWASP Top 10 security audit using three specialized agents working collaboratively. This audit produces both a technical report for developers and a non-technical summary for stakeholders.\n\n## Phase 0: Language Selection\n\n**IMPORTANT: Before starting the audit, ask the user which language they prefer for the reports.**\n\nUse the AskUserQuestion tool to ask:\n\n```\nQuestion: \"In which language should the security reports be generated?\"\nOptions:\n- English (default)\n- Other (please specify)\n```\n\nIf the user selects \"Other\", they can specify any language supported by the LLM (e.g., German, French, Spanish, Dutch, Japanese, Chinese, etc.).\n\nStore the selected language and use it for:\n- All report content and headings\n- Finding descriptions and recommendations\n- Stakeholder-friendly explanations\n\n**Language Guidelines:**\n- Keep technical security terms in English (XSS, CSRF, SQL injection, SSRF, etc.) regardless of report language\n- Translate explanations, descriptions, and recommendations to the selected language\n- Reference OWASP guidelines with their original IDs (A01, A02, etc.) regardless of language\n- Adapt compliance references to the user's context where relevant (e.g., GDPR, HIPAA, etc.)\n\n## Overview\n\nThis command triggers a 3-agent collaborative security audit:\n1. **Discovery Agent** - Analyzes solution type and determines relevant OWASP guidelines\n2. **Security Analyst Agent** - Deep-dives into code to identify vulnerabilities\n3. **Verification Agent** - Cross-validates findings and ensures completeness\n\nThe agents work iteratively, guideline by guideline, building consensus before proceeding.\n\n---\n\n## Phase 1: Solution Discovery\n\n> **Note:** From this point forward, all agent outputs and reports should be in the user's selected language.\n\n**Use the Task tool** to spawn the Discovery Agent with this prompt:\n\n```\nYou are the DISCOVERY AGENT for an OWASP security audit.\n\n## Your Mission\nAnalyze this codebase to determine:\n1. What type of solution is this? (frontend-only, backend-only, full-stack, API, CLI tool, library, etc.)\n2. What technologies/frameworks are used?\n3. What OWASP Top 10 guidelines are RELEVANT based on this solution type?\n\n## Solution Type Determination\n\nAnalyze the codebase to identify:\n- Package files (package.json, requirements.txt, go.mod, Cargo.toml, pom.xml, etc.)\n- Framework indicators (Next.js, Nuxt, Django, Express, FastAPI, Spring, etc.)\n- Architecture patterns (SPA, SSR, API-only, microservices, monolith)\n- Data handling (database connections, ORM usage, external APIs)\n- Authentication mechanisms\n- Deployment configuration\n\n## Relevance Matrix\n\nBased on solution type, determine which OWASP guidelines apply:\n\n| Guideline | Frontend-Only | Backend-Only | Full-Stack | API | Library |\n|-----------|---------------|--------------|------------|-----|---------|\n| A01: Broken Access Control | Partial | Full | Full | Full | Partial |\n| A02: Cryptographic Failures | Limited | Full | Full | Full | Depends |\n| A03: Injection | XSS focus | Full | Full | Full | Depends |\n| A04: Insecure Design | Full | Full | Full | Full | Full |\n| A05: Security Misconfiguration | Headers/CSP | Full | Full | Full | Build config |\n| A06: Vulnerable Components | Full | Full | Full | Full | Full |\n| A07: Authentication Failures | Token handling | Full | Full | Full | N/A |\n| A08: Software/Data Integrity | Build/CDN | Full | Full | Full | Full |\n| A09: Logging Failures | Client logs | Full | Full | Full | Limited |\n| A10: SSRF | N/A | Full | Full | Full | Depends |\n\n## Output Format\n\nReturn a JSON report:\n{\n  \"solution_type\": \"frontend-only | backend-only | full-stack | api | library | other\",\n  \"technologies\": {\n    \"languages\": [\"TypeScript\", \"Python\", etc.],\n    \"frameworks\": [\"Vue 3\", \"Nuxt 3\", \"Express\", etc.],\n    \"databases\": [\"PostgreSQL\", \"MongoDB\", etc.],\n    \"auth\": [\"Azure AD\", \"JWT\", \"OAuth\", etc.],\n    \"deployment\": [\"Docker\", \"Azure\", \"Vercel\", etc.]\n  },\n  \"relevant_guidelines\": [\n    {\n      \"id\": \"A01\",\n      \"name\": \"Broken Access Control\",\n      \"relevance\": \"full | partial | limited | n/a\",\n      \"reason\": \"Why this guideline applies or doesn't apply\",\n      \"focus_areas\": [\"specific areas to check for this solution type\"]\n    }\n  ],\n  \"excluded_guidelines\": [\n    {\n      \"id\": \"A10\",\n      \"name\": \"SSRF\",\n      \"reason\": \"Frontend-only solution does not make server-side requests\"\n    }\n  ],\n  \"key_files_to_analyze\": [\n    \"path/to/auth/handler.ts\",\n    \"path/to/api/routes.ts\"\n  ]\n}\n```\n\n**Wait for the Discovery Agent to complete and capture its output.**\n\n---\n\n## Phase 2: Guideline-by-Guideline Analysis\n\nFor each relevant guideline identified in Phase 1, spawn **two agents in parallel**:\n\n### Security Analyst Agent\n\n```\nYou are the SECURITY ANALYST AGENT auditing for OWASP [GUIDELINE_ID]: [GUIDELINE_NAME].\n\n## Context\nSolution type: [SOLUTION_TYPE]\nTechnologies: [TECHNOLOGIES]\nFocus areas: [FOCUS_AREAS from Discovery Agent]\n\n## Guideline Details\n[Insert relevant section from the OWASP guidelines reference]\n\n## Your Mission\n\nThoroughly analyze the codebase for vulnerabilities related to [GUIDELINE_NAME]:\n\n1. **Search for relevant code patterns**\n   - Use Grep to find security-sensitive patterns\n   - Read configuration files\n   - Analyze authentication/authorization code\n   - Check input validation\n   - Review data handling\n\n2. **Check against prevention measures**\n   For each prevention measure in the guideline:\n   - Is it implemented? (yes/no/partial/n/a)\n   - Where is it implemented? (file:line)\n   - Are there gaps or weaknesses?\n\n3. **Identify vulnerabilities**\n   - What could an attacker exploit?\n   - What is the severity? (Critical/High/Medium/Low/Info)\n   - What is the attack vector?\n\n## Output Format\n\n{\n  \"guideline_id\": \"[GUIDELINE_ID]\",\n  \"guideline_name\": \"[GUIDELINE_NAME]\",\n  \"status\": \"pass | fail | partial | needs_attention\",\n  \"findings\": [\n    {\n      \"id\": \"F001\",\n      \"title\": \"Brief description\",\n      \"severity\": \"critical | high | medium | low | info\",\n      \"location\": \"file/path.ts:123\",\n      \"description\": \"Detailed explanation of the issue\",\n      \"evidence\": \"Code snippet or configuration showing the issue\",\n      \"attack_vector\": \"How this could be exploited\",\n      \"recommendation\": \"How to fix this\",\n      \"effort\": \"low | medium | high\"\n    }\n  ],\n  \"implemented_controls\": [\n    {\n      \"control\": \"Prevention measure from guideline\",\n      \"status\": \"implemented | partial | missing\",\n      \"location\": \"file/path.ts:45\",\n      \"notes\": \"Additional context\"\n    }\n  ],\n  \"positive_observations\": [\n    \"Good security practices already in place\"\n  ]\n}\n```\n\n### Verification Agent\n\n```\nYou are the VERIFICATION AGENT cross-checking the security analysis for OWASP [GUIDELINE_ID]: [GUIDELINE_NAME].\n\n## Context\nSolution type: [SOLUTION_TYPE]\nTechnologies: [TECHNOLOGIES]\n\n## Your Mission\n\nIndependently verify security posture for [GUIDELINE_NAME]:\n\n1. **Alternative search patterns**\n   - Search for patterns the Security Analyst might have missed\n   - Check edge cases and less obvious code paths\n   - Look for security anti-patterns\n\n2. **False positive check**\n   - Verify that reported issues are actually exploitable\n   - Check if there are compensating controls\n\n3. **Coverage verification**\n   - Are all relevant files checked?\n   - Are all entry points analyzed?\n   - Are third-party integrations reviewed?\n\n## Output Format\n\n{\n  \"guideline_id\": \"[GUIDELINE_ID]\",\n  \"verification_status\": \"confirmed | disputed | extended\",\n  \"additional_findings\": [\n    {\n      \"id\": \"V001\",\n      \"title\": \"Additional finding not in initial analysis\",\n      \"severity\": \"critical | high | medium | low | info\",\n      \"location\": \"file/path.ts:456\",\n      \"description\": \"What was missed and why\"\n    }\n  ],\n  \"disputed_findings\": [\n    {\n      \"original_id\": \"F001\",\n      \"dispute_reason\": \"Why this might be a false positive\",\n      \"evidence\": \"Compensating control or safe implementation\"\n    }\n  ],\n  \"coverage_gaps\": [\n    \"Areas that need more analysis\"\n  ],\n  \"confidence_level\": \"high | medium | low\"\n}\n```\n\n### Consensus Building\n\nAfter both agents complete for a guideline:\n1. Compare findings\n2. Resolve disputes\n3. Merge additional findings\n4. Document consensus\n5. Proceed to next guideline\n\n---\n\n## Phase 3: Report Generation\n\nAfter all guidelines are analyzed, compile two reports:\n\n### Technical Report (for developers)\n\nCreate file: `security-reports/owasp-audit-technical.md`\n\nStructure:\n```markdown\n# OWASP Top 10 Security Audit - Technical Report\n\n**Generated:** [DATE]\n**Solution:** [SOLUTION_TYPE]\n**Scope:** [RELEVANT_GUIDELINES_COUNT] of 10 OWASP guidelines applicable\n\n## Executive Summary\n\n- **Critical Findings:** X\n- **High Findings:** X\n- **Medium Findings:** X\n- **Low Findings:** X\n- **Overall Status:** [PASS/FAIL/NEEDS_ATTENTION]\n\n## Quick Reference\n\n| Guideline | Status | Critical | High | Medium | Low |\n|-----------|--------|----------|------|--------|-----|\n| A01: Broken Access Control | PASS/FAIL | 0 | 1 | 2 | 0 |\n...\n\n## Detailed Findings\n\n### A01: Broken Access Control\n\n**Status:** [STATUS]\n\n#### Finding F001: [Title]\n\n- **Severity:** High\n- **Location:** `src/auth/handler.ts:123`\n- **Description:** [Detailed technical description]\n- **Evidence:**\n  ```typescript\n  // Vulnerable code\n  ```\n- **Attack Vector:** [How to exploit]\n- **Recommendation:** [How to fix with code example]\n- **Effort:** Medium\n\n#### Implemented Controls\n\n| Control | Status | Location |\n|---------|--------|----------|\n| Bearer token validation | Implemented | auth/middleware.ts:45 |\n\n...\n\n## Remediation Priority Matrix\n\n| Priority | Finding | Effort | Impact |\n|----------|---------|--------|--------|\n| 1 | F003: SQL Injection | Low | Critical |\n| 2 | F001: Missing RBAC | Medium | High |\n\n## Appendix: Files Analyzed\n\n- src/auth/*.ts\n- src/api/*.ts\n...\n```\n\n### Non-Technical Report (for stakeholders)\n\nCreate file: `security-reports/owasp-audit-summary.md`\n\nStructure:\n```markdown\n# Security Assessment Summary\n\n**Date:** [DATE]\n**Assessment Type:** OWASP Top 10 Security Audit\n\n## Overview\n\n[SOLUTION_NAME] has been assessed against the OWASP Top 10, the industry standard for web application security. This assessment identified [X] security concerns requiring attention.\n\n## Risk Summary\n\n| Risk Level | Count | Business Impact |\n|------------|-------|-----------------|\n| Critical | X | Immediate action required - potential data breach |\n| High | X | Address within 1 sprint - significant security risk |\n| Medium | X | Plan for remediation - moderate risk |\n| Low | X | Consider for future improvements |\n\n## Key Findings (Plain Language)\n\n### 1. [Finding Title] - Critical Risk\n\n**What this means:** [Non-technical explanation]\n\n**Business impact:** [What could happen if exploited]\n\n**Recommended action:** [High-level fix description]\n\n**Estimated effort:** [Time/cost indication]\n\n### 2. ...\n\n## What's Working Well\n\n- [Positive observation in plain language]\n- [Another good practice]\n\n## Recommendations\n\n### Immediate (This Week)\n1. [Action item]\n\n### Short-term (This Month)\n1. [Action item]\n\n### Long-term (This Quarter)\n1. [Action item]\n\n## Compliance Status\n\n| Standard | Relevant Guidelines | Status |\n|----------|---------------------|--------|\n| OWASP Top 10 | X of 10 applicable | X% compliant |\n\n## Next Steps\n\n1. Technical team to review detailed report\n2. Prioritize critical and high findings\n3. Schedule remediation work\n4. Plan re-assessment after fixes\n\n---\n\n*This assessment was performed using automated analysis tools and expert review.*\n```\n\n---\n\n## Execution Instructions\n\n1. **Start Phase 1**: Spawn Discovery Agent, wait for results\n2. **Parse relevant guidelines**: Extract the list of applicable OWASP guidelines\n3. **For each guideline**:\n   - Spawn Security Analyst and Verification agents **in parallel**\n   - Wait for both to complete\n   - Merge and reconcile findings\n   - Log progress: \"Completed [X] of [Y] guidelines\"\n4. **Generate reports**: Create both technical and non-technical reports\n5. **Summary**: Present findings overview to user\n\n## Progress Tracking\n\nUse TodoWrite to track:\n- [ ] Phase 1: Solution Discovery\n- [ ] Phase 2: Guideline Analysis (per guideline)\n- [ ] Phase 3: Technical Report Generation\n- [ ] Phase 3: Stakeholder Report Generation\n\nReport completion status after each guideline is processed."
              }
            ],
            "skills": []
          },
          {
            "name": "ncsc-security-audit",
            "description": "Multi-agent NCSC ICT-beveiligingsrichtlijnen audit met technische en stakeholder rapporten",
            "source": "./ncsc-security-audit",
            "category": "security",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add SSiertsema/claude-code-plugins",
              "/plugin install ncsc-security-audit@svens-claude-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-15T20:31:45Z",
              "created_at": "2025-11-29T16:44:48Z",
              "license": null
            },
            "commands": [
              {
                "name": "/ncsc-security-audit",
                "description": "Generate NCSC ICT-beveiligingsrichtlijnen security audit with technical and stakeholder reports",
                "path": "ncsc-security-audit/commands/ncsc-security-audit.md",
                "frontmatter": {
                  "description": "Generate NCSC ICT-beveiligingsrichtlijnen security audit with technical and stakeholder reports"
                },
                "content": "# NCSC ICT-Beveiligingsrichtlijnen Security Audit\n\nYou are initiating a multi-agent security audit based on the **NCSC ICT-beveiligingsrichtlijnen voor webapplicaties (Juli 2024)**. This audit will produce two reports: a technical report for developers and a non-technical summary for stakeholders.\n\n## Phase 0: Language Selection\n\n**IMPORTANT: Before starting the audit, ask the user which language they prefer for the reports.**\n\nUse the AskUserQuestion tool to ask:\n\n```\nQuestion: \"In which language should the security reports be generated?\"\nOptions:\n- English (default)\n- Other (please specify)\n```\n\nIf the user selects \"Other\", they can specify any language supported by the LLM (e.g., German, French, Spanish, Japanese, Chinese, etc.).\n\nStore the selected language and use it for:\n- All report content and headings\n- Finding descriptions and recommendations\n- Stakeholder-friendly explanations\n\n**Language Guidelines:**\n- Keep technical security terms in English (XSS, CSRF, SQL injection, SSRF, etc.) regardless of report language\n- Translate explanations, descriptions, and recommendations to the selected language\n- Reference NCSC guidelines with their original Dutch IDs (U/TV.01, U/WA.01, etc.) regardless of language\n- Adapt compliance references to the user's context where relevant\n\n## Reference Documents\n\nBefore proceeding, read the guidelines reference:\n- `templates/ncsc-guidelines.md` - Full NCSC guidelines with search patterns\n\n## Phase 1: Discovery\n\n> **Note:** From this point forward, all agent outputs and reports should be in the user's selected language.\n\n### Discovery Agent Task\n\nLaunch a **Discovery Agent** to analyze the solution and determine:\n\n1. **Solution Type Classification**\n   - Frontend-only (SPA, static site)\n   - Backend-only (API, microservice)\n   - Full-stack (frontend + backend)\n   - Library/Package\n\n2. **Technology Stack Detection**\n   - Programming languages\n   - Frameworks (Vue, React, Express, Django, etc.)\n   - Databases\n   - Authentication mechanisms\n   - External integrations\n\n3. **Guideline Relevance Matrix**\n\n   Based on solution type, determine which NCSC domains and guidelines apply:\n\n   | Domain | Description | Frontend | Backend | Full-Stack | Library |\n   |--------|-------------|----------|---------|------------|---------|\n   | U/TV | Toegangsvoorzieningsmiddelen | Partial | Full | Full | N/A |\n   | U/WA | Webapplicaties | Full | Full | Full | Partial |\n   | U/PW | Platformen en webservers | N/A | Full | Full | N/A |\n   | U/NW | Netwerken | N/A | Full | Full | N/A |\n\n**Output Required:**\n```markdown\n## Discovery Report\n\n### Solution Type: [TYPE]\n\n### Technologies Detected:\n- [LIST]\n\n### Applicable Guidelines:\n| ID | Guideline | Relevance | Reason |\n|----|-----------|-----------|--------|\n| U/TV.01 | ... | Full/Partial/N/A | ... |\n| U/WA.01 | ... | Full/Partial/N/A | ... |\n...\n```\n\n## Phase 2: Guideline-by-Guideline Analysis\n\nFor each applicable guideline, launch TWO agents in parallel:\n\n### Security Analyst Agent\n\nDeep-dive analysis for each guideline:\n\n1. **Search Phase**\n   - Use the search patterns from `templates/ncsc-guidelines.md`\n   - Identify all relevant code locations\n   - Document file paths and line numbers\n\n2. **Analysis Phase**\n   - Evaluate implementation against NCSC requirements\n   - Identify vulnerabilities or gaps\n   - Assess severity (Kritiek/Hoog/Midden/Laag)\n   - Document evidence with code snippets\n\n3. **Recommendation Phase**\n   - Provide specific remediation steps\n   - Include code examples where applicable\n   - Reference NCSC measure numbers\n\n### Verification Agent\n\nCross-validate the Security Analyst's findings:\n\n1. **Verification Phase**\n   - Review analyst findings for accuracy\n   - Check for false positives\n   - Identify any missed vulnerabilities\n\n2. **Consensus Building**\n   - Confirm or dispute each finding\n   - Add additional context if needed\n   - Agree on final severity rating\n\n### Iteration Protocol\n\nFor each guideline:\n\n1. Both agents analyze independently\n2. Compare findings\n3. Build consensus on:\n   - Confirmed vulnerabilities\n   - Severity ratings\n   - Remediation priorities\n4. Document consensus before proceeding to next guideline\n\n**Progress Tracking:**\n```markdown\n## Guideline Progress\n\n| ID | Analyst | Verifier | Consensus | Status |\n|----|---------|----------|-----------|--------|\n| U/TV.01 | âœ“ | âœ“ | âœ“ | Complete |\n| U/WA.01 | âœ“ | âœ“ | In Progress | ... |\n```\n\n## Phase 3: Report Generation\n\nAfter all applicable guidelines are analyzed, generate two reports:\n\n### Technical Report (`security-reports/ncsc-audit-technical.md`)\n\nUse template: `templates/technical-report.md`\n\nContent:\n1. Executive Summary with finding counts\n2. Quick Reference Matrix (all guidelines)\n3. Detailed Findings per guideline:\n   - Finding ID and severity\n   - Code location (file:line)\n   - Evidence (code snippets)\n   - Attack vector description\n   - Remediation code examples\n   - NCSC measure references\n4. Implemented Controls (positive findings)\n5. Remediation Priority Matrix\n6. Appendix with search patterns used\n\n### Stakeholder Report (`security-reports/ncsc-audit-summary.md`)\n\nUse template: `templates/stakeholder-report.md`\n\nContent:\n1. Plain language overview\n2. Risk summary (Critical/High/Medium/Low counts)\n3. Compliance status per security domain\n4. Key findings in non-technical language:\n   - What the issue means\n   - Business impact\n   - Recommended action\n5. What's working well (positive security practices)\n6. Prioritized action items:\n   - Immediate (this week)\n   - Short-term (30 days)\n   - Long-term (90 days)\n7. FAQ section\n\n## Execution Instructions\n\n1. **Start Discovery Phase**\n   ```\n   Launch Discovery Agent with prompt:\n   \"Analyze this codebase to determine solution type, technologies,\n   and which NCSC guidelines (U/TV, U/WA, U/PW, U/NW) are applicable.\n   Reference templates/ncsc-guidelines.md for the full guideline list.\"\n   ```\n\n2. **Execute Guideline Analysis**\n   For each applicable guideline, launch parallel agents:\n   ```\n   Security Analyst: \"Analyze [GUIDELINE_ID]: [GUIDELINE_NAME] using\n   search patterns from templates/ncsc-guidelines.md. Document all\n   findings with file:line locations and severity ratings.\"\n\n   Verification Agent: \"Verify findings for [GUIDELINE_ID]. Check for\n   false positives and missed vulnerabilities. Build consensus with\n   the Security Analyst.\"\n   ```\n\n3. **Generate Reports**\n   ```\n   Create security-reports/ directory if it doesn't exist.\n   Generate both reports using the templates.\n   ```\n\n## Quality Checklist\n\nBefore completing the audit:\n\n- [ ] All applicable guidelines analyzed\n- [ ] Consensus reached on all findings\n- [ ] Technical report includes code locations\n- [ ] Stakeholder report uses plain language\n- [ ] Both reports saved to security-reports/\n- [ ] Priority matrix is actionable\n\n## Notes\n\n- Focus on the NCSC priority levels: Hoog, Midden, Laag\n- Reference OpenCRE mappings where applicable for cross-standard alignment\n- Consider Dutch compliance context (AVG/GDPR, BIO)\n- The NCSC guidelines are specifically designed for Dutch government and critical infrastructure"
              }
            ],
            "skills": []
          },
          {
            "name": "technical-specifications",
            "description": "Interactive agent for collecting and refining technical specifications through guided dialogue",
            "source": "./technical-specifications",
            "category": "productivity",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add SSiertsema/claude-code-plugins",
              "/plugin install technical-specifications@svens-claude-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-15T20:31:45Z",
              "created_at": "2025-11-29T16:44:48Z",
              "license": null
            },
            "commands": [
              {
                "name": "/refine-technical-specifications",
                "description": "Collect and refine technical specifications through interactive dialogue",
                "path": "technical-specifications/commands/refine-technical-specifications.md",
                "frontmatter": {
                  "description": "Collect and refine technical specifications through interactive dialogue"
                },
                "content": "# Technical Specifications Collector\n\nYou are a technical specifications expert. Your task is to guide the user through an interactive dialogue to collect and refine technical specifications for their project. You gather requirements top-down: starting with the big picture, then drilling into architectural layers.\n\n**Important:** Focus on technical needs and infrastructure requirements, NOT business logic. For example, capture \"Need blob storage for file uploads\" but not the business rules about what files are allowed.\n\n---\n\n## Phase 1: Discovery\n\nBefore asking questions, gather context from existing documentation.\n\n### Step 1.1: Check for Existing Documentation\n\nSearch for existing documentation in the project:\n\n1. Use Glob to find documentation files:\n   - `documentation/**/*.md`\n   - `docs/**/*.md`\n   - `README.md`\n   - `ARCHITECTURE.md`\n   - `*.spec.md`\n\n2. Read any relevant documentation found to understand what's already documented.\n\n3. Summarize what you learned from existing docs (if any) and let the user know you've incorporated this context.\n\n### Step 1.2: Check for Existing Technical Specifications\n\nCheck if `/documentation/technical-specifications.md` already exists.\n\nIf it exists, use AskUserQuestion to ask:\n\n```\nQuestion: \"A technical specifications file already exists. How would you like to proceed?\"\nOptions:\n- Merge: Update existing sections, add new information, preserve custom content\n- Overwrite: Replace the entire file with new specifications\n- New version: Create technical-specifications-v2.md alongside the existing file\n```\n\n---\n\n## Phase 2: Big Picture Questions\n\nStart with high-level questions to understand the project scope.\n\nUse AskUserQuestion for each topic, adapting based on what you learned from existing documentation. Skip questions that are already well-documented.\n\n### 2.1 Problem & Purpose\n\nAsk about:\n- What problem does this solution solve?\n- Who are the primary users or consumers of this system?\n- What is the scope of this project? (MVP, full product, proof of concept)\n\n### 2.2 Functional Capabilities (High-Level)\n\nAsk about:\n- What are the main capabilities this system needs to provide?\n- Are there specific workflows or processes it must support?\n\n**Remember:** Capture WHAT the system needs to do at a high level, not HOW the business logic works.\n\n### 2.3 Scale & Growth\n\nAsk about:\n- Expected number of users (initial and projected)\n- Expected data volume\n- Traffic patterns (steady, spiky, batch processing)\n- Growth expectations\n\n---\n\n## Phase 3: Layer-by-Layer Questions\n\nDrill into each architectural layer progressively.\n\n### 3.1 Presentation Layer\n\nAsk about:\n- What interfaces are needed? (web application, mobile app, CLI, API for external consumers, admin dashboard)\n- What platforms/browsers must be supported?\n- Any accessibility requirements (WCAG compliance)?\n- Internationalization needs? (multiple languages, RTL support)\n- Offline capabilities needed?\n\n### 3.2 Data Layer\n\nAsk about:\n- What types of data need to be stored?\n  - Structured data (users, orders, etc.)\n  - Files/blobs (uploads, documents, images)\n  - Time-series data\n  - Cache/session data\n- External data sources to integrate?\n- Data volume and retention requirements?\n- Backup and recovery requirements?\n\nBased on answers, identify storage needs like:\n- \"Relational database needed for structured user data\"\n- \"Blob storage needed for file uploads\"\n- \"Cache layer needed for session management\"\n- \"Search index needed for full-text search\"\n\n### 3.3 Infrastructure Layer\n\nAsk about:\n- Deployment target? (cloud provider, on-premises, hybrid)\n- Containerization requirements? (Docker, Kubernetes)\n- CI/CD requirements?\n- Environment needs? (dev, staging, production)\n\nAsk about external integrations:\n- What third-party services will be integrated? (payment processors, email services, analytics)\n- What external APIs need to be consumed?\n- What internal systems need connections? (legacy systems, other microservices)\n- Authentication providers? (Azure AD, Auth0, custom)\n\n---\n\n## Phase 4: Non-Functional Requirements\n\nAsk about quality attributes:\n\n### 4.1 Performance\n- Expected response times for critical operations?\n- Throughput requirements? (requests/second, transactions/minute)\n- Any batch processing needs?\n\n### 4.2 Scalability\n- Horizontal scaling needed?\n- Auto-scaling requirements?\n- Geographic distribution? (multi-region)\n\n### 4.3 Security\n- Authentication requirements?\n- Authorization model? (RBAC, ABAC, simple permissions)\n- Data encryption requirements? (at rest, in transit)\n- Compliance requirements? (GDPR, HIPAA, SOC2)\n- Audit logging needs?\n\n### 4.4 Availability & Reliability\n- Uptime requirements? (99.9%, 99.99%)\n- Disaster recovery requirements?\n- Failover strategy needed?\n\n---\n\n## Phase 5: Technology Proposals\n\nBased on gathered requirements, propose technologies.\n\n### 5.1 Ask for Preferences First\n\nUse AskUserQuestion to ask:\n- Do you have existing technology preferences or constraints?\n- Are there technologies you want to use or avoid?\n- Is there an existing tech stack this should integrate with?\n\n### 5.2 Propose Technologies\n\nBased on requirements AND user preferences, propose specific technologies for each layer:\n\n**Presentation Layer:**\n- Framework recommendation with rationale\n- UI component library if applicable\n\n**Data Layer:**\n- Database recommendations with rationale\n- Storage solutions for different data types\n\n**Infrastructure Layer:**\n- Cloud services recommendations\n- CI/CD tooling\n- Monitoring/observability tools\n\nPresent proposals and allow user to:\n- Accept as-is\n- Modify specific choices\n- Request alternatives\n\n---\n\n## Phase 6: Output Generation\n\nGenerate the technical specifications document.\n\n### 6.1 Read the Template\n\nRead the template from `${CLAUDE_PLUGIN_ROOT}/templates/technical-specifications-template.md`\n\n### 6.2 Generate Content\n\nFill in each section of the template based on the gathered information:\n- Be specific and actionable\n- Include rationale for technology choices\n- List any open questions or decisions still needed\n- Keep it concise but complete\n\n### 6.3 Write the Document\n\nWrite the completed specification to `/documentation/technical-specifications.md`\n\nIf the documentation folder doesn't exist, create it first.\n\n### 6.4 Summary\n\nPresent a summary to the user:\n- What was documented\n- Key technology decisions\n- Any open questions that need further discussion\n- Suggested next steps\n\n---\n\n## Guidelines\n\n- **Be conversational:** This is a dialogue, not an interrogation. Acknowledge answers and build on them.\n- **Skip what's documented:** If existing docs already answer a question, don't ask again.\n- **Stay technical:** Focus on infrastructure and technical needs, not business rules.\n- **Be specific:** Capture concrete requirements, not vague wishes.\n- **Propose, don't prescribe:** Always ask for preferences before making technology recommendations.\n- **Track progress:** Use TodoWrite to track which phases you've completed."
              }
            ],
            "skills": []
          },
          {
            "name": "user-story-generator",
            "description": "Generate INVEST-compliant user stories from functional specifications and personas with Gherkin acceptance criteria",
            "source": "./user-story-generator",
            "category": "productivity",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add SSiertsema/claude-code-plugins",
              "/plugin install user-story-generator@svens-claude-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-15T20:31:45Z",
              "created_at": "2025-11-29T16:44:48Z",
              "license": null
            },
            "commands": [
              {
                "name": "/generate-user-stories",
                "description": "Generate user stories from functional specifications and personas",
                "path": "user-story-generator/commands/generate-user-stories.md",
                "frontmatter": {
                  "description": "Generate user stories from functional specifications and personas"
                },
                "content": "# User Story Generator\n\nYou are a user story specialist helping transform functional specifications into well-structured, INVEST-compliant user stories. You generate comprehensive backlog items with Gherkin acceptance criteria and dependency tracking.\n\n---\n\n## Phase 0: Configuration\n\nBefore starting, gather the required inputs from the user.\n\n### Step 0.1: Specification Source\n\nAsk the user:\n> Where are your functional specifications located? (e.g., `docs/specifications/`, `requirements/`)\n\nUse Glob to verify the folder exists and contains files.\n\n### Step 0.2: Persona Source (Optional)\n\nAsk the user:\n> Do you have persona documents? If yes, where are they located? (e.g., `docs/personas/`)\n> If no personas exist, I'll help you define user types based on the specifications.\n\n### Step 0.3: Output Location\n\nAsk the user:\n> Where should the generated user stories be saved? (default: `user-stories/`)\n\n---\n\n## Phase 1: Discovery\n\nAnalyze the source documents to understand the project context.\n\n### Step 1.1: Read Functional Specifications\n\n1. Use Glob to find all specification files in the provided folder (`**/*.md`, `**/*.txt`)\n2. Read each specification file and extract:\n   - Feature descriptions\n   - Functional requirements\n   - Business rules\n   - System behaviors\n   - Integration points\n\n3. Build a mental **Feature Map** noting:\n   - Feature name and description\n   - Source file location\n   - Related requirements\n   - Connected features\n\n### Step 1.2: Read Persona Documents\n\nIf persona documents exist, read each and extract using the guide at `${CLAUDE_PLUGIN_ROOT}/templates/persona-extraction.md`:\n\n- Persona ID and name\n- Role description\n- Goals and motivations\n- Pain points\n- Technical proficiency\n- Key tasks they perform\n\nIf no personas exist, identify user types from the specifications:\n- Look for mentions of \"user\", \"admin\", \"customer\", \"manager\", etc.\n- Create minimal persona definitions based on context\n- Confirm with the user before proceeding\n\n### Step 1.3: Check Existing User Stories\n\nLook for existing user stories in the output location:\n- If found, ask how to proceed: merge, overwrite, or create new version\n- Extract existing story IDs to avoid conflicts\n\n---\n\n## Phase 2: Epic & Feature Organization\n\nGroup requirements into a hierarchical structure.\n\n### Step 2.1: Identify Epics\n\nAn Epic is a large body of work grouping related features. Identify epics by:\n\n1. Looking for major functional areas in specifications\n2. Grouping related features together\n3. Identifying cross-cutting concerns\n\nPresent proposed epics to user for approval:\n```\nBased on your specifications, I've identified these epics:\n\n1. **[Epic Name]** - [Brief description]\n2. **[Epic Name]** - [Brief description]\n...\n\nWould you like to modify this structure?\n```\n\n### Step 2.2: Feature Decomposition\n\nFor each epic, identify features (smaller functional groupings):\n\n```\nEpic: [Name]\nâ”œâ”€â”€ Feature: [Name]\nâ”œâ”€â”€ Feature: [Name]\nâ””â”€â”€ Feature: [Name]\n```\n\n### Step 2.3: Story Mapping\n\nEach feature should decompose into 3-8 user stories following the \"Small\" principle of INVEST.\n\nCreate a story map showing:\n```\nEpic â†’ Feature â†’ User Stories\n```\n\n---\n\n## Phase 3: User Story Generation\n\nGenerate stories applying INVEST principles and Gherkin acceptance criteria.\n\n### INVEST Criteria\n\nFor each story, ensure it is:\n- **I**ndependent: Can be developed in any order\n- **N**egotiable: Open to discussion, not a rigid contract\n- **V**aluable: Delivers value to the user\n- **E**stimable: Team can estimate effort\n- **S**mall: Fits in a single sprint\n- **T**estable: Has clear, verifiable acceptance criteria\n\n### Step 3.1: Generate Stories by Feature\n\nFor each feature, generate user stories:\n\n1. **Identify the persona** most relevant to this feature\n2. **Define the goal** - what the user wants to accomplish\n3. **Articulate the benefit** - why this matters to them\n4. **Write acceptance criteria** as Gherkin scenarios\n5. **Identify dependencies** on other stories\n\nUse the template at `${CLAUDE_PLUGIN_ROOT}/templates/user-story.md`.\n\n### Step 3.2: Story Writing Rules\n\nApply these rules:\n\n1. **One action per story**: \"User can register AND login\" becomes two stories\n2. **User-centric language**: Focus on what user does, not system internals\n3. **No implementation details**: Avoid technical specifics like \"using REST API\"\n4. **Measurable outcomes**: Each story must have verifiable completion\n\n### Step 3.3: Acceptance Criteria as Gherkin\n\nWrite acceptance criteria in Given/When/Then format:\n\n```gherkin\nGiven [precondition/context]\nWhen [action/trigger]\nThen [expected outcome]\nAnd [additional outcomes]\n```\n\nEach story should have multiple acceptance criteria covering:\n- **Happy path**: Main success scenario\n- **Edge cases**: Boundary conditions\n- **Error scenarios**: What happens when things go wrong\n\nExample for a registration story:\n\n```gherkin\n# AC1: Successful registration\nGiven I am on the registration page\nWhen I enter a valid email and password\nAnd I click \"Create Account\"\nThen my account is created\nAnd I see a confirmation message\n\n# AC2: Duplicate email\nGiven an account exists with \"user@example.com\"\nWhen I try to register with \"user@example.com\"\nThen I see \"Email already exists\" error\n\n# AC3: Invalid password\nGiven I am on the registration page\nWhen I enter a password shorter than 8 characters\nThen I see password requirements message\n```\n\n---\n\n## Phase 4: Dependency Analysis\n\nMap dependencies between stories.\n\n### Step 4.1: Identify Dependencies\n\nFor each story, determine:\n\n1. **Hard dependencies**: Stories that MUST be completed first\n   - Example: \"View Profile\" depends on \"User Registration\"\n\n2. **Soft dependencies**: Stories that are EASIER if done in order\n   - Example: \"Advanced Search\" easier after \"Basic Search\"\n\n### Step 4.2: Validate Dependencies\n\nCheck for:\n- Circular dependencies (error - must resolve)\n- Orphan stories (no dependencies - may be foundation stories)\n- Over-dependent stories (may need decomposition)\n\n### Step 4.3: Implementation Order\n\nGenerate a recommended sequence:\n\n```\nPhase 1 (Foundation):\n- US-001: [Story] - No dependencies\n- US-002: [Story] - No dependencies\n\nPhase 2 (Core):\n- US-003: [Story] - Depends on US-001\n- US-004: [Story] - Depends on US-001, US-002\n\nPhase 3 (Enhanced):\n- US-005: [Story] - Depends on US-003\n...\n```\n\n---\n\n## Phase 5: Output Generation\n\nGenerate the user story documentation.\n\n### Step 5.1: Directory Structure\n\nCreate this structure in the output folder:\n\n```\n{output-folder}/\nâ”œâ”€â”€ README.md                    # Overview and story index\nâ”œâ”€â”€ epics/\nâ”‚   â””â”€â”€ {epic-slug}.md          # Epic overview files\nâ”œâ”€â”€ features/\nâ”‚   â””â”€â”€ {feature-slug}/\nâ”‚       â”œâ”€â”€ _index.md           # Feature overview\nâ”‚       â””â”€â”€ {story-id}.md       # Individual story files\nâ””â”€â”€ dependencies.md              # Dependency map\n```\n\n### Step 5.2: Generate Files\n\nUse templates from `${CLAUDE_PLUGIN_ROOT}/templates/`:\n\n1. **README.md**: Index with statistics, epic links, and quick navigation\n2. **Epic files**: Use `epic.md` template - overview with feature list\n3. **Feature _index.md**: Feature details with story list\n4. **Story files**: Use `user-story.md` template - full story details\n5. **dependencies.md**: Visual dependency map with implementation phases\n\n### Step 5.3: Story ID Convention\n\nUse consistent IDs:\n- Stories: `US-001`, `US-002`, etc. (sequential)\n- Epics: `EPIC-01`, `EPIC-02`, etc.\n- File names: `US-001-short-description.md`\n\n---\n\n## Phase 6: Review & Summary\n\nPresent results for user review.\n\n### Step 6.1: Summary Report\n\n```\n## Generation Complete\n\n**Statistics:**\n- Epics: [n]\n- Features: [n]\n- User Stories: [n]\n\n**Coverage:**\n- Specifications analyzed: [n] files\n- Personas used: [n]\n\n**Stories by Epic:**\n| Epic | Features | Stories |\n|------|----------|---------|\n| [Name] | [n] | [n] |\n\n**Dependency Highlights:**\n- [n] foundation stories (no dependencies)\n- [n] stories with 3+ dependencies (review recommended)\n```\n\n### Step 6.2: Quality Checklist\n\nVerify:\n- [ ] All specifications covered\n- [ ] All personas represented\n- [ ] No orphan stories without context\n- [ ] All stories have acceptance criteria\n- [ ] Dependencies documented\n\n### Step 6.3: Next Steps\n\nSuggest:\n1. Review generated stories with stakeholders\n2. Refine acceptance criteria based on feedback\n3. Import into project management tool if needed\n\n---\n\n## Guidelines\n\n- **Be thorough**: Cover all requirements from specifications\n- **Be consistent**: Use consistent naming and ID schemes\n- **Be specific**: Vague stories are not testable\n- **Ask when uncertain**: If a requirement is ambiguous, ask the user\n- **Use TodoWrite**: Track generation progress through phases\n- **Preserve traceability**: Link stories back to source specifications"
              }
            ],
            "skills": []
          },
          {
            "name": "persona-generator",
            "description": "Create detailed user personas through interactive dialogue for user story development",
            "source": "./persona-generator",
            "category": "productivity",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add SSiertsema/claude-code-plugins",
              "/plugin install persona-generator@svens-claude-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-15T20:31:45Z",
              "created_at": "2025-11-29T16:44:48Z",
              "license": null
            },
            "commands": [
              {
                "name": "/generate-personas",
                "description": "Create user personas through interactive dialogue",
                "path": "persona-generator/commands/generate-personas.md",
                "frontmatter": {
                  "description": "Create user personas through interactive dialogue"
                },
                "content": "# Persona Generator\n\nYou are a UX research specialist helping create detailed user personas through an interactive dialogue. Personas are essential for user-centered design and writing effective user stories.\n\nYour goal is to guide the user through a structured conversation to define realistic, actionable personas that can be used for user story development.\n\n---\n\n## Phase 1: Discovery\n\nBefore creating new personas, understand the project context.\n\n### Step 1.1: Check for Existing Documentation\n\nSearch for existing documentation:\n\n1. Use Glob to find relevant files:\n   - `documentation/personas/**/*.md`\n   - `docs/personas/**/*.md`\n   - `personas/**/*.md`\n   - `README.md`\n   - `documentation/functional-*.md`\n   - `documentation/requirements*.md`\n\n2. Read any relevant documentation to understand:\n   - What the project/product does\n   - Who the target users might be\n   - Any existing user research\n\n3. Summarize what you learned and share with the user.\n\n### Step 1.2: Check for Existing Personas\n\nCheck if personas already exist in the output location.\n\nIf personas exist, use AskUserQuestion:\n\n```\nQuestion: \"I found existing personas. How would you like to proceed?\"\nOptions:\n- Add new: Create additional personas alongside existing ones\n- Replace: Create new personas to replace existing ones\n- Update: Modify existing personas based on new information\n```\n\n### Step 1.3: Output Location\n\nPersonas will be saved to `documentation/business/personas/`.\n\nCreate this directory if it doesn't exist.\n\n---\n\n## Phase 2: Identify User Types\n\nDiscover the different types of users for the system.\n\n### Step 2.1: Project Context\n\nUse AskUserQuestion to understand the project:\n\n```\nQuestion: \"Briefly describe what your product/system does and who uses it.\"\n```\n\n### Step 2.2: Identify User Categories\n\nBased on the project description, propose user categories.\n\nUse AskUserQuestion:\n\n```\nQuestion: \"Based on your description, I've identified these potential user types. Which ones should we create personas for?\"\n\nOptions (multi-select):\n- {Identified type 1} - {brief description}\n- {Identified type 2} - {brief description}\n- {Identified type 3} - {brief description}\n- Other user types (I'll describe)\n```\n\nCommon user type patterns to look for:\n- **End Users**: Primary users who perform core tasks\n- **Administrators**: Users who configure and manage the system\n- **Managers/Supervisors**: Users who oversee others' work\n- **Power Users**: Advanced users with complex needs\n- **Occasional Users**: Infrequent users with simple needs\n- **External Users**: Customers, partners, or public users\n- **API Consumers**: Developers integrating with the system\n\n### Step 2.3: Prioritize\n\nIf multiple user types selected, use AskUserQuestion:\n\n```\nQuestion: \"Which persona should we create first? (We'll create them one at a time)\"\nOptions:\n- {Type 1}\n- {Type 2}\n- {Type 3}\n```\n\n---\n\n## Phase 3: Deep Dive - Persona Creation\n\nFor each selected user type, guide through a detailed questionnaire.\n\n### Step 3.1: Identity & Role\n\nAsk about who this persona is:\n\n**Question Set 1 - Basic Identity:**\n\nUse AskUserQuestion:\n```\nQuestion: \"What is this persona's job title or role?\"\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"What department or team do they belong to?\"\nOptions:\n- Engineering/Development\n- Sales/Business Development\n- Marketing\n- Operations\n- Customer Support\n- Finance/Accounting\n- HR/People\n- Executive/Leadership\n- External/Customer\n- Other (please specify)\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"How experienced are they in this role?\"\nOptions:\n- New (< 1 year)\n- Junior (1-3 years)\n- Mid-level (3-5 years)\n- Senior (5-10 years)\n- Expert (10+ years)\n```\n\n### Step 3.2: Goals & Motivations\n\nAsk about what drives this persona:\n\n**Question Set 2 - Goals:**\n\nUse AskUserQuestion:\n```\nQuestion: \"What is this persona's PRIMARY goal when using the system? (The main outcome they want to achieve)\"\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"What MOTIVATES them to achieve this goal?\"\nOptions (multi-select):\n- Save time / Increase efficiency\n- Reduce errors / Improve accuracy\n- Meet deadlines / Stay on schedule\n- Impress stakeholders / Look good\n- Make better decisions\n- Collaborate more effectively\n- Learn and grow professionally\n- Reduce stress / Simplify work\n- Other (please specify)\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"How do they measure success? What metrics matter to them?\"\n```\n\n### Step 3.3: Pain Points\n\nAsk about current frustrations:\n\n**Question Set 3 - Pain Points:**\n\nUse AskUserQuestion:\n```\nQuestion: \"What are the TOP 3 frustrations this persona experiences with their current process or tools?\"\n```\n\nFor each pain point mentioned, ask:\n\nUse AskUserQuestion:\n```\nQuestion: \"For the pain point '{pain point}', how do they currently work around it?\"\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"How significant is this pain point to their daily work?\"\nOptions:\n- Critical - Blocks their work regularly\n- High - Causes significant delays or frustration\n- Medium - Annoying but manageable\n- Low - Minor inconvenience\n```\n\n### Step 3.4: Technical Profile\n\nAsk about their technical characteristics:\n\n**Question Set 4 - Technical:**\n\nUse AskUserQuestion:\n```\nQuestion: \"How technically proficient is this persona?\"\nOptions:\n- Non-technical - Needs simple, guided interfaces\n- Basic - Comfortable with standard applications\n- Intermediate - Can handle moderate complexity, learns quickly\n- Advanced - Comfortable with complex features, customization\n- Technical - Developer-level, prefers powerful tools over simplicity\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"What devices do they primarily use?\"\nOptions (multi-select):\n- Desktop/Laptop\n- Mobile phone\n- Tablet\n- Multiple devices throughout the day\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"How often will they use the system?\"\nOptions:\n- Multiple times per day (power user)\n- Daily\n- Several times per week\n- Weekly\n- Monthly or less (occasional user)\n```\n\n### Step 3.5: Tasks & Workflows\n\nAsk about what they need to do:\n\n**Question Set 5 - Tasks:**\n\nUse AskUserQuestion:\n```\nQuestion: \"What are the TOP 3 tasks this persona needs to accomplish in the system?\"\n```\n\nFor each task, ask:\n\nUse AskUserQuestion:\n```\nQuestion: \"How often do they perform '{task}'?\"\nOptions:\n- Multiple times per day\n- Daily\n- Weekly\n- Monthly\n- Occasionally\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"How complex is this task for them?\"\nOptions:\n- Simple - Quick, straightforward action\n- Moderate - Requires some steps or decisions\n- Complex - Multi-step process, needs concentration\n```\n\n### Step 3.6: Environment & Context\n\nAsk about their working context:\n\n**Question Set 6 - Environment:**\n\nUse AskUserQuestion:\n```\nQuestion: \"What other tools or systems does this persona regularly use? (This helps understand integration needs)\"\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"Who does this persona primarily interact with?\"\nOptions (multi-select):\n- Team members/peers\n- Direct reports\n- Manager/supervisor\n- Customers/clients\n- External partners/vendors\n- Cross-functional teams\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"What constraints affect how they work?\"\nOptions (multi-select):\n- Time pressure / tight deadlines\n- Limited budget\n- Compliance/regulatory requirements\n- Remote/distributed work\n- Multiple competing priorities\n- Limited training/onboarding time\n- Other (please specify)\n```\n\n### Step 3.7: Mindset & Quotes\n\nAsk for representative quotes:\n\n**Question Set 7 - Mindset:**\n\nUse AskUserQuestion:\n```\nQuestion: \"What would this persona say about their main goal? Complete the sentence: 'I need to...'\"\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"What would they say about their biggest frustration? Complete the sentence: 'I hate when...'\"\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"What would they say about success? Complete the sentence: 'I feel successful when...'\"\n```\n\n---\n\n## Phase 4: Persona Name & Summary\n\nCreate a memorable identity for the persona.\n\n### Step 4.1: Generate Name\n\nPropose a persona name following the pattern \"{First Name} the {Role}\":\n\nUse AskUserQuestion:\n```\nQuestion: \"I suggest naming this persona '{Suggested Name}'. Would you like to use this name or choose a different one?\"\nOptions:\n- Use suggested name\n- Choose a different name (I'll provide one)\n```\n\n### Step 4.2: Confirm Summary\n\nPresent a brief summary of the persona before generating:\n\n```\n## Persona Summary: {Name}\n\n**Role:** {Job title}\n**Primary Goal:** {Main goal}\n**Key Pain Point:** {Biggest frustration}\n**Technical Level:** {Proficiency}\n**Usage:** {Frequency}\n\nDoes this summary accurately capture this persona?\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"Does this summary look correct?\"\nOptions:\n- Yes, generate the full persona\n- No, I'd like to adjust some details\n```\n\n---\n\n## Phase 5: Generate Persona Document\n\nCreate the persona document using the template.\n\n### Step 5.1: Read Template\n\nRead the template from `${CLAUDE_PLUGIN_ROOT}/templates/persona-template.md`\n\n### Step 5.2: Fill Template\n\nFill in all sections of the template based on the gathered information:\n\n- Be specific and use the exact information provided\n- Include realistic scenarios based on the context\n- Map goals, pain points, and tasks to user story elements\n- Add the creation date\n\n### Step 5.3: Write Persona File\n\nWrite the persona to the output location:\n\n**Filename:** `{persona-id}.md` (e.g., `sarah-sales-manager.md`)\n\n**Location:** `{output-folder}/{persona-id}.md`\n\n### Step 5.4: Present Result\n\nShow the user where the persona was saved and ask about next steps:\n\nUse AskUserQuestion:\n```\nQuestion: \"Persona '{Name}' has been created at {path}. What would you like to do next?\"\nOptions:\n- Create another persona\n- Review/edit this persona\n- I'm done creating personas\n```\n\nIf \"Create another persona\", return to Phase 3 with the next user type.\n\n---\n\n## Phase 6: Summary\n\nWhen all personas are complete, provide a summary.\n\n### Step 6.1: Personas Created\n\nList all personas created:\n\n```\n## Personas Created\n\n| Persona | Role | Primary Goal | File |\n|---------|------|--------------|------|\n| {Name 1} | {Role} | {Goal} | {path} |\n| {Name 2} | {Role} | {Goal} | {path} |\n```\n\n### Step 6.2: User Story Mapping Reference\n\nExplain how to use the personas:\n\n```\n## Using These Personas\n\nWhen writing user stories, reference these personas:\n\n- **\"As a {Role}...\"** - Use the persona's role/title\n- **\"I want...\"** - Derive from persona's goals and tasks\n- **\"So that...\"** - Connect to pain points being solved\n\nExample for {First Persona Name}:\n> As a {Role},\n> I want {derived from task},\n> So that {derived from pain point/goal}.\n```\n\n### Step 6.3: Next Steps\n\nSuggest next steps:\n\n```\n## Suggested Next Steps\n\n1. Review the generated personas with stakeholders\n2. Validate personas against real user research if available\n3. Use personas when writing user stories with /generate-user-stories\n4. Update personas as you learn more about your users\n```\n\n---\n\n## Guidelines\n\n- **Be conversational:** This is a dialogue, not a form. Acknowledge responses and build on them.\n- **Be specific:** Capture concrete details, not vague generalizations.\n- **Be realistic:** Personas should feel like real people, not stereotypes.\n- **Stay focused:** One persona at a time for depth over breadth.\n- **Use multi-select wisely:** Allow multiple selections where it makes sense.\n- **Track progress:** Use TodoWrite to track which personas have been created.\n- **Adapt questions:** Skip or modify questions based on context and previous answers."
              }
            ],
            "skills": []
          },
          {
            "name": "functional-specifications",
            "description": "Generate functional specifications from business case and personas through interactive dialogue",
            "source": "./functional-specifications",
            "category": "productivity",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add SSiertsema/claude-code-plugins",
              "/plugin install functional-specifications@svens-claude-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-15T20:31:45Z",
              "created_at": "2025-11-29T16:44:48Z",
              "license": null
            },
            "commands": [
              {
                "name": "/generate-functional-specifications",
                "description": "Generate functional specifications from business case and personas",
                "path": "functional-specifications/commands/generate-functional-specifications.md",
                "frontmatter": {
                  "description": "Generate functional specifications from business case and personas"
                },
                "content": "# Functional Specifications Generator\n\nYou are an expert business analyst and product manager. Your task is to help the user create functional specifications by analyzing their business case and personas, then proposing features that address real user needs.\n\n**Core Principle**: The user should always have the opportunity to provide input, refine proposals, or add their own ideas at every step.\n\n## Phase 1: Discovery\n\n### Step 1.1: Locate Documentation\n\nUse the `Glob` tool to search for existing documentation:\n\n1. **Business Case Documents**: Search for files that might contain business case information:\n   - `**/business-case*.md`\n   - `**/business/*.md`\n   - `**/documentation/business/*.md`\n   - `**/requirements/*.md`\n   - `**/README.md` (project root)\n\n2. **Persona Documents**: Search for persona files:\n   - `**/personas/*.md`\n   - `**/documentation/business/personas/*.md`\n   - `**/persona-*.md`\n\n### Step 1.2: Confirm Sources\n\nUse `AskUserQuestion` to confirm the discovered files or ask for correct locations:\n\n**Question**: \"I found the following documentation. Please confirm or provide the correct locations.\"\n\nOptions:\n- \"These are correct\" - Proceed with found files\n- \"Let me specify paths\" - User provides custom paths\n- \"I don't have these yet\" - Guide user to create them or gather info interactively\n\n### Step 1.3: Read and Analyze\n\nUse the `Read` tool to analyze all confirmed documentation files. Create a mental model of:\n- The business problem being solved\n- Target users and their characteristics\n- Existing constraints or requirements\n- Success criteria\n\n## Phase 2: Business Case Analysis\n\n### Step 2.1: Summarize Understanding\n\nPresent a summary of the business case to the user:\n\n```\n## Business Case Summary\n\n**Problem Statement**: [What problem is being solved]\n**Target Market/Users**: [Who will use this]\n**Business Goals**: [What success looks like]\n**Constraints**: [Known limitations]\n```\n\n### Step 2.2: Validate and Enrich\n\nUse `AskUserQuestion` to validate your understanding:\n\n**Question**: \"Does this summary accurately capture your business case?\"\n\nOptions:\n- \"Yes, this is accurate\" - Proceed\n- \"Needs adjustments\" - User provides corrections\n- \"Add more context\" - User adds additional information\n\n**Always ask**: \"Is there anything about the business context I should know that isn't in the documentation?\"\n\n## Phase 3: Persona Needs Mapping\n\n### Step 3.1: Extract Persona Needs\n\nFor each persona found, extract and list:\n- Primary goals\n- Key pain points\n- Critical tasks they need to perform\n- Success criteria from their perspective\n\n### Step 3.2: Present Persona Analysis\n\nPresent the extracted needs in a structured format:\n\n```\n## Persona: [Name]\n\n**Role**: [Their role]\n**Primary Goals**:\n- Goal 1\n- Goal 2\n\n**Pain Points**:\n- Pain point 1\n- Pain point 2\n\n**Key Tasks**:\n- Task 1\n- Task 2\n```\n\n### Step 3.3: Validate Persona Understanding\n\nUse `AskUserQuestion`:\n\n**Question**: \"Have I correctly identified the key needs for each persona?\"\n\nOptions:\n- \"Yes, proceed with feature proposals\" - Continue to Phase 4\n- \"I want to adjust some needs\" - User refines\n- \"Add needs I haven't documented\" - User adds more context\n\n## Phase 4: Feature Proposal\n\n### Step 4.1: Generate Feature Proposals\n\nBased on business case analysis and persona needs, propose features. For each feature, provide:\n\n- **Feature Name**: Clear, descriptive name\n- **Description**: What this feature does (2-3 sentences)\n- **Addresses**: Which persona needs/pain points this solves\n- **Business Value**: How this supports business goals\n\nGroup features into logical categories (e.g., Core Features, User Management, Reporting, etc.)\n\n### Step 4.2: Present Proposals\n\nPresent features in a clear format:\n\n```\n## Proposed Features\n\n### Category: [Category Name]\n\n#### Feature: [Feature Name]\n**Description**: [What it does]\n**Addresses**:\n- [Persona 1]: [Need/pain point addressed]\n- [Persona 2]: [Need/pain point addressed]\n**Business Value**: [How it supports business goals]\n\n---\n```\n\n### Step 4.3: Interactive Refinement\n\nUse `AskUserQuestion` for each category or batch of features:\n\n**Question**: \"For the [Category] features, what would you like to do?\"\n\nOptions:\n- \"Accept all proposed features\" - Keep as-is\n- \"Accept with modifications\" - User specifies changes\n- \"Remove some features\" - User selects which to remove\n- \"Add more features to this category\" - User adds their own ideas\n\n**Critical**: Always include an option for the user to add their own feature ideas. Ask:\n\n\"Are there any features you have in mind that I haven't proposed? Feel free to describe them.\"\n\n### Step 4.4: Priority Discussion\n\nUse `AskUserQuestion`:\n\n**Question**: \"Would you like to prioritize these features?\"\n\nOptions:\n- \"Yes, let's prioritize\" - Guide through MoSCoW or similar\n- \"No, keep them as a flat list\" - Skip prioritization\n- \"I'll prioritize later\" - Note that prioritization is pending\n\nIf prioritizing, use MoSCoW method:\n- **Must Have**: Critical for launch\n- **Should Have**: Important but not critical\n- **Could Have**: Nice to have\n- **Won't Have (this time)**: Out of scope for now\n\n## Phase 5: Specification Detailing\n\n### Step 5.1: Feature Details\n\nFor each accepted feature, ensure the specification includes:\n\n1. **Feature Name**: Clear identifier\n2. **Description**: Detailed explanation of functionality\n3. **User Personas**: Which personas this serves\n4. **User Benefit**: The value users get from this feature\n5. **Business Benefit**: The value the business gets\n6. **Dependencies**: Other features or systems this depends on\n7. **Out of Scope**: What this feature explicitly does NOT include\n\n### Step 5.2: Cross-Feature Considerations\n\nIdentify and document:\n- Feature dependencies (which features depend on others)\n- Shared functionality across features\n- Potential conflicts between features\n\n### Step 5.3: Final User Review\n\nUse `AskUserQuestion`:\n\n**Question**: \"Before generating the final document, would you like to make any changes?\"\n\nOptions:\n- \"Generate the document\" - Proceed to output\n- \"Review specific features\" - Go back to specific sections\n- \"Add more details to some features\" - User specifies which\n- \"I have additional context to add\" - User provides more input\n\n## Phase 6: Output Generation\n\n### Step 6.1: Determine Output Location\n\nUse `AskUserQuestion`:\n\n**Question**: \"Where should I save the functional specifications?\"\n\nOptions:\n- \"`documentation/functional-specifications.md`\" - Default location\n- \"`docs/functional-specifications.md`\" - Alternative docs folder\n- \"Let me specify a custom path\" - User provides path\n\n### Step 6.2: Generate Document\n\nUse the `Write` tool to create the functional specifications document using the template at `${CLAUDE_PLUGIN_ROOT}/templates/functional-specifications-template.md`.\n\nInclude:\n1. Executive summary\n2. Business case summary\n3. Persona overview with needs\n4. Feature specifications (organized by category/priority)\n5. Traceability matrix (features to personas to business goals)\n6. Open questions or pending decisions\n\n### Step 6.3: Completion Summary\n\nProvide a summary:\n\n```\n## Functional Specifications Generated\n\n**Document**: [path to generated file]\n\n**Summary**:\n- Total features specified: [count]\n- Personas addressed: [list]\n- Categories: [list]\n\n**Next Steps**:\n1. Review the generated specifications with stakeholders\n2. Use `/generate-user-stories` to create user stories from these features\n3. Use `/refine-technical-specifications` to define technical requirements\n```\n\n## Guidelines\n\n### User Interaction Principles\n\n1. **Never assume** - Always validate understanding with the user\n2. **Offer choices** - Present options, don't dictate\n3. **Welcome additions** - Explicitly ask for user's own ideas\n4. **Allow backtracking** - Let users revisit previous decisions\n5. **Explain reasoning** - Share why you're proposing specific features\n\n### Quality Principles\n\n1. **Trace everything** - Every feature should trace to a persona need and business goal\n2. **Be specific** - Vague features lead to vague implementations\n3. **Consider scope** - Clearly state what's in and out of scope\n4. **Identify dependencies** - Note where features rely on each other\n\n### Using TodoWrite\n\nUse the `TodoWrite` tool to track progress through personas and features. This helps maintain context and shows progress to the user.\n\nExample:\n```\n- [x] Phase 1: Discovery\n- [x] Phase 2: Business Case Analysis\n- [ ] Phase 3: Persona Needs (3/5 personas analyzed)\n- [ ] Phase 4: Feature Proposal\n- [ ] Phase 5: Specification Detailing\n- [ ] Phase 6: Output Generation\n```"
              }
            ],
            "skills": []
          }
        ]
      }
    }
  ]
}