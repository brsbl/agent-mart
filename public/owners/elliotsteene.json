{
  "owner": {
    "id": "elliotsteene",
    "display_name": "elliotsteene",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/106337375?v=4",
    "url": "https://github.com/elliotsteene",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 1,
      "total_commands": 3,
      "total_skills": 2,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "elliotsteene/claude-code",
      "url": "https://github.com/elliotsteene/claude-code",
      "description": "Contains my claude code commands and sub-agents",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-12-12T15:01:44Z",
        "created_at": "2025-12-03T17:56:39Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 700
        },
        {
          "path": "CLAUDE.md",
          "type": "blob",
          "size": 10248
        },
        {
          "path": "LICENSE",
          "type": "blob",
          "size": 1069
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 3783
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/workflow-toolkit",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/workflow-toolkit/.gitignore",
          "type": "blob",
          "size": 175
        },
        {
          "path": "plugins/workflow-toolkit/INSTALLATION.md",
          "type": "blob",
          "size": 5268
        },
        {
          "path": "plugins/workflow-toolkit/LICENSE",
          "type": "blob",
          "size": 1069
        },
        {
          "path": "plugins/workflow-toolkit/README.md",
          "type": "blob",
          "size": 12185
        },
        {
          "path": "plugins/workflow-toolkit/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/workflow-toolkit/agents/codebase-analyser.md",
          "type": "blob",
          "size": 5659
        },
        {
          "path": "plugins/workflow-toolkit/agents/codebase-locator.md",
          "type": "blob",
          "size": 4821
        },
        {
          "path": "plugins/workflow-toolkit/agents/codebase-pattern-finder.md",
          "type": "blob",
          "size": 6939
        },
        {
          "path": "plugins/workflow-toolkit/agents/thoughts-analyser.md",
          "type": "blob",
          "size": 5203
        },
        {
          "path": "plugins/workflow-toolkit/agents/thoughts-locator.md",
          "type": "blob",
          "size": 5055
        },
        {
          "path": "plugins/workflow-toolkit/agents/ticket-writer.md",
          "type": "blob",
          "size": 10230
        },
        {
          "path": "plugins/workflow-toolkit/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/workflow-toolkit/commands/create_plan.md",
          "type": "blob",
          "size": 19813
        },
        {
          "path": "plugins/workflow-toolkit/commands/implement_plan.md",
          "type": "blob",
          "size": 9688
        },
        {
          "path": "plugins/workflow-toolkit/commands/research_codebase.md",
          "type": "blob",
          "size": 10582
        },
        {
          "path": "plugins/workflow-toolkit/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/workflow-toolkit/hooks/hooks.json",
          "type": "blob",
          "size": 1273
        },
        {
          "path": "plugins/workflow-toolkit/plugin.json",
          "type": "blob",
          "size": 511
        },
        {
          "path": "plugins/workflow-toolkit/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/workflow-toolkit/scripts/run_silent.sh",
          "type": "blob",
          "size": 2161
        },
        {
          "path": "plugins/workflow-toolkit/scripts/smart_wrap.sh",
          "type": "blob",
          "size": 2936
        },
        {
          "path": "plugins/workflow-toolkit/scripts/spec_metadata.sh",
          "type": "blob",
          "size": 1256
        },
        {
          "path": "plugins/workflow-toolkit/scripts/validate_dependencies.sh",
          "type": "blob",
          "size": 1339
        },
        {
          "path": "plugins/workflow-toolkit/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/workflow-toolkit/skills/silent-execution",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/workflow-toolkit/skills/silent-execution/SKILL.md",
          "type": "blob",
          "size": 6004
        },
        {
          "path": "plugins/workflow-toolkit/skills/stacked-pr",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/workflow-toolkit/skills/stacked-pr/SKILL.md",
          "type": "blob",
          "size": 8929
        },
        {
          "path": "plugins/workflow-toolkit/skills/stacked-pr/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/workflow-toolkit/skills/stacked-pr/scripts/append-stack.sh",
          "type": "blob",
          "size": 1982
        },
        {
          "path": "plugins/workflow-toolkit/skills/stacked-pr/scripts/new-stack.sh",
          "type": "blob",
          "size": 1804
        }
      ],
      "marketplace": {
        "name": "custom-tools",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "Elliot Steene",
          "email": "e.steene@hotmail.co.uk"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "workflow-toolkit",
            "description": "Comprehensive development workflow system for codebase research, implementation planning, and stacked PR management through specialized AI agents",
            "source": "./plugins/workflow-toolkit",
            "category": null,
            "version": "0.1.3",
            "author": {
              "name": "Elliot Steene",
              "email": "e.steene@hotmail.co.uk"
            },
            "install_commands": [
              "/plugin marketplace add elliotsteene/claude-code",
              "/plugin install workflow-toolkit@custom-tools"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-12T15:01:44Z",
              "created_at": "2025-12-03T17:56:39Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/create_plan",
                "description": "Create detailed implementation plans through interactive research and iteration",
                "path": "plugins/workflow-toolkit/commands/create_plan.md",
                "frontmatter": {
                  "description": "Create detailed implementation plans through interactive research and iteration",
                  "model": "opus"
                },
                "content": "# Implementation Plan\n\nYou are tasked with creating detailed implementation plans through an interactive, iterative process. You should be skeptical, thorough, and work collaboratively with the user to produce high-quality technical specifications.\n\n## Initial Response\n\nWhen this command is invoked:\n\n1. **Check if parameters were provided**:\n   - If a file path or ticket reference was provided as a parameter, skip the default message\n   - Immediately read any provided files FULLY\n   - Begin the research process\n\n2. **If no parameters provided**, respond with:\n```\nI'll help you create a detailed implementation plan. Let me start by understanding what we're building.\n\nPlease provide:\n1. The task/ticket description (or reference to a ticket file)\n2. Any relevant context, constraints, or specific requirements\n3. Links to related research or previous implementations\n\nI'll analyze this information and work with you to create a comprehensive plan.\n\nTip: You can also invoke this command with a ticket file directly: `/create_plan thoughts/elliot/tickets/eng_1234.md`\nFor deeper analysis, try: `/create_plan think deeply about thoughts/elliot/tickets/eng_1234.md`\n```\n\nThen wait for the user's input.\n\n## Process Steps\n\n### Step 1: Context Gathering & Initial Analysis\n\n1. **Read all mentioned files immediately and FULLY**:\n   - Ticket files (e.g., `thoughts/elliot/tickets/eng_1234.md`)\n   - Research documents\n   - Related implementation plans\n   - Any JSON/data files mentioned\n   - **IMPORTANT**: Use the Read tool WITHOUT limit/offset parameters to read entire files\n   - **CRITICAL**: DO NOT spawn sub-tasks before reading these files yourself in the main context\n   - **NEVER** read files partially - if a file is mentioned, read it completely\n\n2. **Spawn initial research tasks to gather context**:\n   Before asking the user any questions, use specialized agents to research in parallel:\n\n   - Use the **codebase-locator** agent to find all files related to the ticket/task\n   - Use the **codebase-analyzer** agent to understand how the current implementation works\n   - If relevant, use the **thoughts-locator** agent to find any existing thoughts documents about this feature\n\n   These agents will:\n   - Find relevant source files, configs, and tests\n   - Identify the specific directories to focus on (e.g., if WUI is mentioned, they'll focus on humanlayer-wui/)\n   - Trace data flow and key functions\n   - Return detailed explanations with file:line references\n\n3. **Read all files identified by research tasks**:\n   - After research tasks complete, read ALL files they identified as relevant\n   - Read them FULLY into the main context\n   - This ensures you have complete understanding before proceeding\n\n4. **Analyze and verify understanding**:\n   - Cross-reference the ticket requirements with actual code\n   - Identify any discrepancies or misunderstandings\n   - Note assumptions that need verification\n   - Determine true scope based on codebase reality\n\n5. **Present informed understanding and focused questions**:\n   ```\n   Based on the ticket and my research of the codebase, I understand we need to [accurate summary].\n\n   I've found that:\n   - [Current implementation detail with file:line reference]\n   - [Relevant pattern or constraint discovered]\n   - [Potential complexity or edge case identified]\n\n   Questions that my research couldn't answer:\n   - [Specific technical question that requires human judgment]\n   - [Business logic clarification]\n   - [Design preference that affects implementation]\n   ```\n\n   Only ask questions that you genuinely cannot answer through code investigation.\n\n### Step 2: Research & Discovery\n\nAfter getting initial clarifications:\n\n1. **If the user corrects any misunderstanding**:\n   - DO NOT just accept the correction\n   - Spawn new research tasks to verify the correct information\n   - Read the specific files/directories they mention\n   - Only proceed once you've verified the facts yourself\n\n2. **Create a research todo list** using TodoWrite to track exploration tasks\n\n3. **Spawn parallel sub-tasks for comprehensive research**:\n   - Create multiple Task agents to research different aspects concurrently\n   - Use the right agent for each type of research:\n\n   **For deeper investigation:**\n   - **codebase-locator** - To find more specific files (e.g., \"find all files that handle [specific component]\")\n   - **codebase-analyzer** - To understand implementation details (e.g., \"analyze how [system] works\")\n   - **codebase-pattern-finder** - To find similar features we can model after\n\n   **For historical context:**\n   - **thoughts-locator** - To find any research, plans, or decisions about this area\n   - **thoughts-analyzer** - To extract key insights from the most relevant documents\n\n   Each agent knows how to:\n   - Find the right files and code patterns\n   - Identify conventions and patterns to follow\n   - Look for integration points and dependencies\n   - Return specific file:line references\n   - Find tests and examples\n\n3. **Wait for ALL sub-tasks to complete** before proceeding\n\n4. **Present findings and design options**:\n   ```\n   Based on my research, here's what I found:\n\n   **Current State:**\n   - [Key discovery about existing code]\n   - [Pattern or convention to follow]\n\n   **Design Options:**\n   1. [Option A] - [pros/cons]\n   2. [Option B] - [pros/cons]\n\n   **Open Questions:**\n   - [Technical uncertainty]\n   - [Design decision needed]\n\n   Which approach aligns best with your vision?\n   ```\n\n### Step 3: Plan Structure Development\n\nOnce aligned on approach:\n\n1. **Create initial plan outline**:\n   ```\n   Here's my proposed plan structure:\n\n   ## Overview\n   [1-2 sentence summary]\n\n   ## Implementation Phases:\n   1. [Phase name] - [what it accomplishes]\n   2. [Phase name] - [what it accomplishes]\n   3. [Phase name] - [what it accomplishes]\n\n   Does this phasing make sense? Should I adjust the order or granularity?\n   ```\n\n   **Stacked PR Phase Design**:\n   Each phase should be optimized for stacked PRs, where each phase typically becomes one PR in the stack:\n\n   - **Single Responsibility**: Each phase accomplishes one clear, cohesive objective\n   - **Independently Mergeable**: Must pass all CI tests and be deployable on its own\n   - **Reviewable Size**: Aim for <300 lines of changes per phase for easier review\n   - **Flexible Granularity**:\n     - Combine trivial phases that are too small to review separately\n     - Split large phases that would be overwhelming to review\n     - Balance between atomic changes and logical coherence\n   - **Clear Dependencies**: Later phases can build on earlier ones, but minimize tight coupling\n   - **One Phase ‚Üí One PR**: Generally each phase becomes one PR, but adjust based on reviewability\n\n   The goal is to make each PR in the stack:\n   - Smaller in scope and easier to review than a monolithic PR\n   - More coherent with a clear, focused purpose\n   - Self-documenting with clear commit messages and PR descriptions\n   - Part of a guided journey through the implementation \n\n2. **Get feedback on structure** before writing details\n\n### Step 4: Detailed Plan Writing\n\nAfter structure approval:\n\n1. **Write the plan** to `thoughts/shared/plans/YYYY-MM-DD-ENG-XXXX-description.md`\n   - Format: `YYYY-MM-DD-ENG-XXXX-description.md` where:\n     - YYYY-MM-DD is today's date\n     - ENG-XXXX is the ticket number (omit if no ticket)\n     - description is a brief kebab-case description\n   - Examples:\n     - With ticket: `2025-01-08-ENG-1478-parent-child-tracking.md`\n     - Without ticket: `2025-01-08-improve-error-handling.md`\n2. **Use this template structure**:\n\n````markdown\n# [Feature/Task Name] Implementation Plan\n\n## Overview\n\n[Brief description of what we're implementing and why]\n\n## Current State Analysis\n\n[What exists now, what's missing, key constraints discovered]\n\n## Desired End State\n\n[A Specification of the desired end state after this plan is complete, and how to verify it]\n\n### Key Discoveries:\n- [Important finding with file:line reference]\n- [Pattern to follow]\n- [Constraint to work within]\n\n## What We're NOT Doing\n\n[Explicitly list out-of-scope items to prevent scope creep]\n\n## Implementation Approach\n\n[High-level strategy and reasoning]\n\n## Stacked PR Strategy\n\nThis plan is designed for implementation using stacked PRs, where each phase becomes one branch/PR in a stack:\n\n- **Phase Sequencing**: Each phase builds on the previous one, allowing reviewers to understand the implementation journey\n- **Independent Review**: Each PR can be reviewed and approved independently while maintaining the stack context\n- **Pause Points**: Manual verification happens after each phase before proceeding to the next\n- **Estimated Scope**: Each phase should be roughly <300 lines of changes for optimal reviewability\n- **Stack Management**: Use the `stacked-pr` skill after completing each phase to maintain the stack\n\n## Phase 1: [Descriptive Name]\n\n### Overview\n[What this phase accomplishes]\n\n### PR Context\n**Stack Position**: First PR in the stack (base: main)\n**Purpose**: [One-sentence description of why this phase is needed]\n**Enables**: [What later phases depend on this foundation]\n**Review Focus**: [What reviewers should pay attention to]\n\n### Changes Required:\n\n#### 1. [Component/File Group]\n**File**: `path/to/file.ext`\n**Changes**: [Summary of changes]\n\n```[language]\n// Specific code to add/modify\n```\n\n### Success Criteria:\n\n#### Automated Verification:\n- [ ] Migration applies cleanly: `make migrate`\n- [ ] Unit tests pass: `make test-component`\n- [ ] Type checking passes: `npm run typecheck`\n- [ ] Linting passes: `make lint`\n- [ ] Integration tests pass: `make test-integration`\n\n#### Manual Verification:\n- [ ] Feature works as expected when tested via UI\n- [ ] Performance is acceptable under load\n- [ ] Edge case handling verified manually\n- [ ] No regressions in related features\n\n**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation from the human that the manual testing was successful before proceeding to the next phase.\n\n---\n\n## Phase 2: [Descriptive Name]\n\n### Overview\n[What this phase accomplishes]\n\n### PR Context\n**Stack Position**: Second PR in the stack (base: phase-1-branch)\n**Purpose**: [One-sentence description of why this phase is needed]\n**Builds On**: [What from Phase 1 this phase uses]\n**Enables**: [What later phases depend on this]\n**Review Focus**: [What reviewers should pay attention to]\n\n### Changes Required:\n\n[Similar structure with file changes, automated and manual success criteria...]\n\n---\n\n## Testing Strategy\n\n### Unit Tests:\n- [What to test]\n- [Key edge cases]\n\n### Integration Tests:\n- [End-to-end scenarios]\n\n### Manual Testing Steps:\n1. [Specific step to verify feature]\n2. [Another verification step]\n3. [Edge case to test manually]\n\n## Performance Considerations\n\n[Any performance implications or optimizations needed]\n\n## Migration Notes\n\n[If applicable, how to handle existing data/systems]\n\n## References\n\n- Original ticket: `thoughts/elliot/tickets/eng_XXXX.md`\n- Related research: `thoughts/shared/research/[relevant].md`\n- Similar implementation: `[file:line]`\n````\n\n### Step 5: Sync and Review\n\n1. **Sync the thoughts directory**:\n   - Run `just hl-sync` to sync the newly created plan\n   - This ensures the plan is properly indexed and available\n\n2. **Present the draft plan location**:\n   ```\n   I've created the initial implementation plan at:\n   `thoughts/shared/plans/YYYY-MM-DD-ENG-XXXX-description.md`\n\n   Please review it and let me know:\n   - Are the phases properly scoped?\n   - Are the success criteria specific enough?\n   - Any technical details that need adjustment?\n   - Missing edge cases or considerations?\n   ```\n\n3. **Iterate based on feedback** - be ready to:\n   - Add missing phases\n   - Adjust technical approach\n   - Clarify success criteria (both automated and manual)\n   - Add/remove scope items\n   - After making changes, run `just hl-sync` again\n\n4. **Continue refining** until the user is satisfied\n\n## Important Guidelines\n\n1. **Be Skeptical**:\n   - Question vague requirements\n   - Identify potential issues early\n   - Ask \"why\" and \"what about\"\n   - Don't assume - verify with code\n\n2. **Be Interactive**:\n   - Don't write the full plan in one shot\n   - Get buy-in at each major step\n   - Allow course corrections\n   - Work collaboratively\n\n3. **Design for Stacked PRs**:\n   - Each phase becomes a branch and PR in a stack, making reviews easier\n   - **Phase Boundaries**: Split work to maximize reviewability and testability\n     - Aim for <300 lines of changes per phase as a rough guideline\n     - Each phase must pass CI independently (tests, linting, type checks)\n     - Balance granularity: combine trivial changes, split overwhelming ones\n   - **Dependency Flow**: Structure phases to tell a story\n     - Early phases: Infrastructure, foundations, data models\n     - Middle phases: Core logic, business rules\n     - Later phases: Integration, UI, polish\n     - Each phase should make sense on its own, even if it enables later work\n   - **Review Journey**: Consider the reviewer's experience\n     - Each PR description explains: \"This PR does X, which enables Y in the next PR\"\n     - Changes should be coherent and focused within each phase\n     - Avoid mixing unrelated concerns in a single phase\n   - **Manual Verification Points**: Build in pause points for testing\n     - After each phase, automated CI must pass\n     - Manual testing happens before moving to next phase\n     - If issues found: pause, fix in current branch, then continue\n     - The stack should remain rebaseable if early phases need updates\n   - **Avoid Over-Splitting**: Don't break up coherent changes unnecessarily\n     - A small refactor that enables a feature can be in the same phase\n     - Don't separate test files from the code they test\n     - Related files (model + store methods + tests) can stay together if reviewable\n\n4. **Be Thorough**:\n   - Read all context files COMPLETELY before planning\n   - Research actual code patterns using parallel sub-tasks\n   - Include specific file paths and line numbers\n   - Write measurable success criteria with clear automated vs manual distinction\n   - automated steps should use `just` whenever possible - for example `just check` instead of `uv run ruff check && uv run ruff format`\n\n5. **Be Practical**:\n   - Focus on incremental, testable changes\n   - Consider migration and rollback\n   - Think about edge cases\n   - Include \"what we're NOT doing\"\n\n6. **Track Progress**:\n   - Use TodoWrite to track planning tasks\n   - Update todos as you complete research\n   - Mark planning tasks complete when done\n\n7. **No Open Questions in Final Plan**:\n   - If you encounter open questions during planning, STOP\n   - Research or ask for clarification immediately\n   - Do NOT write the plan with unresolved questions\n   - The implementation plan must be complete and actionable\n   - Every decision must be made before finalizing the plan\n\n## Success Criteria Guidelines\n\n**Always separate success criteria into two categories:**\n\n1. **Automated Verification** (can be run by execution agents):\n   - Commands that can be run: `just tests`, `just check`, etc.\n   - Specific files that should exist\n   - Code compilation/type checking\n   - Automated test suites\n\n2. **Manual Verification** (requires human testing):\n   - UI/UX functionality\n   - Performance under real conditions\n   - Edge cases that are hard to automate\n   - User acceptance criteria\n\n**Context Efficiency in Success Criteria:**\n- ‚úÖ Always use `just` commands (they have backpressure built-in)\n- ‚úÖ Prefer `just check-test` over individual commands\n- ‚úÖ Use `just tests` instead of `uv run pytest`\n- ‚ùå Avoid raw commands that produce verbose output\n\n**Format example:**\n```markdown\n### Success Criteria:\n\n#### Automated Verification:\n- [ ] All tests pass: `just tests`\n- [ ] Linting and formatting pass: `just check`\n- [ ] Full verification passes: `just check-test`\n- [ ] Specific component works: `just test tests/test_component.py`\n\n#### Manual Verification:\n- [ ] New feature appears correctly in the UI\n- [ ] Performance is acceptable with 1000+ items\n- [ ] Error messages are user-friendly\n- [ ] Feature works correctly on mobile devices\n```\n\n## Common Patterns\n\n### For Database Changes (Stacked PR Approach):\n**Phase 1**: Schema/migration + tests (foundation)\n**Phase 2**: Store methods + unit tests (data access layer)\n**Phase 3**: Business logic updates (application layer)\n**Phase 4**: API endpoints + integration tests (interface layer)\n**Phase 5**: Client updates (consumer layer)\n\n*Each phase is independently testable and deployable*\n\n### For New Features (Stacked PR Approach):\n**Phase 1**: Research + data model definition + tests (foundation)\n**Phase 2**: Core backend logic + unit tests (business logic)\n**Phase 3**: API endpoints + integration tests (interface)\n**Phase 4**: UI implementation + component tests (presentation)\n**Phase 5**: End-to-end tests + documentation (validation)\n\n*Each phase adds value and can be reviewed independently*\n\n### For Refactoring (Stacked PR Approach):\n**Phase 1**: Add tests for current behavior (safety net)\n**Phase 2**: Extract/refactor internal implementation (no API changes)\n**Phase 3**: Update API surface if needed (interface changes)\n**Phase 4**: Update consumers + deprecation notices (migration)\n**Phase 5**: Remove old code (cleanup)\n\n*Each phase maintains backwards compatibility until Phase 5*\n\n### General Stacked PR Patterns:\n- **Infrastructure-First**: Set up shared utilities, types, or configs before features that use them\n- **Backend-Before-Frontend**: API endpoints before UI that consumes them\n- **Tests-With-Code**: Include tests in the same phase as the code they test\n- **Migrations-Early**: Database changes in early phases, before logic that depends on them\n- **Integration-Late**: Integration and E2E tests after individual components are solid\n\n## Sub-task Spawning Best Practices\n\nWhen spawning research sub-tasks:\n\n1. **Spawn multiple tasks in parallel** for efficiency\n2. **Each task should be focused** on a specific area\n3. **Provide detailed instructions** including:\n   - Exactly what to search for\n   - Which directories to focus on\n   - What information to extract\n   - Expected output format\n4. **Be EXTREMELY specific about directories**:\n   - Never use generic terms like \"UI\" when you mean \"WUI\"\n   - Include the full path context in your prompts\n5. **Specify read-only tools** to use\n6. **Request specific file:line references** in responses\n7. **Wait for all tasks to complete** before synthesizing\n8. **Verify sub-task results**:\n   - If a sub-task returns unexpected results, spawn follow-up tasks\n   - Cross-check findings against the actual codebase\n   - Don't accept results that seem incorrect\n\nExample of spawning multiple tasks:\n```python\n# Spawn these tasks concurrently:\ntasks = [\n    Task(\"Research database schema\", db_research_prompt),\n    Task(\"Find API patterns\", api_research_prompt),\n    Task(\"Investigate UI components\", ui_research_prompt),\n    Task(\"Check test patterns\", test_research_prompt)\n]\n```\n\n## Example Interaction Flow\n\n```\nUser: /implementation_plan\nAssistant: I'll help you create a detailed implementation plan...\n\nUser: We need to add parent-child tracking for Claude sub-tasks. See thoughts/elliot/tickets/eng_1478.md\nAssistant: Let me read that ticket file completely first...\n\n[Reads file fully]\n\nBased on the ticket, I understand we need to track parent-child relationships for Claude sub-task events in the hld daemon. Before I start planning, I have some questions...\n\n[Interactive process continues...]\n```"
              },
              {
                "name": "/implement_plan",
                "description": "Implement technical plans from thoughts/shared/plans with verification",
                "path": "plugins/workflow-toolkit/commands/implement_plan.md",
                "frontmatter": {
                  "description": "Implement technical plans from thoughts/shared/plans with verification"
                },
                "content": "# Implement Plan\n\nYou are tasked with implementing an approved technical plan from `thoughts/shared/plans/`. These plans contain phases with specific changes and success criteria.\n\n## Getting Started\n\nWhen given a plan path:\n- Ensure that the latest version of the plan is loaded - run `just hl-sync`\n- Read the plan completely and check for any existing checkmarks (- [x])\n- Read the original ticket and all files mentioned in the plan\n- **Read files fully** - never use limit/offset parameters, you need complete context\n- **Check current git branch** - determine if you're resuming an in-progress stack or starting fresh\n- Understand the stacked PR workflow: each phase becomes one PR in a stack\n- Think deeply about how the pieces fit together\n- Create a todo list to track your progress\n- Start implementing if you understand what needs to be done\n\nIf no plan path provided, ask for one.\n\n### Understanding the Stacked PR Workflow\n\nThis plan is designed for stacked PRs where:\n- Each phase becomes one branch and one PR\n- Phase 1 is based on `main`\n- Phase N+1 is based on the Phase N branch\n- After completing each phase, you'll use the `stacked-pr` skill to create the PR\n- Each PR can be reviewed independently while maintaining stack context\n\n## Implementation Philosophy\n\nPlans are carefully designed, but reality can be messy. Your job is to:\n- Follow the plan's intent while adapting to what you find\n- Implement each phase fully before moving to the next\n- Verify your work makes sense in the broader codebase context\n- Update checkboxes in the plan as you complete sections\n\nWhen things don't match the plan exactly, think about why and communicate clearly. The plan is your guide, but your judgment matters too.\n\nIf you encounter a mismatch:\n- STOP and think deeply about why the plan can't be followed\n- Present the issue clearly:\n  ```\n  Issue in Phase [N]:\n  Expected: [what the plan says]\n  Found: [actual situation]\n  Why this matters: [explanation]\n\n  How should I proceed?\n  ```\n\n## Context Efficiency (CRITICAL)\n\n**Always prioritize context efficiency** when running verification commands.\n\nContext tokens are precious - successful test runs should show a ‚úì, not 200+ lines of output. Only failures should show full details.\n\n**Quick rules:**\n- ‚úÖ Use `just check-test` for verification (shows ‚úì on success)\n- ‚úÖ Use `just tests` or `just test <path>` for testing\n- ‚úÖ Use `just check` for linting\n- ‚ùå Never use raw `uv run pytest` or `uv run ruff` commands\n- ‚ùå Don't let verbose output consume context tokens\n\n**Why:** Verbose output wastes 2-3% of context per test run. Over multiple iterations, this pushes agents into \"dumb zone\" where important context gets dropped. The real cost is human time when agents lose context.\n\n## Verification Approach\n\nAfter implementing a phase:\n- Run the success criteria checks (`just check-test` covers everything)\n- Fix any issues before proceeding\n- Update your progress in both the plan and your todos\n- Check off completed items in the plan file itself using Edit\n- **Pause for human verification**: After completing all automated verification for a phase, pause and inform the human that the phase is ready for manual testing. Use this format:\n  ```\n  Phase [N] Complete - Ready for Manual Verification\n\n  Automated verification passed:\n  - [List automated checks that passed]\n\n  Please perform the manual verification steps listed in the plan:\n  - [List manual verification items from the plan]\n\n  Let me know when manual testing is complete so I can proceed to create the PR for this phase.\n  ```\n\nIf instructed to execute multiple phases consecutively, skip the pause until the last phase. Otherwise, assume you are just doing one phase.\n\nDo not check off items in the manual testing steps until confirmed by the user.\n\n### After Manual Verification Confirmation\n\nOnce the user confirms manual verification is complete:\n1. **Invoke the stacked-pr skill** to commit changes and create the PR\n2. Check the current branch to determine phase type (see Phase Completion section below)\n3. Extract PR context from the plan's \"PR Context\" section for this phase\n4. After PR is created, ask if you should proceed to the next phase\n\n## Phase Completion and Stacked PRs\n\nEach phase you complete becomes one PR in a stack. This section explains how to use the `stacked-pr` skill to commit your changes and create PRs.\n\n### When to Invoke the Stacked PR Skill\n\nInvoke the `stacked-pr` skill **only** when:\n- ‚úÖ All automated verification has passed (`just check-test`)\n- ‚úÖ User has confirmed manual verification is complete\n- ‚úÖ There are uncommitted changes in the working directory\n- ‚úÖ You're ready to create a PR for this phase\n\n**DO NOT** invoke it:\n- ‚ùå Before verification is complete\n- ‚ùå When there are no changes to commit\n- ‚ùå Before user confirms manual testing\n\n### Preparing the PR Information\n\nBefore invoking the skill, extract information from the plan:\n\n1. **Phase Number**: From the phase heading (e.g., \"Phase 1\", \"Phase 2\")\n2. **Branch Name**: Create from the phase title\n   - Format: Short kebab-case description (e.g., `websocket-foundation`, `message-parser`)\n   - Extract from the phase's \"Descriptive Name\" in the plan\n3. **Commit Message**: Structured format:\n   ```\n   <type>: <phase-summary>\n\n   Phase N: <detailed-description>\n\n   Changes:\n   - <key change 1>\n   - <key change 2>\n   - <key change 3>\n\n   <any relevant context from the plan>\n   ```\n   Types: `feat`, `fix`, `refactor`, `test`, `chore`, `docs`\n\n4. **PR Title**: Format: `Phase N: <Descriptive Name>`\n   - Example: `Phase 1: WebSocket Connection Foundation`\n\n5. **PR Body**: Use the plan's \"PR Context\" section as a guide:\n   ```markdown\n   ## Phase N: <Title>\n\n   ### Summary\n   <1-2 sentence overview from the plan's \"Purpose\">\n\n   ### Changes\n   - <list key changes from the plan's \"Changes Required\" section>\n\n   ### Stack Context\n   <Information from the plan's \"Enables\" and \"Builds On\" fields>\n\n   ### Stack\n   <!-- branch-stack -->\n\n   ### Verification\n   - [x] All automated tests passed (`just check-test`)\n   - [x] Manual verification completed\n   - [x] Code follows project patterns\n\n   ### Related\n   Part of implementation plan: [plan file path]\n\n   ---\n   ü§ñ Generated with [Claude Code](https://claude.com/claude-code)\n   ```\n\n### Example: Invoking the Skill\n\nWhen you're ready to create the PR, simply invoke:\n\n```\nI'm going to use the stacked-pr skill to commit these changes and create the PR.\n```\n\nThen use the Skill tool with `skill: \"stacked-pr\"`. The skill will guide you through the process and execute the appropriate automation script.\n\n### What Happens After PR Creation\n\nAfter the PR is created:\n1. The skill automatically syncs the git-town stack\n2. You're now on a new phase branch (e.g., `phase-1-websocket-foundation`)\n3. The plan checkboxes are updated\n4. You should ask the user if they want to proceed to the next phase\n\nIf proceeding to the next phase:\n- You're already on the correct branch (the previous phase branch)\n- Start implementing the next phase\n- When done, the skill will automatically detect you're on `phase-N-*` and use `append-stack.sh`\n\n### Handling Fixes to Earlier Phases\n\nIf you need to fix something in an earlier phase:\n\n1. **STOP implementation of current phase**\n2. **Inform the user**:\n   ```\n   I've discovered an issue in Phase [N] that needs to be fixed before continuing.\n\n   Issue: [description]\n   Impact: [how it affects current/future phases]\n\n   I recommend:\n   1. Checkout phase-N-<name> branch\n   2. Make the fix\n   3. Re-run verification\n   4. Sync the stack to propagate changes forward\n\n   Should I proceed with this fix?\n   ```\n3. **After user approval**, checkout the earlier phase branch:\n   ```bash\n   git checkout phase-N-<name>\n   ```\n4. **Make the fix**, commit it normally (not via stacked-pr skill)\n5. **Sync the stack** to propagate changes:\n   ```bash\n   git town sync --stack\n   ```\n6. **Return to current phase** and continue\n\n## If You Get Stuck\n\nWhen something isn't working as expected:\n- First, make sure you've read and understood all the relevant code\n- Consider if the codebase has evolved since the plan was written\n- Present the mismatch clearly and ask for guidance\n\nUse sub-tasks sparingly - mainly for targeted debugging or exploring unfamiliar territory.\n\n## Resuming Work\n\nWhen resuming work on a plan that has some phases already completed:\n\n### Step 1: Check Current Branch\n\nRun `git branch --show-current` to see where you are:\n- **On `main`**: Starting fresh, no phases implemented yet\n- **On `phase-N-<name>`**: Phase N is complete, Phase N+1 is next\n- **On a feature branch**: Not in stacked PR mode, check with user\n\n### Step 2: Review Plan Checkmarks\n\nIf the plan has existing checkmarks:\n- Trust that completed work is done\n- Pick up from the first unchecked phase\n- Verify previous work only if something seems off\n- Don't re-implement completed phases\n\n### Step 3: Verify Stack State\n\nCheck if PRs exist for completed phases:\n```bash\ngit branch -a | grep phase-\ngh pr list --search \"Phase\" --state open\n```\n\nThis helps you understand:\n- Which phases have been implemented\n- Which PRs are already created\n- Where to resume work\n\n### Step 4: Resume Implementation\n\n- Start implementing the first uncompleted phase\n- Follow the normal workflow (implement ‚Üí verify ‚Üí manual test ‚Üí stacked-pr skill)\n- The skill will automatically detect your current branch and use the correct script\n\nRemember: You're implementing a solution, not just checking boxes. Keep the end goal in mind and maintain forward momentum."
              },
              {
                "name": "/research_codebase",
                "description": "Document codebase as-is with thoughts directory for historical context",
                "path": "plugins/workflow-toolkit/commands/research_codebase.md",
                "frontmatter": {
                  "description": "Document codebase as-is with thoughts directory for historical context",
                  "model": "opus"
                },
                "content": "# Research Codebase\n\nYou are tasked with conducting comprehensive research across the codebase to answer user questions by spawning parallel sub-agents and synthesizing their findings.\n\n## CRITICAL: YOUR ONLY JOB IS TO DOCUMENT AND EXPLAIN THE CODEBASE AS IT EXISTS TODAY\n- DO NOT suggest improvements or changes unless the user explicitly asks for them\n- DO NOT perform root cause analysis unless the user explicitly asks for them\n- DO NOT propose future enhancements unless the user explicitly asks for them\n- DO NOT critique the implementation or identify problems\n- DO NOT recommend refactoring, optimization, or architectural changes\n- ONLY describe what exists, where it exists, how it works, and how components interact\n- You are creating a technical map/documentation of the existing system\n\n## Initial Setup:\n\nWhen this command is invoked, respond with:\n```\nI'm ready to research the codebase. Please provide your research question or area of interest, and I'll analyze it thoroughly by exploring relevant components and connections.\n```\n\nThen wait for the user's research query.\n\n## Steps to follow after receiving the research query:\n\n1. **Read any directly mentioned files first:**\n   - If the user mentions specific files (tickets, docs, JSON), read them FULLY first\n   - **IMPORTANT**: Use the Read tool WITHOUT limit/offset parameters to read entire files\n   - **CRITICAL**: Read these files yourself in the main context before spawning any sub-tasks\n   - This ensures you have full context before decomposing the research\n\n2. **Analyze and decompose the research question:**\n   - Break down the user's query into composable research areas\n   - Take time to ultrathink about the underlying patterns, connections, and architectural implications the user might be seeking\n   - Identify specific components, patterns, or concepts to investigate\n   - Create a research plan using TodoWrite to track all subtasks\n   - Consider which directories, files, or architectural patterns are relevant\n\n3. **Spawn parallel sub-agent tasks for comprehensive research:**\n   - Create multiple Task agents to research different aspects concurrently\n   - We now have specialized agents that know how to do specific research tasks:\n\n   **For codebase research:**\n   - Use the **codebase-locator** agent to find WHERE files and components live\n   - Use the **codebase-analyser** agent to understand HOW specific code works (without critiquing it)\n   - Use the **codebase-pattern-finder** agent to find examples of existing patterns (without evaluating them)\n\n   **IMPORTANT**: All agents are documentarians, not critics. They will describe what exists without suggesting improvements or identifying issues.\n   \n  **For thoughts directory:**\n  - Use the **thoughts-locator** agent to discover what documents exist about the topic\n  - Use the **thoughts-analyser** agent to extract key insights from specific documents (only the most relevant ones)\n\n   The key is to use these agents intelligently:\n   - Start with locator agents to find what exists\n   - Then use analyzer agents on the most promising findings to document how they work\n   - Run multiple agents in parallel when they're searching for different things\n   - Each agent knows its job - just tell it what you're looking for\n   - Don't write detailed prompts about HOW to search - the agents already know\n   - Remind agents they are documenting, not evaluating or improving\n\n4. **Wait for all sub-agents to complete and synthesize findings:**\n   - IMPORTANT: Wait for ALL sub-agent tasks to complete before proceeding\n   - Compile all sub-agent results (both codebase and thoughts findings)\n   - Prioritize live codebase findings as primary source of truth\n   - Connect findings across different components\n   - Include specific file paths and line numbers for reference\n   - Highlight patterns, connections, and architectural decisions\n   - Answer the user's specific questions with concrete evidence\n\n5. **Gather metadata for the research document:**\n   - Run the `${CLAUDE_PLUGIN_ROOT}/scripts/spec_metadata.sh` script to generate all relevant metadata\n   - Filename: `./thoughts/shared/research/YYYY-MM-DD-ENG-XXXX-description.md`\n     - Format: `YYYY-MM-DD-ENG-XXXX-description.md` where:\n       - YYYY-MM-DD is today's date\n       - ENG-XXXX is the ticket number (omit if no ticket)\n       - description is a brief kebab-case description of the research topic\n     - Examples:\n       - With ticket: `2025-01-08-ENG-1478-parent-child-tracking.md`\n       - Without ticket: `2025-01-08-authentication-flow.md`\n\n6. **Generate research document:**\n   - Use the metadata gathered in step 4\n   - Structure the document with YAML frontmatter followed by content:\n     ```markdown\n     ---\n     date: [Current date and time with timezone in ISO format]\n     researcher: [Current User]\n     git_commit: [Current commit hash]\n     branch: [Current branch name]\n     repository: [Repository name]\n     topic: \"[User's Question/Topic]\"\n     tags: [research, codebase, relevant-component-names]\n     status: complete\n     last_updated: [Current date in YYYY-MM-DD format]\n     last_updated_by: [Researcher name]\n     ---\n\n     # Research: [User's Question/Topic]\n\n     **Date**: [Current date and time with timezone from step 4]\n     **Researcher**: [Current User]\n     **Git Commit**: [Current commit hash from step 4]\n     **Branch**: [Current branch name from step 4]\n     **Repository**: [Repository name]\n\n     ## Research Question\n     [Original user query]\n\n     ## Summary\n     [High-level documentation of what was found, answering the user's question by describing what exists]\n\n     ## Detailed Findings\n\n     ### [Component/Area 1]\n     - Description of what exists ([file.ext:line](link))\n     - How it connects to other components\n     - Current implementation details (without evaluation)\n\n     ### [Component/Area 2]\n     ...\n\n     ## Code References\n     - `path/to/file.py:123` - Description of what's there\n     - `another/file.ts:45-67` - Description of the code block\n\n     ## Architecture Documentation\n     [Current patterns, conventions, and design implementations found in the codebase]\n\n     ## Historical Context (from thoughts/)\n     [Relevant insights from thoughts/ directory with references]\n     - `thoughts/shared/something.md` - Historical decision about X\n     - `thoughts/local/notes.md` - Past exploration of Y\n     Note: Paths exclude \"searchable/\" even if found there\n\n     ## Related Research\n     [Links to other research documents in thoughts/shared/research/]\n\n     ## Open Questions\n     [Any areas that need further investigation]\n     ```\n\n7. **Add GitHub permalinks (if applicable):**\n   - Check if on main branch or if commit is pushed: `git branch --show-current` and `git status`\n   - If on main/master or pushed, generate GitHub permalinks:\n     - Get repo info: `gh repo view --json owner,name`\n     - Create permalinks: `https://github.com/{owner}/{repo}/blob/{commit}/{file}#L{line}`\n   - Replace local file references with permalinks in the document\n\n8. **Sync and present findings:**\n   - Run `humanlayer thoughts sync` to sync the thoughts directory\n   - Present a concise summary of findings to the user\n   - Include key file references for easy navigation\n   - Ask if they have follow-up questions or need clarification\n\n9. **Handle follow-up questions:**\n   - If the user has follow-up questions, append to the same research document\n   - Update the frontmatter fields `last_updated` and `last_updated_by` to reflect the update\n   - Add `last_updated_note: \"Added follow-up research for [brief description]\"` to frontmatter\n   - Add a new section: `## Follow-up Research [timestamp]`\n   - Spawn new sub-agents as needed for additional investigation\n   - Continue updating the document and syncing\n\n## Important notes:\n- Always use parallel Task agents to maximize efficiency and minimize context usage\n- Always run fresh codebase research - never rely solely on existing research documents\n- The thoughts/ directory provides historical context to supplement live findings\n- The thoughts/ directory provides historical context to supplement live findings\n- Focus on finding concrete file paths and line numbers for developer reference\n- Research documents should be self-contained with all necessary context\n- Each sub-agent prompt should be specific and focused on read-only documentation operations\n- Document cross-component connections and how systems interact\n- Include temporal context (when the research was conducted)\n- Link to GitHub when possible for permanent references\n- Keep the main agent focused on synthesis, not deep file reading\n- Have sub-agents document examples and usage patterns as they exist\n- Explore all of thoughts/ directory, not just research subdirectory\n- **CRITICAL**: You and all sub-agents are documentarians, not evaluators\n- **REMEMBER**: Document what IS, not what SHOULD BE\n- **NO RECOMMENDATIONS**: Only describe the current state of the codebase\n- **File reading**: Always read mentioned files FULLY (no limit/offset) before spawning sub-tasks\n- **Critical ordering**: Follow the numbered steps exactly\n  - ALWAYS read mentioned files first before spawning sub-tasks (step 1)\n  - ALWAYS wait for all sub-agents to complete before synthesizing (step 4)\n  - ALWAYS gather metadata before writing the document (step 5 before step 6)\n  - NEVER write the research document with placeholder values\n- **Path handling**: The thoughts/searchable/ directory contains hard links for searching\n  - Always document paths by removing ONLY \"searchable/\" - preserve all other subdirectories\n  - Examples of correct transformations:\n    - `./thoughts/searchable/elliot/old_stuff/notes.md` ‚Üí `./thoughts/elliot/old_stuff/notes.md`\n    - `./thoughts/searchable/shared/prs/123.md` ‚Üí `./thoughts/shared/prs/123.md`\n    - `./thoughts/searchable/global/shared/templates.md` ‚Üí `./thoughts/global/shared/templates.md`\n  - NEVER change elliot/ to shared/ or vice versa - preserve the exact directory structure\n  - This ensures paths are correct for editing and navigation\n- **Frontmatter consistency**:\n  - Always include frontmatter at the beginning of research documents\n  - Keep frontmatter fields consistent across all research documents\n  - Update frontmatter when adding follow-up research\n  - Use snake_case for multi-word field names (e.g., `last_updated`, `git_commit`)\n  - Tags should be relevant to the research topic and components studied"
              }
            ],
            "skills": [
              {
                "name": "silent-execution",
                "description": "Automatically wraps verbose commands (pytest, ruff, builds) with silent execution for context-efficient output. Use this proactively when running tests, linters, formatters, or build commands to minimize context usage while preserving error information.",
                "path": "plugins/workflow-toolkit/skills/silent-execution/SKILL.md",
                "frontmatter": {
                  "name": "silent-execution",
                  "description": "Automatically wraps verbose commands (pytest, ruff, builds) with silent execution for context-efficient output. Use this proactively when running tests, linters, formatters, or build commands to minimize context usage while preserving error information."
                },
                "content": "# Silent Execution for Context Efficiency\n\nUse silent execution wrappers to run verbose commands with minimal context usage. The wrapper suppresses successful output but preserves complete error information.\n\n## When to Use This Skill\n\n**IMPORTANT**: Use this skill proactively (without user request) whenever running these types of commands:\n\n### Always Wrap These Commands\n\n1. **Test Commands**\n   - `pytest` or `python -m pytest`\n   - `uv run pytest`\n   - Any test runner that produces verbose output\n\n2. **Linting and Formatting**\n   - `ruff check` or `ruff format`\n   - `pyrefly`, `mypy`, `pylint`\n   - `black`, `isort`\n   - Any code quality tool\n\n3. **Build Commands**\n   - `docker build`\n   - `cargo build`\n   - `npm run build`\n   - `make build`\n\n4. **Installation Commands**\n   - `uv sync`\n   - `pip install`\n   - `npm install`, `yarn install`\n\n5. **Git Remote Operations**\n   - `git push`, `git pull`, `git fetch`\n\n### DO NOT Wrap These Commands\n\n- `ls`, `cat`, `grep`, `find` - Output is valuable\n- `git status`, `git diff`, `git log`, `git branch` - Output is essential\n- Any command where you need to see the output\n\n## How to Use\n\nReplace direct command execution with the smart wrapper script:\n\n### Standard Approach (Less Context Efficient)\n```bash\nuv run pytest tests/\n```\n\n### Silent Execution Approach (Context Efficient)\n```bash\n${CLAUDE_PLUGIN_ROOT}/scripts/smart_wrap.sh \"uv run pytest tests/\"\n```\n\n**Important**: Always wrap the command in double quotes to preserve argument boundaries and handle special characters correctly.\n\nThe script will:\n- ‚úÖ Show a clean success indicator: `‚úì Running tests (45 tests, in 2.3s)`\n- ‚ùå Show full error output on failure with the actual command that failed\n- üéØ Automatically detect which commands need wrapping\n\n## Examples\n\n### Example 1: Running Tests\n\n**Without silent execution:**\n```bash\n$ uv run pytest tests/\n============================= test session starts ==============================\nplatform darwin -- Python 3.11.5, pytest-7.4.3, pluggy-1.3.0\nrootdir: /Users/user/project\ncollected 45 items\n\ntests/test_connection.py ....                                            [  8%]\ntests/test_parser.py .........                                           [ 28%]\ntests/test_orderbook.py ....................                             [ 72%]\ntests/test_integration.py ............                                   [100%]\n\n============================= 45 passed in 2.34s ===============================\n```\n(Uses significant context for success information)\n\n**With silent execution:**\n```bash\n$ ${CLAUDE_PLUGIN_ROOT}/scripts/smart_wrap.sh \"uv run pytest tests/\"\n  ‚úì Running tests (45 tests, in 2.3s)\n```\n(Minimal context usage, same information)\n\n### Example 2: Running Linter\n\n**Without silent execution:**\n```bash\n$ uv run ruff check .\nAll checks passed!\n```\n\n**With silent execution:**\n```bash\n$ ${CLAUDE_PLUGIN_ROOT}/scripts/smart_wrap.sh \"uv run ruff check .\"\n  ‚úì Ruff check\n```\n\n### Example 3: Command Failure (Full Output Preserved)\n\n**Silent execution on failure:**\n```bash\n$ ${CLAUDE_PLUGIN_ROOT}/scripts/smart_wrap.sh \"uv run pytest tests/\"\n  ‚úó Running tests\nCommand failed: uv run pytest tests/\n============================= test session starts ==============================\nFAILED tests/test_parser.py::test_invalid_message - AssertionError: ...\nERROR tests/test_connection.py::test_reconnect - ConnectionError: ...\n=========================== 2 failed, 43 passed in 2.1s =======================\n```\n(Full error output preserved for debugging)\n\n## Integration with Commands\n\nWhen implementing commands that run multiple checks, use silent execution throughout:\n\n```bash\n# Standard approach (verbose)\nuv run pytest tests/\nuv run ruff check .\nuv run ruff format --check .\n\n# Silent execution approach (context efficient)\n${CLAUDE_PLUGIN_ROOT}/scripts/smart_wrap.sh \"uv run pytest tests/\"\n${CLAUDE_PLUGIN_ROOT}/scripts/smart_wrap.sh \"uv run ruff check .\"\n${CLAUDE_PLUGIN_ROOT}/scripts/smart_wrap.sh \"uv run ruff format --check .\"\n```\n\n## How It Works\n\nThe `smart_wrap.sh` script:\n1. Analyzes the command to determine if it should be wrapped\n2. If verbose, redirects output to temporary file\n3. On success: Shows clean indicator with key metrics (test count, duration)\n4. On failure: Shows full output for debugging\n5. If not verbose, runs command normally\n\nThe script uses pattern matching to detect verbose commands automatically.\n\n## Verbose Mode\n\nSet `VERBOSE=1` to see all output (useful for debugging):\n\n```bash\nVERBOSE=1 ${CLAUDE_PLUGIN_ROOT}/scripts/smart_wrap.sh \"uv run pytest tests/\"\n```\n\n## Important Notes\n\n- **Always use proactively** - Don't wait for user to request it\n- Preserves all error information - Never hides failures\n- Works with any shell command - Not language-specific\n- Reduces context usage by 80-95% for successful operations\n- Scripts are located in `scripts/` at plugin root\n- Use `${CLAUDE_PLUGIN_ROOT}` for portable paths across installations\n\n## Technical Details\n\n### Scripts\n\n- **`smart_wrap.sh`**: Main wrapper that detects and wraps verbose commands\n- **`run_silent.sh`**: Core execution engine with output management\n\nBoth scripts are in `scripts/` directory (plugin-level, shared across components).\n\n### Exit Codes\n\nThe wrapper preserves exit codes from wrapped commands, so CI/CD pipelines work correctly.\n\n## Best Practices\n\n1. **Use consistently**: Apply to all verbose commands in your workflow\n2. **Check the output**: The wrapper shows when commands pass/fail\n3. **Trust the wrapper**: It preserves all error information\n4. **Context efficiency**: Enables running more checks without context limits\n5. **Automatic detection**: The script knows which commands to wrap"
              },
              {
                "name": "stacked-pr",
                "description": "Create and update stacked pull requests. Use this after completing an implementation phase to commit changed files.",
                "path": "plugins/workflow-toolkit/skills/stacked-pr/SKILL.md",
                "frontmatter": {
                  "name": "stacked-pr",
                  "description": "Create and update stacked pull requests. Use this after completing an implementation phase to commit changed files."
                },
                "content": "# Stacked PR Workflow\n\nThis skill enables Claude to create stacked pull requests using git-town automation scripts. Each phase becomes an atomic PR that builds on previous phases.\n\n## When to Use This Skill\n\nInvoke this skill after completing a phase from `/implement_plan` when:\n1. All automated verification has passed (`just check-test`)\n2. User has confirmed manual verification is complete\n3. There are uncommitted changes ready to be stacked\n\nDO NOT use this skill:\n- Before verification is complete\n- When there are no changes to commit\n- For non-plan-based work (use standard git workflow instead)\n\n## Pre-Flight Checks\n\nBefore creating the stack, verify:\n1. Current git status shows modified/new files\n2. All tests and checks have passed\n3. You know the phase number and plan context\n\n## Workflow Instructions\n\n### Step 1: Determine Phase Type\n\nCheck the current branch to determine if this is Phase 1 or Phase N:\n\n```bash\ngit branch --show-current\n```\n\n**Decision Logic:**\n- **If on `main`**: This is Phase 1 ‚Üí Use `just new-stack`\n- **If on `phase-X-*`**: This is Phase N (where N = X + 1) ‚Üí Use `just append-stack`\n\n### Step 2: Prepare Arguments\n\nBoth scripts require the same arguments (in order):\n1. **phase-num**: The phase number (e.g., `1`, `2`, `3`)\n2. **branch-name**: Short descriptive name (e.g., `websocket-foundation`, `message-parser`)\n3. **commit-msg**: Full commit message (multiline string)\n4. **pr-title**: PR title (e.g., `Phase 1: WebSocket Connection Foundation`)\n5. **pr-body**: PR body/description (multiline string)\n\n#### Branch Naming Convention\n- Format: `phase-N-<short-description>`\n- Examples:\n  - `phase-1-websocket-foundation`\n  - `phase-2-message-parser`\n  - `phase-3-orderbook-state`\n\n#### Commit Message Format\n\n```\n<type>: <phase-summary>\n\nPhase N: <detailed-description>\n\nChanges:\n- <key change 1>\n- <key change 2>\n- <key change 3>\n\n<any relevant context or notes>\n```\n\nTypes: `feat`, `fix`, `refactor`, `test`, `chore`, `docs`\n\n#### PR Body Format\n\n```\n## Phase N: <Title>\n\n### Summary\n<1-2 sentence overview of what this phase accomplishes>\n\n### Changes\n- <key change 1>\n- <key change 2>\n- <key change 3>\n\n### Stack\n<!-- branch-stack -->\n\n### Verification\n- [x] All automated tests passed (\\`just check-test\\`)\n- [x] Manual verification completed\n- [x] Code follows project patterns\n\n### Related\nPart of implementation plan: [link to plan if available]\n\n---\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)\n```\n\n### Step 3: Execute the Appropriate Script\n\n**For Phase 1 (on `main` branch):**\n\n```bash\njust new-stack \\\n  \"<phase-num>\" \\\n  \"<branch-name>\" \\\n  \"<commit-msg>\" \\\n  \"<pr-title>\" \\\n  \"<pr-body>\"\n```\n\n**For Phase N > 1 (on `phase-X-*` branch):**\n\n```bash\njust append-stack \\\n  \"<phase-num>\" \\\n  \"<branch-name>\" \\\n  \"<commit-msg>\" \\\n  \"<pr-title>\" \\\n  \"<pr-body>\"\n```\n\n## Example Workflows\n\n### Example 1: Phase 1 (Starting New Stack)\n\n```bash\n# Current state check\n$ git branch --show-current\nmain\n\n$ git status\n# Shows: modified files in src/connection/ (uncommitted)\n\n# Execute new-stack\njust new-stack \\\n  \"1\" \\\n  \"websocket-foundation\" \\\n  \"feat: Add WebSocket connection foundation\n\nPhase 1: Implement core WebSocket connection logic\n\nChanges:\n- Add WebsocketConnection class with lifecycle management\n- Implement exponential backoff reconnection strategy\n- Add connection health monitoring\n- Create connection stats tracking\n\nEstablishes the foundation for real-time market data streaming.\" \\\n  \"Phase 1: WebSocket Connection Foundation\" \\\n  \"## Phase 1: WebSocket Connection Foundation\n\n### Summary\nImplements the core WebSocket connection class with automatic reconnection, health monitoring, and stats tracking.\n\n### Changes\n- Add WebsocketConnection class with lifecycle management\n- Implement exponential backoff reconnection strategy (1s ‚Üí 30s)\n- Add connection health monitoring (60s silence detection)\n- Create connection stats tracking\n\n### Stack\n<!-- branch-stack -->\n\n### Verification\n- [x] All automated tests passed (\\`just check-test\\`)\n- [x] Manual verification: Connected to Polymarket API successfully\n- [x] Code follows project patterns\n\n---\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)\"\n```\n\n**What the script does:**\n1. ‚úì Verifies you're on `main` branch\n2. ‚úì Checks for uncommitted changes\n3. ‚úì Creates branch `phase-1-websocket-foundation` via `git town hack`\n4. ‚úì Commits changes (excluding `thoughts/` directory)\n5. ‚úì Creates PR with `--base main`\n6. ‚úì Syncs the stack\n\n### Example 2: Phase 2 (Extending Stack)\n\n```bash\n# Current state check\n$ git branch --show-current\nphase-1-websocket-foundation\n\n$ git status\n# Shows: modified files (uncommitted)\n\n# Execute append-stack\njust append-stack \\\n  \"2\" \\\n  \"message-parser\" \\\n  \"feat: Add message parsing with msgspec\n\nPhase 2: Implement zero-copy message parser\n\nChanges:\n- Add msgspec-based message parser\n- Define protocol structures for BookSnapshot, PriceChange, LastTradePrice\n- Implement generator-based parsing for streaming\n- Handle integer scaling for prices/sizes\n\nEnables efficient parsing of WebSocket messages with zero-copy optimization.\" \\\n  \"Phase 2: Message Parser with msgspec\" \\\n  \"## Phase 2: Message Parser with msgspec\n\n### Summary\nImplements zero-copy message parsing using msgspec, enabling efficient processing of WebSocket events.\n\n### Changes\n- Add msgspec-based MessageParser class\n- Define protocol structures (BookSnapshot, PriceChange, LastTradePrice)\n- Implement generator-based parsing for streaming\n- Handle integer scaling (PRICE_SCALE=1000, SIZE_SCALE=100)\n\n### Stack\n<!-- branch-stack -->\n\nMerge order: This PR should be merged after Phase 1.\n\n### Verification\n- [x] All automated tests passed (\\`just check-test\\`)\n- [x] Manual verification: Parsed live messages successfully\n- [x] Code follows project patterns\n\n---\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)\"\n```\n\n**What the script does:**\n1. ‚úì Verifies you're NOT on `main` (you must be on previous phase branch)\n2. ‚úì Auto-detects previous phase branch (`phase-1-websocket-foundation`)\n3. ‚úì Checks for uncommitted changes\n4. ‚úì Creates branch `phase-2-message-parser` via `git town append`\n5. ‚úì Commits changes (excluding `thoughts/` directory)\n6. ‚úì Creates PR with `--base phase-1-websocket-foundation`\n7. ‚úì Syncs the stack\n\n## Script Features\n\nBoth scripts automatically:\n- Validate pre-conditions (branch state, uncommitted changes)\n- Create properly named branches with git-town\n- Stage changes (excluding `thoughts/` directory)\n- Commit with your provided message\n- Create GitHub PR with proper base branch\n- Sync the stack after PR creation\n- Provide clear output with emoji indicators\n\n## Common Issues and Solutions\n\n### Issue: \"No uncommitted changes detected\"\n\nThe script checks `git status --porcelain`. Ensure:\n- You have modified, added, or deleted files\n- Changes are not in the `thoughts/` directory (which is excluded)\n\n### Issue: \"Previous phase branch does not exist\"\n\nFor `append-stack`, ensure:\n- You're on the correct previous phase branch before running\n- The branch name follows the `phase-N-*` pattern\n\n### Issue: Wrong base branch in PR\n\nUse GitHub CLI to fix:\n```bash\ngh pr edit <pr-number> --base <correct-base-branch>\n```\n\n### Issue: Need to update an earlier phase\n\n```bash\n# Checkout the phase that needs changes\ngit checkout phase-N-<name>\n\n# Make changes and commit\n# ...\n\n# Sync stack to propagate changes forward\ngit town sync --stack\n```\n\n## Key Principles\n\n1. **One phase = One PR**: Each phase should be atomic with passing CI\n2. **Sequential dependencies**: Phase N+1 builds on Phase N\n3. **Clear commit messages**: Reference phase number and provide context\n4. **Automatic base branches**: Scripts handle this (Phase 1 ‚Üí main, Phase N ‚Üí Phase N-1)\n5. **Always sync**: Scripts automatically sync the stack after PR creation\n6. **Thoughts excluded**: Both scripts exclude the `thoughts/` directory from commits\n\n## Integration with /implement_plan\n\nThis skill integrates with the `/implement_plan` workflow:\n\n1. `/implement_plan` implements a phase\n2. Automated verification runs (`just check-test`)\n3. Claude pauses for manual verification\n4. User confirms: \"Manual verification complete\"\n5. **Claude invokes stacked-pr skill**\n6. Skill executes appropriate script (new-stack or append-stack)\n7. PR created and stack synced\n8. Ready for next phase\n\n## Notes\n\n- Uses `git-town` for stack management\n- PRs created using GitHub CLI (`gh`)\n- Main branch is `main` (configured in git-town)\n- Stack branches should be merged in order (Phase 1, then 2, then 3, etc.)\n- After all phases are merged, the stack is automatically cleaned up by git-town\n- The `thoughts/` directory is automatically excluded from all commits"
              }
            ]
          }
        ]
      }
    }
  ]
}