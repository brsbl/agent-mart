{
  "owner": {
    "id": "penkzhou",
    "display_name": "Old Autumn",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/1454424?u=3993e3d5404710e4064e1cc612172d63c8070943&v=4",
    "url": "https://github.com/penkzhou",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 1,
      "total_commands": 9,
      "total_skills": 11,
      "total_stars": 1,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "penkzhou/swiss-army-knife-plugin",
      "url": "https://github.com/penkzhou/swiss-army-knife-plugin",
      "description": "A collection of useful Claude Code components for daily development - commands, agents, skills, and hooks",
      "homepage": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2025-12-07T03:46:34Z",
        "created_at": "2025-11-26T09:29:34Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 274
        },
        {
          "path": ".claude",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/settings.local.json",
          "type": "blob",
          "size": 441
        },
        {
          "path": ".github",
          "type": "tree",
          "size": null
        },
        {
          "path": ".github/workflows",
          "type": "tree",
          "size": null
        },
        {
          "path": ".github/workflows/claude-code-review.yml",
          "type": "blob",
          "size": 4459
        },
        {
          "path": ".github/workflows/claude.yml",
          "type": "blob",
          "size": 1898
        },
        {
          "path": ".github/workflows/markdown-lint.yml",
          "type": "blob",
          "size": 1186
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 195
        },
        {
          "path": ".markdown-link-check.json",
          "type": "blob",
          "size": 384
        },
        {
          "path": ".markdownlint.json",
          "type": "blob",
          "size": 309
        },
        {
          "path": "CLAUDE.md",
          "type": "blob",
          "size": 11826
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 1106
        },
        {
          "path": "swiss-army-knife",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 621
        },
        {
          "path": "swiss-army-knife/CHANGELOG.md",
          "type": "blob",
          "size": 6344
        },
        {
          "path": "swiss-army-knife/CLAUDE.md",
          "type": "blob",
          "size": 20609
        },
        {
          "path": "swiss-army-knife/README.md",
          "type": "blob",
          "size": 6102
        },
        {
          "path": "swiss-army-knife/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/agents/backend",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/agents/backend/error-analyzer.md",
          "type": "blob",
          "size": 4661
        },
        {
          "path": "swiss-army-knife/agents/backend/init-collector.md",
          "type": "blob",
          "size": 9862
        },
        {
          "path": "swiss-army-knife/agents/backend/quality-gate.md",
          "type": "blob",
          "size": 4708
        },
        {
          "path": "swiss-army-knife/agents/backend/root-cause.md",
          "type": "blob",
          "size": 4815
        },
        {
          "path": "swiss-army-knife/agents/bugfix",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/agents/bugfix/doc-writer.md",
          "type": "blob",
          "size": 2413
        },
        {
          "path": "swiss-army-knife/agents/bugfix/executor.md",
          "type": "blob",
          "size": 3619
        },
        {
          "path": "swiss-army-knife/agents/bugfix/knowledge.md",
          "type": "blob",
          "size": 2682
        },
        {
          "path": "swiss-army-knife/agents/bugfix/master-coordinator.md",
          "type": "blob",
          "size": 20537
        },
        {
          "path": "swiss-army-knife/agents/bugfix/solution.md",
          "type": "blob",
          "size": 3360
        },
        {
          "path": "swiss-army-knife/agents/ci-job",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/agents/ci-job/job-failure-classifier.md",
          "type": "blob",
          "size": 10934
        },
        {
          "path": "swiss-army-knife/agents/ci-job/job-fix-coordinator.md",
          "type": "blob",
          "size": 10316
        },
        {
          "path": "swiss-army-knife/agents/ci-job/job-init-collector.md",
          "type": "blob",
          "size": 8561
        },
        {
          "path": "swiss-army-knife/agents/ci-job/job-log-fetcher.md",
          "type": "blob",
          "size": 8524
        },
        {
          "path": "swiss-army-knife/agents/ci-job/job-root-cause.md",
          "type": "blob",
          "size": 8270
        },
        {
          "path": "swiss-army-knife/agents/ci-job/job-summary-reporter.md",
          "type": "blob",
          "size": 11598
        },
        {
          "path": "swiss-army-knife/agents/ci-job/master-coordinator.md",
          "type": "blob",
          "size": 20348
        },
        {
          "path": "swiss-army-knife/agents/e2e",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/agents/e2e/error-analyzer.md",
          "type": "blob",
          "size": 5219
        },
        {
          "path": "swiss-army-knife/agents/e2e/init-collector.md",
          "type": "blob",
          "size": 10857
        },
        {
          "path": "swiss-army-knife/agents/e2e/quality-gate.md",
          "type": "blob",
          "size": 4350
        },
        {
          "path": "swiss-army-knife/agents/e2e/root-cause.md",
          "type": "blob",
          "size": 4923
        },
        {
          "path": "swiss-army-knife/agents/execute-plan",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/agents/execute-plan/executor-coordinator.md",
          "type": "blob",
          "size": 10554
        },
        {
          "path": "swiss-army-knife/agents/execute-plan/init-collector.md",
          "type": "blob",
          "size": 7360
        },
        {
          "path": "swiss-army-knife/agents/execute-plan/master-coordinator.md",
          "type": "blob",
          "size": 21252
        },
        {
          "path": "swiss-army-knife/agents/execute-plan/summary-reporter.md",
          "type": "blob",
          "size": 8272
        },
        {
          "path": "swiss-army-knife/agents/execute-plan/validator.md",
          "type": "blob",
          "size": 8067
        },
        {
          "path": "swiss-army-knife/agents/frontend",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/agents/frontend/error-analyzer.md",
          "type": "blob",
          "size": 4159
        },
        {
          "path": "swiss-army-knife/agents/frontend/init-collector.md",
          "type": "blob",
          "size": 10509
        },
        {
          "path": "swiss-army-knife/agents/frontend/quality-gate.md",
          "type": "blob",
          "size": 3954
        },
        {
          "path": "swiss-army-knife/agents/frontend/root-cause.md",
          "type": "blob",
          "size": 4436
        },
        {
          "path": "swiss-army-knife/agents/pr-review",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/agents/pr-review/comment-classifier.md",
          "type": "blob",
          "size": 10508
        },
        {
          "path": "swiss-army-knife/agents/pr-review/comment-fetcher.md",
          "type": "blob",
          "size": 7578
        },
        {
          "path": "swiss-army-knife/agents/pr-review/comment-filter.md",
          "type": "blob",
          "size": 5842
        },
        {
          "path": "swiss-army-knife/agents/pr-review/fix-coordinator.md",
          "type": "blob",
          "size": 14593
        },
        {
          "path": "swiss-army-knife/agents/pr-review/init-collector.md",
          "type": "blob",
          "size": 8129
        },
        {
          "path": "swiss-army-knife/agents/pr-review/knowledge-writer.md",
          "type": "blob",
          "size": 13674
        },
        {
          "path": "swiss-army-knife/agents/pr-review/master-coordinator.md",
          "type": "blob",
          "size": 18605
        },
        {
          "path": "swiss-army-knife/agents/pr-review/response-generator.md",
          "type": "blob",
          "size": 7082
        },
        {
          "path": "swiss-army-knife/agents/pr-review/response-submitter.md",
          "type": "blob",
          "size": 6775
        },
        {
          "path": "swiss-army-knife/agents/pr-review/summary-reporter.md",
          "type": "blob",
          "size": 11878
        },
        {
          "path": "swiss-army-knife/agents/review",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/agents/review/code-reviewer.md",
          "type": "blob",
          "size": 3799
        },
        {
          "path": "swiss-army-knife/agents/review/code-simplifier.md",
          "type": "blob",
          "size": 5005
        },
        {
          "path": "swiss-army-knife/agents/review/comment-analyzer.md",
          "type": "blob",
          "size": 5067
        },
        {
          "path": "swiss-army-knife/agents/review/review-coordinator.md",
          "type": "blob",
          "size": 20286
        },
        {
          "path": "swiss-army-knife/agents/review/review-fixer.md",
          "type": "blob",
          "size": 8675
        },
        {
          "path": "swiss-army-knife/agents/review/silent-failure-hunter.md",
          "type": "blob",
          "size": 5606
        },
        {
          "path": "swiss-army-knife/agents/review/test-analyzer.md",
          "type": "blob",
          "size": 5163
        },
        {
          "path": "swiss-army-knife/agents/review/type-design-analyzer.md",
          "type": "blob",
          "size": 5896
        },
        {
          "path": "swiss-army-knife/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/commands/execute-plan.md",
          "type": "blob",
          "size": 4207
        },
        {
          "path": "swiss-army-knife/commands/fix-backend.md",
          "type": "blob",
          "size": 3780
        },
        {
          "path": "swiss-army-knife/commands/fix-e2e.md",
          "type": "blob",
          "size": 3757
        },
        {
          "path": "swiss-army-knife/commands/fix-failed-job.md",
          "type": "blob",
          "size": 5200
        },
        {
          "path": "swiss-army-knife/commands/fix-frontend.md",
          "type": "blob",
          "size": 3785
        },
        {
          "path": "swiss-army-knife/commands/fix-pr-review.md",
          "type": "blob",
          "size": 4205
        },
        {
          "path": "swiss-army-knife/commands/merge-dep-prs.md",
          "type": "blob",
          "size": 8079
        },
        {
          "path": "swiss-army-knife/commands/pr.md",
          "type": "blob",
          "size": 11749
        },
        {
          "path": "swiss-army-knife/commands/release.md",
          "type": "blob",
          "size": 4739
        },
        {
          "path": "swiss-army-knife/config",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/config/defaults.yaml",
          "type": "blob",
          "size": 26549
        },
        {
          "path": "swiss-army-knife/docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/docs/plans",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/docs/plans/2025-11-27-multi-stack-bugfix-design.md",
          "type": "blob",
          "size": 7131
        },
        {
          "path": "swiss-army-knife/docs/plans/2025-11-27-multi-stack-implementation.md",
          "type": "blob",
          "size": 24943
        },
        {
          "path": "swiss-army-knife/docs/plans/2025-12-01-knowledge-patterns-design.md",
          "type": "blob",
          "size": 6563
        },
        {
          "path": "swiss-army-knife/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/hooks/hooks.json",
          "type": "blob",
          "size": 620
        },
        {
          "path": "swiss-army-knife/hooks/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/hooks/scripts/check-frontend-changes.sh",
          "type": "blob",
          "size": 1579
        },
        {
          "path": "swiss-army-knife/hooks/scripts/check-test-result.sh",
          "type": "blob",
          "size": 2819
        },
        {
          "path": "swiss-army-knife/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/skills/backend-bugfix",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/skills/backend-bugfix/SKILL.md",
          "type": "blob",
          "size": 8270
        },
        {
          "path": "swiss-army-knife/skills/bugfix-workflow",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/skills/bugfix-workflow/SKILL.md",
          "type": "blob",
          "size": 4708
        },
        {
          "path": "swiss-army-knife/skills/ci-job-analysis",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/skills/ci-job-analysis/SKILL.md",
          "type": "blob",
          "size": 9075
        },
        {
          "path": "swiss-army-knife/skills/coordinator-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/skills/coordinator-patterns/SKILL.md",
          "type": "blob",
          "size": 8661
        },
        {
          "path": "swiss-army-knife/skills/e2e-bugfix",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/skills/e2e-bugfix/SKILL.md",
          "type": "blob",
          "size": 9681
        },
        {
          "path": "swiss-army-knife/skills/elements-of-style",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/skills/elements-of-style/SKILL.md",
          "type": "blob",
          "size": 3066
        },
        {
          "path": "swiss-army-knife/skills/elements-of-style/elements-of-style.md",
          "type": "blob",
          "size": 71024
        },
        {
          "path": "swiss-army-knife/skills/execute-plan",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/skills/execute-plan/SKILL.md",
          "type": "blob",
          "size": 9526
        },
        {
          "path": "swiss-army-knife/skills/frontend-bugfix",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/skills/frontend-bugfix/SKILL.md",
          "type": "blob",
          "size": 4668
        },
        {
          "path": "swiss-army-knife/skills/knowledge-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/skills/knowledge-patterns/SKILL.md",
          "type": "blob",
          "size": 2521
        },
        {
          "path": "swiss-army-knife/skills/knowledge-patterns/patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/skills/knowledge-patterns/patterns/_example-silent-error-handling.md",
          "type": "blob",
          "size": 1946
        },
        {
          "path": "swiss-army-knife/skills/pr-review-analysis",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/skills/pr-review-analysis/SKILL.md",
          "type": "blob",
          "size": 8179
        },
        {
          "path": "swiss-army-knife/skills/workflow-logging",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-army-knife/skills/workflow-logging/SKILL.md",
          "type": "blob",
          "size": 15721
        }
      ],
      "marketplace": {
        "name": "swiss-army-knife-plugin",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "penkzhou"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "swiss-army-knife",
            "description": "Standardized frontend bugfix workflow plugin with 6-phase process",
            "source": "./swiss-army-knife",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add penkzhou/swiss-army-knife-plugin",
              "/plugin install swiss-army-knife@swiss-army-knife-plugin"
            ],
            "signals": {
              "stars": 1,
              "forks": 0,
              "pushed_at": "2025-12-07T03:46:34Z",
              "created_at": "2025-11-26T09:29:34Z",
              "license": null
            },
            "commands": [
              {
                "name": "/execute-plan",
                "description": "执行实施计划（六阶段流程）",
                "path": "swiss-army-knife/commands/execute-plan.md",
                "frontmatter": {
                  "description": "执行实施计划（六阶段流程）",
                  "argument-hint": "<PLAN_FILE> [--phase=0,1,2,3,4,5|all] [--dry-run] [--fast] [--skip-review] [--batch-size=N] [--log] [--verbose]",
                  "allowed-tools": "Read, Task, AskUserQuestion, Bash"
                },
                "content": "# Execute Plan Workflow v2.0\n\n基于实施计划文件，执行标准化 6 阶段执行流程。\n\n**宣布**：\"我正在使用 Execute Plan v2.0 工作流执行计划。\"\n\n---\n\n## 参数解析\n\n从用户输入中解析参数：\n\n| 参数 | 必填 | 默认值 | 说明 |\n|------|------|--------|------|\n| `<PLAN_FILE>` | 是 | - | 计划文件路径 |\n| `--phase=X,Y` | 否 | `all` | 指定执行阶段 |\n| `--dry-run` | 否 | `false` | 只分析不执行 |\n| `--fast` | 否 | `false` | 跳过方案细化（Phase 2） |\n| `--skip-review` | 否 | `false` | 跳过 Review 审查（Phase 4） |\n| `--batch-size=N` | 否 | `3` | 批次大小 |\n| `--log` | 否 | `false` | 启用过程日志（INFO 级别） |\n| `--verbose` | 否 | `false` | 启用详细日志（DEBUG 级别，隐含 --log） |\n\n### 日志参数说明\n\n- `--log`：记录 Phase/Agent 事件、置信度决策、用户交互\n- `--verbose`：额外记录完整的 agent 输入输出（文件可能较大）\n- 日志文件位置：`.claude/logs/swiss-army-knife/execute-plan/`\n- 生成两种格式：`.jsonl`（程序查询）和 `.log`（人类阅读）\n\n---\n\n## 前置验证\n\n在调用协调器前，验证计划文件：\n\n1. **文件存在性**：确认 `PLAN_FILE` 路径存在\n2. **文件非空**：检查文件内容非空\n3. **格式识别**：确认是支持的格式（`.md`、`.yaml`、`.yml`）\n\n**验证失败处理**：\n\n```text\n错误：计划文件不存在或为空\n\n文件路径: {PLAN_FILE}\n建议：\n1. 确认文件路径正确\n2. 使用支持的格式（Markdown 或 YAML）编写计划\n3. 参考 execute-plan skill 中的计划格式规范\n```\n\n**停止**，不继续执行。\n\n---\n\n## 调用 Master Coordinator\n\n使用 Task tool 调用 **execute-plan-master-coordinator** agent：\n\n> 使用 execute-plan-master-coordinator agent 执行计划：\n>\n> ## 输入\n>\n> ```json\n> {\n>   \"plan_path\": \"{PLAN_FILE}\",\n>   \"args\": {\n>     \"dry_run\": {--dry-run 解析结果},\n>     \"fast\": {--fast 解析结果},\n>     \"skip_review\": {--skip-review 解析结果},\n>     \"batch_size\": {--batch-size 解析结果或默认值 3},\n>     \"phase\": \"{--phase 解析结果或 'all'}\"\n>   }\n> }\n> ```\n\n---\n\n## 验证协调器响应\n\n在处理返回前，**必须**验证 Task 工具调用是否成功：\n\n### 1. 调用成功性检查\n\n如果 Task 工具调用失败（网络错误、agent 未找到、超时），展示错误并**停止**：\n\n```text\n错误：协调器调用失败\n\n原因: {错误消息}\n建议:\n1. 检查网络连接\n2. 确认插件已正确安装\n3. 重试命令\n```\n\n### 2. 响应格式验证\n\n检查响应是否为有效 JSON 且包含 `status` 字段：\n\n- 响应必须是有效 JSON\n- 必须包含 `status` 字段\n- `status` 必须是 `success|partial|failed|user_cancelled|dry_run_complete` 之一\n\n**验证失败处理**：\n\n```text\n错误：协调器响应格式无效\n\n收到的响应: {原始响应前 200 字符}\n建议:\n1. 重试命令\n2. 如果问题持续，请报告此错误\n```\n\n**停止**，不继续处理无效响应。\n\n---\n\n## 处理协调器返回\n\n协调器返回标准 JSON 格式，根据 `status` 字段处理：\n\n| status | 处理方式 |\n|--------|----------|\n| `success` | 展示成功报告，流程完成 |\n| `partial` | 展示部分成功报告，列出失败任务 |\n| `failed` | 展示错误详情，建议修复方案 |\n| `user_cancelled` | 确认用户取消，展示已完成工作 |\n| `dry_run_complete` | 展示分析报告，不实际执行 |\n\n---\n\n## 输出展示\n\n从协调器返回的 `summary_report` 中提取关键信息：\n\n```text\n=== 计划执行完成 ===\n\n计划: {summary_report.title}\n状态: {status}\n\n执行结果:\n- 总任务: {execution_results.summary.total}\n- 已完成: {execution_results.summary.completed}\n- 失败: {execution_results.summary.failed}\n\nReview 结果:\n- 发现问题: {review_results.summary.initial_issues}\n- 已修复: {review_results.summary.fixed_issues}\n\n报告路径: {summary_report.report_path}\n```"
              },
              {
                "name": "/fix-backend",
                "description": "执行标准化 Backend Bugfix 工作流（六阶段流程）",
                "path": "swiss-army-knife/commands/fix-backend.md",
                "frontmatter": {
                  "description": "执行标准化 Backend Bugfix 工作流（六阶段流程）",
                  "argument-hint": "[--phase=0,1,2,3,4,5|all] [--dry-run] [--log] [--verbose]",
                  "allowed-tools": "Read, Task, AskUserQuestion, Bash"
                },
                "content": "# Bugfix Backend Workflow v3.0\n\n基于测试失败的后端用例，执行标准化 bugfix 流程。\n\n**宣布**：\"我正在使用 Bugfix Backend v3.0 工作流进行问题修复。\"\n\n---\n\n## 参数解析\n\n从用户输入中解析参数：\n\n| 参数 | 必填 | 默认值 | 说明 |\n|------|------|--------|------|\n| `--phase=X,Y` | 否 | `all` | 指定执行阶段 |\n| `--dry-run` | 否 | `false` | 只分析不执行修改 |\n| `--log` | 否 | `false` | 启用过程日志（INFO 级别） |\n| `--verbose` | 否 | `false` | 启用详细日志（DEBUG 级别，隐含 --log） |\n\n### 日志参数说明\n\n- `--log`：记录 Phase/Agent 事件、置信度决策、用户交互\n- `--verbose`：额外记录完整的 agent 输入输出（文件可能较大）\n- 日志文件位置：`.claude/logs/swiss-army-knife/bugfix/`\n- 生成两种格式：`.jsonl`（程序查询）和 `.log`（人类阅读）\n\n---\n\n## 调用 Master Coordinator\n\n使用 Task tool 调用 **bugfix-master-coordinator** agent：\n\n> 使用 bugfix-master-coordinator agent 执行后端 bugfix 工作流：\n>\n> ## 输入\n>\n> ```json\n> {\n>   \"stack\": \"backend\",\n>   \"test_output\": \"{用户提供的测试输出，如有}\",\n>   \"args\": {\n>     \"dry_run\": {--dry-run 解析结果},\n>     \"phase\": \"{--phase 解析结果或 'all'}\"\n>   },\n>   \"logging\": {\n>     \"enabled\": {--log 或 --verbose 解析结果，true/false},\n>     \"level\": \"{--verbose 时为 'debug'，--log 时为 'info'}\",\n>     \"session_id\": \"{生成 8 位随机字符串，如 'a1b2c3d4'}\"\n>   }\n> }\n> ```\n\n### 生成 session_id\n\n使用以下方法生成 8 位随机 ID：\n\n```bash\ncat /dev/urandom | LC_ALL=C tr -dc 'a-z0-9' | head -c 8\n```\n\n---\n\n## 验证协调器响应\n\n在处理返回前，**必须**验证 Task 工具调用是否成功：\n\n### 1. 调用成功性检查\n\n如果 Task 工具调用失败（网络错误、agent 未找到、超时），展示错误并**停止**：\n\n```text\n错误：协调器调用失败\n\n原因: {错误消息}\n建议:\n1. 检查网络连接\n2. 确认插件已正确安装\n3. 重试命令\n```\n\n### 2. 响应格式验证\n\n检查响应是否为有效 JSON 且包含 `status` 字段：\n\n- 响应必须是有效 JSON\n- 必须包含 `status` 字段\n- `status` 必须是 `success|partial|failed|user_cancelled|dry_run_complete` 之一\n\n**验证失败处理**：\n\n```text\n错误：协调器响应格式无效\n\n收到的响应: {原始响应前 200 字符}\n建议:\n1. 重试命令\n2. 如果问题持续，请报告此错误\n```\n\n**停止**，不继续处理无效响应。\n\n---\n\n## 处理协调器返回\n\n协调器返回标准 JSON 格式，根据 `status` 字段处理：\n\n| status | 处理方式 |\n|--------|----------|\n| `success` | 展示成功报告，流程完成 |\n| `partial` | 展示部分成功报告，列出剩余 Review 问题 |\n| `failed` | 展示错误详情，建议修复方案 |\n| `user_cancelled` | 确认用户取消，展示已完成工作 |\n| `dry_run_complete` | 展示分析报告，不实际执行 |\n\n---\n\n## 输出展示\n\n从协调器返回中提取关键信息：\n\n```text\n=== Backend Bugfix 完成 ===\n\n状态: {status}\n\n修复结果:\n- 根因: {root_cause_analysis.root_cause.description}\n- 置信度: {root_cause_analysis.confidence.score}%\n- 变更文件: {execution_results.changed_files}\n\nReview 结果:\n- 发现问题: {review_results.summary.initial_issues}\n- 已修复: {review_results.summary.fixed_issues}\n\n验证状态:\n- 测试: {execution_results.verification.tests}\n- Lint: {execution_results.verification.lint}\n- 类型检查: {execution_results.verification.typecheck}\n```"
              },
              {
                "name": "/fix-e2e",
                "description": "执行标准化 E2E Bugfix 工作流（六阶段流程）",
                "path": "swiss-army-knife/commands/fix-e2e.md",
                "frontmatter": {
                  "description": "执行标准化 E2E Bugfix 工作流（六阶段流程）",
                  "argument-hint": "[--phase=0,1,2,3,4,5|all] [--dry-run] [--log] [--verbose]",
                  "allowed-tools": "Read, Task, AskUserQuestion, Bash"
                },
                "content": "# Bugfix E2E Workflow v3.0\n\n基于测试失败的 E2E 用例，执行标准化 bugfix 流程。\n\n**宣布**：\"我正在使用 Bugfix E2E v3.0 工作流进行问题修复。\"\n\n---\n\n## 参数解析\n\n从用户输入中解析参数：\n\n| 参数 | 必填 | 默认值 | 说明 |\n|------|------|--------|------|\n| `--phase=X,Y` | 否 | `all` | 指定执行阶段 |\n| `--dry-run` | 否 | `false` | 只分析不执行修改 |\n| `--log` | 否 | `false` | 启用过程日志（INFO 级别） |\n| `--verbose` | 否 | `false` | 启用详细日志（DEBUG 级别，隐含 --log） |\n\n### 日志参数说明\n\n- `--log`：记录 Phase/Agent 事件、置信度决策、用户交互\n- `--verbose`：额外记录完整的 agent 输入输出（文件可能较大）\n- 日志文件位置：`.claude/logs/swiss-army-knife/bugfix/`\n- 生成两种格式：`.jsonl`（程序查询）和 `.log`（人类阅读）\n\n---\n\n## 调用 Master Coordinator\n\n使用 Task tool 调用 **bugfix-master-coordinator** agent：\n\n> 使用 bugfix-master-coordinator agent 执行 E2E bugfix 工作流：\n>\n> ## 输入\n>\n> ```json\n> {\n>   \"stack\": \"e2e\",\n>   \"test_output\": \"{用户提供的测试输出，如有}\",\n>   \"args\": {\n>     \"dry_run\": {--dry-run 解析结果},\n>     \"phase\": \"{--phase 解析结果或 'all'}\"\n>   },\n>   \"logging\": {\n>     \"enabled\": {--log 或 --verbose 解析结果，true/false},\n>     \"level\": \"{--verbose 时为 'debug'，--log 时为 'info'}\",\n>     \"session_id\": \"{生成 8 位随机字符串，如 'a1b2c3d4'}\"\n>   }\n> }\n> ```\n\n### 生成 session_id\n\n使用以下方法生成 8 位随机 ID：\n\n```bash\ncat /dev/urandom | LC_ALL=C tr -dc 'a-z0-9' | head -c 8\n```\n\n---\n\n## 验证协调器响应\n\n在处理返回前，**必须**验证 Task 工具调用是否成功：\n\n### 1. 调用成功性检查\n\n如果 Task 工具调用失败（网络错误、agent 未找到、超时），展示错误并**停止**：\n\n```text\n错误：协调器调用失败\n\n原因: {错误消息}\n建议:\n1. 检查网络连接\n2. 确认插件已正确安装\n3. 重试命令\n```\n\n### 2. 响应格式验证\n\n检查响应是否为有效 JSON 且包含 `status` 字段：\n\n- 响应必须是有效 JSON\n- 必须包含 `status` 字段\n- `status` 必须是 `success|partial|failed|user_cancelled|dry_run_complete` 之一\n\n**验证失败处理**：\n\n```text\n错误：协调器响应格式无效\n\n收到的响应: {原始响应前 200 字符}\n建议:\n1. 重试命令\n2. 如果问题持续，请报告此错误\n```\n\n**停止**，不继续处理无效响应。\n\n---\n\n## 处理协调器返回\n\n协调器返回标准 JSON 格式，根据 `status` 字段处理：\n\n| status | 处理方式 |\n|--------|----------|\n| `success` | 展示成功报告，流程完成 |\n| `partial` | 展示部分成功报告，列出剩余 Review 问题 |\n| `failed` | 展示错误详情，建议修复方案 |\n| `user_cancelled` | 确认用户取消，展示已完成工作 |\n| `dry_run_complete` | 展示分析报告，不实际执行 |\n\n---\n\n## 输出展示\n\n从协调器返回中提取关键信息：\n\n```text\n=== E2E Bugfix 完成 ===\n\n状态: {status}\n\n修复结果:\n- 根因: {root_cause_analysis.root_cause.description}\n- 置信度: {root_cause_analysis.confidence.score}%\n- 变更文件: {execution_results.changed_files}\n\nReview 结果:\n- 发现问题: {review_results.summary.initial_issues}\n- 已修复: {review_results.summary.fixed_issues}\n\n验证状态:\n- 测试: {execution_results.verification.tests}\n- Lint: {execution_results.verification.lint}\n- 类型检查: {execution_results.verification.typecheck}\n```"
              },
              {
                "name": "/fix-failed-job",
                "description": "修复失败的 GitHub Action job（7 阶段流程，Phase 0-6）",
                "path": "swiss-army-knife/commands/fix-failed-job.md",
                "frontmatter": {
                  "description": "修复失败的 GitHub Action job（7 阶段流程，Phase 0-6）",
                  "argument-hint": "<JOB_URL> [--dry-run] [--auto-commit] [--retry-job] [--phase=0,1,2,3,4,5,6|all] [--log] [--verbose]",
                  "allowed-tools": "Read, Task, AskUserQuestion, Bash"
                },
                "content": "# Fix Failed Job Workflow v2.0\n\n自动分析和修复失败的 GitHub Action job。\n\n**宣布**：\"我正在使用 Fix Failed Job v2.0 工作流分析并修复 CI Job 失败。\"\n\n---\n\n## 参数解析\n\n从用户输入中解析参数：\n\n| 参数 | 必填 | 默认值 | 说明 |\n|------|------|--------|------|\n| `<JOB_URL>` | 是 | - | 失败的 job URL |\n| `--dry-run` | 否 | `false` | 只分析不执行修复 |\n| `--auto-commit` | 否 | `false` | 修复后自动创建 git commit |\n| `--retry-job` | 否 | `false` | 修复后触发 job 重新运行 |\n| `--phase=X,Y` | 否 | `all` | 指定执行阶段 |\n| `--log` | 否 | `false` | 启用过程日志（INFO 级别） |\n| `--verbose` | 否 | `false` | 启用详细日志（DEBUG 级别，隐含 --log） |\n\n### 日志参数说明\n\n- `--log`：记录 Phase/Agent 事件、置信度决策、用户交互\n- `--verbose`：额外记录完整的 agent 输入输出（文件可能较大）\n- 日志文件位置：`.claude/logs/swiss-army-knife/ci-job/`\n- 生成两种格式：`.jsonl`（程序查询）和 `.log`（人类阅读）\n\n### URL 格式验证\n\n支持的格式：\n```text\nhttps://github.com/{owner}/{repo}/actions/runs/{run_id}/job/{job_id}\nhttps://github.com/{owner}/{repo}/actions/runs/{run_id}/jobs/{job_id}\n```\n\n如果未提供 `JOB_URL` 或格式无效，使用 AskUserQuestion 询问用户。\n\n---\n\n## 调用 Master Coordinator\n\n使用 Task tool 调用 **ci-job-master-coordinator** agent：\n\n> 使用 ci-job-master-coordinator agent 执行 CI Job 修复工作流：\n>\n> ## 输入\n>\n> ```json\n> {\n>   \"job_url\": \"{解析的 JOB_URL}\",\n>   \"args\": {\n>     \"dry_run\": {--dry-run 解析结果},\n>     \"auto_commit\": {--auto-commit 解析结果},\n>     \"retry_job\": {--retry-job 解析结果},\n>     \"phase\": \"{--phase 解析结果或 'all'}\"\n>   },\n>   \"logging\": {\n>     \"enabled\": {--log 或 --verbose 解析结果，true/false},\n>     \"level\": \"{--verbose 时为 'debug'，--log 时为 'info'}\",\n>     \"session_id\": \"{生成 8 位随机字符串，如 'a1b2c3d4'}\"\n>   }\n> }\n> ```\n\n### 生成 session_id\n\n使用以下方法生成 8 位随机 ID：\n\n```bash\ncat /dev/urandom | LC_ALL=C tr -dc 'a-z0-9' | head -c 8\n```\n\n---\n\n## 验证协调器响应\n\n在处理返回前，**必须**验证 Task 工具调用是否成功：\n\n### 1. 调用成功性检查\n\n如果 Task 工具调用失败（网络错误、agent 未找到、超时），展示错误并**停止**：\n\n```text\n错误：协调器调用失败\n\n原因: {错误消息}\n建议:\n1. 检查网络连接\n2. 确认插件已正确安装\n3. 重试命令\n```\n\n### 2. 响应格式验证\n\n检查响应是否为有效 JSON 且包含 `status` 字段：\n\n- 响应必须是有效 JSON\n- 必须包含 `status` 字段\n- `status` 必须是 `success|partial|failed|user_cancelled|dry_run_complete` 之一\n\n**验证失败处理**：\n\n```text\n错误：协调器响应格式无效\n\n收到的响应: {原始响应前 200 字符}\n建议:\n1. 重试命令\n2. 如果问题持续，请报告此错误\n```\n\n**停止**，不继续处理无效响应。\n\n---\n\n## 处理协调器返回\n\n协调器返回标准 JSON 格式，根据 `status` 字段处理：\n\n| status | 处理方式 |\n|--------|----------|\n| `success` | 展示成功报告，流程完成 |\n| `partial` | 展示部分成功报告，列出剩余问题 |\n| `failed` | 展示错误详情，建议修复方案 |\n| `user_cancelled` | 确认用户取消，展示已完成工作 |\n| `dry_run_complete` | 展示分析报告，不实际执行 |\n\n---\n\n## 输出展示\n\n从协调器返回中提取关键信息：\n\n```text\n=== CI Job 修复完成 ===\n\n状态: {status}\nJob: {init_ctx.job_info.name} (#{init_ctx.job_info.id})\n仓库: {init_ctx.repo_info.full_name}\n\n失败分析:\n- 类型: {classification_result.summary.primary_type}\n- 失败数: {classification_result.summary.total_failures}\n- 可自动修复: {classification_result.summary.auto_fixable}\n\n根因分析:\n- 根因: {root_cause_result.analyses[0].root_cause.description}\n- 置信度: {root_cause_result.overall_confidence}%\n\n修复结果:\n- 已修复: {fix_result.summary.fixed}\n- 跳过: {fix_result.summary.skipped}\n- 失败: {fix_result.summary.failed}\n- 变更文件: {fix_result.changed_files}\n\nReview 结果:\n- 发现问题: {review_result.summary.initial_issues}\n- 已修复: {review_result.summary.fixed_issues}\n\n后续操作:\n- Git commit: {final_actions.commit_created}\n- Job 重试: {final_actions.job_rerun_triggered}\n```\n\n---\n\n## 使用示例\n\n### 基本用法\n\n```bash\n/fix-failed-job https://github.com/owner/repo/actions/runs/12345/job/67890\n```\n\n### Dry Run 模式\n\n```bash\n/fix-failed-job https://github.com/owner/repo/actions/runs/12345/job/67890 --dry-run\n```\n\n### 自动提交并重试\n\n```bash\n/fix-failed-job https://github.com/owner/repo/actions/runs/12345/job/67890 --auto-commit --retry-job\n```\n\n### 指定执行阶段\n\n```bash\n/fix-failed-job https://github.com/owner/repo/actions/runs/12345/job/67890 --phase=0,1,2\n```"
              },
              {
                "name": "/fix-frontend",
                "description": "执行标准化 Frontend Bugfix 工作流（六阶段流程）",
                "path": "swiss-army-knife/commands/fix-frontend.md",
                "frontmatter": {
                  "description": "执行标准化 Frontend Bugfix 工作流（六阶段流程）",
                  "argument-hint": "[--phase=0,1,2,3,4,5|all] [--dry-run] [--log] [--verbose]",
                  "allowed-tools": "Read, Task, AskUserQuestion, Bash"
                },
                "content": "# Bugfix Frontend Workflow v3.0\n\n基于测试失败的前端用例，执行标准化 bugfix 流程。\n\n**宣布**：\"我正在使用 Bugfix Frontend v3.0 工作流进行问题修复。\"\n\n---\n\n## 参数解析\n\n从用户输入中解析参数：\n\n| 参数 | 必填 | 默认值 | 说明 |\n|------|------|--------|------|\n| `--phase=X,Y` | 否 | `all` | 指定执行阶段 |\n| `--dry-run` | 否 | `false` | 只分析不执行修改 |\n| `--log` | 否 | `false` | 启用过程日志（INFO 级别） |\n| `--verbose` | 否 | `false` | 启用详细日志（DEBUG 级别，隐含 --log） |\n\n### 日志参数说明\n\n- `--log`：记录 Phase/Agent 事件、置信度决策、用户交互\n- `--verbose`：额外记录完整的 agent 输入输出（文件可能较大）\n- 日志文件位置：`.claude/logs/swiss-army-knife/bugfix/`\n- 生成两种格式：`.jsonl`（程序查询）和 `.log`（人类阅读）\n\n---\n\n## 调用 Master Coordinator\n\n使用 Task tool 调用 **bugfix-master-coordinator** agent：\n\n> 使用 bugfix-master-coordinator agent 执行前端 bugfix 工作流：\n>\n> ## 输入\n>\n> ```json\n> {\n>   \"stack\": \"frontend\",\n>   \"test_output\": \"{用户提供的测试输出，如有}\",\n>   \"args\": {\n>     \"dry_run\": {--dry-run 解析结果},\n>     \"phase\": \"{--phase 解析结果或 'all'}\"\n>   },\n>   \"logging\": {\n>     \"enabled\": {--log 或 --verbose 解析结果，true/false},\n>     \"level\": \"{--verbose 时为 'debug'，--log 时为 'info'}\",\n>     \"session_id\": \"{生成 8 位随机字符串，如 'a1b2c3d4'}\"\n>   }\n> }\n> ```\n\n### 生成 session_id\n\n使用以下方法生成 8 位随机 ID：\n\n```bash\ncat /dev/urandom | LC_ALL=C tr -dc 'a-z0-9' | head -c 8\n```\n\n---\n\n## 验证协调器响应\n\n在处理返回前，**必须**验证 Task 工具调用是否成功：\n\n### 1. 调用成功性检查\n\n如果 Task 工具调用失败（网络错误、agent 未找到、超时），展示错误并**停止**：\n\n```text\n错误：协调器调用失败\n\n原因: {错误消息}\n建议:\n1. 检查网络连接\n2. 确认插件已正确安装\n3. 重试命令\n```\n\n### 2. 响应格式验证\n\n检查响应是否为有效 JSON 且包含 `status` 字段：\n\n- 响应必须是有效 JSON\n- 必须包含 `status` 字段\n- `status` 必须是 `success|partial|failed|user_cancelled|dry_run_complete` 之一\n\n**验证失败处理**：\n\n```text\n错误：协调器响应格式无效\n\n收到的响应: {原始响应前 200 字符}\n建议:\n1. 重试命令\n2. 如果问题持续，请报告此错误\n```\n\n**停止**，不继续处理无效响应。\n\n---\n\n## 处理协调器返回\n\n协调器返回标准 JSON 格式，根据 `status` 字段处理：\n\n| status | 处理方式 |\n|--------|----------|\n| `success` | 展示成功报告，流程完成 |\n| `partial` | 展示部分成功报告，列出剩余 Review 问题 |\n| `failed` | 展示错误详情，建议修复方案 |\n| `user_cancelled` | 确认用户取消，展示已完成工作 |\n| `dry_run_complete` | 展示分析报告，不实际执行 |\n\n---\n\n## 输出展示\n\n从协调器返回中提取关键信息：\n\n```text\n=== Frontend Bugfix 完成 ===\n\n状态: {status}\n\n修复结果:\n- 根因: {root_cause_analysis.root_cause.description}\n- 置信度: {root_cause_analysis.confidence.score}%\n- 变更文件: {execution_results.changed_files}\n\nReview 结果:\n- 发现问题: {review_results.summary.initial_issues}\n- 已修复: {review_results.summary.fixed_issues}\n\n验证状态:\n- 测试: {execution_results.verification.tests}\n- Lint: {execution_results.verification.lint}\n- 类型检查: {execution_results.verification.typecheck}\n```"
              },
              {
                "name": "/fix-pr-review",
                "description": "处理 PR 中的 Code Review 评论（8 阶段流程，Phase 0-7）",
                "path": "swiss-army-knife/commands/fix-pr-review.md",
                "frontmatter": {
                  "description": "处理 PR 中的 Code Review 评论（8 阶段流程，Phase 0-7）",
                  "argument-hint": "<PR_NUMBER> [--dry-run] [--priority=P0,P1,P2] [--auto-reply] [--log] [--verbose]",
                  "allowed-tools": "Read, Task, AskUserQuestion, Bash"
                },
                "content": "# Fix PR Review Workflow v2.0\n\n基于 GitHub PR 中的 Code Review 评论，执行标准化的分析和修复流程。\n\n**宣布**：\"我正在使用 Fix PR Review v2.0 工作流处理 PR 评论。\"\n\n---\n\n## 参数解析\n\n从用户输入中解析参数：\n\n| 参数 | 必填 | 默认值 | 说明 |\n|------|------|--------|------|\n| `<PR_NUMBER>` | 是 | - | PR 编号（正整数） |\n| `--dry-run` | 否 | `false` | 只分析不执行修复和回复 |\n| `--priority=X,Y` | 否 | `P0,P1` | 指定处理的优先级 |\n| `--auto-reply` | 否 | `true` | 自动回复 reviewer |\n| `--log` | 否 | `false` | 启用过程日志（INFO 级别） |\n| `--verbose` | 否 | `false` | 启用详细日志（DEBUG 级别，隐含 --log） |\n\n### 日志参数说明\n\n- `--log`：记录 Phase/Agent 事件、置信度决策、用户交互\n- `--verbose`：额外记录完整的 agent 输入输出（文件可能较大）\n- 日志文件位置：`.claude/logs/swiss-army-knife/pr-review/`\n- 生成两种格式：`.jsonl`（程序查询）和 `.log`（人类阅读）\n\n### 参数验证\n\n1. `PR_NUMBER` 必须是正整数\n2. `--priority` 必须是 P0/P1/P2/P3 的组合\n3. 如果未提供 `PR_NUMBER`，使用 AskUserQuestion 询问用户\n\n---\n\n## 调用 Master Coordinator\n\n使用 Task tool 调用 **pr-review-master-coordinator** agent：\n\n> 使用 pr-review-master-coordinator agent 执行 PR Review 工作流：\n>\n> ## 输入\n>\n> ```json\n> {\n>   \"pr_number\": {PR_NUMBER},\n>   \"args\": {\n>     \"dry_run\": {--dry-run 解析结果},\n>     \"priority\": {--priority 解析结果或 [\"P0\", \"P1\"]},\n>     \"auto_reply\": {--auto-reply 解析结果或 true}\n>   },\n>   \"logging\": {\n>     \"enabled\": {--log 或 --verbose 解析结果，true/false},\n>     \"level\": \"{--verbose 时为 'debug'，--log 时为 'info'}\",\n>     \"session_id\": \"{生成 8 位随机字符串，如 'a1b2c3d4'}\"\n>   }\n> }\n> ```\n\n### 生成 session_id\n\n使用以下方法生成 8 位随机 ID：\n\n```bash\ncat /dev/urandom | LC_ALL=C tr -dc 'a-z0-9' | head -c 8\n```\n\n---\n\n## 验证协调器响应\n\n在处理返回前，**必须**验证 Task 工具调用是否成功：\n\n### 1. 调用成功性检查\n\n如果 Task 工具调用失败（网络错误、agent 未找到、超时），展示错误并**停止**：\n\n```text\n错误：协调器调用失败\n\n原因: {错误消息}\n建议:\n1. 检查网络连接\n2. 确认插件已正确安装\n3. 重试命令\n```\n\n### 2. 响应格式验证\n\n检查响应是否为有效 JSON 且包含 `status` 字段：\n\n- 响应必须是有效 JSON\n- 必须包含 `status` 字段\n- `status` 必须是 `success|partial|failed|user_cancelled|dry_run_complete` 之一\n\n**验证失败处理**：\n\n```text\n错误：协调器响应格式无效\n\n收到的响应: {原始响应前 200 字符}\n建议:\n1. 重试命令\n2. 如果问题持续，请报告此错误\n```\n\n**停止**，不继续处理无效响应。\n\n---\n\n## 处理协调器返回\n\n协调器返回标准 JSON 格式，根据 `status` 字段处理：\n\n| status | 处理方式 |\n|--------|----------|\n| `success` | 展示成功报告，流程完成 |\n| `partial` | 展示部分成功报告，列出失败的评论处理 |\n| `failed` | 展示错误详情，建议修复方案 |\n| `user_cancelled` | 确认用户取消，展示已完成工作 |\n| `dry_run_complete` | 展示分析报告，不实际执行 |\n\n---\n\n## 输出展示\n\n从协调器返回中提取关键信息：\n\n```text\n=== PR Review 处理完成 ===\n\n状态: {status}\n\n评论处理:\n- 总评论: {comments_summary.total}\n- 有效评论: {comments_summary.classified}\n- 按优先级: P0={by_priority.P0}, P1={by_priority.P1}\n\n修复结果:\n- 已修复: {fix_results.summary.fixed}\n- 跳过: {fix_results.summary.skipped}\n- 失败: {fix_results.summary.failed}\n\n回复状态:\n- 已提交: {responses.submitted}\n- 失败: {responses.failed}\n\nReview 结果:\n- 发现问题: {review_results.summary.initial_issues}\n- 已修复: {review_results.summary.fixed_issues}\n\n报告路径: {report_path}\n```"
              },
              {
                "name": "/merge-dep-prs",
                "description": "合并依赖更新 PR（Renovate + Dependabot），减少 CI 成本",
                "path": "swiss-army-knife/commands/merge-dep-prs.md",
                "frontmatter": {
                  "description": "合并依赖更新 PR（Renovate + Dependabot），减少 CI 成本",
                  "argument-hint": "[--bot=all|renovate|dependabot] [--dry-run] [--frontend-only] [--backend-only] [--log] [--verbose]",
                  "allowed-tools": "Read, Write, Edit, Bash, AskUserQuestion"
                },
                "content": "# Merge Dependency PRs Command\n\n将多个依赖更新 PR 合成为一个，减少 CI 成本，提升效率。\n\n**宣布**：\"我正在使用 merge-dep-prs 命令合并依赖更新。\"\n\n---\n\n## 参数解析\n\n| 参数 | 默认值 | 说明 |\n|------|--------|------|\n| `--bot` | `all` | 依赖管理 bot（all=两者/renovate/dependabot） |\n| `--dry-run` | `false` | 只分析不执行 |\n| `--frontend-only` | `false` | 仅处理前端依赖 |\n| `--backend-only` | `false` | 仅处理后端依赖 |\n| `--log` | `false` | 启用过程日志（INFO 级别） |\n| `--verbose` | `false` | 启用详细日志（DEBUG 级别，隐含 --log） |\n\n### 日志参数说明\n\n- `--log`：记录关键步骤、依赖变更、Git 操作\n- `--verbose`：额外记录详细的 PR 解析信息和命令输出\n- 日志文件位置：`.claude/logs/swiss-army-knife/merge-dep-prs/`\n- 生成两种格式：`.jsonl`（程序查询）和 `.log`（人类阅读）\n\n**示例**：\n- `/merge-dep-prs` - 合并所有依赖更新 PR\n- `/merge-dep-prs --bot=renovate --dry-run` - 预览 Renovate PR\n- `/merge-dep-prs --frontend-only` - 仅合并前端依赖\n\n**Bot 配置说明**（参见 `config/defaults.yaml` 中的 `dependency_management.bots`）：\n\n| Bot | 配置键 | Author 过滤 | PR 标题模式 |\n|-----|--------|-------------|-------------|\n| `all` | `authors`（复数） | `app/renovate` + `app/dependabot` | 无 |\n| `renovate` | `author`（单数） | `app/renovate` | `^(chore\\|fix\\|feat)\\(deps\\):` |\n| `dependabot` | `author`（单数） | `app/dependabot` | `^(Bump \\|(chore\\|build\\|fix)\\(deps(-dev)?\\): [Bb]ump )` |\n\n---\n\n## 重要原则\n\n**不要使用 `git merge` 合并 PR**，而是直接修改依赖文件并重新生成 lock 文件。\n\n原因：\n1. 避免合并冲突\n2. 更高效地处理多个依赖更新\n3. 保持提交历史清晰\n\n---\n\n## 步骤 1: 准备工作\n\n### 1.1 验证 Git 状态\n\n确保当前在最新的 main 分支。如果不在 main 分支，尝试切换：\n\n```bash\ngit branch --show-current\ngit checkout main\ngit pull\n```\n\n**如果切换或拉取失败**，报告错误原因并询问用户是否继续。常见原因：未提交的更改、合并冲突、网络问题。\n\n### 1.2 加载配置\n\n读取 `config/defaults.yaml` 中的 `stacks.dependency_management` 配置，然后用项目配置 `.claude/swiss-army-knife.yaml`（如存在）覆盖。\n\n需要的配置项：\n- `dependency_management.frontend.{package_file, lock_command, keywords}`\n- `dependency_management.backend.{package_file, lock_command, keywords}`\n- `dependency_management.bots` - Bot 与 author 的映射\n\n**注意**：`lock_command` 已包含目录切换（如 `cd frontend &&`），直接执行即可。\n\n### 1.3 验证配置\n\n在继续之前，验证必需的配置：\n\n1. **检查依赖文件是否存在**（根据 `--frontend-only`/`--backend-only` 参数决定检查哪些）：\n   - 前端：检查 `dependency_management.frontend.package_file` 是否存在\n   - 后端：检查 `dependency_management.backend.package_file` 是否存在\n\n2. **检查 lock 命令工具是否可用**：\n   - 前端：检查 `pnpm`/`npm`/`yarn` 是否安装\n   - 后端：检查 `uv`/`pip`/`poetry` 是否安装\n\n**如果文件不存在或工具未安装**：\n- 报告具体问题\n- 如果是单一技术栈缺失，询问用户是否继续处理另一技术栈\n- 如果两者都有问题，停止执行\n\n---\n\n## 步骤 2: 收集依赖更新信息\n\n### 2.1 获取 PR 列表\n\n根据 `--bot` 参数从配置 `dependency_management.bots` 中查找对应的 author，然后获取开放 PR：\n\n```bash\ngh pr list --state open --author {author} --json number,title,body\n```\n\n**注意**：`--bot=all` 时需要分别获取 `app/renovate` 和 `app/dependabot` 的 PR，合并去重。\n\n**错误处理**：如果命令失败，根据错误类型处理（认证问题提示 `gh auth login`、API 限流重试、网络问题停止）。空结果是正常情况。\n\n### 2.2 解析 PR 信息\n\n对每个 PR，从 body 中提取：\n\n- 依赖包名\n- 旧版本 → 新版本\n- 变更类型（major/minor/patch）\n\n### 2.3 分类整理\n\n使用配置 `dependency_management.{frontend|backend}.keywords` 匹配 PR 标题和内容，分类为前端或后端依赖。\n\n**如果指定了 `--frontend-only` 或 `--backend-only`**，只保留对应分类。\n\n---\n\n## 步骤 3: Dry-run 检查点\n\n**如果指定了 `--dry-run`**，展示分析结果并停止：\n\n```text\n[DRY RUN] 发现 {count} 个待合并的 PR\n\n前端 ({frontend_count}): PR #{number} {package} {old} → {new}\n后端 ({backend_count}): PR #{number} {package} {old} → {new}\n\n使用不带 --dry-run 的命令执行合并。\n```\n\n---\n\n## 步骤 4: 创建合并分支\n\n首先捕获日期变量（避免跨午夜执行时日期不一致）：\n\n```bash\nMERGE_DATE=$(date +%Y%m%d)\nBRANCH_NAME=\"chore/merge-dependencies-${MERGE_DATE}\"\ngit checkout -b \"${BRANCH_NAME}\"\n```\n\n**后续步骤使用 `${BRANCH_NAME}` 变量**，确保分支名称一致。\n\n---\n\n## 步骤 5: 直接修改依赖文件\n\n对每个技术栈（frontend/backend），如果有依赖更新且未被参数排除：\n\n1. 读取依赖文件（`dependency_management.{stack}.package_file`）\n2. 使用 Edit 工具批量更新版本号\n3. 运行 lock 命令（`dependency_management.{stack}.lock_command`）\n\n**如果 lock 命令失败**：立即停止，报告错误，提供恢复命令（`git checkout -- {stack}/`），询问用户是否手动解决后重试。\n\n---\n\n## 步骤 6: 验证变更\n\n运行项目的检查命令（从配置 `stacks.{frontend|backend}` 获取）。\n\n| 验证结果 | 处理方式 |\n|---------|---------|\n| 全部通过 | 继续步骤 7 |\n| Lint 失败 | 尝试自动修复（如 `eslint --fix`），重试 |\n| 测试失败 | 询问用户：1) 中止并回滚，2) 标记为 Draft PR 并继续，3) 部分回滚后重试 |\n\n**测试失败时**，必须明确询问用户选择，不可静默继续。选择 2 时必须在 PR 中添加警告标记。\n\n---\n\n## 步骤 7: 提交和推送\n\n提交所有变更并推送（使用步骤 4 中捕获的 `${BRANCH_NAME}` 变量）：\n\n```bash\ngit add .\ngit commit -m \"chore(deps): 合并依赖更新 ($(date +%Y-%m-%d))\"\ngit push -u origin \"${BRANCH_NAME}\"\n```\n\n---\n\n## 步骤 8: 创建 PR\n\n使用 `gh pr create` 创建 PR：\n\n```bash\ngh pr create --title \"chore(deps): 合并依赖更新 (YYYY-MM-DD)\" --body \"$(cat <<'EOF'\n## 概要\n\n合并以下依赖更新 PR，减少 CI 执行次数。\n\n## 包含的 PR\n\n### 前端依赖\n{foreach frontend_pr}\n- #{number}: {title}\n{/foreach}\n\n### 后端依赖\n{foreach backend_pr}\n- #{number}: {title}\n{/foreach}\n\n## 变更详情\n\n### 前端\n| 包名 | 旧版本 | 新版本 |\n|------|--------|--------|\n{frontend_changes}\n\n### 后端\n| 包名 | 旧版本 | 新版本 |\n|------|--------|--------|\n{backend_changes}\n\n## 验证结果\n\n- [ ] 代码质量检查：{lint_status}\n- [ ] 测试结果：{test_status}\n\n## 后续工作\n\n{如果有测试失败，说明原因和后续计划}\nEOF\n)\"\n```\n\n---\n\n## 步骤 9: 完成报告\n\n输出合并摘要：\n\n```text\n=== 依赖合并完成 ===\n\n分支: chore/merge-dependencies-{date}\nPR: {pr_url}\n\n已合并的依赖更新:\n- 前端: {frontend_count} 个包\n- 后端: {backend_count} 个包\n\n原始 PR（可在合并后关闭）:\n{foreach pr}\n- #{number}: {title}\n{/foreach}\n\n下一步:\n1. 等待 CI 检查通过\n2. 代码审查后合并 PR\n3. 关闭原始的依赖更新 PR\n```\n\n---\n\n## 错误处理\n\n| 错误场景 | 处理方式 |\n|---------|---------|\n| Git 操作失败 | 提供恢复命令：`git checkout main && git branch -D chore/merge-dependencies-{date}` |\n| Lock 命令失败 | 报告错误，检查版本冲突，建议手动解决 |\n| 无可合并的 PR | 说明已检查的 bot 和可能原因（已是最新、已合并、未配置 bot），建议检查配置文件 |"
              },
              {
                "name": "/pr",
                "description": "自动分析改动、运行质量检查、提交 commit 并创建 PR",
                "path": "swiss-army-knife/commands/pr.md",
                "frontmatter": {
                  "description": "自动分析改动、运行质量检查、提交 commit 并创建 PR",
                  "argument-hint": "[--no-qa] [--draft] [--log] [--verbose]",
                  "allowed-tools": "Read, Glob, Grep, Bash, AskUserQuestion"
                },
                "content": "# PR Command\n\n基于项目所有改动文件，分析变更内容，运行质量检查，提交 commit 并创建 PR。\n\n**宣布**：\"我正在使用 pr 命令分析改动并创建 PR。\"\n\n---\n\n## 参数解析\n\n从用户输入中解析参数：\n\n| 参数 | 默认值 | 说明 |\n|------|--------|------|\n| `--no-qa` | `false` | 跳过质量检查（不推荐） |\n| `--draft` | `false` | 创建草稿 PR |\n| `--log` | `false` | 启用过程日志（INFO 级别） |\n| `--verbose` | `false` | 启用详细日志（DEBUG 级别，隐含 --log） |\n\n### 日志参数说明\n\n- `--log`：记录关键步骤、Git 操作、质量检查结果\n- `--verbose`：额外记录详细的 diff 分析和命令输出\n- 日志文件位置：`.claude/logs/swiss-army-knife/pr/`\n- 生成两种格式：`.jsonl`（程序查询）和 `.log`（人类阅读）\n\n**示例**：\n\n- `/pr` - 分析改动并创建 PR\n- `/pr --draft` - 创建草稿 PR\n- `/pr --no-qa` - 跳过质量检查\n- `/pr --log` - 启用过程日志\n\n---\n\n## 步骤 0: 环境准备\n\n### 0.1 验证 gh CLI 认证\n\n**在开始任何工作之前，必须先验证 gh CLI 已认证**：\n\n```bash\ngh auth status\n```\n\n**检查认证结果**：\n\n```bash\n# 捕获认证状态输出，便于诊断失败原因\nAUTH_OUTPUT=$(gh auth status 2>&1)\nAUTH_STATUS=$?\n\nif [ $AUTH_STATUS -ne 0 ]; then\n  echo \"ERROR: GitHub CLI 认证检查失败\"\n  echo \"\"\n  echo \"认证状态输出：\"\n  echo \"$AUTH_OUTPUT\"\n  echo \"\"\n  echo \"请运行 'gh auth login' 进行认证\"\n  exit 1\nfi\n```\n\n> **重要**：如果 gh 未认证，必须在流程最开始就停止，避免用户完成所有工作后才发现无法创建 PR。\n\n### 0.2 初始化日志（如果启用 --log 或 --verbose）\n\n**生成 session_id**（与其他命令保持一致）：\n\n```bash\n# 使用 /dev/urandom 生成 8 位随机字符串，确保唯一性\nSESSION_ID=$(cat /dev/urandom | LC_ALL=C tr -dc 'a-z0-9' | head -c 8)\n```\n\n**创建日志目录和文件**：\n\n```bash\nLOG_DIR=\".claude/logs/swiss-army-knife/pr\"\nLOG_ENABLED=true\n\n# 创建日志目录（带错误检查）\nif ! mkdir -p \"$LOG_DIR\" 2>/dev/null; then\n  echo \"⚠️ 警告：无法创建日志目录 ${LOG_DIR}，日志功能已禁用\" >&2\n  LOG_ENABLED=false\nfi\n\nTIMESTAMP=$(date +\"%Y-%m-%d_%H%M%S\")\nJSONL_FILE=\"${LOG_DIR}/${TIMESTAMP}_${SESSION_ID}.jsonl\"\nLOG_FILE=\"${LOG_DIR}/${TIMESTAMP}_${SESSION_ID}.log\"\n\n# 验证文件可写（仅当目录创建成功时）\nif [ \"$LOG_ENABLED\" = true ]; then\n  if ! touch \"$JSONL_FILE\" 2>/dev/null || ! touch \"$LOG_FILE\" 2>/dev/null; then\n    echo \"⚠️ 警告：无法创建日志文件，日志功能已禁用\" >&2\n    LOG_ENABLED=false\n  fi\nfi\n```\n\n**记录 SESSION_START**（仅当日志已启用）：\n\n```bash\nif [ \"$LOG_ENABLED\" = true ]; then\n  # JSONL 格式\n  echo '{\"ts\":\"'$(date -u +\"%Y-%m-%dT%H:%M:%S.000Z\")'\",\"level\":\"I\",\"type\":\"SESSION_START\",\"session_id\":\"'$SESSION_ID'\",\"command\":\"/pr\",\"args\":{\"no_qa\":'$NO_QA',\"draft\":'$DRAFT',\"log\":true}}' >> \"$JSONL_FILE\"\n\n  # 文本格式\n  echo \"[$(date +\"%Y-%m-%d %H:%M:%S\")] INFO | SESSION_START | PR Command ($SESSION_ID)\" >> \"$LOG_FILE\"\nfi\n```\n\n> **注意**：后续每个步骤开始和结束时，如果启用了日志，都应追加对应的日志记录。\n\n---\n\n## 步骤 1: 分支状态检查\n\n### 1.1 获取当前分支\n\n```bash\ngit branch --show-current\n```\n\n### 1.2 根据分支采取不同策略\n\n**如果当前是 main 分支**：\n\n1. 基于 main 创建新的特性分支\n2. 询问用户分支名称，或根据改动内容自动生成\n\n**分支命名规则**：\n\n```text\nfeat/<short-description>   # 新功能，如 feat/add-auth-module\nfix/<short-description>    # 修复问题，如 fix/login-timeout\ndocs/<short-description>   # 文档更新，如 docs/api-reference\nrefactor/<short-description> # 代码重构\nchore/<short-description>  # 构建/工具变更\n```\n\n**如果当前不是 main 分支**：\n\n1. 检查是否有远程分支：`git fetch origin && git branch -r | grep \"origin/$(git branch --show-current)\"`\n2. 如果有远程分支，检查是否需要 pull：\n\n   ```bash\n   git fetch origin\n   git status -uno\n   ```\n\n3. 如果本地落后于远程，执行 pull：\n\n   ```bash\n   git pull origin $(git branch --show-current)\n   ```\n\n4. 检查是否需要与 main 同步：\n\n   ```bash\n   git fetch origin main\n   git merge-base --is-ancestor origin/main HEAD || echo \"需要 merge main\"\n   ```\n\n5. 如果需要，执行 merge main：\n\n   ```bash\n   git merge origin/main\n   ```\n\n   **检查 merge 结果**：\n\n   ```bash\n   # 检查是否有冲突\n   if [ -n \"$(git ls-files -u)\" ]; then\n     echo \"ERROR: 与 main 分支存在合并冲突\"\n     echo \"冲突文件：\"\n     git ls-files -u | awk '{print $4}' | sort -u\n     echo \"\"\n     echo \"请手动解决冲突后再运行此命令\"\n     echo \"或执行 'git merge --abort' 取消合并\"\n     exit 1\n   fi\n   ```\n\n   > **重要**：如果 merge 产生冲突，必须停止流程并列出冲突文件，让用户手动处理。\n\n---\n\n## 步骤 2: 分析改动\n\n### 2.1 获取改动文件列表\n\n```bash\ngit status --porcelain\ngit diff --stat\ngit diff --cached --stat\n```\n\n**检查是否有改动**：\n\n```bash\n# 检查是否有任何改动（工作区 + 暂存区）\nif [ -z \"$(git status --porcelain)\" ]; then\n  echo \"ERROR: 没有检测到任何改动，无法创建 PR\"\n  echo \"请先进行代码修改后再运行此命令\"\n  exit 1\nfi\n```\n\n> **重要**：如果没有任何改动（工作区和暂存区都为空），必须停止流程并提示用户。\n\n### 2.2 分析改动内容\n\n对于每个改动的文件：\n\n1. 读取文件 diff：`git diff <file>` 或 `git diff --cached <file>`\n2. 总结改动要点\n3. 识别改动类型：feat/fix/docs/refactor/chore/test\n\n---\n\n## 步骤 3: 质量检查（除非指定 --no-qa）\n\n### 3.1 检测项目 QA 命令\n\n**首先检测包管理器**（用于 Node.js 项目）：\n\n```bash\n# 检测包管理器\nif [ -f pnpm-lock.yaml ]; then\n  PKG_MANAGER=\"pnpm\"\nelif [ -f yarn.lock ]; then\n  PKG_MANAGER=\"yarn\"\nelif [ -f package-lock.json ]; then\n  PKG_MANAGER=\"npm\"\nelse\n  PKG_MANAGER=\"npm\"  # 默认使用 npm\nfi\n```\n\n**然后按以下优先级检测项目使用的质量检查命令**：\n\n1. **Makefile**：检查是否存在 `make qa` 或 `make lint` 或 `make check`\n\n   ```bash\n   if [ -f Makefile ]; then\n     grep -E \"^(qa|lint|check):\" Makefile\n   fi\n   ```\n\n2. **package.json**：检查 npm scripts\n\n   ```bash\n   if [ -f package.json ]; then\n     # 检查 lint、test、check 等脚本\n     cat package.json | grep -E '\"(lint|test|check|qa)\"'\n   fi\n   ```\n\n3. **pyproject.toml / setup.cfg**：Python 项目\n\n   ```bash\n   if [ -f pyproject.toml ]; then\n     # 检查 ruff 配置\n     grep -q \"\\[tool.ruff\" pyproject.toml && echo \"ruff: ruff check .\"\n     # 检查 black 配置\n     grep -q \"\\[tool.black\" pyproject.toml && echo \"black: black --check .\"\n     # 检查 mypy 配置\n     grep -q \"\\[tool.mypy\" pyproject.toml && echo \"mypy: mypy .\"\n     # 检查 pytest 配置\n     grep -q \"\\[tool.pytest\" pyproject.toml && echo \"pytest: pytest\"\n     # 检查 poetry scripts\n     grep -q \"\\[tool.poetry.scripts\" pyproject.toml && echo \"poetry scripts available\"\n   fi\n   ```\n\n### 3.2 运行质量检查\n\n根据检测结果运行对应命令。使用上一步检测到的 `$PKG_MANAGER`：\n\n| 检测到 | 运行命令 |\n|--------|----------|\n| Makefile 有 `qa` | `make qa` |\n| Makefile 有 `lint` | `make lint` |\n| package.json 有 `lint` | `$PKG_MANAGER run lint` |\n| package.json 有 `check` | `$PKG_MANAGER run check` |\n| package.json 有 `test` | `$PKG_MANAGER run test` |\n| pyproject.toml + ruff | `ruff check .` |\n| pyproject.toml + black | `black --check .` |\n| pyproject.toml + mypy | `mypy .` |\n\n**如果质量检查失败**：\n\n1. 显示错误详情\n2. 询问用户：\n   - \"发现质量检查错误。是否要我尝试自动修复？\"\n   - 选项：[自动修复] [手动修复] [跳过检查继续]\n\n3. 如果选择自动修复，运行对应的 fix 命令（如 `make lint-fix`、`npm run lint -- --fix`）\n\n### 3.3 质量检查跳过审计\n\n**如果用户指定了 `--no-qa` 或选择跳过检查**：\n\n1. 在 PR body 中添加警告标记：\n\n   ```markdown\n   > ⚠️ **注意**：此 PR 跳过了质量检查（lint/test）\n   ```\n\n2. 如果启用了日志，记录跳过事件：\n\n   ```bash\n   # JSONL 格式\n   echo '{\"ts\":\"'$(date -u +\"%Y-%m-%dT%H:%M:%S.000Z\")'\",\"level\":\"W\",\"type\":\"QA_SKIPPED\",\"session_id\":\"'$SESSION_ID'\",\"reason\":\"user_requested\"}' >> \"$JSONL_FILE\"\n\n   # 文本格式\n   echo \"[$(date +\"%Y-%m-%d %H:%M:%S\")] WARN | QA_SKIPPED | 质量检查被用户跳过\" >> \"$LOG_FILE\"\n   ```\n\n> **重要**：跳过质量检查应该有明确的审计记录，方便后续追溯问题。\n\n---\n\n## 步骤 4: 生成 Commit 信息\n\n### 4.1 基于改动分析生成 commit message\n\n遵循 Conventional Commits 格式：\n\n```text\n<type>(<scope>): <description>\n\n[可选的详细描述]\n\n[可选的 footer]\n```\n\n**类型映射**：\n\n- `feat`: 新功能\n- `fix`: 修复问题\n- `docs`: 文档更新\n- `refactor`: 代码重构\n- `chore`: 构建/工具变更\n- `test`: 测试相关\n- `style`: 代码风格（不影响功能）\n- `perf`: 性能优化\n\n### 4.2 确认 commit message\n\n向用户展示生成的 commit message，询问是否需要修改。\n\n---\n\n## 步骤 5: 提交改动\n\n### 5.1 暂存文件\n\n```bash\ngit add -A\n```\n\n> **注意**：`git add -A` 会暂存所有改动（包括新文件、修改和删除）。\n> 如果需要更精确控制，可以：\n>\n> - 只添加已跟踪文件的修改：`git add -u`\n> - 交互式选择：`git add -p`\n> - 添加特定文件：`git add <file1> <file2>`\n\n### 5.2 创建 commit\n\n```bash\ngit commit -m \"<commit message>\"\n```\n\n---\n\n## 步骤 6: 创建 PR\n\n### 6.1 推送分支\n\n```bash\ngit push -u origin $(git branch --show-current)\n```\n\n**检查 push 结果**：\n\n```bash\nPUSH_RESULT=$?\nif [ $PUSH_RESULT -ne 0 ]; then\n  echo \"ERROR: 推送分支失败，退出码: $PUSH_RESULT\"\n  echo \"可能的原因：\"\n  echo \"  - 没有远程仓库写权限\"\n  echo \"  - 远程分支有新提交需要先 pull\"\n  echo \"  - 网络连接问题\"\n  exit 1\nfi\n```\n\n> **重要**：如果 push 失败，必须停止流程并向用户报告错误，不能继续创建 PR。\n\n### 6.2 生成 PR 内容\n\n基于 commit 分析生成：\n\n- **Title**: 简洁描述主要改动\n- **Body**: 包含以下部分：\n  - `## Summary`: 改动摘要（2-3 个要点）\n  - `## Changes`: 改动文件列表和说明\n  - `## Test Plan`: 测试说明（如适用）\n\n### 6.3 创建 PR\n\n**如果指定了 `--draft` 参数**：\n\n```bash\ngh pr create \\\n  --title \"<PR title>\" \\\n  --body \"<PR body>\" \\\n  --draft\n```\n\n**否则创建正式 PR**：\n\n```bash\ngh pr create \\\n  --title \"<PR title>\" \\\n  --body \"<PR body>\"\n```\n\n---\n\n## 步骤 7: 完成报告\n\n输出结果摘要：\n\n```text\nPR 创建成功！\n\nCommit: <commit hash> - <commit message>\nPR: <PR URL>\n分支: <branch name>\n\n改动文件：\n- file1 (新增/修改/删除)\n- file2 (新增/修改/删除)\n...\n\n下一步：\n1. 在 GitHub 上查看 PR：<PR URL>\n2. 等待 CI 检查完成\n3. 请求 review\n```\n\n---\n\n## 错误处理\n\n### Git 冲突\n\n如果遇到 merge 冲突：\n\n1. 列出冲突文件\n2. 询问用户如何处理\n3. 提供恢复命令：`git merge --abort`\n\n### Push 失败\n\n如果 push 失败：\n\n1. 检查是否是权限问题\n2. 检查是否需要 pull\n3. 提供具体的解决建议\n\n### PR 创建失败\n\n如果 gh pr create 失败：\n\n1. 检查 gh 是否已认证：`gh auth status`\n2. 检查是否已有同名 PR\n3. 提供手动创建 PR 的链接"
              },
              {
                "name": "/release",
                "description": "自动化发版流程：更新 CHANGELOG、plugin.json、创建 git tag 并推送",
                "path": "swiss-army-knife/commands/release.md",
                "frontmatter": {
                  "description": "自动化发版流程：更新 CHANGELOG、plugin.json、创建 git tag 并推送",
                  "argument-hint": "<version> [--no-push] [--dry-run]",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "Edit",
                    "Bash",
                    "AskUserQuestion"
                  ]
                },
                "content": "# Release Command\n\n自动化插件发版流程，包括更新文档、版本号、创建 tag 和推送。\n\n**宣布**：\"我正在使用 release 命令执行自动化发版流程。\"\n\n---\n\n## 参数解析\n\n从用户输入中解析参数：\n\n- `<version>`：新版本号（必需，格式：X.Y.Z，例如 0.3.0）\n- `--no-push`：不自动推送 tag 到远程仓库\n- `--dry-run`：预览操作但不实际执行\n\n**示例**：\n\n- `/release 0.3.0` - 发布 0.3.0 版本并推送\n- `/release 0.3.0 --no-push` - 发布 0.3.0 但不推送\n- `/release 0.3.0 --dry-run` - 预览发布操作\n\n---\n\n## 步骤 1: 参数验证\n\n### 1.1 验证版本号格式\n\n检查版本号是否符合语义化版本格式（X.Y.Z）：\n\n```bash\nif [[ ! \"$VERSION\" =~ ^[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n  echo \"错误：版本号格式不正确。应为 X.Y.Z 格式（例如：0.3.0）\"\n  exit 1\nfi\n```\n\n### 1.2 读取当前版本\n\n读取 `.claude-plugin/plugin.json` 获取当前版本号，确保新版本号大于当前版本。\n\n**验证规则**：\n\n- 如果当前是 0.2.0，新版本应该是 0.2.1、0.3.0 或 1.0.0\n- 不允许降级版本或使用相同版本号\n\n---\n\n## 步骤 2: 工作区检查\n\n### 2.1 检查 git 状态\n\n确保工作区干净，避免意外提交未完成的工作：\n\n```bash\n# 检查是否有未提交的更改\ngit status --porcelain\n```\n\n如果有未提交的更改，询问用户：\n\n- \"检测到未提交的更改。是否继续？这些更改将包含在发版提交中。\"\n- 选项：[继续] [取消]\n\n### 2.2 验证 CHANGELOG.md\n\n读取 `CHANGELOG.md` 并验证：\n\n1. 文件存在\n2. 包含 `## [未发布]` 区域\n3. [未发布] 区域下有实际内容（不只是空标题）\n\n如果 [未发布] 区域为空，警告用户：\n\n- \"CHANGELOG.md 的 [未发布] 区域为空。是否继续发版？\"\n- 选项：[继续] [取消]\n\n---\n\n## 步骤 3: 更新文件\n\n### 3.1 更新 CHANGELOG.md\n\n执行以下转换：\n\n1. **添加新版本标题**：\n\n   ```markdown\n   ## [未发布]\n\n   ## [X.Y.Z] - YYYY-MM-DD\n   ```\n\n   将 [未发布] 下的内容移到新版本标题下。\n\n2. **更新底部链接**：\n\n   ```markdown\n   [未发布]: https://github.com/penkzhou/swiss-army-knife-plugin/compare/vX.Y.Z...HEAD\n   [X.Y.Z]: https://github.com/penkzhou/swiss-army-knife-plugin/compare/vPREV...vX.Y.Z\n   ```\n\n**实现**：使用 Read 读取文件，使用 Edit 工具进行精确替换。\n\n### 3.2 更新 plugin.json\n\n更新 `.claude-plugin/plugin.json` 中的版本号：\n\n```json\n{\n  \"version\": \"X.Y.Z\"\n}\n```\n\n**实现**：使用 Read 和 Edit 工具进行精确替换。\n\n---\n\n## 步骤 4: Git 操作\n\n### 4.1 创建提交\n\n**如果不是 dry-run 模式**：\n\n```bash\ngit add CHANGELOG.md .claude-plugin/plugin.json\ngit commit -m \"chore: release version X.Y.Z\"\n```\n\n### 4.2 创建 tag\n\n```bash\ngit tag -a vX.Y.Z -m \"Release version X.Y.Z\"\n```\n\n### 4.3 推送（可选）\n\n**如果没有 --no-push 标志**：\n\n```bash\ngit push origin main\ngit push origin vX.Y.Z\n```\n\n**如果有 --no-push 标志**：\n\n提示用户：\n\n```text\n✅ 发版完成！Tag vX.Y.Z 已创建。\n\n要推送到远程仓库，请运行：\n  git push origin main\n  git push origin vX.Y.Z\n```\n\n---\n\n## 步骤 5: 完成报告\n\n输出发版摘要：\n\n```text\n🎉 版本 X.Y.Z 发布成功！\n\n✅ 已更新 CHANGELOG.md\n✅ 已更新 .claude-plugin/plugin.json\n✅ 已创建 git commit\n✅ 已创建 tag vX.Y.Z\n[✅ 已推送到远程仓库] （如果执行了推送）\n\n下一步：\n1. 在 GitHub 上创建 Release：https://github.com/penkzhou/swiss-army-knife-plugin/releases/new?tag=vX.Y.Z\n2. 更新 CHANGELOG.md 的 [未发布] 区域，记录下一个版本的变更\n```\n\n---\n\n## 错误处理\n\n在每个步骤中，如果遇到错误：\n\n1. 清晰地报告错误信息\n2. 如果已经修改了文件，提供恢复命令：\n\n   ```bash\n   git checkout CHANGELOG.md .claude-plugin/plugin.json\n   git tag -d vX.Y.Z  # 如果 tag 已创建\n   ```\n\n3. 停止执行，不继续后续步骤\n\n---\n\n## Dry-run 模式\n\n如果指定了 `--dry-run`：\n\n1. 执行所有验证步骤\n2. 显示将要进行的操作（不实际执行）：\n\n   ```text\n   [DRY RUN] 将执行以下操作：\n   1. 更新 CHANGELOG.md：将 [未发布] 内容移到 [X.Y.Z] - YYYY-MM-DD\n   2. 更新 .claude-plugin/plugin.json：version: \"0.2.0\" → \"X.Y.Z\"\n   3. 创建 git commit：chore: release version X.Y.Z\n   4. 创建 git tag：vX.Y.Z\n   [5. 推送到远程仓库] （如果没有 --no-push）\n   ```\n\n3. 不修改任何文件，不执行 git 操作"
              }
            ],
            "skills": [
              {
                "name": "backend-bugfix",
                "description": "This skill should be used when the user asks to \"debug backend tests\", \"fix pytest failures\", \"analyze Python errors\", \"fix FastAPI bugs\", or mentions keywords like \"pytest\", \"IntegrityError\", \"ValidationError\", \"SQLAlchemy\", \"FastAPI\". It provides the complete bugfix workflow knowledge including error classification, confidence scoring, and TDD best practices for Python/FastAPI backends.\n",
                "path": "swiss-army-knife/skills/backend-bugfix/SKILL.md",
                "frontmatter": {
                  "name": "backend-bugfix",
                  "description": "This skill should be used when the user asks to \"debug backend tests\", \"fix pytest failures\", \"analyze Python errors\", \"fix FastAPI bugs\", or mentions keywords like \"pytest\", \"IntegrityError\", \"ValidationError\", \"SQLAlchemy\", \"FastAPI\". It provides the complete bugfix workflow knowledge including error classification, confidence scoring, and TDD best practices for Python/FastAPI backends.\n",
                  "version": "2.1.0"
                },
                "content": "# Backend Bugfix Workflow Skill\n\n本 skill 提供后端测试 bugfix 的完整工作流知识，包括错误分类体系、置信度评分系统和 TDD 最佳实践。\n\n## 错误分类体系\n\n后端测试失败主要分为以下类型（按频率排序）：\n\n### 1. 数据库错误（30%）\n\n**症状**：数据库连接失败、查询错误、事务问题\n\n**识别特征**：\n\n- `IntegrityError`、`OperationalError`\n- `sqlalchemy.exc.*` 异常\n- `UNIQUE constraint failed`\n- 事务未提交或未回滚\n\n**解决策略**：正确处理事务边界\n\n```python\n# Before - 事务未正确处理\ndef create_user(db: Session, user: UserCreate):\n    db_user = User(**user.dict())\n    db.add(db_user)\n    db.commit()  # 失败时无回滚\n    return db_user\n\n# After - 使用 try/except 确保事务安全\ndef create_user(db: Session, user: UserCreate):\n    try:\n        db_user = User(**user.dict())\n        db.add(db_user)\n        db.commit()\n        db.refresh(db_user)\n        return db_user\n    except IntegrityError:\n        db.rollback()\n        raise HTTPException(status_code=409, detail=\"User already exists\")\n```\n\n### 2. 验证错误（25%）\n\n**症状**：输入验证失败、Schema 不匹配\n\n**识别特征**：\n\n- `ValidationError`\n- `pydantic.error_wrappers`\n- `422 Unprocessable Entity`\n- `field required` 错误\n\n**解决策略**：完善 Pydantic Schema\n\n```python\n# Before - 缺少验证\nclass UserCreate(BaseModel):\n    email: str  # 没有格式验证\n\n# After - 使用 Pydantic 验证器\nclass UserCreate(BaseModel):\n    email: EmailStr\n\n    @field_validator('email')\n    @classmethod\n    def email_must_be_valid(cls, v):\n        if not v or '@' not in v:\n            raise ValueError('Invalid email format')\n        return v.lower()\n```\n\n### 3. API 错误（20%）\n\n**症状**：端点返回错误状态码、路由不匹配\n\n**识别特征**：\n\n- `HTTPException`\n- `404 Not Found`、`405 Method Not Allowed`\n- 响应格式不符合预期\n\n**解决策略**：检查路由定义和请求方法\n\n```python\n# 确保端点定义正确\n@router.get(\"/users/{user_id}\", response_model=UserResponse)\nasync def get_user(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user\n```\n\n### 4. 认证错误（10%）\n\n**症状**：认证失败、权限不足\n\n**识别特征**：\n\n- `401 Unauthorized`\n- `403 Forbidden`\n- Token 相关错误\n- `credentials` 验证失败\n\n**解决策略**：检查认证流程和 Token 处理\n\n```python\n# 确保 Token 验证正确\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        user_id: str = payload.get(\"sub\")\n        if user_id is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    return user_id\n```\n\n### 5. 异步错误（8%）\n\n**症状**：异步操作超时、并发问题\n\n**识别特征**：\n\n- `TimeoutError`\n- `CancelledError`\n- `asyncio` 相关异常\n- 缺少 `await` 关键字\n\n**解决策略**：正确使用 async/await\n\n```python\n# Before - 忘记 await\nasync def get_data():\n    result = fetch_from_external_api()  # 缺少 await\n    return result\n\n# After - 正确等待异步操作\nasync def get_data():\n    result = await fetch_from_external_api()\n    return result\n```\n\n### 6. 配置错误（5%）\n\n**症状**：配置加载失败、环境变量缺失\n\n**识别特征**：\n\n- `KeyError`\n- `environment` 相关错误\n- `settings` 加载失败\n\n**解决策略**：使用 Pydantic Settings 管理配置\n\n```python\nfrom pydantic_settings import BaseSettings\n\nclass Settings(BaseSettings):\n    database_url: str\n    secret_key: str\n\n    class Config:\n        env_file = \".env\"\n\nsettings = Settings()\n```\n\n## 置信度评分系统\n\n### 评分标准（0-100）\n\n| 分数 | 级别 | 行为 |\n| ------ | ------ | ------ |\n| 80+ | 高 | 自动执行 |\n| 60-79 | 中 | 标记验证后继续 |\n| 40-59 | 低 | 暂停询问用户 |\n| <40 | 不确定 | 停止收集信息 |\n\n### 置信度计算\n\n```text\n置信度 = 证据质量(40%) + 模式匹配(30%) + 上下文完整性(20%) + 可复现性(10%)\n```\n\n**证据质量**：\n\n- 高：有完整堆栈、行号、可稳定复现\n- 中：有错误信息但缺上下文\n- 低：仅有模糊描述\n\n**模式匹配**：\n\n- 高：完全匹配已知错误模式\n- 中：部分匹配\n- 低：未知错误类型\n\n**上下文完整性**：\n\n- 高：测试代码 + 源代码 + 配置 + 数据库 Schema\n- 中：只有测试或源代码\n- 低：只有错误信息\n\n**可复现性**：\n\n- 高：每次运行都复现\n- 中：偶发（可能与数据或并发相关）\n- 低：环境相关\n\n## TDD 流程\n\n### RED Phase（写失败测试）\n\n```python\nimport pytest\nfrom fastapi.testclient import TestClient\n\ndef test_create_user_duplicate_email(client: TestClient, db_session):\n    \"\"\"测试重复邮箱应返回 409\"\"\"\n    # 1. 设置前置条件\n    client.post(\"/api/users\", json={\"email\": \"test@example.com\", \"name\": \"User 1\"})\n\n    # 2. 执行被测操作\n    response = client.post(\"/api/users\", json={\"email\": \"test@example.com\", \"name\": \"User 2\"})\n\n    # 3. 断言期望结果\n    assert response.status_code == 409\n    assert \"already exists\" in response.json()[\"detail\"]\n```\n\n### GREEN Phase（最小实现）\n\n```python\n# 只写让测试通过的最小代码\n# 不要优化，不要添加额外功能\ndef create_user(db: Session, user: UserCreate):\n    existing = db.query(User).filter(User.email == user.email).first()\n    if existing:\n        raise HTTPException(status_code=409, detail=\"User already exists\")\n    # ... 创建用户逻辑\n```\n\n### REFACTOR Phase（重构）\n\n```python\n# 改善代码结构\n# 保持测试通过\n# 消除重复\n# 提取公共逻辑到服务层\n```\n\n## 质量门禁\n\n| 检查项 | 标准 |\n| ---------- | ------ |\n| 测试通过率 | 100% |\n| 代码覆盖率 | >= 90% |\n| 新代码覆盖率 | 100% |\n| Lint (flake8) | 无错误 |\n| TypeCheck (mypy) | 无错误 |\n\n## pytest 常用模式\n\n### Fixtures\n\n```python\n@pytest.fixture\ndef db_session():\n    \"\"\"创建测试数据库会话\"\"\"\n    engine = create_engine(\"sqlite:///:memory:\")\n    Base.metadata.create_all(engine)\n    Session = sessionmaker(bind=engine)\n    session = Session()\n    yield session\n    session.close()\n\n@pytest.fixture\ndef client(db_session):\n    \"\"\"创建测试客户端\"\"\"\n    def override_get_db():\n        yield db_session\n    app.dependency_overrides[get_db] = override_get_db\n    return TestClient(app)\n```\n\n### 异步测试\n\n```python\nimport pytest\n\n@pytest.mark.asyncio\nasync def test_async_operation():\n    result = await some_async_function()\n    assert result is not None\n```\n\n### 参数化测试\n\n```python\n@pytest.mark.parametrize(\"status_code,detail\", [\n    (400, \"Invalid input\"),\n    (404, \"Not found\"),\n    (409, \"Already exists\"),\n])\ndef test_error_responses(client, status_code, detail):\n    # 测试多种错误场景\n    pass\n```\n\n## 常用命令\n\n```bash\n# 运行后端测试\nmake test TARGET=backend\n\n# 运行特定测试\nmake test TARGET=backend FILTER=test_create_user\n\n# 或使用 pytest 直接运行\npytest tests/ -k \"test_create_user\" -v\n\n# 覆盖率检查\npytest --cov=app --cov-report=term-missing --cov-fail-under=90\n\n# Lint 检查\nflake8 app/ tests/\n\n# 类型检查\nmypy app/\n\n# 完整 QA\nmake qa\n```\n\n## 相关文档\n\n文档路径由配置指定（`best_practices_dir`），使用以下关键词搜索：\n\n- **测试最佳实践**：关键词 \"testing\", \"pytest\", \"backend\"\n- **数据库操作**：关键词 \"database\", \"sqlalchemy\", \"transaction\"\n- **API 设计**：关键词 \"api\", \"endpoint\", \"fastapi\"\n- **问题诊断**：关键词 \"troubleshooting\", \"debugging\""
              },
              {
                "name": "bugfix-workflow",
                "description": "通用 Bugfix 工作流知识库，包含 TDD 流程、输出格式规范、置信度评分标准和通用最佳实践。适用于所有技术栈（backend/frontend/e2e）。",
                "path": "swiss-army-knife/skills/bugfix-workflow/SKILL.md",
                "frontmatter": {
                  "name": "bugfix-workflow",
                  "description": "通用 Bugfix 工作流知识库，包含 TDD 流程、输出格式规范、置信度评分标准和通用最佳实践。适用于所有技术栈（backend/frontend/e2e）。"
                },
                "content": "# Bugfix 工作流通用知识库\n\n本 Skill 提供标准化 6 阶段 Bugfix 工作流的通用知识，适用于所有技术栈。\n\n## TDD 流程（核心原则）\n\n### RED Phase（先写失败测试）\n\n1. **测试必须能复现当前 bug**\n2. **测试必须在修复前失败**\n3. **测试应该测试行为，不是实现**\n\n验证命令模板：\n```bash\nmake test TARGET={stack} FILTER={test_file}\n```\n\n### GREEN Phase（最小实现）\n\n1. **只写让测试通过的最小代码**\n2. **不要在此阶段优化**\n3. **不要添加未被测试覆盖的功能**\n\n### REFACTOR Phase（重构）\n\n1. **改善代码结构**\n2. **保持测试通过**\n3. **消除重复代码**\n\n最终验证：\n```bash\nmake test TARGET={stack}\nmake lint TARGET={stack}\nmake typecheck TARGET={stack}\n```\n\n## 置信度评分标准\n\n### 根因分析置信度\n\n| 分数范围 | 行为 |\n|----------|------|\n| ≥60 | 自动继续 |\n| 40-59 | 暂停询问用户 |\n| <40 | 停止并收集更多信息 |\n\n### 代码审查置信度\n\n| 分数范围 | 级别 | 行为 |\n|----------|------|------|\n| ≥90 | Critical | 自动修复 |\n| 80-89 | Important | 自动修复 |\n| <80 | 低于阈值 | 不报告 |\n\n## 通用输出格式\n\n### Error 结构\n\n```json\n{\n  \"id\": \"BF-{YYYY}-{MMDD}-{NNN}\",\n  \"file\": \"文件路径\",\n  \"line\": 行号,\n  \"severity\": \"critical|high|medium|low\",\n  \"category\": \"错误类型\",\n  \"description\": \"问题描述\",\n  \"evidence\": [\"支持判断的证据\"],\n  \"stack\": \"堆栈信息\"\n}\n```\n\n### Summary 结构\n\n```json\n{\n  \"total\": 总数,\n  \"by_type\": { \"类型\": 数量 },\n  \"by_file\": { \"文件\": 数量 }\n}\n```\n\n### Solution 结构\n\n```json\n{\n  \"solution\": {\n    \"approach\": \"修复思路概述\",\n    \"steps\": [\"步骤1\", \"步骤2\"],\n    \"risks\": [\"风险1\", \"风险2\"],\n    \"estimated_complexity\": \"low|medium|high\"\n  },\n  \"tdd_plan\": {\n    \"red_phase\": { \"tests\": [...] },\n    \"green_phase\": { \"changes\": [...] },\n    \"refactor_phase\": { \"items\": [...] }\n  },\n  \"impact_analysis\": {\n    \"affected_files\": [...],\n    \"api_changes\": [...],\n    \"test_impact\": [...]\n  },\n  \"security_review\": {\n    \"performed\": true/false,\n    \"vulnerabilities\": [...],\n    \"passed\": true/false\n  }\n}\n```\n\n### Execution Result 结构\n\n```json\n{\n  \"issue_id\": \"BF-2025-MMDD-001\",\n  \"phases\": {\n    \"red\": { \"status\": \"pass|fail|skip\", \"duration_ms\": 1234 },\n    \"green\": { \"status\": \"pass|fail|skip\", \"changes\": [...] },\n    \"refactor\": { \"status\": \"pass|fail|skip\", \"changes\": [...] }\n  },\n  \"overall_status\": \"success|partial|failed\"\n}\n```\n\n## 影响分析维度\n\n1. **直接影响**：修改的文件\n2. **间接影响**：依赖修改文件的组件\n3. **API 影响**：是否有破坏性变更\n4. **测试影响**：需要更新的测试\n\n## 安全审查清单（常见安全问题）\n\n仅在涉及敏感代码（认证、输入处理、数据存储等）时进行：\n\n- [ ] SQL/命令注入\n- [ ] XSS 跨站脚本\n- [ ] 敏感信息泄露\n- [ ] 认证/授权问题\n- [ ] 输入验证不足\n\n## 批次执行策略\n\n1. **默认批次大小**：3 个问题/批\n2. **每批完成后**：输出批次报告，等待用户确认\n3. **失败处理**：记录失败原因，尝试最多 3 次，3 次失败后标记为 failed\n\n## Bugfix 文档模板\n\n```markdown\n# [问题简述] Bugfix 报告\n\n> 日期：{YYYY-MM-DD}\n> 置信度：{confidence}/100\n> 技术栈：{stack}\n\n## 1. 问题描述\n\n### 1.1 错误信息\n[结构化错误列表]\n\n### 1.2 根因分析\n[根因描述 + 证据]\n\n## 2. 修复方案\n\n### 2.1 TDD 计划\n\n#### RED Phase\n[失败测试代码]\n\n#### GREEN Phase\n[最小实现代码]\n\n#### REFACTOR Phase\n- [ ] 重构项\n\n### 2.2 影响分析\n[影响范围]\n\n## 3. 验证计划\n\n- [ ] 测试通过\n- [ ] 覆盖率达标\n- [ ] 无回归\n```\n\n## 知识沉淀标准\n\n### 值得沉淀的知识\n\n1. **新发现的问题模式** - 之前没有记录的错误类型\n2. **可复用的解决方案** - 适用于多种场景的修复模式\n3. **重要的教训** - 容易犯的错误，反直觉的行为\n4. **性能优化** - 测试执行速度提升\n\n### 不需要沉淀的情况\n\n1. **一次性问题** - 特定于某个文件的 typo\n2. **已有文档覆盖** - 问题已在 troubleshooting 中记录\n\n## 质量门禁标准\n\n| 检查项 | 标准 | 阻塞级别 |\n|--------|------|----------|\n| 测试通过 | 100% | 阻塞 |\n| 覆盖率 | >= 90% | 阻塞 |\n| 新代码覆盖率 | 100% | 阻塞 |\n| Lint | 无错误 | 阻塞 |\n| TypeCheck | 无错误 | 阻塞 |\n| 回归测试 | 无回归 | 阻塞 |"
              },
              {
                "name": "ci-job-analysis",
                "description": "CI Job 失败分析知识库，包含失败类型分类、置信度评估、技术栈识别和常见错误模式",
                "path": "swiss-army-knife/skills/ci-job-analysis/SKILL.md",
                "frontmatter": {
                  "name": "ci-job-analysis",
                  "description": "CI Job 失败分析知识库，包含失败类型分类、置信度评估、技术栈识别和常见错误模式"
                },
                "content": "# CI Job 分析知识库\n\n本知识库提供 GitHub Actions Job 失败分析和修复的专业知识。\n\n## 失败类型分类体系\n\n### 1. 测试失败 (test_failure)\n\n| 子类型 | 频率 | 关键信号 | 可自动修复 |\n|--------|------|----------|-----------|\n| unit_test | 45% | pytest FAILED, jest FAIL, vitest | 是 |\n| integration_test | 30% | integration, api test, mock server | 是 |\n| snapshot_test | 15% | snapshot, toMatchSnapshot | 是 |\n| other_test | 10% | 其他测试框架 | 部分 |\n\n> **注意**：频率数据基于历史统计，总和为 100%。\n\n**常见根因**：\n\n1. **Mock 数据不完整**：测试 mock 缺少新增字段\n2. **API 契约变更**：接口返回格式改变\n3. **异步时序问题**：await 缺失或时序错误\n4. **环境差异**：CI 环境与本地环境不一致\n\n**修复策略**：\n\n```text\n1. 定位失败测试和断言\n2. 比较期望值 vs 实际值\n3. 追踪数据流到源头\n4. 更新 mock 或修复断言\n5. 验证修复\n```\n\n### 2. E2E 失败 (e2e_failure)\n\n| 子类型 | 频率 | 关键信号 | 可自动修复 |\n|--------|------|----------|-----------|\n| timeout | 35% | Timeout, 30000ms, waiting for | 是 |\n| selector | 30% | strict mode, not found, resolved to | 是 |\n| assertion | 20% | expect().toHave, toBeVisible | 是 |\n| network | 15% | Route handler, net::ERR | 部分 |\n\n**常见根因**：\n\n1. **选择器过时**：UI 变更导致选择器失效\n2. **加载时序**：页面加载慢导致超时\n3. **网络拦截失效**：API mock 未正确配置\n4. **状态污染**：测试之间状态未隔离\n\n**修复策略**：\n\n```text\n1. 分析超时/选择器错误的具体位置\n2. 检查 UI 是否变更\n3. 添加适当的等待策略\n4. 更新选择器或断言\n```\n\n### 3. 构建失败 (build_failure)\n\n| 子类型 | 频率 | 关键信号 | 可自动修复 |\n|--------|------|----------|-----------|\n| typescript | 45% | tsc, error TS, compile | 部分 |\n| webpack | 20% | webpack, Module not found | 部分 |\n| python | 20% | SyntaxError, ModuleNotFound | 部分 |\n| other | 15% | build failed, make error | 否 |\n\n**常见根因**：\n\n1. **类型不匹配**：TypeScript 类型错误\n2. **缺失依赖**：import 的模块不存在\n3. **语法错误**：代码语法问题\n4. **配置错误**：构建配置不正确\n\n### 4. Lint 失败 (lint_failure)\n\n| 子类型 | 频率 | 关键信号 | 可自动修复 |\n|--------|------|----------|-----------|\n| eslint | 50% | eslint, @typescript-eslint | 是 |\n| ruff | 25% | ruff, E501, W503 | 是 |\n| prettier | 20% | prettier, formatting | 是 |\n| other | 5% | mypy, pylint | 部分 |\n\n**快速修复路径**：\n\n```bash\n# ESLint\nnpx eslint --fix {files}\n\n# Ruff\nruff check --fix {files}\n\n# Prettier\nnpx prettier --write {files}\n```\n\n### 5. 类型检查失败 (type_check_failure)\n\n| 子类型 | 频率 | 关键信号 | 可自动修复 |\n|--------|------|----------|-----------|\n| typescript | 70% | tsc --noEmit, error TS | 部分 |\n| mypy | 30% | mypy, type: ignore | 部分 |\n\n**常见错误类型**：\n\n| 错误码 | 描述 | 自动修复 |\n|--------|------|----------|\n| TS2345 | 参数类型不匹配 | 否 |\n| TS2322 | 类型赋值错误 | 否 |\n| TS2339 | 属性不存在 | 否 |\n| TS7006 | 隐式 any | 是 |\n\n### 6. 依赖失败 (dependency_failure)\n\n| 子类型 | 频率 | 关键信号 | 可自动修复 |\n|--------|------|----------|-----------|\n| npm | 40% | npm install, ERESOLVE | 否 |\n| pip | 35% | pip install, requirement | 否 |\n| yarn | 15% | yarn, resolution | 否 |\n| other | 10% | pnpm, poetry | 否 |\n\n**常见问题**：\n\n1. 版本冲突\n2. 私有包认证失败\n3. 网络问题\n4. 锁文件过时\n\n**建议**：依赖问题通常需要手动处理，因为涉及版本策略决策。\n\n### 7. 配置失败 (config_failure)\n\n| 子类型 | 频率 | 关键信号 | 可自动修复 |\n|--------|------|----------|-----------|\n| env | 50% | env, secret, KEY_ERROR | 否 |\n| permission | 30% | permission denied, 403 | 否 |\n| config_file | 20% | config, settings | 否 |\n\n**不可自动修复原因**：涉及敏感信息和权限配置，需要人工处理。\n\n### 8. 基础设施失败 (infrastructure_failure)\n\n| 子类型 | 频率 | 关键信号 | 可自动修复 |\n|--------|------|----------|-----------|\n| runner | 40% | runner, self-hosted | 否 |\n| resource | 35% | OOM, killed, disk | 否 |\n| network | 25% | network, timeout | 否 |\n\n**不可自动修复原因**：涉及 CI 基础设施，需要运维处理。\n\n---\n\n## 置信度评估体系\n\n### 评分因素\n\n| 因素 | 权重 | 描述 |\n|------|------|------|\n| 信号明确性 | 40% | 错误信号是否清晰明确 |\n| 文件定位 | 30% | 是否能定位到具体文件和行号 |\n| 模式匹配 | 20% | 是否匹配已知错误模式 |\n| 上下文完整 | 10% | 是否有完整的堆栈追踪 |\n\n### 置信度阈值\n\n| 分数 | 级别 | 行为 |\n|------|------|------|\n| >= 80 | 高 | 自动修复 |\n| 60-79 | 中 | 询问用户后修复 |\n| 40-59 | 低 | 展示分析，建议手动 |\n| < 40 | 极低 | 跳过 |\n\n### 置信度调整规则\n\n**提升条件**：\n\n- 找到高相似度历史案例：+10\n- 完整的堆栈追踪：+5\n- 明确的代码变更点：+5\n- 匹配已知错误模式：+5\n\n**降低条件**：\n\n- 涉及多个不相关文件：-10\n- 错误消息模糊：-10\n- 无法定位具体原因：-15\n- 可能涉及配置/权限：-20\n\n---\n\n## 技术栈识别\n\n### 基于文件路径\n\n```yaml\nbackend:\n  patterns:\n    - \"**/*.py\"\n    - \"tests/backend/**\"\n    - \"tests/unit/**\"\n    - \"src/api/**\"\n    - \"app/**\"\n  signals:\n    - \"pytest\"\n    - \"FastAPI\"\n    - \"Django\"\n    - \"Python\"\n\nfrontend:\n  patterns:\n    - \"**/*.tsx\"\n    - \"**/*.jsx\"\n    - \"**/*.ts\"\n    - \"tests/frontend/**\"\n    - \"src/components/**\"\n  signals:\n    - \"jest\"\n    - \"vitest\"\n    - \"React\"\n    - \"Vue\"\n\ne2e:\n  patterns:\n    - \"e2e/**\"\n    - \"tests/e2e/**\"\n    - \"playwright/**\"\n    - \"cypress/**\"\n  signals:\n    - \"playwright\"\n    - \"cypress\"\n    - \"puppeteer\"\n```\n\n### 混合技术栈处理\n\n当检测到多个技术栈时：\n\n1. 按错误数量确定主要技术栈\n2. 次要技术栈作为 `secondary_stack`\n3. 优先处理主要技术栈的错误\n\n---\n\n## 常见错误模式库\n\n### pytest 错误模式\n\n```text\n# 断言失败\nFAILED tests/test_xxx.py::test_name - AssertionError: assert X == Y\n\n# 异常未捕获\nFAILED tests/test_xxx.py::test_name - ExceptionType: message\n\n# fixture 错误\nERROR tests/test_xxx.py::test_name - fixture 'xxx' not found\n\n# 导入错误\nERROR tests/test_xxx.py - ModuleNotFoundError: No module named 'xxx'\n```\n\n### jest/vitest 错误模式\n\n```text\n# 断言失败\nFAIL src/xxx.test.ts\n  ✕ test name (123ms)\n    expect(received).toBe(expected)\n\n# 超时\nFAIL src/xxx.test.ts\n  ✕ test name (5001ms)\n    Timeout - Async callback was not invoked within 5000ms\n\n# 快照失败\nFAIL src/xxx.test.ts\n  ✕ test name\n    expect(received).toMatchSnapshot()\n```\n\n### playwright 错误模式\n\n```text\n# 超时\nError: locator.click: Timeout 30000ms exceeded.\nwaiting for locator('selector')\n\n# 选择器问题\nError: locator.click: Error: strict mode violation:\nlocator('selector') resolved to 2 elements\n\n# 断言失败\nError: expect(locator).toBeVisible()\nLocator expected to be visible\n```\n\n### TypeScript 错误模式\n\n```text\n# 类型不匹配\nerror TS2345: Argument of type 'X' is not assignable to parameter of type 'Y'\n\n# 属性不存在\nerror TS2339: Property 'xxx' does not exist on type 'Y'\n\n# 隐式 any\nerror TS7006: Parameter 'xxx' implicitly has an 'any' type\n```\n\n---\n\n## 修复工作流映射\n\n| 失败类型 | 修复方式 | 关联工作流 |\n|----------|----------|-----------|\n| test_failure (backend) | bugfix_workflow | /fix-backend |\n| test_failure (frontend) | bugfix_workflow | /fix-frontend |\n| e2e_failure | bugfix_workflow | /fix-e2e |\n| lint_failure | quick_fix | 直接运行 lint --fix |\n| type_check_failure | bugfix_workflow | 对应栈工作流 |\n| build_failure | bugfix_workflow | 对应栈工作流 |\n| dependency_failure | manual | 无 |\n| config_failure | manual | 无 |\n| infrastructure_failure | manual | 无 |\n\n---\n\n## 历史案例匹配\n\n### 相似度计算\n\n```python\ndef calculate_similarity(current, historical):\n    score = 0\n\n    # 错误类型匹配 (30%)\n    if current.failure_type == historical.failure_type:\n        score += 30\n\n    # 文件路径匹配 (25%)\n    file_overlap = len(set(current.files) & set(historical.files))\n    score += min(25, file_overlap * 5)\n\n    # 错误消息相似 (25%)\n    message_similarity = text_similarity(current.error, historical.error)\n    score += message_similarity * 25\n\n    # 修复模式相似 (20%)\n    if current.suggested_fix_type == historical.fix_type:\n        score += 20\n\n    return score\n```\n\n### 高价值案例特征\n\n值得记录为历史案例的修复：\n\n1. 置信度 >= 80\n2. 修复成功\n3. 有明确的根因分析\n4. 包含可复用的修复方法\n5. 涉及常见错误模式"
              },
              {
                "name": "coordinator-patterns",
                "description": "master-coordinator 和 review-coordinator 共享的通用模式，包括 Phase 验证、错误处理、TodoWrite 管理和状态说明。所有 coordinator agents 应引用此 skill 以保持一致性。",
                "path": "swiss-army-knife/skills/coordinator-patterns/SKILL.md",
                "frontmatter": {
                  "name": "coordinator-patterns",
                  "description": "master-coordinator 和 review-coordinator 共享的通用模式，包括 Phase 验证、错误处理、TodoWrite 管理和状态说明。所有 coordinator agents 应引用此 skill 以保持一致性。"
                },
                "content": "# Coordinator 通用模式\n\n本 skill 定义了所有 coordinator agents 共享的通用模式，包括：\n\n1. Phase 验证逻辑\n2. 错误处理模式\n3. TodoWrite 管理\n4. 状态说明\n\n## Phase 验证逻辑\n\n所有 master-coordinator 必须在初始化时验证 `phase` 参数：\n\n```python\ndef validate_phase(phase_arg, valid_phases):\n    \"\"\"\n    验证 phase 参数\n\n    Args:\n        phase_arg: 用户传入的 phase 参数（如 \"0,1,2\" 或 \"all\"）\n        valid_phases: 有效 phase 列表（如 [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"all\"]）\n\n    Returns:\n        (is_valid, result): 如果有效，result 是 phase 列表；如果无效，result 是错误响应\n    \"\"\"\n    if phase_arg == \"all\":\n        # 返回所有数字 phases（排除 \"all\"）\n        return True, sorted([p for p in valid_phases if p != \"all\"], key=int)\n\n    phases = phase_arg.split(\",\")\n    invalid_phases = [p for p in phases if p not in valid_phases]\n\n    if invalid_phases:\n        return False, {\n            \"status\": \"failed\",\n            \"error\": {\n                \"code\": \"INVALID_PHASE\",\n                \"message\": f\"无效的 phase 参数: {invalid_phases}\",\n                \"valid_values\": valid_phases,\n                \"received\": phase_arg,\n                \"suggestion\": f\"有效值: 0-{len(valid_phases)-2} 的数字或 'all'，多个用逗号分隔\"\n            }\n        }\n\n    return True, sorted(set(phases), key=int)\n```\n\n### 各工作流的有效 Phases\n\n| 工作流 | 有效 Phases | 说明 |\n|--------|------------|------|\n| Bugfix | 0-5 | 6 阶段 |\n| PR Review | 0-7 | 8 阶段 |\n| CI Job | 0-6 | 7 阶段 |\n| Execute Plan | 0-5 | 6 阶段 |\n\n## 错误处理模式\n\n所有 coordinator 必须处理以下错误类型：\n\n### JSON 解析错误\n\n当 agent 返回的内容无法解析为有效 JSON 时：\n\n```python\ntry:\n    result = json.loads(agent_output)\nexcept json.JSONDecodeError as e:\n    return {\n        \"status\": \"failed\",\n        \"error\": {\n            \"code\": \"JSON_PARSE_ERROR\",\n            \"message\": \"Agent 输出无法解析为 JSON\",\n            \"phase\": current_phase,\n            \"agent\": agent_name,\n            \"parse_error\": str(e),\n            \"raw_output_preview\": agent_output[:500],  # 前 500 字符供调试\n            \"suggestion\": \"检查 agent 是否正确返回 JSON 格式，或重试命令\"\n        }\n    }\n```\n\n### Agent 执行超时\n\n```python\nif agent_result.error.code == \"TIMEOUT\":\n    return {\n        \"status\": \"failed\",\n        \"error\": {\n            \"code\": \"AGENT_TIMEOUT\",\n            \"message\": f\"Agent {agent_name} 执行超时\",\n            \"phase\": current_phase,\n            \"timeout_ms\": agent_result.error.timeout_ms,\n            \"suggestion\": \"任务可能过于复杂，建议拆分或简化输入\"\n        }\n    }\n```\n\n### 响应截断\n\n当 agent 输出超过长度限制被截断时：\n\n```python\nif agent_result.truncated:\n    # 记录警告但尝试继续\n    warnings.append({\n        \"code\": \"OUTPUT_TRUNCATED\",\n        \"message\": f\"Agent {agent_name} 输出被截断\",\n        \"original_length\": agent_result.original_length,\n        \"truncated_length\": agent_result.truncated_length,\n        \"impact\": \"可能丢失部分诊断信息\"\n    })\n    # 如果关键字段缺失，则停止\n    if not validate_required_fields(agent_result):\n        return {\n            \"status\": \"failed\",\n            \"error\": {\n                \"code\": \"TRUNCATION_DATA_LOSS\",\n                \"message\": \"输出截断导致关键数据丢失\",\n                \"missing_fields\": get_missing_fields(agent_result),\n                \"suggestion\": \"请简化输入或分批处理\"\n            }\n        }\n```\n\n### 用户取消\n\n```python\nif user_choice in [\"取消\", \"停止\"]:\n    return {\n        \"status\": \"user_cancelled\",\n        \"phase\": current_phase,\n        \"reason\": \"用户选择停止执行\",\n        \"completed_work\": {...}  # 已完成的工作\n    }\n```\n\n### Agent 调用失败（通用）\n\n```python\nif agent_result.status == \"failed\":\n    return {\n        \"status\": \"failed\",\n        \"error\": {\n            \"phase\": current_phase,\n            \"agent\": agent_name,\n            \"code\": agent_result.error.code,\n            \"message\": agent_result.error.message\n        }\n    }\n```\n\n### 错误恢复机制（可选）\n\n对于支持错误恢复的 coordinator：\n\n```python\n# 可恢复错误类型\nRECOVERABLE_ERRORS = {\n    \"TIMEOUT\": True,           # 超时可重试\n    \"RATE_LIMIT\": True,        # 限流可重试\n    \"OUTPUT_TRUNCATED\": True,  # 截断可简化输入重试\n}\n\nMAX_RETRIES = 2  # 最多重试 2 次\n\ndef is_recoverable(error):\n    \"\"\"判断错误是否可恢复\"\"\"\n    return RECOVERABLE_ERRORS.get(error.code, False)\n```\n\n## TodoWrite 管理\n\n所有 coordinator 必须使用 TodoWrite 跟踪执行进度：\n\n### 初始化 Todo 列表\n\n```python\ndef create_phase_todos(phases, phase_descriptions):\n    \"\"\"\n    创建 Phase 任务列表\n\n    Args:\n        phases: Phase 列表（如 [\"0\", \"1\", \"2\"]）\n        phase_descriptions: Phase 描述映射（如 {\"0\": (\"问题收集\", \"收集中\"), ...}）\n\n    Returns:\n        todos 列表\n    \"\"\"\n    todos = []\n    for i, phase in enumerate(phases):\n        desc, active_form = phase_descriptions.get(phase, (f\"Phase {phase}\", f\"执行 Phase {phase}\"))\n        todos.append({\n            \"content\": f\"Phase {phase}: {desc}\",\n            \"status\": \"in_progress\" if i == 0 else \"pending\",\n            \"activeForm\": active_form\n        })\n    return todos\n```\n\n### 更新 Todo 状态\n\n```python\ndef on_phase_complete(todos, phase_index):\n    \"\"\"完成 Phase 后更新状态\"\"\"\n    todos[phase_index][\"status\"] = \"completed\"\n    if phase_index + 1 < len(todos):\n        todos[phase_index + 1][\"status\"] = \"in_progress\"\n    return todos\n```\n\n### 各工作流的 Phase 描述\n\n**Bugfix 工作流：**\n```python\nBUGFIX_PHASES = {\n    \"0\": (\"问题收集与分类\", \"收集中\"),\n    \"1\": (\"诊断分析\", \"分析中\"),\n    \"2\": (\"方案设计\", \"设计中\"),\n    \"3\": (\"方案文档化\", \"文档化中\"),\n    \"4\": (\"实施执行\", \"执行中\"),\n    \"5\": (\"验证与审查\", \"审查中\")\n}\n```\n\n**PR Review 工作流：**\n```python\nPR_REVIEW_PHASES = {\n    \"0\": (\"初始化\", \"初始化中\"),\n    \"1\": (\"评论获取\", \"获取评论中\"),\n    \"2\": (\"评论过滤\", \"过滤评论中\"),\n    \"3\": (\"评论分类\", \"分类评论中\"),\n    \"4\": (\"修复协调\", \"协调修复中\"),\n    \"5\": (\"回复生成\", \"生成回复中\"),\n    \"6\": (\"回复提交\", \"提交回复中\"),\n    \"7\": (\"审查与汇总\", \"审查汇总中\")\n}\n```\n\n**CI Job 工作流：**\n```python\nCI_JOB_PHASES = {\n    \"0\": (\"初始化\", \"初始化中\"),\n    \"1\": (\"日志获取\", \"获取日志中\"),\n    \"2\": (\"失败分类\", \"分类失败中\"),\n    \"3\": (\"根因分析\", \"分析根因中\"),\n    \"4\": (\"修复执行\", \"执行修复中\"),\n    \"5\": (\"验证与审查\", \"验证审查中\"),\n    \"6\": (\"汇总报告\", \"生成报告中\")\n}\n```\n\n**Execute Plan 工作流：**\n```python\nEXECUTE_PLAN_PHASES = {\n    \"0\": (\"初始化与计划解析\", \"初始化中\"),\n    \"1\": (\"计划验证\", \"验证中\"),\n    \"2\": (\"方案细化\", \"细化方案中\"),\n    \"3\": (\"批次执行\", \"执行中\"),\n    \"4\": (\"Review 审查\", \"审查中\"),\n    \"5\": (\"汇总报告\", \"生成报告中\")\n}\n```\n\n## 状态说明\n\n所有 coordinator 输出的 `status` 字段使用统一的语义：\n\n| status | 含义 | 适用场景 |\n|--------|------|----------|\n| `success` | 所有 Phase 成功完成 | 正常完成 |\n| `failed` | 某个 Phase 失败且无法继续 | 不可恢复错误 |\n| `partial` | 部分任务失败，但流程完成 | 有剩余问题 |\n| `user_cancelled` | 用户选择停止 | 用户主动取消 |\n| `dry_run_complete` | Dry run 模式完成分析 | --dry-run 模式 |\n\n## 必填输出字段\n\n每个 coordinator 的 JSON 输出**必须**包含：\n\n```json\n{\n  \"status\": \"success|failed|partial|user_cancelled|dry_run_complete\",\n  \"agent\": \"xxx-master-coordinator\",\n  \"phases_completed\": [\"phase_0\", \"phase_1\", ...],\n  \"errors\": [],\n  \"warnings\": []\n}\n```\n\n## 关键原则\n\n1. **闭环执行**：所有逻辑在 agent 内部完成，不依赖命令层\n2. **状态透明**：每个 Phase 的输出都保存并传递到下一 Phase\n3. **用户控制**：关键决策点使用 AskUserQuestion 询问用户\n4. **进度可见**：使用 TodoWrite 让用户了解执行进度\n5. **错误隔离**：单个任务失败不应影响其他独立任务"
              },
              {
                "name": "e2e-bugfix",
                "description": "This skill should be used when the user asks to \"debug E2E tests\", \"fix Playwright failures\", \"fix Cypress tests\", \"analyze timeout errors\", or mentions keywords like \"Playwright\", \"Cypress\", \"Timeout exceeded\", \"locator\", \"selector\", \"flaky test\". It provides the complete bugfix workflow knowledge including error classification, confidence scoring, and E2E-specific debugging techniques.\n",
                "path": "swiss-army-knife/skills/e2e-bugfix/SKILL.md",
                "frontmatter": {
                  "name": "e2e-bugfix",
                  "description": "This skill should be used when the user asks to \"debug E2E tests\", \"fix Playwright failures\", \"fix Cypress tests\", \"analyze timeout errors\", or mentions keywords like \"Playwright\", \"Cypress\", \"Timeout exceeded\", \"locator\", \"selector\", \"flaky test\". It provides the complete bugfix workflow knowledge including error classification, confidence scoring, and E2E-specific debugging techniques.\n",
                  "version": "2.1.0"
                },
                "content": "# E2E Bugfix Workflow Skill\n\n本 skill 提供端到端测试 bugfix 的完整工作流知识，包括错误分类体系、置信度评分系统和 E2E 特有的调试技巧。\n\n## 错误分类体系\n\nE2E 测试失败主要分为以下类型（按频率排序）：\n\n### 1. 超时错误（35%）\n\n**症状**：元素等待超时、操作超时\n\n**识别特征**：\n\n- `Timeout 30000ms exceeded`\n- `waiting for locator`\n- `waiting for element`\n- `TimeoutError`\n\n**解决策略**：使用显式等待和合理超时\n\n```typescript\n// Before - 硬编码等待\nawait page.waitForTimeout(5000);\nawait page.click('.submit-button');\n\n// After - 等待特定条件\nawait page.waitForSelector('.submit-button', { state: 'visible' });\nawait page.click('.submit-button');\n\n// 或使用 Playwright 的自动等待\nawait page.getByRole('button', { name: 'Submit' }).click();\n```\n\n**常见原因**：\n\n- 页面加载慢\n- 动态内容未渲染\n- 网络请求延迟\n- 元素被遮挡或不可见\n\n### 2. 选择器错误（25%）\n\n**症状**：找不到元素、选择器匹配多个元素\n\n**识别特征**：\n\n- `strict mode violation`\n- `resolved to X elements`\n- `element not found`\n- `locator.click: Error`\n\n**解决策略**：使用更精确的选择器\n\n```typescript\n// Before - 模糊选择器\nawait page.click('button');  // 可能匹配多个\n\n// After - 精确选择器\n// 方法 1：使用 data-testid\nawait page.click('[data-testid=\"submit-button\"]');\n\n// 方法 2：使用角色和文本\nawait page.getByRole('button', { name: 'Submit' }).click();\n\n// 方法 3：使用组合选择器\nawait page.locator('.form-container').getByRole('button').click();\n```\n\n**Playwright 推荐选择器优先级**：\n\n1. `getByRole()` - 最语义化\n2. `getByTestId()` - 最稳定\n3. `getByText()` - 用户可见\n4. CSS/XPath - 最后手段\n\n### 3. 断言错误（15%）\n\n**症状**：期望值与实际值不匹配\n\n**识别特征**：\n\n- `expect(...).toHave*`\n- `Expected:` vs `Received:`\n- `AssertionError`\n\n**解决策略**：使用正确的断言和等待\n\n```typescript\n// Before - 立即断言\nexpect(await page.textContent('.message')).toBe('Success');\n\n// After - 使用自动重试的断言\nawait expect(page.locator('.message')).toHaveText('Success');\n\n// 异步内容断言\nawait expect(page.locator('.user-list')).toContainText('John');\n\n// 可见性断言\nawait expect(page.locator('.modal')).toBeVisible();\n```\n\n### 4. 网络错误（12%）\n\n**症状**：API 请求失败、网络拦截问题\n\n**识别特征**：\n\n- `Route handler` 错误\n- `net::ERR_*`\n- `request failed`\n- Mock 数据不生效\n\n**解决策略**：正确配置网络拦截\n\n```typescript\n// Mock API 响应\nawait page.route('**/api/users', async (route) => {\n  await route.fulfill({\n    status: 200,\n    contentType: 'application/json',\n    body: JSON.stringify({ users: [{ id: 1, name: 'Test' }] }),\n  });\n});\n\n// 等待网络请求完成\nconst responsePromise = page.waitForResponse('**/api/users');\nawait page.click('.load-users');\nconst response = await responsePromise;\nexpect(response.status()).toBe(200);\n```\n\n### 5. 导航错误（8%）\n\n**症状**：页面导航失败、URL 不匹配\n\n**识别特征**：\n\n- `page.goto: Error`\n- `ERR_NAME_NOT_RESOLVED`\n- `navigation timeout`\n- URL 重定向问题\n\n**解决策略**：正确处理导航\n\n```typescript\n// 等待导航完成\nawait page.goto('http://localhost:3000/login');\nawait page.waitForURL('**/dashboard');\n\n// 处理重定向\nawait Promise.all([\n  page.waitForNavigation(),\n  page.click('.login-button'),\n]);\n\n// 验证 URL\nawait expect(page).toHaveURL(/.*dashboard/);\n```\n\n### 6. 环境错误（3%）\n\n**症状**：浏览器启动失败、测试环境问题\n\n**识别特征**：\n\n- `browser.launch` 失败\n- `Target closed`\n- `context` 错误\n- 端口冲突\n\n**解决策略**：检查环境配置\n\n```typescript\n// playwright.config.ts\nexport default defineConfig({\n  webServer: {\n    command: 'npm run start',\n    url: 'http://localhost:3000',\n    reuseExistingServer: !process.env.CI,\n    timeout: 120 * 1000,\n  },\n  use: {\n    baseURL: 'http://localhost:3000',\n    trace: 'on-first-retry',\n    screenshot: 'only-on-failure',\n  },\n});\n```\n\n## 置信度评分系统\n\n### 评分标准（0-100）\n\n| 分数 | 级别 | 行为 |\n| ------ | ------ | ------ |\n| 80+ | 高 | 自动执行 |\n| 60-79 | 中 | 标记验证后继续 |\n| 40-59 | 低 | 暂停询问用户 |\n| <40 | 不确定 | 停止收集信息 |\n\n### 置信度计算\n\n```text\n置信度 = 证据质量(40%) + 模式匹配(30%) + 上下文完整性(20%) + 可复现性(10%)\n```\n\n**证据质量**：\n\n- 高：有截图、trace、完整堆栈\n- 中：有错误信息但缺上下文\n- 低：仅有失败描述\n\n**模式匹配**：\n\n- 高：完全匹配已知错误模式\n- 中：部分匹配\n- 低：未知错误类型\n\n**上下文完整性**：\n\n- 高：测试代码 + 页面代码 + trace + 截图\n- 中：只有测试代码\n- 低：只有错误信息\n\n**可复现性**：\n\n- 高：每次运行都复现\n- 中：偶发（flaky test）\n- 低：仅在特定环境失败\n\n## E2E 调试技巧\n\n### 使用 Trace Viewer\n\n```bash\n# 运行测试并收集 trace\nnpx playwright test --trace on\n\n# 查看 trace\nnpx playwright show-trace trace.zip\n```\n\n### 使用 UI 模式调试\n\n```bash\n# 启动 UI 模式\nnpx playwright test --ui\n\n# 或使用调试模式\nnpx playwright test --debug\n```\n\n### 截图和录像\n\n```typescript\n// 测试失败时自动截图\ntest.afterEach(async ({ page }, testInfo) => {\n  if (testInfo.status !== 'passed') {\n    await page.screenshot({ path: `screenshots/${testInfo.title}.png` });\n  }\n});\n\n// 录制视频\n// playwright.config.ts\nuse: {\n  video: 'on-first-retry',\n}\n```\n\n### 处理 Flaky Tests\n\n```typescript\n// 重试不稳定的测试\ntest.describe.configure({ retries: 2 });\n\n// 或在配置中设置\nexport default defineConfig({\n  retries: process.env.CI ? 2 : 0,\n});\n```\n\n## TDD 流程\n\n### RED Phase（写失败测试）\n\n```typescript\nimport { test, expect } from '@playwright/test';\n\ntest('should display error message on invalid login', async ({ page }) => {\n  // 1. 导航到页面\n  await page.goto('/login');\n\n  // 2. 执行操作\n  await page.fill('[data-testid=\"email\"]', 'invalid@email');\n  await page.fill('[data-testid=\"password\"]', 'wrong');\n  await page.click('[data-testid=\"submit\"]');\n\n  // 3. 断言期望结果\n  await expect(page.locator('.error-message')).toHaveText('Invalid credentials');\n});\n```\n\n### GREEN Phase（最小实现）\n\n```typescript\n// 只实现让测试通过的最小功能\n// 不要优化，不要添加额外功能\n```\n\n### REFACTOR Phase（重构）\n\n```typescript\n// 改善测试结构\n// 提取 Page Object\n// 复用测试辅助函数\n```\n\n## Page Object 模式\n\n```typescript\n// pages/LoginPage.ts\nexport class LoginPage {\n  constructor(private page: Page) {}\n\n  async goto() {\n    await this.page.goto('/login');\n  }\n\n  async login(email: string, password: string) {\n    await this.page.fill('[data-testid=\"email\"]', email);\n    await this.page.fill('[data-testid=\"password\"]', password);\n    await this.page.click('[data-testid=\"submit\"]');\n  }\n\n  async getErrorMessage() {\n    return this.page.locator('.error-message');\n  }\n}\n\n// 使用 Page Object\ntest('login with invalid credentials', async ({ page }) => {\n  const loginPage = new LoginPage(page);\n  await loginPage.goto();\n  await loginPage.login('invalid@email', 'wrong');\n  await expect(loginPage.getErrorMessage()).toHaveText('Invalid credentials');\n});\n```\n\n## 质量门禁\n\n| 检查项 | 标准 |\n| ---------- | ------ |\n| 测试通过率 | 100% |\n| 代码覆盖率 | >= 90%（如适用） |\n| Lint | 无错误 |\n| Flaky Rate | < 5% |\n\n## 常用命令\n\n```bash\n# 运行所有 E2E 测试\nmake test TARGET=e2e\n\n# 或使用 Playwright 直接运行\nnpx playwright test\n\n# 运行特定测试文件\nnpx playwright test tests/login.spec.ts\n\n# 运行带标签的测试\nnpx playwright test --grep @smoke\n\n# 运行 UI 模式\nnpx playwright test --ui\n\n# 生成测试代码\nnpx playwright codegen localhost:3000\n\n# 查看测试报告\nnpx playwright show-report\n```\n\n## Playwright 配置示例\n\n```typescript\n// playwright.config.ts\nimport { defineConfig, devices } from '@playwright/test';\n\nexport default defineConfig({\n  testDir: './tests',\n  fullyParallel: true,\n  forbidOnly: !!process.env.CI,\n  retries: process.env.CI ? 2 : 0,\n  workers: process.env.CI ? 1 : undefined,\n  reporter: 'html',\n  use: {\n    baseURL: 'http://localhost:3000',\n    trace: 'on-first-retry',\n    screenshot: 'only-on-failure',\n  },\n  projects: [\n    { name: 'chromium', use: { ...devices['Desktop Chrome'] } },\n    { name: 'firefox', use: { ...devices['Desktop Firefox'] } },\n    { name: 'webkit', use: { ...devices['Desktop Safari'] } },\n  ],\n  webServer: {\n    command: 'npm run start',\n    url: 'http://localhost:3000',\n    reuseExistingServer: !process.env.CI,\n  },\n});\n```\n\n## 相关文档\n\n文档路径由配置指定（`best_practices_dir`），使用以下关键词搜索：\n\n- **选择器策略**：关键词 \"selector\", \"locator\", \"data-testid\"\n- **等待策略**：关键词 \"wait\", \"timeout\", \"retry\"\n- **网络拦截**：关键词 \"intercept\", \"mock\", \"route\"\n- **问题诊断**：关键词 \"troubleshooting\", \"debugging\", \"flaky\""
              },
              {
                "name": "elements-of-style",
                "description": "Strunk 写作规则，用于提升文档质量。适用于所有面向人类读者的文本：文档、报告、注释、提交信息等。",
                "path": "swiss-army-knife/skills/elements-of-style/SKILL.md",
                "frontmatter": {
                  "name": "elements-of-style",
                  "description": "Strunk 写作规则，用于提升文档质量。适用于所有面向人类读者的文本：文档、报告、注释、提交信息等。"
                },
                "content": "# Writing Clearly and Concisely\n\n## 概述\n\nWilliam Strunk Jr. 的 *The Elements of Style* (1918) 教你如何写出清晰、简洁的文字。\n\n**警告**：`elements-of-style.md` 约消耗 12,000 tokens。仅在编写或编辑文档时读取完整内容。\n\n## 使用场景\n\n当为人类编写文本时使用此 skill：\n\n- 文档、README、技术说明\n- Commit messages、Pull Request 描述\n- 错误信息、UI 文案、帮助文本、注释\n- 报告、摘要、或任何解释性文本\n\n**如果你在为人类读者写句子，就使用此 skill。**\n\n## 使用策略\n\n### 轻量模式（用于 haiku 模型和简单文档）\n\n直接参考下方的规则摘要，应用核心原则：\n\n- **Rule 10**: 使用主动语态\n- **Rule 11**: 正面陈述\n- **Rule 12**: 使用具体、明确的语言\n- **Rule 13**: 删除冗词\n- **Rule 16**: 相关词语紧邻\n- **Rule 18**: 强调词放句末\n\n### 深度模式（用于 sonnet/opus 模型和重要文档）\n\n当生成最终报告、知识沉淀文档时：\n\n1. 先生成草稿\n2. 使用 Read 工具读取 `elements-of-style.md`\n3. 逐条检查 Section V（常见误用词）\n4. 优化并定稿\n\n### 受限上下文策略\n\n当上下文紧张时：\n\n1. 根据规则摘要独立完成草稿\n2. 派发子 agent，携带草稿和 `elements-of-style.md`\n3. 让子 agent 进行编辑润色并返回修订版\n\n## 规则摘要\n\n### Elementary Rules of Usage（语法/标点）\n\n1. 所有格单数名词加 's\n2. 三个或更多项的系列中，每项后加逗号（除最后一项）\n3. 插入语用逗号包围\n4. 引入并列从句的连词前加逗号\n5. 不要用逗号连接独立从句\n6. 不要把句子断成两截\n7. 句首的分词短语必须指向语法主语\n\n### Elementary Principles of Composition（写作原则）\n\n8. 一段一主题\n9. 段落以主题句开头\n10. **使用主动语态**\n11. **用肯定形式陈述**\n12. **使用明确、具体、形象的语言**\n13. **删除冗词**\n14. 避免连续松散句\n15. 用相似形式表达并列概念\n16. **相关词语保持紧邻**\n17. 摘要保持同一时态\n18. **强调词放在句末**\n\n### Section V: Words and Expressions Commonly Misused\n\n按字母顺序参考常见用词问题（详见 `elements-of-style.md`）\n\n## 核心原则速查\n\n| 原则 | 说明 | 示例 |\n|------|------|------|\n| 主动语态 | 主语执行动作 | ✓ \"测试发现了 3 个错误\" ✗ \"3 个错误被测试发现\" |\n| 正面陈述 | 避免双重否定 | ✓ \"忘记了\" ✗ \"没有记住\" |\n| 删除冗词 | 精简表达 | ✓ \"现在\" ✗ \"在目前这个时间点\" |\n| 具体语言 | 避免抽象模糊 | ✓ \"响应时间 200ms\" ✗ \"性能不错\" |\n| 强调词放句末 | 重点信息收尾 | ✓ \"最重要的是安全性\" |\n\n## 底线\n\n为人类写作？读取 `elements-of-style.md` 并应用规则。Token 不足？派发子 agent 使用完整指南进行编辑。"
              },
              {
                "name": "execute-plan",
                "description": "计划执行工作流知识库，包含计划格式规范、任务解析、依赖分析和执行策略",
                "path": "swiss-army-knife/skills/execute-plan/SKILL.md",
                "frontmatter": {
                  "name": "execute-plan",
                  "description": "计划执行工作流知识库，包含计划格式规范、任务解析、依赖分析和执行策略"
                },
                "content": "# Execute Plan Skill\n\n本 Skill 提供计划执行工作流的核心知识，包括计划格式规范、任务解析规则、依赖分析算法和批次执行策略。\n\n---\n\n## 1. 计划格式规范\n\n### 1.1 支持的格式\n\n| 格式 | 文件扩展名 | 检测方式 |\n|------|-----------|----------|\n| Markdown | `.md` | 文件扩展名 + 任务模式检测 |\n| YAML | `.yaml`, `.yml` | 文件扩展名 + `tasks:` 键检测 |\n\n### 1.2 Markdown 计划格式\n\n**任务标记模式**（按优先级检测）：\n\n```markdown\n## Task 1: 实现用户认证模块\n描述：实现基于 JWT 的用户认证...\n\n## Task 2: 添加数据库迁移\n描述：...\n```\n\n```markdown\n### 1. 创建 API 端点\n描述：...\n\n### 2. 添加单元测试\n描述：...\n```\n\n```markdown\n- [ ] 重构认证中间件\n- [ ] 添加错误处理\n- [ ] 更新文档\n```\n\n```markdown\n1. **创建用户服务**\n   - 文件: `src/services/user.ts`\n   - 描述: ...\n\n2. **添加数据验证**\n   - 文件: `src/validators/user.ts`\n   - 描述: ...\n```\n\n### 1.3 YAML 计划格式\n\n```yaml\ntitle: \"用户认证系统实现\"\ndescription: \"实现完整的用户认证流程\"\n\ntasks:\n  - id: T-001\n    title: \"创建用户模型\"\n    description: \"定义 User 数据模型和相关类型\"\n    files:\n      - src/models/user.ts\n      - src/types/user.ts\n    dependencies: []\n    complexity: low\n\n  - id: T-002\n    title: \"实现认证服务\"\n    description: \"实现登录、注册、Token 刷新逻辑\"\n    files:\n      - src/services/auth.ts\n    dependencies:\n      - T-001\n    complexity: medium\n```\n\n### 1.4 任务字段规范\n\n| 字段 | 必填 | 类型 | 说明 |\n|------|------|------|------|\n| `id` | 否 | string | 任务 ID（自动生成如 T-001） |\n| `title` | 是 | string | 任务标题 |\n| `description` | 否 | string | 任务描述 |\n| `files` | 否 | string[] | 涉及的文件列表 |\n| `dependencies` | 否 | string[] | 依赖的任务 ID |\n| `complexity` | 否 | enum | low/medium/high |\n| `test_files` | 否 | string[] | 相关测试文件 |\n\n---\n\n## 2. 任务解析规则\n\n### 2.1 Markdown 任务提取\n\n**解析优先级**：\n\n1. `## Task N:` 模式\n2. `### N.` 模式\n3. `- [ ]` 模式\n4. `N. **xxx**` 模式\n\n**示例解析**：\n\n```markdown\n## Task 1: 创建用户服务\n\n实现用户 CRUD 操作的服务层。\n\n**文件**：\n- `src/services/user.ts`\n- `src/types/user.ts`\n\n**依赖**：无\n\n**测试**：\n- `tests/services/user.test.ts`\n```\n\n解析结果：\n\n```json\n{\n  \"id\": \"T-001\",\n  \"title\": \"创建用户服务\",\n  \"description\": \"实现用户 CRUD 操作的服务层。\",\n  \"files\": [\"src/services/user.ts\", \"src/types/user.ts\"],\n  \"dependencies\": [],\n  \"test_files\": [\"tests/services/user.test.ts\"],\n  \"complexity\": \"medium\"\n}\n```\n\n### 2.2 复杂度推断\n\n如果计划未显式指定复杂度，根据以下规则推断：\n\n| 条件 | 复杂度 |\n|------|--------|\n| 涉及文件 ≤ 2 且无依赖 | low |\n| 涉及文件 3-5 或有 1-2 个依赖 | medium |\n| 涉及文件 > 5 或有 > 2 个依赖 | high |\n\n### 2.3 ID 自动生成\n\n如果任务无 ID，按顺序生成：\n\n- `T-001`, `T-002`, `T-003`, ...\n\n---\n\n## 3. 依赖分析算法\n\n### 3.1 显式依赖\n\n计划中通过 `dependencies` 字段声明的依赖关系。\n\n### 3.2 隐式依赖检测\n\n自动检测以下隐式依赖：\n\n1. **同文件修改**：多个任务修改同一文件时，按任务顺序形成依赖链\n2. **类型/接口依赖**：任务 A 创建类型，任务 B 使用该类型\n3. **导入依赖**：任务 A 创建模块，任务 B 导入该模块\n\n### 3.3 拓扑排序\n\n使用 Kahn 算法进行拓扑排序：\n\n```python\ndef topological_sort(tasks, dependencies):\n    in_degree = {t.id: 0 for t in tasks}\n    for deps in dependencies.values():\n        for dep in deps:\n            in_degree[dep] += 1\n\n    queue = [t for t in tasks if in_degree[t.id] == 0]\n    result = []\n\n    while queue:\n        task = queue.pop(0)\n        result.append(task)\n        for t in tasks:\n            if task.id in dependencies.get(t.id, []):\n                in_degree[t.id] -= 1\n                if in_degree[t.id] == 0:\n                    queue.append(t)\n\n    if len(result) != len(tasks):\n        raise CyclicDependencyError(\"检测到循环依赖\")\n\n    return result\n```\n\n### 3.4 循环依赖检测\n\n如果检测到循环依赖：\n\n1. **停止**执行\n2. 报告循环涉及的任务\n3. 建议解决方案（拆分任务或重新排序）\n\n---\n\n## 4. 批次执行策略\n\n### 4.1 批次划分原则\n\n1. **依赖优先**：同一批次内的任务不应有依赖关系\n2. **复杂度平衡**：每批包含的 high 复杂度任务不超过 1 个\n3. **大小限制**：每批任务数不超过配置的 `batch_size`\n\n### 4.2 批次生成算法\n\n```python\ndef generate_batches(sorted_tasks, batch_size, max_parallel):\n    batches = []\n    current_batch = []\n    completed = set()\n\n    for task in sorted_tasks:\n        # 检查依赖是否已完成\n        deps_satisfied = all(d in completed for d in task.dependencies)\n\n        # 检查是否可以并行（无同文件修改）\n        can_parallel = not any(\n            set(task.files) & set(t.files)\n            for t in current_batch\n        )\n\n        if deps_satisfied and can_parallel and len(current_batch) < batch_size:\n            current_batch.append(task)\n        else:\n            if current_batch:\n                batches.append(current_batch)\n                completed.update(t.id for t in current_batch)\n            current_batch = [task]\n\n    if current_batch:\n        batches.append(current_batch)\n\n    return batches\n```\n\n### 4.3 批次内并行\n\n同一批次内的任务可以并行执行，条件：\n\n1. 任务之间无依赖\n2. 任务不修改同一文件\n3. 并行数不超过 `max_parallel`\n\n---\n\n## 5. 置信度评估标准\n\n### 5.1 任务置信度\n\n每个任务的置信度基于以下因素：\n\n| 因素 | 权重 | 评分标准 |\n|------|------|----------|\n| 文件存在性 | 30% | 目标文件/目录是否存在或可创建 |\n| 描述清晰度 | 25% | 任务描述是否明确可执行 |\n| 依赖可满足 | 25% | 依赖任务是否已定义且无循环 |\n| 复杂度合理 | 20% | 复杂度评估是否合理 |\n\n### 5.2 计划整体置信度\n\n整体置信度 = 所有任务置信度的加权平均\n\n权重：\n- high 复杂度任务：权重 3\n- medium 复杂度任务：权重 2\n- low 复杂度任务：权重 1\n\n### 5.3 置信度决策\n\n| 整体置信度 | 行为 |\n|-----------|------|\n| ≥ 80 | 自动继续执行 |\n| 60-79 | 展示验证结果，询问用户是否继续 |\n| 40-59 | 建议调整计划后重试 |\n| < 40 | 停止，报告计划无法执行 |\n\n---\n\n## 6. TDD 执行流程\n\n### 6.1 每个任务的 TDD 周期\n\n```text\n1. RED Phase\n   ├─ 识别或创建测试文件\n   ├─ 编写失败的测试用例\n   └─ 运行测试确认失败\n\n2. GREEN Phase\n   ├─ 实现最小代码使测试通过\n   └─ 运行测试确认通过\n\n3. REFACTOR Phase\n   ├─ 重构代码（保持测试通过）\n   ├─ 运行 lint 检查\n   └─ 运行类型检查\n```\n\n### 6.2 TDD 跳过条件\n\n以下情况可跳过 TDD：\n\n1. 纯配置文件修改\n2. 文档更新\n3. 样式/格式调整\n\n---\n\n## 7. 常见问题处理\n\n### 7.1 计划格式无法解析\n\n**症状**：无法识别任务列表\n\n**解决**：\n1. 检查是否使用支持的格式（Markdown/YAML）\n2. 确认任务标记符合规范\n3. 提供示例格式供参考\n\n### 7.2 循环依赖\n\n**症状**：拓扑排序失败\n\n**解决**：\n1. 识别循环涉及的任务\n2. 建议拆分任务或调整依赖\n3. 支持用户手动打破循环\n\n### 7.3 文件冲突\n\n**症状**：多个任务修改同一文件且无法确定顺序\n\n**解决**：\n1. 检测同文件修改的任务\n2. 建议添加显式依赖\n3. 串行执行冲突任务\n\n### 7.4 置信度过低\n\n**症状**：整体置信度 < 40\n\n**可能原因**：\n- 任务描述不清晰\n- 目标文件不存在\n- 依赖关系复杂或有循环\n\n**解决**：\n1. 报告具体的低置信度任务\n2. 列出影响置信度的因素\n3. 建议改进措施\n\n---\n\n## 8. 输出格式规范\n\n### 8.1 init_ctx 格式\n\n```json\n{\n  \"config\": {\n    \"test_command\": \"make test\",\n    \"lint_command\": \"make lint\",\n    \"typecheck_command\": \"make typecheck\",\n    \"batch_size\": 3,\n    \"docs\": {\n      \"bugfix_dir\": \"docs/bugfix\",\n      \"best_practices_dir\": \"docs/best-practices\"\n    }\n  },\n  \"plan_info\": {\n    \"source\": \"file\",\n    \"path\": \"docs/plans/feature-auth.md\",\n    \"title\": \"用户认证系统实现\",\n    \"format\": \"markdown\",\n    \"total_tasks\": 5\n  },\n  \"tasks\": [...],\n  \"project_info\": {\n    \"plugin_root\": \"/path/to/project\",\n    \"git\": {\n      \"branch\": \"feature/auth\",\n      \"modified_files\": []\n    },\n    \"detected_stack\": \"mixed\"\n  }\n}\n```\n\n### 8.2 验证结果格式\n\n```json\n{\n  \"validation_results\": [...],\n  \"execution_order\": [\"T-001\", \"T-002\", \"T-003\"],\n  \"batches\": [\n    {\n      \"batch_id\": 1,\n      \"tasks\": [\"T-001\", \"T-002\"],\n      \"can_parallel\": true\n    }\n  ],\n  \"overall_confidence\": 85,\n  \"recommendation\": \"proceed\"\n}\n```\n\n### 8.3 执行报告格式\n\n```json\n{\n  \"execution_results\": [\n    {\n      \"task_id\": \"T-001\",\n      \"status\": \"completed\",\n      \"tdd_cycles\": 1,\n      \"changes\": [...],\n      \"duration_seconds\": 120\n    }\n  ],\n  \"summary\": {\n    \"total\": 5,\n    \"completed\": 4,\n    \"skipped\": 1,\n    \"failed\": 0\n  },\n  \"review_results\": {...},\n  \"knowledge_extracted\": [...]\n}\n```"
              },
              {
                "name": "frontend-bugfix",
                "description": "Use this skill when debugging frontend test failures (React/TypeScript, Vitest, etc.), fixing bugs in React/TypeScript code, or following TDD methodology for frontend bug fixes. This skill provides the complete bugfix workflow knowledge including error classification, confidence scoring, and TDD best practices.\n",
                "path": "swiss-army-knife/skills/frontend-bugfix/SKILL.md",
                "frontmatter": {
                  "name": "frontend-bugfix",
                  "description": "Use this skill when debugging frontend test failures (React/TypeScript, Vitest, etc.), fixing bugs in React/TypeScript code, or following TDD methodology for frontend bug fixes. This skill provides the complete bugfix workflow knowledge including error classification, confidence scoring, and TDD best practices.\n",
                  "version": "2.1.0"
                },
                "content": "# Frontend Bugfix Workflow Skill\n\n本 skill 提供前端测试 bugfix 的完整工作流知识，包括错误分类体系、置信度评分系统和 TDD 最佳实践。\n\n## 错误分类体系\n\n前端测试失败主要分为以下类型（按频率排序）：\n\n### 1. Mock 层次冲突（71%）\n\n**症状**：Mock 不生效，组件行为异常\n\n**识别特征**：\n\n- 同时存在 `vi.mock` 和 `server.use`\n- Hook 返回值与预期不符\n- API 调用未被拦截\n\n**解决策略**：选择单一 Mock 层\n\n```typescript\n// 选项 A：HTTP Mock（推荐用于集成测试）\nserver.use(\n  http.get('/api/data', () => HttpResponse.json({ data: 'test' }))\n);\n\n// 选项 B：Hook Mock（用于单元测试）\nvi.mock('@/hooks/useData', () => ({\n  useData: () => ({ data: 'test', isLoading: false })\n}));\n```\n\n### 2. TypeScript 类型不匹配（15%）\n\n**症状**：类型错误、Mock 数据不完整\n\n**识别特征**：\n\n- `as any` 或类型断言\n- 缺少必需字段\n- 类型定义过时\n\n**解决策略**：使用工厂函数\n\n```typescript\nconst createMockData = (overrides?: Partial<DataType>): DataType => ({\n  id: 1,\n  name: 'default',\n  ...overrides\n});\n```\n\n### 3. 异步时序问题（8%）\n\n**症状**：测试间歇性失败\n\n**识别特征**：\n\n- 缺少 `await`\n- 使用 `getBy` 而非 `findBy`\n- setTimeout 后立即断言\n\n**解决策略**：正确等待\n\n```typescript\n// Before\nrender(<Component />);\nexpect(screen.getByText('Loaded')).toBeInTheDocument();\n\n// After\nrender(<Component />);\nexpect(await screen.findByText('Loaded')).toBeInTheDocument();\n```\n\n### 4. 组件渲染问题（4%）\n\n**症状**：组件未按预期渲染\n\n**识别特征**：\n\n- 条件渲染不触发\n- 状态更新未反映\n- Props 传递错误\n\n**解决策略**：验证渲染条件和状态\n\n### 5. Hook 缓存依赖问题（2%）\n\n**症状**：Hook 返回过时数据\n\n**识别特征**：\n\n- `useEffect` 依赖数组不完整\n- `useMemo`/`useCallback` 缓存问题\n- 闭包陷阱\n\n**解决策略**：检查并修复依赖数组\n\n## 置信度评分系统\n\n### 评分标准（0-100）\n\n| 分数 | 级别 | 行为 |\n| ------ | ------ | ------ |\n| 80+ | 高 | 自动执行 |\n| 60-79 | 中 | 标记验证后继续 |\n| 40-59 | 低 | 暂停询问用户 |\n| <40 | 不确定 | 停止收集信息 |\n\n### 置信度计算\n\n```text\n置信度 = 证据质量(40%) + 模式匹配(30%) + 上下文完整性(20%) + 可复现性(10%)\n```\n\n**证据质量**：\n\n- 高：有代码行号、堆栈、可复现\n- 中：有错误信息但缺上下文\n- 低：仅有模糊描述\n\n**模式匹配**：\n\n- 高：完全匹配已知模式\n- 中：部分匹配\n- 低：未知错误类型\n\n**上下文完整性**：\n\n- 高：测试代码 + 源代码 + 配置\n- 中：只有测试或源代码\n- 低：只有错误信息\n\n**可复现性**：\n\n- 高：稳定复现\n- 中：偶发\n- 低：环境相关\n\n## TDD 流程\n\n### RED Phase（写失败测试）\n\n```typescript\n// 1. 明确期望行为\nit('should display error when API fails', async () => {\n  // 2. 设置失败场景\n  server.use(\n    http.get('/api/data', () => HttpResponse.error())\n  );\n\n  // 3. 渲染组件\n  render(<DataComponent />);\n\n  // 4. 断言期望结果\n  expect(await screen.findByText('Error loading data')).toBeInTheDocument();\n});\n```\n\n### GREEN Phase（最小实现）\n\n```typescript\n// 只写让测试通过的最小代码\n// 不要优化，不要添加额外功能\n```\n\n### REFACTOR Phase（重构）\n\n```typescript\n// 改善代码结构\n// 保持测试通过\n// 消除重复\n```\n\n## 质量门禁\n\n| 检查项 | 标准 |\n| ---------- | ------ |\n| 测试通过率 | 100% |\n| 代码覆盖率 | >= 90% |\n| 新代码覆盖率 | 100% |\n| Lint | 无错误 |\n| TypeCheck | 无错误 |\n\n## 常用命令\n\n```bash\n# 运行前端测试\nmake test TARGET=frontend\n\n# 运行特定测试\nmake test TARGET=frontend FILTER=ComponentName\n\n# 覆盖率检查\nmake test TARGET=frontend MODE=coverage\n\n# 完整 QA\nmake qa\n```\n\n## 相关文档\n\n文档路径由配置指定（`best_practices_dir`），使用以下关键词搜索：\n\n- **测试最佳实践**：关键词 \"testing\", \"best-practices\"\n- **Mock 策略**：关键词 \"mock\", \"msw\", \"vi.mock\"\n- **问题诊断**：关键词 \"troubleshooting\", \"debugging\"\n- **实现指南**：关键词 \"implementation\", \"guide\""
              },
              {
                "name": "knowledge-patterns",
                "description": "PR Review 修复模式库。在处理 PR Review 评论时自动查阅，寻找已知问题模式和解决方案。",
                "path": "swiss-army-knife/skills/knowledge-patterns/SKILL.md",
                "frontmatter": {
                  "name": "knowledge-patterns",
                  "description": "PR Review 修复模式库。在处理 PR Review 评论时自动查阅，寻找已知问题模式和解决方案。"
                },
                "content": "# PR Review 知识模式库\n\n当处理 PR Review 评论时，先查阅此模式库寻找已知解决方案，避免重复分析相同问题。\n\n## 使用场景\n\n1. **comment-classifier agent**：分类评论时，匹配已知模式提高置信度\n2. **fix-coordinator agent**：修复前查阅推荐方案\n3. **人类开发者**：学习常见问题和最佳修复实践\n\n## 快速索引\n\n<!-- INDEX_START -->\n| 模式 ID | 标题 | 技术栈 | 严重度 | 实例数 | 标签 |\n|---------|------|--------|--------|--------|------|\n| _example-silent-error-handling | [示例] 错误处理静默失败 | backend | P1 | 1 | error-handling, try-catch, silent-failure, example |\n<!-- INDEX_END -->\n\n> 带 `_example-` 前缀的是示例模式，展示格式规范。实际模式由 `knowledge-writer` agent 在 fix-pr-review 流程中自动沉淀。\n\n## 按技术栈分类\n\n### Backend\n\n<!-- BACKEND_START -->\n- [_example-silent-error-handling](patterns/_example-silent-error-handling.md) - [示例] 错误处理静默失败\n<!-- BACKEND_END -->\n\n### Frontend\n\n<!-- FRONTEND_START -->\n_暂无模式_\n<!-- FRONTEND_END -->\n\n### E2E\n\n<!-- E2E_START -->\n_暂无模式_\n<!-- E2E_END -->\n\n## 模式文件格式\n\n每个模式文件位于 `patterns/` 目录，包含：\n\n```yaml\n---\nid: pattern-id           # 唯一标识符\ntitle: 模式标题          # 人类可读标题\ntags: [tag1, tag2]       # 用于相似度匹配的标签\nstack: backend           # 技术栈: backend/frontend/e2e\nseverity: P0             # 严重度: P0/P1/P2/P3\ncreated: 2025-12-01      # 创建日期\nupdated: 2025-12-01      # 最后更新日期\ninstances: 1             # 实例数量\n---\n```\n\n## 如何查阅\n\n### AI Agent 查阅\n\n1. 读取此 SKILL.md 获取索引\n2. 根据评论关键词和技术栈筛选候选模式\n3. 读取候选模式文件获取详细信息\n4. 参考\"推荐修复\"部分制定方案\n\n### 人类开发者查阅\n\n1. 浏览上方索引表找到相关模式\n2. 点击链接查看模式详情\n3. 参考\"实例记录\"了解历史修复\n\n## 知识沉淀触发条件\n\n以下修复会自动沉淀到此库：\n\n- **优先级**：P0 或 P1\n- **置信度**：≥ 85%\n- **状态**：修复成功\n\n沉淀由 `knowledge-writer` agent 执行，支持智能合并：\n- 相似度 ≥ 70：追加到现有模式\n- 相似度 40-69：询问用户\n- 相似度 < 40：创建新模式"
              },
              {
                "name": "pr-review-analysis",
                "description": "PR Code Review 评论分析知识库，包含置信度评估、优先级分类、技术栈识别和常见评论模式",
                "path": "swiss-army-knife/skills/pr-review-analysis/SKILL.md",
                "frontmatter": {
                  "name": "pr-review-analysis",
                  "description": "PR Code Review 评论分析知识库，包含置信度评估、优先级分类、技术栈识别和常见评论模式"
                },
                "content": "# PR Review 分析 Skill\n\n本 Skill 提供 PR Code Review 评论分析的知识库，用于支持 `/fix-pr-review` 工作流。\n\n## 1. 置信度评估体系\n\n### 1.1 评分因素\n\n置信度表示评论的\"可操作性\"，分数范围 0-100。\n\n| 因素 | 权重 | 说明 |\n|------|------|------|\n| 明确性 (clarity) | 40% | 评论是否清晰指出问题和位置 |\n| 具体性 (specificity) | 30% | 是否有具体示例或测试场景 |\n| 上下文 (context) | 20% | 是否理解代码上下文和影响 |\n| 可复现 (reproducibility) | 10% | 是否有复现步骤 |\n\n### 1.2 评分指标\n\n#### 明确性 (Clarity) - 权重 40%\n\n| 指标 | 分值 | 示例 |\n|------|------|------|\n| 有具体文件位置 | +30 | \"src/auth.py:42\" |\n| 有行号 | +10 | \"第 42 行\" |\n| 有期望行为描述 | +30 | \"应该返回 401\" |\n| 有代码示例 | +20 | ``` `if token.expired:` ``` |\n| 评论长度 > 50 字 | +10 | 详细描述 |\n\n#### 具体性 (Specificity) - 权重 30%\n\n| 指标 | 分值 | 示例 |\n|------|------|------|\n| 有测试建议 | +40 | \"添加测试用例验证...\" |\n| 有具体值/示例 | +30 | \"返回 `{\"error\": \"expired\"}`\" |\n| 有对比说明 | +30 | \"应该用 X 而不是 Y\" |\n\n#### 上下文 (Context) - 权重 20%\n\n| 指标 | 分值 | 示例 |\n|------|------|------|\n| 引用其他代码位置 | +25 | \"这会影响 `UserService`\" |\n| 讨论影响范围 | +25 | \"可能导致数据不一致\" |\n| 基础分 | 50 | - |\n\n#### 可复现 (Reproducibility) - 权重 10%\n\n| 指标 | 分值 | 示例 |\n|------|------|------|\n| 有步骤描述 | +30 | \"1. 登录 2. 访问 /api\" |\n| 有输入输出描述 | +20 | \"当 token 过期时...\" |\n| 基础分 | 50 | - |\n\n### 1.3 置信度等级\n\n| 分数范围 | 等级 | 处理方式 |\n|---------|------|---------|\n| 80-100 | 高 (high) | 自动处理 |\n| 60-79 | 中 (medium) | 询问用户后处理 |\n| 40-59 | 低 (low) | 标记需澄清 |\n| 0-39 | 极低 (very_low) | 跳过，回复 reviewer |\n\n---\n\n## 2. 优先级分类体系\n\n### 2.1 优先级定义\n\n| 优先级 | 名称 | 描述 | 处理要求 |\n|--------|------|------|---------|\n| P0 | Blocker | 阻塞上线的安全/数据问题 | 必须立即处理 |\n| P1 | Critical | 核心功能缺陷 | 当前 PR 必须修复 |\n| P2 | Major | 重要改进 | 建议本 PR 修复 |\n| P3 | Minor | 建议/风格问题 | 可选处理 |\n\n### 2.2 分类关键词\n\n#### P0 (Blocker) 关键词\n\n**安全相关**（自动升级 2 个优先级）：\n\n- `security`, `vulnerability`, `injection`\n- `XSS`, `CSRF`, `leak`, `exposed`\n- `sensitive`, `password`, `token`, `secret`\n- `安全`, `漏洞`, `泄露`, `暴露`\n\n**关键缺陷**：\n\n- `crash`, `data loss`, `downtime`\n- `blocker`, `production`, `urgent`\n- `崩溃`, `数据丢失`, `紧急`, `阻塞`\n\n#### P1 (Critical) 关键词\n\n- `bug`, `broken`, `fail`, `error`\n- `incorrect`, `doesn't work`, `not working`\n- `wrong`, `invalid`, `missing`\n- `错误`, `失败`, `不正确`, `缺失`\n\n#### P2 (Major) 关键词\n\n- `should`, `better`, `improve`\n- `optimize`, `refactor`, `performance`\n- `cleanup`, `simplify`\n- `应该`, `改进`, `优化`, `重构`\n\n#### P3 (Minor) 关键词\n\n- `consider`, `maybe`, `could`\n- `nit`, `style`, `minor`, `typo`\n- `nitpick`, `suggestion`\n- `建议`, `风格`, `小问题`\n\n### 2.3 优先级提升规则\n\n| 条件 | 提升 |\n|------|------|\n| 包含安全关键词 | +2 级 |\n| 包含数据相关关键词 | +1 级 |\n| 文件在核心路径 (auth, payment) | +1 级 |\n\n---\n\n## 3. 技术栈识别\n\n### 3.1 路径模式匹配\n\n#### Backend\n\n```yaml\npatterns:\n  - \"src/api/**\"\n  - \"src/models/**\"\n  - \"src/services/**\"\n  - \"app/**\"\n  - \"tests/backend/**\"\n  - \"tests/unit/**\"\n  - \"**/*.py\"\n```\n\n#### Frontend\n\n```yaml\npatterns:\n  - \"src/components/**\"\n  - \"src/pages/**\"\n  - \"src/hooks/**\"\n  - \"src/stores/**\"\n  - \"tests/frontend/**\"\n  - \"**/*.tsx\"\n  - \"**/*.jsx\"\n```\n\n#### E2E\n\n```yaml\npatterns:\n  - \"tests/e2e/**\"\n  - \"e2e/**\"\n  - \"playwright/**\"\n  - \"cypress/**\"\n```\n\n### 3.2 文件扩展名推断\n\n| 扩展名 | 技术栈 |\n|--------|--------|\n| `.py` | Backend |\n| `.tsx`, `.ts`, `.jsx`, `.js` | Frontend |\n| `.spec.ts`, `.test.ts` (在 e2e 目录) | E2E |\n\n---\n\n## 4. 常见评论模式\n\n### 4.1 Backend 常见评论\n\n#### 数据库相关\n\n| 模式 | 置信度加成 | 优先级 |\n|------|-----------|--------|\n| \"事务/transaction\" | +15 | P1 |\n| \"N+1 查询\" | +20 | P1 |\n| \"索引/index\" | +10 | P2 |\n| \"死锁/deadlock\" | +20 | P0 |\n\n#### API 相关\n\n| 模式 | 置信度加成 | 优先级 |\n|------|-----------|--------|\n| \"状态码错误\" | +15 | P1 |\n| \"响应格式\" | +10 | P2 |\n| \"参数验证\" | +15 | P1 |\n| \"错误处理\" | +15 | P1 |\n\n#### 认证相关\n\n| 模式 | 置信度加成 | 优先级 |\n|------|-----------|--------|\n| \"token 过期\" | +20 | P0 |\n| \"权限检查\" | +20 | P0 |\n| \"会话管理\" | +15 | P1 |\n\n### 4.2 Frontend 常见评论\n\n#### React 相关\n\n| 模式 | 置信度加成 | 优先级 |\n|------|-----------|--------|\n| \"useEffect 依赖\" | +15 | P1 |\n| \"状态管理\" | +10 | P2 |\n| \"memo/useMemo\" | +10 | P2 |\n| \"key 属性\" | +15 | P1 |\n\n#### 测试相关\n\n| 模式 | 置信度加成 | 优先级 |\n|------|-----------|--------|\n| \"mock 冲突\" | +20 | P1 |\n| \"异步测试\" | +15 | P1 |\n| \"测试覆盖\" | +10 | P2 |\n\n### 4.3 E2E 常见评论\n\n| 模式 | 置信度加成 | 优先级 |\n|------|-----------|--------|\n| \"选择器不稳定\" | +15 | P1 |\n| \"超时问题\" | +15 | P1 |\n| \"等待条件\" | +15 | P1 |\n| \"断言不准确\" | +10 | P2 |\n\n---\n\n## 5. 回复最佳实践\n\n### 5.1 回复原则\n\n1. **感谢 Reviewer**：始终表示感谢\n2. **说明行动**：清楚描述做了什么\n3. **提供证据**：链接到修复代码/测试\n4. **开放沟通**：邀请进一步讨论\n\n### 5.2 回复模板\n\n#### 已修复\n\n```markdown\n✅ 已修复\n\n感谢指出！已在 `{commit}` 中完成修复。\n\n**变更**：\n- {变更描述}\n\n**测试**：\n- ✅ {测试名称} 通过\n```\n\n#### 需要澄清\n\n```markdown\n⏸️ 需要更多信息\n\n感谢建议！为了更好地理解，能否提供：\n1. {问题 1}\n2. {问题 2}\n```\n\n#### 不采纳（有理由）\n\n```markdown\nℹ️ 暂不修改\n\n感谢建议！经过分析，当前实现是预期行为，原因：\n- {原因}\n\n如果您有不同看法，欢迎继续讨论。\n```\n\n### 5.3 避免的回复\n\n- ❌ \"你的建议不对\"\n- ❌ \"代码已经这样写了\"\n- ❌ 不提供任何解释的 \"已修复\"\n- ❌ 防御性语气\n\n---\n\n## 6. 时间窗口过滤\n\n### 6.1 过滤规则\n\n**有效评论条件**：\n\n- 评论创建时间 > 最后 commit 时间\n- 或评论更新时间 > 最后 commit 时间（有新回复）\n\n### 6.2 时区处理\n\n- 所有时间使用 UTC\n- GitHub API 返回的时间已是 UTC\n- 比较前确保时区一致\n\n### 6.3 边界情况\n\n| 情况 | 处理 |\n|------|------|\n| 评论与 commit 同时 | 保守保留 |\n| 更新时间 > 创建时间 | 检查更新内容 |\n| 评论在 commit 前但有新回复 | 保留 |\n\n---\n\n## 7. TDD 集成\n\n### 7.1 修复流程\n\n所有 PR Review 修复必须遵循 TDD：\n\n1. **RED**：编写能复现评论问题的测试\n2. **GREEN**：最小实现使测试通过\n3. **REFACTOR**：优化代码\n\n### 7.2 测试命名\n\n```python\n# 格式: test_{功能}_{评论描述}\ndef test_token_validation_returns_401_when_expired():\n    \"\"\"\n    PR Review: rc_123456\n    Reviewer: @alice_dev\n    \"\"\"\n    pass\n```\n\n### 7.3 覆盖率要求\n\n- 新增代码：100% 覆盖\n- 修改代码：不低于原覆盖率\n- 总体覆盖：>= 90%\n\n---\n\n## 8. 知识沉淀\n\n### 8.1 何时沉淀\n\n- P0/P1 评论的修复\n- 置信度 >= 85 的评论\n- 新发现的问题模式\n\n### 8.2 沉淀内容\n\n```markdown\n## {问题模式名称}\n\n**频率**: ★★★☆☆\n**技术栈**: Backend/Frontend/E2E\n**关键词**: token, expire, validation\n\n### 问题描述\n{描述}\n\n### 解决方案\n{TDD 修复代码示例}\n\n### 检查清单\n- [ ] 检查项 1\n- [ ] 检查项 2\n```\n\n### 8.3 沉淀位置\n\n- 通用模式：`docs/best-practices/pr-review-patterns.md`\n- 技术栈特定：`docs/best-practices/{stack}/*.md`"
              },
              {
                "name": "workflow-logging",
                "description": "工作流过程日志格式规范和写入模式。定义 JSONL 和文本两种格式的日志结构、事件类型、级别定义和写入方法。",
                "path": "swiss-army-knife/skills/workflow-logging/SKILL.md",
                "frontmatter": {
                  "name": "workflow-logging",
                  "description": "工作流过程日志格式规范和写入模式。定义 JSONL 和文本两种格式的日志结构、事件类型、级别定义和写入方法。"
                },
                "content": "# 工作流过程日志规范\n\n本规范定义了 Swiss Army Knife 插件所有工作流的日志格式和写入模式。\n\n## 日志级别\n\n| 级别 | 代码 | 用途 |\n|------|------|------|\n| INFO | `I` | 正常流程事件（Phase/Agent 开始结束） |\n| DEBUG | `D` | 详细调试信息（完整 agent I/O，仅 --verbose） |\n| WARN | `W` | 可恢复的警告（如 Git 不可用） |\n| ERROR | `E` | 错误和失败 |\n| DECISION | `X` | 决策点（置信度决策、用户交互） |\n\n## 日志事件类型\n\n### 会话事件\n\n| 类型 | 说明 | 时机 |\n|------|------|------|\n| SESSION_START | 会话开始 | 工作流初始化后 |\n| SESSION_END | 会话结束 | 工作流完成或失败后 |\n\n### Phase 事件\n\n| 类型 | 说明 | 时机 |\n|------|------|------|\n| PHASE_START | Phase 开始 | 每个 Phase 执行前 |\n| PHASE_END | Phase 结束 | 每个 Phase 完成后 |\n\n### Agent 事件（Coordinator 级）\n\n| 类型 | 说明 | 时机 |\n|------|------|------|\n| AGENT_CALL | Agent 调用 | Task 工具调用前 |\n| AGENT_RESULT | Agent 返回 | Task 工具返回后 |\n\n### Agent 内部事件（Phase Agent 级）\n\n| 类型 | 说明 | 时机 |\n|------|------|------|\n| STEP_START | 步骤开始 | Agent 内部每个主要步骤开始 |\n| STEP_END | 步骤结束 | Agent 内部每个主要步骤结束 |\n| TOOL_USE | 工具调用 | Agent 使用 Read/Bash/Glob 等工具 |\n| DATA_COLLECTED | 数据收集 | 关键数据收集完成（配置、测试输出等） |\n| ANALYSIS_RESULT | 分析结果 | 错误分类、根因分析等结果 |\n\n### 决策事件\n\n| 类型 | 说明 | 时机 |\n|------|------|------|\n| CONFIDENCE_DECISION | 置信度决策 | 根因分析等置信度检查点 |\n| USER_INTERACTION | 用户交互 | AskUserQuestion 调用 |\n\n### Review 事件\n\n| 类型 | 说明 | 时机 |\n|------|------|------|\n| REVIEW_PARALLEL_START | 并行审查开始 | 6 个 review agents 启动 |\n| REVIEW_PARALLEL_END | 并行审查结束 | 6 个 agents 全部返回 |\n| REVIEW_FIX_ITERATION | Fix 循环迭代 | 每次 review-fix 循环 |\n\n### 警告和错误\n\n| 类型 | 说明 | 时机 |\n|------|------|------|\n| WARNING | 警告信息 | 可恢复的问题 |\n| ERROR | 错误信息 | 失败和异常 |\n\n---\n\n## JSONL 格式规范\n\n每行一条完整的 JSON 记录，字段定义：\n\n### 通用字段\n\n```json\n{\n  \"ts\": \"YYYY-MM-DDTHH:MM:SS.000Z\",  // ISO 8601 时间戳（必填）\n  \"level\": \"I\",                       // 日志级别（必填）\n  \"type\": \"PHASE_START\",              // 事件类型（必填）\n  \"session_id\": \"a1b2c3d4\"            // 会话 ID（必填）\n}\n```\n\n> **注意**：以下示例中的时间戳仅为演示，实际使用时应替换为当前时间。\n\n### SESSION_START\n\n```json\n{\n  \"ts\": \"2024-12-06T14:30:52.123Z\",\n  \"level\": \"I\",\n  \"type\": \"SESSION_START\",\n  \"session_id\": \"a1b2c3d4\",\n  \"workflow\": \"bugfix\",\n  \"stack\": \"frontend\",\n  \"command\": \"/swiss-army-knife:fix-frontend --log\",\n  \"args\": {\n    \"phase\": \"all\",\n    \"dry_run\": false,\n    \"log\": true,\n    \"verbose\": false\n  },\n  \"env\": {\n    \"project_root\": \"/path/to/project\",\n    \"plugin_version\": \"1.0.0\",\n    \"git_branch\": \"feature/login\"\n  }\n}\n```\n\n### SESSION_END\n\n```json\n{\n  \"ts\": \"2024-12-06T14:40:00.000Z\",\n  \"level\": \"I\",\n  \"type\": \"SESSION_END\",\n  \"session_id\": \"a1b2c3d4\",\n  \"status\": \"success\",\n  \"total_duration_ms\": 548000,\n  \"phases_completed\": [\"phase_0\", \"phase_1\", \"phase_2\", \"phase_3\", \"phase_4\", \"phase_5\"],\n  \"summary\": {\n    \"errors_fixed\": 3,\n    \"files_changed\": 2,\n    \"review_issues_fixed\": 4,\n    \"user_interactions\": 2\n  }\n}\n```\n\n### PHASE_START / PHASE_END\n\n```json\n{\n  \"ts\": \"2024-12-06T14:30:53.456Z\",\n  \"level\": \"I\",\n  \"type\": \"PHASE_START\",\n  \"session_id\": \"a1b2c3d4\",\n  \"phase\": \"phase_0\",\n  \"phase_name\": \"问题收集与分类\",\n  \"agents\": [\"frontend-init-collector\", \"frontend-error-analyzer\"]\n}\n```\n\n```json\n{\n  \"ts\": \"2024-12-06T14:31:05.789Z\",\n  \"level\": \"I\",\n  \"type\": \"PHASE_END\",\n  \"session_id\": \"a1b2c3d4\",\n  \"phase\": \"phase_0\",\n  \"status\": \"success\",\n  \"duration_ms\": 12333,\n  \"summary\": {\n    \"errors_found\": 3,\n    \"test_status\": \"test_failed\"\n  }\n}\n```\n\n### AGENT_CALL / AGENT_RESULT\n\n```json\n{\n  \"ts\": \"2024-12-06T14:30:53.500Z\",\n  \"level\": \"I\",\n  \"type\": \"AGENT_CALL\",\n  \"session_id\": \"a1b2c3d4\",\n  \"phase\": \"phase_0\",\n  \"agent\": \"frontend-init-collector\",\n  \"model\": \"sonnet\",\n  \"input_summary\": \"加载配置和收集测试输出\"\n}\n```\n\n```json\n{\n  \"ts\": \"2024-12-06T14:30:58.200Z\",\n  \"level\": \"I\",\n  \"type\": \"AGENT_RESULT\",\n  \"session_id\": \"a1b2c3d4\",\n  \"phase\": \"phase_0\",\n  \"agent\": \"frontend-init-collector\",\n  \"status\": \"success\",\n  \"duration_ms\": 4700,\n  \"output_summary\": {\n    \"config_loaded\": true,\n    \"test_output_lines\": 150,\n    \"warnings_count\": 1\n  }\n}\n```\n\n### STEP_START / STEP_END（Agent 内部）\n\n```json\n{\n  \"ts\": \"2024-12-06T14:30:54.000Z\",\n  \"level\": \"I\",\n  \"type\": \"STEP_START\",\n  \"session_id\": \"a1b2c3d4\",\n  \"phase\": \"phase_0\",\n  \"agent\": \"frontend-init-collector\",\n  \"step\": \"config_loading\",\n  \"step_name\": \"加载配置\",\n  \"step_index\": 1,\n  \"total_steps\": 3\n}\n```\n\n```json\n{\n  \"ts\": \"2024-12-06T14:30:55.500Z\",\n  \"level\": \"I\",\n  \"type\": \"STEP_END\",\n  \"session_id\": \"a1b2c3d4\",\n  \"phase\": \"phase_0\",\n  \"agent\": \"frontend-init-collector\",\n  \"step\": \"config_loading\",\n  \"status\": \"success\",\n  \"duration_ms\": 1500,\n  \"result_summary\": {\n    \"default_config\": true,\n    \"project_config\": true,\n    \"merged\": true\n  }\n}\n```\n\n### TOOL_USE（Agent 内部）\n\n```json\n{\n  \"ts\": \"2024-12-06T14:30:54.200Z\",\n  \"level\": \"D\",\n  \"type\": \"TOOL_USE\",\n  \"session_id\": \"a1b2c3d4\",\n  \"phase\": \"phase_0\",\n  \"agent\": \"frontend-init-collector\",\n  \"step\": \"config_loading\",\n  \"tool\": \"Read\",\n  \"target\": \"config/defaults.yaml\",\n  \"status\": \"success\"\n}\n```\n\n### DATA_COLLECTED（Agent 内部）\n\n```json\n{\n  \"ts\": \"2024-12-06T14:30:56.000Z\",\n  \"level\": \"I\",\n  \"type\": \"DATA_COLLECTED\",\n  \"session_id\": \"a1b2c3d4\",\n  \"phase\": \"phase_0\",\n  \"agent\": \"frontend-init-collector\",\n  \"data_type\": \"test_output\",\n  \"summary\": {\n    \"lines\": 150,\n    \"exit_code\": 1,\n    \"status\": \"test_failed\",\n    \"source\": \"auto_run\"\n  }\n}\n```\n\n### ANALYSIS_RESULT（Agent 内部）\n\n```json\n{\n  \"ts\": \"2024-12-06T14:31:02.000Z\",\n  \"level\": \"I\",\n  \"type\": \"ANALYSIS_RESULT\",\n  \"session_id\": \"a1b2c3d4\",\n  \"phase\": \"phase_0\",\n  \"agent\": \"frontend-error-analyzer\",\n  \"analysis_type\": \"error_classification\",\n  \"result\": {\n    \"errors_found\": 3,\n    \"categories\": {\n      \"mock_conflict\": 2,\n      \"async_timing\": 1\n    },\n    \"files_affected\": [\"Button.test.tsx\", \"Form.test.tsx\"]\n  }\n}\n```\n\n### CONFIDENCE_DECISION\n\n```json\n{\n  \"ts\": \"2024-12-06T14:31:15.100Z\",\n  \"level\": \"X\",\n  \"type\": \"CONFIDENCE_DECISION\",\n  \"session_id\": \"a1b2c3d4\",\n  \"phase\": \"phase_1\",\n  \"confidence_score\": 65,\n  \"threshold\": {\n    \"auto_continue\": 60,\n    \"ask_user\": 40,\n    \"stop\": 0\n  },\n  \"decision\": \"auto_continue\",\n  \"factors\": {\n    \"clarity\": 70,\n    \"specificity\": 60,\n    \"context\": 65,\n    \"reproducibility\": 55\n  }\n}\n```\n\n### USER_INTERACTION\n\n```json\n{\n  \"ts\": \"2024-12-06T14:32:00.000Z\",\n  \"level\": \"X\",\n  \"type\": \"USER_INTERACTION\",\n  \"session_id\": \"a1b2c3d4\",\n  \"phase\": \"phase_3\",\n  \"interaction_type\": \"AskUserQuestion\",\n  \"question\": \"Bugfix 方案已生成，请查看 docs/bugfix/xxx.md。确认后开始实施。\",\n  \"options\": [\"确认执行\", \"调整方案\", \"取消\"],\n  \"user_response\": \"确认执行\",\n  \"wait_duration_ms\": 15000\n}\n```\n\n### REVIEW_PARALLEL_START / REVIEW_PARALLEL_END\n\n```json\n{\n  \"ts\": \"2024-12-06T14:35:00.000Z\",\n  \"level\": \"I\",\n  \"type\": \"REVIEW_PARALLEL_START\",\n  \"session_id\": \"a1b2c3d4\",\n  \"phase\": \"phase_5\",\n  \"agents\": [\n    \"review-code-reviewer\",\n    \"review-silent-failure-hunter\",\n    \"review-code-simplifier\",\n    \"review-test-analyzer\",\n    \"review-comment-analyzer\",\n    \"review-type-design-analyzer\"\n  ]\n}\n```\n\n```json\n{\n  \"ts\": \"2024-12-06T14:35:30.000Z\",\n  \"level\": \"I\",\n  \"type\": \"REVIEW_PARALLEL_END\",\n  \"session_id\": \"a1b2c3d4\",\n  \"phase\": \"phase_5\",\n  \"duration_ms\": 30000,\n  \"results\": [\n    {\"agent\": \"review-code-reviewer\", \"status\": \"success\", \"issues\": 2},\n    {\"agent\": \"review-silent-failure-hunter\", \"status\": \"success\", \"issues\": 1},\n    {\"agent\": \"review-code-simplifier\", \"status\": \"success\", \"issues\": 0},\n    {\"agent\": \"review-test-analyzer\", \"status\": \"success\", \"issues\": 1},\n    {\"agent\": \"review-comment-analyzer\", \"status\": \"failed\", \"error\": \"timeout\"},\n    {\"agent\": \"review-type-design-analyzer\", \"status\": \"success\", \"issues\": 0}\n  ],\n  \"total_issues\": 4,\n  \"fixable_issues\": 3\n}\n```\n\n### REVIEW_FIX_ITERATION\n\n```json\n{\n  \"ts\": \"2024-12-06T14:36:00.000Z\",\n  \"level\": \"I\",\n  \"type\": \"REVIEW_FIX_ITERATION\",\n  \"session_id\": \"a1b2c3d4\",\n  \"phase\": \"phase_5\",\n  \"iteration\": 1,\n  \"issues_before\": 4,\n  \"issues_after\": 1,\n  \"fixed_count\": 3,\n  \"termination_reason\": null\n}\n```\n\n### WARNING / ERROR\n\n```json\n{\n  \"ts\": \"2024-12-06T14:31:10.500Z\",\n  \"level\": \"W\",\n  \"type\": \"WARNING\",\n  \"session_id\": \"a1b2c3d4\",\n  \"phase\": \"phase_0\",\n  \"code\": \"GIT_UNAVAILABLE\",\n  \"message\": \"Git 信息收集失败：not a git repository\",\n  \"impact\": \"根因分析将缺少版本控制上下文\"\n}\n```\n\n```json\n{\n  \"ts\": \"2024-12-06T14:33:00.000Z\",\n  \"level\": \"E\",\n  \"type\": \"ERROR\",\n  \"session_id\": \"a1b2c3d4\",\n  \"phase\": \"phase_1\",\n  \"code\": \"CONFIDENCE_TOO_LOW\",\n  \"message\": \"根因分析置信度 35% 低于阈值 40%\",\n  \"agent\": \"frontend-root-cause\",\n  \"recoverable\": false\n}\n```\n\n### DEBUG: AGENT_IO（仅 --verbose）\n\n```json\n{\n  \"ts\": \"2024-12-06T14:30:53.500Z\",\n  \"level\": \"D\",\n  \"type\": \"AGENT_IO\",\n  \"session_id\": \"a1b2c3d4\",\n  \"phase\": \"phase_0\",\n  \"agent\": \"frontend-init-collector\",\n  \"direction\": \"input\",\n  \"content\": \"... 完整的 agent 输入 ...\"\n}\n```\n\n---\n\n## 文本格式规范\n\n人类可读的时间线格式，每行一条记录：\n\n```\n[{timestamp}] {LEVEL} | {TYPE} | {message}\n```\n\n### 格式示例\n\n```\n[2024-12-06 14:30:52.123] INFO | SESSION_START | Bugfix Frontend (a1b2c3d4)\n[2024-12-06 14:30:52.123] INFO | ENV          | project=/path/to/project branch=feature/login\n[2024-12-06 14:30:53.456] INFO | PHASE_START  | Phase 0: 问题收集与分类\n[2024-12-06 14:30:53.500] INFO | AGENT_CALL   | frontend-init-collector (sonnet)\n[2024-12-06 14:30:58.200] INFO | AGENT_RESULT | frontend-init-collector | success | 4700ms\n[2024-12-06 14:31:05.789] INFO | PHASE_END    | Phase 0 | success | 12333ms | errors_found=3\n[2024-12-06 14:31:06.000] INFO | PHASE_START  | Phase 1: 诊断分析\n[2024-12-06 14:31:15.100] DECN | CONFIDENCE   | score=65 | decision=auto_continue | threshold=60\n[2024-12-06 14:31:20.000] INFO | PHASE_END    | Phase 1 | success | 14000ms\n[2024-12-06 14:32:00.000] DECN | USER_ASK     | \"确认后开始实施\" | options=[确认执行,调整方案,取消]\n[2024-12-06 14:32:15.000] DECN | USER_ANSWER  | \"确认执行\" | wait=15000ms\n[2024-12-06 14:35:00.000] INFO | REVIEW_START | 6 agents: code-reviewer,silent-failure-hunter,...\n[2024-12-06 14:35:30.000] INFO | REVIEW_END   | 30000ms | issues=4 | fixable=3\n[2024-12-06 14:36:00.000] INFO | REVIEW_FIX   | iteration=1 | before=4 | after=1 | fixed=3\n[2024-12-06 14:40:00.000] INFO | SESSION_END  | success | 548000ms | files=2 | issues_fixed=4\n```\n\n### 级别对齐\n\n```\nINFO  - 正常信息（4 字符 + 空格）\nDEBUG - 调试信息（5 字符）\nWARN  - 警告（4 字符 + 空格）\nERROR - 错误（5 字符）\nDECN  - 决策（4 字符 + 空格）\n```\n\n---\n\n## 日志写入方法\n\n### 使用 Bash 追加写入\n\n由于 Write 工具会覆盖文件，**必须使用 Bash 追加**：\n\n```bash\n# JSONL 格式\necho '{\"ts\":\"2024-12-06T14:30:52.123Z\",\"level\":\"I\",\"type\":\"PHASE_START\",...}' >> \"${jsonl_file}\"\n\n# 文本格式\necho '[2024-12-06 14:30:52.123] INFO | PHASE_START  | Phase 0: 问题收集与分类' >> \"${log_file}\"\n```\n\n### JSON 转义注意事项\n\nJSON 字符串中的特殊字符需要正确转义：\n- 双引号 `\"` → `\\\"`\n- 反斜杠 `\\` → `\\\\`\n- 换行符 → `\\n`\n\n### 时间戳格式\n\n- **JSONL**: ISO 8601 格式 `2024-12-06T14:30:52.123Z`\n- **文本**: 人类可读 `[2024-12-06 14:30:52.123]`\n\n获取当前时间戳：\n```bash\n# ISO 8601 格式（用于 JSONL）\ndate -u +\"%Y-%m-%dT%H:%M:%S.000Z\"\n\n# 人类可读格式（用于文本）\ndate +\"%Y-%m-%d %H:%M:%S.000\"\n```\n\n---\n\n## 日志上下文传递\n\n### 层级 1: 命令层 → Master Coordinator\n\n命令层传递给 coordinator 的 logging 上下文：\n\n```json\n{\n  \"logging\": {\n    \"enabled\": true,\n    \"level\": \"info\",\n    \"session_id\": \"a1b2c3d4\"\n  }\n}\n```\n\n### 层级 2: Master Coordinator → Phase Agent\n\nMaster Coordinator 初始化日志文件后，传递给每个 Phase Agent：\n\n```json\n{\n  \"logging\": {\n    \"enabled\": true,\n    \"level\": \"info\",\n    \"session_id\": \"a1b2c3d4\",\n    \"phase\": \"phase_0\",\n    \"log_files\": {\n      \"jsonl\": \".claude/logs/swiss-army-knife/bugfix/2024-12-06_143052_frontend_a1b2c3d4.jsonl\",\n      \"text\": \".claude/logs/swiss-army-knife/bugfix/2024-12-06_143052_frontend_a1b2c3d4.log\"\n    }\n  }\n}\n```\n\n### Phase Agent 日志记录模式\n\nPhase Agent 收到 logging 上下文后，在每个主要步骤记录日志：\n\n```markdown\n## 日志记录\n\n如果 `logging.enabled` 为 `true`，在每个步骤记录日志：\n\n### 步骤开始\n\n\\`\\`\\`bash\n# JSONL\necho '{\"ts\":\"'$(date -u +\"%Y-%m-%dT%H:%M:%S.000Z\")'\",\"level\":\"I\",\"type\":\"STEP_START\",\"session_id\":\"${session_id}\",\"phase\":\"${phase}\",\"agent\":\"${agent_name}\",\"step\":\"config_loading\",\"step_name\":\"加载配置\",\"step_index\":1,\"total_steps\":3}' >> \"${jsonl_file}\"\n\n# 文本\necho \"[$(date +\"%Y-%m-%d %H:%M:%S.000\")] INFO | STEP_START  | ${agent_name} | 步骤 1/3: 加载配置\" >> \"${log_file}\"\n\\`\\`\\`\n\n### 步骤结束\n\n\\`\\`\\`bash\n# JSONL\necho '{\"ts\":\"'$(date -u +\"%Y-%m-%dT%H:%M:%S.000Z\")'\",\"level\":\"I\",\"type\":\"STEP_END\",\"session_id\":\"${session_id}\",\"phase\":\"${phase}\",\"agent\":\"${agent_name}\",\"step\":\"config_loading\",\"status\":\"success\",\"duration_ms\":1500}' >> \"${jsonl_file}\"\n\n# 文本\necho \"[$(date +\"%Y-%m-%d %H:%M:%S.000\")] INFO | STEP_END    | ${agent_name} | 步骤 1/3 完成 | 1500ms\" >> \"${log_file}\"\n\\`\\`\\`\n```\n\n### Coordinator 内部维护\n\nCoordinator 初始化后计算日志文件路径：\n\n```python\nlog_dir = \".claude/logs/swiss-army-knife/{workflow}\"\ntimestamp = \"2024-12-06_143052\"\nsession_id = input.logging.session_id\n\njsonl_file = f\"{log_dir}/{timestamp}_{identifier}_{session_id}.jsonl\"\nlog_file = f\"{log_dir}/{timestamp}_{identifier}_{session_id}.log\"\n```\n\n### 传递给子 Coordinator（如 review-coordinator）\n\n```json\n{\n  \"logging\": {\n    \"enabled\": true,\n    \"level\": \"info\",\n    \"session_id\": \"a1b2c3d4\",\n    \"log_files\": {\n      \"jsonl\": \".claude/logs/swiss-army-knife/bugfix/xxx.jsonl\",\n      \"text\": \".claude/logs/swiss-army-knife/bugfix/xxx.log\"\n    }\n  }\n}\n```\n\n---\n\n## 日志查询示例\n\n### 使用 jq 查询 JSONL\n\n```bash\n# 查看会话摘要\njq 'select(.type == \"SESSION_START\" or .type == \"SESSION_END\")' xxx.jsonl\n\n# 查看所有错误\njq 'select(.level == \"E\")' xxx.jsonl\n\n# 查看 Phase 耗时\njq 'select(.type == \"PHASE_END\") | {phase, duration_ms, status}' xxx.jsonl\n\n# 查看置信度决策\njq 'select(.type == \"CONFIDENCE_DECISION\")' xxx.jsonl\n\n# 查看用户交互\njq 'select(.type == \"USER_INTERACTION\")' xxx.jsonl\n\n# 按时间排序\njq -s 'sort_by(.ts)' xxx.jsonl\n\n# 计算总耗时\njq 'select(.type == \"SESSION_END\") | .total_duration_ms / 1000 | \"\\(.) 秒\"' xxx.jsonl\n```\n\n### 使用 grep 查询文本日志\n\n```bash\n# 查看所有错误\ngrep \"ERROR\" xxx.log\n\n# 查看 Phase 耗时\ngrep \"PHASE_END\" xxx.log\n\n# 查看决策点\ngrep \"DECN\" xxx.log\n\n# 查看特定 agent\ngrep \"frontend-root-cause\" xxx.log\n```"
              }
            ]
          }
        ]
      }
    }
  ]
}