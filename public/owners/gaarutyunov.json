{
  "owner": {
    "id": "gaarutyunov",
    "display_name": "German Arutyunov",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/36804225?u=b0c60badab41aeb1fdc849d6fb30d06850af69e7&v=4",
    "url": "https://github.com/gaarutyunov",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 3,
      "total_commands": 0,
      "total_skills": 5,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "gaarutyunov/dev-skills",
      "url": "https://github.com/gaarutyunov/dev-skills",
      "description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-12-23T20:43:38Z",
        "created_at": "2025-12-19T01:26:08Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 927
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 75
        },
        {
          "path": "CLAUDE.md",
          "type": "blob",
          "size": 289
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 860
        },
        {
          "path": "bazel",
          "type": "tree",
          "size": null
        },
        {
          "path": "bazel/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "bazel/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 369
        },
        {
          "path": "bazel/LICENSE",
          "type": "blob",
          "size": 1073
        },
        {
          "path": "bazel/README.md",
          "type": "blob",
          "size": 1165
        },
        {
          "path": "bazel/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "bazel/skills/developing-bazel-rules",
          "type": "tree",
          "size": null
        },
        {
          "path": "bazel/skills/developing-bazel-rules/SKILL.md",
          "type": "blob",
          "size": 5175
        },
        {
          "path": "bazel/skills/developing-bazel-rules/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "bazel/skills/developing-bazel-rules/references/api-reference.md",
          "type": "blob",
          "size": 5649
        },
        {
          "path": "bazel/skills/developing-bazel-rules/references/go-patterns.md",
          "type": "blob",
          "size": 6661
        },
        {
          "path": "bazel/skills/developing-bazel-rules/references/providers.md",
          "type": "blob",
          "size": 4637
        },
        {
          "path": "bazel/skills/developing-bazel-rules/references/testing.md",
          "type": "blob",
          "size": 5739
        },
        {
          "path": "bazel/skills/developing-bazel-rules/references/toolchains.md",
          "type": "blob",
          "size": 5565
        },
        {
          "path": "gitea",
          "type": "tree",
          "size": null
        },
        {
          "path": "gitea/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "gitea/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 334
        },
        {
          "path": "gitea/LICENSE",
          "type": "blob",
          "size": 1073
        },
        {
          "path": "gitea/README.md",
          "type": "blob",
          "size": 1721
        },
        {
          "path": "gitea/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "gitea/skills/go-sdk",
          "type": "tree",
          "size": null
        },
        {
          "path": "gitea/skills/go-sdk/SKILL.md",
          "type": "blob",
          "size": 3375
        },
        {
          "path": "gitea/skills/go-sdk/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "gitea/skills/go-sdk/references/api-reference.md",
          "type": "blob",
          "size": 9925
        },
        {
          "path": "gitea/skills/go-sdk/references/examples.md",
          "type": "blob",
          "size": 9353
        },
        {
          "path": "gitea/skills/go-sdk/references/types.md",
          "type": "blob",
          "size": 6247
        },
        {
          "path": "gitea/skills/tea-cli",
          "type": "tree",
          "size": null
        },
        {
          "path": "gitea/skills/tea-cli/SKILL.md",
          "type": "blob",
          "size": 2557
        },
        {
          "path": "gitea/skills/tea-cli/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "gitea/skills/tea-cli/references/authentication.md",
          "type": "blob",
          "size": 1974
        },
        {
          "path": "gitea/skills/tea-cli/references/commands.md",
          "type": "blob",
          "size": 5547
        },
        {
          "path": "gitea/skills/tea-cli/references/workflows.md",
          "type": "blob",
          "size": 3477
        },
        {
          "path": "hetzner",
          "type": "tree",
          "size": null
        },
        {
          "path": "hetzner/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "hetzner/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 377
        },
        {
          "path": "hetzner/README.md",
          "type": "blob",
          "size": 1395
        },
        {
          "path": "hetzner/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "hetzner/skills/hcloud-cli",
          "type": "tree",
          "size": null
        },
        {
          "path": "hetzner/skills/hcloud-cli/SKILL.md",
          "type": "blob",
          "size": 4352
        },
        {
          "path": "hetzner/skills/hcloud-cli/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "hetzner/skills/hcloud-cli/references/commands.md",
          "type": "blob",
          "size": 10639
        },
        {
          "path": "hetzner/skills/hcloud-cli/references/configuration.md",
          "type": "blob",
          "size": 3627
        },
        {
          "path": "hetzner/skills/hcloud-go-sdk",
          "type": "tree",
          "size": null
        },
        {
          "path": "hetzner/skills/hcloud-go-sdk/SKILL.md",
          "type": "blob",
          "size": 4388
        },
        {
          "path": "hetzner/skills/hcloud-go-sdk/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "hetzner/skills/hcloud-go-sdk/references/api-reference.md",
          "type": "blob",
          "size": 14949
        },
        {
          "path": "hetzner/skills/hcloud-go-sdk/references/patterns.md",
          "type": "blob",
          "size": 9633
        }
      ],
      "marketplace": {
        "name": "dev-skills",
        "version": null,
        "description": "Personal collection of skills for infrastructure tools - CLIs, APIs, and SDKs",
        "owner_info": {
          "name": "German Arutyunov"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "gitea",
            "description": "Skills for Gitea: tea CLI operations and Go SDK development",
            "source": "./gitea",
            "category": null,
            "version": "1.0.0",
            "author": {
              "name": "German Arutyunov"
            },
            "install_commands": [
              "/plugin marketplace add gaarutyunov/dev-skills",
              "/plugin install gitea@dev-skills"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-23T20:43:38Z",
              "created_at": "2025-12-19T01:26:08Z",
              "license": null
            },
            "commands": [],
            "skills": [
              {
                "name": "go-sdk",
                "description": "Use when writing Go code to interact with Gitea API - automation, bots, integrations, migrations, or programmatic git forge operations",
                "path": "gitea/skills/go-sdk/SKILL.md",
                "frontmatter": {
                  "name": "go-sdk",
                  "description": "Use when writing Go code to interact with Gitea API - automation, bots, integrations, migrations, or programmatic git forge operations"
                },
                "content": "# Gitea Go SDK\n\n## Overview\n\nThe official Go SDK for Gitea provides 332+ API methods with full type safety. Use it for bots, automation, integrations, and complex workflows. For quick CLI operations, use `gitea:tea-cli` instead.\n\n## Quick Setup\n\n```go\nimport \"code.gitea.io/sdk/gitea\"\n\n// Create client\nclient, err := gitea.NewClient(\n    \"https://gitea.example.com\",\n    gitea.SetToken(\"your-token\"),\n)\n```\n\n```bash\ngo get code.gitea.io/sdk/gitea\n```\n\nSee `references/authentication.md` in tea-cli for token creation.\n\n## Quick Reference\n\n| Task | Method |\n|------|--------|\n| **Repos** | |\n| List my repos | `client.ListMyRepos(ListReposOptions{})` |\n| Get repo | `client.GetRepo(owner, repo)` |\n| Create repo | `client.CreateRepo(CreateRepoOption{})` |\n| **Issues** | |\n| List issues | `client.ListRepoIssues(owner, repo, ListIssueOption{})` |\n| Create issue | `client.CreateIssue(owner, repo, CreateIssueOption{})` |\n| Edit issue | `client.EditIssue(owner, repo, index, EditIssueOption{})` |\n| **PRs** | |\n| List PRs | `client.ListRepoPullRequests(owner, repo, ListPullRequestsOptions{})` |\n| Create PR | `client.CreatePullRequest(owner, repo, CreatePullRequestOption{})` |\n| Merge PR | `client.MergePullRequest(owner, repo, index, MergePullRequestOption{})` |\n| **Releases** | |\n| List releases | `client.ListReleases(owner, repo, ListReleasesOptions{})` |\n| Create release | `client.CreateRelease(owner, repo, CreateReleaseOption{})` |\n\n## API Categories\n\nSee `references/api-reference.md` for complete method list:\n- Repositories (70+ methods)\n- Issues & comments (50+ methods)\n- Pull requests & reviews (40+ methods)\n- Releases & attachments\n- Organizations & teams\n- Users, webhooks, actions\n\n## Common Types\n\nSee `references/types.md` for struct definitions:\n- `Repository`, `Issue`, `PullRequest`, `Release`\n- `User`, `Organization`, `Team`\n- `ListOptions` for pagination\n- Option structs for create/edit\n\n## Patterns\n\nSee `references/examples.md` for idiomatic patterns:\n- Error handling\n- Pagination\n- Context usage\n- Webhook handlers\n\n## Authentication Options\n\n```go\n// Token auth (recommended)\nclient, _ := gitea.NewClient(url, gitea.SetToken(token))\n\n// Basic auth\nclient, _ := gitea.NewClient(url, gitea.SetBasicAuth(user, pass))\n\n// With 2FA\nclient, _ := gitea.NewClient(url,\n    gitea.SetBasicAuth(user, pass),\n    gitea.SetOTP(otp),\n)\n\n// SSH key\nclient, _ := gitea.NewClient(url,\n    gitea.UseSSHPubkey(fingerprint, keyPath, passphrase),\n)\n```\n\n## Common Patterns\n\n```go\n// Pagination\nopts := gitea.ListOptions{Page: 1, PageSize: 50}\nfor {\n    repos, resp, _ := client.ListMyRepos(gitea.ListReposOptions{ListOptions: opts})\n    // process repos...\n    if resp.NextPage == 0 {\n        break\n    }\n    opts.Page = resp.NextPage\n}\n\n// Context support\nctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\ndefer cancel()\nclient.SetContext(ctx)\n```\n\n## Common Mistakes\n\n| Problem | Solution |\n|---------|----------|\n| Nil pointer panic | Always check error before using result |\n| Missing pagination | Use `resp.NextPage` to get all results |\n| Context timeout | Set appropriate timeout for bulk operations |\n| Rate limiting | Check `resp.Header` for rate limit info |"
              },
              {
                "name": "tea-cli",
                "description": "Use when interacting with Gitea via command line - managing issues, PRs, releases, repos, or any git forge operations with tea CLI",
                "path": "gitea/skills/tea-cli/SKILL.md",
                "frontmatter": {
                  "name": "tea-cli",
                  "description": "Use when interacting with Gitea via command line - managing issues, PRs, releases, repos, or any git forge operations with tea CLI"
                },
                "content": "# Tea CLI for Gitea\n\n## Overview\n\nTea is the official CLI for Gitea. Use it for quick operations, scripting, and CI/CD workflows. For complex automation or custom integrations, use the `gitea:go-sdk` skill instead.\n\n## Quick Setup\n\n```bash\n# Install\nbrew install tea  # or: go install code.gitea.io/tea@latest\n\n# Authenticate\ntea login add --name myserver --url https://gitea.example.com --token YOUR_TOKEN\n```\n\nSee `references/authentication.md` for detailed auth options.\n\n## Quick Reference\n\n| Task | Command |\n|------|---------|\n| **Issues** | |\n| List issues | `tea issues` |\n| Create issue | `tea issues create --title \"Bug\" --body \"Details\"` |\n| Close issue | `tea issues close 123` |\n| **Pull Requests** | |\n| List PRs | `tea pr` |\n| Create PR | `tea pr create --head feature --base main` |\n| Checkout PR | `tea pr checkout 45` |\n| Merge PR | `tea pr merge 45` |\n| Review PR | `tea pr review 45 --approve` |\n| **Releases** | |\n| List releases | `tea releases` |\n| Create release | `tea release create --tag v1.0.0 --title \"Release\"` |\n| Upload asset | `tea release assets create --tag v1.0.0 FILE` |\n| **Repos** | |\n| List repos | `tea repos` |\n| Create repo | `tea repos create --name myrepo` |\n| Clone repo | `tea clone owner/repo` |\n| Fork repo | `tea repos fork owner/repo` |\n\n## Command Categories\n\nSee `references/commands.md` for complete command reference:\n- Issues & comments\n- Pull requests & reviews\n- Releases & assets\n- Repositories & branches\n- Labels, milestones, organizations\n- Webhooks, notifications, time tracking\n- Actions (secrets/variables)\n\n## Common Workflows\n\nSee `references/workflows.md` for patterns:\n- Feature branch to merged PR\n- Release with assets\n- Issue triage\n- Multi-instance management\n\n## Output Formats\n\n```bash\ntea issues --output json    # JSON\ntea issues --output yaml    # YAML\ntea issues --output csv     # CSV\ntea issues --output simple  # Plain text\n```\n\n## Repository Context\n\nTea auto-detects repo from current directory's git remote. Override with:\n```bash\ntea issues --repo owner/repo\ntea issues --login myserver  # specific Gitea instance\n```\n\n## Common Mistakes\n\n| Problem | Solution |\n|---------|----------|\n| \"not logged in\" | Run `tea login add` first |\n| Wrong repo context | Use `--repo owner/repo` flag |\n| Can't find PR | Check `--state` flag (open/closed/all) |\n| Token expired | Re-run `tea login add` with new token |"
              }
            ]
          },
          {
            "name": "hetzner",
            "description": "Skills for Hetzner Cloud: hcloud CLI operations and Go SDK development",
            "source": "./hetzner",
            "category": null,
            "version": "1.0.0",
            "author": {
              "name": "German Arutyunov"
            },
            "install_commands": [
              "/plugin marketplace add gaarutyunov/dev-skills",
              "/plugin install hetzner@dev-skills"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-23T20:43:38Z",
              "created_at": "2025-12-19T01:26:08Z",
              "license": null
            },
            "commands": [],
            "skills": [
              {
                "name": "hcloud-cli",
                "description": "Use when interacting with Hetzner Cloud via command line - managing servers, networks, volumes, load balancers, firewalls, DNS, or any cloud infrastructure operations with hcloud CLI",
                "path": "hetzner/skills/hcloud-cli/SKILL.md",
                "frontmatter": {
                  "name": "hcloud-cli",
                  "description": "Use when interacting with Hetzner Cloud via command line - managing servers, networks, volumes, load balancers, firewalls, DNS, or any cloud infrastructure operations with hcloud CLI"
                },
                "content": "# Hetzner Cloud CLI (hcloud)\n\n## Overview\n\nhcloud is the official CLI for Hetzner Cloud. Use it for quick operations, scripting, and CI/CD workflows. For complex automation or custom Go integrations, use the `hetzner:hcloud-go-sdk` skill instead.\n\n## Quick Setup\n\n```bash\n# Install\nbrew install hcloud  # or: go install github.com/hetznercloud/cli/cmd/hcloud@latest\n\n# Authenticate\nhcloud context create myproject\n# Enter your API token when prompted (from https://console.hetzner.cloud)\n```\n\nSee `references/configuration.md` for multi-project and advanced setup.\n\n## Quick Reference\n\n| Task | Command |\n|------|---------|\n| **Servers** | |\n| List servers | `hcloud server list` |\n| Create server | `hcloud server create --name web --type cpx22 --image ubuntu-24.04` |\n| SSH to server | `hcloud server ssh web` |\n| Delete server | `hcloud server delete web` |\n| Reboot/Reset | `hcloud server reboot web` / `hcloud server reset web` |\n| **Networks** | |\n| Create network | `hcloud network create --name private --ip-range 10.0.0.0/8` |\n| Attach server | `hcloud server attach-to-network web --network private` |\n| **Volumes** | |\n| Create volume | `hcloud volume create --name data --size 100 --server web` |\n| Attach volume | `hcloud volume attach data --server web --automount` |\n| **Firewalls** | |\n| Create firewall | `hcloud firewall create --name web-fw` |\n| Add rule | `hcloud firewall add-rule web-fw --direction in --protocol tcp --port 80` |\n| Apply to server | `hcloud firewall apply-to-resource web-fw --type server --server web` |\n| **Load Balancers** | |\n| Create LB | `hcloud load-balancer create --name lb --type lb11 --location fsn1` |\n| Add target | `hcloud load-balancer add-target lb --server web` |\n| **SSH Keys** | |\n| Upload key | `hcloud ssh-key create --name mykey --public-key-from-file ~/.ssh/id_rsa.pub` |\n| **DNS (Zones)** | |\n| List zones | `hcloud zone list` |\n| Create zone | `hcloud zone create --name example.com` |\n\n## Command Categories\n\nSee `references/commands.md` for complete command reference:\n- Servers (lifecycle, rescue, metrics, console)\n- Networks, subnets, routes\n- Volumes, storage boxes\n- Firewalls and rules\n- Load balancers, targets, services\n- Floating IPs, primary IPs\n- SSH keys, images, ISOs\n- DNS zones and records\n- Certificates, placement groups\n\n## Output Formats\n\n```bash\n# JSON output for scripting\nhcloud server list --output json | jq '.[] | select(.status == \"running\")'\n\n# YAML output\nhcloud server describe web --output yaml\n\n# Go template formatting\nhcloud server describe web --output format='{{.ServerType.Cores}} cores'\n\n# Table customization\nhcloud server list --output columns=id,name,status,ipv4\nhcloud server list --output noheader\n```\n\n## Context Management (Multi-Project)\n\n```bash\n# Create contexts for different projects/tokens\nhcloud context create production\nhcloud context create staging\n\n# Switch context\nhcloud context use production\n\n# List contexts\nhcloud context list\n```\n\n## Common Patterns\n\n```bash\n# Create server with SSH key and private network\nhcloud server create \\\n  --name web-01 \\\n  --type cpx22 \\\n  --image ubuntu-24.04 \\\n  --ssh-key mykey \\\n  --network private \\\n  --location fsn1\n\n# Create firewall with rules file\nhcloud firewall create --name web-fw --rules-file rules.json\n\n# Bulk server creation\nfor i in {1..3}; do\n  hcloud server create --name \"node-$i\" --type cx22 --image ubuntu-24.04\ndone\n\n# Wait for server to be running\nhcloud server create --name app --type cx22 --image ubuntu-24.04\nwhile [[ $(hcloud server describe app -o format='{{.Status}}') != \"running\" ]]; do\n  sleep 2\ndone\n```\n\n## Common Mistakes\n\n| Problem | Solution |\n|---------|----------|\n| \"context not set\" | Run `hcloud context create <name>` and enter token |\n| \"resource not found\" | Check `hcloud <resource> list` - might be in different project |\n| Token expired | Update with `hcloud context create <name>` (same name replaces) |\n| Wrong location | Use `--location fsn1` or `nbg1` or `hel1` explicitly |\n| Server unreachable | Check firewall rules, ensure SSH port 22 is open |\n| Volume not visible | Use `--automount` or mount manually via SSH |"
              },
              {
                "name": "hcloud-go-sdk",
                "description": "Use when writing Go code to interact with Hetzner Cloud API - automation, infrastructure provisioning, bots, integrations, or programmatic cloud operations",
                "path": "hetzner/skills/hcloud-go-sdk/SKILL.md",
                "frontmatter": {
                  "name": "hcloud-go-sdk",
                  "description": "Use when writing Go code to interact with Hetzner Cloud API - automation, infrastructure provisioning, bots, integrations, or programmatic cloud operations"
                },
                "content": "# Hetzner Cloud Go SDK\n\n## Overview\n\nThe official Go SDK for Hetzner Cloud provides type-safe access to 23+ resource types with automatic retries, action polling, and comprehensive error handling. Use it for bots, automation, integrations, and complex workflows. For quick CLI operations, use `hetzner:hcloud-cli` instead.\n\n## Quick Setup\n\n```go\nimport \"github.com/hetznercloud/hcloud-go/v2/hcloud\"\n\n// Create client\nclient := hcloud.NewClient(hcloud.WithToken(\"your-api-token\"))\n```\n\n```bash\ngo get github.com/hetznercloud/hcloud-go/v2/hcloud\n```\n\n## Quick Reference\n\n| Task | Method |\n|------|--------|\n| **Servers** | |\n| List servers | `client.Server.All(ctx)` |\n| Get server | `client.Server.GetByID(ctx, 123)` or `GetByName(ctx, \"web\")` |\n| Create server | `client.Server.Create(ctx, hcloud.ServerCreateOpts{})` |\n| Delete server | `client.Server.Delete(ctx, server)` |\n| Reboot/Reset | `client.Server.Reboot(ctx, server)` / `Reset(ctx, server)` |\n| **Networks** | |\n| Create network | `client.Network.Create(ctx, hcloud.NetworkCreateOpts{})` |\n| Attach server | `client.Server.AttachToNetwork(ctx, server, opts)` |\n| **Volumes** | |\n| Create volume | `client.Volume.Create(ctx, hcloud.VolumeCreateOpts{})` |\n| Attach volume | `client.Volume.Attach(ctx, volume, server)` |\n| **Actions** | |\n| Wait for action | `client.Action.WaitFor(ctx, action)` |\n| Poll with callback | `client.Action.WaitForFunc(ctx, callback, action)` |\n\n## API Categories\n\nSee `references/api-reference.md` for complete method list:\n- Servers (create, lifecycle, networking)\n- Networks, subnets, routes\n- Volumes\n- Firewalls and rules\n- Load balancers, targets, services\n- Floating IPs, Primary IPs\n- SSH keys, images, certificates\n- DNS zones (GA in v2.30.0)\n- Storage boxes (experimental)\n\n## Client Configuration\n\n```go\nclient := hcloud.NewClient(\n    hcloud.WithToken(\"token\"),                    // Required\n    hcloud.WithEndpoint(\"https://api.hetzner.cloud/v1\"), // Custom endpoint\n    hcloud.WithApplication(\"myapp\", \"1.0.0\"),     // User-Agent\n    hcloud.WithDebugWriter(os.Stderr),            // Debug logging\n    hcloud.WithHTTPClient(customClient),          // Custom HTTP client\n    hcloud.WithRetryOpts(hcloud.RetryOpts{        // Retry config\n        MaxRetries: 5,\n        BackoffFunc: hcloud.ExponentialBackoff(2, time.Second),\n    }),\n    hcloud.WithPollOpts(hcloud.PollOpts{          // Action polling\n        BackoffFunc: hcloud.ConstantBackoff(500 * time.Millisecond),\n    }),\n)\n```\n\n## Common Patterns\n\nSee `references/patterns.md` for idiomatic patterns:\n- Error handling\n- Action polling\n- Pagination\n- Resource lookups\n\n## Action Handling\n\nAll long-running operations return an `Action`:\n\n```go\nresult, _, err := client.Server.Create(ctx, opts)\nif err != nil {\n    return err\n}\n\n// Wait for completion\nif err := client.Action.WaitFor(ctx, result.Action); err != nil {\n    return err\n}\n\n// Or with progress callback\nerr = client.Action.WaitForFunc(ctx,\n    func(update *hcloud.Action) error {\n        fmt.Printf(\"Progress: %.0f%%\\n\", update.Progress)\n        return nil\n    },\n    result.Action,\n)\n```\n\n## Error Handling\n\n```go\nimport \"github.com/hetznercloud/hcloud-go/v2/hcloud\"\n\nerr := someAPICall()\n\n// Check specific error codes\nif hcloud.IsError(err, hcloud.ErrorCodeNotFound) {\n    // Resource doesn't exist\n}\n\n// Get error details\nif apiErr, ok := err.(*hcloud.APIError); ok {\n    fmt.Printf(\"Error: %s - %s\\n\", apiErr.Code, apiErr.Message)\n}\n```\n\nCommon error codes:\n- `ErrorCodeNotFound` - Resource doesn't exist\n- `ErrorCodeInvalidInput` - Validation error\n- `ErrorCodeForbidden` - Insufficient permissions\n- `ErrorCodeRateLimitExceeded` - Rate limit hit (auto-retried)\n- `ErrorCodeConflict` - Resource changed (auto-retried)\n- `ErrorCodeLocked` - Another action running\n\n## Common Mistakes\n\n| Problem | Solution |\n|---------|----------|\n| Nil pointer panic | Always check error before using result |\n| Action timeout | Use `ctx, cancel := context.WithTimeout(...)` |\n| Missing pagination | Use `client.Server.All(ctx)` for complete list |\n| Action failed | Check action error with `WaitFor()` return value |\n| Rate limiting | SDK auto-retries, but add backoff for bulk ops |"
              }
            ]
          },
          {
            "name": "bazel",
            "description": "Skills for developing custom Bazel rules, toolchains, providers, and aspects",
            "source": "./bazel",
            "category": null,
            "version": "1.0.0",
            "author": {
              "name": "German Arutyunov"
            },
            "install_commands": [
              "/plugin marketplace add gaarutyunov/dev-skills",
              "/plugin install bazel@dev-skills"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-23T20:43:38Z",
              "created_at": "2025-12-19T01:26:08Z",
              "license": null
            },
            "commands": [],
            "skills": [
              {
                "name": "developing-bazel-rules",
                "description": "Use when creating custom Bazel rules, toolchains, providers, or aspects. Use when extending Bazel for new languages, build systems, or custom actions. Use when debugging Starlark rule implementations or understanding Bazel build phases.",
                "path": "bazel/skills/developing-bazel-rules/SKILL.md",
                "frontmatter": {
                  "name": "developing-bazel-rules",
                  "description": "Use when creating custom Bazel rules, toolchains, providers, or aspects. Use when extending Bazel for new languages, build systems, or custom actions. Use when debugging Starlark rule implementations or understanding Bazel build phases."
                },
                "content": "# Developing Bazel Rules\n\n## Overview\n\nBazel rules define how to transform inputs into outputs through actions. A rule has an implementation function executed during analysis phase that registers actions for execution phase.\n\n**Core principle:** Rules don't execute commands directly - they register actions that Bazel executes later based on dependency analysis.\n\n## When to Use\n\n- Creating rules for new languages or tools\n- Building custom toolchains\n- Implementing providers for dependency propagation\n- Creating aspects for cross-cutting concerns\n- Wrapping existing tools with Bazel\n\n## Build Phases\n\n| Phase | What Happens | Rule Author's Role |\n|-------|--------------|-------------------|\n| **Loading** | `BUILD` files evaluated, rules instantiated | Define rule with `rule()`, macros expand |\n| **Analysis** | Implementation functions run | Register actions, return providers |\n| **Execution** | Actions run (if needed) | Actions produce outputs |\n\n## Quick Start: Minimal Rule\n\n```python\n# my_rules.bzl\ndef _my_compile_impl(ctx):\n    output = ctx.actions.declare_file(ctx.label.name + \".out\")\n    ctx.actions.run(\n        mnemonic = \"MyCompile\",\n        executable = ctx.executable._compiler,\n        arguments = [\"-o\", output.path] + [f.path for f in ctx.files.srcs],\n        inputs = ctx.files.srcs,\n        outputs = [output],\n    )\n    return [DefaultInfo(files = depset([output]))]\n\nmy_compile = rule(\n    implementation = _my_compile_impl,\n    attrs = {\n        \"srcs\": attr.label_list(allow_files = True),\n        \"_compiler\": attr.label(\n            default = \"//tools:compiler\",\n            executable = True,\n            cfg = \"exec\",\n        ),\n    },\n)\n```\n\n## Core Concepts\n\n### Providers - Passing Data Between Rules\n\nProviders are the mechanism for rules to communicate:\n\n```python\nMyInfo = provider(\n    doc = \"Information from my_library targets\",\n    fields = {\n        \"files\": \"depset of output files\",\n        \"transitive_files\": \"depset of all transitive files\",\n    },\n)\n\ndef _impl(ctx):\n    # Collect from dependencies\n    transitive = [dep[MyInfo].transitive_files for dep in ctx.attr.deps]\n\n    # Return new provider\n    return [\n        DefaultInfo(files = depset([output])),\n        MyInfo(\n            files = depset([output]),\n            transitive_files = depset([output], transitive = transitive),\n        ),\n    ]\n```\n\n**Require providers in deps:**\n```python\n\"deps\": attr.label_list(providers = [MyInfo])\n```\n\n### Depsets - Efficient Transitive Collections\n\nUse depsets to avoid quadratic complexity:\n\n```python\n# GOOD: O(1) per target\ntransitive_srcs = depset(\n    direct = ctx.files.srcs,\n    transitive = [dep[MyInfo].srcs for dep in ctx.attr.deps],\n)\n\n# BAD: O(n) copying - becomes O(n^2) across graph\ntransitive_srcs = list(ctx.files.srcs)\nfor dep in ctx.attr.deps:\n    transitive_srcs.extend(dep[MyInfo].srcs.to_list())\n```\n\n**Only call `.to_list()` in binary rules, never in libraries.**\n\n### Actions - Registering Work\n\n```python\n# Run executable (preferred)\nctx.actions.run(\n    mnemonic = \"Compile\",\n    executable = ctx.executable._tool,\n    arguments = [args],\n    inputs = inputs,\n    outputs = [output],\n)\n\n# Use args builder for large inputs\nargs = ctx.actions.args()\nargs.add(\"-o\", output)\nargs.add_all(srcs)  # Deferred expansion - efficient!\n\n# Write file content\nctx.actions.write(output, content, is_executable = True)\n```\n\n### Attributes - Rule Parameters\n\n| Type | Use Case |\n|------|----------|\n| `attr.label_list` | File/target inputs (`srcs`, `deps`) |\n| `attr.label` | Single target (`_compiler`) |\n| `attr.string` | Config value (`importpath`) |\n| `attr.bool` | Toggle (`cgo = True`) |\n\n**Private attributes** (underscore prefix) for implicit deps:\n```python\n\"_stdlib\": attr.label(default = \"//go:stdlib\")\n```\n\n**cfg for tools:**\n```python\n\"_compiler\": attr.label(executable = True, cfg = \"exec\")\n```\n\n## Implementation Checklist\n\n1. Get toolchain (if using): `ctx.toolchains[\"//my:type\"]`\n2. Access inputs: `ctx.files.srcs`, `ctx.attr.deps`\n3. Declare outputs: `ctx.actions.declare_file()`\n4. Build depsets for transitive data\n5. Register actions: `ctx.actions.run()`\n6. Return providers: `[DefaultInfo(...), MyInfo(...)]`\n\n## Common Mistakes\n\n| Mistake | Fix |\n|---------|-----|\n| Flattening depsets in library | Keep as depset, flatten only in binary |\n| Missing `cfg = \"exec\"` for tools | Add `cfg = \"exec\"` to tool attributes |\n| Not returning DefaultInfo | Always return DefaultInfo with files |\n| Reading files in analysis | Files can only be read by actions |\n| Action without outputs | All actions must produce output files |\n\n## Reference Files\n\nSee `references/` for detailed guides:\n- `api-reference.md` - Starlark API quick reference\n- `providers.md` - Provider design patterns\n- `toolchains.md` - Toolchain development\n- `testing.md` - Testing Bazel rules\n- `go-patterns.md` - Patterns from rules_go"
              }
            ]
          }
        ]
      }
    }
  ]
}