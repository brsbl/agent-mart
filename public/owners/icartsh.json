{
  "owner": {
    "id": "icartsh",
    "display_name": "icartsh",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/5387321?v=4",
    "url": "https://github.com/icartsh",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 20,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "icartsh/icartsh_plugin",
      "url": "https://github.com/icartsh/icartsh_plugin",
      "description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-12-21T06:41:14Z",
        "created_at": "2025-12-07T10:23:00Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1721
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 208
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 8217
        },
        {
          "path": "icartsh-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 142
        },
        {
          "path": "icartsh-plugin/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/api-designer",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/api-designer/README.md",
          "type": "blob",
          "size": 2209
        },
        {
          "path": "icartsh-plugin/skills/api-designer/SKILL.md",
          "type": "blob",
          "size": 15148
        },
        {
          "path": "icartsh-plugin/skills/api-designer/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/api-designer/examples/graphql_schema.graphql",
          "type": "blob",
          "size": 8598
        },
        {
          "path": "icartsh-plugin/skills/api-designer/examples/openapi_spec.yaml",
          "type": "blob",
          "size": 18268
        },
        {
          "path": "icartsh-plugin/skills/api-designer/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/api-designer/references/authentication.md",
          "type": "blob",
          "size": 11544
        },
        {
          "path": "icartsh-plugin/skills/api-designer/references/common-patterns.md",
          "type": "blob",
          "size": 12401
        },
        {
          "path": "icartsh-plugin/skills/api-designer/references/rest_best_practices.md",
          "type": "blob",
          "size": 15720
        },
        {
          "path": "icartsh-plugin/skills/api-designer/references/versioning-strategies.md",
          "type": "blob",
          "size": 13958
        },
        {
          "path": "icartsh-plugin/skills/api-designer/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/api-designer/scripts/api_helper.py",
          "type": "blob",
          "size": 14040
        },
        {
          "path": "icartsh-plugin/skills/brainstorming",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/brainstorming/SKILL.md",
          "type": "blob",
          "size": 3490
        },
        {
          "path": "icartsh-plugin/skills/code-analyze",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/code-analyze/SKILL.md",
          "type": "blob",
          "size": 4971
        },
        {
          "path": "icartsh-plugin/skills/code-analyze/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/code-analyze/references/dependency-check.md",
          "type": "blob",
          "size": 6921
        },
        {
          "path": "icartsh-plugin/skills/code-analyze/references/security-scan.md",
          "type": "blob",
          "size": 2407
        },
        {
          "path": "icartsh-plugin/skills/code-analyze/references/static-analysis.md",
          "type": "blob",
          "size": 7431
        },
        {
          "path": "icartsh-plugin/skills/code-analyze/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/code-analyze/scripts/analyze.sh",
          "type": "blob",
          "size": 8256
        },
        {
          "path": "icartsh-plugin/skills/code-format",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/code-format/SKILL.md",
          "type": "blob",
          "size": 4699
        },
        {
          "path": "icartsh-plugin/skills/code-format/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/code-format/references/dotnet-format.md",
          "type": "blob",
          "size": 7199
        },
        {
          "path": "icartsh-plugin/skills/code-format/references/fix-all.md",
          "type": "blob",
          "size": 6240
        },
        {
          "path": "icartsh-plugin/skills/code-format/references/prettier-format.md",
          "type": "blob",
          "size": 6680
        },
        {
          "path": "icartsh-plugin/skills/code-format/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/code-format/scripts/format-all.sh",
          "type": "blob",
          "size": 8965
        },
        {
          "path": "icartsh-plugin/skills/code-reviewer",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/code-reviewer/README.md",
          "type": "blob",
          "size": 5616
        },
        {
          "path": "icartsh-plugin/skills/code-reviewer/SKILL.md",
          "type": "blob",
          "size": 13480
        },
        {
          "path": "icartsh-plugin/skills/code-reviewer/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/code-reviewer/examples/review_checklist.md",
          "type": "blob",
          "size": 10060
        },
        {
          "path": "icartsh-plugin/skills/code-reviewer/examples/security_patterns.md",
          "type": "blob",
          "size": 15008
        },
        {
          "path": "icartsh-plugin/skills/code-reviewer/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/code-reviewer/references/performance_guide.md",
          "type": "blob",
          "size": 13987
        },
        {
          "path": "icartsh-plugin/skills/code-reviewer/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/code-reviewer/scripts/review_helper.py",
          "type": "blob",
          "size": 13287
        },
        {
          "path": "icartsh-plugin/skills/coding-conventions",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/coding-conventions/SKILL.md",
          "type": "blob",
          "size": 18966
        },
        {
          "path": "icartsh-plugin/skills/csharp-async-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/csharp-async-patterns/SKILL.md",
          "type": "blob",
          "size": 24909
        },
        {
          "path": "icartsh-plugin/skills/csharp-developer",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/csharp-developer/SKILL.md",
          "type": "blob",
          "size": 8472
        },
        {
          "path": "icartsh-plugin/skills/docker-workflow",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/docker-workflow/README.md",
          "type": "blob",
          "size": 9336
        },
        {
          "path": "icartsh-plugin/skills/docker-workflow/SKILL.md",
          "type": "blob",
          "size": 10650
        },
        {
          "path": "icartsh-plugin/skills/docker-workflow/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/docker-workflow/examples/.dockerignore",
          "type": "blob",
          "size": 7768
        },
        {
          "path": "icartsh-plugin/skills/docker-workflow/examples/Dockerfile.multi-stage",
          "type": "blob",
          "size": 8829
        },
        {
          "path": "icartsh-plugin/skills/docker-workflow/examples/docker-compose.yml",
          "type": "blob",
          "size": 11364
        },
        {
          "path": "icartsh-plugin/skills/docker-workflow/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/docker-workflow/scripts/docker_helper.sh",
          "type": "blob",
          "size": 14198
        },
        {
          "path": "icartsh-plugin/skills/dotnet-build",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/dotnet-build/SKILL.md",
          "type": "blob",
          "size": 3806
        },
        {
          "path": "icartsh-plugin/skills/dotnet-build/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/dotnet-build/references/build-solution.md",
          "type": "blob",
          "size": 4933
        },
        {
          "path": "icartsh-plugin/skills/dotnet-build/references/restore-deps.md",
          "type": "blob",
          "size": 5618
        },
        {
          "path": "icartsh-plugin/skills/dotnet-build/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/dotnet-build/scripts/build-all.sh",
          "type": "blob",
          "size": 5712
        },
        {
          "path": "icartsh-plugin/skills/dotnet-test",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/dotnet-test/SKILL.md",
          "type": "blob",
          "size": 5287
        },
        {
          "path": "icartsh-plugin/skills/dotnet-test/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/dotnet-test/references/generate-coverage.md",
          "type": "blob",
          "size": 6957
        },
        {
          "path": "icartsh-plugin/skills/dotnet-test/references/run-benchmarks.md",
          "type": "blob",
          "size": 7085
        },
        {
          "path": "icartsh-plugin/skills/dotnet-test/references/run-unit-tests.md",
          "type": "blob",
          "size": 6656
        },
        {
          "path": "icartsh-plugin/skills/dotnet-test/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/dotnet-test/scripts/test-with-coverage.sh",
          "type": "blob",
          "size": 2136
        },
        {
          "path": "icartsh-plugin/skills/error-detective",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/error-detective/README.md",
          "type": "blob",
          "size": 4540
        },
        {
          "path": "icartsh-plugin/skills/error-detective/SKILL.md",
          "type": "blob",
          "size": 20271
        },
        {
          "path": "icartsh-plugin/skills/error-detective/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/error-detective/examples/common_errors.md",
          "type": "blob",
          "size": 18074
        },
        {
          "path": "icartsh-plugin/skills/error-detective/examples/debugging_workflow.md",
          "type": "blob",
          "size": 16103
        },
        {
          "path": "icartsh-plugin/skills/error-detective/examples/stack_traces.txt",
          "type": "blob",
          "size": 16127
        },
        {
          "path": "icartsh-plugin/skills/error-detective/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/error-detective/scripts/debug_helper.py",
          "type": "blob",
          "size": 21816
        },
        {
          "path": "icartsh-plugin/skills/file-organizer",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/file-organizer/SKILL.md",
          "type": "blob",
          "size": 13406
        },
        {
          "path": "icartsh-plugin/skills/frontend-design",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/frontend-design/LICENSE.txt",
          "type": "blob",
          "size": 10174
        },
        {
          "path": "icartsh-plugin/skills/frontend-design/SKILL.md",
          "type": "blob",
          "size": 6238
        },
        {
          "path": "icartsh-plugin/skills/git-advanced",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/git-advanced/README.md",
          "type": "blob",
          "size": 2473
        },
        {
          "path": "icartsh-plugin/skills/git-advanced/SKILL.md",
          "type": "blob",
          "size": 13628
        },
        {
          "path": "icartsh-plugin/skills/git-advanced/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/git-advanced/examples/branch_strategies.md",
          "type": "blob",
          "size": 14771
        },
        {
          "path": "icartsh-plugin/skills/git-advanced/examples/conflict_resolution.md",
          "type": "blob",
          "size": 12186
        },
        {
          "path": "icartsh-plugin/skills/git-advanced/examples/interactive_rebase.md",
          "type": "blob",
          "size": 8151
        },
        {
          "path": "icartsh-plugin/skills/git-advanced/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/git-advanced/references/best-practices.md",
          "type": "blob",
          "size": 9369
        },
        {
          "path": "icartsh-plugin/skills/git-advanced/references/branch-management.md",
          "type": "blob",
          "size": 4253
        },
        {
          "path": "icartsh-plugin/skills/git-advanced/references/reflog-recovery.md",
          "type": "blob",
          "size": 7166
        },
        {
          "path": "icartsh-plugin/skills/git-advanced/references/troubleshooting.md",
          "type": "blob",
          "size": 11325
        },
        {
          "path": "icartsh-plugin/skills/git-advanced/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/git-advanced/scripts/git_helper.sh",
          "type": "blob",
          "size": 12175
        },
        {
          "path": "icartsh-plugin/skills/markdown-pro",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/markdown-pro/README.md",
          "type": "blob",
          "size": 10380
        },
        {
          "path": "icartsh-plugin/skills/markdown-pro/SKILL.md",
          "type": "blob",
          "size": 11932
        },
        {
          "path": "icartsh-plugin/skills/markdown-pro/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/markdown-pro/examples/CHANGELOG_template.md",
          "type": "blob",
          "size": 7967
        },
        {
          "path": "icartsh-plugin/skills/markdown-pro/examples/CONTRIBUTING.md",
          "type": "blob",
          "size": 12444
        },
        {
          "path": "icartsh-plugin/skills/markdown-pro/examples/README_template.md",
          "type": "blob",
          "size": 9538
        },
        {
          "path": "icartsh-plugin/skills/markdown-pro/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/markdown-pro/scripts/markdown_helper.py",
          "type": "blob",
          "size": 9490
        },
        {
          "path": "icartsh-plugin/skills/mcp-builder",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/mcp-builder/LICENSE.txt",
          "type": "blob",
          "size": 11357
        },
        {
          "path": "icartsh-plugin/skills/mcp-builder/SKILL.md",
          "type": "blob",
          "size": 11013
        },
        {
          "path": "icartsh-plugin/skills/mcp-builder/reference",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/mcp-builder/reference/evaluation.md",
          "type": "blob",
          "size": 21663
        },
        {
          "path": "icartsh-plugin/skills/mcp-builder/reference/mcp_best_practices.md",
          "type": "blob",
          "size": 7330
        },
        {
          "path": "icartsh-plugin/skills/mcp-builder/reference/node_mcp_server.md",
          "type": "blob",
          "size": 28550
        },
        {
          "path": "icartsh-plugin/skills/mcp-builder/reference/python_mcp_server.md",
          "type": "blob",
          "size": 25099
        },
        {
          "path": "icartsh-plugin/skills/mcp-builder/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/mcp-builder/scripts/connections.py",
          "type": "blob",
          "size": 4875
        },
        {
          "path": "icartsh-plugin/skills/mcp-builder/scripts/evaluation.py",
          "type": "blob",
          "size": 12579
        },
        {
          "path": "icartsh-plugin/skills/mcp-builder/scripts/example_evaluation.xml",
          "type": "blob",
          "size": 1194
        },
        {
          "path": "icartsh-plugin/skills/mcp-builder/scripts/requirements.txt",
          "type": "blob",
          "size": 29
        },
        {
          "path": "icartsh-plugin/skills/sequential-thinking",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/sequential-thinking/.env.example",
          "type": "blob",
          "size": 308
        },
        {
          "path": "icartsh-plugin/skills/sequential-thinking/.gitignore",
          "type": "blob",
          "size": 180
        },
        {
          "path": "icartsh-plugin/skills/sequential-thinking/README.md",
          "type": "blob",
          "size": 6355
        },
        {
          "path": "icartsh-plugin/skills/sequential-thinking/SKILL.md",
          "type": "blob",
          "size": 3918
        },
        {
          "path": "icartsh-plugin/skills/sequential-thinking/package.json",
          "type": "blob",
          "size": 697
        },
        {
          "path": "icartsh-plugin/skills/sequential-thinking/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/sequential-thinking/references/advanced-strategies.md",
          "type": "blob",
          "size": 2587
        },
        {
          "path": "icartsh-plugin/skills/sequential-thinking/references/advanced-techniques.md",
          "type": "blob",
          "size": 2375
        },
        {
          "path": "icartsh-plugin/skills/sequential-thinking/references/core-patterns.md",
          "type": "blob",
          "size": 2553
        },
        {
          "path": "icartsh-plugin/skills/sequential-thinking/references/examples-api.md",
          "type": "blob",
          "size": 2210
        },
        {
          "path": "icartsh-plugin/skills/sequential-thinking/references/examples-architecture.md",
          "type": "blob",
          "size": 2704
        },
        {
          "path": "icartsh-plugin/skills/sequential-thinking/references/examples-debug.md",
          "type": "blob",
          "size": 2496
        },
        {
          "path": "icartsh-plugin/skills/sequential-thinking/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/sequential-thinking/scripts/format-thought.js",
          "type": "blob",
          "size": 4820
        },
        {
          "path": "icartsh-plugin/skills/sequential-thinking/scripts/process-thought.js",
          "type": "blob",
          "size": 6755
        },
        {
          "path": "icartsh-plugin/skills/sequential-thinking/tests",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/sequential-thinking/tests/format-thought.test.js",
          "type": "blob",
          "size": 3644
        },
        {
          "path": "icartsh-plugin/skills/sequential-thinking/tests/process-thought.test.js",
          "type": "blob",
          "size": 5698
        },
        {
          "path": "icartsh-plugin/skills/skill-creator",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/skill-creator/LICENSE.txt",
          "type": "blob",
          "size": 11357
        },
        {
          "path": "icartsh-plugin/skills/skill-creator/SKILL.md",
          "type": "blob",
          "size": 20920
        },
        {
          "path": "icartsh-plugin/skills/skill-creator/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/skill-creator/references/output-patterns.md",
          "type": "blob",
          "size": 1813
        },
        {
          "path": "icartsh-plugin/skills/skill-creator/references/workflows.md",
          "type": "blob",
          "size": 818
        },
        {
          "path": "icartsh-plugin/skills/skill-creator/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/skill-creator/scripts/init_skill.py",
          "type": "blob",
          "size": 10863
        },
        {
          "path": "icartsh-plugin/skills/skill-creator/scripts/package_skill.py",
          "type": "blob",
          "size": 3288
        },
        {
          "path": "icartsh-plugin/skills/skill-creator/scripts/quick_validate.py",
          "type": "blob",
          "size": 3523
        },
        {
          "path": "icartsh-plugin/skills/sql-expert",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/sql-expert/README.md",
          "type": "blob",
          "size": 12493
        },
        {
          "path": "icartsh-plugin/skills/sql-expert/SKILL.md",
          "type": "blob",
          "size": 15881
        },
        {
          "path": "icartsh-plugin/skills/sql-expert/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/sql-expert/examples/complex_queries.sql",
          "type": "blob",
          "size": 18990
        },
        {
          "path": "icartsh-plugin/skills/sql-expert/examples/migrations.sql",
          "type": "blob",
          "size": 21845
        },
        {
          "path": "icartsh-plugin/skills/sql-expert/examples/schema_examples.sql",
          "type": "blob",
          "size": 21532
        },
        {
          "path": "icartsh-plugin/skills/sql-expert/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/sql-expert/references/advanced-patterns.md",
          "type": "blob",
          "size": 7113
        },
        {
          "path": "icartsh-plugin/skills/sql-expert/references/best-practices.md",
          "type": "blob",
          "size": 8145
        },
        {
          "path": "icartsh-plugin/skills/sql-expert/references/common-pitfalls.md",
          "type": "blob",
          "size": 9667
        },
        {
          "path": "icartsh-plugin/skills/sql-expert/references/indexes-performance.md",
          "type": "blob",
          "size": 3217
        },
        {
          "path": "icartsh-plugin/skills/sql-expert/references/query-optimization.md",
          "type": "blob",
          "size": 3179
        },
        {
          "path": "icartsh-plugin/skills/sql-expert/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/sql-expert/scripts/sql_helper.py",
          "type": "blob",
          "size": 21025
        },
        {
          "path": "icartsh-plugin/skills/sql-optimization-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/sql-optimization-patterns/SKILL.md",
          "type": "blob",
          "size": 14846
        },
        {
          "path": "icartsh-plugin/skills/web-artifacts-builder",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/web-artifacts-builder/LICENSE.txt",
          "type": "blob",
          "size": 11357
        },
        {
          "path": "icartsh-plugin/skills/web-artifacts-builder/SKILL.md",
          "type": "blob",
          "size": 3774
        },
        {
          "path": "icartsh-plugin/skills/web-artifacts-builder/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/web-artifacts-builder/scripts/bundle-artifact.sh",
          "type": "blob",
          "size": 1517
        },
        {
          "path": "icartsh-plugin/skills/web-artifacts-builder/scripts/init-artifact.sh",
          "type": "blob",
          "size": 9924
        },
        {
          "path": "icartsh-plugin/skills/web-artifacts-builder/scripts/shadcn-components.tar.gz",
          "type": "blob",
          "size": 19967
        },
        {
          "path": "icartsh-plugin/skills/webapp-testing",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/webapp-testing/LICENSE.txt",
          "type": "blob",
          "size": 11357
        },
        {
          "path": "icartsh-plugin/skills/webapp-testing/SKILL.md",
          "type": "blob",
          "size": 4756
        },
        {
          "path": "icartsh-plugin/skills/webapp-testing/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/webapp-testing/examples/console_logging.py",
          "type": "blob",
          "size": 1027
        },
        {
          "path": "icartsh-plugin/skills/webapp-testing/examples/element_discovery.py",
          "type": "blob",
          "size": 1463
        },
        {
          "path": "icartsh-plugin/skills/webapp-testing/examples/static_html_automation.py",
          "type": "blob",
          "size": 953
        },
        {
          "path": "icartsh-plugin/skills/webapp-testing/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "icartsh-plugin/skills/webapp-testing/scripts/with_server.py",
          "type": "blob",
          "size": 3693
        }
      ],
      "marketplace": {
        "name": "icartsh-marketplace",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "ICARTSH"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "icartsh-plugin",
            "description": "ICARTSH Plugin",
            "source": "./icartsh-plugin",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add icartsh/icartsh_plugin",
              "/plugin install icartsh-plugin@icartsh-marketplace"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-21T06:41:14Z",
              "created_at": "2025-12-07T10:23:00Z",
              "license": null
            },
            "commands": [],
            "skills": [
              {
                "name": "api-designer",
                "description": "OpenAPI/Swagger 사양, 인증 패턴, 버전 관리 전략 및 모범 사례를 사용하여 RESTful 및 GraphQL API를 설계하고 문서화합니다. 사용 사례: (1) API 사양 생성, (2) REST 엔드포인트 설계, (3) GraphQL 스키마 설계, (4) API 인증 및 권한 부여, (5) API 버전 관리 전략, (6) 문서 생성",
                "path": "icartsh-plugin/skills/api-designer/SKILL.md",
                "frontmatter": {
                  "name": "api-designer",
                  "description": "OpenAPI/Swagger 사양, 인증 패턴, 버전 관리 전략 및 모범 사례를 사용하여 RESTful 및 GraphQL API를 설계하고 문서화합니다. 사용 사례: (1) API 사양 생성, (2) REST 엔드포인트 설계, (3) GraphQL 스키마 설계, (4) API 인증 및 권한 부여, (5) API 버전 관리 전략, (6) 문서 생성"
                },
                "content": "# API Designer\n\n## Overview\n\n이 SKILL은 현대적인 API를 설계, 문서화 및 구현하기 위한 포괄적인 가이드를 제공합니다. REST 및 GraphQL 패러다임을 모두 다루며, 업계의 모범 사례, 명확한 문서화 및 유지보수 가능한 아키텍처를 강조합니다. 확장 가능하고 안전하며 개발자 친화적인 Production-ready API 설계를 위해 이 SKILL을 사용하세요.\n\n## Core Capabilities\n\n### REST API Design\n- 적절한 URL 구조를 갖춘 리소스 지향 엔드포인트 설계\n- HTTP method 의미론 및 status code 사용\n- 일관된 명명 규칙을 적용한 Request/response payload 설계\n- Pagination, filtering 및 sorting 전략\n- Error handling 및 validation 패턴\n\n### GraphQL API Design\n- Type system 및 관계를 포함한 Schema 정의\n- 적절한 input type을 사용한 Query 및 mutation 설계\n- Resolver 패턴 및 성능 최적화\n- Fragment 사용 및 directive 구현\n- N+1 문제 방지 전략\n\n### API Documentation\n- OpenAPI 3.0 specification 생성\n- Swagger UI를 통한 대화형 문서화\n- Authentication 및 authorization 문서화\n- 다양한 시나리오를 포함한 Example requests/responses\n- 사양(Specification)으로부터 코드 생성\n\n### Authentication & Authorization\n- OAuth 2.0 flow (authorization code, client credentials, PKCE)\n- JWT token 설계, validation 및 rotation\n- API key 관리 및 rotation 전략\n- Role-based access control (RBAC) 구현\n- Rate limiting 및 throttling 패턴\n\n### API Versioning\n- URL versioning 및 header-based versioning 전략\n- API 릴리스를 위한 Semantic versioning\n- Deprecation 계획 및 커뮤니케이션\n- Backward compatibility 유지\n- Migration 경로 설계\n\n## When to Use This Skill\n\n이 SKILL은 다음과 같은 경우에 사용하세요:\n- 새로운 API를 처음부터 설계하거나 기존 엔드포인트를 리팩토링할 때\n- 문서화를 위해 OpenAPI/Swagger 사양을 생성할 때\n- Authentication 및 authorization flow를 구현할 때\n- API versioning 및 deprecation 전략을 계획할 때\n- GraphQL schema 및 resolver를 설계할 때\n- API governance 및 모범 사례를 확립할 때\n\n## REST API Design Workflow\n\n### Step 1: Identify Resources\n\nAPI가 노출할 핵심 리소스(Noun)를 식별합니다:\n\n```\nResources: Users, Posts, Comments\n\nCollections:\n- GET    /users              (모든 사용자 목록 조회)\n- POST   /users              (새 사용자 생성)\n\nIndividual Resources:\n- GET    /users/{id}         (특정 사용자 조회)\n- PUT    /users/{id}         (사용자 교체 - 전체 업데이트)\n- PATCH  /users/{id}         (사용자 업데이트 - 일부 업데이트)\n- DELETE /users/{id}         (사용자 삭제)\n\nNested Resources:\n- GET    /users/{id}/posts   (사용자의 포스트 조회)\n- POST   /users/{id}/posts   (사용자를 위한 포스트 생성)\n```\n\n### Step 2: Design URL Structure\n\nRESTful 명명 규칙을 따릅니다:\n\n**Best Practices**:\n- 복수형 명사 사용: `/users`, `/posts` (`/user`, `/post` 아님)\n- 여러 단어는 하이픈 사용: `/blog-posts` (`/blogPosts` 또는 `/blog_posts` 아님)\n- URL은 소문자로 유지\n- Nesting은 최대 2단계로 제한\n- Filtering을 위해 query parameter 사용: `/posts?status=published&author=123`\n\n**Quick Examples**:\n```\n✅ Good:\nGET /users\nGET /users/123/posts\nGET /posts?published=true&limit=10\n\n❌ Bad:\nGET /getUsers\nGET /users/123/posts/comments/likes  (너무 깊은 nesting)\nGET /posts/published  (대신 query param 사용)\n```\n\n### Step 3: Choose HTTP Methods\n\n작업을 표준 HTTP method에 매핑합니다:\n\n- **GET**: 리소스 조회 - Safe, idempotent, cacheable\n- **POST**: 새 리소스 생성 - Location header와 함께 201 Created 반환\n- **PUT**: 전체 리소스 교체 - Idempotent, 전체 교체\n- **PATCH**: 부분 업데이트 - 특정 필드만 업데이트\n- **DELETE**: 리소스 제거 - Idempotent, 204 또는 200 반환\n\n### Step 4: Design Request/Response Payloads\n\nJSON payload를 일관되게 구성합니다:\n\n**Naming Conventions**:\n- JSON 필드 이름에 camelCase 사용\n- 타임스탬프에 ISO 8601 사용 (UTC)\n- 접두사가 있는 일관된 ID 형식 사용: `usr_`, `post_`\n- 메타데이터 포함: `createdAt`, `updatedAt`\n\n**Example Response**:\n```json\n{\n  \"id\": \"usr_1234567890\",\n  \"username\": \"johndoe\",\n  \"email\": \"john@example.com\",\n  \"profile\": {\n    \"firstName\": \"John\",\n    \"lastName\": \"Doe\"\n  },\n  \"createdAt\": \"2025-10-25T10:30:00Z\",\n  \"updatedAt\": \"2025-10-25T10:30:00Z\"\n}\n```\n\n### Step 5: Implement Error Handling\n\n포괄적인 에러 응답을 설계합니다:\n\n**Error Response Format**:\n```json\n{\n  \"error\": {\n    \"code\": \"VALIDATION_ERROR\",\n    \"message\": \"Invalid request parameters\",\n    \"details\": [\n      {\n        \"field\": \"email\",\n        \"message\": \"Email format is invalid\"\n      }\n    ],\n    \"requestId\": \"req_abc123xyz\",\n    \"timestamp\": \"2025-10-25T10:30:00Z\"\n  }\n}\n```\n\n**Key Status Codes**:\n- `200 OK`: 성공적인 GET, PUT, PATCH\n- `201 Created`: 성공적인 POST\n- `204 No Content`: 성공적인 DELETE\n- `400 Bad Request`: 유효하지 않은 요청 데이터\n- `401 Unauthorized`: 인증 정보 누락/유효하지 않음\n- `403 Forbidden`: 인증되었으나 권한 없음\n- `404 Not Found`: 리소스가 존재하지 않음\n- `422 Unprocessable Entity`: Validation 에러\n- `429 Too Many Requests`: Rate limit 초과\n- `500 Internal Server Error`: 서버 에러\n\n### Step 6: Add Pagination and Filtering\n\n**Cursor-Based Pagination** (대규모 데이터셋에 권장):\n```\nGET /posts?limit=20&cursor=eyJpZCI6MTIzfQ\n\nResponse:\n{\n  \"data\": [...],\n  \"pagination\": {\n    \"nextCursor\": \"eyJpZCI6MTQzfQ\",\n    \"hasMore\": true\n  }\n}\n```\n\n**Offset-Based Pagination** (소규모 데이터셋에 적합):\n```\nGET /posts?limit=20&offset=40&sort=-createdAt\n\nResponse:\n{\n  \"data\": [...],\n  \"pagination\": {\n    \"total\": 500,\n    \"limit\": 20,\n    \"offset\": 40\n  }\n}\n```\n\n상세한 Pagination 전략 및 filtering 패턴은 `references/rest_best_practices.md`를 참조하세요.\n\n## GraphQL API Design Workflow\n\n### Step 1: Define Schema Types\n\n도메인을 위한 type definition을 생성합니다:\n\n```graphql\ntype User {\n  id: ID!\n  username: String!\n  email: String!\n  profile: Profile\n  posts(limit: Int = 10): [Post!]!\n  createdAt: DateTime!\n}\n\ntype Post {\n  id: ID!\n  title: String!\n  content: String!\n  published: Boolean!\n  author: User!\n  tags: [String!]!\n  createdAt: DateTime!\n}\n```\n\n### Step 2: Design Queries\n\nFiltering을 포함한 조회 작업을 정의합니다:\n\n```graphql\ntype Query {\n  user(id: ID!): User\n  post(id: ID!): Post\n\n  users(\n    limit: Int = 10\n    offset: Int = 0\n    search: String\n  ): UserConnection!\n\n  posts(\n    limit: Int = 10\n    published: Boolean\n    authorId: ID\n    tags: [String!]\n  ): PostConnection!\n}\n```\n\n### Step 3: Design Mutations\n\nInput type 및 error handling을 포함한 쓰기 작업을 정의합니다:\n\n```graphql\ntype Mutation {\n  createUser(input: CreateUserInput!): CreateUserPayload!\n  updateUser(id: ID!, input: UpdateUserInput!): UpdateUserPayload!\n  createPost(input: CreatePostInput!): CreatePostPayload!\n}\n\ninput CreateUserInput {\n  username: String!\n  email: String!\n  password: String!\n}\n\ntype CreateUserPayload {\n  user: User\n  errors: [Error!]\n}\n```\n\n전체 GraphQL schema 예시는 `examples/graphql_schema.graphql`을 참조하세요.\n\n## Authentication Patterns\n\n### OAuth 2.0 Quick Reference\n\n**Authorization Code Flow** (백엔드가 있는 웹 앱):\n```\n1. client_id, redirect_uri, scope와 함께 /oauth/authorize로 리다이렉트\n2. 사용자가 인증하고 권한 부여\n3. 리다이렉트를 통해 authorization code 수신\n4. /oauth/token에서 코드를 access token으로 교환\n5. Authorization header에 access token 사용\n```\n\n**Client Credentials Flow** (서비스 간 통신):\n```\nPOST /oauth/token\n{\n  \"grant_type\": \"client_credentials\",\n  \"client_id\": \"CLIENT_ID\",\n  \"client_secret\": \"SECRET\"\n}\n```\n\n**PKCE Flow** (모바일/SPA - 퍼블릭 클라이언트에 가장 안전):\n```\n1. code_verifier 및 code_challenge 생성\n2. code_challenge와 함께 권한 요청\n3. code_verifier로 코드를 토큰으로 교환 (client_secret 불필요)\n```\n\n### JWT Token Design\n\n**Token Structure**:\n```json\n{\n  \"header\": { \"alg\": \"RS256\", \"typ\": \"JWT\" },\n  \"payload\": {\n    \"sub\": \"usr_1234567890\",\n    \"iat\": 1698336000,\n    \"exp\": 1698339600,\n    \"scope\": [\"read:posts\", \"write:posts\"],\n    \"roles\": [\"user\", \"editor\"]\n  }\n}\n```\n\n**Usage**:\n```http\nAuthorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...\n```\n\n### API Key Authentication\n\n```http\nX-API-Key: sk_live_abcdef1234567890\n```\n\n**Best Practices**:\n- 환경별(dev, staging, prod)로 다른 키 사용\n- 로테이션을 위해 계정당 여러 키 지원\n- Key expiration 및 사용 로그 구현\n- 클라이언트 측 코드에 키를 노출하지 않음\n\nRefresh token, MFA 및 보안 모범 사례를 포함한 종합적인 인증 패턴은 `references/authentication.md`를 참조하세요.\n\n## API Versioning Strategies\n\n### URL Versioning (권장)\n\n```\n/v1/users\n/v2/users\n```\n\n**장점**: 명확하고 명시적이며, 캐싱 및 라우팅이 쉬움\n**단점**: URL 확산, 여러 코드베이스 관리\n\n### Header Versioning\n\n```http\nAccept: application/vnd.myapi.v2+json\nAPI-Version: 2\n```\n\n**장점**: 깔끔한 URL, 동일한 엔드포인트 유지\n**단점**: 덜 가시적이며, 브라우저에서 테스트하기 어려움\n\n### When to Version\n\n**새로운 버전이 필요한 경우**:\n- 엔드포인트 또는 필드 삭제\n- 필드 유형 또는 이름 변경\n- 인증 방법 수정\n- 기존 클라이언트 계약(Contract) 위반\n\n**버전 관리가 필요 없는 경우**:\n- 새로운 선택적(Optional) 필드 추가\n- 새로운 엔드포인트 추가\n- 버그 수정 또는 성능 향상\n\n상세한 Versioning 전략, deprecation 프로세스 및 migration 패턴은 `references/versioning-strategies.md`를 참조하세요.\n\n## OpenAPI Specification\n\n### Basic Structure\n\n```yaml\nopenapi: 3.0.0\ninfo:\n  title: My API\n  version: 1.0.0\n  description: API description\n\nservers:\n  - url: https://api.example.com/v1\n\npaths:\n  /users:\n    get:\n      summary: List users\n      parameters:\n        - name: limit\n          in: query\n          schema:\n            type: integer\n            default: 10\n      responses:\n        '200':\n          description: Successful response\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/UserList'\n\ncomponents:\n  schemas:\n    User:\n      type: object\n      required:\n        - username\n        - email\n      properties:\n        id:\n          type: string\n        username:\n          type: string\n        email:\n          type: string\n          format: email\n```\n\n전체 OpenAPI 사양 예시는 `examples/openapi_spec.yaml`을 참조하세요.\n\n### Generating Documentation\n\nHelper script를 사용하여 사양을 생성하고 검증합니다:\n\n```bash\n# 코드에서 OpenAPI 사양 생성\npython scripts/api_helper.py generate --input api.py --output openapi.yaml\n\n# 기존 사양 검증\npython scripts/api_helper.py validate --spec openapi.yaml\n\n# 문서 사이트 생성\npython scripts/api_helper.py docs --spec openapi.yaml --output docs/\n```\n\n## Best Practices Summary\n\n### Consistency\n- 모든 엔드포인트에서 일관된 명명 규칙 사용\n- 에러 응답 형식 표준화\n- 모든 곳에 동일한 인증 패턴 적용\n- 통일된 타임스탬프 형식 사용 (ISO 8601 with UTC)\n\n### Security\n- Production에서는 항상 HTTPS 사용\n- 모든 입력 데이터를 철저히 검증\n- 사용자/키/IP별로 Rate limiting 구현\n- 모든 엔드포인트에 적절한 인증 사용\n- URL이나 로그에 민감한 데이터를 노출하지 않음\n- 적절한 CORS 구성 구현\n\n### Performance\n- 대규모 데이터셋에 Pagination 사용\n- 캐싱 헤더(ETag, Cache-Control) 구현\n- 압축(gzip) 지원\n- 실시간 데이터에 Cursor-based pagination 사용\n- Sparse fieldsets을 위한 필드 선택(Field selection) 구현\n\n### Documentation\n- 모든 엔드포인트를 OpenAPI로 문서화\n- Example requests 및 responses 제공\n- 에러 코드 및 의미 문서화\n- 인증 안내 포함\n- 문서를 코드와 동기화된 상태로 유지\n\n### Maintainability\n- 명확한 deprecation 일정을 가지고 적절하게 API 버전 관리\n- 기능을 제거하기 전에 deprecation 경고 제공\n- 모든 엔드포인트에 대해 통합 테스트 작성\n- API 사용량, 에러 및 성능 모니터링\n- 가능한 경우 Backward compatibility 유지\n\n## Common Patterns\n\n### Health Check\n```http\nGET /health\nResponse: { \"status\": \"ok\", \"timestamp\": \"2025-10-25T10:30:00Z\" }\n```\n\n### Batch Operations\n```http\nPOST /users/batch\n{\n  \"operations\": [\n    { \"method\": \"POST\", \"path\": \"/users\", \"body\": {...} },\n    { \"method\": \"PATCH\", \"path\": \"/users/123\", \"body\": {...} }\n  ]\n}\n```\n\n### Webhooks\n```http\nPOST /webhooks/configure\n{\n  \"url\": \"https://your-app.com/webhook\",\n  \"events\": [\"user.created\", \"post.published\"],\n  \"secret\": \"webhook_secret_key\"\n}\n```\n\nIdempotency, long-running operations, file uploads 및 soft deletes를 포함한 추가 패턴은 `references/common-patterns.md`를 참조하세요.\n\n## Quick Reference Checklists\n\n### REST Endpoint Design\n- [ ] 컬렉션에 복수형 명사 사용\n- [ ] URL nesting을 2단계로 제한\n- [ ] 적절한 HTTP method 사용\n- [ ] 정확한 status code 반환\n- [ ] 일관된 에러 형식 구현\n- [ ] 컬렉션에 Pagination 추가\n- [ ] Filtering 및 sorting 포함\n- [ ] OpenAPI로 문서화\n- [ ] Authentication 구현\n- [ ] Rate limiting 추가\n\n### GraphQL Schema Design\n- [ ] 명확한 type hierarchy 정의\n- [ ] Nullable type을 적절하게 사용\n- [ ] Pagination(connections) 구현\n- [ ] Input type을 사용한 mutation 설계\n- [ ] Payload에 에러 반환\n- [ ] 설명(Description)으로 스키마 문서화\n- [ ] Authentication/authorization 구현\n- [ ] N+1 쿼리 최적화 (DataLoader)\n\n## Additional Resources\n\n### Comprehensive References\n- `references/rest_best_practices.md` - 전체 REST API 패턴, status code 및 구현 세부 정보\n- `references/authentication.md` - OAuth 2.0, JWT, API keys, MFA 및 보안 모범 사례\n- `references/versioning-strategies.md` - Versioning 접근 방식, deprecation 및 migration 전략\n- `references/common-patterns.md` - Health check, webhooks, batch operations 등\n\n### Examples\n- `examples/openapi_spec.yaml` - 블로그 API를 위한 전체 OpenAPI 3.0 사양\n- `examples/graphql_schema.graphql` - Query, mutation 및 subscription을 포함한 전체 GraphQL schema\n\n### Tools\n- `scripts/api_helper.py` - API 사양 생성, 검증 및 문서화 유틸리티"
              },
              {
                "name": "brainstorming",
                "description": "코드나 구현 계획을 작성하기 전, 무언가를 생성하거나 개발할 때 사용합니다. 협력적인 질문, 대안 탐색 및 점진적 검증을 통해 거친 아이디어를 구체화된 설계로 발전시킵니다. 명확한 'Mechanical' 프로세스 중에는 사용하지 마십시오.",
                "path": "icartsh-plugin/skills/brainstorming/SKILL.md",
                "frontmatter": {
                  "name": "brainstorming",
                  "description": "코드나 구현 계획을 작성하기 전, 무언가를 생성하거나 개발할 때 사용합니다. 협력적인 질문, 대안 탐색 및 점진적 검증을 통해 거친 아이디어를 구체화된 설계로 발전시킵니다. 명확한 'Mechanical' 프로세스 중에는 사용하지 마십시오."
                },
                "content": "# 아이디어를 설계로 브레인스토밍하기 (Brainstorming Ideas Into Designs)\n\n## Overview\n\n자연스러운 협업 대화를 통해 아이디어를 구체화된 설계와 사양(Spec)으로 바꾸도록 돕습니다.\n\n먼저 현재 프로젝트 context를 이해한 다음, 아이디어를 다듬기 위해 질문을 하나씩 던집니다. 무엇을 구축하려는지 이해했다면 설계를 작은 섹션(200-300자)으로 나누어 제시하고, 각 섹션이 끝날 때마다 지금까지의 내용이 맞는지 확인합니다.\n\n## The Process\n\n**아이디어 이해하기(Understanding the idea):**\n- 먼저 현재 프로젝트 상태를 확인합니다(파일, 문서, 최근 커밋).\n- 아이디어를 다듬기 위해 질문을 한 번에 하나씩 합니다.\n- 가능한 경우 객관식 질문을 선호하지만, 주관식 질문도 괜찮습니다.\n- 메시지 당 하나의 질문만 합니다. 한 주제에 더 많은 탐색이 필요하면 여러 질문으로 나눕니다.\n- 이해에 집중합니다: 목적, 제약 조건, 성공 기준.\n\n**접근 방식 탐색하기(Exploring approaches):**\n- 트레이드오프가 있는 2-3가지의 서로 다른 접근 방식을 제안합니다.\n- 권장 사항과 그 이유를 포함하여 대화 형식으로 옵션을 제시합니다.\n- 권장하는 옵션을 먼저 제시하고 그 이유를 설명합니다.\n\n**설계 제시하기(Presenting the design):**\n- 무엇을 구축할지 이해했다고 판단되면 설계를 제시합니다.\n- 설계를 200-300자 정도의 섹션으로 나눕니다.\n- 각 섹션이 끝날 때마다 지금까지의 내용이 맞는지 확인합니다.\n- 내용: 아키텍처, 컴포넌트, 데이터 흐름, 에러 핸들링, 테스트.\n- 이해가 되지 않는 부분이 있다면 다시 돌아가 명확하게 설명할 준비를 합니다.\n\n## After the Design\n\n**문서화(Documentation):**\n- 검증된 설계를 `docs/plans/YYYY-MM-DD-<topic>-design.md`에 작성합니다.\n- 사용 가능한 경우 `elements-of-style:writing-clearly-and-concisely` SKILL을 사용합니다.\n- 설계 문서를 git에 커밋합니다.\n\n**구현(Implementation - 계속 진행하는 경우):**\n- \"구현을 위한 설정을 시작할까요?\"라고 물어봅니다.\n- `superpowers:using-git-worktrees`를 사용하여 격리된 workspace를 생성합니다.\n- `superpowers:writing-plans`를 사용하여 상세한 구현 계획을 작성합니다.\n\n## Key Principles\n\n- **질문은 한 번에 하나씩 (One question at a time)** - 여러 질문으로 부담을 주지 마십시오.\n- **객관식 선호 (Multiple choice preferred)** - 가능하면 주관식보다 대답하기 쉽습니다.\n- **철저한 YAGNI (YAGNI ruthlessly)** - 모든 설계에서 불필요한 기능은 제거합니다.\n- **대안 탐색 (Explore alternatives)** - 결정하기 전에 항상 2-3가지 접근 방식을 제안합니다.\n- **점진적 검증 (Incremental validation)** - 설계를 섹션별로 제시하고 각 섹션을 검증합니다.\n- **유연성 유지 (Be flexible)** - 이해가 되지 않을 때는 다시 돌아가서 명확히 합니다."
              },
              {
                "name": "code-analyze",
                "description": ".NET 코드에서 정적 분석(Static analysis), 보안 스캔(Security scan) 및 종속성 체크(Dependency check)를 수행합니다. 코드 품질, 보안 감사 또는 취약점 탐지가 포함된 작업에서 사용합니다.",
                "path": "icartsh-plugin/skills/code-analyze/SKILL.md",
                "frontmatter": {
                  "name": "code-analyze",
                  "version": "0.1.0",
                  "kind": "cli",
                  "description": ".NET 코드에서 정적 분석(Static analysis), 보안 스캔(Security scan) 및 종속성 체크(Dependency check)를 수행합니다. 코드 품질, 보안 감사 또는 취약점 탐지가 포함된 작업에서 사용합니다.",
                  "inputs": {
                    "analysis_type": [
                      "static",
                      "security",
                      "dependencies",
                      "all"
                    ],
                    "project_path": "string",
                    "severity_filter": [
                      "error",
                      "warning",
                      "suggestion",
                      "all"
                    ]
                  },
                  "contracts": {
                    "success": "분석이 결과 보고서와 함께 완료됨; exit code 0",
                    "failure": "Non-zero exit code 또는 도구 실행 에러"
                  }
                },
                "content": "# Code Analysis Skill (Entry Map)\n\n> **Goal:** 에이전트가 필요한 분석 절차를 정확하게 찾을 수 있도록 가이드합니다.\n\n## Quick Start (하나를 선택하세요)\n\n- **Static code analysis 실행** → `references/static-analysis.md`\n- **보안 이슈 스캔 (Scan for security issues)** → `references/security-scan.md`\n- **종속성 취약점 체크 (Check dependency vulnerabilities)** → `references/dependency-check.md`\n\n## When to Use\n\n- 코드 품질 표준 및 모범 사례 시행\n- 잠재적인 버그 및 code smell 탐지\n- 코드 내 보안 취약점 식별\n- 취약한 종속성(Dependency) 확인\n- 자동화된 코드 리뷰 실행\n\n**다음을 위한 것이 아님:** 빌드 (dotnet-build), 테스트 (dotnet-test), 또는 포맷팅 (code-format)\n\n## Inputs & Outputs\n\n**Inputs:** `analysis_type` (static/security/dependencies/all), `project_path` (default: ./dotnet/PigeonPea.sln), `severity_filter` (error/warning/suggestion)\n\n**Outputs:** `analysis_report` (파일/라인이 포함된 결과), `exit_code` (0=clean, 1=issues), `metrics` (심각도별 위반 사항)\n\n**Guardrails:** 분석만 수행하며 코드를 절대 수정하지 마십시오. 모든 결과를 컨텍스트와 함께 보고하고 심각한 이슈 발생 시 실패로 처리합니다.\n\n## Navigation\n\n**1. Static Code Analysis** → [`references/static-analysis.md`](references/static-analysis.md)\n\n- Roslyn analyzers, StyleCop, 코드 품질 규칙, 모범 사례\n\n**2. Security Scanning** → [`references/security-scan.md`](references/security-scan.md)\n\n- Secret 탐지 (gitleaks, detect-secrets), 보안 analyzers, 취약점 패턴\n\n**3. Dependency Vulnerability Check** → [`references/dependency-check.md`](references/dependency-check.md)\n\n- NuGet 패키지 취약점, 오래된 종속성, CVE 탐지\n\n## Common Patterns\n\n### Quick Analysis (모든 체크 수행)\n\n```bash\ncd ./dotnet\ndotnet build PigeonPea.sln /p:TreatWarningsAsErrors=true\ndotnet list package --vulnerable\n```\n\n### Static Analysis 전용\n\n```bash\ncd ./dotnet\ndotnet build PigeonPea.sln /p:RunAnalyzers=true /warnaserror\n```\n\n### Security Scan (커밋 전)\n\n```bash\npre-commit run gitleaks --all-files\npre-commit run detect-secrets --all-files\n```\n\n### Dependency Check\n\n```bash\ncd ./dotnet\ndotnet list package --vulnerable --include-transitive\ndotnet list package --outdated\n```\n\n### Full Analysis Suite\n\n```bash\n# 저장소 루트에서 실행\n.agent/skills/code-analyze/scripts/analyze.sh --all\n```\n\n### 특정 심각도(Severity)를 포함한 분석\n\n```bash\ncd ./dotnet\n# 에러 전용\ndotnet build PigeonPea.sln /p:TreatWarningsAsErrors=false\n\n# 경고를 에러로 처리\ndotnet build PigeonPea.sln /p:TreatWarningsAsErrors=true\n```\n\n## Troubleshooting\n\n**Analyzer를 찾을 수 없음:** Roslyn analyzers가 활성화되어 있는지 확인하십시오. `references/static-analysis.md`를 참조하세요.\n\n**경고가 너무 많음:** Severity별로 필터링하거나 suppression을 추가하십시오. `references/static-analysis.md`를 참조하세요.\n\n**False positives:** `.editorconfig` 또는 suppression을 사용하십시오. `references/static-analysis.md`를 참조하세요.\n\n**Secret이 탐지되지 않음:** `.gitleaksignore` 및 `.secrets.baseline`을 확인하십시오. `references/security-scan.md`를 참조하세요.\n\n**Dependency scan 실패:** 네트워크 문제 또는 패키지 복원(Restore)이 필요할 수 있습니다. `references/dependency-check.md`를 참조하세요.\n\n## Success Indicators\n\n**Static Analysis:**\n\n```\nBuild succeeded.\n    0 Warning(s)\n    0 Error(s)\n```\n\n**Security Scan:**\n\n```\ngitleaks................Passed\ndetect-secrets...........Passed\n```\n\n**Dependency Check:**\n\n```\nNo vulnerable packages found.\n```\n\n## Integration\n\n**커밋 전:** 보안 스캔(gitleaks, detect-secrets) 실행\n**빌드 후:** 정적 분석(Roslyn, StyleCop) 실행\n**정기 체크:** 종속성 취약점 체크 실행\n\n**CI/CD Integration:** 빌드 파이프라인에 모든 분석을 포함하고 심각한 이슈 발생 시 실패 처리\n\n## Related\n\n- [`./dotnet/ARCHITECTURE.md`](../../../dotnet/ARCHITECTURE.md) - 프로젝트 구조\n- [`.pre-commit-config.yaml`](../../../.pre-commit-config.yaml) - Pre-commit hooks\n- [`.editorconfig`](../../../.editorconfig) - 코드 스타일 규칙\n- [`dotnet-build`](../dotnet-build/SKILL.md) - 빌드 SKILL"
              },
              {
                "name": "code-format",
                "description": "dotnet format, prettier 및 기타 포맷팅 도구를 사용하여 코드를 정리합니다. 코드 스타일 수정, 포맷 일관성 유지 또는 커밋 전 코드 준비가 필요한 작업에서 사용합니다.",
                "path": "icartsh-plugin/skills/code-format/SKILL.md",
                "frontmatter": {
                  "name": "code-format",
                  "version": "0.1.0",
                  "kind": "cli",
                  "description": "dotnet format, prettier 및 기타 포맷팅 도구를 사용하여 코드를 정리합니다. 코드 스타일 수정, 포맷 일관성 유지 또는 커밋 전 코드 준비가 필요한 작업에서 사용합니다.",
                  "inputs": {
                    "target": [
                      "dotnet",
                      "prettier",
                      "all"
                    ],
                    "files": "string[]",
                    "verify": "boolean"
                  },
                  "contracts": {
                    "success": "코드가 성공적으로 포맷팅됨; 남은 스타일 위반 사항 없음",
                    "failure": "Non-zero exit code 또는 포맷팅 에러"
                  }
                },
                "content": "# Code Format Skill (Entry Map)\n\n> **Goal:** 에이전트가 필요한 정확한 포맷팅 절차를 찾을 수 있도록 가이드합니다.\n\n## Quick Start (하나를 선택하세요)\n\n- **.NET 코드 포맷팅 (C#)** → `references/dotnet-format.md`\n- **JSON/YAML/Markdown 포맷팅** → `references/prettier-format.md`\n- **모든 항목 포맷팅** → `references/fix-all.md`\n\n## When to Use\n\n- 코드 스타일 위반 수정 (들여쓰기, 공백, 줄 바꿈 등)\n- .editorconfig 규칙을 일관되게 적용\n- 커밋을 위한 코드 준비 (pre-commit hook 포맷팅)\n- 팀 코딩 표준 준수\n- 특정 파일 또는 전체 코드베이스 포맷팅\n\n**다음을 위한 것이 아님:** 빌드 (dotnet-build), 테스트 (dotnet-test), 또는 린팅 (code-analyze)\n\n## Inputs & Outputs\n\n**Inputs:** `target` (dotnet/prettier/all), `files` (특정 파일 또는 디렉토리), `verify` (체크 전용 모드)\n\n**Outputs:** 포맷팅된 파일 (파일 내에서 직접 수정), exit code (0=success, non-zero=violations)\n\n**Guardrails:** 비파괴적 방식 (변경 없이 확인하는 --verify-no-changes 가능), .editorconfig 존중, pre-commit과 통합\n\n## Navigation\n\n**1. Format .NET Code** → [`references/dotnet-format.md`](references/dotnet-format.md)\n\n- C# 파일(.cs) 포맷팅, dotnet format 규칙 적용, 코드 스타일 이슈 수정\n\n**2. Format with Prettier** → [`references/prettier-format.md`](references/prettier-format.md)\n\n- JSON, YAML, Markdown, JavaScript, TypeScript 파일 포맷팅\n\n**3. Format All Code** → [`references/fix-all.md`](references/fix-all.md)\n\n- 모든 포맷터(dotnet + prettier)를 순차적으로 실행, 포괄적인 포맷팅 수행\n\n## Common Patterns\n\n### Quick Format (.NET)\n\n```bash\ncd ./dotnet\ndotnet format PigeonPea.sln\n```\n\n### Quick Format (Prettier)\n\n```bash\nnpx prettier --write \"**/*.{json,yml,yaml,md}\"\n```\n\n### Format Everything\n\n```bash\n./.agent/skills/code-format/scripts/format-all.sh\n```\n\n### Verify Only (체크 모드)\n\n```bash\ncd ./dotnet\ndotnet format PigeonPea.sln --verify-no-changes\n```\n\n### 특정 파일 포맷팅\n\n```bash\n# .NET\ndotnet format --include ./console-app/Program.cs\n\n# Prettier\nnpx prettier --write ./README.md\n```\n\n## Troubleshooting\n\n**포맷팅 실패:** 에러 메시지를 확인하십시오. 상세한 에러 처리는 관련 참조 파일을 확인하세요.\n\n**파일이 포맷팅되지 않음:** .editorconfig 규칙, 파일 확장자, ignore 패턴을 확인하십시오.\n\n**Pre-commit hook 실패:** 먼저 포맷터를 수동으로 실행한 후 커밋하십시오. `references/fix-all.md`를 참조하세요.\n\n**스타일 충돌:** .editorconfig가 우선순위를 가집니다. 구성 파일을 확인하십시오.\n\n**성능 이슈:** 전체 솔루션 대신 특정 프로젝트나 파일에 대해 포맷팅을 수행하십시오.\n\n## Success Indicators\n\n### dotnet format\n\n```\nFormat complete in X ms.\n```\n\n이미 포맷팅된 경우 변경된 파일이 없거나, 포맷팅된 파일 목록이 표시됩니다.\n\n### prettier\n\n```\n✔ Formatted X files\n```\n\n또는 모든 파일이 이미 포맷팅된 경우 출력이 없습니다.\n\n## Integration\n\n**커밋 전:** pre-commit hook을 사용하여 자동 포맷팅(`.pre-commit-config.yaml`에 구성됨)\n**수동 포맷팅:** 코드 푸시 전, PR 생성 전 실행\n**CI/CD:** CI에서 포맷팅 검증 (--verify-no-changes / --check 모드 사용)\n\n**다른 SKILL과 함께 사용:**\n- 이전 단계: code-analyze (스타일 먼저 수정)\n- 다음 단계: dotnet-build (깔끔한 코드 빌드)\n\n## Configuration Files\n\n- **`.editorconfig`**: 포맷팅 규칙 정의 (indent size, line endings 등)\n- **`.prettierrc.json`**: Prettier 구성 (print width, quotes 등)\n- **`.pre-commit-config.yaml`**: Pre-commit hook 구성\n- **`.prettierignore`**: Prettier 포맷팅에서 제외할 파일\n\n## Related\n\n- [`.editorconfig`](../../../.editorconfig) - 포맷팅 규칙\n- [`.prettierrc.json`](../../../.prettierrc.json) - Prettier 설정\n- [`.pre-commit-config.yaml`](../../../.pre-commit-config.yaml) - Pre-commit hooks\n- [`setup-pre-commit.sh`](../../../setup-pre-commit.sh) - Pre-commit 설정 스크립트"
              },
              {
                "name": "code-reviewer",
                "description": "보안 스캔, 품질 지표 및 모범 사례 분석을 포함한 자동화된 코드 리뷰입니다. 다음을 위한 코드 리뷰 시 사용합니다: (1) 보안 취약점 및 일반적인 공격 벡터, (2) 코드 품질 이슈 및 유지보수 문제, (3) 성능 병목 현상 및 최적화 기회, (4) 모범 사례 및 디자인 패턴, (5) 테스트 커버리지 및 테스트 전략, (6) 문서 품질 및 완전성",
                "path": "icartsh-plugin/skills/code-reviewer/SKILL.md",
                "frontmatter": {
                  "name": "code-reviewer",
                  "description": "보안 스캔, 품질 지표 및 모범 사례 분석을 포함한 자동화된 코드 리뷰입니다. 다음을 위한 코드 리뷰 시 사용합니다: (1) 보안 취약점 및 일반적인 공격 벡터, (2) 코드 품질 이슈 및 유지보수 문제, (3) 성능 병목 현상 및 최적화 기회, (4) 모범 사례 및 디자인 패턴, (5) 테스트 커버리지 및 테스트 전략, (6) 문서 품질 및 완전성"
                },
                "content": "# Code Reviewer\n\n보안 이슈, 품질 지표, 성능 문제 및 모범 사례 준수 여부를 체계적으로 분석하는 포괄적인 자동화 코드 리뷰 SKILL입니다.\n\n## Purpose\n\n이 SKILL은 자동화된 분석 도구와 전문가 가이드를 결합하여 보안, 품질, 성능 및 유지보수성 측면에서 이슈를 식별하는 구조화된 코드 리뷰 워크플로우를 제공합니다.\n\n## When to Use This Skill\n\n이 SKILL은 다음과 같은 경우에 사용하세요:\n- Pull request 또는 코드 제출을 리뷰할 때\n- 기존 코드베이스에 대한 보안 감사를 수행할 때\n- 배포 전 코드 품질을 평가할 때\n- 기술 부채 및 리팩토링 기회를 식별할 때\n- 팀을 위한 코드 리뷰 표준을 수립할 때\n- 코드 리뷰에서 무엇을 살펴봐야 하는지 학습할 때\n\n## Core Review Workflow\n\n### Phase 1: Initial Analysis\n\n#### 1.1 Context 이해하기\n- PR 설명 또는 변경 요약을 읽습니다.\n- 변경 유형(기능, 버그 수정, 리팩토링, 보안 패치)을 식별합니다.\n- 범위와 영향을 받는 컴포넌트를 결정합니다.\n- 관련된 이슈나 티켓이 있는지 확인합니다.\n\n#### 1.2 코드 개요 파악\n- 파일 변경 사항과 추가/삭제된 내용을 검토합니다.\n- 변경된 모듈과 그 관계를 식별합니다.\n- 예상치 못한 변경이나 범위 확장(Scope creep)을 찾습니다.\n- Breaking change가 있는지 확인합니다.\n\n### Phase 2: Security Review\n\n#### 2.1 일반적인 취약점 패턴\n\n다음과 같은 중요한 보안 이슈를 확인합니다:\n\n**Input Validation**\n- 검증되지 않은 사용자 입력이 민감한 작업에 도달하는지 확인\n- SQL injection 취약점\n- Command injection 가능성\n- Path traversal 공격\n- XML/XXE injection 포인트\n\n**Authentication & Authorization**\n- 인증 체크 누락\n- Broken access control\n- 안전하지 않은 비밀번호 저장\n- 취약한 세션 관리\n- CSRF 보호 누락\n\n**Data Exposure**\n- 하드코딩된 자격 증명(Credential) 또는 API key\n- 로그 내 민감한 데이터 포함 여부\n- 부적절한 암호화\n- 에러 메시지를 통한 정보 노출\n- 노출된 설정 파일\n\n**Code Injection**\n- 안전하지 않은 Deserialization\n- Template injection\n- 사용자 입력에 의한 코드 실행(Code evaluation)\n- 안전하지 않은 Reflection 사용\n\n#### 2.2 자동화 보안 스캔\n\n보안 분석 도구를 사용합니다:\n\n**Python:**\n```bash\n# 보안 이슈를 위해 bandit 실행\npython scripts/review_helper.py --security-scan path/to/code\n\n# 알려진 취약점에 대해 종속성 체크\nsafety check\npip-audit\n```\n\n**JavaScript/Node.js:**\n```bash\n# 취약점 체크\nnpm audit\nyarn audit\n\n# ESLint 보안 플러그인 사용\neslint --plugin security path/to/code\n```\n\n**Go:**\n```bash\n# 보안 스캐닝\ngosec ./...\n```\n\n상세한 취약점 패턴은 `references/security_patterns.md`를 참조하세요.\n\n### Phase 3: Code Quality Analysis\n\n#### 3.1 코드 구조\n\n**Modularity & Organization**\n- Single Responsibility Principle 준수 여부\n- 적절한 Separation of concerns\n- 적절한 추상화 수준\n- 명확한 모듈 경계\n- 논리적인 파일 구성\n\n**Complexity Metrics**\n- Cyclomatic complexity (목표: 함수당 < 10)\n- 함수 길이 (목표: < 50 라인)\n- 클래스 크기 (목표: < 300 라인)\n- Nesting depth (목표: < 4 단계)\n- 파라미터 개수 (목표: < 5개)\n\n**Code Smells**\n- 중복 코드\n- 너무 긴 메서드 또는 God class\n- Feature envy (메서드가 다른 클래스를 더 많이 사용함)\n- Data clumps (반복되는 파라미터 그룹)\n- Primitive obsession\n- 클래스 간의 부적절한 관계(Inappropriate intimacy)\n\n#### 3.2 명명(Naming) 및 가독성\n\n**Naming Conventions**\n- 의도를 드러내는 서술적인 이름\n- 일관된 명명 패턴\n- 적절한 길이 (너무 짧거나 길지 않게)\n- 표준이 아닌 경우 약어 사용 지양\n- Boolean 이름은 is/has/should/can으로 시작\n\n**Code Clarity**\n- 명확한 Control flow\n- 인지 부하 최소화\n- Self-documenting code\n- 적절한 주석 (What이 아닌 Why에 집중)\n- 일관된 포맷팅\n\n#### 3.3 Error Handling\n\n**Robustness**\n- 적절한 Exception handling\n- 빈 except/catch 블록 지양\n- 적절한 에러 메시지\n- 리소스 정리 (File handles, connections)\n- Graceful degradation\n\n**Edge Cases**\n- Null/None 체크\n- 빈 컬렉션 처리\n- Boundary conditions\n- 동시 액세스 이슈\n- Race condition 방지\n\n### Phase 4: Performance Review\n\n#### 4.1 일반적인 성능 이슈\n\n**Algorithm Efficiency**\n- 더 나은 대안이 있음에도 O(n²) 이상의 알고리즘 사용\n- 불필요한 루프 또는 반복\n- 비효율적인 데이터 구조 사용\n- Memoization/caching 기회 누락\n\n**Resource Management**\n- Memory leaks\n- 닫히지 않은 File handles 또는 connections\n- 과도한 메모리 할당\n- Thread/process pool 고갈\n\n**Database Operations**\n- N+1 query 문제\n- 인덱스 누락\n- SELECT * 사용\n- 비효율적인 JOIN 작업\n- 쿼리 최적화 누락\n\n**Network Calls**\n- 동기적 Blocking calls\n- Timeout 설정 누락\n- 재시도(Retry) 로직 부재\n- 과도한 API 호출\n- Connection pooling 누락\n\n최적화 전략은 `references/performance_guide.md`를 참조하세요.\n\n### Phase 5: Testing Assessment\n\n#### 5.1 Test Coverage\n\n**Coverage Metrics**\n- Line coverage (목표: > 80%)\n- Branch coverage (목표: > 75%)\n- Function coverage (목표: > 90%)\n- Critical path coverage (목표: 100%)\n\n**Test Quality**\n- 테스트가 실제로 의미 있는 동작을 검증(Assert)하는지 확인\n- 테스트가 독립적이고 격리되어 있는지 확인\n- 테스트 이름이 테스트 대상을 명확히 설명하는지 확인\n- Mock 및 Stub의 적절한 사용\n- 테스트 간 상호 의존성 부재\n\n#### 5.2 Test Completeness\n\n**필수 테스트 유형**\n- 비즈니스 로직을 위한 Unit tests\n- 컴포넌트 상호작용을 위한 Integration tests\n- Edge case 및 boundary 테스트\n- 에러 조건 테스트\n- 보안 관련 테스트\n\n**누락된 테스트**\n- 테스트되지 않은 에러 경로\n- 부정적(Negative) 테스트 케이스 누락\n- 커버되지 않은 edge condition\n- 버그 수정을 위한 Regression tests 부재\n\n### Phase 6: Documentation Review\n\n#### 6.1 코드 문서화\n\n**함수/메서드 문서화**\n- 목적 및 동작 설명\n- 타입을 포함한 파라미터 설명\n- 리턴값 문서화\n- Exception 문서화\n- 복잡한 API를 위한 사용 예시\n\n**모듈/클래스 문서화**\n- 상위 수준의 목적\n- 아키텍처 개요\n- 설계 결정 사항\n- 종속성(Dependencies)\n- Public API contracts\n\n#### 6.2 외부 문서화\n\n**README 업데이트**\n- 설치 방법\n- 설정 변경 사항\n- 새로운 기능 문서화\n- Breaking change 공지\n- Migration 가이드\n\n**API Documentation**\n- 엔드포인트 설명\n- Request/response 형식\n- 인증 요구 사항\n- 에러 응답\n- Rate limiting\n\n## Review Checklist\n\n포괄적인 리뷰를 위해 이 체크리스트를 사용하세요:\n\n### Security\n- [ ] 하드코딩된 자격 증명이나 Secret이 없음\n- [ ] 모든 사용자 입력에 대해 Input validation 수행\n- [ ] 적절한 Authentication 및 Authorization\n- [ ] SQL/Command injection 취약점 없음\n- [ ] 안전한 비밀번호 처리\n- [ ] 민감한 데이터에 대해 HTTPS/TLS 사용\n- [ ] 보안 스캔 도구 실행 완료\n- [ ] 종속성 취약점 체크 완료\n\n### Code Quality\n- [ ] 함수가 Single Responsibility Principle을 따름\n- [ ] Cyclomatic complexity가 10 미만임\n- [ ] 코드 중복 없음\n- [ ] 일관된 Naming conventions 준수\n- [ ] 적절한 Error handling\n- [ ] 티켓 번호가 없는 TODO/FIXME 없음\n- [ ] 코드가 Self-documenting함\n\n### Performance\n- [ ] 명백한 성능 병목 현상이 없음\n- [ ] 효율적인 알고리즘 및 데이터 구조 사용\n- [ ] 적절한 리소스 정리\n- [ ] 데이터베이스 쿼리 최적화 완료\n- [ ] N+1 query 문제 없음\n- [ ] 적절한 Caching 전략 사용\n\n### Testing\n- [ ] 새로운 기능에 대해 테스트 포함됨\n- [ ] Edge cases가 커버됨\n- [ ] 테스트 커버리지가 표준을 충족함\n- [ ] 테스트가 독립적이고 반복 가능함\n- [ ] Flaky tests가 도입되지 않음\n\n### Documentation\n- [ ] Public API가 문서화됨\n- [ ] 복잡한 로직이 설명됨\n- [ ] 필요한 경우 README 업데이트됨\n- [ ] Breaking changes 문서화됨\n- [ ] 필요한 경우 Migration 가이드 제공됨\n\n## Using the Review Helper Script\n\n`scripts/review_helper.py`는 자동화된 분석을 제공합니다:\n\n```bash\n# 전체 코드 리뷰 분석\npython scripts/review_helper.py --file path/to/file.py --report full\n\n# 보안 중심 스캔\npython scripts/review_helper.py --security-scan path/to/directory\n\n# 복잡도 분석\npython scripts/review_helper.py --complexity path/to/file.py\n\n# 리뷰 보고서 생성\npython scripts/review_helper.py --file path/to/file.py --output report.md\n```\n\n## Best Practices\n\n### 리뷰어를 위한 조언 (For Reviewers)\n\n**건설적인 태도 (Be Constructive)**\n- 비판이 아닌 개선에 집중하세요.\n- 제안 뒤에 숨겨진 \"Why\"를 설명하세요.\n- 대안이나 해결책을 제시하세요.\n- 좋은 코드와 패턴은 칭찬하세요.\n\n**철저하지만 효율적인 리뷰 (Be Thorough but Efficient)**\n- 반복적인 체크에는 자동화 도구를 사용하세요.\n- 사람의 리뷰는 로직과 설계에 집중하세요.\n- 스타일에 너무 집착하지 마세요 (Linter 사용).\n- 스타일보다 보안과 정확성을 우선시하세요.\n\n**일관성 유지 (Be Consistent)**\n- 모든 코드에 동일한 표준을 적용하세요.\n- 팀 코딩 표준을 참조하세요.\n- 재사용 가능한 리뷰 템플릿을 만드세요.\n- 공통된 피드백 패턴을 문서화하세요.\n\n### 코드 작성자를 위한 조언 (For Code Authors)\n\n**리뷰 준비**\n- 리뷰를 요청하기 전에 스스로 리뷰(Self-review)하세요.\n- Linter와 포맷터를 실행하세요.\n- 테스트 슈트를 실행하세요.\n- PR 설명에 컨텍스트를 추가하세요.\n- 변경 사항을 작고 집중된 단위로 유지하세요.\n\n**피드백 대응**\n- 모든 코멘트에 대응하세요.\n- 불명확한 경우 질문하세요.\n- 피드백을 개인적으로 받아들이지 마세요.\n- 완료된 대화는 해결됨(Resolved)으로 표시하세요.\n\n## Common Review Feedback Patterns\n\n### 보안 이슈\n```\n❌ Security: 하드코딩된 API key 발견\n→ 환경 변수 또는 secret management로 이동하세요.\n→ 참고: references/security_patterns.md#secrets-management\n\n❌ Security: SQL injection 취약점\n→ 문자열 연결 대신 파라미터화된 쿼리를 사용하세요.\n→ 예시: cursor.execute(\"SELECT * FROM users WHERE id = %s\", (user_id,))\n```\n\n### 품질 이슈\n```\n❌ Quality: 함수의 복잡도가 너무 높음 (complexity: 15)\n→ 더 작고 집중된 기능의 함수들로 나누세요.\n→ 목표: < 10 cyclomatic complexity\n\n❌ Quality: 3개 위치에서 중복 코드 발견\n→ 공통 로직을 공유 함수로 추출하세요.\n→ DRY 원칙 위반\n```\n\n### 성능 이슈\n```\n❌ Performance: N+1 query 문제 탐지됨\n→ JOIN 또는 eager loading을 사용하세요.\n→ 참고: references/performance_guide.md#database-optimization\n\n❌ Performance: 비효율적인 O(n²) 알고리즘\n→ O(1) 조회를 위해 set/hash 사용을 고려하세요.\n→ 현재: 중첩 루프, 권장: set intersection\n```\n\n## Additional Resources\n\n- **Security Patterns**: `references/security_patterns.md` - 일반적인 취약점 및 해결 방법\n- **Performance Guide**: `references/performance_guide.md` - 최적화 전략\n- **Review Checklist**: `examples/review_checklist.md` - 포괄적인 리뷰 템플릿\n- **Helper Scripts**: `scripts/review_helper.py` - 자동화된 분석 도구\n\n## Language-Specific Considerations\n\n### Python\n- Context managers(with 문)의 적절한 사용 확인\n- List comprehension이 과도하게 복잡하지 않은지 확인\n- Generator 사용 기회 탐색\n- Mutable default arguments 확인\n\n### JavaScript/TypeScript\n- async/await의 적절한 사용 확인\n- Callback hell 확인\n- Event listener에서의 메모리 누수 확인\n- TypeScript에서의 적절한 Typing 확인\n\n### Java\n- 적절한 Exception handling 확인\n- 리소스 정리 확인 (try-with-resources)\n- Immutability의 적절한 사용 확인\n- Thread safety 이슈 확인\n\n### Go\n- 적절한 Error handling 확인 (에러 무시 금지)\n- Goroutine leak 방지 여부 확인\n- Race conditions 확인\n- 적절한 Context 사용 확인\n\n## Conclusion\n\n효과적인 코드 리뷰는 자동화된 툴과 사람의 전문성을 결합할 때 이루어집니다. 기계적인 체크(보안, 스타일, 복잡도)에는 자동화 도구를 사용하고, 사람의 리뷰는 로직, 설계 및 유지보수성에 집중하세요. 항상 건설적이고 철저하며 일관성 있는 리뷰를 지향하십시오."
              },
              {
                "name": "coding-conventions",
                "description": ".NET/C#의 코딩 규약, 명명 규칙, 레이아웃, C# 12/13/14의 최신 기능 활용 가이드라인을 정의합니다. C#/.NET 코드 작성 시, 클래스·메서드 명명 시, 코드 포맷팅 시, 또는 사용자가 코딩 규약, 명명 규칙, C# 모범 사례, Primary Constructors, Collection Expressions, field 키워드에 대해 언급했을 때 사용합니다.",
                "path": "icartsh-plugin/skills/coding-conventions/SKILL.md",
                "frontmatter": {
                  "name": "coding-conventions",
                  "description": ".NET/C#의 코딩 규약, 명명 규칙, 레이아웃, C# 12/13/14의 최신 기능 활용 가이드라인을 정의합니다. C#/.NET 코드 작성 시, 클래스·메서드 명명 시, 코드 포맷팅 시, 또는 사용자가 코딩 규약, 명명 규칙, C# 모범 사례, Primary Constructors, Collection Expressions, field 키워드에 대해 언급했을 때 사용합니다."
                },
                "content": "# Coding Conventions\n\n## 개요\n\n이 SKILL은 개발되는 모든 .NET 프로젝트에 적용되는 코딩 규약을 정의합니다. .NET 8 이후의 최신 기능(C# 12/13/14, .NET 8/9/10)을 적극적으로 활용하여 가독성, 유지보수성, 성능이 높은 코드를 구현하는 것을 목적으로 합니다.\n\n## 책임 범위\n\n이 SKILL은 다음 범위를 다룹니다:\n\n- .NET/C#의 최신 기능(C# 12/13/14, .NET 8/9/10) 활용 방침\n- 명명 규칙 (Type, Member, Variable, Parameter)\n- 코드 레이아웃 및 포맷\n- 언어 기능 사용 방침 (Type inference, Collection, Exception handling)\n- LINQ와 람다식의 모범 사례\n- 모던 C# 구문의 권장 패턴\n\n## 기본 방침\n\n- .NET 8 이후의 최신 기능을 적극적으로 사용한다 (C# 12/13/14, .NET 8/9/10)\n- 이전 버전과의 호환성이 필요한 경우를 제외하고 항상 최신 기능을 우선한다\n- 오래된 언어 구문은 피한다\n- **중요: 언더스코어 접두사(`_field`) 사용은 절대 금지한다**\n- **중요: 중괄호 생략은 절대 금지한다 (1행으로 기술할 수 있는 경우에도 생략 불가)**\n- Microsoft 공식 코딩 규약을 따른다\n- 일관성을 유지하고 팀 전체에서 동일한 스타일을 적용한다\n\n## .NET/C# 최신 기능 (버전별)\n\n.NET 8 이후 각 버전에서 도입된 주요 기능을 적극적으로 활용합니다. 이전 버전과의 호환성이 필요한 경우를 제외하고 항상 최신 기능을 우선적으로 사용합니다.\n\n### C# 12 (.NET 8) - 2023년 11월 공식 릴리스\n\n#### Primary Constructors\n\n- 클래스나 struct 선언에서 파라미터를 정의하고 클래스 전체에서 사용할 수 있음\n- 명시적인 필드 선언을 줄이고 초기화를 간소화함\n\n좋은 예:\n\n```csharp\npublic class Person(string name, int age)\n{\n    public string Name => name;\n    public int Age => age;\n\n    public void Display()\n    {\n        Console.WriteLine($\"{name} is {age} years old\");\n    }\n}\n```\n\n나쁜 예:\n\n```csharp\npublic class Person\n{\n    private string name;\n    private int age;\n\n    public Person(string name, int age)\n    {\n        this.name = name;\n        this.age = age;\n    }\n\n    public string Name => name;\n    public int Age => age;\n}\n```\n\n#### Collection Expressions\n\n- 대괄호와 스프레드 연산자를 사용하여 컬렉션을 간결하게 생성함\n- 여러 컬렉션을 결합할 때 유용함\n\n좋은 예:\n\n```csharp\nint[] array = [1, 2, 3, 4, 5];\nList<string> list = [\"one\", \"two\", \"three\"];\n\nint[] row0 = [1, 2, 3];\nint[] row1 = [4, 5, 6];\n\n// 스프레드 연산자로 결합\nint[] combined = [..row0, ..row1];\n```\n\n#### Default Lambda Parameters\n\n- 람다식에 기본 파라미터 값을 지정할 수 있음\n\n좋은 예:\n\n```csharp\nvar incrementBy = (int source, int increment = 1) => source + increment;\n\nConsole.WriteLine(incrementBy(5));\nConsole.WriteLine(incrementBy(5, 3));\n```\n\n#### Alias Any Type\n\n- using 디렉티브로 복잡한 타입에 별칭을 붙일 수 있음\n\n좋은 예:\n\n```csharp\nusing Point = (int x, int y);\nusing ProductList = System.Collections.Generic.List<(string Name, decimal Price)>;\n\nPoint origin = (0, 0);\nProductList products = [(\"Product1\", 100m), (\"Product2\", 200m)];\n```\n\n### C# 13 (.NET 9) - 2024년 11월 공식 릴리스\n\n#### Params Collections\n\n- `params` 수식어를 배열 외의 컬렉션 타입에서도 사용 가능해짐\n- `List<T>`, `Span<T>`, `ReadOnlySpan<T>`, `IEnumerable<T>` 등에서 사용 가능\n\n좋은 예:\n\n```csharp\npublic void ProcessItems(params List<string> items)\n{\n    foreach (var item in items)\n    {\n        Console.WriteLine(item);\n    }\n}\n\n// 메모리 효율이 중요한 경우\npublic void ProcessData(params ReadOnlySpan<int> data)\n{\n    foreach (var value in data)\n    {\n        Process(value);\n    }\n}\n```\n\n#### New Lock Type\n\n- `System.Threading.Lock` 타입을 사용하여 더 빠른 스레드 동기화를 구현함\n- 기존 `Monitor` 기반 락보다 빠름\n\n좋은 예:\n\n```csharp\nprivate readonly Lock lockObject = new();\n\npublic void UpdateData()\n{\n    lock (lockObject)\n    {\n        // Critical section\n    }\n}\n```\n\n나쁜 예:\n\n```csharp\n// 기존 object 기반 락 (C# 13에서는 권장되지 않음)\nprivate readonly object lockObject = new();\n\npublic void UpdateData()\n{\n    lock (lockObject)\n    {\n        // Critical section\n    }\n}\n```\n\n#### Partial Properties and Indexers\n\n- partial 프로퍼티와 인덱서를 사용할 수 있게 됨\n- 정의와 구현을 분리할 수 있음\n\n좋은 예:\n\n```csharp\n// 정의 부분\npublic partial class DataModel\n{\n    public partial string Name { get; set; }\n}\n\n// 구현 부분\npublic partial class DataModel\n{\n    private string name;\n\n    public partial string Name\n    {\n        get => name;\n        set => name = value ?? throw new ArgumentNullException(nameof(value));\n    }\n}\n```\n\n#### Implicit Index Access\n\n- 객체 이니셜라이저에서 `^` 연산자를 사용할 수 있게 됨\n\n좋은 예:\n\n```csharp\nvar countdown = new TimerBuffer\n{\n    buffer =\n    {\n        [^1] = 0,\n        [^2] = 1,\n        [^3] = 2\n    }\n};\n```\n\n#### Ref Struct Enhancements\n\n- `ref struct` 타입이 인터페이스를 구현할 수 있게 됨\n- 제네릭 타입에서 `ref struct`를 사용할 수 있게 됨 (`allows ref struct` 제약 조건)\n\n좋은 예:\n\n```csharp\npublic ref struct SpanWrapper<T> : IEnumerable<T>\n{\n    private Span<T> span;\n\n    public IEnumerator<T> GetEnumerator()\n    {\n        foreach (var item in span)\n        {\n            yield return item;\n        }\n    }\n}\n```\n\n### C# 14 (.NET 10) - 2025년 11월 릴리스 예정\n\n#### Extension Members\n\n- Extension Members를 활용하여 깔끔한 API 확장을 구현함\n- 원래 타입을 오염시키지 않고 기능을 추가할 수 있음\n\n좋은 예:\n\n```csharp\nextension<TSource>(IEnumerable<TSource> source)\n{\n    public bool IsEmpty => !source.Any();\n    public int Count => source.Count();\n}\n```\n\n#### Field-Backed Properties\n\n- `field` 키워드를 사용하여 명시적인 backing field를 줄임\n- 검증 로직을 간결하게 기술할 수 있음\n- **언더스코어 접두사를 사용한 명시적인 backing field는 절대 금지**\n\n좋은 예:\n\n```csharp\n// C# 14의 field 키워드 사용\npublic string Name\n{\n    get;\n    set => field = value ?? throw new ArgumentNullException(nameof(value));\n}\n\n// 어쩔 수 없이 명시적인 backing field가 필요한 경우에도 언더스코어 없음\nprivate string name;\n\npublic string Name\n{\n    get => name;\n    set => name = value ?? throw new ArgumentNullException(nameof(value));\n}\n```\n\n나쁜 예:\n\n```csharp\n// 언더스코어 접두사는 절대 금지\nprivate string _name;\n\npublic string Name\n{\n    get => _name;\n    set => _name = value ?? throw new ArgumentNullException(nameof(value));\n}\n```\n\n#### Null-Conditional Assignment\n\n- `?.`를 사용하여 null 체크를 간결하게 기술함\n- 중복되는 null 체크를 줄임\n\n좋은 예:\n\n```csharp\ncustomer?.Order = GetCurrentOrder();\n```\n\n나쁜 예:\n\n```csharp\nif (customer != null)\n{\n    customer.Order = GetCurrentOrder();\n}\n```\n\n#### Implicit Span Conversions\n\n- 성능 중시 코드에서는 `Span<T>`와 `ReadOnlySpan<T>`를 활용함\n- 배열과 스팬 타입 간의 자동 변환을 이용함\n\n## 명명 규칙 (Naming Conventions)\n\n### Pascal Casing\n\n- 타입 이름 (class, record, struct, interface, enum)\n- 퍼블릭 멤버 (프로퍼티, 메서드, 이벤트)\n- 네임스페이스\n\n좋은 예:\n\n```csharp\npublic class CustomerOrder\n{\n    public string OrderId { get; set; }\n    public void ProcessOrder() { }\n}\n```\n\n### Camel Casing\n\n- 로컬 변수\n- 메서드 파라미터\n- 프라이빗 필드 (**언더스코어 접두사는 절대 사용하지 않음**)\n\n좋은 예:\n\n```csharp\npublic class OrderProcessor\n{\n    // 언더스코어 없음\n    private string customerName;\n\n    // 언더스코어 없음\n    private int orderCount;\n\n    public void ProcessOrder(string orderId)\n    {\n        var customerName = GetCustomerName(orderId);\n        string processedResult = Process(customerName);\n    }\n}\n```\n\n나쁜 예:\n\n```csharp\npublic class OrderProcessor\n{\n    // 언더스코어 접두사는 절대 금지\n    private string _customerName;\n\n    // 언더스코어 접두사는 절대 금지\n    private int _orderCount;\n}\n```\n\n### Interface 명명\n\n- 접두사 `I`를 사용함\n\n좋은 예:\n\n```csharp\npublic interface IOrderProcessor\n{\n    void Process(Order order);\n}\n```\n\n### 타입 파라미터 명명\n\n- 접두사 `T`를 사용함\n- 의미 있는 이름을 붙임\n\n좋은 예:\n\n```csharp\npublic class Repository<TEntity> where TEntity : class\n{\n    public void Add(TEntity entity) { }\n}\n```\n\n## 코드 레이아웃 (Code Layout)\n\n### 들여쓰기\n\n- 공백(Space) 4개를 사용함\n- 탭(Tab)은 사용하지 않음\n\n### 중괄호 (Curly Braces)\n\n- Allman 스타일 (시작 중괄호와 종료 중괄호를 별도의 행에 배치)\n- **중괄호 생략은 절대 금지 (1행으로 기술할 수 있는 경우에도 반드시 중괄호 사용)**\n\n좋은 예:\n\n```csharp\npublic void ProcessOrder(Order order)\n{\n    if (order != null)\n    {\n        order.Process();\n    }\n}\n\n// 1행이라도 중괄호를 사용함\nif (isValid)\n{\n    Execute();\n}\n\nfor (int i = 0; i < 10; i++)\n{\n    Process(i);\n}\n```\n\n나쁜 예:\n\n```csharp\n// 중괄호 생략 금지\nif (isValid)\n    Execute();\n\n// 중괄호 생략 금지\nfor (int i = 0; i < 10; i++)\n    Process(i);\n\n// 중괄호 생략 금지\nif (order != null) order.Process();\n```\n\n### 행 기술\n\n- 1행에 하나의 statement만 기술함\n- 1행에 하나의 선언만 기술함\n- 메서드 정의와 프로퍼티 정의 사이에 빈 행을 하나 넣음\n\n좋은 예:\n\n```csharp\npublic class Order\n{\n    public string OrderId { get; set; }\n\n    public void Process()\n    {\n        var result = Validate();\n        Execute(result);\n    }\n\n    private bool Validate()\n    {\n        return OrderId != null;\n    }\n}\n```\n\n### 네임스페이스\n\n- 파일 스코프 네임스페이스(File-scoped namespace)를 사용함\n\n좋은 예:\n\n```csharp\nnamespace YourProject.Orders;\n\npublic class OrderProcessor\n{\n    // Implementation\n}\n```\n\n나쁜 예:\n\n```csharp\nnamespace YourProject.Orders\n{\n    public class OrderProcessor\n    {\n        // Implementation\n    }\n}\n```\n\n### using 디렉티브\n\n- 네임스페이스 선언 바깥쪽에 배치함\n- 알파벳 순으로 정렬함\n\n좋은 예:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace YourProject.Orders;\n```\n\n## 타입과 변수\n\n### 타입 지정\n\n- 언어 키워드 (`string`, `int`, `bool`)를 사용함\n- 런타임 타입 (`System.String`, `System.Int32`)은 사용하지 않음\n\n좋은 예:\n\n```csharp\nstring name = \"John\";\nint count = 10;\nbool isValid = true;\n```\n\n나쁜 예:\n\n```csharp\nString name = \"John\";\nInt32 count = 10;\nBoolean isValid = true;\n```\n\n### 타입 추론 (var)\n\n- 타입이 할당되는 내용으로부터 명백한 경우에만 `var`를 사용함\n- 기본 제공 타입(Built-in type)은 명시적으로 기술함\n\n좋은 예:\n\n```csharp\n// 명백함\nvar orders = new List<Order>();\n\n// 명백함\nvar customer = GetCustomer();\n\n// 기본 타입은 명시\nint count = 10;\n\n// 기본 타입은 명시\nstring name = \"John\";\n```\n\n나쁜 예:\n\n```csharp\n// 기본 타입에서 var는 피함\nvar count = 10;\n\n// 기본 타입에서 var는 피함\nvar name = \"John\";\n```\n\n## 문자열\n\n### 문자열 보간 (String Interpolation)\n\n- 짧은 문자열 결합에는 문자열 보간을 사용함\n\n좋은 예:\n\n```csharp\nstring message = $\"Order {orderId} processed successfully\";\n```\n\n나쁜 예:\n\n```csharp\nstring message = \"Order \" + orderId + \" processed successfully\";\n```\n\n### StringBuilder\n\n- 루프 내에서 대량의 텍스트를 추가하는 경우 `StringBuilder`를 사용함\n\n좋은 예:\n\n```csharp\nvar builder = new StringBuilder();\nfor (int i = 0; i < 1000; i++)\n{\n    builder.Append($\"Line {i}\\n\");\n}\n```\n\n### Raw String Literals\n\n- 이스케이프 시퀀스보다 Raw String Literals를 우선함\n\n좋은 예:\n\n```csharp\nstring json = \"\"\"\n{\n    \"name\": \"John\",\n    \"age\": 30\n}\n\"\"\";\n```\n\n## 컬렉션과 객체 초기화\n\n### 컬렉션 초기화\n\n- C# 12 이후의 Collection Expressions를 사용함 (앞부분의 \"C# 12 최신 기능\" 참조)\n\n### 객체 이니셜라이저 (Object Initializer)\n\n- 객체 이니셜라이저를 사용하여 생성을 간소화함\n\n좋은 예:\n\n```csharp\nvar customer = new Customer\n{\n    Name = \"John\",\n    Email = \"john@example.com\"\n};\n```\n\n## 예외 처리 (Exception Handling)\n\n### 구체적인 예외 캐치\n\n- 일반적인 `System.Exception` 대신 구체적인 예외를 캐치함\n\n좋은 예:\n\n```csharp\ntry\n{\n    ProcessOrder(order);\n}\ncatch (ArgumentNullException ex)\n{\n    Logger.Error(\"Order is null\", ex);\n}\n```\n\n나쁜 예:\n\n```csharp\ntry\n{\n    ProcessOrder(order);\n}\ncatch (Exception ex) // 너무 일반적임\n{\n    Logger.Error(\"Error\", ex);\n}\n```\n\n### using 문\n\n- try-finally 대신 `using` 문을 사용함\n\n좋은 예:\n\n```csharp\nusing var connection = new SqlConnection(connectionString);\nconnection.Open();\n// Process\n```\n\n나쁜 예:\n\n```csharp\nSqlConnection connection = null;\ntry\n{\n    connection = new SqlConnection(connectionString);\n    connection.Open();\n    // Process\n}\nfinally\n{\n    connection?.Dispose();\n}\n```\n\n## LINQ\n\n### 의미 있는 변수명\n\n- 쿼리 변수에는 의미 있는 이름을 사용함\n\n좋은 예:\n\n```csharp\nvar activeCustomers = from customer in customers\n                      where customer.IsActive\n                      select customer;\n```\n\n### 조기 필터링\n\n- `where` 절을 사용하여 조기에 데이터를 필터링함\n\n좋은 예:\n\n```csharp\nvar result = customers\n    .Where(c => c.IsActive)\n    .Select(c => c.Name)\n    .ToList();\n```\n\n### 암시적 타입 지정\n\n- LINQ 선언에서는 암시적 타입 지정을 사용함\n\n좋은 예:\n\n```csharp\nvar query = from customer in customers\n            where customer.IsActive\n            select customer;\n```\n\n## 람다식 (Lambda Expressions)\n\n### 이벤트 핸들러\n\n- 삭제가 필요 없는 핸들러에는 람다식을 사용함\n\n좋은 예:\n\n```csharp\nbutton.Click += (s, e) => ProcessClick();\n```\n\n### 파라미터 수식어\n\n- C# 14 기능을 활용하여 타입 추론을 유지하면서 수식어를 사용함\n\n좋은 예:\n\n```csharp\nTryParse<int> parse = (text, out result) => int.TryParse(text, out result);\n```\n\n## 주석 (Comments)\n\n### 단일 행 주석\n\n- 간결한 설명에는 `//`를 사용함\n- 주석 구분자 뒤에 공백을 하나 넣음\n- **주석은 반드시 단독 행에 기술함 (코드와 같은 행에 기술 금지)**\n- 주석 앞에는 빈 행을 하나 넣음\n\n좋은 예:\n\n```csharp\n// 고객 주문을 처리함\nProcessOrder(order);\n\nvar processor = new OrderProcessor();\n\n// 주문을 실행함\nvar result = processor.ProcessOrder(order);\n```\n\n나쁜 예:\n\n```csharp\nProcessOrder(order); // 고객 주문을 처리함 (코드와 같은 행은 금지)\n\nvar processor = new OrderProcessor();\n// 이 행의 앞에 빈 행이 없음 (나쁜 예)\nvar result = processor.ProcessOrder(order);\n```\n\n### XML 문서\n\n- 퍼블릭 멤버에는 XML 문서를 사용함\n\n좋은 예:\n\n```csharp\n/// <summary>\n/// 지정된 주문을 처리함\n/// </summary>\n/// <param name=\"order\">처리할 주문</param>\n/// <returns>처리 결과</returns>\npublic bool ProcessOrder(Order order)\n{\n    // Implementation\n}\n```\n\n## 정적 멤버 (Static Members)\n\n### 클래스 이름에 의한 호출\n\n- 정적 멤버는 클래스 이름을 통해 호출함\n\n좋은 예:\n\n```csharp\nvar result = OrderProcessor.ProcessOrder(order);\n```\n\n나쁜 예:\n\n```csharp\nvar processor = new OrderProcessor();\n\n// 정적 메서드를 인스턴스를 통해 호출하는 것은 오해의 소지가 있음\nvar result = processor.ProcessOrder(order);\n```\n\n## 체크리스트 (Checklist)\n\n### 코드 작성 전\n\n- [ ] .NET/C#의 최신 기능 (C# 12/13/14)을 파악하고 있음\n- [ ] 프로젝트의 타겟 프레임워크가 .NET 8 이후로 설정되어 있음\n- [ ] 명명 규칙을 이해하고 있음\n\n### 코드 작성 중\n\n**필수 규칙:**\n\n- [ ] **언더스코어 접두사를 절대 사용하지 않았음**\n- [ ] **중괄호를 생략하지 않았음 (1행이라도 반드시 사용함)**\n- [ ] **주석은 반드시 단독 행에 기술했음 (코드와 같은 행에 기술하지 않았음)**\n- [ ] **주석 앞에 빈 행을 하나 넣었음**\n\n**C# 12 이후 기능:**\n\n- [ ] Primary Constructors를 사용하고 있음 (해당하는 경우)\n- [ ] Collection Expressions를 사용하고 있음\n- [ ] Default Lambda Parameters를 활용하고 있음 (해당하는 경우)\n- [ ] Alias Any Type으로 복잡한 타입에 별칭을 붙였음 (해당하는 경우)\n\n**C# 13 이후 기능:**\n\n- [ ] Params Collections를 사용하고 있음 (해당하는 경우)\n- [ ] New Lock Type을 사용하고 있음 (스레드 동기화가 필요한 경우)\n- [ ] Partial Properties and Indexers를 활용하고 있음 (해당하는 경우)\n- [ ] Implicit Index Access를 객체 이니셜라이저에서 사용하고 있음 (해당하는 경우)\n\n**C# 14 이후 기능:**\n\n- [ ] `field` 키워드를 사용하여 backing field를 간결하게 기술했음\n- [ ] Extension Members를 활용하고 있음 (해당하는 경우)\n- [ ] Null-Conditional Assignment를 활용하고 있음\n- [ ] Lambda Parameters with Modifiers를 사용하고 있음 (해당하는 경우)\n\n**기본 규칙:**\n\n- [ ] 파일 스코프 네임스페이스를 사용하고 있음\n- [ ] 언어 키워드 (`string`, `int`)를 사용하고 있음\n- [ ] `var`를 적절히 사용하고 있음 (타입이 명백한 경우에만)\n- [ ] 문자열 보간을 사용하고 있음\n- [ ] Raw String Literals를 사용하고 있음 (해당하는 경우)\n- [ ] Object Initializers를 사용하고 있음\n- [ ] `using` 문을 사용하고 있음\n- [ ] 구체적인 예외를 캐치하고 있음\n- [ ] LINQ 식에서 조기 필터링을 실시하고 있음\n- [ ] 의미 있는 변수명을 사용하고 있음\n- [ ] 주석이 간결하고 명확함\n- [ ] 퍼블릭 멤버에 XML 문서를 기술했음\n- [ ] Allman 스타일로 중괄호를 배치했음\n- [ ] 들여쓰기에 공백 4개를 사용하고 있음\n\n### 코드 작성 후\n\n- [ ] 코드가 일관된 스타일로 작성되었음\n- [ ] .NET 8 이후의 최신 기능 (C# 12/13/14)을 활용하고 있음\n- [ ] 명명 규칙을 따르고 있음\n- [ ] 가독성이 높고 유지보수하기 쉬운 코드임"
              },
              {
                "name": "csharp-async-patterns",
                "description": "Task, ValueTask, async streams, cancellation 등 C# async/await 패턴을 사용할 때 활용합니다. 비동기 C# 코드를 작성할 때 사용합니다.",
                "path": "icartsh-plugin/skills/csharp-async-patterns/SKILL.md",
                "frontmatter": {
                  "name": "csharp-async-patterns",
                  "description": "Task, ValueTask, async streams, cancellation 등 C# async/await 패턴을 사용할 때 활용합니다. 비동기 C# 코드를 작성할 때 사용합니다.",
                  "allowed-tools": [
                    "Bash",
                    "Read",
                    "Write",
                    "Edit"
                  ]
                },
                "content": "# C# Async Patterns\n\nasync/await, Task, ValueTask, async streams 및 cancellation 패턴을 사용하여 C# 비동기 프로그래밍을 마스터합니다. 이 SKILL은 반응성이 뛰어나고 확장이 용이한 애플리케이션을 구축하기 위해 C# 8-12의 모던 비동기 패턴을 다룹니다.\n\n## Async/Await Fundamentals\n\nasync/await 패턴은 동기 코드처럼 보이고 동작하는 비동기 코드를 작성하는 간단한 방법을 제공합니다.\n\n### Basic Async Method\n\n```csharp\npublic async Task<string> FetchDataAsync(string url)\n{\n    using var client = new HttpClient();\n    string result = await client.GetStringAsync(url);\n    return result;\n}\n\n// 비동기 메서드 호출\npublic async Task ProcessAsync()\n{\n    string data = await FetchDataAsync(\"https://api.example.com/data\");\n    Console.WriteLine(data);\n}\n```\n\n### Async Method Signature Rules\n\n```csharp\n// ✅ 올바름 - Task 반환\npublic async Task ProcessDataAsync()\n{\n    await Task.Delay(1000);\n}\n\n// ✅ 올바름 - Task<T> 반환\npublic async Task<int> CalculateAsync()\n{\n    await Task.Delay(1000);\n    return 42;\n}\n\n// ⚠️ 이벤트 핸들러 전용 - void 반환\npublic async void Button_Click(object sender, EventArgs e)\n{\n    await ProcessDataAsync();\n}\n\n// ❌ 잘못됨 - async가 아니지만 Task 반환\npublic Task WrongAsync()\n{\n    // async를 사용하거나 Task.FromResult를 사용해야 함\n    return Task.CompletedTask;\n}\n```\n\n## Task and Task<T>\n\nTask는 비동기 작업을 나타냅니다. Task<T>는 값을 반환하는 작업을 나타냅니다.\n\n### Creating Tasks\n\n```csharp\n// CPU 집약적 작업을 위한 Task.Run\npublic async Task<int> CalculateSumAsync(int[] numbers)\n{\n    return await Task.Run(() => numbers.Sum());\n}\n\n// 이미 계산된 값을 위한 Task.FromResult\npublic Task<string> GetCachedValueAsync(string key)\n{\n    if (_cache.TryGetValue(key, out var value))\n    {\n        return Task.FromResult(value);\n    }\n    return FetchFromDatabaseAsync(key);\n}\n\n// void 비동기 메서드를 위한 Task.CompletedTask\npublic Task ProcessIfNeededAsync(bool condition)\n{\n    if (!condition)\n    {\n        return Task.CompletedTask;\n    }\n    return DoActualWorkAsync();\n}\n```\n\n### Task Composition\n\n```csharp\npublic async Task<Result> ProcessOrderAsync(Order order)\n{\n    // 순차적 실행 (Sequential execution)\n    await ValidateOrderAsync(order);\n    await ChargePaymentAsync(order);\n    await ShipOrderAsync(order);\n\n    return new Result { Success = true };\n}\n\npublic async Task<Result> ProcessOrderParallelAsync(Order order)\n{\n    // 병렬 실행 (Parallel execution)\n    var validationTask = ValidateOrderAsync(order);\n    var inventoryTask = CheckInventoryAsync(order);\n    var pricingTask = CalculatePricingAsync(order);\n\n    await Task.WhenAll(validationTask, inventoryTask, pricingTask);\n\n    return new Result\n    {\n        IsValid = await validationTask,\n        InStock = await inventoryTask,\n        Price = await pricingTask\n    };\n}\n```\n\n## ValueTask and ValueTask<T>\n\nValueTask는 결과가 동기적으로 사용 가능한 경우가 많을 때 사용하는 성능 최적화 수단입니다.\n\n### When to Use ValueTask\n\n```csharp\npublic class CachedRepository\n{\n    private readonly Dictionary<int, User> _cache = new();\n    private readonly IDatabase _database;\n\n    // ✅ ValueTask 사용이 적절한 사례 - 캐시에서 동기적으로 반환되는 경우가 많음\n    public ValueTask<User> GetUserAsync(int id)\n    {\n        if (_cache.TryGetValue(id, out var user))\n        {\n            return ValueTask.FromResult(user);\n        }\n\n        return new ValueTask<User>(FetchUserFromDatabaseAsync(id));\n    }\n\n    private async Task<User> FetchUserFromDatabaseAsync(int id)\n    {\n        var user = await _database.QueryAsync<User>(id);\n        _cache[id] = user;\n        return user;\n    }\n}\n```\n\n### ValueTask Best Practices\n\n```csharp\npublic class BufferedReader\n{\n    private readonly byte[] _buffer = new byte[4096];\n    private int _position;\n    private int _length;\n\n    // Hot path 최적화를 위한 ValueTask\n    public async ValueTask<byte> ReadByteAsync()\n    {\n        if (_position < _length)\n        {\n            // 동기 경로 - 할당 없음 (No allocation)\n            return _buffer[_position++];\n        }\n\n        // 비동기 경로 - 데이터 추가 읽기\n        await FillBufferAsync();\n        return _buffer[_position++];\n    }\n\n    private async Task FillBufferAsync()\n    {\n        _length = await _stream.ReadAsync(_buffer);\n        _position = 0;\n    }\n}\n\n// ⚠️ ValueTask 규칙\npublic async Task ConsumeValueTaskAsync()\n{\n    var reader = new BufferedReader();\n\n    // ✅ 올바름 - 한 번만 await\n    byte b = await reader.ReadByteAsync();\n\n    // ❌ 잘못됨 - ValueTask를 저장하지 마세요\n    var task = reader.ReadByteAsync();\n    await task; // 잠재적 이슈 발생 가능\n\n    // ❌ 잘못됨 - 여러 번 await 하지 마세요\n    var vt = reader.ReadByteAsync();\n    await vt;\n    await vt; // 절대 하지 마세요\n}\n```\n\n## Async Void vs Async Task\n\nasync void (드물게 발생)와 async Task (거의 항상 사용)를 언제 사용할지 이해합니다.\n\n### The Async Void Problem\n\n```csharp\n// ❌ 나쁨 - await 불가, 예외 처리 안 됨\npublic async void ProcessDataBadAsync()\n{\n    await Task.Delay(1000);\n    throw new Exception(\"Unhandled!\"); // 앱 크래시 발생\n}\n\n// ✅ 좋음 - await 가능, 예외 처리 가능\npublic async Task ProcessDataGoodAsync()\n{\n    await Task.Delay(1000);\n    throw new Exception(\"Handled!\"); // catch 가능\n}\n\n// 사용 예시\npublic async Task CallerAsync()\n{\n    try\n    {\n        // async void는 await 불가\n        ProcessDataBadAsync(); // Fire and forget - 위험함\n\n        // async Task는 await 가능\n        await ProcessDataGoodAsync(); // 여기서 예외 catch됨\n    }\n    catch (Exception ex)\n    {\n        Console.WriteLine($\"Caught: {ex.Message}\");\n    }\n}\n```\n\n### The Only Valid Use of Async Void\n\n```csharp\n// ✅ 이벤트 핸들러 - 유일하게 허용되는 사례\npublic partial class MainWindow : Window\n{\n    public async void SaveButton_Click(object sender, RoutedEventArgs e)\n    {\n        try\n        {\n            await SaveDataAsync();\n            MessageBox.Show(\"Saved successfully!\");\n        }\n        catch (Exception ex)\n        {\n            MessageBox.Show($\"Error: {ex.Message}\");\n        }\n    }\n\n    private async Task SaveDataAsync()\n    {\n        await _repository.SaveAsync(_data);\n    }\n}\n```\n\n## ConfigureAwait(false)\n\n라이브러리 코드에서 성능을 위해 synchronization context 캡처를 제어합니다.\n\n### Understanding ConfigureAwait\n\n```csharp\n// 라이브러리 코드 - ConfigureAwait(false) 사용\npublic class DataService\n{\n    public async Task<Data> GetDataAsync(int id)\n    {\n        // ConfigureAwait(false) - 컨텍스트를 캡처하지 않음\n        var json = await _httpClient.GetStringAsync($\"/api/data/{id}\")\n            .ConfigureAwait(false);\n\n        var data = await DeserializeAsync(json)\n            .ConfigureAwait(false);\n\n        return data;\n    }\n}\n\n// UI 코드 - ConfigureAwait(false) 사용 금지\npublic class ViewModel\n{\n    public async Task LoadDataAsync()\n    {\n        var data = await _dataService.GetDataAsync(42);\n        // 여기서 UI 컨텍스트가 필요함\n        this.DataProperty = data; // UI 업데이트\n    }\n}\n```\n\n### ConfigureAwait Patterns\n\n```csharp\npublic class AsyncLibrary\n{\n    // ✅ ConfigureAwait(false)를 사용한 라이브러리 메서드\n    public async Task<Result> ProcessAsync(string input)\n    {\n        var step1 = await Step1Async(input).ConfigureAwait(false);\n        var step2 = await Step2Async(step1).ConfigureAwait(false);\n        var step3 = await Step3Async(step2).ConfigureAwait(false);\n        return step3;\n    }\n\n    // ✅ ASP.NET Core - 어디서나 ConfigureAwait(false) 안전함\n    [HttpGet]\n    public async Task<IActionResult> GetData(int id)\n    {\n        // ASP.NET Core에는 synchronization context가 없음\n        var data = await _repository.GetAsync(id).ConfigureAwait(false);\n        return Ok(data);\n    }\n}\n```\n\n## CancellationToken Patterns\n\n오래 실행되는 작업에 대한 적절한 취약점 지원.\n\n### Basic Cancellation\n\n```csharp\npublic async Task<List<Result>> ProcessItemsAsync(\n    IEnumerable<Item> items,\n    CancellationToken cancellationToken = default)\n{\n    var results = new List<Result>();\n\n    foreach (var item in items)\n    {\n        // 취소 요청 확인\n        cancellationToken.ThrowIfCancellationRequested();\n\n        var result = await ProcessItemAsync(item, cancellationToken);\n        results.Add(result);\n    }\n\n    return results;\n}\n\n// Timeout과 함께 사용\npublic async Task<List<Result>> ProcessWithTimeoutAsync(IEnumerable<Item> items)\n{\n    using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));\n\n    try\n    {\n        return await ProcessItemsAsync(items, cts.Token);\n    }\n    catch (OperationCanceledException)\n    {\n        Console.WriteLine(\"Operation timed out\");\n        throw;\n    }\n}\n```\n\n### Advanced Cancellation Patterns\n\n```csharp\npublic class BackgroundProcessor\n{\n    private CancellationTokenSource? _cts;\n\n    public async Task StartAsync()\n    {\n        _cts = new CancellationTokenSource();\n        await ProcessLoopAsync(_cts.Token);\n    }\n\n    public void Stop()\n    {\n        _cts?.Cancel();\n    }\n\n    private async Task ProcessLoopAsync(CancellationToken cancellationToken)\n    {\n        while (!cancellationToken.IsCancellationRequested)\n        {\n            try\n            {\n                await ProcessBatchAsync(cancellationToken);\n                await Task.Delay(1000, cancellationToken);\n            }\n            catch (OperationCanceledException)\n            {\n                // 취소 시 예상되는 상황\n                break;\n            }\n        }\n    }\n\n    // 연결된 cancellation tokens (Linked cancellation tokens)\n    public async Task ProcessWithMultipleTokensAsync(\n        CancellationToken userToken,\n        CancellationToken systemToken)\n    {\n        using var linkedCts = CancellationTokenSource\n            .CreateLinkedTokenSource(userToken, systemToken);\n\n        await DoWorkAsync(linkedCts.Token);\n    }\n}\n```\n\n## Async Streams (IAsyncEnumerable)\n\nIAsyncEnumerable<T>를 사용하여 비동기적으로 데이터를 스트리밍합니다 (C# 8+).\n\n### Basic Async Streams\n\n```csharp\npublic async IAsyncEnumerable<LogEntry> ReadLogsAsync(\n    string filePath,\n    [EnumeratorCancellation] CancellationToken cancellationToken = default)\n{\n    await using var stream = File.OpenRead(filePath);\n    using var reader = new StreamReader(stream);\n\n    string? line;\n    while ((line = await reader.ReadLineAsync(cancellationToken)) != null)\n    {\n        if (TryParseLog(line, out var entry))\n        {\n            yield return entry;\n        }\n    }\n}\n\n// 비동기 스트림 소비\npublic async Task ProcessLogsAsync(string filePath)\n{\n    await foreach (var log in ReadLogsAsync(filePath))\n    {\n        Console.WriteLine($\"{log.Timestamp}: {log.Message}\");\n    }\n}\n```\n\n### Advanced Async Stream Patterns\n\n```csharp\npublic class DataStreamProcessor\n{\n    // 필터링이 포함된 비동기 스트림\n    public async IAsyncEnumerable<Event> GetEventsAsync(\n        DateTime startDate,\n        [EnumeratorCancellation] CancellationToken cancellationToken = default)\n    {\n        int page = 0;\n\n        while (true)\n        {\n            var events = await FetchPageAsync(page++, cancellationToken);\n\n            if (events.Count == 0)\n                yield break;\n\n            foreach (var evt in events.Where(e => e.Date >= startDate))\n            {\n                yield return evt;\n            }\n        }\n    }\n\n    // 비동기 스트림에 대한 LINQ 스타일 작업\n    public async IAsyncEnumerable<TResult> SelectAsync<TSource, TResult>(\n        IAsyncEnumerable<TSource> source,\n        Func<TSource, TResult> selector)\n    {\n        await foreach (var item in source)\n        {\n            yield return selector(item);\n        }\n    }\n\n    // 비동기 스트림 버퍼링 (Buffering)\n    public async IAsyncEnumerable<List<T>> BufferAsync<T>(\n        IAsyncEnumerable<T> source,\n        int bufferSize)\n    {\n        var buffer = new List<T>(bufferSize);\n\n        await foreach (var item in source)\n        {\n            buffer.Add(item);\n\n            if (buffer.Count >= bufferSize)\n            {\n                yield return buffer;\n                buffer = new List<T>(bufferSize);\n            }\n        }\n\n        if (buffer.Count > 0)\n        {\n            yield return buffer;\n        }\n    }\n}\n```\n\n## Parallel Async Operations\n\n여러 비동기 작업을 동시에 실행합니다.\n\n### Task.WhenAll and Task.WhenAny\n\n```csharp\npublic async Task<Summary> GetDashboardDataAsync()\n{\n    // 모든 작업을 동시에 시작\n    var userTask = GetUserDataAsync();\n    var ordersTask = GetOrdersAsync();\n    var analyticsTask = GetAnalyticsAsync();\n\n    // 모두 완료될 때까지 대기\n    await Task.WhenAll(userTask, ordersTask, analyticsTask);\n\n    return new Summary\n    {\n        User = await userTask,\n        Orders = await ordersTask,\n        Analytics = await analyticsTask\n    };\n}\n\n// 일부 실패 처리 (Partial failures)\npublic async Task<Results> ProcessWithPartialFailuresAsync()\n{\n    var tasks = new[]\n    {\n        ProcessTask1Async(),\n        ProcessTask2Async(),\n        ProcessTask3Async()\n    };\n\n    await Task.WhenAll(tasks.Select(async t =>\n    {\n        try\n        {\n            await t;\n        }\n        catch (Exception ex)\n        {\n            // 로그를 남기되 throw 하지 않음\n            Console.WriteLine($\"Task failed: {ex.Message}\");\n        }\n    }));\n\n    // 성공한 결과 수집\n    var results = tasks\n        .Where(t => t.IsCompletedSuccessfully)\n        .Select(t => t.Result)\n        .ToList();\n\n    return new Results { Successful = results };\n}\n```\n\n### Task.WhenAny for Timeouts and Racing\n\n```csharp\npublic async Task<T> WithTimeoutAsync<T>(Task<T> task, TimeSpan timeout)\n{\n    var delayTask = Task.Delay(timeout);\n    var completedTask = await Task.WhenAny(task, delayTask);\n\n    if (completedTask == delayTask)\n    {\n        throw new TimeoutException(\"Operation timed out\");\n    }\n\n    return await task;\n}\n\n// 여러 소스 간 레이싱 (Racing multiple sources)\npublic async Task<Data> GetFastestDataAsync()\n{\n    var primaryTask = GetFromPrimaryAsync();\n    var secondaryTask = GetFromSecondaryAsync();\n    var cacheTask = GetFromCacheAsync();\n\n    var completedTask = await Task.WhenAny(primaryTask, secondaryTask, cacheTask);\n    return await completedTask;\n}\n\n// Throttled parallel processing (동시성 제한 병렬 처리)\npublic async Task<List<Result>> ProcessWithThrottlingAsync(\n    IEnumerable<Item> items,\n    int maxConcurrency)\n{\n    var semaphore = new SemaphoreSlim(maxConcurrency);\n    var tasks = items.Select(async item =>\n    {\n        await semaphore.WaitAsync();\n        try\n        {\n            return await ProcessItemAsync(item);\n        }\n        finally\n        {\n            semaphore.Release();\n        }\n    });\n\n    return (await Task.WhenAll(tasks)).ToList();\n}\n```\n\n## Exception Handling in Async Code\n\n비동기 메서드에 대한 적절한 예외 처리 패턴.\n\n### Basic Exception Handling\n\n```csharp\npublic async Task<Result> ProcessWithErrorHandlingAsync()\n{\n    try\n    {\n        var data = await FetchDataAsync();\n        return await ProcessDataAsync(data);\n    }\n    catch (HttpRequestException ex)\n    {\n        _logger.LogError(ex, \"Network error occurred\");\n        throw;\n    }\n    catch (Exception ex)\n    {\n        _logger.LogError(ex, \"Unexpected error occurred\");\n        return Result.Failed(ex.Message);\n    }\n}\n\n// Task.WhenAll과 함께 사용하는 예외 처리\npublic async Task ProcessMultipleAsync()\n{\n    var tasks = new[] { Task1Async(), Task2Async(), Task3Async() };\n\n    try\n    {\n        await Task.WhenAll(tasks);\n    }\n    catch (Exception ex)\n    {\n        // 첫 번째 예외만 throw됨\n        _logger.LogError(ex, \"At least one task failed\");\n\n        // 모든 예외를 가져오려면:\n        var exceptions = tasks\n            .Where(t => t.IsFaulted)\n            .Select(t => t.Exception)\n            .ToList();\n\n        foreach (var exception in exceptions)\n        {\n            _logger.LogError(exception, \"Task failed\");\n        }\n    }\n}\n```\n\n### AggregateException Handling\n\n```csharp\npublic async Task HandleAllExceptionsAsync()\n{\n    var tasks = Enumerable.Range(1, 10)\n        .Select(i => ProcessItemAsync(i))\n        .ToArray();\n\n    try\n    {\n        await Task.WhenAll(tasks);\n    }\n    catch\n    {\n        // 모든 예외 조사\n        var aggregateException = new AggregateException(\n            tasks.Where(t => t.IsFaulted)\n                .SelectMany(t => t.Exception?.InnerExceptions ?? Array.Empty<Exception>())\n        );\n\n        aggregateException.Handle(ex =>\n        {\n            if (ex is HttpRequestException)\n            {\n                _logger.LogWarning(ex, \"Network error - retrying\");\n                return true; // 처리됨 (Handled)\n            }\n            return false; // 다시 throw (Rethrow)\n        });\n    }\n}\n```\n\n## Deadlock Prevention\n\n비동기 코드에서 흔히 발생하는 데드락 상황을 피합니다.\n\n### Common Deadlock Patterns\n\n```csharp\n// ❌ DEADLOCK - 비동기 코드에서 blocking 발생\npublic void DeadlockExample()\n{\n    // UI 또는 ASP.NET 컨텍스트에서 데드락 발생\n    var result = GetDataAsync().Result;\n\n    // 이것 또한 데드락 발생 가능\n    GetDataAsync().Wait();\n}\n\n// ✅ 올바름 - 끝까지 비동기 유지 (async all the way)\npublic async Task CorrectExample()\n{\n    var result = await GetDataAsync();\n}\n\n// ✅ 올바름 - 라이브러리 코드에서 ConfigureAwait(false) 사용\npublic async Task<Data> LibraryMethodAsync()\n{\n    var data = await FetchAsync().ConfigureAwait(false);\n    return ProcessData(data);\n}\n```\n\n### Avoiding Deadlocks\n\n```csharp\npublic class DeadlockFreeService\n{\n    // ✅ 끝까지 비동기 유지\n    public async Task<Result> ProcessAsync()\n    {\n        var data = await GetDataAsync();\n        var processed = await ProcessDataAsync(data);\n        return processed;\n    }\n\n    // ✅ 부득이하게 block 해야 한다면 Task.Run 사용\n    public Result ProcessSync()\n    {\n        return Task.Run(async () => await ProcessAsync()).GetAwaiter().GetResult();\n    }\n\n    // ✅ 비동기 disposal 사용 (Async disposal)\n    public async Task UseResourceAsync()\n    {\n        await using var resource = new AsyncDisposableResource();\n        await resource.ProcessAsync();\n    }\n}\n```\n\n## Async in ASP.NET Core\n\nASP.NET Core 애플리케이션의 비동기 코드 모범 사례.\n\n### Controller Async Patterns\n\n```csharp\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class ProductsController : ControllerBase\n{\n    private readonly IProductRepository _repository;\n\n    // ✅ Async 액션 메서드\n    [HttpGet(\"{id}\")]\n    public async Task<ActionResult<Product>> GetProduct(\n        int id,\n        CancellationToken cancellationToken)\n    {\n        var product = await _repository.GetByIdAsync(id, cancellationToken);\n\n        if (product == null)\n            return NotFound();\n\n        return Ok(product);\n    }\n\n    [HttpPost]\n    public async Task<ActionResult<Product>> CreateProduct(\n        [FromBody] CreateProductRequest request,\n        CancellationToken cancellationToken)\n    {\n        var product = await _repository.CreateAsync(request, cancellationToken);\n        return CreatedAtAction(nameof(GetProduct), new { id = product.Id }, product);\n    }\n\n    // ✅ IAsyncEnumerable을 사용한 응답 스트리밍\n    [HttpGet(\"stream\")]\n    public async IAsyncEnumerable<Product> StreamProducts(\n        [EnumeratorCancellation] CancellationToken cancellationToken)\n    {\n        await foreach (var product in _repository.GetAllStreamAsync(cancellationToken))\n        {\n            yield return product;\n        }\n    }\n}\n```\n\n### Background Services\n\n```csharp\npublic class DataProcessorService : BackgroundService\n{\n    private readonly IServiceProvider _serviceProvider;\n    private readonly ILogger<DataProcessorService> _logger;\n\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        _logger.LogInformation(\"Data processor service starting\");\n\n        while (!stoppingToken.IsCancellationRequested)\n        {\n            try\n            {\n                await ProcessDataBatchAsync(stoppingToken);\n                await Task.Delay(TimeSpan.FromMinutes(5), stoppingToken);\n            }\n            catch (OperationCanceledException)\n            {\n                // 중지 시 예상되는 상황\n                break;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error processing data batch\");\n                await Task.Delay(TimeSpan.FromSeconds(30), stoppingToken);\n            }\n        }\n\n        _logger.LogInformation(\"Data processor service stopped\");\n    }\n\n    private async Task ProcessDataBatchAsync(CancellationToken cancellationToken)\n    {\n        using var scope = _serviceProvider.CreateScope();\n        var repository = scope.ServiceProvider.GetRequiredService<IDataRepository>();\n\n        await repository.ProcessBatchAsync(cancellationToken);\n    }\n}\n```\n\n## Best Practices\n\n1. **Async All the Way**: .Result나 .Wait()를 사용하여 비동기 코드를 block 하지 마세요.\n2. **Use CancellationToken**: 오래 실행되는 작업에는 항상 CancellationToken을 받도록 하세요.\n3. **ConfigureAwait in Libraries**: 라이브러리 코드에서는 ConfigureAwait(false)를 사용하세요.\n4. **Avoid Async Void**: 이벤트 핸들러용으로만 async void를 사용하세요.\n5. **Return Task Directly**: 가능하면 await 없이 Task를 직접 반환하세요.\n6. **Use ValueTask for Hot Paths**: 자주 호출되거나 동기적으로 실행되는 경우가 많은 메서드에는 ValueTask를 고려하세요.\n7. **Handle All Exceptions**: 비동기 메서드에서는 항상 예외를 처리하세요.\n8. **Don't Mix Blocking and Async**: 하나의 호출 체인에는 하나의 패러다임만 선택하세요.\n9. **Dispose Async Resources**: IAsyncDisposable에는 await using을 사용하세요.\n10. **Test with Cancellation**: 취소가 올바르게 작동하는지 테스트하세요.\n\n## Common Pitfalls\n\n1. **Blocking on Async Code**: .Result나 .Wait() 사용은 데드락을 유발합니다.\n2. **Forgetting ConfigureAwait**: 라이브러리에서 성능 문제를 일으킬 수 있습니다.\n3. **Async Void Methods**: await가 불가능하며 예외를 삼켜버립니다.\n4. **Not Handling Cancellation**: CancellationToken 파라미터를 무시하는 것.\n5. **Over-using Task.Run**: 이미 비동기인 코드를 Task.Run으로 감싸지 마세요.\n6. **Capturing Context Unnecessarily**: 컨텍스트가 필요 없는 상황에서 리소스를 낭비합니다.\n7. **Fire and Forget**: await 없이 비동기 작업을 시작하는 것.\n8. **Mixing Sync and Async**: 혼란을 야기하고 잠재적인 데드락을 만듭니다.\n9. **Not Using ValueTask Correctly**: ValueTask를 여러 번 await 하는 것.\n10. **Ignoring Exceptions in Task.WhenAll**: 첫 번째 예외만 catch 하는 것.\n\n## When to Use\n\n다음을 수행할 때 이 SKILL을 사용합니다:\n\n- C#에서 비동기 코드 작성\n- I/O 바운드 작업 구현 (데이터베이스, 네트워크, 파일 시스템)\n- 반응형 UI 애플리케이션 구축\n- 확장 가능한 웹 서비스 구축\n- 데이터 스트림 처리\n- 취소 지원(Cancellation support) 구현\n- ValueTask를 통한 비동기 성능 최적화\n- 병렬 비동기 작업 처리\n- 비동기 코드의 데드락 방지\n- ASP.NET Core 비동기 패턴 작업\n\n## Resources\n\n- [Async/Await Best Practices](https://learn.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming)\n- [ConfigureAwait FAQ](https://devblogs.microsoft.com/dotnet/configureawait-faq/)\n- [Async Streams Tutorial](https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/async-streams)\n- [ValueTask Overview](https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/)\n- [Task-based Asynchronous Pattern (TAP)](https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap)"
              },
              {
                "name": "csharp-developer",
                "description": "모던 .NET 개발, ASP.NET Core 및 클라우드 네이티브 애플리케이션을 전문으로 하는 전문가 수준의 C# 개발자입니다. C# 14 기능, Blazor 및 크로스 플랫폼 개발을 마스터했으며 성능과 Clean Architecture를 강조합니다.",
                "path": "icartsh-plugin/skills/csharp-developer/SKILL.md",
                "frontmatter": {
                  "name": "csharp-developer",
                  "description": "모던 .NET 개발, ASP.NET Core 및 클라우드 네이티브 애플리케이션을 전문으로 하는 전문가 수준의 C# 개발자입니다. C# 14 기능, Blazor 및 크로스 플랫폼 개발을 마스터했으며 성능과 Clean Architecture를 강조합니다.",
                  "tools": "Read, Write, Bash, Glob, Grep, dotnet, msbuild, nuget, xunit, resharper, dotnet-ef"
                },
                "content": "당신은 .NET 8+ 및 Microsoft 에코시스템을 마스터한 시니어 C# 개발자로서, 고성능 웹 애플리케이션, 클라우드 네이티브 솔루션 및 크로스 플랫폼 개발 구축을 전문으로 합니다. 귀하의 전문 지식은 ASP.NET Core, Blazor, Entity Framework Core 및 클린 코드와 아키텍처 패턴에 중점을 둔 모던 C# 언어 기능을 아우릅니다.\n\n\n호출 시 수행할 작업:\n1. 기존 .NET 솔루션 구조 및 프로젝트 구성에 대해 컨텍스트 매니저에 쿼리합니다.\n2. .csproj 파일, NuGet 패키지 및 솔루션 아키텍처를 검토합니다.\n3. C# 패턴, nullable reference types 사용 현황 및 성능 특성을 분석합니다.\n4. 모던 C# 기능과 .NET 모범 사례를 활용하여 솔루션을 구현합니다.\n\nC# 개발 체크리스트:\n- Nullable reference types 활성화 여부\n- .editorconfig를 이용한 코드 분석\n- StyleCop 및 분석기(Analyzer) 준수\n- 테스트 커버리지 80% 초과\n- API versioning 구현\n- 성능 프로파일링 완료\n- 보안 스캔 통과\n- XML 문서 생성\n\n모던 C# 패턴:\n- 불변성(Immutability)을 위한 Record types\n- Pattern matching 표현식\n- Nullable reference types 규율\n- Async/await 모범 사례\n- LINQ 최적화 기법\n- Expression trees 활용\n- Source generators 도입\n- Global using 디렉티브\n\nASP.NET Core 숙련도:\n- 마이크로서비스를 위한 Minimal APIs\n- Middleware 파이프라인 최적화\n- Dependency injection 패턴\n- Configuration 및 options\n- Authentication/authorization\n- 커스텀 모델 바인딩\n- Output caching 전략\n- Health checks 구현\n\nBlazor 개발:\n- 컴포넌트 아키텍처 설계\n- 상태 관리(State management) 패턴\n- JavaScript interop\n- WebAssembly 최적화\n- Server-side vs WASM\n- 컴포넌트 생명주기(Lifecycle)\n- Form 검증\n- SignalR을 이용한 실시간 기능\n\nEntity Framework Core:\n- Code-first migrations\n- 쿼리 최적화\n- 복잡한 관계(Relationship) 처리\n- 성능 튜닝\n- 벌크 작업(Bulk operations)\n- Compiled queries\n- Change tracking 최적화\n- 다중 테넌시(Multi-tenancy) 구현\n\n성능 최적화:\n- Span<T> 및 Memory<T> 사용\n- 할당(Allocation)을 줄이기 위한 ArrayPool\n- ValueTask 패턴\n- SIMD 작업\n- Source generators\n- AOT 컴파일 준비\n- Trimming 호환성\n- Benchmark.NET 프로파일링\n\n클라우드 네이티브 패턴:\n- 컨테이너 최적화\n- Kubernetes health probes\n- 분산 캐싱(Distributed caching)\n- Service bus 연동\n- Azure SDK 모범 사례\n- Dapr 연동\n- Feature flags\n- Circuit breaker 패턴\n\n테스트 우수성:\n- Theories를 포함한 xUnit\n- 통합 테스트(Integration testing)\n- TestServer 사용\n- Moq를 이용한 모킹(Mocking)\n- Property-based testing\n- 성능 테스트\n- Playwright를 이용한 E2E\n- Test data builders\n\n비동기 프로그래밍:\n- ConfigureAwait 사용\n- Cancellation tokens\n- Async streams\n- Parallel.ForEachAsync\n- 생산자를 위한 Channels\n- Task composition\n- 예외 처리\n- 데드락(Deadlock) 방지\n\n크로스 플랫폼 개발:\n- 모바일/데스크톱을 위한 MAUI\n- 플랫폼별 코드(Platform-specific code) 작성\n- 네이티브 Interop\n- 리소스 관리\n- 플랫폼 감지\n- 조건부 컴파일(Conditional compilation)\n- 게시(Publishing) 전략\n- Self-contained 배포\n\n아키텍처 패턴:\n- Clean Architecture 설정\n- Vertical slice architecture\n- CQRS를 위한 MediatR\n- 도메인 이벤트(Domain events)\n- Specification 패턴\n- Repository 추상화\n- Result 패턴\n- Options 패턴\n\n## MCP Tool Suite\n- **dotnet**: 빌드, 테스트, 게시를 위한 CLI\n- **msbuild**: 복잡한 프로젝트를 위한 빌드 엔진\n- **nuget**: 패키지 관리 및 게시\n- **xunit**: Theories를 지원하는 테스트 프레임워크\n- **resharper**: 코드 분석 및 리팩토링\n- **dotnet-ef**: Entity Framework Core 도구\n\n## Communication Protocol\n\n### .NET Project Assessment\n\n.NET 솔루션 아키텍처와 요구 사항을 이해하여 개발을 시작합니다.\n\nSolution query:\n```json\n{\n  \"requesting_agent\": \"csharp-developer\",\n  \"request_type\": \"get_dotnet_context\",\n  \"payload\": {\n    \"query\": \".NET context needed: target framework, project types, Azure services, database setup, authentication method, and performance requirements.\"\n  }\n}\n```\n\n## Development Workflow\n\n체계적인 단계를 통해 C# 개발을 실행합니다:\n\n### 1. Solution Analysis\n\n.NET 아키텍처와 프로젝트 구조를 이해합니다.\n\n분석 우선순위:\n- 솔루션 구성\n- 프로젝트 종속성\n- NuGet 패키지 감사\n- 대상 프레임워크 (Target frameworks)\n- 코드 스타일 설정\n- 테스트 프로젝트 설정\n- 빌드 구성\n- 배포 대상\n\n기술 평가:\n- Nullable annotations 검토\n- 비동기 패턴(Async patterns) 확인\n- LINQ 사용 현황 분석\n- 메모리 패턴 평가\n- DI 설정 검토\n- 보안 설정 확인\n- API 설계 평가\n- 사용된 패턴 문서화\n\n### 2. Implementation Phase\n\n모던 C# 기능을 사용하여 .NET 솔루션을 개발합니다.\n\n구현 중점 사항:\n- Primary constructors 사용\n- File-scoped namespaces 적용\n- Pattern matching 활용\n- Records를 이용한 구현\n- Nullable reference types 사용\n- 효율적인 LINQ 적용\n- 불변(Immutable) API 설계\n- Extension methods 생성\n\n개발 패턴:\n- 도메인 모델(Domain models)부터 시작\n- 핸들러를 위해 MediatR 사용\n- Validation attributes 적용\n- Repository 패턴 구현\n- 서비스 추상화 작성\n- 설정을 위해 options 패턴 사용\n- 캐싱 전략 적용\n- 구조화된 로깅(Structured logging) 설정\n\n상태 업데이트:\n```json\n{\n  \"agent\": \"csharp-developer\",\n  \"status\": \"implementing\",\n  \"progress\": {\n    \"projects_updated\": [\"API\", \"Domain\", \"Infrastructure\"],\n    \"endpoints_created\": 18,\n    \"test_coverage\": \"84%\",\n    \"warnings\": 0\n  }\n}\n```\n\n### 3. Quality Verification\n\n.NET 모범 사례와 성능을 보장합니다.\n\n품질 체크리스트:\n- 코드 분석 통과\n- StyleCop 클린 상태\n- 테스트 통과\n- 커버리지 목표 달성\n- API 문서화 완료\n- 성능 검증 완료\n- 보안 스캔 클린 상태\n- NuGet 감사 통과\n\n완료 메시지 (예시):\n\".NET 구현이 완료되었습니다. Blazor WASM 프런트엔드를 포함한 ASP.NET Core 8 API를 전달했으며, p95 응답 시간 20ms를 달성했습니다. Compiled queries를 포함한 EF Core, 분산 캐싱, 포괄적인 테스트(86% 커버리지), 그리고 메모리를 40% 절감하는 AOT 준비 설정이 포함되어 있습니다.\"\n\nMinimal API 패턴:\n- Endpoint filters\n- Route groups\n- OpenAPI 통합\n- 모델 검증\n- 에러 처리\n- Rate limiting\n- 버전 관리(Versioning) 설정\n- 인증 흐름(Authentication flow)\n\nBlazor 패턴:\n- 컴포넌트 합성(Component composition)\n- Cascading parameters\n- Event callbacks\n- Render fragments\n- Component parameters\n- State containers\n- JS isolation\n- CSS isolation\n\ngRPC 구현:\n- 서비스 정의\n- Client factory 설정\n- Interceptors\n- 스트리밍 패턴\n- 에러 처리\n- 성능 튜닝\n- 코드 생성\n- Health checks\n\nAzure 통합:\n- App Configuration\n- Key Vault secrets\n- Service Bus messaging\n- Cosmos DB 사용\n- Blob storage\n- Azure Functions\n- Application Insights\n- Managed Identity\n\n실시간 기능:\n- SignalR hubs\n- 연결 관리(Connection management)\n- 그룹 브로드캐스팅(Group broadcasting)\n- 인증\n- 확장 전략(Scaling strategies)\n- Backplane 설정\n- 클라이언트 라이브러리\n- 재연결(Reconnection) 로직\n\n다른 에이전트와의 협업:\n- frontend-developer와 API 공유\n- api-designer에게 계약(Contract) 제공\n- 클라우드 관련하여 azure-specialist와 협업\n- EF Core 관련하여 database-optimizer와 작업\n- 컴포넌트 관련하여 blazor-developer 지원\n- .NET 통합 관련하여 powershell-dev 가이드\n- OWASP 준수 관련하여 security-auditor 지원\n- 배포 관련하여 devops-engineer 보조\n\n최신 C# 언어 기능과 .NET 플랫폼 기능을 활용하면서 항상 성능, 보안 및 유지보수성을 최우선으로 고려합니다."
              },
              {
                "name": "docker-workflow",
                "description": "멀티 스테이지 빌드(multi-stage builds), docker-compose 오케스트레이션, 이미지 최적화, 디버깅 및 운영 모범 사례를 포함하는 포괄적인 Docker 컨테이너화 워크플로우입니다. 애플리케이션 컨테이너화, 개발 환경 구축 또는 Docker 배포 시 사용합니다.",
                "path": "icartsh-plugin/skills/docker-workflow/SKILL.md",
                "frontmatter": {
                  "name": "docker-workflow",
                  "description": "멀티 스테이지 빌드(multi-stage builds), docker-compose 오케스트레이션, 이미지 최적화, 디버깅 및 운영 모범 사례를 포함하는 포괄적인 Docker 컨테이너화 워크플로우입니다. 애플리케이션 컨테이너화, 개발 환경 구축 또는 Docker 배포 시 사용합니다."
                },
                "content": "# Docker Workflow\n\n## Overview\n\nDocker 컨테이너화는 애플리케이션과 그 종속성을 이식 가능하고 재현 가능한 컨테이너로 패키징하여 개발, 테스트 및 배포를 능률화합니다. 이 SKILL은 개발부터 운영에 이르기까지 전문적인 Docker 워크플로우를 안내합니다.\n\n## Core Capabilities\n\n- **멀티 스테이지 빌드 (Multi-stage builds)**: 최적의 이미지 크기를 위해 빌드와 런타임 종속성을 분리합니다.\n- **Docker Compose 오케스트레이션**: 네트워킹과 종속성을 갖춘 다중 컨테이너 애플리케이션을 관리합니다.\n- **이미지 최적화**: 모범 사례를 통해 이미지 크기를 50-90% 줄입니다.\n- **개발 워크플로우**: Hot-reload, 볼륨 마운트 및 환경별 설정을 지원합니다.\n- **디버깅 도구**: 컨테이너 조사, health checks 및 트러블슈팅 유틸리티를 제공합니다.\n- **운영 준비 (Production readiness)**: 보안 강화(Security hardening), health checks 및 배포 전략을 다룹니다.\n\n## When to Use This Skill\n\n다음을 수행할 때 활성화하세요:\n- 새로운 애플리케이션 컨테이너화\n- Docker로 개발 환경 구축\n- 운영 환경에 적합한 Docker 이미지 생성\n- 다중 컨테이너 애플리케이션 오케스트레이션\n- 컨테이너 이슈 디버깅\n- Docker 빌드 및 이미지 최적화\n\n## Workflow Phases\n\n### Phase 1: Initial Setup\n\n#### .dockerignore 생성\n\n빌드 컨텍스트에서 불필요한 파일을 제외합니다:\n\n```dockerignore\nnode_modules/\n__pycache__/\n*.pyc\n.git/\n.env\n*.log\ndist/\nbuild/\ncoverage/\n```\n\n포괄적인 템플릿은 `examples/.dockerignore`를 참조하세요.\n\n**핵심 원칙**:\n- 빌드 아티팩트 및 종속성 제외\n- 민감한 파일(.env, 자격 증명) 제외\n- 버전 관리 시스템(.git) 제외\n- 컨텍스트 크기 축소 = 빌드 속도 향상\n\n#### 애플리케이션 요구 사항 분석\n\n다음을 결정합니다:\n- 런타임 (Node.js, Python, Go, Java)\n- 종속성 및 패키지 매니저\n- 빌드 요구 사항 vs 런타임 요구 사항\n- 포트 노출 및 볼륨 필요성\n\n### Phase 2: Multi-Stage Dockerfile\n\n#### 전략 선택\n\n멀티 스테이지 빌드는 최종 이미지 크기를 50-90% 줄여줍니다:\n\n```dockerfile\n# Stage 1: Build\nFROM node:18-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --only=production\nCOPY . .\nRUN npm run build\n\n# Stage 2: Production\nFROM node:18-alpine\nWORKDIR /app\nCOPY --from=builder /app/dist ./dist\nCOPY --from=builder /app/node_modules ./node_modules\nEXPOSE 3000\nCMD [\"node\", \"dist/index.js\"]\n```\n\nNode.js, Python, Go, Java, Rust 템플릿은 `examples/Dockerfile.multi-stage`를 참조하세요.\n\n#### 레이어 캐싱 최적화 (Optimize Layer Caching)\n\n순서가 중요합니다 - 자주 변경되는 콘텐츠는 마지막에 배치하세요:\n\n```dockerfile\n# ✅ 좋음: 종속성이 별도로 캐시됨\nCOPY package.json package-lock.json ./\nRUN npm ci\nCOPY . .\n\n# ❌ 나쁨: 파일이 하나만 변경되어도 캐시가 무효화됨\nCOPY . .\nRUN npm ci\n```\n\n#### 보안 모범 사례 적용\n\n```dockerfile\n# 특정 버전 사용\nFROM node:18.17.1-alpine\n\n# non-root 사용자로 실행\nRUN addgroup -g 1001 -S nodejs && adduser -S nodejs -u 1001\nUSER nodejs\n\n# 소유권과 함께 복사\nCOPY --chown=nodejs:nodejs . .\n```\n\n**보안 체크리스트**:\n- 베이스 이미지 버전 고정 (Pin versions)\n- 최소한의 베이스 이미지 사용 (alpine, slim)\n- non-root 사용자로 실행\n- 취약점 스캔 실시\n- 설치 패키지 최소화\n\n### Phase 3: Docker Compose Setup\n\n#### 서비스 정의\n\n`docker-compose.yml`을 생성합니다:\n\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    ports:\n      - \"3000:3000\"\n    environment:\n      - DATABASE_URL=postgresql://db:5432/myapp\n    depends_on:\n      db:\n        condition: service_healthy\n    volumes:\n      - ./src:/app/src  # 개발 시 hot-reload\n    networks:\n      - app-network\n\n  db:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_DB: myapp\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U user\"]\n      interval: 5s\n    networks:\n      - app-network\n\nvolumes:\n  postgres-data:\n\nnetworks:\n  app-network:\n```\n\n모니터링, 큐, 캐싱이 포함된 전체 기능 설정은 `examples/docker-compose.yml`을 참조하세요.\n\n#### 환경 설정\n\n환경별로 override 파일을 사용합니다:\n\n**개발용 (docker-compose.override.yml)**:\n```yaml\nservices:\n  app:\n    build:\n      target: development\n    volumes:\n      - ./src:/app/src\n    environment:\n      - NODE_ENV=development\n    command: npm run dev\n```\n\n**운영용 (docker-compose.prod.yml)**:\n```yaml\nservices:\n  app:\n    build:\n      target: production\n    restart: always\n    environment:\n      - NODE_ENV=production\n```\n\n**사용법**:\n```bash\n# 개발 (override 파일이 자동으로 사용됨)\ndocker-compose up\n\n# 운영\ndocker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d\n```\n\n### Phase 4: Build and Run\n\n#### 빌드 명령\n\n```bash\n# 기본 빌드\ndocker build -t myapp:latest .\n\n# 특정 스테이지 빌드\ndocker build --target production -t myapp:prod .\n\n# BuildKit을 사용한 빌드 (빠름)\nDOCKER_BUILDKIT=1 docker build -t myapp:latest .\n```\n\n#### 실행 명령\n\n```bash\n# 단일 컨테이너\ndocker run -d -p 3000:3000 -e NODE_ENV=production myapp:latest\n\n# Docker Compose\ndocker-compose up -d\n\n# 로그 확인\ndocker-compose logs -f app\n\n# 컨테이너 내 명령 실행\ndocker-compose exec app sh\n\n# 중지 및 제거\ndocker-compose down -v\n```\n\n### Phase 5: Debugging and Troubleshooting\n\n#### Helper 스크립트 사용\n\n`scripts/docker_helper.sh` 유틸리티는 일반적인 디버깅 작업을 제공합니다:\n\n```bash\n# 컨테이너 상태 체크\n./scripts/docker_helper.sh health myapp\n\n# 상세 정보 조사\n./scripts/docker_helper.sh inspect myapp\n\n# 로그 확인\n./scripts/docker_helper.sh logs myapp 200\n\n# Shell 열기\n./scripts/docker_helper.sh shell myapp\n\n# 이미지 크기 분석\n./scripts/docker_helper.sh size myapp:latest\n\n# 리소스 정리 (Cleanup)\n./scripts/docker_helper.sh cleanup\n```\n\n#### 일반적인 이슈\n\n**컨테이너가 즉시 종료되는 경우**:\n```bash\ndocker logs myapp\ndocker run -it --entrypoint sh myapp:latest\n```\n\n**네트워크 연결성**:\n```bash\ndocker network inspect myapp_default\ndocker exec myapp ping db\n```\n\n**볼륨 권한**:\n```bash\n# Dockerfile에서 수정\nRUN chown -R nodejs:nodejs /app/data\n```\n\n### Phase 6: Optimization\n\n#### 이미지 크기 축소\n\n**전략**:\n1. 더 작은 베이스 이미지 사용 (alpine > slim > debian)\n2. 빌드 도구 제외를 위해 멀티 스테이지 빌드 활용\n3. 레이어 수를 줄이기 위해 RUN 명령 결합\n4. 동일한 레이어 내에서 정리(Clean up) 수행\n5. .dockerignore 활용\n\n**예시**:\n```dockerfile\n# ✅ 좋음: 결합 및 정리 완료\nRUN apt-get update && \\\n    apt-get install -y --no-install-recommends package1 && \\\n    apt-get clean && \\\n    rm -rf /var/lib/apt/lists/*\n```\n\n#### 빌드 성능\n\n```bash\n# BuildKit 활성화\nexport DOCKER_BUILDKIT=1\n\n# 캐시 마운트(Cache mounts) 사용\nRUN --mount=type=cache,target=/root/.cache/pip \\\n    pip install -r requirements.txt\n\n# 병렬 빌드\ndocker-compose build --parallel\n```\n\n### Phase 7: Production Deployment\n\n#### 운영 환경용 Dockerfile\n\n```dockerfile\nFROM node:18-alpine AS production\n\n# 보안: non-root 사용자\nRUN addgroup -g 1001 -S nodejs && adduser -S nodejs -u 1001\n\nWORKDIR /app\nCOPY --from=builder --chown=nodejs:nodejs /app/dist ./dist\nUSER nodejs\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s \\\n  CMD node healthcheck.js\n\nEXPOSE 3000\nCMD [\"node\", \"dist/index.js\"]\n```\n\n#### 배포 명령\n\n```bash\n# Registry용 태그 지정\ndocker tag myapp:latest registry.example.com/myapp:v1.0.0\n\n# Registry로 Push\ndocker push registry.example.com/myapp:v1.0.0\n\n# 배포\ndocker-compose pull && docker-compose up -d\n\n# 무중단 업데이트 (Rolling update)\ndocker-compose up -d --no-deps --build app\n```\n\n## Common Patterns\n\n### Full-Stack Application\n- Frontend + Backend + Database + Redis\n- `examples/docker-compose.yml` 참조\n\n### Microservices\n- API Gateway + Multiple Services + Message Queue\n- 네트워크 격리(Network isolation) 및 서비스 검색(Service discovery)\n\n### 개발 시 Hot Reload 적용\n- 소스 코드를 위한 볼륨 마운트\n- 개발 설정을 위한 override 파일\n\n## Best Practices Summary\n\n### Security (보안)\n✅ `latest`가 아닌 구체적인 이미지 버전 사용\n✅ non-root 사용자로 실행\n✅ 민감한 데이터에는 secrets management 사용\n✅ 이미지의 취약점 스캔 실시\n✅ 최소한의 베이스 이미지 사용\n\n### Performance (성능)\n✅ 멀티 스테이지 빌드 사용\n✅ 레이어 캐싱 최적화\n✅ .dockerignore 사용\n✅ RUN 명령 결합\n✅ BuildKit 사용\n\n### Development (개발)\n✅ 다중 컨테이너 앱에 docker-compose 사용\n✅ hot-reload를 위해 볼륨(Volumes) 사용\n✅ health checks 구현\n✅ 적절한 종속성 순서 적용\n\n### Production (운영)\n✅ 재시작 정책(Restart policies) 설정\n✅ 오케스트레이션(Swarm, Kubernetes) 사용\n✅ health checks로 모니터링\n✅ Reverse proxy 사용\n✅ Rolling updates 구현\n\n## Helper Resources\n\n- **scripts/docker_helper.sh**: 컨테이너 조사, health checks, 자동화\n- **examples/Dockerfile.multi-stage**: Node.js, Python, Go, Java, Rust용 템플릿\n- **examples/docker-compose.yml**: 전체 기능을 갖춘 멀티 서비스 설정\n- **examples/.dockerignore**: 포괄적인 무시(Ignore) 패턴\n\n## Quick Reference\n\n### Essential Commands\n\n```bash\n# 빌드\ndocker build -t myapp .\ndocker-compose build\n\n# 실행\ndocker run -d -p 3000:3000 myapp\ndocker-compose up -d\n\n# 로그\ndocker logs -f myapp\ndocker-compose logs -f\n\n# 실행 (Execute)\ndocker exec -it myapp sh\ndocker-compose exec app sh\n\n# 중지\ndocker-compose down\n\n# 정리 (Clean)\ndocker system prune -a\n```\n\n### Debugging\n\n```bash\n# 조사 (Inspect)\ndocker inspect myapp\n\n# 상태 (Stats)\ndocker stats myapp\n\n# 네트워크\ndocker network inspect bridge\n\n# 볼륨\ndocker volume ls\n```"
              },
              {
                "name": "dotnet-build",
                "description": "dotnet CLI를 사용하여 .NET 솔루션/프로젝트를 빌드합니다. 컴파일, 종속성 복원 또는 아티팩트 빌드 작업 시 사용합니다.",
                "path": "icartsh-plugin/skills/dotnet-build/SKILL.md",
                "frontmatter": {
                  "name": "dotnet-build",
                  "version": "0.2.0",
                  "kind": "cli",
                  "description": "dotnet CLI를 사용하여 .NET 솔루션/프로젝트를 빌드합니다. 컴파일, 종속성 복원 또는 아티팩트 빌드 작업 시 사용합니다.",
                  "inputs": {
                    "target": [
                      "solution",
                      "project",
                      "all"
                    ],
                    "configuration": [
                      "Debug",
                      "Release"
                    ],
                    "project_path": "string"
                  },
                  "contracts": {
                    "success": "에러 없이 빌드 완료; bin/ 디렉토리에 아티팩트 생성",
                    "failure": "0이 아닌 종료 코드 또는 컴파일 에러 발생"
                  }
                },
                "content": "# .NET Build Skill (Entry Map)\n\n> **목표:** 정확한 빌드 절차를 안내합니다.\n\n## 빠른 시작 (택일)\n\n- **전체 솔루션 빌드** → `references/build-solution.md`\n- **종속성만 복원** → `references/restore-deps.md`\n\n## 사용 시기\n\n- .NET 코드 컴파일 (`.csproj`, `.sln` 파일)\n- NuGet 패키지 및 종속성 복원\n- Debug/Release 구성 빌드\n- 빌드 아티팩트(바이너리, 어셈블리) 생성\n\n**다음의 경우에는 사용하지 마세요:** 테스트 (dotnet-test), 포맷팅 (code-format), 또는 분석 (code-analyze)\n\n## 입력 및 출력 (Inputs & Outputs)\n\n**입력:** `target` (solution/project/all), `configuration` (Debug/Release), `project_path` (기본값: ./dotnet/PigeonPea.sln)\n\n**출력:** `artifact_path` (bin/ 디렉토리), `build_log`, 종료 코드 (0=성공)\n\n**가드레일:** ./dotnet 디렉토리 내에서만 작업하며, bin/obj/ 디렉토리는 커밋하지 않습니다. 멱등성(idempotent) 있는 빌드를 지향합니다.\n\n## 탐색 (Navigation)\n\n**1. 전체 솔루션 빌드** → [`references/build-solution.md`](references/build-solution.md)\n\n- 복제(Cloning) 후 첫 빌드, 테스트 전 빌드, 릴리스 아티팩트 생성 시\n\n**2. 종속성만 복원** → [`references/restore-deps.md`](references/restore-deps.md)\n\n- 개발 환경 설정, 누락된 패키지 수정, NuGet 트러블슈팅 시\n\n## 일반적인 패턴 (Common Patterns)\n\n### 빠른 빌드 (Debug)\n\n```bash\ncd ./dotnet\ndotnet build PigeonPea.sln\n```\n\n### 빠른 빌드 (Release)\n\n```bash\ncd ./dotnet\ndotnet build PigeonPea.sln --configuration Release\n```\n\n### 복원 후 빌드 (Restore then Build)\n\n```bash\ncd ./dotnet\ndotnet restore PigeonPea.sln\ndotnet build PigeonPea.sln --no-restore\n```\n\n### Clean 후 Rebuild\n\n```bash\ncd ./dotnet\ndotnet clean PigeonPea.sln\ndotnet build PigeonPea.sln\n```\n\n### 특정 프로젝트 빌드\n\n```bash\ncd ./dotnet\ndotnet build console-app/PigeonPea.Console.csproj\n```\n\n### 디버깅을 위한 상세 빌드 (Verbose Build)\n\n```bash\ncd ./dotnet\ndotnet build PigeonPea.sln --verbosity detailed\n```\n\n## 트러블슈팅 (Troubleshooting)\n\n**빌드 실패:** 에러 메시지를 확인하세요. 상세한 에러 처리는 `references/build-solution.md`를 참조하세요.\n\n**종속성 누락:** `dotnet restore`를 실행하세요. `references/restore-deps.md`를 참조하세요.\n\n**NU1301 (service index):** NuGet에 접속할 수 없습니다. `references/restore-deps.md`를 확인하세요.\n\n**빌드 속도 저하:** `--no-restore`, `-m` (병렬 처리), 또는 `/p:RunAnalyzers=false`를 사용하세요. `references/build-solution.md`를 참조하세요.\n\n**오래된 아티팩트:** `dotnet clean`을 실행한 후 다시 빌드하세요.\n\n## 성공 지표 (Success Indicators)\n\n```\nBuild succeeded.\n    0 Warning(s)\n    0 Error(s)\n```\n\n아티팩트 위치: `./dotnet/{ProjectName}/bin/{Configuration}/net9.0/`\n\n## 통합 (Integration)\n\n**빌드 후:** dotnet-test (테스트), code-analyze (정적 분석)\n**빌드 전:** code-format (스타일 수정)\n\n## 관련 링크 (Related)\n\n- [`./dotnet/README.md`](../../../dotnet/README.md) - 프로젝트 구조\n- [`./dotnet/ARCHITECTURE.md`](../../../dotnet/ARCHITECTURE.md) - 아키텍처\n- [`.pre-commit-config.yaml`](../../../.pre-commit-config.yaml) - Pre-commit hooks"
              },
              {
                "name": "dotnet-test",
                "description": "dotnet CLI를 사용하여 .NET 테스트를 실행합니다. 유닛 테스트 실행, 코드 커버리지 리포트 생성 또는 벤치마크 수행 시 사용합니다.",
                "path": "icartsh-plugin/skills/dotnet-test/SKILL.md",
                "frontmatter": {
                  "name": "dotnet-test",
                  "version": "0.1.0",
                  "kind": "cli",
                  "description": "dotnet CLI를 사용하여 .NET 테스트를 실행합니다. 유닛 테스트 실행, 코드 커버리지 리포트 생성 또는 벤치마크 수행 시 사용합니다.",
                  "inputs": {
                    "target": [
                      "all",
                      "project",
                      "specific"
                    ],
                    "configuration": [
                      "Debug",
                      "Release"
                    ],
                    "coverage": [
                      "true",
                      "false"
                    ],
                    "project_path": "string"
                  },
                  "contracts": {
                    "success": "테스트 통과 (실패 없음); 요청 시 커버리지 데이터 생성 완료",
                    "failure": "0이 아닌 종료 코드, 테스트 실패 또는 커버리지 생성 에러 발생"
                  }
                },
                "content": "# .NET Test Skill (Entry Map)\n\n> **목표:** 정확한 테스트 절차를 안내합니다.\n\n## 빠른 시작 (택일)\n\n- **유닛 테스트 실행** → `references/run-unit-tests.md`\n- **커버리지 리포트 생성** → `references/generate-coverage.md`\n- **벤치마크 실행** → `references/run-benchmarks.md`\n\n## 사용 시기\n\n- 유닛 테스트 실행 (xUnit, NUnit)\n- coverlet을 이용한 코드 커버리지 리포트 생성\n- BenchmarkDotNet을 이용한 성능 벤치마크 수행\n- 테스트 스위트를 통한 코드 변경 사항 검증\n- 테스트 실행 시간 측정\n\n**다음의 경우에는 사용하지 마세요:** 코드 빌드 (dotnet-build), 포맷팅 (code-format), 또는 정적 분석 (code-analyze)\n\n## 입력 및 출력 (Inputs & Outputs)\n\n**입력:** `target` (all/project/specific), `configuration` (Debug/Release), `coverage` (true/false), `project_path` (기본값: 모든 테스트 프로젝트)\n\n**출력:** 테스트 결과 (성공/실패 카운트), 커버리지 리포트 (요청 시), 벤치마크 결과, 종료 코드 (0=성공)\n\n**가드레일:** ./dotnet 디렉토리 내에서만 작업하며, 실패 사항을 명확히 보고하고, 허가 없이 테스트를 건너뛰지 않습니다.\n\n## 탐색 (Navigation)\n\n**1. 유닛 테스트 실행** → [`references/run-unit-tests.md`](references/run-unit-tests.md)\n\n- 모든 테스트 실행, 특정 프로젝트 테스트 실행, 테스트 실패 트러블슈팅\n\n**2. 커버리지 리포트 생성** → [`references/generate-coverage.md`](references/generate-coverage.md)\n\n- 커버리지 데이터 수집, 리포트 생성 (HTML/Cobertura), 커버리지 지표 분석\n\n**3. 벤치마크 실행** → [`references/run-benchmarks.md`](references/run-benchmarks.md)\n\n- 성능 벤치마크 수행, 결과 비교, 데이터 기반 최적화\n\n## 일반적인 패턴 (Common Patterns)\n\n### 모든 테스트 실행 (빠른 속도)\n\n```bash\ncd ./dotnet\ndotnet test\n```\n\n### 상세 출력을 포함한 테스트 실행\n\n```bash\ncd ./dotnet\ndotnet test --verbosity normal\n```\n\n### 특정 테스트 프로젝트 실행\n\n```bash\ncd ./dotnet\ndotnet test console-app.Tests/PigeonPea.Console.Tests.csproj\n```\n\n### 커버리지와 함께 테스트 실행\n\n```bash\ncd ./dotnet\ndotnet test --collect:\"XPlat Code Coverage\"\n```\n\n### 테스트 실행 및 커버리지 리포트 생성\n\n```bash\ncd ./dotnet\ndotnet test --collect:\"XPlat Code Coverage\" --results-directory ./TestResults\n# 커버리지 파일: ./TestResults/{guid}/coverage.cobertura.xml\n```\n\n### 이름으로 테스트 필터링\n\n```bash\ncd ./dotnet\ndotnet test --filter \"FullyQualifiedName~FrameTests\"\n```\n\n### 카테고리로 테스트 필터링\n\n```bash\ncd ./dotnet\ndotnet test --filter \"Category=Unit\"\n```\n\n### Release 구정으로 테스트 실행\n\n```bash\ncd ./dotnet\ndotnet test --configuration Release\n```\n\n### 벤치마크 실행\n\n```bash\ncd ./dotnet/benchmarks\ndotnet run -c Release\n```\n\n## 트러블슈팅 (Troubleshooting)\n\n**테스트 실패:** Assertion 실패에 대한 테스트 출력을 확인하세요. 디버깅은 `references/run-unit-tests.md`를 참조하세요.\n\n**커버리지 미생성:** coverlet.collector가 설치되어 있는지 확인하세요. `references/generate-coverage.md`를 참조하세요.\n\n**벤치마크 실행 실패:** Release 구성을 사용해야 합니다. `references/run-benchmarks.md`를 참조하세요.\n\n**테스트 실행 속도 저하:** 테스트 필터 사용, 병렬 실행 또는 빌드 후 `--no-build` 옵션을 사용하세요.\n\n**테스트 발견 실패:** 프로젝트 참조를 확인하고 테스트 프레임워크 패키지가 설치되어 있는지 확인하세요.\n\n## 성공 지표 (Success Indicators)\n\n```\nPassed!  - Failed:     0, Passed:    42, Skipped:     0, Total:    42\n```\n\n테스트 아티팩트 위치: `./dotnet/TestResults/`\n\n커버리지 리포트 위치: `./dotnet/TestResults/coverage.cobertura.xml`\n\n## 통합 (Integration)\n\n**테스트 전:** dotnet-build (코드가 빌드되었는지 확인)\n**테스트 후:** code-analyze (정적 분석), code-review (품질 검사)\n\n## 테스트 프레임워크\n\n이 저장소는 다음을 사용합니다:\n\n- 유닛 테스트를 위한 **xUnit** (console-app.Tests, shared-app.Tests, windows-app.Tests)\n- 코드 커버리지를 위한 **coverlet.collector**\n- 성능 벤치마크를 위한 **BenchmarkDotNet**\n\n## 관련 링크 (Related)\n\n- [`./dotnet/README.md`](../../../dotnet/README.md) - 프로젝트 구조\n- [`./dotnet/ARCHITECTURE.md`](../../../dotnet/ARCHITECTURE.md) - 아키텍처\n- [`.pre-commit-config.yaml`](../../../.pre-commit-config.yaml) - Pre-commit hooks\n- [`dotnet-build` skill](../dotnet-build/SKILL.md) - 빌드 스킬"
              },
              {
                "name": "error-detective",
                "description": "TRACE 프레임워크(Trace, Read, Analyze, Check, Execute)를 사용한 체계적인 디버깅 및 에러 해결입니다. 에러 디버깅, 스택 트레이스(stack traces) 분석, 실패 조사, 근본 원인 분석(root cause analysis) 또는 운영 이슈 트러블슈팅 시 사용합니다.",
                "path": "icartsh-plugin/skills/error-detective/SKILL.md",
                "frontmatter": {
                  "name": "error-detective",
                  "description": "TRACE 프레임워크(Trace, Read, Analyze, Check, Execute)를 사용한 체계적인 디버깅 및 에러 해결입니다. 에러 디버깅, 스택 트레이스(stack traces) 분석, 실패 조사, 근본 원인 분석(root cause analysis) 또는 운영 이슈 트러블슈팅 시 사용합니다."
                },
                "content": "# Error Detective - Systematic Debugging and Error Resolution\n\n## 개요 (Overview)\n\nError Detective는 에러를 효율적으로 식별, 분석 및 해결하기 위해 체계적인 방법론을 적용하는 종합적인 디버깅 SKILL입니다. TRACE 프레임워크와 구조화된 분석 기법을 사용하여 에러의 초기 발견부터 검증된 해결까지 디버깅 과정을 안내합니다.\n\n## 핵심 역량 (Core Capabilities)\n\n### 스택 트레이스 분석 (Stack Trace Analysis)\n- 여러 언어에 걸친 스택 트레이스 파싱 및 해석\n- 근본 원인(root cause)과 증상 에러(symptom errors) 구분\n- 관련 파일 경로 및 라인 번호 추출\n- 호출 체인 및 에러 전파 과정 이해\n\n### 에러 패턴 인식 (Error Pattern Recognition)\n- 유형별 에러 분류 (syntax, runtime, logic, integration)\n- 공통 에러 패턴 및 안티 패턴 식별\n- 프레임워크별 특화 에러 인식\n- 에러를 발생 가능한 근본 원인에 매핑\n\n### 근본 원인 분석 (Root Cause Analysis)\n- 증상과 기저 이슈의 구분\n- 에러 체인을 따라 원래 발생 지점 추적\n- 환경 이슈와 코드 이슈의 실별\n- 설정 및 종속성 문제 감지\n\n### 디버깅 워크플로우 관리\n- 구조화된 조사 프로세스\n- 가설 생성 및 테스트\n- 이해도에 대한 반복적 정밀화\n- 조사 결과 및 해결책 문서화\n\n## TRACE 프레임워크\n\nTRACE는 어떤 에러든 디버깅할 수 있는 체계적인 5단계 접근 방식입니다:\n\n### T - Trace the Error (에러 추적)\n**목표**: 완전한 에러 정보와 컨텍스트 캡처\n\n1. **전체 에러 메시지 수집**\n   - 전체 스택 트레이스 (처음 몇 줄만이 아닌 전체)\n   - 에러 유형 및 메시지\n   - 타임스탬프 및 발생 빈도\n   - 에러가 발생한 환경\n\n2. **에러 위치 식별**\n   - 정확한 파일 및 라인 번호\n   - 에러가 발생한 함수 또는 메서드\n   - 코드 컨텍스트 (주변 라인)\n   - 진입점부터 에러 지점까지의 호출 스택\n\n3. **재현 단계 갈무리**\n   - 재현을 위한 최소한의 단계\n   - 사용된 입력 데이터 또는 파라미터\n   - 기대 결과 vs. 실제 동작\n   - 재현의 일관성 (항상 발생, 간헐적 발생, 드물게 발생)\n\n### R - Read the Error Message (에러 메시지 읽기)\n**목표**: 에러 자체에서 모든 정보 추출\n\n1. **에러 구성 요소 파싱**\n   - 에러 유형/클래스 (TypeError, ValueError 등)\n   - 에러 메시지 내용\n   - 권장 수정 사항 (제공되는 경우)\n   - 관련 에러 또는 경고\n\n2. **에러 시맨틱 이해**\n   - 해당 언어/프레임워크에서 해당 에러 유형이 의미하는 바\n   - 어떤 조건이 이 에러를 유발하는지\n   - 에러 메시지가 구체적으로 무엇을 말하고 있는지\n   - 에러 코드 또는 상태 코드\n\n3. **에러 카테고리 식별**\n   - Syntax error (코드 파싱 불가)\n   - Runtime error (실행 중 크래시 발생)\n   - Logic error (결과가 틀림, 크래시 없음)\n   - Integration error (외부 시스템 실패)\n   - Performance error (타임아웃, 리소스 고갈)\n\n### A - Analyze the Context (컨텍스트 분석)\n**목표**: 에러 주변의 더 넓은 컨텍스트 이해\n\n1. **코드 분석**\n   - 실패한 라인과 주변 코드 검토\n   - 해당 코드의 최근 변경 사항 확인\n   - 함수/메서드 시그니처 및 사용법 검토\n   - 실패한 코드를 호출하거나 호출되는 관련 코드 검토\n\n2. **데이터 분석**\n   - 실패 시점의 입력값 조사\n   - 데이터 타입 및 구조 확인\n   - 데이터가 예상된 형식/제약 사항을 충족하는지 검증\n   - 엣지 케이스(edge cases) 또는 예상치 못한 값 식별\n\n3. **환경 분석**\n   - 종속성 및 버전 확인\n   - 설정 파일 검토\n   - 환경 변수 검증\n   - 필요한 리소스(파일, 네트워크, 메모리) 가용성 확인\n\n4. **상태 분석**\n   - 에러 발생 시점의 애플리케이션 상태\n   - 이 상태로 이어진 이전 작업들\n   - 관련된 공유 상태 또는 전역 변수\n   - 데이터베이스 또는 외부 시스템 상태\n\n### C - Check for Root Cause (근본 원인 확인)\n**목표**: 단순한 증상이 아닌 기저의 이슈 실별\n\n1. **에러 체인 추적**\n   - 스택 트레이스의 맨 아래(첫 번째 에러)부터 시작\n   - 상위로 거슬러 올라가며 원래 원인 탐색\n   - 에러 발생 지점과 에러 핸들러 구분\n   - 래핑되거나 다시 던져진(re-thrown) 에러 식별\n\n2. **가설 테스트**\n   - 구체적이고 테스트 가능한 가설 생성\n   - 변수 격리 (한 번에 하나씩 변경)\n   - 로깅/디버깅 도구를 사용하여 가정 검증\n   - 확인되거나 기각된 가설 문서화\n\n3. **일반적인 근본 원인**\n   - **Null/undefined 값**: 초기화 또는 검증 누락\n   - **타입 불일치 (Type mismatches)**: 잘못된 데이터 타입 전달 또는 반환\n   - **Off-by-one 에러**: 배열/루프 경계 이슈\n   - **경합 조건 (Race conditions)**: 타이밍에 따른 실패\n   - **리소스 고갈**: 메모리, 디스크, 커넥션 부족\n   - **설정 에러 (Configuration errors)**: 잘못된 설정 또는 누락된 설정\n   - **종속성 이슈 (Dependency issues)**: 버전 충돌 또는 누락된 라이브러리\n   - **권한 에러**: 불충분한 접속 권한\n   - **네트워크 에러**: 연결성, 타임아웃, DNS 이슈\n   - **데이터 손상**: 유효하지 않거나 예상치 못한 데이터 형식\n\n### E - Execute the Fix (수정 실행)\n**목표**: 해결책 구현 및 검증\n\n1. **수정 설계**\n   - 증상이 아닌 근본 원인 해결\n   - 부수 효과(side effects) 및 엣지 케이스 고려\n   - 필요한 경우 하위 호환성 계획\n   - 가장 유지보수하기 쉬운 해결책 선택\n\n2. **신중한 구현**\n   - 최소한의 타겟팅된 변경 실시\n   - 검증 및 에러 핸들링 추가\n   - 향후 디버깅을 위한 로깅 포함\n   - 수정 내용 및 근거 문서화\n\n3. **철저한 검증**\n   - 원래 에러가 해결되었는지 확인\n   - 재현 단계를 통해 테스트\n   - 엣지 케이스 및 관련 기능 테스트\n   - 새로운 에러가 도입되지 않았는지 확인\n\n4. **문서화 및 방지**\n   - 에러 유발 원인 문서화\n   - 해결책 및 작동 이유 문서화\n   - 회귀(regression) 방지를 위한 테스트 추가\n   - 필요한 경우 문서 업데이트 또는 경고 추가\n\n## 디버깅 워크플로우\n\n### 초기 평가 (5분)\n\n```\n1. 전체 에러 메시지 읽기\n2. 에러 유형 및 심각도 식별\n3. 에러 재현 가능 여부 확인\n4. 영향도 평가 (차단형, 성능 저하, 단순 외관상 문제)\n5. 조사 우선순위 결정\n```\n\n### 심층 조사 (15-30분)\n\n```\n1. TRACE 프레임워크를 체계적으로 적용\n2. 디버깅 도구 사용 (scripts/debug_helper.py 참조)\n3. 가설 생성 및 테스트\n4. 진행하면서 발견 사항 문서화\n5. 근본 원인으로 좁히기\n```\n\n### 해결책 구현 (상황에 따라 다름)\n\n```\n1. 근본 원인을 해결하는 수정 설계\n2. 적절한 에러 핸들링과 함께 구현\n3. 로깅 및 검증 추가\n4. 철저한 테스트\n5. 해결책 문서화\n```\n\n### 검증 및 방지 (10분)\n\n```\n1. 원래의 재현 단계로 수정 사항 검증\n2. 관련 기능 테스트\n3. 회귀 테스트 추가\n4. 문서 업데이트\n5. 배포 및 모니터링\n```\n\n## 언어별 공통 에러 패턴\n\n### Python\n\n**AttributeError: 'NoneType' has no attribute 'X'**\n- 근본 원인: 객체를 기대했으나 변수가 None임\n- 체크 사항: 초기화, 함수 반환값, API 응답\n- 해결책: Null 체크 추가, 적절한 초기화 보장\n\n**KeyError: 'key_name'**\n- 근본 원인: 딕셔너리에 기대한 키가 없음\n- 체크 사항: 데이터 소스, 파싱 로직, 키 철자\n- 해결책: 디폴트값과 함께 .get() 사용, 데이터 구조 검증\n\n**ImportError / ModuleNotFoundError**\n- 근본 원인: 모듈이 설치되지 않았거나 경로에 없음\n- 체크 사항: requirements.txt, 가상 환경, PYTHONPATH\n- 해결책: 누락된 패키지 설치, 임포트 경로 수정\n\n**IndentationError**\n- 근본 원인: 일관되지 않은 여백 (탭 vs 공백)\n- 체크 사항: 에디터 설정, 복사된 코드\n- 해결책: 공백(PEP 8)으로 표준화, linter 사용\n\n### JavaScript/TypeScript\n\n**TypeError: Cannot read property 'X' of undefined**\n- 근본 원인: undefined 객체의 프로퍼티에 접근\n- 체크 사항: 객체 초기화, 비동기 타이밍, API 응답\n- 해결책: 옵셔널 체이닝(?. 연산자), null 체크\n\n**ReferenceError: X is not defined**\n- 근본 원인: 선언 전 변수 사용 또는 스코프 벗어남\n- 체크 사항: 변수 선언, 스코프, 호이스팅(hoisting) 이슈\n- 해결책: 변수 선언, 스코프 수정, 임포트 확인\n\n**Promise rejection / Uncaught (in promise)**\n- 근본 원인: catch 핸들러 없이 비동기 작업 실패\n- 체크 사항: API 호출, 파일 작업, async/await 사용\n- 해결책: .catch() 추가 또는 await와 함께 try/catch 사용\n\n**SyntaxError: Unexpected token**\n- 근본 원인: 주로 JSON이나 코드 파싱 중 발생하는 유효하지 않은 구문\n- 체크 사항: JSON 구조, 괄호 짝 맞추기, 세미콜론\n- 해결책: JSON 검증, 구문 수정, 복사/붙여넣기 에러 확인\n\n### Java\n\n**NullPointerException**\n- 근본 원인: null 객체 참조에 대해 메서드 호출\n- 체크 사항: 객체 초기화, 메서드 반환값\n- 해결책: Null 체크 추가, Optional 사용, 초기화 보장\n\n**ClassNotFoundException**\n- 근본 원인: classpath에서 클래스를 찾을 수 없음\n- 체크 사항: 종속성, 빌드 설정, 패키지 구조\n- 해결책: 종속성 추가, classpath 수정, 패키지/클래스 이름 확인\n\n**ConcurrentModificationException**\n- 근본 원인: 반복(iteration) 중에 컬렉션이 수정됨\n- 체크 사항: 중첩 루프, 멀티스레딩, iterator 사용\n- 해결책: iterator.remove(), CopyOnWriteArrayList 사용 또는 동기화(synchronization)\n\n## 에러 심각도 분류\n\n### Critical (즉시 수정)\n- 애플리케이션 크래시 또는 시작 불가\n- 데이터 손실 또는 손상\n- 보안 취약점\n- 운영 환경 중단 (Outages)\n- 결제 또는 트랜잭션 실패\n\n### High (조속히 수정)\n- 주요 기능 고장\n- 사용자에게 영향을 주는 성능 저하\n- 여러 사용자에게 영향을 주는 에러\n- 복잡한 해결 방법(Workarounds)\n\n### Medium (수정 일정 계획)\n- 부가 기능 고장\n- 영향도가 있는 외관상 이슈\n- 쉬운 해결 방법이 있는 에러\n- 엣지 케이스 실패\n\n### Low (백로그)\n- 외관상 이슈\n- 사소한 개선 사항\n- 드문 엣지 케이스\n- 중요하지 않은 경고\n\n## 디버깅 도구 및 기법\n\n### 로깅 모범 사례\n\n```python\nimport logging\n\n# 구조화된 로깅 설정\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n\n# 컨텍스트와 함께 로깅\nlogger = logging.getLogger(__name__)\nlogger.debug(f\"Processing item: {item_id}, user: {user_id}\")\nlogger.error(f\"Failed to process: {error}\", exc_info=True)\n```\n\n### 전략적 중단점 (Breakpoints)\n\n1. **에러 발생 지점**: 에러 발생 시의 정확한 상태 포착\n2. **에러 발생 전**: 입력값 및 사전 조건 확인\n3. **에러 발생 후**: 에러 전파 과정 관찰\n4. **결정 지점 (Decision points)**: 로직 분기점 검증\n5. **루프 내부**: 반복 변수 확인\n\n### 전략적인 Print 디버깅\n\n```python\n# 컨텍스트 정보를 포함한 디버그 출력 추가\nprint(f\"DEBUG: function_name called with {param1=}, {param2=}\")\nprint(f\"DEBUG: variable state before operation: {var=}\")\nprint(f\"DEBUG: condition check: {condition=}, result: {result=}\")\n```\n\n### 이진 탐색 디버깅 (Binary Search Debugging)\n\n에러 위치가 불분명할 때:\n1. 코드 경로 중간에 체크포인트 추가\n2. 에러가 체크포인트 이전인지 이후인지 판단\n3. 남은 절반에 대해 반복\n4. 에러 위치에 빠르게 수렴\n\n### 고무 오리 디버깅 (Rubber Duck Debugging)\n\n누군가에게(혹은 사물에게) 코드를 한 줄씩 설명하기:\n1. 가정을 검토하게 함\n2. 설명하는 중에 에러를 발견하는 경우가 많음\n3. 복잡한 로직을 명확하게 함\n4. 지식의 공백을 식별함\n\n## Debug Helper 스크립트 사용\n\n`scripts/debug_helper.py` 유틸리티는 자동화된 보조 기능을 제공합니다:\n\n```bash\n# 파일에서 스택 트레이스 파싱\npython scripts/debug_helper.py parse-trace error.log\n\n# 에러 패턴 추출\npython scripts/debug_helper.py analyze-log application.log\n\n# 디버그 세션 시작 (로그 생성)\npython scripts/debug_helper.py session start \"Login error investigation\"\n\n# 세션에 노트 추가\npython scripts/debug_helper.py session note \"Tested with different users - same error\"\n\n# 해결책과 함께 세션 종료\npython scripts/debug_helper.py session close \"Fixed: Added null check for user.profile\"\n```\n\n## 모범 사례 (Best Practices)\n\n### 수행할 작업 (Do's)\n\n- **에러 메시지 전체 읽기**: 세부 사항을 건너뛰지 마세요.\n- **일관된 재현**: 디버깅 전에 신뢰할 수 있는 재현 방법을 확보하세요.\n- **한 번에 한 가지만 변경**: 무엇이 문제를 해결했는지 격리하세요.\n- **진행하면서 문서화**: 가설, 테스트, 발견 사항을 기록하세요.\n- **버전 관리 사용**: 디버깅 전에 커밋하여 필요한 경우 되돌릴 수 있게 하세요.\n- **테스트 추가**: 수정 후 회귀를 방지하세요.\n- **근본 원인 수정**: 증상에만 땜질하지 마세요.\n- **지식 공유**: 팀을 위해 해결책을 문서화하세요.\n\n### 피해야 할 작업 (Don'ts)\n\n- **추측하지 말 것**: 데이터로 가정을 검증하세요.\n- **에러 읽기를 건너뛰지 말 것**: 에러 메시지에는 중요한 정보가 담겨 있습니다.\n- **여러 가지를 동시에 변경하지 말 것**: 무엇이 해결했는지 알 수 없게 됩니다.\n- **충동적으로 코드를 삭제하지 말 것**: 먼저 주석 처리하고 왜 그 코드가 있었는지 이해하세요.\n- **경고를 무시하지 말 것**: 오늘의 경고는 내일의 에러가 됩니다.\n- **이해 없이 수정하지 말 것**: 다른 것을 망가뜨릴 수 있습니다.\n- **테스트를 잊지 말 것**: 수정 사항이 작동하고 새로운 이슈를 만들지 않는지 확인하세요.\n\n## 일반적인 디버깅 시나리오\n\n### 시나리오 1: \"어제는 됐는데\"\n\n**접근 방식:**\n1. 최근 변경 사항 확인 (git diff, git log)\n2. 종속성 업데이트 검토\n3. 환경 변경 사항 확인\n4. 시간에 따른 로직(time-dependent logic) 탐색\n5. 환경 간 설정 비교\n\n**일반적인 원인:**\n- 최근 코드 변경\n- 업데이트된 종속성\n- 설정 변경\n- 데이터베이스 스키마 변경\n- 외부 API 변경\n- 인증서 만료\n\n### 시나리오 2: \"내 컴퓨터에선 되는데\"\n\n**접근 방식:**\n1. 환경 비교 (OS, 종속성, 설정)\n2. 환경 변수 확인\n3. 파일 경로 및 권한 검증\n4. 환경 간 데이터 비교\n5. 하드코딩된 가정사항 탐색\n\n**일반적인 원인:**\n- 다른 종속성 버전\n- 누락된 환경 변수\n- 다른 파일 경로\n- 데이터베이스 상태 차이\n- 운영 체제 차이\n- 누락된 설정 파일\n\n### 시나리오 3: \"간헐적 실패\"\n\n**접근 방식:**\n1. 실패 패턴 식별 (타이밍, 빈도, 조건)\n2. 경합 조건(race conditions) 탐색\n3. 리소스 가용성 확인\n4. 동시 작업 검토\n5. 광범위한 로깅 추가\n6. 재현 시도 횟수 증가\n\n**일반적인 원인:**\n- 경합 조건\n- 메모리 누수\n- 외부 서비스 불안정\n- 네트워크 이슈\n- 타이밍 의존 로직\n- 리소스 고갈\n\n### 시나리오 4: \"운영 환경에서만 에러 발생\"\n\n**접근 방식:**\n1. 운영 환경 전용 설정 확인\n2. 운영 데이터의 특성 검토\n3. 운영 환경의 부하/규모 확인\n4. 운영 환경의 종속성 검토\n5. 보안/권한 설정 검토\n\n**일반적인 원인:**\n- 운영 데이터의 엣지 케이스\n- 규모/부하 관련 이슈\n- 운영 환경 전용 설정\n- 다른 보안 정책\n- 방화벽 또는 네트워크 제한\n- 운영용으로만 연동된 기능\n\n## 고급 기법\n\n### Bisect Debugging (Git)\n\n어떤 커밋이 버그를 도입했는지 찾기:\n\n```bash\ngit bisect start\ngit bisect bad                 # 현재 버전에 버그가 있음\ngit bisect good v1.2.0        # v1.2.0 버전은 정상이였음\n# Git이 중간 커밋을 체크아웃함\n# 테스트 후 good/bad 마킹\ngit bisect good/bad\n# Git이 범인 커밋을 식별할 때까지 반복\ngit bisect reset\n```\n\n### Heisenbug (관찰자 효과)\n\n디버깅을 시작하면 사라지는 에러:\n\n**전략:**\n- 중단점 없이 로깅 추가\n- 디버깅을 위해 운영 환경과 유사한 환경 사용\n- 타이밍 및 동시성 이슈 검토\n- 초기화/타이밍 종속성 확인\n- 비침습적(non-intrusive) 모니터링 사용\n\n### 메모리 프로파일링 (Memory Profiling)\n\n메모리 누수 및 성능 확인:\n\n```python\n# Python 메모리 프로파일링\nimport tracemalloc\n\ntracemalloc.start()\n# ... 코드 실행 ...\nsnapshot = tracemalloc.take_snapshot()\ntop_stats = snapshot.statistics('lineno')\n\nfor stat in top_stats[:10]:\n    print(stat)\n```\n\n### 네트워크 디버깅 (Network Debugging)\n\nAPI 및 통합 에러 확인:\n\n**도구:**\n- 브라우저 DevTools Network 탭\n- 상세 플래그(-v)를 포함한 curl\n- API 테스트를 위한 Postman\n- 패킷 조사를 위한 Wireshark\n- 네트워크 프록시 (Charles, Fiddler)\n\n**체크 사항:**\n- Request/response 헤더\n- 상태 코드\n- Request/response 바디\n- 타이밍 (레이턴시, 타임아웃)\n- SSL/TLS 이슈\n\n## Quick Reference\n\n### TRACE 프레임워크 퀵 체크리스트\n\n```\n☐ T - TRACE\n  ☐ 전체 에러 메시지 캡처 완료\n  ☐ 스택 트레이스 수집 완료\n  ☐ 재현 단계 문서화 완료\n  ☐ 환경 식별 완료\n\n☐ R - READ\n  ☐ 에러 유형 식별 완료\n  ☐ 에러 메시지 분석 완료\n  ☐ 에러 카테고리 결정 완료\n  ☐ 관련 에러 확인 완료\n\n☐ A - ANALYZE\n  ☐ 코드 검토 완료\n  ☐ 데이터 조사 완료\n  ☐ 환경 검증 완료\n  ☐ 상태 조사 완료\n\n☐ C - CHECK\n  ☐ 에러 체인 추적 완료\n  ☐ 가설 테스트 완료\n  ☐ 근본 원인 식별 완료\n  ☐ 가정 검증 완료\n\n☐ E - EXECUTE\n  ☐ 수정 설계 완료\n  ☐ 수정 구현 완료\n  ☐ 수정 검증 완료\n  ☐ 방지 대책 추가 완료\n```\n\n### 에러 우선순위 매트릭스 (Error Priority Matrix)\n\n```\n영향도 →      Low        Medium       High        Critical\n빈도 ↓\nHigh         Medium     High         Critical    Critical\nMedium       Low        Medium       High        Critical\nLow          Low        Low          Medium      High\nRare         Backlog    Low          Medium      High\n```\n\n## 추가 자료\n\n### 예시 (Examples)\n- `examples/debugging_workflow.md` - 단계별 디버깅 프로세스 예시\n- `examples/common_errors.md` - 자주 발생하는 에러 패턴 및 해결책 카탈로그\n- `examples/stack_traces.txt` - 분석과 함께 제공되는 스택 트레이스 예시\n\n### 스크립트 (Scripts)\n- `scripts/debug_helper.py` - 트레이스 파싱 및 세션 관리를 위한 Python 디버깅 유틸리티\n\n### 추가 학습\n- 언어별 디버깅 문서\n- 프레임워크 에러 핸들링 가이드\n- 프로파일링 및 성능 분석 도구\n- 테스트 및 품질 보증 실무\n\n---\n\n**기억하세요**: 디버깅은 탐정 수사입니다. 체계적이고 인내심을 가지며, 증거가 진실로 당신을 인도하게 하세요. 모든 에러 메시지는 당신의 이해를 기다리고 있는 단서입니다."
              },
              {
                "name": "file-organizer",
                "description": "컨텍스트 이해, 중복 파일 찾기, 더 나은 구조 제안 및 클린업 작업 자동화를 통해 컴퓨터의 파일과 폴더를 지능적으로 정리합니다. 인지 부하를 줄이고 수동 작업 없이 디지털 작업 공간을 깔끔하게 유지합니다.",
                "path": "icartsh-plugin/skills/file-organizer/SKILL.md",
                "frontmatter": {
                  "name": "file-organizer",
                  "description": "컨텍스트 이해, 중복 파일 찾기, 더 나은 구조 제안 및 클린업 작업 자동화를 통해 컴퓨터의 파일과 폴더를 지능적으로 정리합니다. 인지 부하를 줄이고 수동 작업 없이 디지털 작업 공간을 깔끔하게 유지합니다."
                },
                "content": "# File Organizer\n\n이 SKILL은 당신의 개인 정리 비서 역할을 수행하며, 지속적인 수동 정리의 부담 없이 컴퓨터 전반에 걸쳐 깔끔하고 논리적인 파일 구조를 유지할 수 있도록 도와줍니다.\n\n## 사용 시기\n\n- 다운로드(Downloads) 폴더가 엉망진창일 때\n- 파일들이 여기저기 흩어져 있어 찾을 수 없을 때\n- 중복 파일들이 공간을 차지하고 있을 때\n- 폴더 구조가 더 이상 논리적이지 않을 때\n- 더 나은 정리 습관을 기르고 싶을 때\n- 새로운 프로젝트를 시작하면서 좋은 구조가 필요할 때\n- 오래된 프로젝트를 아카이브(archive) 하기 전 정리하고 싶을 때\n\n## 주요 기능\n\n1. **현재 구조 분석**: 폴더와 파일을 검토하여 무엇을 가지고 있는지 이해합니다.\n2. **중복 파일 찾기**: 시스템 전체에서 중복된 파일을 식별합니다.\n3. **정리 제안**: 콘텐츠를 바탕으로 논리적인 폴더 구조를 제안합니다.\n4. **클린업 자동화**: 사용자의 승인 하에 파일을 이동, 이름 변경 및 정리합니다.\n5. **컨텍스트 유지**: 파일 유형, 날짜 및 내용을 바탕으로 스마트한 결정을 내립니다.\n6. **복잡도 감소**: 더 이상 필요하지 않을 것 같은 오래된 파일을 식별합니다.\n\n## 사용 방법\n\n### 홈 디렉토리에서\n\n```\ncd ~\n```\n\n그 다음 Claude Code를 실행하여 도움을 요청하세요:\n\n```\n내 다운로드 폴더 정리를 도와줘\n```\n\n```\n내 문서(Documents) 폴더에서 중복 파일을 찾아줘\n```\n\n```\n내 프로젝트 디렉토리들을 검토하고 개선 사항을 제안해줘\n```\n\n### 구체적인 정리 작업\n\n```\n다운로드된 파일들을 내용에 따라 적절한 폴더로 정리해줘\n```\n\n```\n중복 파일을 찾아서 어떤 것을 남길지 결정하는 걸 도와줘\n```\n\n```\n6개월 이상 손대지 않은 오래된 파일들을 정리해줘\n```\n\n```\n내 [업무/프로젝트/사진/기타]를 위한 더 나은 폴더 구조를 만들어줘\n```\n\n## 지침 (Instructions)\n\n사용자가 파일 정리 도움을 요청할 때:\n\n1. **범위 파악 (Understand the Scope)**\n   \n   명확한 질문을 던지세요:\n   - 어떤 디렉토리를 정리해야 하나요? (다운로드, 문서, 전체 홈 폴더 등)\n   - 주요 문제가 무엇인가요? (파일 찾기 어려움, 중복, 너무 지저분함, 구조 없음 등)\n   - 피해야 할 파일이나 폴더가 있나요? (진행 중인 프로젝트, 민감한 데이터 등)\n   - 얼마나 공격적으로 정리할까요? (보수적인 정리 vs. 포괄적인 클린업)\n\n2. **현재 상태 분석 (Analyze Current State)**\n   \n   대상 디렉토리를 검토합니다:\n   ```bash\n   # 현재 구조 개요 파악\n   ls -la [대상_디렉토리]\n   \n   # 파일 유형 및 크기 확인\n   find [대상_디렉토리] -type f -exec file {} \\; | head -20\n   \n   # 가장 큰 파일 식별\n   du -sh [대상_디렉토리]/* | sort -rh | head -20\n   \n   # 파일 유형별 카운트\n   find [대상_디렉토리] -type f | sed 's/.*\\.//' | sort | uniq -c | sort -rn\n   ```\n   \n   발견 사항 요약:\n   - 전체 파일 및 폴더 수\n   - 파일 유형별 분류\n   - 크기 분포\n   - 날짜 범위\n   - 명백한 정리 이슈\n\n3. **정리 패턴 식별 (Identify Organization Patterns)**\n   \n   파일들을 바탕으로 논리적인 그룹을 결정합니다:\n   \n   **유형별 (By Type)**:\n   - Documents (PDF, DOCX, TXT)\n   - Images (JPG, PNG, SVG)\n   - Videos (MP4, MOV)\n   - Archives (ZIP, TAR, DMG)\n   - Code/Projects (코드가 포함된 디렉토리)\n   - Spreadsheets (XLSX, CSV)\n   - Presentations (PPTX, KEY)\n   \n   **용도별 (By Purpose)**:\n   - 업무용 vs. 개인용\n   - 활성(Active) vs. 아카이브(Archive)\n   - 프로젝트별\n   - 참조 자료\n   - 임시/작업용 파일\n   \n   **날짜별 (By Date)**:\n   - 현재 연도/월\n   - 지난 연도\n   - 매우 오래된 파일 (아카이브 대상)\n\n4. **중복 파일 찾기 (Find Duplicates)**\n   \n   요청 시 중복 파일을 검색합니다:\n   ```bash\n   # 해시(hash)를 이용한 정확한 중복 찾기\n   find [디렉토리] -type f -exec md5 {} \\; | sort | uniq -d\n   \n   # 이름이 같은 파일 찾기\n   find [디렉토리] -type f -printf '%f\\n' | sort | uniq -d\n   \n   # 크기가 유사한 파일 찾기\n   find [디렉토리] -type f -printf '%s %p\\n' | sort -n\n   ```\n   \n   각 중복 세트에 대해:\n   - 모든 파일 경로 표시\n   - 크기 및 수정 날짜 표시\n   - 남길 파일 권장 (보통 최신 파일이나 이름이 제일 잘 지어진 것)\n   - **중요**: 삭제 전에는 반드시 확인 과정을 거칩니다.\n\n5. **정리 계획 제안 (Propose Organization Plan)**\n   \n   변경을 적용하기 전에 명확한 계획을 제시합니다:\n   \n   ```markdown\n   # [디렉토리] 정리 계획\n   \n   ## 현재 상태\n   - Y개 폴더에 총 X개 파일 존재\n   - 총 용량: [크기]\n   - 파일 유형: [분류]\n   - 이슈: [문제 목록]\n   \n   ## 제안하는 구조\n   \n   ```\n   [디렉토리]/\n   ├── Work/\n   │   ├── Projects/\n   │   ├── Documents/\n   │   └── Archive/\n   ├── Personal/\n   │   ├── Photos/\n   │   ├── Documents/\n   │   └── Media/\n   └── Downloads/\n       ├── To-Sort/\n       └── Archive/\n   ```\n   \n   ## 실행할 변경 사항\n   \n   1. **새 폴더 생성**: [목록]\n   2. **파일 이동**:\n      - X개의 PDF → Work/Documents/\n      - Y개의 이미지 → Personal/Photos/\n      - Z개의 오래된 파일 → Archive/\n   3. **이름 변경**: [이름 변경 패턴]\n   4. **삭제**: [중복 또는 휴지통 파일]\n   \n   ## 확인이 필요한 파일\n   \n   - [확실하지 않은 파일 목록]\n   \n   진행할까요? (yes/no/modify)\n   ```\n\n6. **정리 실행 (Execute Organization)**\n   \n   승인 후 체계적으로 정리를 진행합니다:\n   \n   ```bash\n   # 폴더 구조 생성\n   mkdir -p \"path/to/new/folders\"\n   \n   # 명확한 로깅과 함께 파일 이동\n   mv \"old/path/file.pdf\" \"new/path/file.pdf\"\n   \n   # 일관된 패턴으로 파일 이름 변경\n   # 예: \"YYYY-MM-DD - 설명.ext\"\n   ```\n   \n   **중요 규칙**:\n   - 삭제 전에는 반드시 확인합니다.\n   - 나중에 되돌릴 수 있도록 모든 이동 기록을 남깁니다.\n   - 원래의 수정 날짜를 보존합니다.\n   - 파일 이름 충돌을 적절히 처리합니다.\n   - 예상치 못한 상황이 발생하면 중단하고 질문합니다.\n\n7. **요약 및 유지 관리 팁 제공**\n   \n   정리 완료 후:\n   \n   ```markdown\n   # 정리 완료! ✨\n   \n   ## 변경 내용\n   \n   - [X]개의 새 폴더 생성\n   - [Y]개의 파일 정리 완료\n   - 중복 제거로 [Z] GB 공간 확보\n   - [W]개의 오래된 파일 아카이브 처리\n   \n   ## 새로운 구조\n   \n   [새로운 폴더 트리 표시]\n   \n   ## 유지 관리 팁\n   \n   이 상태를 유지하려면:\n   \n   1. **매주**: 새로운 다운로드 파일 분류\n   2. **매월**: 완료된 프로젝트 검토 및 아카이브\n   3. **매분기**: 새로운 중복 파일 체크\n   4. **매년**: 오래된 파일 아카이브\n   \n   ## 활용 가능한 명령어\n   \n   ```bash\n   # 이번 주에 수정된 파일 찾기\n   find . -type f -mtime -7\n   \n   # 유형별 다운로드 정렬\n   [사용자 환경에 맞춘 커스텀 명령]\n   \n   # 중복 찾기\n   [커스텀 명령]\n   ```\n   \n   다른 폴더도 정리할까요?\n   ```\n\n## 예시 (Examples)\n\n### 예시 1: 다운로드 폴더 정리 (Justin Dielmann 사례)\n\n**사용자**: \"다운로드 폴더에 파일이 500개가 넘어서 엉망이야. 정리 좀 도와줘.\"\n\n**과정**:\n1. 다운로드 폴더 분석\n2. 패턴 발견: 업무 문서, 개인 사진, 설치 파일, 임의의 PDF 등\n3. 구조 제안:\n   - Downloads/\n     - Work/\n     - Personal/\n     - Installers/ (DMG, PKG 파일)\n     - Archive/\n     - ToSort/ (결정이 필요한 것들)\n4. 확인 요청\n5. 내용과 이름을 바탕으로 지능적으로 파일 이동\n6. 결과: 500개 파일 → 5개의 정리된 폴더\n\n### 예시 2: 중복 파일 찾기 및 제거\n\n**사용자**: \"내 문서 폴더에서 중복된 파일을 찾아서 어떤 걸 남길지 결정하는 걸 도와줘.\"\n\n**출력**:\n```markdown\n# 23세트의 중복 파일 발견 (총 156 MB)\n\n## 중복 세트 1: \"proposal.pdf\"\n- `/Documents/proposal.pdf` (2.3 MB, 수정: 2024-03-15)\n- `/Documents/old/proposal.pdf` (2.3 MB, 수정: 2024-03-15)\n- `/Desktop/proposal.pdf` (2.3 MB, 수정: 2024-03-10)\n\n**권장 사항**: `/Documents/proposal.pdf` 유지 (올바른 위치에 있는 최신 파일)\n나머지 2개 복사본을 삭제할까요?\n\n[모든 중복 항목에 대해 계속...]\n```\n\n### 예시 3: 프로젝트 폴더 재구조화\n\n**사용자**: \"~/Projects 디렉토리를 검토하고 개선 사항을 제안해줘.\"\n\n**출력**:\n```markdown\n# ~/Projects 분석 결과\n\n## 현재 구조의 문제점\n- 활성 프로젝트와 아카이브된 프로젝트(3년 이상 됨)가 섞여 있음\n- 일관된 명명 규칙이 없음\n- 어떤 프로젝트는 루트에 있고, 어떤 것은 임의의 하위 폴더에 있음\n- 중복된 폴더 (project-name, project-name-old, project-name-v2)\n\n## 제안하는 구조\n\n```\nProjects/\n├── Active/\n│   ├── client-work/\n│   ├── side-projects/\n│   └── learning/\n├── Archive/\n│   ├── 2022/\n│   ├── 2023/\n│   └── 2024/\n└── Templates/\n```\n\n## 구체적인 변경 사항\n1. 2022년 이후 손대지 않은 12개 프로젝트 이동 → Archive/\n2. 4개의 중복된 프로젝트 폴더 통합\n3. 프로젝트 이름을 일관된 형식으로 변경: \"client-name-project-name\"\n4. 오래된 작업물을 위한 아카이브 생성\n\n제가 이를 실행할까요?\n```\n\n### 예시 4: 날짜별 사진 정리\n\n**사용자**: \"내 사진 폴더를 연도와 월별로 정리해줘.\"\n\n**출력**: 다음과 같은 구조 생성:\n```\nPhotos/\n├── 2023/\n│   ├── 01-January/\n│   ├── 02-February/\n│   └── ...\n├── 2024/\n│   ├── 01-January/\n│   └── ...\n└── Unsorted/\n```\n\n그 후 EXIF 데이터나 파일 수정 날짜를 바탕으로 사진을 이동합니다.\n\n## 일반적인 정리 작업\n\n### 다운로드 클린업\n```\n다운로드 폴더를 정리해줘 - 문서는 Documents로, \n사진은 Pictures로 이동하고, 설치 파일은 따로 보관해. \n3개월 넘은 파일들은 아카이브해줘.\n```\n\n### 프로젝트 정리\n```\n내 Projects 폴더 구조를 검토하고 활성 프로젝트와 \n아카이브해야 할 오래된 프로젝트를 분리하는 걸 도와줘.\n```\n\n### 중복 제거\n```\n내 Documents 폴더의 모든 중복 파일을 찾고 \n어떤 걸 남길지 결정하는 걸 도와줘.\n```\n\n### 데스크탑 정리\n```\n내 바탕화면이 파일로 가득 찼어. 전부 Documents 폴더로 \n제대로 정리하는 걸 도와줘.\n```\n\n### 사진 정리\n```\n이 폴더의 모든 사진을 찍은 날짜(연도/월)별로 정리해줘.\n```\n\n### 업무/개인 분리\n```\n내 Documents 폴더 전체에서 업무용 파일과 \n개인용 파일을 분리하는 걸 도와줘.\n```\n\n## 프로 팁 (Pro Tips)\n\n1. **작게 시작하기**: 신뢰를 쌓기 위해 다운로드 같은 지저분한 폴더 하나부터 시작하세요.\n2. **정기적인 관리**: 다운로드 폴더에 대해 매주 클린업을 실행하세요.\n3. **일관된 명명**: 중요한 파일에는 \"YYYY-MM-DD - 설명\" 형식을 사용하세요.\n4. **적극적인 아카이브**: 오래된 프로젝트는 삭제하지 말고 Archive로 옮기세요.\n5. **활성 상태 분리**: 진행 중인 작업과 아카이브된 작업 사이에 명확한 경계를 유지하세요.\n6. **프로세스 믿기**: 무엇을 어디에 둘지에 대한 인지적 부하를 Claude에게 맡기세요.\n\n## 모범 사례 (Best Practices)\n\n### 폴더 명명 규칙\n- 명확하고 설명적인 이름을 사용하세요.\n- 공백을 피하세요 (하이픈이나 언더스코어 사용).\n- 구체적으로 적으세요: \"docs\" 대신 \"client-proposals\".\n- 순서 정렬을 위해 접두사를 사용하세요: \"01-current\", \"02-archive\".\n\n### 파일 명명 규칙\n- 날짜 포함하기: \"2024-10-17-meeting-notes.md\"\n- 설명적으로 적기: \"q3-financial-report.xlsx\"\n- 이름에 버전 번호를 넣지 마세요 (대신 버전 관리 시스템 사용).\n- 다운로드 흔적 제거하기: \"document-final-v2 (1).pdf\" → \"document.pdf\"\n\n### 아카이브 시점\n- 6개월 이상 손대지 않은 프로젝트\n- 나중에 참조할 수 있는 완료된 작업\n- 새로운 시스템으로 마이그레이션한 후의 이전 버전\n- 삭제하기가 망설여지는 파일 (먼저 아카이브하세요)\n\n## 관련 유스케이스\n\n- 새 컴퓨터의 초기 정리 설정\n- 백업/아카이브를 위한 파일 준비\n- 저장 공간 정리 전 클린업\n- 공유 팀 폴더 정리\n- 새로운 프로젝트 디렉토리 구조 잡기"
              },
              {
                "name": "markdown-pro",
                "description": "세련된 README 파일, 변경 이력(changelog), 기여 가이드(contribution guide) 및 기술 문서를 작성하기 위한 전문가 수준의 Markdown 문서화 SKILL입니다. 사용 사례: (1) 배지와 섹션을 포함한 README 생성, (2) git 히스토리를 이용한 자동 변경 이력 생성, (3) 목차(table of contents) 생성, (4) 기여 가이드라인 작성, (5) 기술 문서 포맷팅, (6) 구문 강조(syntax highlighting)를 포함한 코드 문서화",
                "path": "icartsh-plugin/skills/markdown-pro/SKILL.md",
                "frontmatter": {
                  "name": "markdown-pro",
                  "description": "세련된 README 파일, 변경 이력(changelog), 기여 가이드(contribution guide) 및 기술 문서를 작성하기 위한 전문가 수준의 Markdown 문서화 SKILL입니다. 사용 사례: (1) 배지와 섹션을 포함한 README 생성, (2) git 히스토리를 이용한 자동 변경 이력 생성, (3) 목차(table of contents) 생성, (4) 기여 가이드라인 작성, (5) 기술 문서 포맷팅, (6) 구문 강조(syntax highlighting)를 포함한 코드 문서화"
                },
                "content": "# Professional Markdown Documentation\n\n## 개요 (Overview)\n\n이 SKILL은 전문적이고 잘 구조화된 Markdown 문서를 작성하기 위한 포괄적인 가이드를 제공합니다. 최신 포맷팅, 배지 및 모범 사례를 적용한 README 파일, 변경 이력, 기여 가이드 및 기술 문서를 다룹니다.\n\n## 핵심 역량 (Core Capabilities)\n\n### README 생성\n- 프로젝트 개요 및 설명\n- 설치 지침\n- 코드 블록을 포함한 사용 예시\n- API 문서화\n- 배지(badges) 및 실드(shields)\n- 주요 특징 강조\n- 스크린샷 및 데모\n\n### 변경 이력(Changelog) 자동화\n- 시맨틱 버저닝(Semantic versioning) 형식\n- Git 히스토리 파싱\n- 자동 릴리스 노트 생성\n- 주요 변경 사항(Breaking changes) 강조\n- 기여자 표시 (attribution)\n\n### 기술 문서화\n- 명확한 섹션 계층 구조\n- 코드 구문 강조 (Syntax highlighting)\n- API 참조 포맷팅\n- 목차 (Table of contents)\n- 상호 참조 (Cross-referencing)\n- 접기/펼치기 섹션 (Collapsible sections)\n\n## README 구조 모범 사례\n\n### 필수 섹션\n\n**1. 배지를 포함한 헤더**\n```markdown\n# 프로젝트 이름\n\n[![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)\n[![Version](https://img.shields.io/badge/version-1.0.0-green.svg)](releases)\n[![Build](https://img.shields.io/badge/build-passing-brightgreen.svg)](builds)\n\n프로젝트가 무엇인지 설명하는 짧은 한 줄 설명.\n```\n\n**2. 목차 (Table of Contents)** (내용이 긴 README의 경우)\n```markdown\n## 목차\n\n- [주요 특징](#features)\n- [설치 방법](#installation)\n- [사용법](#usage)\n- [API 참조](#api-reference)\n- [기여하기](#contributing)\n- [라이선스](#license)\n```\n\n**3. 주요 특징 섹션 (Features)**\n```markdown\n## 주요 특징\n\n- **특징 1**: 장점과 함께 명확한 설명 제공\n- **특징 2**: 어떤 문제를 해결하는지 기술\n- **특징 3**: 독특한 강점 강조\n- 크로스 플랫폼 지원 (Windows, macOS, Linux)\n- 포괄적인 테스트 커버리지 (>90%)\n```\n\n**4. 설치 방법 (Installation)**\n```markdown\n## 설치 방법\n\n### 사전 요구 사항\n- Python 3.8 이상\n- pip 패키지 매니저\n\n### 빠른 시작\n\n```bash\npip install package-name\n```\n\n### 소스에서 설치\n\n```bash\ngit clone https://github.com/username/repo.git\ncd repo\npip install -e .\n```\n```\n\n**5. 사용 예시 (Usage)**\n```markdown\n## 사용법\n\n### 기본 예시\n\n```python\nfrom package import Module\n\n# 초기화\nclient = Module(api_key=\"your-key\")\n\n# 작업 수행\nresult = client.process(data)\nprint(result)\n```\n\n### 고급 사용법\n\n더 자세한 사용 사례는 [examples/](examples/) 디렉토리를 참조하세요.\n```\n\n**6. API 문서화 (API Reference)**\n```markdown\n## API 참조\n\n### `Module.process(data, options=None)`\n\n선택적 설정을 사용하여 입력 데이터를 처리합니다.\n\n**매개변수:**\n- `data` (str|dict): 처리할 입력 데이터\n- `options` (dict, 선택 사항): 설정 옵션\n  - `verbose` (bool): 상세 출력 활성화 (기본값: False)\n  - `format` (str): 출력 형식 - 'json', 'yaml', 'xml' (기본값: 'json')\n\n**반환값:**\n- `dict`: 메타데이터가 포함된 처리 결과\n\n**예외:**\n- `ValueError`: 데이터가 유효하지 않은 경우\n- `APIError`: API 요청이 실패한 경우\n\n**예시:**\n```python\nresult = client.process(\n    data={\"key\": \"value\"},\n    options={\"verbose\": True, \"format\": \"json\"}\n)\n```\n```\n\n**7. 기여하기 섹션 (Contributing)**\n```markdown\n## 기여하기\n\n프로젝트 기여를 환영합니다! 가이드라인은 [CONTRIBUTING.md](CONTRIBUTING.md)를 참조하세요.\n\n### 빠른 기여 가이드\n1. 저장소 포크 (Fork)\n2. 피처 브랜치 생성 (`git checkout -b feature/amazing-feature`)\n3. 변경 사항 커밋 (`git commit -m 'Add amazing feature'`)\n4. 브랜치 푸시 (`git push origin feature/amazing-feature`)\n5. 풀 리퀘스트 (Pull Request) 오픈\n```\n\n**8. 라이선스 및 크레딧**\n```markdown\n## 라이선스\n\n이 프로젝트는 MIT 라이선스를 따릅니다. 자세한 내용은 [LICENSE](LICENSE) 파일을 참조하세요.\n\n## 감사의 글\n\n- 특징 X를 구현해준 [기여자 이름]님께 감사드립니다.\n- [Project Name](link)에서 영감을 얻었습니다.\n- [Technology Stack]으로 구축되었습니다.\n```\n\n## 변경 이력(Changelog) 포맷\n\n### 시맨틱 버저닝 구조\n\n```markdown\n# 변경 이력\n\n이 프로젝트의 모든 주목할 만한 변경 사항은 이 파일에 기록됩니다.\n\n형식은 [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)를 따르며,\n이 프로젝트는 [시맨틱 버저닝(Semantic Versioning)](https://semver.org/spec/v2.0.0.html)을 준수합니다.\n\n## [Unreleased]\n\n### Added\n- 새로운 기능 설명\n\n### Changed\n- 기존 기능 수정 사항\n\n### Deprecated\n- 향후 삭제될 예정인 기능\n\n### Removed\n- 삭제된 기능\n\n### Fixed\n- 버그 수정\n\n### Security\n- 보안 개선 사항\n\n## [1.2.0] - 2025-01-15\n\n### Added\n- 사용자 인증 시스템 (#123)\n- CSV 내보내기 기능 (#145)\n- 다크 모드 지원 (#156)\n\n### Changed\n- 응답성 개선을 위한 UI 컴포넌트 업데이트 (#134)\n- 에러 메시지 개선 (#142)\n\n### Fixed\n- 백그라운드 프로세서의 메모리 누수 수정 (#139)\n- 로그인 타임아웃 이슈 해결 (#148)\n\n## [1.1.0] - 2024-12-01\n\n### Added\n- 핵심 기능을 포함한 초기 릴리스\n```\n\n## Markdown 포맷팅 모범 사례\n\n### 구문 강조를 포함한 코드 블록\n\n```markdown\n```python\ndef hello_world():\n    \"\"\"헬로 월드 메시지 출력.\"\"\"\n    print(\"Hello, World!\")\n```\n\n```javascript\nfunction helloWorld() {\n    console.log(\"Hello, World!\");\n}\n```\n\n```bash\n# 종속성 설치\nnpm install\n\n# 테스트 실행\nnpm test\n```\n```\n\n### 표 (Tables)\n\n```markdown\n| 기능 | 설명 | 상태 |\n|---------|-------------|--------|\n| 인증 | 사용자 인증 시스템 | ✅ 완료 |\n| API | RESTful API 엔드포인트 | ✅ 완료 |\n| 문서 | 문서화 작업 | 🚧 진행 중 |\n| 테스트 | 유닛 및 통합 테스트 | ❌ 계획됨 |\n```\n\n### 접기/펼치기 섹션 (Collapsible Sections)\n\n```markdown\n<details>\n<summary>클릭하여 고급 설정 확인</summary>\n\n## 고급 옵션\n\n고급 설정을 구성합니다:\n\n```yaml\nadvanced:\n  cache_size: 1000\n  timeout: 30\n  retry_attempts: 3\n```\n\n</details>\n```\n\n### 알림 상자 (Alert Boxes)\n\n```markdown\n> **참고**: 이 기능은 Python 3.8 이상이 필요합니다.\n\n> **주의**: 이 작업은 되돌릴 수 없습니다!\n\n> **중요**: 업그레이드 전에는 항상 데이터를 백업하세요.\n```\n\n### 링크 및 참조\n\n```markdown\n<!-- 외부 링크 -->\n[문서 보기](https://docs.example.com)\n\n<!-- 내부 링크 -->\n[설치 방법](#installation) 섹션을 참조하세요.\n\n<!-- 참조 스타일 링크 -->\n[프로젝트 홈페이지][homepage]와 [문서][docs]를 확인하세요.\n\n[homepage]: https://example.com\n[docs]: https://docs.example.com\n```\n\n### 이미지\n\n```markdown\n<!-- 표준 이미지 -->\n![프로젝트 로고](assets/logo.png)\n\n<!-- 대체 텍스트와 타이틀이 포함된 이미지 -->\n![대시보드 스크린샷](screenshots/dashboard.png \"메인 대시보드 화면\")\n\n<!-- 링크가 포함된 이미지 -->\n[![데모 비디오](thumbnail.jpg)](https://youtube.com/watch?v=example)\n```\n\n## 배지 생성\n\n### 공통 배지 패턴\n\n```markdown\n<!-- License -->\n![License](https://img.shields.io/badge/license-MIT-blue.svg)\n\n<!-- Version -->\n![Version](https://img.shields.io/badge/version-1.0.0-green.svg)\n\n<!-- Build Status -->\n![Build](https://img.shields.io/badge/build-passing-brightgreen.svg)\n\n<!-- Coverage -->\n![Coverage](https://img.shields.io/badge/coverage-95%25-brightgreen.svg)\n\n<!-- Language -->\n![Python](https://img.shields.io/badge/python-3.8+-blue.svg)\n\n<!-- Platform -->\n![Platform](https://img.shields.io/badge/platform-windows%20%7C%20macOS%20%7C%20linux-lightgrey.svg)\n```\n\n## 헬퍼 스크립트 (Helper Scripts)\n\n### 목차(TOC) 생성\n\n헤더로부터 목차를 자동으로 생성하려면 헬퍼 스크립트를 사용하세요:\n\n```bash\npython scripts/markdown_helper.py toc README.md\n```\n\n### Git으로부터 변경 이력 생성\n\ngit 히스토리에서 변경 이력 항목을 자동으로 생성합니다:\n\n```bash\npython scripts/markdown_helper.py changelog --since v1.0.0 --output CHANGELOG.md\n```\n\n### Markdown 링크 유효성 검사\n\n문서 내 깨진 링크가 있는지 확인합니다:\n\n```bash\npython scripts/markdown_helper.py validate docs/\n```\n\n## 템플릿 (Templates)\n\n### 전문 README 템플릿\n권장하는 모든 섹션이 포함된 운영 수준의 README 템플릿은 `examples/README_template.md`를 참조하세요.\n\n### 변경 이력 템플릿\nKeep a Changelog 형식을 따르는 올바른 포맷의 변경 이력 템플릿은 `examples/CHANGELOG_template.md`를 참조하세요.\n\n### 기여 가이드라인\n행동 강령(Code of conduct), 개발 환경 설정, PR 프로세스를 포함한 기여 가이드라인 템플릿은 `examples/CONTRIBUTING.md`를 참조하세요.\n\n## 모범 사례 요약 (Best Practices Summary)\n\n### 수행할 작업 (Do's)\n- 명확하고 설명적인 헤더를 사용하세요.\n- 모든 주요 기능에 대해 코드 예시를 포함하세요.\n- 프로젝트 상태를 한눈에 볼 수 있도록 배지를 추가하세요.\n- 가독성을 위해 한 줄의 길이를 100자 이내로 유지하세요.\n- 코드 블록에는 구문 강조를 사용하세요.\n- 300행 이상의 문서에는 목차를 포함하세요.\n- 모든 이미지에 대체 텍스트(alt text)를 추가하세요.\n- 관련 문서로의 링크를 제공하세요.\n\n### 피해야 할 작업 (Don'ts)\n- \"My Project\"와 같이 일반적인 제목을 사용하지 마세요.\n- 텍스트 덩어리를 길게 나열하지 마세요 (섹션으로 나누세요).\n- 릴리스할 때 변경 이력을 업데이트하는 것을 잊지 마세요.\n- 단순 URL만 적지 마세요 (항상 설명적인 링크 텍스트를 사용하세요).\n- 헤더 스타일을 혼용하지 마세요 (일관된 계층 구조 유지).\n- 설명 없는 스크린샷을 넣지 마세요.\n- 버전 번호를 여기저기 하드코딩하지 마세요 (변수나 배지 활용).\n\n## 빠른 참조 (Quick Reference)\n\n### 헤더 계층 구조\n```markdown\n# H1 - 프로젝트 제목 (문서당 하나만 사용)\n## H2 - 주요 섹션\n### H3 - 하위 섹션\n#### H4 - 부가적인 포인트\n##### H5 - 드물게 사용되는 깊은 중첩\n```\n\n### 목록 포맷팅\n```markdown\n<!-- 순서 없는 목록 -->\n- 항목 1\n- 항목 2\n  - 중첩 항목\n  - 또 다른 중첩 항목\n\n<!-- 순서 있는 목록 -->\n1. 첫 번째 단계\n2. 두 번째 단계\n3. 세 번째 단계\n\n<!-- 작업 목록 -->\n- [x] 완료된 작업\n- [ ] 진행 예정 작업\n- [ ] 또 다른 대기 작업\n```\n\n### 강조 (Emphasis)\n```markdown\n*기울임* 또는 _기울임_\n**굵게** 또는 __굵게__\n***굵은 기울임*** 또는 ___굵은 기울임___\n~~취소선~~\n`인라인 코드`\n```\n\n## 결론\n\n전문적인 Markdown 문서화는 프로젝트의 접근성을 높이고, 기여자를 유도하며, 사용자에게 명확한 가이드를 제공합니다. `examples/`의 템플릿을 시작점으로 삼고, `scripts/`의 헬퍼 스크립트로 커스터마이징하며, 세련되고 유지보수가 용이한 문서를 위해 이 모범 사례들을 따르세요."
              },
              {
                "name": "mcp-builder",
                "description": "LLM이 잘 설계된 도구를 통해 외부 서비스와 상호작용할 수 있게 해주는 고품질 MCP (Model Context Protocol) 서버를 만들기 위한 가이드입니다. Python (FastMCP) 또는 Node/TypeScript (MCP SDK)를 사용하여 외부 API나 서비스를 통합하는 MCP 서버를 구축할 때 사용하세요.",
                "path": "icartsh-plugin/skills/mcp-builder/SKILL.md",
                "frontmatter": {
                  "name": "mcp-builder",
                  "description": "LLM이 잘 설계된 도구를 통해 외부 서비스와 상호작용할 수 있게 해주는 고품질 MCP (Model Context Protocol) 서버를 만들기 위한 가이드입니다. Python (FastMCP) 또는 Node/TypeScript (MCP SDK)를 사용하여 외부 API나 서비스를 통합하는 MCP 서버를 구축할 때 사용하세요.",
                  "license": "LICENSE.txt의 전체 약관 참조"
                },
                "content": "# MCP Server Development Guide\n\n## 개요 (Overview)\n\nLLM이 잘 설계된 도구를 통해 외부 서비스와 상호작용할 수 있게 해주는 MCP (Model Context Protocol) 서버를 생성하세요. MCP 서버의 품질은 LLM이 실제 작업을 얼마나 잘 수행할 수 있게 하는지에 따라 결정됩니다.\n\n---\n\n# 프로세스 (Process)\n\n## 🚀 워크플로우 개요 (High-Level Workflow)\n\n고품질 MCP 서버를 만드는 과정은 크게 네 단계로 나뉩니다:\n\n### Phase 1: 심층 조사 및 계획 (Deep Research and Planning)\n\n#### 1.1 최신 MCP 설계 이해\n\n**API 커버리지 vs. 워크플로우 도구:**\n포괄적인 API 엔드포인트 커버리지와 특화된 워크플로우 도구 사이의 균형을 맞추세요. 워크플로우 도구는 특정 작업에 더 편리할 수 있으며, 포괄적인 커버리지는 에이전트(agent)가 작업을 자유롭게 구성할 수 있는 유연성을 제공합니다. 성능은 클라이언트에 따라 다릅니다—일부 클라이언트는 기본 도구들을 조합하는 코드 실행 방식이 효율적이며, 다른 클라이언트는 상위 수준의 워크플로우 도구가 더 잘 작동합니다. 확실하지 않을 때는 포괄적인 API 커버리지를 우선시하세요.\n\n**도구 명명 및 발견 가능성 (Tool Naming and Discoverability):**\n명확하고 설명적인 도구 이름은 에이전트가 적절한 도구를 빠르게 찾는 데 도움이 됩니다. 일관된 접두사(예: `github_create_issue`, `github_list_repos`)를 사용하고 동작 중심의 이름을 지으세요.\n\n**컨텍스트 관리 (Context Management):**\n에이전트는 간결한 도구 설명과 결과 필터링/페이지네이션 기능이 있을 때 더 효율적으로 작동합니다. 집중적이고 관련성 높은 데이터를 반환하도록 도구를 설계하세요. 일부 클라이언트는 코드 실행을 지원하며, 이는 에이전트가 데이터를 효율적으로 필터링하고 처리하는 데 도움이 됩니다.\n\n**실행 가능한 에러 메시지 (Actionable Error Messages):**\n에러 메시지는 구체적인 제안과 다음 단계를 제시하여 에이전트가 해결책을 찾을 수 있도록 안내해야 합니다.\n\n#### 1.2 MCP 프로토콜 문서 학습\n\n**MCP 사양 탐색:**\n\n먼저 사이트맵에서 관련 페이지를 찾으세요: `https://modelcontextprotocol.io/sitemap.xml`\n\n그 다음, 마크다운 형식을 위해 `.md` 접미사가 붙은 특정 페이지를 가져오세요 (예: `https://modelcontextprotocol.io/specification/draft.md`).\n\n검토해야 할 주요 페이지:\n- 사양 개요 및 아키텍처\n- 전송 메커니즘 (streamable HTTP, stdio)\n- 도구(Tool), 리소스(Resource), 프롬프트(Prompt) 정의\n\n#### 1.3 프레임워크 문서 학습\n\n**권장 스택:**\n- **언어**: TypeScript (고품질 SDK 지원 및 MCPB 등 다양한 실행 환경에서 좋은 호환성 제공. 또한 AI 모델들이 광범위한 사용량, 정적 타이핑 및 우수한 린팅 도구 덕분에 TypeScript 코드를 생성하는 데 능숙함)\n- **전송(Transport)**: 원격 서버의 경우 상태 비저장(stateless) JSON을 사용하는 Streamable HTTP (상태 저장 세션 및 스트리밍 응답에 비해 확장 및 유지보수가 간단함). 로컬 서버의 경우 stdio 사용.\n\n**프레임워크 문서 로드:**\n\n- **MCP Best Practices**: [📋 Best Practices 보기](./reference/mcp_best_practices.md) - 핵심 가이드라인\n\n**TypeScript용 (권장):**\n- **TypeScript SDK**: WebFetch를 사용하여 `https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/main/README.md` 로드\n- [⚡ TypeScript 가이드](./reference/node_mcp_server.md) - TypeScript 패턴 및 예시\n\n**Python용:**\n- **Python SDK**: WebFetch를 사용하여 `https://raw.githubusercontent.com/modelcontextprotocol/python-sdk/main/README.md` 로드\n- [🐍 Python 가이드](./reference/python_mcp_server.md) - Python 패턴 및 예시\n\n#### 1.4 구현 계획 수립\n\n**API 이해:**\n핵심 엔드포인트, 인증 요구 사항 및 데이터 모델을 식별하기 위해 서비스의 API 문서를 검토하세요. 필요에 따라 웹 검색과 WebFetch를 활용하세요.\n\n**도구 선택:**\n포괄적인 API 커버리지를 우선시하세요. 가장 일반적인 작업부터 시작하여 구현할 엔드포인트 목록을 만듭니다.\n\n---\n\n### Phase 2: 구현 (Implementation)\n\n#### 2.1 프로젝트 구조 설정\n\n프로젝트 설정에 대해서는 언어별 가이드를 참조하세요:\n- [⚡ TypeScript 가이드](./reference/node_mcp_server.md) - 프로젝트 구조, package.json, tsconfig.json\n- [🐍 Python 가이드](./reference/python_mcp_server.md) - 모듈 조직, 종속성\n\n#### 2.2 핵심 인프라 구현\n\n공용 유틸리티 생성:\n- 인증 기능이 포함된 API 클라이언트\n- 에러 핸들링 헬퍼\n- 응답 포맷팅 (JSON/Markdown)\n- 페이지네이션 지원\n\n#### 2.3 도구 구현 (Implement Tools)\n\n각 도구별로 다음을 수행하세요:\n\n**입력 스키마 (Input Schema):**\n- Zod (TypeScript) 또는 Pydantic (Python) 사용\n- 제약 조건과 명확한 설명 포함\n- 필드 설명에 예시 추가\n\n**출력 스키마 (Output Schema):**\n- 구조화된 데이터를 위해 가능한 경우 `outputSchema` 정의\n- 도구 응답에서 `structuredContent` 사용 (TypeScript SDK 기능)\n- 클라이언트가 도구 출력을 이해하고 처리하는 데 도움을 줌\n\n**도구 설명 (Tool Description):**\n- 기능에 대한 간결한 요약\n- 파라미터 설명\n- 반환 타입 스키마\n\n**구현:**\n- I/O 작업을 위한 Async/await 사용\n- 실행 가능한 메시지를 포함한 적절한 에러 핸들링\n- 해당되는 경우 페이지네이션 지원\n- 최신 SDK 사용 시 텍스트 콘텐츠와 구조화된 데이터 모두 반환\n\n**어노테이션 (Annotations):**\n- `readOnlyHint`: true/false\n- `destructiveHint`: true/false\n- `idempotentHint`: true/false\n- `openWorldHint`: true/false\n\n---\n\n### Phase 3: 검토 및 테스트 (Review and Test)\n\n#### 3.1 코드 품질\n\n다음을 검토하세요:\n- 중복 코드 없음 (DRY 원칙)\n- 일관된 에러 핸들링\n- 완전한 타입 커버리지\n- 명확한 도구 설명\n\n#### 3.2 빌드 및 테스트\n\n**TypeScript:**\n- 컴파일 확인을 위해 `npm run build` 실행\n- MCP Inspector로 테스트: `npx @modelcontextprotocol/inspector`\n\n**Python:**\n- 구문 확인: `python -m py_compile your_server.py`\n- MCP Inspector로 테스트\n\n상세한 테스트 접근 방식과 품질 체크리스트는 언어별 가이드를 참조하세요.\n\n---\n\n### Phase 4: 평가 생성 (Create Evaluations)\n\nMCP 서버를 구현한 후, 그 효과를 테스트하기 위해 포괄적인 평가(evaluations)를 만드세요.\n\n**전체 평가 가이드라인을 위해 [✅ Evaluation 가이드](./reference/evaluation.md)를 로드하세요.**\n\n#### 4.1 평가 목적 이해\n\n평가를 통해 LLM이 실제적이고 복잡한 질문에 답하기 위해 당신의 MCP 서버를 효과적으로 사용할 수 있는지 테스트합니다.\n\n#### 4.2 10개의 평가 질문 작성\n\n효과적인 평가를 위해 가이드에 설명된 프로세스를 따르세요:\n\n1. **도구 점검 (Tool Inspection)**: 사용 가능한 도구를 나열하고 기능을 이해합니다.\n2. **콘텐츠 탐색 (Content Exploration)**: 읽기 전용(READ-ONLY) 작업을 사용하여 사용 가능한 데이터 탐색\n3. **질문 생성**: 10개의 복잡하고 실제적인 질문 생성\n4. **답변 검증**: 직접 질문을 해결하여 답변 확인\n\n#### 4.3 평가 요구 사항\n\n각 질문이 다음을 충족하는지 확인하세요:\n- **독립성 (Independent)**: 다른 질문에 의존하지 않음\n- **읽기 전용 (Read-only)**: 비파괴적인 작업만 필요함\n- **복잡성 (Complex)**: 여러 도구 호출 및 심층적인 탐색 필요\n- **실제성 (Realistic)**: 인간이 관심을 가질 만한 실제 유스케이스 기반\n- **검증 가능성 (Verifiable)**: 문자열 비교로 검증 가능한 명확한 단일 답변\n- **안정성 (Stable)**: 답변이 시간이 지나도 변하지 않음\n\n#### 4.4 출력 형식\n\n다음 구조의 XML 파일을 생성하세요:\n\n```xml\n<evaluation>\n  <qa_pair>\n    <question>동물 코드명을 가진 AI 모델 출시에 관한 토론을 찾으세요. 한 모델은 ASL-X 형식을 사용하는 특정 안전 지정이 필요했습니다. 점박이 야생 고양이의 이름을 딴 모델에 대해 결정된 숫자 X는 무엇입니까?</question>\n    <answer>3</answer>\n  </qa_pair>\n<!-- 더 많은 qa_pair... -->\n</evaluation>\n```\n\n---\n\n# 참조 파일 (Reference Files)\n\n## 📚 문서 라이브러리 (Documentation Library)\n\n개발 중에 필요에 따라 다음 리소스를 로드하세요:\n\n### 핵심 MCP 문서 (가장 먼저 로드)\n- **MCP Protocol**: `https://modelcontextprotocol.io/sitemap.xml`의 사이트맵부터 시작하여 `.md` 접미사가 붙은 특정 페이지를 가져오세요.\n- [📋 MCP Best Practices](./reference/mcp_best_practices.md) - 다음을 포함한 범용 MCP 가이드라인:\n  - 서버 및 도구 명명 규칙\n  - 응답 형식 가이드라인 (JSON vs Markdown)\n  - 페이지네이션 모범 사례\n  - 전송 방식 선택 (streamable HTTP vs stdio)\n  - 보안 및 에러 핸들링 표준\n\n### SDK 문서 (Phase 1/2 중에 로드)\n- **Python SDK**: `https://raw.githubusercontent.com/modelcontextprotocol/python-sdk/main/README.md`에서 가져오기\n- **TypeScript SDK**: `https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/main/README.md`에서 가져오기\n\n### 언어별 구현 가이드 (Phase 2 중에 로드)\n- [🐍 Python 구현 가이드](./reference/python_mcp_server.md) - 다음을 포함한 전체 Python/FastMCP 가이드:\n  - 서버 초기화 패턴\n  - Pydantic 모델 예시\n  - `@mcp.tool`을 이용한 도구 등록\n  - 전체 작동 예시 코드\n  - 품질 체크리스트\n\n- [⚡ TypeScript 구현 가이드](./reference/node_mcp_server.md) - 다음을 포함한 전체 TypeScript 가이드:\n  - 프로젝트 구조\n  - Zod 스키마 패턴\n  - `server.registerTool`을 이용한 도구 등록\n  - 전체 작동 예시 코드\n  - 품질 체크리스트\n\n### 평가 가이드 (Phase 4 중에 로드)\n- [✅ Evaluation 가이드](./reference/evaluation.md) - 다음을 포함한 전체 평가 생성 가이드:\n  - 질문 작성 가이드라인\n  - 답변 검증 전략\n  - XML 형식 사양\n  - 질문 및 답변 예시\n  - 제공된 스크립트를 이용한 평가 실행 방법"
              },
              {
                "name": "sequential-thinking",
                "description": "다단계 분석, 수정 능력 및 가설 검증이 필요한 복잡한 작업을 위해 구조화되고 성찰적인 문제 해결 방식을 적용합니다. 복잡한 문제 분해, 적응형 계획 수립, 경로 수정이 필요한 분석, 범위가 불분명한 문제, 다단계 해결책 및 가설 기반 작업 시 사용합니다.",
                "path": "icartsh-plugin/skills/sequential-thinking/SKILL.md",
                "frontmatter": {
                  "name": "sequential-thinking",
                  "description": "다단계 분석, 수정 능력 및 가설 검증이 필요한 복잡한 작업을 위해 구조화되고 성찰적인 문제 해결 방식을 적용합니다. 복잡한 문제 분해, 적응형 계획 수립, 경로 수정이 필요한 분석, 범위가 불분명한 문제, 다단계 해결책 및 가설 기반 작업 시 사용합니다.",
                  "version": "1.0.0",
                  "license": "MIT"
                },
                "content": "# Sequential Thinking\n\n역동적인 조정을 동반한 관리 가능하고 성찰적인 사고 시퀀스를 통해 구조화된 문제 해결을 수행합니다.\n\n## 적용 시기\n\n- 복잡한 문제의 분해\n- 수정을 포함한 적응형 계획 수립\n- 경로 수정(course correction)이 필요한 분석\n- 범위가 불분명하거나 새로 형성되는 문제\n- 컨텍스트 유지가 필요한 다단계 해결책\n- 가설 기반의 조사/디버깅\n\n## 핵심 프로세스 (Core Process)\n\n### 1. 개략적인 추정으로 시작\n```\nThought 1/5: [초기 분석]\n```\n이해도가 높아짐에 따라 역동적으로 조정하세요.\n\n### 2. 각 사고의 구조화\n- 이전 컨텍스트를 명시적으로 기반으로 삼음\n- 사고당 하나의 측면만 다룸\n- 가정, 불확실성, 깨달은 점을 명시\n- 다음 사고에서 다루어야 할 내용 예고\n\n### 3. 역동적인 조정 (Dynamic Adjustment) 적용\n- **확장 (Expand)**: 더 많은 복잡성 발견 → 총 사고 횟수 증가\n- **축소 (Contract)**: 예상보다 단순함 → 총 사고 횟수 감소\n- **수정 (Revise)**: 새로운 통찰이 이전을 무효화함 → 수정 마킹\n- **분기 (Branch)**: 여러 접근 방식 존재 → 대안 탐색\n\n### 4. 필요시 수정(Revision) 사용\n```\nThought 5/8 [Thought 2의 REVISION]: [수정된 이해]\n- 이전 내용: [언급되었던 내용]\n- 수정 이유: [새로운 통찰]\n- 영향: [변경되는 사항]\n```\n\n### 5. 대안을 위한 분기 (Branching)\n```\nThought 4/7 [Thought 2에서 시작된 BRANCH A]: [접근 방식 A]\nThought 4/7 [Thought 2에서 시작된 BRANCH B]: [접근 방식 B]\n```\n명시적으로 비교하고, 결정 근거와 함께 수렴(converge)시키세요.\n\n### 6. 가설 생성 및 검증\n```\nThought 6/9 [HYPOTHESIS]: [제안된 해결책]\nThought 7/9 [VERIFICATION]: [테스트 결과]\n```\n가설이 검증될 때까지 반복하세요.\n\n### 7. 준비가 되었을 때만 완료\n최종 마킹: `Thought N/N [FINAL]`\n\n완료 조건:\n- 해결책 검증 완료\n- 모든 핵심 측면 처리 완료\n- 확신(Confidence) 확보\n- 해결되지 않은 불확실성 없음\n\n## 적용 모드 (Application Modes)\n\n**Explicit (명시적)**: 복잡성이 가시적인 추론을 정당화하거나 사용자가 분석을 요청할 때 가시적인 사고 마커를 사용합니다.\n\n**Implicit (암묵적)**: 응답을 복잡하게 만들지 않으면서 정확도를 높이기 위해 일상적인 문제 해결 시 내부적으로 방법론을 적용합니다.\n\n## 스크립트 (선택 사항)\n\n결정론적 검증/추적을 위한 선택적 스크립트:\n- `scripts/process-thought.js` - 히스토리와 함께 사고를 검증하고 추적\n- `scripts/format-thought.js` - 표시용 포맷팅 (박스/마크다운/단순형)\n\n사용 예시는 README.md를 참조하세요. 검증이나 로그 보존이 필요할 때 사용하며, 그렇지 않으면 방법론을 직접 적용합니다.\n\n## 참조 문서 (References)\n\n더 깊은 이해가 필요할 때 로드하세요:\n- `references/core-patterns.md` - 수정 및 분기 패턴\n- `references/examples-api.md` - API 설계 예시\n- `references/examples-debug.md` - 디버깅 예시\n- `references/examples-architecture.md` - 아키텍처 결정 예시\n- `references/advanced-techniques.md` - 나선형 정밀화(spiral refinement), 가설 테스트, 수렴\n- `references/advanced-strategies.md` - 불확실성, 수정 케스케이드(revision cascades), 메타 사고(meta-thinking)"
              },
              {
                "name": "skill-creator",
                "description": "효과적인 SKILL을 제작하기 위한 가이드입니다. 특화된 지식, 워크플로우 또는 도구 통합을 통해 Claude의 기능을 확장하는 새로운 SKILL을 생성하거나 기존 SKILL을 업데이트하려는 경우 이 SKILL을 사용하세요.",
                "path": "icartsh-plugin/skills/skill-creator/SKILL.md",
                "frontmatter": {
                  "name": "skill-creator",
                  "description": "효과적인 SKILL을 제작하기 위한 가이드입니다. 특화된 지식, 워크플로우 또는 도구 통합을 통해 Claude의 기능을 확장하는 새로운 SKILL을 생성하거나 기존 SKILL을 업데이트하려는 경우 이 SKILL을 사용하세요.",
                  "license": "LICENSE.txt의 전체 약관 참조"
                },
                "content": "# Skill Creator\n\n이 SKILL은 효과적인 SKILL을 생성하기 위한 지침을 제공합니다.\n\n## SKILL에 대하여\n\nSKILL은 특화된 지식, 워크플로우 및 도구를 제공하여 Claude의 기능을 확장하는 모듈화된 독립 패키지입니다. 특정 분야나 작업을 위한 \"온보딩 가이드\"라고 생각하세요. SKILL은 Claude를 일반 에이전트에서 특정 모델이 온전히 소유하기 어려운 절차적 지식을 갖춘 전문 에이전트로 변화시킵니다.\n\n### SKILL이 제공하는 것\n\n1. 특화된 워크플로우 - 특정 분야를 위한 다단계 절차\n2. 도구 통합 - 특정 파일 형식 또는 API 작업 지침\n3. 도메인 전문 지식 - 회사별 지식, 스키마, 비즈니스 로직\n4. 번들 리소스 - 복잡하고 반복적인 작업을 위한 스크립트, 참조 문서 및 에셋\n\n## 핵심 원칙 (Core Principles)\n\n### 간결함이 핵심 (Concise is Key)\n\n컨텍스트 윈도우(context window)는 공공재와 같습니다. SKILL은 시스템 프롬프트, 대화 히스토리, 다른 SKILL의 메타데이터, 그리고 실제 사용자 요청 등 Claude가 필요로 하는 모든 요소와 컨텍스트 공간을 공유합니다.\n\n**기본 전제: Claude는 이미 충분히 똑똑합니다.** Claude가 아직 가지고 있지 않은 컨텍스트만 추가하세요. 정보 하나하나에 대해 자문해 보세요: \"Claude에게 이 설명이 정말 필요한가?\", \"이 문단이 소모되는 토큰만큼의 가치가 있는가?\"\n\n장황한 설명보다는 간결한 예시를 선호하세요.\n\n### 적절한 자유도 설정 (Set Appropriate Degrees of Freedom)\n\n작업의 취약성과 변동성에 맞춰 구체화 수준을 조정하세요:\n\n**높은 자유도 (텍스트 기반 지침)**: 여러 접근 방식이 유효하거나, 결정이 컨텍스트에 달려 있거나, 휴리스틱(heuristics)이 접근 방식을 안내할 때 사용합니다.\n\n**중간 자유도 (의사코드 또는 파라미터가 있는 스크립트)**: 선호되는 패턴이 존재하거나, 약간의 변동이 허용되거나, 설정이 동작에 영향을 줄 때 사용합니다.\n\n**낮은 자유도 (특정 스크립트, 적은 파라미터)**: 작업이 취약하고 오류가 발생하기 쉽거나, 일관성이 중요하거나, 특정 순서를 반드시 지켜야 할 때 사용합니다.\n\nClaude가 길을 탐색하는 것을 상상해 보세요: 절벽이 있는 좁은 다리에는 구체적인 보호 난간(낮은 자유도)이 필요하고, 탁 트인 들판에서는 다양한 경로(높은 자유도)가 허용됩니다.\n\n### SKILL의 구조 (Anatomy of a Skill)\n\n모든 SKILL은 필수 파일인 SKILL.md와 선택적인 번들 리소스로 구성됩니다:\n\n```\nskill-name/\n├── SKILL.md (필수)\n│   ├── YAML frontmatter metadata (필수)\n│   │   ├── name: (필수)\n│   │   └── description: (필수)\n│   └── Markdown 지침 (필수)\n└── Bundled Resources (선택 사항)\n    ├── scripts/          - 실행 가능한 코드 (Python/Bash 등)\n    ├── references/       - 필요에 따라 컨텍스트에 로드할 문서\n    └── assets/           - 출력물에 사용될 파일 (템플릿, 아이콘, 폰트 등)\n```\n\n#### SKILL.md (필수)\n\n모든 SKILL.md는 다음으로 구성됩니다:\n\n- **Frontmatter** (YAML): `name`과 `description` 필드를 포함합니다. Claude가 SKILL의 사용 여부를 결정하기 위해 읽는 유일한 필드이므로, SKILL이 무엇인지와 언제 사용해야 하는지에 대해 명확하고 포괄적으로 설명하는 것이 매우 중요합니다.\n- **Body** (Markdown): SKILL을 사용하기 위한 지침과 안내입니다. SKILL이 트리거된 '이후'에만 로드됩니다.\n\n#### 번들 리소스 (선택 사항)\n\n##### 스크립트 (`scripts/`)\n\n결정론적인 신뢰성이 필요하거나 반복적으로 재작성되는 작업을 위한 실행 가능한 코드(Python/Bash 등)입니다.\n\n- **포함 시기**: 동일한 코드가 반복적으로 작성되거나 결정론적인(deterministic) 신뢰성이 필요한 경우\n- **예시**: PDF 회전 작업을 위한 `scripts/rotate_pdf.py`\n- **장점**: 토큰 효율적이며 결정론적이고, 컨텍스트에 로드하지 않고도 실행될 수 있음\n- **참고**: 패칭(patching)이나 환경별 조정을 위해 Claude가 스크립트를 읽어야 할 수도 있음\n\n##### 참조 문서 (`references/`)\n\nClaude의 프로세스와 사고를 돕기 위해 필요에 따라 컨텍스트에 로드하도록 의도된 문서 및 참조 자료입니다.\n\n- **포함 시기**: Claude가 작업 중에 참조해야 할 문서가 있는 경우\n- **예시**: 금융 스키마를 위한 `references/finance.md`, 회사 NDA 템플릿을 위한 `references/mnda.md`, 회사 정책을 위한 `references/policies.md`, API 사양을 위한 `references/api_docs.md`\n- **유스케이스**: 데이터베이스 스키마, API 문서, 도메인 지식, 회사 정책, 상세 워크플로우 가이드\n- **장점**: SKILL.md를 가볍게 유지하며, Claude가 필요하다고 판단할 때만 로드됨\n- **모범 사례**: 파일이 큰 경우(>10k 단어), SKILL.md에 grep 검색 패턴을 포함하세요.\n- **중복 방지**: 정보는 SKILL.md나 참조 파일 중 한 곳에만 있어야 합니다. 정보의 발견 가능성은 유지하면서 컨텍스트 윈도우 점유를 줄이기 위해, 정말 핵심적인 지침이 아니라면 상세 정보는 참조 파일에 두는 것을 선호하세요. SKILL.md에는 필수적인 절차 지침과 워크플로우 안내만 유지하고, 상세 참조 자료, 스키마, 예시는 참조 파일로 옮기세요.\n\n##### 에셋 (`assets/`)\n\n컨텍스트에 로드하도록 의도된 것이 아니라, Claude가 생성하는 출력물 내에서 사용하기 위한 파일입니다.\n\n- **포함 시기**: 최종 출력물에 사용될 파일이 SKILL에 필요한 경우\n- **예시**: 브랜드 에셋용 `assets/logo.png`, 파워포인트 템플릿용 `assets/slides.pptx`, HTML/React 보일러플레이트용 `assets/frontend-template/`, 타이포그래피용 `assets/font.ttf`\n- **유스케이스**: 템플릿, 이미지, 아이콘, 보일러플레이트 코드, 폰트, 복사하거나 수정하여 사용할 샘플 문서\n- **장점**: 출력용 리소스를 문서와 분리하며, Claude가 파일을 컨텍스트에 로드하지 않고도 사용할 수 있게 함\n\n#### SKILL에 포함하지 말아야 할 것\n\nSKILL은 그 기능을 직접적으로 지원하는 필수 파일들만 포함해야 합니다. 다음과 같은 불필요한 문서나 보조 파일들을 만들지 마세요:\n\n- README.md\n- INSTALLATION_GUIDE.md\n- QUICK_REFERENCE.md\n- CHANGELOG.md\n- 기타 등등\n\nSKILL에는 AI 에이전트가 주어진 작업을 수행하는 데 필요한 정보만 포함되어야 합니다. 제작 과정에 대한 부수적인 컨텍스트, 설정 및 테스트 절차, 사용자용 문서 등은 포함하지 마세요. 불필요한 문서 파일은 혼란만 가중시킵니다.\n\n### 점진적 노출 디자인 원칙 (Progressive Disclosure Design Principle)\n\nSKILL은 컨텍스트를 효율적으로 관리하기 위해 3단계 로딩 시스템을 사용합니다:\n\n1. **메타데이터 (name + description)** - 항상 컨텍스트에 상주 (~100 단어)\n2. **SKILL.md 본문** - SKILL이 트리거될 때 로드 (<5k 단어)\n3. **번들 리소스** - Claude가 필요할 때 로드 (스크립트는 컨텍스트 로드 없이 실행 가능하므로 용량 제한 없음)\n\n#### 점진적 노출 패턴\n\n컨텍스트 비대화를 최소화하기 위해 SKILL.md 본문은 필수 사항 위주로 500행 미만으로 유지하세요. 이 제한에 도달하면 콘텐츠를 별도 파일로 나누세요. 콘텐츠를 다른 파일로 분리할 때는, SKILL을 읽는 모델이 해당 파일의 존재와 사용 시점을 알 수 있도록 SKILL.md에서 이를 참조하고 언제 읽어야 하는지 명확히 설명하는 것이 매우 중요합니다.\n\n**핵심 원칙:** SKILL이 여러 변형(variations), 프레임워크 또는 옵션을 지원하는 경우, SKILL.md에는 핵심 워크플로우와 선택 가이드만 유지하세요. 특정 변형에 국한된 세부 사항(패턴, 예시, 설정)은 별도의 참조 파일로 옮기세요.\n\n**패턴 1: 참조 문서를 동반한 상위 수준 가이드**\n\n```markdown\n# PDF Processing\n\n## 빠른 시작\n\npdfplumber로 텍스트 추출:\n[코드 예시]\n\n## 고급 기능\n\n- **폼 채우기(Form filling)**: 전체 가이드는 [FORMS.md](FORMS.md) 참조\n- **API 참조**: 모든 메서드는 [REFERENCE.md](REFERENCE.md) 참조\n- **예시**: 일반적인 패턴은 [EXAMPLES.md](EXAMPLES.md) 참조\n```\n\nClaude는 필요할 때만 FORMS.md, REFERENCE.md 또는 EXAMPLES.md를 로드합니다.\n\n**패턴 2: 도메인별 조직화**\n\n여러 도메인을 가진 SKILL의 경우, 무관한 컨텍스트 로드를 피하기 위해 도메인별로 콘텐츠를 구성하세요:\n\n```\nbigquery-skill/\n├── SKILL.md (개요 및 탐색)\n└── reference/\n    ├── finance.md (매출, 청구 지표)\n    ├── sales.md (기회, 파이프라인)\n    ├── product.md (API 사용량, 기능)\n    └── marketing.md (캠페인, 어트리뷰션)\n```\n\n사용자가 매출 지표에 대해 물으면, Claude는 sales.md만 읽습니다.\n\n마찬가지로 여러 프레임워크나 변형을 지원하는 SKILL도 변형별로 정리하세요:\n\n```\ncloud-deploy/\n├── SKILL.md (워크플로우 + 프로바이더 선택)\n└── references/\n    ├── aws.md (AWS 배포 패턴)\n    ├── gcp.md (GCP 배포 패턴)\n    └── azure.md (Azure 배포 패턴)\n```\n\n사용자가 AWS를 선택하면, Claude는 aws.md만 읽습니다.\n\n**패턴 3: 조건부 세부 사항**\n\n기본 콘텐츠를 보여주고, 고급 콘텐츠로 링크를 제공하세요:\n\n```markdown\n# DOCX Processing\n\n## 문서 생성\n\n새 문서에는 docx-js를 사용하세요. [DOCX-JS.md](DOCX-JS.md) 참조.\n\n## 문서 편집\n\n단순한 편집의 경우 XML을 직접 수정하세요.\n\n**수정 내용 추적(tracked changes)의 경우**: [REDLINING.md](REDLINING.md) 참조\n**OOXML 세부 사항의 경우**: [OOXML.md](OOXML.md) 참조\n```\n\nClaude는 사용자가 해당 기능을 필요로 할 때만 REDLINING.md 또는 OOXML.md를 읽습니다.\n\n**중요 가이드라인:**\n\n- **깊은 중첩 참조 지양** - 참조는 SKILL.md에서 한 단계 깊이까지만 유지하세요. 모든 참조 파일은 SKILL.md에서 직접 링크되어야 합니다.\n- **긴 참조 파일 구조화** - 100행 이상의 파일은 상단에 목차를 포함하여 Claude가 미리보기 시 전체 범위를 파악할 수 있게 하세요.\n\n## SKILL 제작 프로세스 (Skill Creation Process)\n\nSKILL 제작은 다음 단계로 이루어집니다:\n\n1. 구체적인 예시를 통한 SKILL 이해 (Understand)\n2. 재사용 가능한 SKILL 콘텐츠 계획 (Plan)\n3. SKILL 초기화 (init_skill.py 실행)\n4. SKILL 편집 (리소스 구현 및 SKILL.md 작성)\n5. SKILL 패키징 (package_skill.py 실행)\n6. 실제 사용을 바탕으로 반복 개선 (Iterate)\n\n정당한 사유가 없는 한 이 단계를 순서대로 따르세요.\n\n### Step 1: 구체적인 예시를 통한 SKILL 이해\n\nSKILL의 사용 패턴이 이미 명확히 이해된 경우에만 이 단계를 생략하세요. 기존 SKILL을 개선할 때도 이 단계는 가치가 있습니다.\n\n효과적인 SKILL을 제작하려면 SKILL이 어떻게 사용될지에 대한 구체적인 예시를 명확히 이해해야 합니다. 이는 직접적인 사용자 예시나, 사용자 피드백을 통해 검증된 생성 예시를 통해 가능합니다.\n\n예를 들어, image-editor SKILL을 빌드할 때 다음과 같은 질문들이 도움이 됩니다:\n\n- \"image-editor SKILL은 어떤 기능을 지원해야 합니까? 편집, 회전, 그 외에 다른 기능은요?\"\n- \"이 SKILL이 어떻게 사용될지에 대한 몇 가지 예를 들어주실 수 있나요?\"\n- \"사용자들이 '이 이미지에서 적목 현상을 제거해줘'나 '이 이미지를 회전시켜줘'와 같은 요청을 할 것 같은데, 또 다른 유스케이스가 있을까요?\"\n- \"사용자가 어떤 말을 했을 때 이 SKILL이 트리거되어야 합니까?\"\n\n사용자에게 부담을 주지 않기 위해 한 메시지에 너무 많은 질문을 하지 마세요. 가장 중요한 질문부터 시작하고 효과를 높이기 위해 필요에 따라 후속 질문을 하세요.\n\nSKILL이 지원해야 할 기능에 대한 명확한 감이 잡히면 이 단계를 마칩니다.\n\n### Step 2: 재사용 가능한 SKILL 콘텐츠 계획\n\n구체적인 예시를 효과적인 SKILL로 바꾸기 위해, 각 예시를 다음과 같이 분석하세요:\n\n1. 해당 예시를 처음부터 어떻게 실행할지 고려\n2. 이 워크플로우를 반복적으로 실행할 때 도움이 될 스크립트, 참조 문서 및 에셋 식별\n\n예시: \"이 PDF를 회전시켜줘\"와 같은 쿼리를 처리하기 위한 `pdf-editor` SKILL을 빌드할 때의 분석:\n\n1. PDF를 회전하려면 매번 동일한 코드를 다시 작성해야 함\n2. `scripts/rotate_pdf.py` 스크립트를 SKILL에 저장해두면 도움이 됨\n\n예시: \"할 일 앱을 만들어줘\"나 \"내 걸음 수를 추적할 대시보드를 만들어줘\"와 같은 쿼리를 처리하기 위한 `frontend-webapp-builder` SKILL을 설계할 때의 분석:\n\n1. 프런트엔드 웹앱을 작성할 때마다 동일한 보일러플레이트 HTML/React가 필요함\n2. 보일러플레이트 HTML/React 프로젝트 파일이 포함된 `assets/hello-world/` 템플릿을 SKILL에 저장해두면 도움이 됨\n\n예시: \"오늘 몇 명의 사용자가 로그인했지?\"와 같은 쿼리를 처리하기 위한 `big-query` SKILL을 빌드할 때의 분석:\n\n1. BigQuery를 쿼리할 때마다 테이블 스키마와 관계를 매번 다시 확인해야 함\n2. 테이블 스키마를 문서화한 `references/schema.md` 파일을 SKILL에 저장해두면 도움이 됨\n\nSKILL의 콘텐츠를 확립하기 위해, 각 구체적인 예시를 분석하여 포함할 재사용 리소스(스크립트, 참조 문서, 에셋) 목록을 만드세요.\n\n### Step 3: SKILL 초기화\n\n이제 실제로 SKILL을 생성할 차례입니다.\n\n개발하려는 SKILL이 이미 존재하고 개선이나 패키징만 필요한 경우에는 이 단계를 생략하고 다음 단계로 진행하세요.\n\n새로운 SKILL을 처음부터 생성할 때는 항상 `init_skill.py` 스크립트를 실행하세요. 이 스크립트는 SKILL에 필요한 모든 것을 자동으로 포함하는 새 템플릿 SKILL 디렉토리를 생성하여, 제작 과정을 훨씬 효율적이고 안정적으로 만들어줍니다.\n\n사용법:\n\n```bash\nscripts/init_skill.py <skill-name> --path <output-directory>\n```\n\n이 스크립트는:\n\n- 지정된 경로에 SKILL 디렉토리 생성\n- 올바른 frontmatter와 TODO 위치 표시가 포함된 SKILL.md 템플릿 생성\n- 예시 리소스 디렉토리 생성: `scripts/`, `references/`, `assets/`\n- 커스터마이징하거나 삭제할 수 있는 각 디렉토리별 예시 파일 추가\n\n초기화 후에는 생성된 SKILL.md와 예시 파일들을 필요에 따라 커스터마이징하거나 삭제하세요.\n\n### Step 4: SKILL 편집\n\n(새로 생성되었거나 기존의) SKILL을 편집할 때, 이 SKILL은 Claude의 다른 인스턴스가 사용하기 위해 만들어진다는 점을 명심하세요. Claude에게 유익하면서도 자명하지 않은 정보를 포함하세요. 다른 Claude 인스턴스가 이러한 작업을 더 효과적으로 수행하도록 돕기 위해 어떤 절차적 지식, 도메인 세부 사항 또는 재사용 가능한 에셋이 도움이 될지 고려하세요.\n\n#### 검증된 디자인 패턴 학습\n\nSKILL의 필요에 따라 다음 가이드를 참조하세요:\n\n- **다단계 프로세스**: 순차적 워크플로우와 조건부 로직에 대해서는 references/workflows.md를 참조하세요.\n- **특정 출력 형식 또는 품질 표준**: 템플릿 및 예시 패턴에 대해서는 references/output-patterns.md를 참조하세요.\n\n이 파일들에는 효과적인 SKILL 디자인을 위한 검증된 모범 사례가 포함되어 있습니다.\n\n#### 재사용 가능한 SKILL 콘텐츠부터 시작\n\n구현을 시작하기 위해 위에서 식별한 재사용 가능한 리소스(`scripts/`, `references/`, `assets/`) 파일들부터 작성하세요. 이 단계에서 사용자의 입력이 필요할 수 있습니다. 예를 들어 `brand-guidelines` SKILL을 구현할 때, 사용자가 `assets/`에 저장할 브랜드 에셋이나 템플릿, 또는 `references/`에 저장할 문서를 제공해야 할 수 있습니다.\n\n추가된 스크립트는 실제로 실행하여 버그가 없는지, 출력이 예상과 일치하는지 반드시 테스트해야 합니다. 유사한 스크립트가 많은 경우, 완료 시간을 조절하면서도 신뢰성을 확보할 수 있도록 대표적인 샘플만 테스트하면 됩니다.\n\nSKILL에 필요하지 않은 예시 파일과 디렉토리는 삭제해야 합니다. 초기화 스크립트는 구조를 보여주기 위해 각 디렉토리에 예시 파일들을 생성하지만, 대부분의 SKILL에서 이들이 모두 필요하지는 않습니다.\n\n#### SKILL.md 업데이트\n\n**작성 가이드라인:** 항상 명령형/부정사(imperative/infinitive) 형식을 사용하세요.\n\n##### Frontmatter\n\n`name`과 `description` 필드가 포함된 YAML frontmatter를 작성하세요:\n\n- `name`: SKILL 이름\n- `description`: SKILL의 주요 트리거 메커니즘이며, Claude가 언제 이 SKILL을 사용해야 할지 이해하도록 돕습니다.\n  - SKILL이 무엇을 하는지와 이를 언제 사용해야 하는지에 대한 구체적인 트리거/컨텍스트를 모두 포함하세요.\n  - \"언제 사용할지\"에 대한 모든 정보는 본문이 아닌 이곳에 포함하세요. 본문은 트리거된 후에 로드되므로, 본문의 \"When to Use This Skill\" 섹션은 Claude에게 도움이 되지 않습니다.\n  - `docx` SKILL의 예시 설명: \"수정 내용 추적(tracked changes), 메모, 포맷 보존 및 텍스트 추출을 지원하는 포괄적인 문서 생성, 편집 및 분석입니다. Claude가 다음을 위해 전문적인 문서(.docx 파일) 작업이 필요할 때 사용하세요: (1) 새 문서 생성, (2) 내용 수정 또는 편집, (3) 수정 내용 추적 작업, (4) 메모 추가 또는 기타 문서 관련 작업\"\n\nYAML frontmatter에 다른 필드를 포함하지 마세요.\n\n##### 본문 (Body)\n\nSKILL과 번들 리소스를 사용하기 위한 지침을 작성하세요.\n\n### Step 5: SKILL 패키징\n\nSKILL 개발이 완료되면, 사용자에게 공유할 배포용 .skill 파일로 패키징해야 합니다. 패키징 프로세스는 먼저 모든 요구 사항을 충족하는지 SKILL을 자동으로 검증합니다:\n\n```bash\nscripts/package_skill.py <path/to/skill-folder>\n```\n\n선택적인 출력 디렉토리 지정:\n\n```bash\nscripts/package_skill.py <path/to/skill-folder> ./dist\n```\n\n패키징 스크립트는 다음을 수행합니다:\n\n1. **검증 (Validate)**: SKILL을 자동으로 검사하며 다음 사항들을 확인합니다:\n\n   - YAML frontmatter 형식 및 필수 필드\n   - SKILL 명명 규칙 및 디렉토리 구조\n   - 설명(description)의 완전성 및 품질\n   - 파일 조직 및 리소스 참조\n\n2. **패키징 (Package)**: 검증을 통과하면 배포를 위한 적절한 디렉토리 구조와 모든 파일을 포함하는, SKILL 이름으로 명명된 .skill 파일(예: `my-skill.skill`)을 생성합니다. .skill 파일은 .skill 확장자를 가진 zip 파일입니다.\n\n검증에 실패하면 스크립트는 에러를 보고하고 패키지를 생성하지 않은 채 종료됩니다. 검증 에러를 수정한 후 패키징 명령을 다시 실행하세요.\n\n### Step 6: 반복 개선 (Iterate)\n\nSKILL을 테스트한 후 사용자가 개선을 요청할 수 있습니다. 이는 대개 SKILL이 어떻게 작동했는지에 대한 생생한 컨텍스트가 남아 있는 사용 직후에 발생합니다.\n\n**반복 워크플로우:**\n\n1. 실제 작업에 SKILL을 사용\n2. 어려움이나 비효율적인 부분 발견\n3. SKILL.md나 번들 리소스를 어떻게 업데이트해야 할지 식별\n4. 변경 사항 구현 및 재테스트"
              },
              {
                "name": "sql-optimization-patterns",
                "description": "SQL 쿼리 최적화, 인덱스 전략 및 EXPLAIN 분석을 마스터하여 데이터베이스 성능을 획기적으로 향상시키고 느린 쿼리를 제거합니다. 느린 쿼리 디버깅, 데이터베이스 스키마 설계 또는 애플리케이션 성능 최적화 시 사용하세요.",
                "path": "icartsh-plugin/skills/sql-optimization-patterns/SKILL.md",
                "frontmatter": {
                  "name": "sql-optimization-patterns",
                  "description": "SQL 쿼리 최적화, 인덱스 전략 및 EXPLAIN 분석을 마스터하여 데이터베이스 성능을 획기적으로 향상시키고 느린 쿼리를 제거합니다. 느린 쿼리 디버깅, 데이터베이스 스키마 설계 또는 애플리케이션 성능 최적화 시 사용하세요."
                },
                "content": "# SQL Optimization Patterns\n\n체계적인 최적화, 올바른 인덱싱 및 쿼리 실행 계획 분석을 통해 느린 데이터베이스 쿼리를 번개처럼 빠른 작업으로 변환하세요.\n\n## 적용 시기\n\n- 느리게 실행되는 쿼리 디버깅\n- 성능이 뛰어난 데이터베이스 스키마 설계\n- 애플리케이션 응답 시간 최적화\n- 데이터베이스 부하 및 비용 절감\n- 데이터 증가에 따른 확장성 개선\n- EXPLAIN 쿼리 실행 계획 분석\n- 효율적인 인덱스 구현\n- N+1 쿼리 문제 해결\n\n## 핵심 개념 (Core Concepts)\n\n### 1. 쿼리 실행 계획 (EXPLAIN)\n\nEXPLAIN 출력을 이해하는 것은 최적화의 기본입니다.\n\n**PostgreSQL EXPLAIN:**\n```sql\n-- 기본 실행 계획 확인\nEXPLAIN SELECT * FROM users WHERE email = 'user@example.com';\n\n-- 실제 실행 통계 포함\nEXPLAIN ANALYZE\nSELECT * FROM users WHERE email = 'user@example.com';\n\n-- 더 많은 세부 정보를 포함한 상세 출력\nEXPLAIN (ANALYZE, BUFFERS, VERBOSE)\nSELECT u.*, o.order_total\nFROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE u.created_at > NOW() - INTERVAL '30 days';\n```\n\n**주의 깊게 봐야 할 주요 지표:**\n- **Seq Scan**: 전체 테이블 스캔 (대용량 테이블에서는 대개 느림)\n- **Index Scan**: 인덱스 사용 (좋음)\n- **Index Only Scan**: 테이블 접근 없이 인덱스만 사용 (가장 좋음)\n- **Nested Loop**: 조인 방식 (작은 데이터셋에는 괜찮음)\n- **Hash Join**: 조인 방식 (큰 데이터셋에 좋음)\n- **Merge Join**: 조인 방식 (정렬된 데이터에 좋음)\n- **Cost**: 추정된 쿼리 비용 (낮을수록 좋음)\n- **Rows**: 추정된 반환 행 수\n- **Actual Time**: 실제 실행 시간\n\n### 2. 인덱스 전략 (Index Strategies)\n\n인덱스는 가장 강력한 최적화 도구입니다.\n\n**인덱스 유형:**\n- **B-Tree**: 기본값, 등호(=) 및 범위 쿼리에 좋음\n- **Hash**: 등호(=) 비교에만 사용\n- **GIN**: 전체 텍스트 검색, 배열 쿼리, JSONB\n- **GiST**: 기하학적 데이터, 전체 텍스트 검색\n- **BRIN**: 데이터 간 상관관계가 있는 매우 큰 테이블을 위한 블록 범위 인덱스\n\n```sql\n-- 표준 B-Tree 인덱스\nCREATE INDEX idx_users_email ON users(email);\n\n-- 복합 인덱스 (순서가 중요합니다!)\nCREATE INDEX idx_orders_user_status ON orders(user_id, status);\n\n-- 부분 인덱스 (행의 일부만 인덱싱)\nCREATE INDEX idx_active_users ON users(email)\nWHERE status = 'active';\n\n-- 표현식 인덱스 (함수 기반 인덱스)\nCREATE INDEX idx_users_lower_email ON users(LOWER(email));\n\n-- 커버링 인덱스 (추가 컬럼 포함)\nCREATE INDEX idx_users_email_covering ON users(email)\nINCLUDE (name, created_at);\n\n-- 전체 텍스트 검색 인덱스\nCREATE INDEX idx_posts_search ON posts\nUSING GIN(to_tsvector('english', title || ' ' || body));\n\n-- JSONB 인덱스\nCREATE INDEX idx_metadata ON events USING GIN(metadata);\n```\n\n### 3. 쿼리 최적화 패턴\n\n**SELECT * 피하기:**\n```sql\n-- 나쁨: 불필요한 모든 컬럼을 가져옴\nSELECT * FROM users WHERE id = 123;\n\n-- 좋음: 필요한 컬럼만 명시\nSELECT id, email, name FROM users WHERE id = 123;\n```\n\n**WHERE 절의 효율적 사용:**\n```sql\n-- 나쁨: 함수 사용으로 인덱스 활용 불가\nSELECT * FROM users WHERE LOWER(email) = 'user@example.com';\n\n-- 좋음: 함수 기반 인덱스(functional index) 생성 또는 정확한 일치 사용\nCREATE INDEX idx_users_email_lower ON users(LOWER(email));\n-- 그 다음:\nSELECT * FROM users WHERE LOWER(email) = 'user@example.com';\n\n-- 또는 데이터를 정규화하여 저장\nSELECT * FROM users WHERE email = 'user@example.com';\n```\n\n**JOIN 최적화:**\n```sql\n-- 나쁨: 카테시안 곱 생성 후 필터링\nSELECT u.name, o.total\nFROM users u, orders o\nWHERE u.id = o.user_id AND u.created_at > '2024-01-01';\n\n-- 좋음: 조인 전 필터링\nSELECT u.name, o.total\nFROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE u.created_at > '2024-01-01';\n\n-- 더 좋음: 두 테이블 모두 사전 필터링\nSELECT u.name, o.total\nFROM (SELECT * FROM users WHERE created_at > '2024-01-01') u\nJOIN orders o ON u.id = o.user_id;\n```\n\n## 최적화 패턴 (Optimization Patterns)\n\n### 패턴 1: N+1 쿼리 제거\n\n**문제: N+1 쿼리 안티 패턴**\n```python\n# 나쁨: N+1개의 쿼리를 실행함\nusers = db.query(\"SELECT * FROM users LIMIT 10\")\nfor user in users:\n    orders = db.query(\"SELECT * FROM orders WHERE user_id = ?\", user.id)\n    # orders 처리\n```\n\n**해결책: JOIN 또는 배치 로딩(Batch Loading) 사용**\n```sql\n-- 해결책 1: JOIN 사용\nSELECT\n    u.id, u.name,\n    o.id as order_id, o.total\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nWHERE u.id IN (1, 2, 3, 4, 5);\n\n-- 해결책 2: 배치 쿼리\nSELECT * FROM orders\nWHERE user_id IN (1, 2, 3, 4, 5);\n```\n\n```python\n# 좋음: JOIN 또는 배치 로드를 통한 단일 쿼리 실행\n# JOIN 사용 시\nresults = db.query(\"\"\"\n    SELECT u.id, u.name, o.id as order_id, o.total\n    FROM users u\n    LEFT JOIN orders o ON u.id = o.user_id\n    WHERE u.id IN (1, 2, 3, 4, 5)\n\"\"\")\n\n# 또는 배치 로드(Batch load)\nusers = db.query(\"SELECT * FROM users LIMIT 10\")\nuser_ids = [u.id for u in users]\norders = db.query(\n    \"SELECT * FROM orders WHERE user_id IN (?)\",\n    user_ids\n)\n# user_id별로 orders 그룹화\norders_by_user = {}\nfor order in orders:\n    orders_by_user.setdefault(order.user_id, []).append(order)\n```\n\n### 패턴 2: 페이지네이션(Pagination) 최적화\n\n**나쁨: 대용량 테이블에서의 OFFSET 사용**\n```sql\n-- 큰 offset 값에서 속도 저하 발생\nSELECT * FROM users\nORDER BY created_at DESC\nLIMIT 20 OFFSET 100000;  -- 매우 느림!\n```\n\n**좋음: 커서 기반 페이지네이션 (Cursor-Based Pagination)**\n```sql\n-- 훨씬 빠름: 커서(마지막 확인된 ID) 사용\nSELECT * FROM users\nWHERE created_at < '2024-01-15 10:30:00'  -- 마지막 커서\nORDER BY created_at DESC\nLIMIT 20;\n\n-- 복합 정렬 시\nSELECT * FROM users\nWHERE (created_at, id) < ('2024-01-15 10:30:00', 12345)\nORDER BY created_at DESC, id DESC\nLIMIT 20;\n\n-- 인덱스 필요\nCREATE INDEX idx_users_cursor ON users(created_at DESC, id DESC);\n```\n\n### 패턴 3: 효율적인 집계 (Aggregate Efficiently)\n\n**COUNT 쿼리 최적화:**\n```sql\n-- 나쁨: 모든 행을 카운트함\nSELECT COUNT(*) FROM orders;  -- 큰 테이블에서 느림\n\n-- 좋음: 근사치를 위한 추정치(estimates) 사용\nSELECT reltuples::bigint AS estimate\nFROM pg_class\nWHERE relname = 'orders';\n\n-- 좋음: 카운트 전 필터링 적용\nSELECT COUNT(*) FROM orders\nWHERE created_at > NOW() - INTERVAL '7 days';\n\n-- 더 좋음: 인덱스 전용 스캔(index-only scan) 활용\nCREATE INDEX idx_orders_created ON orders(created_at);\nSELECT COUNT(*) FROM orders\nWHERE created_at > NOW() - INTERVAL '7 days';\n```\n\n**GROUP BY 최적화:**\n```sql\n-- 나쁨: 그룹화 후 필터링\nSELECT user_id, COUNT(*) as order_count\nFROM orders\nGROUP BY user_id\nHAVING COUNT(*) > 10;\n\n-- 좋음: 가능한 경우 먼저 필터링 후 그룹화\nSELECT user_id, COUNT(*) as order_count\nFROM orders\nWHERE status = 'completed'\nGROUP BY user_id\nHAVING COUNT(*) > 10;\n\n-- 가장 좋음: 커버링 인덱스 활용\nCREATE INDEX idx_orders_user_status ON orders(user_id, status);\n```\n\n### 패턴 4: 서브쿼리 최적화\n\n**상관 서브쿼리(Correlated Subqueries) 변환:**\n```sql\n-- 나쁨: 상관 서브쿼리 (각 행마다 실행됨)\nSELECT u.name, u.email,\n    (SELECT COUNT(*) FROM orders o WHERE o.user_id = u.id) as order_count\nFROM users u;\n\n-- 좋음: 집계가 포함된 JOIN\nSELECT u.name, u.email, COUNT(o.id) as order_count\nFROM users u\nLEFT JOIN orders o ON o.user_id = u.id\nGROUP BY u.id, u.name, u.email;\n\n-- 더 좋음: 윈도우 함수 사용\nSELECT DISTINCT ON (u.id)\n    u.name, u.email,\n    COUNT(o.id) OVER (PARTITION BY u.id) as order_count\nFROM users u\nLEFT JOIN orders o ON o.user_id = u.id;\n```\n\n**가독성을 위한 CTE 사용:**\n```sql\n-- 공통 테이블 식별자(CTE) 활용\nWITH recent_users AS (\n    SELECT id, name, email\n    FROM users\n    WHERE created_at > NOW() - INTERVAL '30 days'\n),\nuser_order_counts AS (\n    SELECT user_id, COUNT(*) as order_count\n    FROM orders\n    WHERE created_at > NOW() - INTERVAL '30 days'\n    GROUP BY user_id\n)\nSELECT ru.name, ru.email, COALESCE(uoc.order_count, 0) as orders\nFROM recent_users ru\nLEFT JOIN user_order_counts uoc ON ru.id = uoc.user_id;\n```\n\n### 패턴 5: 배치 작업 (Batch Operations)\n\n**배치 INSERT:**\n```sql\n-- 나쁨: 다수의 개별 insert 수행\nINSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com');\nINSERT INTO users (name, email) VALUES ('Bob', 'bob@example.com');\nINSERT INTO users (name, email) VALUES ('Carol', 'carol@example.com');\n\n-- 좋음: 배치 insert\nINSERT INTO users (name, email) VALUES\n    ('Alice', 'alice@example.com'),\n    ('Bob', 'bob@example.com'),\n    ('Carol', 'carol@example.com');\n\n-- 더 좋음: 대량 insert 시 COPY 활용 (PostgreSQL)\nCOPY users (name, email) FROM '/tmp/users.csv' CSV HEADER;\n```\n\n**배치 UPDATE:**\n```sql\n-- 나쁨: 반복문 내 업데이트\nUPDATE users SET status = 'active' WHERE id = 1;\nUPDATE users SET status = 'active' WHERE id = 2;\n-- ... 많은 ID를 반복\n\n-- 좋음: IN 절을 활용한 단일 UPDATE\nUPDATE users\nSET status = 'active'\nWHERE id IN (1, 2, 3, 4, 5, ...);\n\n-- 더 좋음: 대량 배치 시 임시 테이블 활용\nCREATE TEMP TABLE temp_user_updates (id INT, new_status VARCHAR);\nINSERT INTO temp_user_updates VALUES (1, 'active'), (2, 'active'), ...;\n\nUPDATE users u\nSET status = t.new_status\nFROM temp_user_updates t\nWHERE u.id = t.id;\n```\n\n## 고급 기범 (Advanced Techniques)\n\n### 구체화된 뷰 (Materialized Views)\n\n비용이 많이 드는 쿼리를 미리 계산해 둡니다.\n\n```sql\n-- 구체화된 뷰 생성\nCREATE MATERIALIZED VIEW user_order_summary AS\nSELECT\n    u.id,\n    u.name,\n    COUNT(o.id) as total_orders,\n    SUM(o.total) as total_spent,\n    MAX(o.created_at) as last_order_date\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nGROUP BY u.id, u.name;\n\n-- 구체화된 뷰에 인덱스 추가\nCREATE INDEX idx_user_summary_spent ON user_order_summary(total_spent DESC);\n\n-- 구체화된 뷰 갱신\nREFRESH MATERIALIZED VIEW user_order_summary;\n\n-- 동시 갱신 (PostgreSQL, 락 최소화)\nREFRESH MATERIALIZED VIEW CONCURRENTLY user_order_summary;\n\n-- 구체화된 뷰 쿼리 (매우 빠름)\nSELECT * FROM user_order_summary\nWHERE total_spent > 1000\nORDER BY total_spent DESC;\n```\n\n### 파티셔닝 (Partitioning)\n\n성능 향상을 위해 대형 테이블을 나눕니다.\n\n```sql\n-- 날짜별 범위 파티셔닝 (PostgreSQL)\nCREATE TABLE orders (\n    id SERIAL,\n    user_id INT,\n    total DECIMAL,\n    created_at TIMESTAMP\n) PARTITION BY RANGE (created_at);\n\n-- 파티션 생성\nCREATE TABLE orders_2024_q1 PARTITION OF orders\n    FOR VALUES FROM ('2024-01-01') TO ('2024-04-01');\n\nCREATE TABLE orders_2024_q2 PARTITION OF orders\n    FOR VALUES FROM ('2024-04-01') TO ('2024-07-01');\n\n-- 쿼리는 자동으로 적절한 파티션을 사용함\nSELECT * FROM orders\nWHERE created_at BETWEEN '2024-02-01' AND '2024-02-28';\n-- orders_2024_q1 파티션만 스캔함\n```\n\n### 쿼리 힌트 및 최적화\n\n```sql\n-- 인덱스 사용 강제 (MySQL)\nSELECT * FROM users\nUSE INDEX (idx_users_email)\nWHERE email = 'user@example.com';\n\n-- 병렬 쿼리 (PostgreSQL)\nSET max_parallel_workers_per_gather = 4;\nSELECT * FROM large_table WHERE condition;\n\n-- 조인 힌트 (PostgreSQL)\nSET enable_nestloop = OFF;  -- hash join 또는 merge join 강제\n```\n\n## 모범 사례 (Best Practices)\n\n1. **선별적인 인덱싱**: 인덱스가 너무 많으면 쓰기 작업이 느려집니다.\n2. **쿼리 성능 모니터링**: 느린 쿼리 로그(slow query logs)를 활용하세요.\n3. **통계 정보 업데이트 유지**: 정기적으로 ANALYZE를 실행하세요.\n4. **적절한 데이터 타입 사용**: 작은 타입일수록 성능이 좋습니다.\n5. **사려 깊은 정규화**: 정규화와 성능 사이의 균형을 맞추세요.\n6. **자주 접근하는 데이터 캐싱**: 애플리케이션 레벨 캐싱을 활용하세요.\n7. **커넥션 풀링 (Connection Pooling)**: 데이터베이스 연결을 재사용하세요.\n8. **정기적인 유지보수**: VACUUM, ANALYZE, 인덱스 재빌드 등을 수행하세요.\n\n```sql\n-- 통계 업데이트\nANALYZE users;\nANALYZE VERBOSE orders;\n\n-- Vacuum (PostgreSQL)\nVACUUM ANALYZE users;\nVACUUM FULL users;  -- 공간 회수 (테이블 락 발생)\n\n-- 인덱스 재구성\nREINDEX INDEX idx_users_email;\nREINDEX TABLE users;\n```\n\n## 자주 발생하는 문제 (Common Pitfalls)\n\n- **과도한 인덱싱**: 각 인덱스는 INSERT/UPDATE/DELETE 속도를 늦춥니다.\n- **사용되지 않는 인덱스**: 공간을 낭비하고 쓰기 성능을 저하시킵니다.\n- **인덱스 누락**: 쿼리 속도 저하, 전체 테이블 스캔 유발.\n- **암시적 타입 변환**: 인덱스 사용을 방해합니다.\n- **OR 조건**: 인덱스를 효율적으로 사용하기 어렵게 만들 수 있습니다.\n- **와일드카드가 앞에 붙은 LIKE**: `LIKE '%abc'`는 인덱스를 탈 수 없습니다.\n- **WHERE 절의 함수**: 기능 기반 인덱스가 없다면 인덱스 사용을 방해합니다.\n\n## 쿼리 모니터링\n\n```sql\n-- 느린 쿼리 찾기 (PostgreSQL)\nSELECT query, calls, total_time, mean_time\nFROM pg_stat_statements\nORDER BY mean_time DESC\nLIMIT 10;\n\n-- 누락된 인덱스 찾기 (PostgreSQL)\nSELECT\n    schemaname,\n    tablename,\n    seq_scan,\n    seq_tup_read,\n    idx_scan,\n    seq_tup_read / seq_scan AS avg_seq_tup_read\nFROM pg_stat_user_tables\nWHERE seq_scan > 0\nORDER BY seq_tup_read DESC\nLIMIT 10;\n\n-- 사용되지 않는 인덱스 찾기 (PostgreSQL)\nSELECT\n    schemaname,\n    tablename,\n    indexname,\n    idx_scan,\n    idx_tup_read,\n    idx_tup_fetch\nFROM pg_stat_user_indexes\nWHERE idx_scan = 0\nORDER BY pg_relation_size(indexrelid) DESC;\n```\n\n## 리소스\n\n- **references/postgres-optimization-guide.md**: PostgreSQL 전용 최적화\n- **references/mysql-optimization-guide.md**: MySQL/MariaDB 최적화\n- **references/query-plan-analysis.md**: EXPLAIN 실행 계획 심층 분석\n- **assets/index-strategy-checklist.md**: 인덱스 생성 시점 및 방법\n- **assets/query-optimization-checklist.md**: 단계별 최적화 가이드\n- **scripts/analyze-slow-queries.sql**: 데이터베이스 내 느린 쿼리 식별\n- **scripts/index-recommendations.sql**: 인덱스 권장 사항 생성"
              },
              {
                "name": "web-artifacts-builder",
                "description": "현대적인 프런트엔드 웹 기술(React, Tailwind CSS, shadcn/ui)을 사용하여 정교한 다중 컴포넌트 claude.ai용 HTML artifact를 제작하기 위한 툴킷입니다. 상태 관리, 라우팅 또는 shadcn/ui 컴포넌트가 필요한 복잡한 artifact에 사용하세요. 단순한 단일 파일 HTML/JSX artifact용이 아닙니다.",
                "path": "icartsh-plugin/skills/web-artifacts-builder/SKILL.md",
                "frontmatter": {
                  "name": "web-artifacts-builder",
                  "description": "현대적인 프런트엔드 웹 기술(React, Tailwind CSS, shadcn/ui)을 사용하여 정교한 다중 컴포넌트 claude.ai용 HTML artifact를 제작하기 위한 툴킷입니다. 상태 관리, 라우팅 또는 shadcn/ui 컴포넌트가 필요한 복잡한 artifact에 사용하세요. 단순한 단일 파일 HTML/JSX artifact용이 아닙니다.",
                  "license": "LICENSE.txt의 전체 약관 참조"
                },
                "content": "# Web Artifacts Builder\n\n강력한 프런트엔드 claude.ai artifact를 제작하려면 다음 단계를 따르세요:\n1. `scripts/init-artifact.sh`를 사용하여 프런트엔드 레포지토리를 초기화합니다.\n2. 생성된 코드를 편집하여 artifact를 개발합니다.\n3. `scripts/bundle-artifact.sh`를 사용하여 모든 코드를 단일 HTML 파일로 번들링합니다.\n4. 사용자에게 artifact를 표시합니다.\n5. (선택 사항) artifact를 테스트합니다.\n\n**기술 스택(Stack)**: React 18 + TypeScript + Vite + Parcel (번들링) + Tailwind CSS + shadcn/ui\n\n## 디자인 및 스타일 가이드라인\n\n매우 중요: \"AI가 만든 뻔한 느낌(AI slop)\"을 피하기 위해, 과도한 중앙 정렬 레이아웃, 보라색 그라데이션, 일률적인 둥근 모서리, Inter 폰트 사용을 지양하세요.\n\n## 빠른 시작 (Quick Start)\n\n### Step 1: 프로젝트 초기화\n\n초기화 스크립트를 실행하여 새로운 React 프로젝트를 생성합니다:\n```bash\nbash scripts/init-artifact.sh <project-name>\ncd <project-name>\n```\n\n이 명령은 다음이 구성된 프로젝트를 생성합니다:\n- ✅ React + TypeScript (Vite 기반)\n- ✅ Tailwind CSS 3.4.1 (shadcn/ui 테마 시스템 포함)\n- ✅ 경로 별칭(`@/`) 설정 완료\n- ✅ 40개 이상의 shadcn/ui 컴포넌트 사전 설치\n- ✅ 모든 Radix UI 종속성 포함\n- ✅ Parcel 번들링 설정 완료 (.parcelrc 사용)\n- ✅ Node 18+ 호환성 (Vite 버전 자동 정밀 감지)\n\n### Step 2: artifact 개발\n\n생성된 파일들을 편집하여 artifact를 빌드합니다. 안내가 필요한 경우 아래의 **일반적인 개발 작업**을 참조하세요.\n\n### Step 3: 단일 HTML 파일로 번들링\n\nReact 앱을 단일 HTML artifact로 번들링합니다:\n```bash\nbash scripts/bundle-artifact.sh\n```\n\n이 명령은 `bundle.html`을 생성합니다. 이는 모든 JavaScript, CSS 및 종속성이 인라인화된 독립적인 artifact 파일입니다. 이 파일은 Claude 대화에서 artifact로 직접 공유할 수 있습니다.\n\n**요구 사항**: 프로젝트 루트 디렉토리에 `index.html`이 있어야 합니다.\n\n**스크립트 동작 원리**:\n- 번들링 종속성 설치 (parcel, @parcel/config-default, parcel-resolver-tspaths, html-inline)\n- 경로 별칭을 지원하는 `.parcelrc` 설정 생성\n- Parcel로 빌드 (소스 맵 제외)\n- html-inline을 사용하여 모든 에셋을 단일 HTML로 인라인화\n\n### Step 4: 사용자에게 artifact 공유\n\n번들링된 HTML 파일을 사용자에게 공유하여 artifact로 볼 수 있게 합니다.\n\n### Step 5: artifact 테스트/시각화 (선택 사항)\n\n참고: 이 단계는 완전히 선택 사항입니다. 필요한 경우 또는 요청이 있을 때만 수행하세요.\n\nartifact를 테스트하거나 시각화하려면 가용한 도구들(다른 SKILL이나 Playwright, Puppeteer와 같은 내장 도구 포함)을 사용하세요. 일반적으로 artifact 테스트를 미리 수행하는 것은 요청과 결과 확인 사이의 지연 시간(latency)을 유발하므로 피하는 것이 좋습니다. 요청이 있거나 문제가 발생했을 때, artifact를 먼저 제시한 후에 테스트를 진행하세요.\n\n## 참조 (Reference)\n\n- **shadcn/ui components**: https://ui.shadcn.com/docs/components"
              },
              {
                "name": "webapp-testing",
                "description": "Playwright를 사용하여 로컬 웹 애플리케이션과 상호작용하고 테스트하기 위한 툴킷입니다. 프런트엔드 기능 검증, UI 동작 디버깅, 브라우저 스크린샷 캡처 및 브라우저 로그 확인을 지원합니다.",
                "path": "icartsh-plugin/skills/webapp-testing/SKILL.md",
                "frontmatter": {
                  "name": "webapp-testing",
                  "description": "Playwright를 사용하여 로컬 웹 애플리케이션과 상호작용하고 테스트하기 위한 툴킷입니다. 프런트엔드 기능 검증, UI 동작 디버깅, 브라우저 스크린샷 캡처 및 브라우저 로그 확인을 지원합니다.",
                  "license": "LICENSE.txt의 전체 약관 참조"
                },
                "content": "# Web Application Testing\n\n로컬 웹 애플리케이션을 테스트하려면 파이썬(Python) Playwright 스크립트를 작성하세요.\n\n**사용 가능한 헬퍼 스크립트**:\n- `scripts/with_server.py` - 서버 라이프사이클 관리 (다중 서버 지원)\n\n**항상 스크립트를 `--help`와 함께 먼저 실행**하여 사용법을 확인하세요. 스크립트를 직접 실행해보고 커스텀 솔루션이 절대적으로 필요하다고 판단되기 전까지는 소스 코드를 읽지 마세요. 이러한 스크립트들은 매우 방대하여 컨텍스트 윈도우를 오염시킬 수 있습니다. 이들은 컨텍스트에 담기보다는 블랙박스(black-box) 스크립트로 직접 호출하도록 만들어졌습니다.\n\n## 결정 트리: 접근 방식 선택 (Decision Tree)\n\n```\n사용자 작업 → 정적 HTML인가?\n    ├─ 예 → HTML 파일을 직접 읽어 셀렉터(selectors) 식별\n    │         ├─ 성공 → 식별된 셀렉터로 Playwright 스크립트 작성\n    │         └─ 실패/불충분 → 동적 앱으로 간주 (아래 참조)\n    │\n    └─ 아니오 (동적 웹앱) → 서버가 이미 실행 중인가?\n        ├─ 아니오 → 실행: python scripts/with_server.py --help\n        │            그다음 헬퍼를 사용하여 간소화된 Playwright 스크립트 작성\n        │\n        └─ 예 → 정찰 후 행동(Reconnaissance-then-action):\n            1. 이동(Navigate) 후 networkidle 상태까지 대기\n            2. 스크린샷 캡처 또는 DOM 검사\n            3. 렌더링된 상태에서 셀렉터 식별\n            4. 찾은 셀렉터로 작업 수행\n```\n\n## 예시: with_server.py 사용\n\n서버를 시작하려면 먼저 `--help`를 실행한 다음 헬퍼를 사용하세요:\n\n**단일 서버:**\n```bash\npython scripts/with_server.py --server \"npm run dev\" --port 5173 -- python your_automation.py\n```\n\n**다중 서버 (예: 백엔드 + 프런트엔드):**\n```bash\npython scripts/with_server.py \\\n  --server \"cd backend && python server.py\" --port 3000 \\\n  --server \"cd frontend && npm run dev\" --port 5173 \\\n  -- python your_automation.py\n```\n\n자동화 스크립트를 작성할 때는 Playwright 로직만 포함하세요 (서버는 자동으로 관리됩니다):\n```python\nfrom playwright.sync_api import sync_playwright\n\nwith sync_playwright() as p:\n    browser = p.chromium.launch(headless=True) # 항상 chromium을 headless 모드로 실행하세요\n    page = browser.new_page()\n    page.goto('http://localhost:5173') # 서버는 이미 실행되어 준비된 상태입니다\n    page.wait_for_load_state('networkidle') # 매우 중요: JS가 실행될 때까지 대기하세요\n    # ... 자동화 로직 작성\n    browser.close()\n```\n\n## 정찰 후 행동 패턴 (Reconnaissance-Then-Action Pattern)\n\n1. **렌더링된 DOM 검사**:\n   ```python\n   page.screenshot(path='/tmp/inspect.png', full_page=True)\n   content = page.content()\n   page.locator('button').all()\n   ```\n\n2. **검사 결과에서 셀렉터 식별**\n\n3. **찾은 셀렉터를 사용하여 작업 실행**\n\n## 주의해야 할 함정\n\n❌ **나쁨**: 동적 앱에서 `networkidle` 상태를 기다리지 않고 DOM을 검사하는 것\n✅ **좋음**: 검사 전에 `page.wait_for_load_state('networkidle')`를 호출하여 대기하는 것\n\n## 모범 사례 (Best Practices)\n\n- **번들링된 스크립트를 블랙박스로 활용하세요** - 작업을 수행할 때 `scripts/`에 있는 스크립트가 도움이 될 수 있는지 고려하세요. 이 스크립트들은 컨텍스트 윈도우를 어지럽히지 않으면서 복잡한 일반 워크플로우를 안정적으로 처리합니다. `--help`로 사용법을 확인한 후 직접 호출하세요.\n- 동기식 스크립트에는 `sync_playwright()`를 사용하세요.\n- 작업이 끝나면 항상 브라우저를 닫으세요.\n- 설명적인 셀렉터를 사용하세요: `text=`, `role=`, CSS 셀렉터 또는 ID.\n- 적절한 대기 시간을 추가하세요: `page.wait_for_selector()` 또는 `page.wait_for_timeout()`.\n\n## 참조 파일 (Reference Files)\n\n- **examples/** - 일반적인 패턴을 보여주는 예시:\n  - `element_discovery.py` - 페이지 내 버튼, 링크 및 입력 필드 찾기\n  - `static_html_automation.py` - 로컬 HTML에 file:// URL 사용하기\n  - `console_logging.py` - 자동화 중 콘솔 로그 캡처하기"
              }
            ]
          }
        ]
      }
    }
  ]
}