{
  "owner": {
    "id": "amoscicki",
    "display_name": "amoscicki",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/82836981?v=4",
    "url": "https://github.com/amoscicki",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 2,
      "total_commands": 1,
      "total_skills": 1,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "amoscicki/aromatt",
      "url": "https://github.com/amoscicki/aromatt",
      "description": "Claude Code plugins marketplace",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-12-31T00:43:55Z",
        "created_at": "2025-12-11T19:00:38Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 676
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 438
        },
        {
          "path": "docs-researcher",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs-researcher/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs-researcher/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 311
        },
        {
          "path": "docs-researcher/README.md",
          "type": "blob",
          "size": 3217
        },
        {
          "path": "docs-researcher/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs-researcher/agents/docs-researcher.md",
          "type": "blob",
          "size": 11199
        },
        {
          "path": "docs-researcher/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs-researcher/skills/research-methodology",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs-researcher/skills/research-methodology/SKILL.md",
          "type": "blob",
          "size": 4306
        },
        {
          "path": "docs-researcher/skills/research-methodology/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs-researcher/skills/research-methodology/references/document-template.md",
          "type": "blob",
          "size": 5769
        },
        {
          "path": "docs-researcher/skills/research-methodology/references/query-patterns.md",
          "type": "blob",
          "size": 2322
        },
        {
          "path": "swarm",
          "type": "tree",
          "size": null
        },
        {
          "path": "swarm/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "swarm/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 237
        },
        {
          "path": "swarm/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "swarm/agents/swarm-reviewer-opus.md",
          "type": "blob",
          "size": 3305
        },
        {
          "path": "swarm/agents/swarm-reviewer-ultrathink.md",
          "type": "blob",
          "size": 3527
        },
        {
          "path": "swarm/agents/swarm-worker-haiku.md",
          "type": "blob",
          "size": 3697
        },
        {
          "path": "swarm/agents/swarm-worker-opus.md",
          "type": "blob",
          "size": 3362
        },
        {
          "path": "swarm/agents/swarm-worker-ultrathink.md",
          "type": "blob",
          "size": 3802
        },
        {
          "path": "swarm/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "swarm/commands/swarm.md",
          "type": "blob",
          "size": 9598
        },
        {
          "path": "swarm/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "swarm/skills/swarm",
          "type": "tree",
          "size": null
        },
        {
          "path": "swarm/skills/swarm/SKILL.md",
          "type": "blob",
          "size": 5476
        },
        {
          "path": "swarm/skills/swarm/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "swarm/skills/swarm/references/architect-protocol.md",
          "type": "blob",
          "size": 6127
        },
        {
          "path": "swarm/skills/swarm/references/auditor-protocol.md",
          "type": "blob",
          "size": 7544
        },
        {
          "path": "swarm/skills/swarm/references/escalation-rules.md",
          "type": "blob",
          "size": 4650
        },
        {
          "path": "swarm/skills/swarm/references/orchestrator-protocol.md",
          "type": "blob",
          "size": 18205
        },
        {
          "path": "swarm/skills/swarm/references/plan-format.md",
          "type": "blob",
          "size": 9388
        },
        {
          "path": "swarm/skills/swarm/references/worker-protocol.md",
          "type": "blob",
          "size": 5576
        }
      ],
      "marketplace": {
        "name": "aromatt",
        "version": null,
        "description": "Personal Claude Code plugins by Arkadiusz Moscicki",
        "owner_info": {
          "name": "Arkadiusz Moscicki",
          "url": "https://github.com/amoscicki"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "docs-researcher",
            "description": "Subagent that researches documentation and saves to .claude/knowledge/ as project-local knowledge base",
            "source": "./docs-researcher",
            "category": null,
            "version": "0.6.0",
            "author": null,
            "install_commands": [
              "/plugin marketplace add amoscicki/aromatt",
              "/plugin install docs-researcher@aromatt"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-31T00:43:55Z",
              "created_at": "2025-12-11T19:00:38Z",
              "license": null
            },
            "commands": [],
            "skills": [
              {
                "name": "Research Methodology",
                "description": "This skill should be used when docs-researcher agent needs guidance on \"how to search documentation\", \"WebSearch query patterns\", \"filtering search results\", \"documentation research strategy\", or \"creating knowledge files\". Provides systematic methodology for effective technical documentation research.",
                "path": "docs-researcher/skills/research-methodology/SKILL.md",
                "frontmatter": {
                  "name": "Research Methodology",
                  "description": "This skill should be used when docs-researcher agent needs guidance on \"how to search documentation\", \"WebSearch query patterns\", \"filtering search results\", \"documentation research strategy\", or \"creating knowledge files\". Provides systematic methodology for effective technical documentation research.",
                  "version": "0.1.0"
                },
                "content": "# Research Methodology for Documentation\n\nThis skill provides systematic approach to researching technical documentation using WebSearch and WebFetch tools.\n\n## Core Principles\n\n1. **Validate before research** - Ensure request is specific enough\n2. **Check local first** - Look in `.claude/knowledge/` before searching\n3. **Official sources priority** - Start with official docs\n4. **Filter aggressively** - Extract only what's relevant to context\n5. **Save for reuse** - Document findings in standard format\n\n## Request Validation\n\nA valid research request must contain three elements:\n\n| Element | Example | Invalid |\n|---------|---------|---------|\n| Technology | \"React\", \"Effect\", \"Prisma\" | \"JavaScript library\" |\n| Topic | \"useEffect cleanup\", \"pipe operator\" | \"how it works\" |\n| Context | \"fixing memory leak in subscription\" | \"learning\" |\n\nIf any element is missing, return validation error and request clarification.\n\n## Search Strategy\n\n### Query Formulation\n\nBuild queries progressively:\n\n```\nLevel 1 (Official): {technology} official documentation {topic}\nLevel 2 (Tutorial): {technology} {topic} tutorial example\nLevel 3 (Problem): {technology} {topic} {error-message} solution\n```\n\n### Source Hierarchy\n\nPrioritize sources in this order:\n\n1. **Official documentation** (always check first)\n   - react.dev, docs.python.org, effect.website\n   - GitHub official repos and examples\n\n2. **Trusted secondary sources**\n   - MDN Web Docs (web technologies)\n   - DigitalOcean Community tutorials\n   - Dev.to (high-quality articles only)\n   - Stack Overflow (accepted answers)\n\n3. **Avoid**\n   - SEO-optimized content farms\n   - Outdated tutorials (check dates)\n   - AI-generated summaries\n   - Forums without accepted solutions\n\n### WebSearch Patterns\n\nReference `references/query-patterns.md` for specific query templates per technology domain.\n\n## Filtering Results\n\n### Relevance Criteria\n\nInclude information that:\n- Directly addresses the stated context\n- Provides actionable code examples\n- Explains common pitfalls for the use case\n- Is current (matches stated version or latest)\n\nExclude information that:\n- Is tangentially related\n- Covers advanced edge cases not needed\n- Is deprecated or version-mismatched\n- Duplicates what's already found\n\n### Extraction Process\n\n1. Scan search results for relevance\n2. Open 2-3 most promising sources\n3. Extract specific sections, not entire pages\n4. Verify code examples are complete\n5. Note version compatibility\n\n## Document Format\n\nSave all knowledge files to `.claude/knowledge/` using the template in `references/document-template.md`.\n\n### File Naming\n\nFormat: `{technology}-{topic}.md`\n\nExamples:\n- `react-useeffect-cleanup.md`\n- `effect-pipe-operator.md`\n- `prisma-relations.md`\n- `nextauth-jwt-session.md`\n\nRules:\n- All lowercase\n- Hyphens between words\n- Technology first, then topic\n- No version numbers in filename\n\n### Frontmatter Structure\n\nRequired fields in YAML frontmatter:\n- `topic`: Descriptive title\n- `technology`: Library/framework name\n- `version`: Version researched (or \"latest\")\n- `sources`: List of URLs used\n- `created`: Date in YYYY-MM-DD format\n- `context`: Original problem that triggered research\n\n## Quality Checklist\n\nBefore saving knowledge document, verify:\n\n- [ ] Request was properly validated\n- [ ] Existing knowledge was checked first\n- [ ] Official sources were consulted\n- [ ] Content is specific to stated context\n- [ ] Code examples are complete and tested\n- [ ] Sources are cited\n- [ ] File follows naming convention\n- [ ] Frontmatter is complete\n\n## Additional Resources\n\n### Reference Files\n\n- **`references/query-patterns.md`** - Technology-specific search query templates\n- **`references/document-template.md`** - Complete knowledge document template\n\n### Implementation Notes\n\nThis methodology is designed for Haiku model execution. Instructions are explicit and procedural to ensure consistent results across model capabilities."
              }
            ]
          },
          {
            "name": "swarm-orchestrator",
            "description": "Multi-agent parallel task orchestration with wave-based execution, automatic auditing, and model escalation",
            "source": "./swarm",
            "category": null,
            "version": "1.0.4",
            "author": null,
            "install_commands": [
              "/plugin marketplace add amoscicki/aromatt",
              "/plugin install swarm-orchestrator@aromatt"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-31T00:43:55Z",
              "created_at": "2025-12-11T19:00:38Z",
              "license": null
            },
            "commands": [
              {
                "name": "/swarm",
                "description": "Orchestrate parallel agent workflows with wave-based execution and mandatory review",
                "path": "swarm/commands/swarm.md",
                "frontmatter": {
                  "description": "Orchestrate parallel agent workflows with wave-based execution and mandatory review",
                  "arguments": [
                    {
                      "name": "input",
                      "description": "Task description, plan file path, or \"resume [from X]\"",
                      "required": false
                    }
                  ],
                  "allowed-tools": [
                    "Task",
                    "TaskOutput",
                    "Read(.swarm/**)",
                    "Write(.swarm/**)",
                    "Edit(.swarm/**)",
                    "Glob(.swarm/**)",
                    "TodoWrite",
                    "AskUserQuestion"
                  ]
                },
                "content": "# /swarm Command\n\nYou are the ORCHESTRATOR. Your job is COORDINATION ONLY.\n\n## CRITICAL CONSTRAINTS\n\n**YOU CANNOT (ABSOLUTE PROHIBITION):**\n- Read source code files - ONLY `.swarm/**` allowed\n- Run Bash commands - workers do this\n- Read worker output content - ignore it\n- Poll with `block: false` - wastes context\n- Use Glob/Read/Grep on anything outside `.swarm/`\n\n**FORBIDDEN PATTERNS - NEVER DO THIS:**\n```\nGlob(\"src/**\")           ❌ FORBIDDEN\nRead(\"src/anything.ts\")  ❌ FORBIDDEN\nGrep(path: \"src/\")       ❌ FORBIDDEN\nSearch(\"src/**/*.ts\")    ❌ FORBIDDEN\nBash(\"mkdir ...\")        ❌ FORBIDDEN - workers create dirs\nBash(\"tsc --noEmit\")     ❌ FORBIDDEN - workers/reviewers run commands\n```\n\n**YOU CAN ONLY:**\n- Spawn agents with `Task(run_in_background: true)` - fire and forget\n- Read/Write/Edit files in `.swarm/` directory ONLY\n- Track mappings: taskId → reportPath\n\n**REACTIVE MODEL - IGNORE ALL OUTPUT:**\n- Spawn agents → they run in background\n- Agents notify when done (reactive) - IGNORE notification content\n- Agent output is STREAMED → reading it wastes context\n- DO NOT read agent output - EVER\n- DO NOT read report files - REVIEWERS do that\n- YOU read ONLY: plan file (.swarm/{slug}-inprogress.md)\n- YOU update ONLY: plan file (paths, status, checkmarks)\n\n**CONTEXT ISOLATION:**\n```\nWorkers → write to .swarm/reports/     (you NEVER read these)\nReviewers → read reports, analyze      (their context, not yours)\nReviewers → return: \"HIGH|action|path\" (minimal, you act on this)\nYOU → update plan file ONLY            (paths, not content)\n```\n\n**AGENT NAMES - USE FULLY QUALIFIED:**\n```\nswarm-orchestrator:swarm-worker-haiku       # Simple tasks\nswarm-orchestrator:swarm-worker-opus        # Standard tasks\nswarm-orchestrator:swarm-worker-ultrathink  # Complex tasks\nswarm-orchestrator:swarm-reviewer-ultrathink # MANDATORY wave review\nswarm-orchestrator:swarm-reviewer-opus      # Optional task review\n```\n\n## Input: $ARGUMENTS\n\n---\n\n## EXECUTION FLOW\n\n### PHASE 0: STARTUP (MANDATORY FIRST STEP)\n\n**Always execute this phase before anything else.**\n\n```\n1. CHECK FOR EXISTING PLANS:\n   Glob(\".swarm/*-inprogress.md\")\n   Glob(\".swarm/*-paused.md\")\n\n   If found:\n     → List them to user\n     → AskUserQuestion: \"Found existing plans. Resume one, or create new?\"\n       Options:\n       - Resume: {plan-name-1}\n       - Resume: {plan-name-2}\n       - Create new plan\n\n   If none found:\n     → Proceed to step 2\n\n2. DETECT MODE:\n   AskUserQuestion: \"How should I run this swarm?\"\n   Options:\n   - Plan only (create plan, don't execute)\n   - Execute with checkpoints (default - pause after each wave)\n   - Auto-execute (minimal pauses, only stop on errors)\n\n3. PARSE INPUT:\n   - Empty input → AskUserQuestion: \"What task should the swarm work on?\"\n   - Task description → Proceed to PHASE 1 (Architect)\n   - File path (.swarm/*.md) → Load plan, run STATE VERIFICATION\n   - \"resume\" or \"resume from X\" → Find plan, run STATE VERIFICATION\n\n4. STATE VERIFICATION (when resuming):\n   For each wave marked as \"completed\" or \"in_progress\" in plan:\n\n   a) Check task reports exist:\n      Glob(\".swarm/reports/{slug}/wave-{N}/task-*.md\")\n      → If 0 reports but tasks marked done → Wave NOT actually complete\n\n   b) Check MANDATORY review was done:\n      Glob(\".swarm/reports/{slug}/wave-{N}/wave-review.md\")\n      → If no review file → Review was NEVER run\n\n   c) Determine actual state:\n      - Tasks done + review done → Wave complete, go to next wave\n      - Tasks done + NO review → Run PHASE 3 (MANDATORY REVIEW)\n      - Tasks NOT done → Run PHASE 2 for this wave\n\n   **NEVER verify by reading source files. Use .swarm/reports/ ONLY.**\n```\n\n---\n\n### PHASE 1: ARCHITECT\n\n```\n1. Spawn architect to create plan:\n   Task(\n     subagent_type: \"swarm-orchestrator:swarm-worker-opus\",\n     run_in_background: true,\n     prompt: \"\"\"\n       Role: Swarm Architect\n       Task: {user's task description}\n\n       1. Explore codebase (you can read any files)\n       2. Run tsc --noEmit if applicable\n       3. Create directories: mkdir -p .swarm/reports/{slug}\n       4. Create plan file: .swarm/{slug}-inprogress.md\n       5. Return: \"architect|success|.swarm/{slug}-inprogress.md\"\n     \"\"\"\n   )\n   → Architect runs in background\n\n2. WAIT FOR NOTIFICATION (reactive):\n   → Agent notifies when done - IGNORE output\n   → Architect wrote plan to .swarm/{slug}-inprogress.md\n\n3. Read PLAN FILE ONLY:\n   Read(\".swarm/{slug}-inprogress.md\")\n\n4. Ask user to confirm checkpoints\n```\n\n### PHASE 2: WAVE EXECUTION (for each wave)\n\n```\n1. Update plan: wave N → in_progress\n\n2. SPAWN ALL WORKERS IN SINGLE MESSAGE (parallel):\n\n   Task(\n     subagent_type: \"swarm-orchestrator:swarm-worker-{model}\",\n     run_in_background: true,\n     prompt: \"\"\"\n       Task {ID}: {description}\n       Plan: {slug}\n       Report to: .swarm/reports/{slug}/wave-{N}/task-{ID}.md\n\n       1. Create directory: mkdir -p .swarm/reports/{slug}/wave-{N}\n       2. Execute task\n       3. Write detailed report to file above\n       4. Return ONLY: \"{ID}|{success|failed|partial}|{report-path}\"\n     \"\"\"\n   )\n   → Store: taskId → agentId mapping\n   → Store: taskId → reportPath mapping\n\n3. WAIT FOR NOTIFICATIONS (reactive):\n   → All workers notify when done - IGNORE output content\n   → Workers wrote reports to .swarm/reports/{slug}/wave-{N}/\n\n4. Update plan with report paths (DO NOT READ REPORTS):\n   Edit(\".swarm/{slug}-inprogress.md\", mark tasks [x] with paths)\n```\n\n### PHASE 3: MANDATORY WAVE REVIEW\n\n```\n1. Spawn ultrathink reviewer:\n   Task(\n     subagent_type: \"swarm-orchestrator:swarm-reviewer-ultrathink\",\n     run_in_background: true,\n     prompt: \"\"\"\n       Review wave {N} implementation.\n       Plan: {slug}\n       Reports directory: .swarm/reports/{slug}/wave-{N}/\n\n       1. Read ALL task reports in that directory\n       2. Read the actual source files that were modified\n       3. Run tsc --noEmit to check for errors\n       4. Analyze for issues\n       5. Write review to: .swarm/reports/{slug}/wave-{N}/wave-review.md\n       6. Return ONLY: \"{priority}|{action}|{review-path}\"\n          - priority: HIGH (fix now) | MED (defer) | LOW (proceed)\n     \"\"\"\n   )\n   → Reviewer runs in background\n\n2. WAIT FOR NOTIFICATION (reactive):\n   → Reviewer notifies when done\n   → Reviewer returns: \"HIGH|action|path\" or \"MED|action|path\" or \"LOW|proceed|path\"\n   → This is the ONLY output you use (minimal string)\n\n3. Process priority (DO NOT READ REVIEW FILE):\n\n   if HIGH:\n     Spawn fixer agent that READS the review file (not you):\n     Task(swarm-orchestrator:swarm-worker-opus, \"\"\"\n       Fix issues from review.\n       Review file: .swarm/reports/{slug}/wave-{N}/wave-review.md\n       Read it, fix issues, write report.\n     \"\"\")\n     → Wait for fixer notification\n     → GOTO step 1 (re-review)\n\n   if MED:\n     Edit plan: note \"{action}\" as deferred issue\n     → CONTINUE to next wave\n\n   if LOW:\n     → CONTINUE to next wave\n```\n\n### PHASE 4: CHECKPOINT (if scheduled)\n\n```\n1. Summarize to user:\n   - Tasks completed in wave\n   - Review result (LOW/MED/HIGH)\n   - Any issues noted\n\n2. Ask user to continue or pause\n\n3. If pause → rename plan to -paused.md\n```\n\n### PHASE 5: NEXT WAVE\n\n```\nRepeat PHASE 2-4 for each wave until complete.\n\nWhen all waves done:\n1. Final review with ultrathink\n2. Rename plan: -inprogress.md → -completed.md\n3. Report to user\n```\n\n---\n\n## CONCRETE EXAMPLE\n\nUser: `/swarm Fix all TypeScript errors in the codebase`\n\n**Orchestrator does:**\n\n```\n# 1. Spawn architect\nTask(swarm-orchestrator:swarm-worker-opus, \"Architect: analyze TS errors, create plan\", run_in_background: true)\n\n# 2. WAIT (reactive) - architect notifies when done - IGNORE output\n# Architect wrote: .swarm/fix-typescript-errors-inprogress.md\n\n# 3. Read PLAN ONLY\nRead(\".swarm/fix-typescript-errors-inprogress.md\")\n\n# 4. User confirms\n\n# 5. Spawn wave 1 workers (ALL IN SINGLE MESSAGE)\nTask(swarm-orchestrator:swarm-worker-haiku, \"Task 1.1: ...\", run_in_background: true)\nTask(swarm-orchestrator:swarm-worker-opus, \"Task 1.2: ...\", run_in_background: true)\nTask(swarm-orchestrator:swarm-worker-opus, \"Task 1.3: ...\", run_in_background: true)\n\n# 6. WAIT (reactive) - workers notify when done - IGNORE output\n# Workers wrote reports to .swarm/reports/fix-typescript-errors/wave-1/\n\n# 7. Update plan (paths only, DO NOT READ REPORTS)\nEdit(\".swarm/fix-typescript-errors-inprogress.md\", mark tasks [x])\n\n# 8. Spawn MANDATORY review\nTask(swarm-orchestrator:swarm-reviewer-ultrathink, \"Review wave 1\", run_in_background: true)\n\n# 9. WAIT (reactive) - reviewer notifies: \"LOW|proceed|path\"\n# This is the ONLY output you use\n\n# 10. Process: LOW → continue to wave 2 (DO NOT read review file)\n```\n\n---\n\n## PLAN FILE FORMAT\n\nLocation: `.swarm/{descriptive-slug}-{status}.md`\n\nStatus: `inprogress` | `paused` | `completed`\n\n---\n\n## NOW EXECUTE\n\n**Start with PHASE 0. Always.**\n\n1. **PHASE 0**: Check for existing plans, detect mode, parse input\n2. **PHASE 1-5**: Follow the EXECUTION FLOW above exactly\n3. Remember: YOU ARE COORDINATOR. Workers and reviewers do the actual work.\n\n**First action**: `Glob(\".swarm/*-inprogress.md\")` and `Glob(\".swarm/*-paused.md\")`"
              }
            ],
            "skills": []
          }
        ]
      }
    }
  ]
}