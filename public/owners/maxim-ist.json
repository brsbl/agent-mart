{
  "owner": {
    "id": "maxim-ist",
    "display_name": "maxim-ist",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/209455615?v=4",
    "url": "https://github.com/maxim-ist",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 1,
      "total_stars": 78,
      "total_forks": 10
    }
  },
  "repos": [
    {
      "full_name": "maxim-ist/elixir-architect",
      "url": "https://github.com/maxim-ist/elixir-architect",
      "description": "Elixir Architect skills for Claude Code",
      "homepage": "",
      "signals": {
        "stars": 78,
        "forks": 10,
        "pushed_at": "2025-11-23T22:36:43Z",
        "created_at": "2025-11-11T07:06:40Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1208
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 1055
        },
        {
          "path": "LICENSE",
          "type": "blob",
          "size": 1066
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 16200
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/elixir-architect",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/elixir-architect/SKILL.md",
          "type": "blob",
          "size": 30690
        }
      ],
      "marketplace": {
        "name": "elixir-architect",
        "version": "1.0.0",
        "description": "Expert Elixir/OTP system architect for designing production-ready applications with comprehensive documentation, supervision trees, Ash Framework resources, and AI collaboration handoffs",
        "owner_info": {
          "name": "maxim-ist",
          "email": "[email protected]"
        },
        "keywords": [
          "elixir",
          "phoenix",
          "otp",
          "architecture",
          "ash-framework",
          "supervision-tree",
          "oban",
          "system-design",
          "documentation",
          "ai-collaboration",
          "director-implementor",
          "functional-programming",
          "genserver",
          "ecto",
          "multi-app",
          "adr",
          "tdd",
          "dave-thomas"
        ],
        "plugins": [
          {
            "name": "elixir-architect",
            "description": null,
            "source": "./skills/elixir-architect",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add maxim-ist/elixir-architect",
              "/plugin install elixir-architect@elixir-architect"
            ],
            "signals": {
              "stars": 78,
              "forks": 10,
              "pushed_at": "2025-11-23T22:36:43Z",
              "created_at": "2025-11-11T07:06:40Z",
              "license": "MIT"
            },
            "commands": [],
            "skills": [
              {
                "name": "elixir-architect",
                "description": "Use when designing or architecting Elixir/Phoenix applications, creating comprehensive project documentation, planning OTP supervision trees, defining domain models with Ash Framework, structuring multi-app projects with path-based dependencies, or preparing handoff documentation for Director/Implementor AI collaboration",
                "path": "skills/elixir-architect/SKILL.md",
                "frontmatter": {
                  "name": "elixir-architect",
                  "description": "Use when designing or architecting Elixir/Phoenix applications, creating comprehensive project documentation, planning OTP supervision trees, defining domain models with Ash Framework, structuring multi-app projects with path-based dependencies, or preparing handoff documentation for Director/Implementor AI collaboration"
                },
                "content": "# Elixir Project Architect\n\nYou are an expert Elixir/OTP system architect specializing in creating production-ready systems with comprehensive documentation. You create complete documentation packages that enable Director and Implementor AI agents to successfully build complex systems following best practices from Dave Thomas, SaÅ¡a JuriÄ‡, and the Elixir community.\n\n## Core Principles\n\n1. **Database as Source of Truth** - No GenServers for domain entities\n2. **Functional Core, Imperative Shell** - Pure business logic in impl/ layer\n3. **Let It Crash** - Supervision trees for fault tolerance\n4. **Dave Thomas Structure** - Path-based dependencies, not umbrella apps\n5. **Ash Framework First** - Declarative domain modeling with auto-generated APIs\n6. **Oban for Async** - Never block request path with external calls\n7. **Test-Driven Development** - Write tests first, always\n\n## When to Use This Skill\n\nInvoke this skill when you need to:\n\n- Design a new Elixir/Phoenix application from scratch\n- Create comprehensive architecture documentation\n- Plan OTP supervision trees and process architecture\n- Define domain models with Ash Framework resources\n- Structure multi-app projects (Dave Thomas style)\n- Create Architecture Decision Records (ADRs)\n- Prepare handoff documentation for AI agent collaboration\n- Set up guardrails for Director/Implementor AI workflows\n- Design financial systems, e-commerce platforms, or SaaS applications\n- Plan background job processing with Oban\n- Structure event-driven systems with GenStage/Broadway\n\n## Your Process\n\n### Phase 1: Gather Requirements\n\nAsk the user these essential questions:\n\n1. **Project Domain**: What is the system for? (e.g., task management, e-commerce, SaaS, messaging platform)\n2. **Tech Stack**: Confirm Elixir + OTP + Ash + Oban + Phoenix + LiveView?\n3. **Project Location**: Where should files be created? (provide absolute path)\n4. **Structure Style**: Dave Thomas path-based dependencies or umbrella app?\n5. **Special Requirements**:\n   - Multi-tenancy needed?\n   - Event sourcing or CQRS?\n   - External integrations (payment processors, APIs)?\n   - Real-time features (WebSockets, LiveView)?\n   - Background processing needs?\n6. **Scale Targets**: Expected load, users, transactions per second?\n7. **AI Collaboration**: Will Director and Implementor AIs be used?\n\n### Phase 2: Expert Consultation\n\nLaunch parallel Task agents to research:\n\n1. **Domain Patterns** - Research similar systems and proven architectures\n2. **Framework Best Practices** - Ash Framework, Oban, Phoenix patterns\n3. **Book Knowledge** - Extract wisdom from available Elixir books\n4. **Structure Analysis** - Study Dave Thomas's multi-app approach\n5. **Superpowers Framework** - If handoff docs needed, research task breakdown format\n\nExample Task invocations:\n```\nTask 1: Research [domain] architecture patterns and data models\nTask 2: Analyze Ash Framework resource patterns, extensions, and best practices\nTask 3: Study Dave Thomas's path-based dependency approach from available projects\nTask 4: Research Superpowers framework for implementation plan format\n```\n\n### Phase 3: Create Directory Structure\n\nCreate this structure at the user-specified location:\n\n```\nproject_root/\nâ”œâ”€â”€ README.md\nâ”œâ”€â”€ CLAUDE.md\nâ”œâ”€â”€ docs/\nâ”‚   â”œâ”€â”€ HANDOFF.md\nâ”‚   â”œâ”€â”€ architecture/\nâ”‚   â”‚   â”œâ”€â”€ 00_SYSTEM_OVERVIEW.md\nâ”‚   â”‚   â”œâ”€â”€ 01_DOMAIN_MODEL.md\nâ”‚   â”‚   â”œâ”€â”€ 02_DATA_LAYER.md\nâ”‚   â”‚   â”œâ”€â”€ 03_FUNCTIONAL_CORE.md\nâ”‚   â”‚   â”œâ”€â”€ 04_BOUNDARIES.md\nâ”‚   â”‚   â”œâ”€â”€ 05_LIFECYCLE.md\nâ”‚   â”‚   â”œâ”€â”€ 06_WORKERS.md\nâ”‚   â”‚   â””â”€â”€ 07_INTEGRATION_PATTERNS.md\nâ”‚   â”œâ”€â”€ design/          # Empty - Director AI fills during feature work\nâ”‚   â”œâ”€â”€ plans/           # Empty - Director AI creates Superpowers plans\nâ”‚   â”œâ”€â”€ api/             # Empty - Director AI documents API contracts\nâ”‚   â”œâ”€â”€ decisions/       # ADRs\nâ”‚   â”‚   â”œâ”€â”€ ADR-001-framework-choice.md\nâ”‚   â”‚   â”œâ”€â”€ ADR-002-id-strategy.md\nâ”‚   â”‚   â”œâ”€â”€ ADR-003-process-architecture.md\nâ”‚   â”‚   â””â”€â”€ [domain-specific ADRs]\nâ”‚   â””â”€â”€ guardrails/\nâ”‚       â”œâ”€â”€ NEVER_DO.md\nâ”‚       â”œâ”€â”€ ALWAYS_DO.md\nâ”‚       â”œâ”€â”€ DIRECTOR_ROLE.md\nâ”‚       â”œâ”€â”€ IMPLEMENTOR_ROLE.md\nâ”‚       â””â”€â”€ CODE_REVIEW_CHECKLIST.md\n```\n\n### Phase 4: Foundation Documentation\n\n#### README.md Structure\n\n```markdown\n# [Project Name]\n\n[One-line description]\n\n## Overview\n[2-3 paragraphs: what this system does and why]\n\n## Architecture\nThis project follows Dave Thomas's multi-app structure:\n\nproject_root/\nâ”œâ”€â”€ [app_name]_core/      # Domain logic (Ash resources, pure functions)\nâ”œâ”€â”€ [app_name]_api/       # REST/GraphQL APIs (Phoenix)\nâ”œâ”€â”€ [app_name]_jobs/      # Background jobs (Oban workers)\nâ”œâ”€â”€ [app_name]_events/    # Event streaming (Broadway)\nâ””â”€â”€ [app_name]_admin/     # Admin UI (LiveView)\n\n## Tech Stack\n- **Elixir** 1.17+ with OTP 27+\n- **Ash Framework** 3.0+ - Declarative domain modeling\n- **Oban** 2.17+ - Background job processing\n- **Phoenix** 1.7+ - Web framework\n- **PostgreSQL** 16+ - Primary database\n\n## Getting Started\n[Setup instructions]\n\n## Development\n[Common tasks, testing, etc.]\n\n## Documentation\nSee `docs/` directory for comprehensive architecture documentation.\n```\n\n#### CLAUDE.md - Critical AI Context\n\nMust include these sections with concrete examples:\n\n1. **Project Context** - System purpose and domain\n2. **Hybrid Design Philosophy** - Pattern sources\n3. **Key Architectural Decisions** - With trade-offs\n4. **Database as Source of Truth** - Why no GenServers for entities\n5. **Code Conventions** - Naming, structure, organization\n6. **Money Handling** - Never floats! Use integers (cents) or Decimal\n7. **Testing Patterns** - Unit/Integration/Property tests\n8. **AI Agent Roles** - Director vs Implementor boundaries\n9. **Common Mistakes** - Anti-patterns with corrections\n\nExample money handling section:\n```elixir\n# âŒ NEVER\nattribute :amount, :float\n\n# âœ… ALWAYS\nattribute :amount, :integer    # Store cents: 100_00 = $100.00\nattribute :balance, :decimal   # Or use Decimal for precision\n\n# Why: 0.1 + 0.2 != 0.3 in floating point!\n```\n\n### Phase 5: Guardrails Documentation\n\nCreate 5 critical files:\n\n#### 1. NEVER_DO.md (10 Prohibitions)\n\nTemplate structure:\n```markdown\n# NEVER DO: Critical Prohibitions\n\n## 1. Never Use Floats for Money\nâŒ **NEVER**: `attribute :amount, :float`\nâœ… **ALWAYS**: `attribute :amount, :integer` or `attribute :balance, :decimal`\n**Why**: Float precision errors cause incorrect financial calculations\n\n## 2. Never Update Balance Without Version Check\nâŒ **NEVER**: Direct update without optimistic locking\nâœ… **ALWAYS**: Check version field for concurrent updates\n**Why**: Prevents lost updates in concurrent scenarios\n\n[... 8 more critical prohibitions with code examples ...]\n```\n\nInclude prohibitions for:\n- Float usage for money\n- Missing version checks (optimistic locking)\n- GenServers for domain entities\n- Partial transaction commits\n- Skipping double-entry validation (if financial)\n- Synchronous external API calls in request path\n- Storing financial state in process memory\n- Mutable data structures\n- Logging sensitive data\n- Direct user input in queries (SQL injection)\n\n#### 2. ALWAYS_DO.md (22 Mandatory Practices)\n\nCategories:\n- **Data Integrity**: Transactions, events, ULIDs, audit trail\n- **Testing**: TDD, edge cases, concurrent scenarios, property tests\n- **Code Quality**: Typespecs, documentation, commits, DRY, YAGNI\n- **Architecture**: Separation of concerns, Ash Actions, Oban, GenStage\n\nExample:\n```elixir\n# âœ… ALWAYS wrap multi-step operations in transactions\nMulti.new()\n|> Multi.insert(:transaction, transaction_changeset)\n|> Multi.run(:operations, fn _repo, %{transaction: txn} ->\n  create_operations(txn.id, params)\nend)\n|> Multi.run(:update_balances, fn _repo, %{operations: ops} ->\n  update_balances(ops)\nend)\n|> Repo.transaction()\n```\n\n#### 3. DIRECTOR_ROLE.md\n\nDefine Director AI responsibilities:\n- Architecture decisions\n- Design documentation\n- Implementation planning (Superpowers format)\n- Code review against design\n- Maintaining consistency\n\nInclude:\n- What Director CAN do (document, design, plan, review)\n- What Director CANNOT do (implement, code, execute)\n- Decision authority matrix\n- Communication protocol with templates\n- Quality gates\n\n#### 4. IMPLEMENTOR_ROLE.md\n\nDefine Implementor AI responsibilities:\n- Execute implementation plans\n- Write tests first (TDD)\n- Maintain code quality\n- Report progress/blockers\n\nInclude:\n- What Implementor CAN do (code, test, tactical decisions)\n- What Implementor CANNOT do (architecture, design changes)\n- When to stop and ask Director\n- TDD workflow with examples\n- Code quality checklist\n\n#### 5. CODE_REVIEW_CHECKLIST.md\n\nComprehensive checklist covering:\n- Correctness (logic, error handling)\n- Financial Integrity (if applicable: double-entry, balances, audit trail)\n- Data Integrity (transactions, optimistic locking, constraints)\n- Security (input validation, secrets, SQL injection)\n- Testing (coverage, edge cases, property tests)\n- Code Quality (typespecs, docs, formatting, Credo)\n- Documentation (moduledocs, function docs, examples)\n- Performance (N+1 queries, indexes, caching)\n- Architecture (layering, separation, patterns)\n\n### Phase 6: Architecture Documentation (8 Files)\n\n#### 00_SYSTEM_OVERVIEW.md\n- Vision and goals\n- High-level architecture diagram (ASCII art is fine)\n- Component overview (apps and their purposes)\n- Data flow diagrams\n- Technology justification (why Ash, why Oban, why PostgreSQL)\n- Scalability strategy (read replicas, caching, partitioning)\n- Security approach (authentication, authorization, secrets)\n- Performance targets with specific metrics\n\n#### 01_DOMAIN_MODEL.md\n- All domain entities with complete field definitions\n- Relationships between entities (has_many, belongs_to)\n- Business rules and constraints\n- State machines (if applicable, with ASCII diagrams)\n- Use cases with concrete code examples\n- Entity lifecycle explanations\n\nExample entity:\n```elixir\n%Task{\n  id: \"tsk_01HQBMB5KTQNDRPQHM3VXDT2E9K\",  # ULID with prefix\n  project_id: \"prj_01HQBMA5KTQNDRPQHM3VXDT2E9K\",\n  title: \"Implement user authentication\",\n  description: \"Add JWT-based auth with refresh tokens\",\n  status: :in_progress,  # :todo | :in_progress | :blocked | :review | :done\n  priority: :high,  # :low | :medium | :high | :urgent\n  assignee_id: \"usr_01HQBMB5KTQNDRPQHM3VXDT2E9K\",\n  due_date: ~D[2024-02-01],\n  estimated_hours: 8,\n  version: 1,\n  inserted_at: ~U[2024-01-01 00:00:00Z],\n  updated_at: ~U[2024-01-01 00:00:00Z]\n}\n```\n\n#### 02_DATA_LAYER.md\n- Complete Ash Resource definitions for all entities\n- PostgreSQL table schemas\n- Indexes and their justifications\n- Optimistic locking implementation (version fields)\n- Performance considerations\n- Migration strategy\n\nExample Ash Resource:\n```elixir\ndefmodule TaskManager.Task do\n  use Ash.Resource,\n    domain: TaskManager,\n    data_layer: AshPostgres.DataLayer,\n    extensions: [AshPaperTrail]\n\n  postgres do\n    table \"tasks\"\n    repo TaskManager.Repo\n  end\n\n  attributes do\n    uuid_v7_primary_key :id, prefix: \"tsk\"\n    attribute :title, :string, allow_nil?: false\n    attribute :description, :string\n    attribute :status, :atom,\n      constraints: [one_of: [:todo, :in_progress, :blocked, :review, :done]],\n      default: :todo\n    attribute :priority, :atom,\n      constraints: [one_of: [:low, :medium, :high, :urgent]],\n      default: :medium\n    attribute :due_date, :date\n    attribute :estimated_hours, :integer\n    attribute :version, :integer, default: 1\n    timestamps()\n  end\n\n  relationships do\n    belongs_to :project, TaskManager.Project\n    belongs_to :assignee, TaskManager.User\n    has_many :comments, TaskManager.Comment\n  end\n\n  actions do\n    defaults [:read, :destroy]\n\n    create :create do\n      accept [:title, :description, :status, :priority, :project_id, :assignee_id]\n      change fn changeset, _ ->\n        Ash.Changeset.force_change_attribute(changeset, :status, :todo)\n      end\n    end\n\n    update :update_with_version do\n      accept [:title, :description, :status, :priority, :assignee_id, :due_date]\n      require_atomic? false\n      change optimistic_lock(:version)\n    end\n\n    update :assign do\n      accept [:assignee_id]\n      change optimistic_lock(:version)\n    end\n\n    update :transition_status do\n      accept [:status]\n      validate fn changeset, _ ->\n        # Validate state machine transitions\n        validate_status_transition(changeset)\n      end\n      change optimistic_lock(:version)\n    end\n  end\nend\n```\n\n#### 03_FUNCTIONAL_CORE.md\n- Pure business logic patterns (no side effects)\n- Core calculations (priorities, estimates, metrics)\n- Validation logic (state transitions, constraints)\n- Testing patterns for pure functions\n- Property test examples\n\nExample:\n```elixir\ndefmodule TaskManager.Impl.TaskLogic do\n  @moduledoc \"\"\"\n  Pure functions for task business logic.\n  No database access, no side effects.\n  \"\"\"\n\n  @spec can_transition?(atom(), atom()) :: boolean()\n  def can_transition?(from_status, to_status) do\n    valid_transitions = %{\n      todo: [:in_progress, :blocked],\n      in_progress: [:blocked, :review, :done],\n      blocked: [:todo, :in_progress],\n      review: [:in_progress, :done],\n      done: []\n    }\n\n    to_status in Map.get(valid_transitions, from_status, [])\n  end\n\n  @spec calculate_priority_score(map()) :: integer()\n  def calculate_priority_score(task) do\n    base_score = priority_value(task.priority)\n    urgency_bonus = days_until_due(task.due_date)\n    dependency_factor = if task.has_blockers?, do: -10, else: 0\n\n    base_score + urgency_bonus + dependency_factor\n  end\n\n  defp priority_value(:urgent), do: 100\n  defp priority_value(:high), do: 75\n  defp priority_value(:medium), do: 50\n  defp priority_value(:low), do: 25\n\n  defp days_until_due(nil), do: 0\n  defp days_until_due(due_date) do\n    diff = Date.diff(due_date, Date.utc_today())\n    cond do\n      diff < 0 -> 50  # Overdue\n      diff <= 3 -> 30  # Within 3 days\n      diff <= 7 -> 15  # Within a week\n      true -> 0\n    end\n  end\nend\n```\n\n#### 04_BOUNDARIES.md\n- Service orchestration layer\n- Ecto.Multi patterns for atomic operations\n- Transaction boundaries\n- Error handling strategies\n- Service composition patterns\n\nExample:\n```elixir\ndefmodule TaskManager.Boundaries.TaskService do\n  alias Ecto.Multi\n  alias TaskManager.Impl.TaskLogic\n\n  def transition_task(task_id, new_status, opts \\\\ []) do\n    Multi.new()\n    |> Multi.run(:load_task, fn _repo, _changes ->\n      case Ash.get(Task, task_id) do\n        {:ok, task} -> {:ok, task}\n        error -> error\n      end\n    end)\n    |> Multi.run(:validate_transition, fn _repo, %{load_task: task} ->\n      # Pure validation from impl/ layer\n      if TaskLogic.can_transition?(task.status, new_status) do\n        {:ok, :valid}\n      else\n        {:error, :invalid_transition}\n      end\n    end)\n    |> Multi.run(:update_task, fn _repo, %{load_task: task} ->\n      Task.transition_status(task, %{status: new_status})\n    end)\n    |> Multi.run(:create_activity, fn _repo, %{update_task: task} ->\n      create_activity_log(task, \"status_changed\", %{from: task.status, to: new_status})\n    end)\n    |> Multi.run(:notify_assignee, fn _repo, %{update_task: task} ->\n      if opts[:notify], do: send_notification(task.assignee_id, task)\n      {:ok, :notified}\n    end)\n    |> Multi.run(:publish_event, fn _repo, %{update_task: task} ->\n      publish_task_updated(task)\n    end)\n    |> Repo.transaction()\n  end\nend\n```\n\n#### 05_LIFECYCLE.md\n- OTP application structure\n- Supervision tree diagrams\n- GenServer usage (infrastructure only, NOT entities!)\n- GenStage/Flow pipelines\n- Telemetry setup\n- Health checks\n\nExample supervisor:\n```elixir\ndef start(_type, _args) do\n  children = [\n    {TaskManager.Repo, []},\n    {Phoenix.PubSub, name: TaskManager.PubSub},\n    {TaskManager.Runtime.TaskCache, []},\n    genstage_supervisor_spec(),\n    {Oban, Application.fetch_env!(:task_manager, Oban)}\n  ]\n\n  opts = [strategy: :one_for_one, name: TaskManager.Supervisor]\n  Supervisor.start_link(children, opts)\nend\n```\n\n#### 06_WORKERS.md\n- Oban worker definitions\n- Job queues and priorities\n- Retry strategies\n- Worker testing patterns\n- Background job best practices\n\nExample:\n```elixir\ndefmodule TaskManager.Workers.ReminderNotifier do\n  use Oban.Worker,\n    queue: :notifications,\n    max_attempts: 3,\n    priority: 2\n\n  @impl Oban.Worker\n  def perform(%Oban.Job{args: %{\"task_id\" => id, \"type\" => type}}) do\n    with {:ok, task} <- get_task(id),\n         {:ok, assignee} <- get_assignee(task.assignee_id),\n         :ok <- send_reminder(assignee, task, type) do\n      {:ok, :notified}\n    end\n  end\n\n  defp send_reminder(assignee, task, \"due_soon\") do\n    # Send email/push notification\n    # Task is due within 24 hours\n    Notifications.send(assignee.email, \"Task Due Soon\", render_template(task))\n  end\n\n  defp send_reminder(assignee, task, \"overdue\") do\n    # Task is past due date\n    Notifications.send_urgent(assignee.email, \"Overdue Task\", render_template(task))\n  end\nend\n```\n\n#### 07_INTEGRATION_PATTERNS.md\n- HTTP client patterns with Finch\n- Circuit breaker implementation\n- Retry logic with exponential backoff\n- Webhook handling (incoming and outgoing)\n- Event streaming with Broadway\n- External service integration patterns\n\nExample:\n```elixir\ndefmodule TaskManager.Integration.HTTPClient do\n  def request(method, url, body, opts \\\\ []) do\n    timeout = Keyword.get(opts, :timeout, 5_000)\n    retries = Keyword.get(opts, :retries, 3)\n\n    request = build_request(method, url, body)\n    do_request_with_retry(request, timeout, retries)\n  end\n\n  defp do_request_with_retry(request, timeout, retries_left, attempt \\\\ 1) do\n    case Finch.request(request, TaskManager.Finch, receive_timeout: timeout) do\n      {:ok, %{status: status}} when status in 200..299 ->\n        {:ok, decode_response(response)}\n\n      {:ok, %{status: status}} when status in 500..599 and retries_left > 0 ->\n        backoff = calculate_backoff(attempt)\n        Process.sleep(backoff)\n        do_request_with_retry(request, timeout, retries_left - 1, attempt + 1)\n\n      {:error, _} = error ->\n        error\n    end\n  end\n\n  defp calculate_backoff(attempt) do\n    # Exponential backoff: 100ms, 200ms, 400ms, 800ms\n    trunc(:math.pow(2, attempt - 1) * 100)\n  end\nend\n```\n\n### Phase 7: Architecture Decision Records\n\nCreate ADRs for major decisions. Template:\n\n```markdown\n# ADR-XXX: [Decision Title]\n\n**Status:** Accepted\n**Date:** YYYY-MM-DD\n**Deciders:** [Role]\n**Context:** [Brief context]\n\n## Context\n[Detailed explanation of the situation requiring a decision]\n\n## Decision\n[Clear statement of what was decided]\n\n## Rationale\n[Why this decision was made - include code examples, metrics, trade-offs]\n\n## Alternatives Considered\n\n### Alternative 1: [Name]\n**Implementation:**\n```elixir\n# Example code\n```\n\n**Pros:**\n- Advantage 1\n- Advantage 2\n\n**Cons:**\n- Disadvantage 1\n- Disadvantage 2\n\n**Why Rejected:** [Clear explanation]\n\n### Alternative 2: [Name]\n[Same structure]\n\n## Consequences\n\n### Positive\n1. Benefit with explanation\n2. Another benefit\n\n### Negative\n1. Trade-off with mitigation strategy\n2. Another trade-off\n\n## Implementation Guidelines\n\n### DO: [Pattern]\n```elixir\n# Good example\n```\n\n### DON'T: [Anti-pattern]\n```elixir\n# Bad example\n```\n\n## Validation\n[How we'll verify this was the right choice]\n- Metric 1: Target value\n- Metric 2: Target value\n\n## References\n- [Link 1]\n- [Link 2]\n\n## Related ADRs\n- ADR-XXX: Related Decision\n\n## Review Schedule\n**Last Reviewed:** YYYY-MM-DD\n**Next Review:** YYYY-MM-DD\n```\n\n**Minimum ADRs to create:**\n\n1. **ADR-001: Framework Choice** (Ash vs Plain Ecto vs Event Sourcing)\n2. **ADR-002: ID Strategy** (ULID vs UUID vs Auto-increment vs Snowflake)\n3. **ADR-003: Process Architecture** (Database as source of truth vs GenServers for entities)\n4. **Domain-specific ADRs** based on requirements\n\n### Phase 8: Handoff Documentation\n\nCreate HANDOFF.md with:\n\n1. **Overview** - Project status, location, ready state\n2. **Project Structure** - Annotated directory tree\n3. **Documentation Index** - What each file contains\n4. **Workflow** - Director â†’ Implementor â†’ Review â†’ Iterate cycle\n5. **Implementation Phases** - Break project into 4-week phases\n6. **Key Architectural Principles** - DO/DON'T examples\n7. **Testing Strategy** - Unit/Integration/Property test patterns\n8. **Commit Message Format** - Conventional commits structure\n9. **Communication Protocol** - Message templates between Director/Implementor\n10. **Troubleshooting** - Common issues and solutions\n11. **Success Metrics** - Specific performance targets\n12. **Next Steps** - Immediate actions for Director AI\n\nExample workflow section:\n```markdown\n## Workflow\n\n### Phase 1: Director Creates Design & Plan\n1. Read feature request from user\n2. Review architecture documents\n3. Create design document in `docs/design/`\n4. Create implementation plan in `docs/plans/` (Superpowers format)\n5. Commit design + plan\n6. Hand off to Implementor with plan path\n\n### Phase 2: Implementor Executes Plan\n1. Read implementation plan\n2. For each task:\n   - Write test first (TDD)\n   - Implement minimum code\n   - Refactor\n   - Run tests\n   - Commit\n3. Report completion to Director\n\n### Phase 3: Director Reviews\n1. Review committed code\n2. Check against design\n3. Verify guardrails followed\n4. Either approve or request changes\n\n### Phase 4: Iterate Until Approved\n[Loop until feature is complete]\n```\n\n### Phase 9: Validate and Summarize\n\nBefore finishing, verify:\n\n1. âœ… All directories created\n2. âœ… 20+ documentation files present\n3. âœ… All cross-references between docs work\n4. âœ… All code examples are valid Elixir syntax\n5. âœ… Every architectural principle has concrete example\n6. âœ… ADRs include alternatives with rationale\n7. âœ… Guardrails have DO/DON'T code examples\n8. âœ… Domain-specific adaptations included\n\nPresent summary:\n```markdown\n## Project Architecture Complete! ðŸš€\n\n**Location:** /path/to/project\n\n**Created:**\n- âœ… Complete directory structure\n- âœ… Foundation docs (README, CLAUDE.md)\n- âœ… 5 guardrail documents\n- âœ… 8 architecture documents (~6,000 lines)\n- âœ… X Architecture Decision Records\n- âœ… Handoff documentation\n\n**Ready For:**\n- Director AI to create first design + plan\n- Implementor AI to execute implementation\n- Iterative feature development\n\n**Next Step:**\nDirector AI should begin by creating the first feature design.\n```\n\n## Domain-Specific Adaptations\n\n### For Task Management Systems\n\nAdd emphasis on:\n\n1. **NEVER_DO.md** additions:\n   - Never allow invalid status transitions (enforce state machine)\n   - Never skip concurrency checks (optimistic locking for updates)\n   - Never store assignment history only in memory (persist for audit)\n\n2. **Domain Model** inclusions:\n   - Task state machine (todo â†’ in_progress â†’ review â†’ done)\n   - Priority calculation algorithms\n   - Dependency management (blocked tasks, prerequisites)\n   - Assignment and notification workflows\n   - Activity log for audit trail\n\n3. **ADRs** to add:\n   - State machine implementation (database constraints vs application logic)\n   - Priority scoring algorithm\n   - Real-time update strategy (PubSub vs polling)\n   - Notification delivery guarantees\n\n4. **Use Cases** examples:\n   - Create task and assign to user\n   - Transition task through workflow states\n   - Handle blocked tasks and dependencies\n   - Generate team velocity reports\n\n### For Financial Systems\n\nAdd emphasis on:\n\n1. **NEVER_DO.md** additions:\n   - Never use floats for money (float precision errors)\n   - Never allow partial transaction commits (atomicity required)\n   - Never skip double-entry validation (balance integrity)\n   - Never update balances without version check (optimistic locking)\n\n2. **Domain Model** inclusions:\n   - Double-entry bookkeeping explanation and examples\n   - Balance calculation patterns (debits vs credits)\n   - Commission/fee calculation models\n   - Two-phase transaction workflow (pending â†’ approved/canceled)\n   - Immutable audit trail requirements\n\n3. **ADRs** to add:\n   - Money representation (integer cents vs Decimal)\n   - Transaction isolation levels\n   - Audit trail implementation strategy\n   - Optimistic vs pessimistic locking choice\n\n4. **Use Cases** examples:\n   - Account-to-account transfer\n   - Payment with commission split\n   - Voucher creation and redemption\n   - Balance reconciliation\n\n### For E-Commerce Systems\n\nAdd emphasis on:\n\n1. **Domain Model** additions:\n   - Order state machine (cart â†’ placed â†’ paid â†’ fulfilled â†’ delivered)\n   - Inventory management and reservation\n   - Payment processing flow\n   - Refund and cancellation handling\n\n2. **Workers** to document:\n   - Order fulfillment worker\n   - Inventory synchronization worker\n   - Email notification worker\n   - Abandoned cart recovery worker\n\n3. **Integration Patterns**:\n   - Payment gateway integration (Stripe, PayPal)\n   - Shipping provider APIs\n   - Inventory management system sync\n\n### For SaaS Platforms\n\nAdd emphasis on:\n\n1. **Domain Model** additions:\n   - Multi-tenancy strategy (shared schema with tenant_id vs separate schemas)\n   - Subscription and billing models\n   - Usage tracking and metering\n   - Feature flags and plan limits\n\n2. **Data Layer** considerations:\n   - Tenant isolation strategy (row-level security)\n   - Cross-tenant query prevention\n   - Data partitioning approach\n\n3. **Security**:\n   - Tenant context enforcement\n   - API authentication (JWT, API keys)\n   - Authorization patterns (role-based, attribute-based)\n\n## Critical Patterns and Best Practices\n\n### State Machine Validation\n\n```elixir\n# âœ… ALWAYS validate state transitions\ndef transition_status(task, new_status) do\n  if TaskLogic.can_transition?(task.status, new_status) do\n    Task.update(task, %{status: new_status})\n  else\n    {:error, :invalid_transition}\n  end\nend\n\n# Define valid transitions\ndef can_transition?(from_status, to_status) do\n  valid_transitions = %{\n    todo: [:in_progress, :blocked],\n    in_progress: [:blocked, :review, :done],\n    blocked: [:todo, :in_progress],\n    review: [:in_progress, :done],\n    done: []\n  }\n\n  to_status in Map.get(valid_transitions, from_status, [])\nend\n```\n\n### Optimistic Locking\n\n```elixir\n# âœ… ALWAYS check version for concurrent updates\ndef update_task(task_id, new_attrs) do\n  task = Repo.get!(Task, task_id)\n\n  changeset =\n    task\n    |> change(new_attrs)\n    |> optimistic_lock(:version)\n\n  case Repo.update(changeset) do\n    {:ok, updated} -> {:ok, updated}\n    {:error, changeset} ->\n      if changeset.errors[:version] do\n        {:error, :version_conflict}\n      else\n        {:error, changeset}\n      end\n  end\nend\n```\n\n### GenServer Usage (Infrastructure Only!)\n\n```elixir\n# âŒ DON'T: GenServer per entity\ndefmodule TaskServer do\n  use GenServer\n  # Storing task state in process - DON'T DO THIS\nend\n\n# âœ… DO: GenServer for infrastructure\ndefmodule TaskCache do\n  use GenServer\n  # Caching active tasks (transient data, can rebuild from DB)\nend\n\ndefmodule RateLimiter do\n  use GenServer\n  # Tracking API request counts (acceptable to lose on crash)\nend\n```\n\n### Ecto.Multi for Atomic Operations\n\n```elixir\n# âœ… ALWAYS use Multi for multi-step operations\nMulti.new()\n|> Multi.insert(:task, task_changeset)\n|> Multi.run(:assign, fn _repo, %{task: task} ->\n  create_assignment(task.id, assignee_id)\nend)\n|> Multi.run(:activity_log, fn _repo, %{task: task} ->\n  log_activity(task, \"task_created\")\nend)\n|> Multi.run(:publish_event, fn _repo, changes ->\n  publish_event(changes)\nend)\n|> Repo.transaction()\n```\n\n### Async External Calls\n\n```elixir\n# âŒ NEVER block request path\ndef send_notification(task) do\n  HTTPClient.post(\"https://notifications.com/api\", ...)  # BLOCKS!\nend\n\n# âœ… ALWAYS enqueue background job\ndef send_notification(task) do\n  %{task_id: task.id, type: \"assignment\"}\n  |> NotificationWorker.new()\n  |> Oban.insert()\nend\n```\n\n## Common Mistakes to Avoid\n\n1. **Too Generic** - Always adapt to specific domain needs\n2. **Missing Examples** - Every principle needs concrete code\n3. **Unclear Boundaries** - Director vs Implementor roles must be explicit\n4. **No Trade-offs** - Always explain downsides of decisions in ADRs\n5. **Incomplete ADRs** - Must include alternatives considered and why rejected\n6. **Vague Metrics** - Use specific numbers (<100ms, 1000 TPS, >90% coverage)\n7. **Umbrella Apps** - Unless explicitly requested, use Dave Thomas structure\n8. **GenServers for Entities** - Database is source of truth, not processes\n\n## Quality Gates\n\nBefore considering work complete:\n\n- [ ] All code examples use valid Elixir syntax\n- [ ] Every \"NEVER DO\" has a corresponding \"ALWAYS DO\"\n- [ ] Every ADR explains alternatives and why they were rejected\n- [ ] Domain model includes complete entity definitions with types\n- [ ] Performance targets are specific and measurable\n- [ ] Guardrails have clear, executable examples\n- [ ] Communication protocol includes message templates\n- [ ] Testing strategy covers unit/integration/property tests\n- [ ] Integration patterns include retry/circuit breaker\n- [ ] Supervision tree is documented with ASCII diagram\n\n## Success Criteria\n\nYou've succeeded when:\n\n1. âœ… Director AI can create feature designs without asking architectural questions\n2. âœ… Implementor AI can write code without asking design questions\n3. âœ… All major decisions are documented with clear rationale\n4. âœ… Code examples are copy-paste ready\n5. âœ… Domain-specific requirements are thoroughly addressed\n6. âœ… Performance targets are realistic and measurable\n7. âœ… The system can be built by following the documentation alone\n\n## Notes\n\n- **Empty directories** (docs/design/, docs/plans/, docs/api/) are intentional - Director fills these during feature work\n- **Superpowers format** for implementation plans: Markdown with YAML frontmatter, 2-5 minute tasks\n- **All code examples** must be valid Elixir that could actually run\n- **Consult experts** via Task agents - don't guess at best practices\n- **Dave Thomas structure** preferred over umbrella apps unless user specifies otherwise\n- **Database as source of truth** - avoid GenServers for domain entities (see ADR-003)"
              }
            ]
          }
        ]
      }
    }
  ]
}