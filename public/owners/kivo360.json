{
  "owner": {
    "id": "kivo360",
    "display_name": "Kevin Hill",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/2403240?u=6dc50c315eb11d00cfe1646c6d9c43db2a736432&v=4",
    "url": "https://github.com/kivo360",
    "bio": "I code stuff. #finance",
    "stats": {
      "total_repos": 1,
      "total_plugins": 1,
      "total_commands": 4,
      "total_skills": 3,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "kivo360/claude-toolbelt",
      "url": "https://github.com/kivo360/claude-toolbelt",
      "description": "A personal collection of professional Claude Code plugins for database development, automation, and productivity tools",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-11-20T18:27:08Z",
        "created_at": "2025-11-20T18:25:36Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1844
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 2619
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter",
          "type": "tree",
          "size": null
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 738
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/.gitignore",
          "type": "blob",
          "size": 432
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/.mcp.json",
          "type": "blob",
          "size": 363
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/GETTING_STARTED.md",
          "type": "blob",
          "size": 7590
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/INSTALL.md",
          "type": "blob",
          "size": 4744
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/README.md",
          "type": "blob",
          "size": 9874
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/VALIDATION_REPORT.md",
          "type": "blob",
          "size": 10025
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/agents/conversion-analyzer.md",
          "type": "blob",
          "size": 6036
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/agents/schema-reflector.md",
          "type": "blob",
          "size": 7912
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/commands/convert-project.md",
          "type": "blob",
          "size": 2163
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/commands/create-session.md",
          "type": "blob",
          "size": 2940
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/commands/generate-models.md",
          "type": "blob",
          "size": 2621
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/commands/validate-conversion.md",
          "type": "blob",
          "size": 4373
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/examples/usage-example.md",
          "type": "blob",
          "size": 14762
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/hooks/hooks.json",
          "type": "blob",
          "size": 334
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/scripts/supabase-mcp-server.py",
          "type": "blob",
          "size": 13524
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/scripts/validate-sqlalchemy.sh",
          "type": "blob",
          "size": 9835
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/setup.py",
          "type": "blob",
          "size": 1546
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/skills/asyncpg-detection",
          "type": "tree",
          "size": null
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/skills/asyncpg-detection/SKILL.md",
          "type": "blob",
          "size": 2790
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/skills/sqlalchemy-conversion",
          "type": "tree",
          "size": null
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/skills/sqlalchemy-conversion/SKILL.md",
          "type": "blob",
          "size": 4345
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/skills/supabase-integration",
          "type": "tree",
          "size": null
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/skills/supabase-integration/SKILL.md",
          "type": "blob",
          "size": 16027
        }
      ],
      "marketplace": {
        "name": "claude-toolbelt",
        "version": "1.0.0",
        "description": "A personal collection of professional Claude Code plugins for database development, automation, and productivity tools",
        "owner_info": {
          "name": "Kevin Hill",
          "email": "kevin.hill@example.com",
          "url": "https://github.com/kivo360"
        },
        "keywords": [
          "database",
          "sqlalchemy",
          "asyncpg",
          "fastapi",
          "supabase",
          "conversion",
          "productivity"
        ],
        "plugins": [
          {
            "name": "asyncpg-to-sqlalchemy-converter",
            "description": "Convert asyncpg code in FastAPI projects to SQLAlchemy 2.0+ with async support, optimized for Supabase integration",
            "source": "./asyncpg-to-sqlalchemy-converter",
            "category": "database",
            "version": "1.0.0",
            "author": "Kevin Hill",
            "install_commands": [
              "/plugin marketplace add kivo360/claude-toolbelt",
              "/plugin install asyncpg-to-sqlalchemy-converter@claude-toolbelt"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-11-20T18:27:08Z",
              "created_at": "2025-11-20T18:25:36Z",
              "license": null
            },
            "commands": [
              {
                "name": "/convert-project",
                "description": null,
                "path": "asyncpg-to-sqlalchemy-converter/commands/convert-project.md",
                "frontmatter": null,
                "content": "Convert asyncpg FastAPI project to SQLAlchemy async patterns\n\nThis command analyzes a FastAPI project, detects all asyncpg usage patterns, and systematically converts them to SQLAlchemy 2.0+ with async support while maintaining full functionality.\n\n## Usage\n\n```bash\n/convert-asyncpg-to-sqlalchemy [options]\n```\n\n## Options\n\n- `--path <directory>`: Project directory to analyze (default: current directory)\n- `--backup <directory>`: Backup location before conversion (default: ./backup_asyncpg)\n- `--supabase`: Enable Supabase-specific optimizations and integrations\n- `--models-only`: Only convert models, skip utility functions\n- `--dry-run`: Preview changes without modifying files\n- `--interactive`: Prompt for confirmation on major changes\n\n## Process\n\n### Phase 1: Detection & Analysis\n1. Scan all Python files for asyncpg imports and usage patterns\n2. Analyze connection methods, query patterns, and transaction handling\n3. Generate detailed conversion report with complexity assessment\n\n### Phase 2: Backup Creation\n1. Create complete backup of original code\n2. Generate conversion log for rollback capabilities\n3. Document all detected patterns and planned changes\n\n### Phase 3: Systematic Conversion\n1. Update imports from asyncpg to SQLAlchemy\n2. Convert connection patterns to async session management\n3. Transform query syntax (fetch → execute, parameter binding)\n4. Update transaction handling patterns\n5. Convert error handling to SQLAlchemy exceptions\n\n### Phase 4: Validation\n1. Syntax validation of converted code\n2. Import verification and dependency checking\n3. Basic functionality testing of converted patterns\n\n### Phase 5: Documentation\n1. Generate conversion summary report\n2. Create migration guide with before/after examples\n3. Document any manual intervention requirements\n\n## Examples\n\nConvert current directory with Supabase support:\n```bash\n/convert-asyncpg-to-sqlalchemy --supabase\n```\n\nDry run to preview changes:\n```bash\n/convert-asyncpg-to-sqlalchemy --dry-run --path ./my-fastapi-app\n```\n\nInteractive conversion with custom backup:\n```bash\n/convert-asyncpg-to-sqlalchemy --path ./src --backup ./original_code --interactive\n```"
              },
              {
                "name": "/create-session",
                "description": null,
                "path": "asyncpg-to-sqlalchemy-converter/commands/create-session.md",
                "frontmatter": null,
                "content": "Create SQLAlchemy async session management setup\n\nThis command generates complete async session management configuration for FastAPI projects, including dependency injection, connection pooling, error handling, and Supabase integration patterns.\n\n## Usage\n\n```bash\n/create-async-session [options]\n```\n\n## Options\n\n- `--output <directory>`: Output directory for session files (default: ./database)\n- `--supabase`: Include Supabase-specific configurations\n- `--pool-size <number>`: Connection pool size (default: 10)\n- `--max-overflow <number>`: Maximum overflow connections (default: 0)\n- `--testing`: Include testing configuration and fixtures\n- `--migrations`: Include Alembic migration setup\n- `--docker`: Generate Docker Compose configuration\n\n## Generated Components\n\n### Core Session Management\n- Async engine configuration with proper connection pooling\n- Async session factory setup\n- FastAPI dependency injection patterns\n- Connection lifecycle management\n\n### Database Configuration\n- Environment-based configuration management\n- Connection string handling with security\n- Pool optimization for different deployment targets\n- Serverless environment optimizations\n\n### Error Handling & Monitoring\n- Database error handling patterns\n- Connection retry logic with exponential backoff\n- Health check endpoints for database connectivity\n- Logging and monitoring setup\n\n### Testing Support\n- In-memory database configuration for testing\n- Test fixtures and utilities\n- Transaction rollback testing patterns\n- Mock session providers\n\n### Supabase Integration (optional)\n- Supabase auth integration with RLS\n- Service key management\n- Row Level Security context handling\n- Supabase-specific connection optimizations\n\n## Examples\n\nCreate basic session setup:\n```bash\n/create-async-session --output ./src/database\n```\n\nCreate Supabase-enabled session management:\n```bash\n/create-async-session --supabase --pool-size 20 --testing\n```\n\nComplete setup with migrations and Docker:\n```bash\n/create-async-session --testing --migrations --docker --supabase\n```\n\n## Generated Files\n\n### Core Files\n- `database.py` - Main database configuration and session factory\n- `dependencies.py` - FastAPI dependency injection patterns\n- `config.py` - Environment-based configuration management\n- `exceptions.py` - Custom database exception handlers\n\n### Optional Files\n- `testing.py` - Testing configuration and fixtures\n- `migrations/` - Alembic migration setup\n- `docker-compose.yml` - Database container configuration\n- `supabase_integration.py` - Supabase-specific integration patterns\n\n### Features\n- Async session management with proper cleanup\n- Connection pooling optimized for different environments\n- Error handling with retry mechanisms\n- Testing utilities with in-memory database support\n- Supabase auth and RLS integration\n- Health check endpoints and monitoring\n- Docker development environment setup\n- Comprehensive logging and debugging support"
              },
              {
                "name": "/generate-models",
                "description": null,
                "path": "asyncpg-to-sqlalchemy-converter/commands/generate-models.md",
                "frontmatter": null,
                "content": "Generate SQLAlchemy models from database schema\n\nThis command connects to your database (PostgreSQL/Supabase), reflects the schema structure, and generates complete SQLAlchemy model definitions with proper relationships, constraints, and type mappings.\n\n## Usage\n\n```bash\n/generate-sqlalchemy-models [options]\n```\n\n## Options\n\n- `--url <connection_string>`: Database connection string (or uses SUPABASE_URL env var)\n- `--schema <name>`: Schema to reflect (default: public)\n- `--output <file>`: Output file for generated models (default: models.py)\n- `--base-class <name>`: Base class for all models (default: Base)\n- `--lazy-load`: Enable lazy loading for large schemas\n- `--include-extensions`: Include table relationships from database extensions\n- `--supabase-optimize`: Optimize for Supabase-specific features (RLS, UUIDs, etc.)\n\n## Schema Reflection Features\n\n### Automatic Type Detection\n- Maps PostgreSQL types to SQLAlchemy types\n- Handles Supabase-specific types (uuid_generate_v4(), jsonb, timestamptz)\n- Detects auto-incrementing primary keys and sequences\n\n### Relationship Generation\n- Automatically detects foreign key constraints\n- Creates bi-directional relationships with proper back_populates\n- Handles many-to-many relationships through junction tables\n\n### Constraint Mapping\n- Primary key constraints (composite keys supported)\n- Unique constraints and indexes\n- Check constraints and default values\n- NOT NULL constraints and nullable columns\n\n### Supabase Integration\n- Row Level Security (RLS) policy hints\n- Supabase auth user table relationships\n- Storage bucket integration patterns\n- Webhook table handling\n\n## Examples\n\nGenerate models from Supabase:\n```bash\n/generate-sqlalchemy-models --url \"postgresql+asyncpg://user:pass@host:5432/db\" --supabase-optimize\n```\n\nGenerate for specific schema with lazy loading:\n```bash\n/generate-sqlalchemy-models --schema analytics --output analytics_models.py --lazy-load\n```\n\nReflect all schemas with extensions:\n```bash\n/generate-sqlalchemy-models --include-extensions --base-class CustomBase\n```\n\n## Output Format\n\nThe command generates:\n- SQLAlchemy model classes with proper type hints\n- Column definitions with constraints and defaults\n- Relationship definitions with cascade options\n- Import statements and base class definition\n- Optional migration script for existing code\n\n## Generated Features\n\n- Type hints for all columns and relationships\n- Proper __repr__ methods for debugging\n- Validation methods for common use cases\n- Supabase-specific optimizations\n- Lazy loading support for large schemas\n- JSON serialization methods for API responses"
              },
              {
                "name": "/validate-conversion",
                "description": null,
                "path": "asyncpg-to-sqlalchemy-converter/commands/validate-conversion.md",
                "frontmatter": null,
                "content": "Validate SQLAlchemy conversion and test functionality\n\nThis command validates that the asyncpg to SQLAlchemy conversion was successful by running comprehensive tests, checking syntax validity, verifying database connectivity, and ensuring all functionality works as expected.\n\n## Usage\n\n```bash\n/validate-sqlalchemy-conversion [options]\n```\n\n## Options\n\n- `--path <directory>`: Project directory to validate (default: current directory)\n- `--connection-string <url>`: Database connection for testing (required)\n- `--test-data`: Run tests with sample data\n- `--performance`: Include performance benchmarks\n- `--supabase`: Include Supabase-specific validations\n- `--detailed`: Provide detailed validation report\n- `--fix-issues`: Attempt to automatically fix detected issues\n\n## Validation Categories\n\n### Syntax & Import Validation\n- Check all Python files for syntax errors\n- Verify SQLAlchemy imports are correct\n- Validate async/await usage patterns\n- Check for proper type hints and annotations\n\n### Database Connectivity\n- Test database connection establishment\n- Verify async session creation and cleanup\n- Test connection pooling functionality\n- Validate connection string parsing\n\n### Query Functionality Tests\n- Test basic CRUD operations (Create, Read, Update, Delete)\n- Validate parameter binding and escaping\n- Test complex queries with joins and aggregations\n- Verify transaction handling and rollback scenarios\n\n### Performance Benchmarks\n- Compare query performance between original and converted code\n- Test connection pooling efficiency\n- Memory usage analysis during database operations\n- Concurrent request handling validation\n\n### Supabase Integration Tests (optional)\n- Row Level Security (RLS) functionality\n- JWT token validation with database sessions\n- Supabase auth integration testing\n- Storage integration with database operations\n\n## Validation Process\n\n### Phase 1: Static Analysis\n1. Syntax validation of all Python files\n2. Import verification and dependency checking\n3. Async pattern validation and coroutine checking\n4. Type hint verification for better IDE support\n\n### Phase 2: Database Testing\n1. Connection establishment tests\n2. Session lifecycle validation\n3. Basic CRUD operation testing\n4. Error handling and recovery testing\n\n### Phase 3: Integration Testing\n1. FastAPI endpoint testing with database operations\n2. Dependency injection validation\n3. Concurrent request handling\n4. Memory leak detection\n\n### Phase 4: Performance Analysis\n1. Query execution time comparison\n2. Connection pool efficiency testing\n3. Memory usage profiling\n4. Scalability assessment\n\n## Examples\n\nBasic validation:\n```bash\n/validate-sqlalchemy-conversion --connection-string \"postgresql+asyncpg://user:pass@host:5432/db\"\n```\n\nComprehensive validation with Supabase support:\n```bash\n/validate-sqlalchemy-conversion --supabase --performance --test-data --detailed\n```\n\nValidate specific directory with auto-fix:\n```bash\n/validate-sqlalchemy-conversion --path ./src/api --connection-string $DATABASE_URL --fix-issues\n```\n\n## Output Reports\n\n### Summary Report\n- Overall validation status (PASS/FAIL/WARNING)\n- Number of issues found and fixed\n- Performance metrics comparison\n- Recommendations for improvements\n\n### Detailed Issues Report\n- File-by-file validation results\n- Specific syntax errors and fixes applied\n- Missing imports or incorrect patterns\n- Performance bottlenecks identified\n\n### Performance Analysis\n- Query execution time comparisons\n- Connection pool efficiency metrics\n- Memory usage patterns\n- Scalability test results\n\n### Recommendations\n- Code improvement suggestions\n- Performance optimization opportunities\n- Security considerations\n- Best practice recommendations\n\n## Auto-Fix Capabilities\n\nWhen `--fix-issues` is enabled, the command can automatically:\n\n- Fix common import errors and missing dependencies\n- Correct async/await usage patterns\n- Update type hints for better IDE support\n- Fix basic syntax errors\n- Optimize connection pooling configurations\n- Update error handling patterns\n- Fix parameter binding issues\n- Correct transaction handling patterns\n\n## Exit Codes\n\n- `0`: Validation successful - all tests passed\n- `1`: Validation failed - critical issues found\n- `2`: Validation failed with warnings - non-critical issues present\n- `3`: Validation error - unable to complete validation due to environment issues"
              }
            ],
            "skills": [
              {
                "name": "asyncpg-detection",
                "description": "This skill should be used when the user asks to \"detect asyncpg usage\", \"find asyncpg patterns\", \"scan for asyncpg imports\", or \"identify asyncpg database code in FastAPI projects\". It automatically scans Python files to identify asyncpg imports, connection patterns, and query execution methods that need conversion to SQLAlchemy.",
                "path": "asyncpg-to-sqlalchemy-converter/skills/asyncpg-detection/SKILL.md",
                "frontmatter": {
                  "name": "asyncpg-detection",
                  "description": "This skill should be used when the user asks to \"detect asyncpg usage\", \"find asyncpg patterns\", \"scan for asyncpg imports\", or \"identify asyncpg database code in FastAPI projects\". It automatically scans Python files to identify asyncpg imports, connection patterns, and query execution methods that need conversion to SQLAlchemy.",
                  "version": "1.0.0"
                },
                "content": "# AsyncPG Detection for FastAPI Projects\n\nThis skill provides comprehensive detection of asyncpg usage patterns in FastAPI applications, identifying all code that needs to be converted to SQLAlchemy with asyncpg engine support.\n\n## Detection Overview\n\nScan FastAPI projects for asyncpg patterns including imports, connection management, queries, transactions, and error handling. Generate detailed reports with line numbers and conversion recommendations.\n\n## Core Detection Patterns\n\n### Import Detection\nLook for these import statements:\n- `import asyncpg`\n- `from asyncpg import`\n- `import asyncpg as pg`\n- `from asyncpg import Connection, Pool`\n\n### Connection Patterns\nIdentify these asyncpg connection approaches:\n- `asyncpg.connect()` calls\n- `asyncpg.create_pool()` usage\n- Manual connection string parsing\n- Environment-based connection configuration\n\n### Query Patterns\nDetect these asyncpg execution methods:\n- `connection.fetch()` for SELECT queries\n- `connection.execute()` for INSERT/UPDATE/DELETE\n- `connection.fetchval()` for single values\n- `connection.fetchrow()` for single rows\n- `connection.iter()` for result iteration\n\n## Usage Instructions\n\nTo detect asyncpg usage in your FastAPI project:\n\n1. **Run comprehensive scan**: Use the `/convert-asyncpg-to-sqlalchemy` command to scan all Python files in the project\n2. **Analyze detection results**: Review the generated report for files containing asyncpg code\n3. **Prioritize conversion**: Focus on files with the most asyncpg usage first\n4. **Check for complex patterns**: Look for nested connections, transactions, and error handling that may require special attention\n\n## Reporting Format\n\nThe detection generates reports with:\n- **File list**: All files containing asyncpg imports\n- **Pattern analysis**: Specific asyncpg methods found\n- **Complexity assessment**: Files requiring manual intervention\n- **Conversion recommendations**: Suggested SQLAlchemy equivalents\n\n## Additional Resources\n\n### Reference Files\n- **`references/patterns-mapping.md`** - Complete asyncpg to SQLAlchemy pattern mapping\n- **`references/complex-cases.md`** - Handling of complex asyncpg scenarios\n- **`references/supabase-specific.md`** - Supabase-specific asyncpg patterns\n\n### Examples\n- **`examples/detection-report.md`** - Sample detection output\n- **`examples/fastapi-project-structure.md`** - Example FastAPI project with asyncpg usage"
              },
              {
                "name": "sqlalchemy-conversion",
                "description": "This skill should be used when the user asks to \"convert asyncpg to SQLAlchemy\", \"convert database queries\", \"migrate asyncpg code\", \"transform asyncpg patterns to SQLAlchemy\", or \"update FastAPI database layer\". It provides systematic conversion of asyncpg code to SQLAlchemy async patterns with proper error handling and transaction management.",
                "path": "asyncpg-to-sqlalchemy-converter/skills/sqlalchemy-conversion/SKILL.md",
                "frontmatter": {
                  "name": "sqlalchemy-conversion",
                  "description": "This skill should be used when the user asks to \"convert asyncpg to SQLAlchemy\", \"convert database queries\", \"migrate asyncpg code\", \"transform asyncpg patterns to SQLAlchemy\", or \"update FastAPI database layer\". It provides systematic conversion of asyncpg code to SQLAlchemy async patterns with proper error handling and transaction management.",
                  "version": "1.0.0"
                },
                "content": "# SQLAlchemy Conversion for AsyncPG Migration\n\nThis skill provides systematic conversion of asyncpg database code to SQLAlchemy 2.0+ with async support, maintaining async performance while providing ORM benefits.\n\n## Conversion Strategy\n\nConvert asyncpg procedural code to SQLAlchemy declarative patterns while preserving async functionality and improving maintainability.\n\n## Core Conversion Patterns\n\n### Import Replacement\nReplace asyncpg imports with SQLAlchemy:\n- `import asyncpg` → `from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine`\n- `from asyncpg import Connection` → `from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker`\n\n### Engine Configuration\nConvert connection setup:\n```python\n# Before (asyncpg)\nengine = await asyncpg.create_pool(dsn)\n\n# After (SQLAlchemy)\nengine = create_async_engine(\n    DATABASE_URL,\n    echo=True,\n    poolclass=NullPool  # For asyncpg compatibility\n)\n```\n\n### Session Management\nReplace connection objects with async sessions:\n```python\n# Before (asyncpg)\nasync def get_user(db, user_id):\n    async with db.acquire() as conn:\n        result = await conn.fetchrow(\"SELECT * FROM users WHERE id = $1\", user_id)\n        return dict(result)\n\n# After (SQLAlchemy)\nasync def get_user(session: AsyncSession, user_id: int):\n    result = await session.execute(\n        select(User).where(User.id == user_id)\n    )\n    return result.scalar_one()\n```\n\n## Query Conversion Guidelines\n\n### SELECT Queries\nTransform fetch operations to SQLAlchemy Core/ORM:\n- `fetchall()` → `execute().scalars().all()`\n- `fetchrow()` → `execute().scalar_one()` or `execute().first()`\n- `fetchval()` → `execute().scalar()`\n- `iter()` → `execute().yield_per()`\n\n### INSERT Operations\nConvert execute patterns:\n```python\n# Before (asyncpg)\nawait conn.execute(\n    \"INSERT INTO users (name, email) VALUES ($1, $2)\",\n    name, email\n)\n\n# After (SQLAlchemy ORM)\nsession.add(User(name=name, email=email))\nawait session.commit()\n```\n\n### Transaction Handling\nUpdate transaction patterns:\n```python\n# Before (asyncpg)\nasync with conn.transaction():\n    await conn.execute(\"UPDATE users SET status = $1\", status)\n\n# After (SQLAlchemy)\nasync with session.begin():\n    await session.execute(\n        update(User).where(User.id == user_id).values(status=status)\n    )\n```\n\n## Usage Instructions\n\nTo convert asyncpg code:\n\n1. **Analyze detected patterns**: Use detection results to understand current codebase structure\n2. **Apply systematic conversion**: Follow the pattern mapping for each identified asyncpg usage\n3. **Handle edge cases**: Refer to complex cases documentation for advanced scenarios\n4. **Validate conversions**: Test converted code to ensure functionality is preserved\n\n## Error Handling Conversion\n\n### Exception Types\nUpdate exception handling:\n- `asyncpg.PostgresError` → `sqlalchemy.exc.DBAPIError`\n- `asyncpg.InterfaceError` → `sqlalchemy.exc.InterfaceError`\n- `asyncpg.exceptions` → Use SQLAlchemy's built-in exceptions\n\n### Connection Errors\nImplement robust error handling:\n```python\n# Before\ntry:\n    conn = await asyncpg.connect(dsn)\nexcept asyncpg.PostgresError as e:\n    logger.error(f\"Database connection failed: {e}\")\n\n# After\ntry:\n    engine = create_async_engine(DATABASE_URL)\n    async with engine.begin() as conn:\n        pass\nexcept SQLAlchemyError as e:\n    logger.error(f\"Database setup failed: {e}\")\n```\n\n## Additional Resources\n\n### Reference Files\n- **`references/pattern-mapping.md`** - Comprehensive asyncpg to SQLAlchemy conversion mapping\n- **`references/async-patterns.md`** - Async SQLAlchemy best practices\n- **`references/error-handling.md`** - SQLAlchemy exception handling patterns\n\n### Examples\n- **`examples/conversion-comparison.md`** - Side-by-side asyncpg vs SQLAlchemy examples\n- **`examples/migration-scripts.py`** - Automated conversion utilities\n- **`examples/test-validation.py`** - Testing converted code patterns"
              },
              {
                "name": "supabase-integration",
                "description": "This skill should be used when the user asks to \"configure Supabase with SQLAlchemy\", \"set up Supabase async engine\", \"create Supabase models\", \"handle Supabase authentication with SQLAlchemy\", or \"integrate Supabase pooling with SQLAlchemy async patterns\". It provides complete Supabase integration patterns for SQLAlchemy with async support, authentication, and connection pooling optimizations.",
                "path": "asyncpg-to-sqlalchemy-converter/skills/supabase-integration/SKILL.md",
                "frontmatter": {
                  "name": "supabase-integration",
                  "description": "This skill should be used when the user asks to \"configure Supabase with SQLAlchemy\", \"set up Supabase async engine\", \"create Supabase models\", \"handle Supabase authentication with SQLAlchemy\", or \"integrate Supabase pooling with SQLAlchemy async patterns\". It provides complete Supabase integration patterns for SQLAlchemy with async support, authentication, and connection pooling optimizations.",
                  "version": "1.0.0"
                },
                "content": "# Supabase Integration for SQLAlchemy Async Projects\n\nThis skill provides comprehensive integration patterns for using SQLAlchemy with Supabase, including async engine configuration, authentication setup, connection pooling, and performance optimizations.\n\n## Integration Overview\n\nConfigure SQLAlchemy to work seamlessly with Supabase PostgreSQL databases while maintaining async performance, proper authentication, and connection management optimizations for serverless environments.\n\n## Supabase Engine Configuration\n\n### Async Engine Setup\nConfigure SQLAlchemy async engine for Supabase:\n```python\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker\nfrom sqlalchemy.orm import DeclarativeBase, sessionmaker\nimport os\n\n# Supabase connection string\nSUPABASE_URL = f\"postgresql+asyncpg://postgres.{SUPABASE_PROJECT_ID}:{SUPABASE_PASSWORD}@aws-0-{SUPABASE_REGION}.pooler.supabase.com:6543/postgres\"\n\n# Async engine optimized for Supabase\nengine = create_async_engine(\n    SUPABASE_URL,\n    echo=True,\n    pool_size=20,\n    max_overflow=0,\n    pool_pre_ping=True,\n    pool_recycle=300,\n    connect_args={\n        \"server_settings\": {\n            \"application_name\": \"fastapi_supabase_app\",\n            \"search_path\": \"public, extensions\"\n        }\n    }\n)\n\n# Async session factory\nAsyncSessionFactory = async_sessionmaker(\n    engine,\n    class_=AsyncSession,\n    expire_on_commit=False\n)\n```\n\n### Environment-Based Configuration\nSet up flexible configuration for different environments:\n```python\n# config/database.py\nfrom pydantic_settings import BaseSettings\nfrom typing import Optional\n\nclass DatabaseSettings(BaseSettings):\n    supabase_url: str\n    supabase_key: str\n    supabase_service_key: Optional[str] = None\n    pool_size: int = 10\n    max_overflow: int = 0\n\n    class Config:\n        env_prefix = \"DB_\"\n        case_sensitive = False\n\n    @property\n    def async_url(self) -> str:\n        return self.supabase_url.replace(\"postgresql://\", \"postgresql+asyncpg://\")\n\n# Dependency injection for FastAPI\nasync def get_db_session() -> AsyncSession:\n    async with AsyncSessionFactory() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n```\n\n## Authentication Integration\n\n### Row Level Security (RLS) Integration\nHandle Supabase RLS with SQLAlchemy:\n```python\nfrom fastapi import Request, HTTPException\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nimport jwt\n\nsecurity = HTTPBearer()\n\nasync def get_supabase_user(request: Request) -> dict:\n    \"\"\"Extract and validate Supabase JWT token\"\"\"\n    authorization = request.headers.get(\"Authorization\")\n    if not authorization or not authorization.startswith(\"Bearer \"):\n        raise HTTPException(status_code=401, detail=\"Missing or invalid token\")\n\n    token = authorization.split(\" \")[1]\n    try:\n        # Decode Supabase JWT\n        payload = jwt.decode(\n            token,\n            SUPABASE_JWT_SECRET,\n            algorithms=[\"HS256\"],\n            options={\"verify_aud\": False}\n        )\n        return payload\n    except jwt.ExpiredSignatureError:\n        raise HTTPException(status_code=401, detail=\"Token expired\")\n    except jwt.InvalidTokenError:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n\nasync def get_db_with_auth(request: Request) -> AsyncSession:\n    \"\"\"Get database session with RLS context\"\"\"\n    session = AsyncSessionFactory()\n\n    # Set RLS user context\n    user = await get_supabase_user(request)\n    await session.execute(\n        text(\"SET request.jwt.claims.user_id = :user_id\"),\n        {\"user_id\": user.get(\"sub\")}\n    )\n\n    await session.execute(\n        text(\"SET request.jwt.claims.role = :role\"),\n        {\"role\": user.get(\"role\", \"authenticated\")}\n    )\n\n    return session\n```\n\n### Service Key Integration\nUse Supabase service key for admin operations:\n```python\nfrom supabase import create_client, Client\n\nclass SupabaseAdminClient:\n    def __init__(self, supabase_url: str, service_key: str):\n        self.supabase: Client = create_client(supabase_url, service_key)\n\n    async def upload_file(self, bucket: str, path: str, file_content: bytes) -> dict:\n        \"\"\"Upload file to Supabase Storage\"\"\"\n        return self.supabase.storage.from_(bucket).upload(path, file_content)\n\n    async def sign_url(self, bucket: str, path: str, expires_in: int = 3600) -> str:\n        \"\"\"Generate signed URL for file access\"\"\"\n        return self.supabase.storage.from_(bucket).create_signed_url(path, expires_in)\n\n# FastAPI dependency\nasync def get_supabase_admin() -> SupabaseAdminClient:\n    return SupabaseAdminClient(SUPABASE_URL, SUPABASE_SERVICE_KEY)\n```\n\n## Performance Optimization\n\n### Connection Pooling for Serverless\nOptimize for Supabase connection limits:\n```python\n# config/pooling.py\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom sqlalchemy.pool import QueuePool\nimport asyncio\n\nclass SupabaseEngineManager:\n    def __init__(self, supabase_url: str, max_connections: int = 20):\n        self.engine = create_async_engine(\n            supabase_url,\n            poolclass=QueuePool,\n            pool_size=max_connections - 5,  # Leave room for admin connections\n            max_overflow=5,\n            pool_pre_ping=True,\n            pool_recycle=300,  # 5 minutes\n            pool_timeout=30,\n            connect_args={\n                \"command_timeout\": 10,\n                \"server_settings\": {\n                    \"application_name\": \"fastapi_supabase_app\",\n                    \"jit\": \"off\"  # Disable JIT for serverless\n                }\n            }\n        )\n        self._background_heartbeater = None\n\n    async def start_heartbeat(self):\n        \"\"\"Keep connections alive in serverless environments\"\"\"\n        async def heartbeat():\n            while True:\n                await asyncio.sleep(240)  # 4 minutes\n                async with self.engine.connect() as conn:\n                    await conn.execute(text(\"SELECT 1\"))\n\n        self._background_heartbeater = asyncio.create_task(heartbeat())\n\n    async def stop_heartbeat(self):\n        if self._background_heartbeater:\n            self._background_heartbeater.cancel()\n            try:\n                await self._background_heartbeater\n            except asyncio.CancelledError:\n                pass\n```\n\n### Lazy Loading Implementation\nImplement efficient lazy loading for large schemas:\n```python\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select, text\nfrom typing import Type, TypeVar, Generic\nfrom pydantic import BaseModel\n\nT = TypeVar('T')\n\nclass LazyLoader(Generic[T]):\n    def __init__(self, model: Type[T], session: AsyncSession):\n        self.model = model\n        self.session = session\n        self._loaded = None\n        self._query = None\n\n    def where(self, *criteria):\n        \"\"\"Add where conditions to query\"\"\"\n        self._query = select(self.model).where(*criteria)\n        return self\n\n    async def load(self) -> list[T]:\n        \"\"\"Execute the query and cache results\"\"\"\n        if self._loaded is None:\n            if self._query is None:\n                self._query = select(self.model)\n            result = await self.session.execute(self._query)\n            self._loaded = result.scalars().all()\n        return self._loaded\n\n    async def first(self) -> T | None:\n        \"\"\"Load first result only\"\"\"\n        if self._query is None:\n            self._query = select(self.model)\n        result = await self.session.execute(self._query.limit(1))\n        return result.scalar_one_or_none()\n\n# Usage in FastAPI endpoints\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: int, session: AsyncSession = Depends(get_db_session)):\n    lazy_users = LazyLoader(User, session)\n    user = await lazy_users.where(User.id == user_id).first()\n\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    return user\n```\n\n## Model Generation\n\n### Supabase Schema Reflection\nGenerate SQLAlchemy models from Supabase schema:\n```python\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom sqlalchemy import inspect, text\nfrom sqlalchemy.orm import DeclarativeBase\nfrom typing import Dict, List\n\nasync def reflect_supabase_schema(engine: AsyncEngine, schema: str = \"public\") -> Dict[str, dict]:\n    \"\"\"Reflect Supabase database schema\"\"\"\n    async with engine.connect() as conn:\n        # Get table information\n        tables_query = text(\"\"\"\n            SELECT table_name, column_name, data_type, is_nullable, column_default\n            FROM information_schema.columns\n            WHERE table_schema = :schema\n            ORDER BY table_name, ordinal_position\n        \"\"\")\n\n        result = await conn.execute(tables_query, {\"schema\": schema})\n        columns = result.fetchall()\n\n        # Get foreign key constraints\n        fk_query = text(\"\"\"\n            SELECT\n                tc.table_name,\n                kcu.column_name,\n                ccu.table_name AS foreign_table_name,\n                ccu.column_name AS foreign_column_name\n            FROM information_schema.table_constraints tc\n            JOIN information_schema.key_column_usage kcu\n                ON tc.constraint_name = kcu.constraint_name\n            JOIN information_schema.constraint_column_usage ccu\n                ON ccu.constraint_name = tc.constraint_name\n            WHERE tc.constraint_type = 'FOREIGN KEY'\n                AND tc.table_schema = :schema\n        \"\"\")\n\n        fk_result = await conn.execute(fk_query, {\"schema\": schema})\n        foreign_keys = fk_result.fetchall()\n\n        # Process and return schema information\n        schema_info = {}\n        for table_name, column_name, data_type, is_nullable, column_default in columns:\n            if table_name not in schema_info:\n                schema_info[table_name] = {\n                    \"columns\": {},\n                    \"foreign_keys\": []\n                }\n\n            schema_info[table_name][\"columns\"][column_name] = {\n                \"type\": data_type,\n                \"nullable\": is_nullable == \"YES\",\n                \"default\": column_default\n            }\n\n        # Add foreign key information\n        for table_name, column_name, fk_table, fk_column in foreign_keys:\n            schema_info[table_name][\"foreign_keys\"].append({\n                \"column\": column_name,\n                \"references\": f\"{fk_table}.{fk_column}\"\n            })\n\n        return schema_info\n\n# Model generation\nasync def generate_sqlalchemy_models(schema_info: Dict[str, dict], base_class: DeclarativeBase) -> str:\n    \"\"\"Generate SQLAlchemy model classes from schema info\"\"\"\n    model_code = []\n\n    for table_name, table_info in schema_info.items():\n        class_name = \"\".join(word.capitalize() for word in table_name.split(\"_\"))\n\n        # Column definitions\n        columns = []\n        primary_key_columns = []\n\n        for column_name, column_info in table_info[\"columns\"]..items():\n            col_def = _generate_column_definition(column_name, column_info)\n            columns.append(col_def)\n\n            # Detect primary keys (common patterns in Supabase)\n            if column_name in [\"id\", f\"{table_name}_id\"] or column_info.get(\"default\", \"\").startswith(\"nextval\"):\n                primary_key_columns.append(column_name)\n\n        # Foreign key relationships\n        relationships = []\n        for fk in table_info[\"foreign_keys\"]:\n            fk_table, fk_column = fk[\"references\"].split(\".\")\n            fk_class_name = \"\".join(word.capitalize() for word in fk_table.split(\"_\"))\n            relationship_name = fk_table if fk_table.endswith(\"s\") else f\"{fk_table}s\"\n\n            if column_name.endswith(\"_id\"):\n                relationship_name = column_name[:-3] + (\"s\" if not column_name[:-3].endswith(\"s\") else \"\")\n\n            relationships.append(\n                f'    {relationship_name} = relationship(\"{fk_class_name}\", back_populates=\"{table_name}\")'\n            )\n\n        # Generate the complete class\n        model_class = f\"\"\"\nclass {class_name}({base_class.__name__}):\n    __tablename__ = \"{table_name}\"\n\n{chr(10).join(columns)}\n\"\"\"\n\n        if primary_key_columns:\n            pk_declaration = f\"    __table_args__ = (PrimaryKeyConstraint({', '.join(map(lambda c: f'\\\"{c}\\\"', primary_key_columns))}),)\"\n            model_class += pk_declaration + \"\\n\"\n\n        if relationships:\n            model_class += \"\\n\" + \"\\n\".join(relationships) + \"\\n\"\n\n        model_code.append(model_class)\n\n    return \"\\n\".join(model_code)\n\ndef _generate_column_definition(name: str, info: dict) -> str:\n    \"\"\"Generate SQLAlchemy column definition\"\"\"\n    type_mapping = {\n        \"text\": \"Text\",\n        \"varchar\": \"String\",\n        \"character varying\": \"String\",\n        \"integer\": \"Integer\",\n        \"bigint\": \"BigInteger\",\n        \"decimal\": \"Numeric\",\n        \"numeric\": \"Numeric\",\n        \"real\": \"Float\",\n        \"double precision\": \"Float\",\n        \"boolean\": \"Boolean\",\n        \"date\": \"Date\",\n        \"timestamp\": \"DateTime\",\n        \"timestamp with time zone\": \"DateTime(timezone=True)\",\n        \"uuid\": \"UUID\",\n        \"jsonb\": \"JSON\",\n        \"json\": \"JSON\"\n    }\n\n    sql_type = type_mapping.get(info[\"type\"].lower(), \"String\")\n\n    nullable_str = \"\" if info[\"nullable\"] else \", nullable=False\"\n    default_str = \"\"\n\n    if info[\"default\"]:\n        if info[\"default\"].startswith(\"nextval\"):\n            default_str = \", autoincrement=True\"\n        elif \"uuid_generate\" in info[\"default\"]:\n            default_str = \", server_default=text('uuid_generate_v4()')\"\n        elif \"now()\" in info[\"default\"]:\n            default_str = \", server_default=text('now()')\"\n\n    return f'    {name} = Column({sql_type}{nullable_str}{default_str})'\n```\n\n## Usage Instructions\n\nTo integrate Supabase with SQLAlchemy:\n\n1. **Configure async engine**: Set up SQLAlchemy async engine with Supabase connection string\n2. **Implement authentication**: Handle JWT tokens and RLS policies\n3. **Optimize connection pooling**: Configure for serverless environments\n4. **Generate models**: Use schema reflection to create SQLAlchemy models\n5. **Test integration**: Validate queries and authentication work correctly\n\n## Error Handling\n\n### Supabase-Specific Errors\nHandle Supabase-specific error scenarios:\n```python\nfrom sqlalchemy.exc import SQLAlchemyError, OperationalError, InterfaceError\n\nasync def handle_supabase_errors(func):\n    \"\"\"Decorator for handling Supabase-specific errors\"\"\"\n    async def wrapper(*args, **kwargs):\n        try:\n            return await func(*args, **kwargs)\n        except OperationalError as e:\n            if \"connection\" in str(e).lower():\n                # Retry connection errors\n                await asyncio.sleep(1)\n                return await func(*args, **kwargs)\n            raise\n        except SQLAlchemyError as e:\n            logger.error(f\"Supabase database error: {e}\")\n            raise\n    return wrapper\n```\n\n## Additional Resources\n\n### Reference Files\n- **`references/supabase-connection.md`** - Supabase connection configuration patterns\n- **`references/rls-integration.md`** - Row Level Security with SQLAlchemy\n- **`references/performance-optimization.md`** - Performance tuning for Supabase\n\n### Examples\n- **`examples/supabase-fastapi-setup.py`** - Complete FastAPI + Supabase + SQLAlchemy setup\n- **`examples/async-patterns.py`** - Async patterns for Supabase integration\n- **`examples/schema-generation.py`** - Automated model generation from Supabase schema"
              }
            ]
          }
        ]
      }
    }
  ]
}