{
  "owner": {
    "id": "nathan-gage",
    "display_name": "Nathan Gage",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/54559789?u=9b4523e8765f9679d4102920b5123d14f0c4fd02&v=4",
    "url": "https://github.com/nathan-gage",
    "bio": "Loading...",
    "stats": {
      "total_repos": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 1,
      "total_stars": 2,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "nathan-gage/ngage-marketplace",
      "url": "https://github.com/nathan-gage/ngage-marketplace",
      "description": "ngage's personal claude marketplace",
      "homepage": null,
      "signals": {
        "stars": 2,
        "forks": 0,
        "pushed_at": "2025-12-30T22:44:00Z",
        "created_at": "2025-12-30T22:08:42Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 405
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 584
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/react",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/react/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/react/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 115
        },
        {
          "path": "plugins/react/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/react/skills/react-compositional",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/react/skills/react-compositional/SKILL.md",
          "type": "blob",
          "size": 9111
        },
        {
          "path": "plugins/react/skills/react-compositional/assets",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/react/skills/react-compositional/assets/select-component-template.tsx",
          "type": "blob",
          "size": 8370
        },
        {
          "path": "plugins/react/skills/react-compositional/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/react/skills/react-compositional/references/compositional-patterns.md",
          "type": "blob",
          "size": 7369
        },
        {
          "path": "plugins/react/skills/react-compositional/references/react-query-patterns.md",
          "type": "blob",
          "size": 4274
        }
      ],
      "marketplace": {
        "name": "ngage-marketplace",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "Nathan Gage",
          "email": "contract@nathangage.co"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "react",
            "description": "ngage's collection of helpful React related skills",
            "source": "./plugins/react",
            "category": null,
            "version": "0.1.0",
            "author": null,
            "install_commands": [
              "/plugin marketplace add nathan-gage/ngage-marketplace",
              "/plugin install react@ngage-marketplace"
            ],
            "signals": {
              "stars": 2,
              "forks": 0,
              "pushed_at": "2025-12-30T22:44:00Z",
              "created_at": "2025-12-30T22:08:42Z",
              "license": null
            },
            "commands": [],
            "skills": [
              {
                "name": "react-compositional",
                "description": "Create functional, compositional React components using headless UI patterns with decoupled state management. Use when building React components that need: (1) Composition over complex prop APIs, (2) Separation of logic from presentation (headless patterns), (3) Pure, idempotent rendering, (4) Compound component APIs, (5) Integration with react-query for server state, or (6) Support for both controlled and uncontrolled patterns. Ideal for building flexible, reusable component libraries and data-driven UIs.",
                "path": "plugins/react/skills/react-compositional/SKILL.md",
                "frontmatter": {
                  "name": "react-compositional",
                  "description": "Create functional, compositional React components using headless UI patterns with decoupled state management. Use when building React components that need: (1) Composition over complex prop APIs, (2) Separation of logic from presentation (headless patterns), (3) Pure, idempotent rendering, (4) Compound component APIs, (5) Integration with react-query for server state, or (6) Support for both controlled and uncontrolled patterns. Ideal for building flexible, reusable component libraries and data-driven UIs."
                },
                "content": "# React Compositional Components\n\nBuild functional, compositional React components following headless UI patterns with proper state separation and react-query integration.\n\n## Core Workflow\n\nWhen creating compositional components:\n\n1. **Identify state types** - Separate UI state from server state\n2. **Extract logic to hooks** - Create headless hooks for reusable logic  \n3. **Design composition API** - Plan how components combine (compound, slots, render props)\n4. **Implement pure components** - Ensure idempotency and no side effects in render\n5. **Integrate react-query** - Add server state management where needed\n6. **Support both patterns** - Allow controlled and uncontrolled usage\n\n## State Management Strategy\n\n### UI State vs Server State\n\n**UI State** (component-local):\n- Modal open/closed\n- Selected tab\n- Highlighted index\n- Form draft values\n- Use: `useState`, `useReducer`, context\n\n**Server State** (react-query):\n- User data from API\n- Product listings\n- Search results\n- Posted form submissions\n- Use: `useQuery`, `useMutation`, `useInfiniteQuery`\n\nKeep these concerns strictly separated.\n\n## Design Patterns\n\n### Choose the Right Pattern\n\n**Compound Components** - When sub-components work together:\n```typescript\n<Tabs>\n  <Tabs.List>\n    <Tabs.Tab value=\"a\">Tab A</Tabs.Tab>\n  </Tabs.List>\n  <Tabs.Panel value=\"a\">Content A</Tabs.Panel>\n</Tabs>\n```\n\n**Render Props** - When consumers need full control:\n```typescript\n<DataList data={users}>\n  {(user) => <UserCard user={user} />}\n</DataList>\n```\n\n**Headless Hook** - When logic is reusable without UI:\n```typescript\nconst { isOpen, toggle } = useDisclosure();\n```\n\n### Implementation Guidelines\n\n**Create Context for Compound Components:**\n```typescript\nconst Context = createContext<ContextValue | null>(null);\n\nfunction useComponentContext() {\n  const ctx = useContext(Context);\n  if (!ctx) throw new Error('Must use within Parent');\n  return ctx;\n}\n```\n\n**Extract Headless Logic:**\n```typescript\nfunction useComponentLogic(props) {\n  // All stateful logic here\n  return { state, actions };\n}\n\nfunction Component(props) {\n  const logic = useComponentLogic(props);\n  return <UI {...logic} />;\n}\n```\n\n**Support Controlled/Uncontrolled:**\n```typescript\nfunction Component({ value, defaultValue, onChange }) {\n  const [internal, setInternal] = useState(defaultValue);\n  const isControlled = value !== undefined;\n  const current = isControlled ? value : internal;\n  \n  const handleChange = (newValue) => {\n    if (!isControlled) setInternal(newValue);\n    onChange?.(newValue);\n  };\n  \n  return <input value={current} onChange={handleChange} />;\n}\n```\n\n## React Query Integration\n\n### Query Hooks\n\nCreate custom hooks that encapsulate queries:\n\n```typescript\nexport function useUserList() {\n  return useQuery({\n    queryKey: ['users', 'list'],\n    queryFn: fetchUsers,\n  });\n}\n```\n\n### Query Key Factories\n\nOrganize keys consistently:\n\n```typescript\nconst userKeys = {\n  all: ['users'] as const,\n  lists: () => [...userKeys.all, 'list'] as const,\n  detail: (id: string) => [...userKeys.all, 'detail', id] as const,\n};\n```\n\n### Composition with Queries\n\nSeparate data fetching from presentation:\n\n```typescript\nfunction UserList() {\n  const { data, isLoading, error } = useUserList();\n  \n  if (isLoading) return <Spinner />;\n  if (error) return <Error error={error} />;\n  \n  return (\n    <List>\n      {data.map(user => <UserItem key={user.id} user={user} />)}\n    </List>\n  );\n}\n```\n\n### Mutations with Optimistic Updates\n\nUse immutable patterns for optimistic updates:\n\n```typescript\nconst mutation = useMutation({\n  mutationFn: updateUser,\n  onMutate: async (updated) => {\n    await queryClient.cancelQueries({ queryKey: userKeys.detail(updated.id) });\n    const previous = queryClient.getQueryData(userKeys.detail(updated.id));\n    queryClient.setQueryData(userKeys.detail(updated.id), updated);\n    return { previous };\n  },\n  onError: (err, updated, context) => {\n    queryClient.setQueryData(userKeys.detail(updated.id), context?.previous);\n  },\n  onSettled: (data) => {\n    queryClient.invalidateQueries({ queryKey: userKeys.detail(data.id) });\n  },\n});\n```\n\n## Pure Component Requirements\n\n### Idempotency\n\nSame props must always produce same output:\n\n```typescript\n// Pure - always renders same output for same input\nfunction UserCard({ user }: { user: User }) {\n  return <div>{user.name}</div>;\n}\n\n// Impure - side effects in render\nfunction ImpureCard({ user }: { user: User }) {\n  trackEvent('card_viewed'); // DON'T DO THIS\n  return <div>{user.name}</div>;\n}\n\n// Fixed - side effects in useEffect\nfunction PureCard({ user }: { user: User }) {\n  useEffect(() => {\n    trackEvent('card_viewed');\n  }, [user.id]);\n  \n  return <div>{user.name}</div>;\n}\n```\n\n### Avoid Mutations\n\nNever mutate props or state directly:\n\n```typescript\n// Bad - mutates prop\nfunction BadList({ items }: { items: Item[] }) {\n  items.sort(); // Mutates!\n  return <ul>{items.map(item => <li>{item.name}</li>)}</ul>;\n}\n\n// Good - creates new array\nfunction GoodList({ items }: { items: Item[] }) {\n  const sorted = [...items].sort();\n  return <ul>{sorted.map(item => <li>{item.name}</li>)}</ul>;\n}\n```\n\n## TypeScript Typing\n\n### Props Interfaces\n\nUse clear, specific types:\n\n```typescript\ninterface SelectProps {\n  value?: string;\n  defaultValue?: string;\n  onChange?: (value: string) => void;\n  children: React.ReactNode;\n  disabled?: boolean;\n}\n```\n\n### Context Typing\n\nAlways type context values:\n\n```typescript\ninterface ContextValue {\n  state: State;\n  actions: Actions;\n}\n\nconst Context = createContext<ContextValue | null>(null);\n```\n\n### Generic Components\n\nSupport generic types when needed:\n\n```typescript\ninterface ListProps<T> {\n  items: T[];\n  renderItem: (item: T) => React.ReactNode;\n  keyExtractor: (item: T) => string;\n}\n\nfunction List<T>({ items, renderItem, keyExtractor }: ListProps<T>) {\n  return (\n    <ul>\n      {items.map(item => (\n        <li key={keyExtractor(item)}>{renderItem(item)}</li>\n      ))}\n    </ul>\n  );\n}\n```\n\n## Detailed References\n\nFor comprehensive patterns and examples:\n\n- **Compositional patterns** - See `references/compositional-patterns.md` for headless UI patterns, compound components, render props, slots, and purity guidelines\n- **React Query integration** - See `references/react-query-patterns.md` for query organization, mutations, infinite queries, and error handling\n- **Complete example** - See `assets/select-component-template.tsx` for a fully-implemented compositional select component demonstrating all patterns\n\n## Common Patterns\n\n### Data List with Infinite Scroll\n\n```typescript\nfunction UserList() {\n  const {\n    data,\n    fetchNextPage,\n    hasNextPage,\n    isFetchingNextPage,\n  } = useInfiniteQuery({\n    queryKey: ['users'],\n    queryFn: ({ pageParam = 0 }) => fetchUsers(pageParam),\n    getNextPageParam: (lastPage) => lastPage.nextCursor,\n    initialPageParam: 0,\n  });\n\n  return (\n    <>\n      {data?.pages.flatMap(page => page.users).map(user => (\n        <UserCard key={user.id} user={user} />\n      ))}\n      {hasNextPage && (\n        <button onClick={() => fetchNextPage()} disabled={isFetchingNextPage}>\n          Load More\n        </button>\n      )}\n    </>\n  );\n}\n```\n\n### Dependent Queries\n\n```typescript\nfunction UserProfile({ userId }: { userId: string }) {\n  const { data: user } = useQuery({\n    queryKey: ['user', userId],\n    queryFn: () => fetchUser(userId),\n  });\n\n  const { data: posts } = useQuery({\n    queryKey: ['posts', userId],\n    queryFn: () => fetchPosts(userId),\n    enabled: !!user, // Only fetch when user exists\n  });\n\n  if (!user) return <Spinner />;\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      {posts?.map(post => <PostCard key={post.id} post={post} />)}\n    </div>\n  );\n}\n```\n\n### Error Boundaries\n\nAlways wrap components with error boundaries:\n\n```typescript\n<ErrorBoundary fallback={<ErrorFallback />}>\n  <Suspense fallback={<LoadingSpinner />}>\n    <ComponentThatMightFail />\n  </Suspense>\n</ErrorBoundary>\n```\n\n## Checklist\n\nBefore considering a component complete:\n\n- [ ] Separated UI state from server state\n- [ ] Extracted reusable logic to hooks\n- [ ] Components are pure (no side effects in render)\n- [ ] No prop mutations or direct state mutations\n- [ ] Proper TypeScript types throughout\n- [ ] Supports both controlled and uncontrolled (where applicable)\n- [ ] React Query queries use consistent key factories\n- [ ] Mutations handle optimistic updates correctly\n- [ ] Error boundaries and suspense boundaries in place\n- [ ] Accessibility attributes (ARIA) included"
              }
            ]
          }
        ]
      }
    }
  ]
}