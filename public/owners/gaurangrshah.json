{
  "owner": {
    "id": "gaurangrshah",
    "display_name": "gshah2020",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/1086269?u=ad12da0c6cc72b90196e8416f08eb0bd23fea769&v=4",
    "url": "https://github.com/gaurangrshah",
    "bio": "/* ... */",
    "stats": {
      "total_repos": 1,
      "total_plugins": 5,
      "total_commands": 21,
      "total_skills": 0,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "gaurangrshah/gsc-plugins",
      "url": "https://github.com/gaurangrshah/gsc-plugins",
      "description": "Claude Code plugins: webgen, worklog, taskflow",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-12T03:40:00Z",
        "created_at": "2025-12-13T22:09:06Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1824
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 237
        },
        {
          "path": "CLAUDE.md",
          "type": "blob",
          "size": 6336
        },
        {
          "path": "CONTRIBUTING.md",
          "type": "blob",
          "size": 4083
        },
        {
          "path": "ECOSYSTEM.md",
          "type": "blob",
          "size": 8701
        },
        {
          "path": "LICENSE",
          "type": "blob",
          "size": 1059
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 18785
        },
        {
          "path": "TASKFLOW-WEBGEN-INTEGRATION-SUMMARY.md",
          "type": "blob",
          "size": 10575
        },
        {
          "path": "_build",
          "type": "tree",
          "size": null
        },
        {
          "path": "_build/frameworks",
          "type": "tree",
          "size": null
        },
        {
          "path": "_build/frameworks/api-pattern.md",
          "type": "blob",
          "size": 6371
        },
        {
          "path": "_build/frameworks/auth-strategy.md",
          "type": "blob",
          "size": 8216
        },
        {
          "path": "_build/frameworks/database-selection.md",
          "type": "blob",
          "size": 7087
        },
        {
          "path": "_build/frameworks/framework-selection.md",
          "type": "blob",
          "size": 4801
        },
        {
          "path": "_build/inline-templates.sh",
          "type": "blob",
          "size": 8068
        },
        {
          "path": "_build/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "_build/templates/api-design.md",
          "type": "blob",
          "size": 3495
        },
        {
          "path": "_build/templates/code-review-template.md",
          "type": "blob",
          "size": 2622
        },
        {
          "path": "_build/templates/database-design.md",
          "type": "blob",
          "size": 3299
        },
        {
          "path": "_build/templates/deployment-guide.md",
          "type": "blob",
          "size": 3975
        },
        {
          "path": "_build/templates/orchestration-protocol.md",
          "type": "blob",
          "size": 2618
        },
        {
          "path": "_build/templates/setup-guide.md",
          "type": "blob",
          "size": 3483
        },
        {
          "path": "_build/templates/tech-stack-decision.md",
          "type": "blob",
          "size": 2794
        },
        {
          "path": "_build/templates/testing-guide.md",
          "type": "blob",
          "size": 5120
        },
        {
          "path": "docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/PROPOSED-ADDITIONS.md",
          "type": "blob",
          "size": 6237
        },
        {
          "path": "docs/local-md-schema.md",
          "type": "blob",
          "size": 7213
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/appgen",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/appgen/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/appgen/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 667
        },
        {
          "path": "plugins/appgen/README.md",
          "type": "blob",
          "size": 17399
        },
        {
          "path": "plugins/appgen/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/appgen/agents/appgen-code-reviewer.md",
          "type": "blob",
          "size": 3996
        },
        {
          "path": "plugins/appgen/agents/appgen-orchestrator.md",
          "type": "blob",
          "size": 9684
        },
        {
          "path": "plugins/appgen/agents/appgen.md",
          "type": "blob",
          "size": 7743
        },
        {
          "path": "plugins/appgen/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/appgen/commands/appgen.md",
          "type": "blob",
          "size": 4678
        },
        {
          "path": "plugins/appgen/docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/appgen/docs/ARCHITECTURE.md",
          "type": "blob",
          "size": 13870
        },
        {
          "path": "plugins/appgen/docs/CHANGELOG.md",
          "type": "blob",
          "size": 5251
        },
        {
          "path": "plugins/appgen/docs/DECISIONS.md",
          "type": "blob",
          "size": 8189
        },
        {
          "path": "plugins/appgen/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/appgen/skills/api-design",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/appgen/skills/api-design/skill.md",
          "type": "blob",
          "size": 10730
        },
        {
          "path": "plugins/appgen/skills/asset-management",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/appgen/skills/asset-management/skill.md",
          "type": "blob",
          "size": 12989
        },
        {
          "path": "plugins/appgen/skills/auth-integration",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/appgen/skills/auth-integration/skill.md",
          "type": "blob",
          "size": 11478
        },
        {
          "path": "plugins/appgen/skills/database-design",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/appgen/skills/database-design/skill.md",
          "type": "blob",
          "size": 10336
        },
        {
          "path": "plugins/appgen/skills/project-scaffold",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/appgen/skills/project-scaffold/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/appgen/skills/project-scaffold/scripts/setup-api-only.sh",
          "type": "blob",
          "size": 6014
        },
        {
          "path": "plugins/appgen/skills/project-scaffold/scripts/setup-monorepo.sh",
          "type": "blob",
          "size": 2668
        },
        {
          "path": "plugins/appgen/skills/project-scaffold/scripts/setup-nextjs-app.sh",
          "type": "blob",
          "size": 3483
        },
        {
          "path": "plugins/appgen/skills/project-scaffold/skill.md",
          "type": "blob",
          "size": 7648
        },
        {
          "path": "plugins/appgen/skills/taskflow-integration",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/appgen/skills/taskflow-integration/skill.md",
          "type": "blob",
          "size": 12622
        },
        {
          "path": "plugins/appgen/skills/worktree-workflow",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/appgen/skills/worktree-workflow/skill.md",
          "type": "blob",
          "size": 6875
        },
        {
          "path": "plugins/docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/docs/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/docs/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 649
        },
        {
          "path": "plugins/docs/README.md",
          "type": "blob",
          "size": 4916
        },
        {
          "path": "plugins/docs/_core",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/docs/_core/config-loader.md",
          "type": "blob",
          "size": 7701
        },
        {
          "path": "plugins/docs/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/docs/commands/docs-init.md",
          "type": "blob",
          "size": 9529
        },
        {
          "path": "plugins/docs/commands/docs-reconcile.md",
          "type": "blob",
          "size": 3290
        },
        {
          "path": "plugins/docs/commands/docs-validate.md",
          "type": "blob",
          "size": 2757
        },
        {
          "path": "plugins/docs/docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/docs/docs/usage.md",
          "type": "blob",
          "size": 1650
        },
        {
          "path": "plugins/docs/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/docs/skills/docs-manager",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/docs/skills/docs-manager/skill.md",
          "type": "blob",
          "size": 22434
        },
        {
          "path": "plugins/docs/skills/docs-validator",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/docs/skills/docs-validator/skill.md",
          "type": "blob",
          "size": 11646
        },
        {
          "path": "plugins/docs/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/docs/templates/frontmatter-schema.md",
          "type": "blob",
          "size": 2541
        },
        {
          "path": "plugins/docs/templates/guide-template.md",
          "type": "blob",
          "size": 958
        },
        {
          "path": "plugins/taskflow",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/taskflow/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/taskflow/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 694
        },
        {
          "path": "plugins/taskflow/README.md",
          "type": "blob",
          "size": 10108
        },
        {
          "path": "plugins/taskflow/_core",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/taskflow/_core/backend-interface.md",
          "type": "blob",
          "size": 10973
        },
        {
          "path": "plugins/taskflow/_core/backend-loader.md",
          "type": "blob",
          "size": 17417
        },
        {
          "path": "plugins/taskflow/_core/backends",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/taskflow/_core/backends/github.md",
          "type": "blob",
          "size": 16029
        },
        {
          "path": "plugins/taskflow/_core/backends/local.md",
          "type": "blob",
          "size": 11480
        },
        {
          "path": "plugins/taskflow/_core/backends/plane.md",
          "type": "blob",
          "size": 15248
        },
        {
          "path": "plugins/taskflow/_core/command-preamble.md",
          "type": "blob",
          "size": 2810
        },
        {
          "path": "plugins/taskflow/_core/epic-strategy.md",
          "type": "blob",
          "size": 8968
        },
        {
          "path": "plugins/taskflow/_core/task-hygiene.md",
          "type": "blob",
          "size": 9715
        },
        {
          "path": "plugins/taskflow/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/taskflow/commands/task-add.md",
          "type": "blob",
          "size": 6464
        },
        {
          "path": "plugins/taskflow/commands/task-expand.md",
          "type": "blob",
          "size": 6983
        },
        {
          "path": "plugins/taskflow/commands/task-init.md",
          "type": "blob",
          "size": 7802
        },
        {
          "path": "plugins/taskflow/commands/task-list.md",
          "type": "blob",
          "size": 2504
        },
        {
          "path": "plugins/taskflow/commands/task-migrate-config.md",
          "type": "blob",
          "size": 11752
        },
        {
          "path": "plugins/taskflow/commands/task-next.md",
          "type": "blob",
          "size": 19274
        },
        {
          "path": "plugins/taskflow/commands/task-parse.md",
          "type": "blob",
          "size": 16707
        },
        {
          "path": "plugins/taskflow/commands/task-show.md",
          "type": "blob",
          "size": 9068
        },
        {
          "path": "plugins/taskflow/commands/task-status.md",
          "type": "blob",
          "size": 6138
        },
        {
          "path": "plugins/taskflow/commands/task-tag.md",
          "type": "blob",
          "size": 8764
        },
        {
          "path": "plugins/taskflow/commands/task.md",
          "type": "blob",
          "size": 8546
        },
        {
          "path": "plugins/taskflow/config",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/taskflow/config/default-config.json",
          "type": "blob",
          "size": 433
        },
        {
          "path": "plugins/taskflow/docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/taskflow/docs/design.md",
          "type": "blob",
          "size": 17103
        },
        {
          "path": "plugins/taskflow/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/taskflow/skills/task-setup",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/taskflow/skills/task-setup/skill.md",
          "type": "blob",
          "size": 13780
        },
        {
          "path": "plugins/webgen",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/webgen/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/webgen/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 676
        },
        {
          "path": "plugins/webgen/README.md",
          "type": "blob",
          "size": 25897
        },
        {
          "path": "plugins/webgen/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/webgen/agents/webgen-code-reviewer.md",
          "type": "blob",
          "size": 3627
        },
        {
          "path": "plugins/webgen/agents/webgen-orchestrator.md",
          "type": "blob",
          "size": 9089
        },
        {
          "path": "plugins/webgen/agents/webgen.md",
          "type": "blob",
          "size": 6958
        },
        {
          "path": "plugins/webgen/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/webgen/commands/webgen.md",
          "type": "blob",
          "size": 4439
        },
        {
          "path": "plugins/webgen/docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/webgen/docs/ARCHITECTURE.md",
          "type": "blob",
          "size": 27166
        },
        {
          "path": "plugins/webgen/docs/ASSET-MANAGEMENT-INTEGRATION.md",
          "type": "blob",
          "size": 12003
        },
        {
          "path": "plugins/webgen/docs/CHANGELOG.md",
          "type": "blob",
          "size": 7340
        },
        {
          "path": "plugins/webgen/docs/DECISIONS.md",
          "type": "blob",
          "size": 10426
        },
        {
          "path": "plugins/webgen/docs/LEARNINGS.md",
          "type": "blob",
          "size": 5453
        },
        {
          "path": "plugins/webgen/docs/TASKFLOW-INTEGRATION.md",
          "type": "blob",
          "size": 9846
        },
        {
          "path": "plugins/webgen/docs/TASKFLOW-QUICK-REFERENCE.md",
          "type": "blob",
          "size": 5298
        },
        {
          "path": "plugins/webgen/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/webgen/skills/asset-management",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/webgen/skills/asset-management/skill.md",
          "type": "blob",
          "size": 12989
        },
        {
          "path": "plugins/webgen/skills/design-system",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/webgen/skills/design-system/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/webgen/skills/design-system/references/shadcn.md",
          "type": "blob",
          "size": 13528
        },
        {
          "path": "plugins/webgen/skills/design-system/skill.md",
          "type": "blob",
          "size": 7437
        },
        {
          "path": "plugins/webgen/skills/project-scaffold",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/webgen/skills/project-scaffold/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/webgen/skills/project-scaffold/scripts/setup-astro.sh",
          "type": "blob",
          "size": 7338
        },
        {
          "path": "plugins/webgen/skills/project-scaffold/scripts/setup-next.sh",
          "type": "blob",
          "size": 6878
        },
        {
          "path": "plugins/webgen/skills/project-scaffold/scripts/setup-vite.sh",
          "type": "blob",
          "size": 6736
        },
        {
          "path": "plugins/webgen/skills/project-scaffold/skill.md",
          "type": "blob",
          "size": 4765
        },
        {
          "path": "plugins/webgen/skills/taskflow-integration",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/webgen/skills/taskflow-integration/skill.md",
          "type": "blob",
          "size": 12622
        },
        {
          "path": "plugins/webgen/skills/worktree-workflow",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/webgen/skills/worktree-workflow/skill.md",
          "type": "blob",
          "size": 6875
        },
        {
          "path": "plugins/worklog",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/worklog/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/worklog/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 793
        },
        {
          "path": "plugins/worklog/.mcp.json",
          "type": "blob",
          "size": 255
        },
        {
          "path": "plugins/worklog/README.md",
          "type": "blob",
          "size": 30013
        },
        {
          "path": "plugins/worklog/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/worklog/agents/kb-curator.md",
          "type": "blob",
          "size": 9394
        },
        {
          "path": "plugins/worklog/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/worklog/commands/worklog-configure.md",
          "type": "blob",
          "size": 4301
        },
        {
          "path": "plugins/worklog/commands/worklog-connect.md",
          "type": "blob",
          "size": 5100
        },
        {
          "path": "plugins/worklog/commands/worklog-init.md",
          "type": "blob",
          "size": 11531
        },
        {
          "path": "plugins/worklog/commands/worklog-setup-mcp.md",
          "type": "blob",
          "size": 4829
        },
        {
          "path": "plugins/worklog/commands/worklog-status.md",
          "type": "blob",
          "size": 3912
        },
        {
          "path": "plugins/worklog/docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/worklog/docs/network-protocol.md",
          "type": "blob",
          "size": 4797
        },
        {
          "path": "plugins/worklog/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/worklog/hooks/post-tool-use.md",
          "type": "blob",
          "size": 12651
        },
        {
          "path": "plugins/worklog/hooks/session-start.md",
          "type": "blob",
          "size": 9722
        },
        {
          "path": "plugins/worklog/hooks/session-stop.md",
          "type": "blob",
          "size": 12066
        },
        {
          "path": "plugins/worklog/mcp",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/worklog/mcp/.env.example",
          "type": "blob",
          "size": 125
        },
        {
          "path": "plugins/worklog/mcp/.gitignore",
          "type": "blob",
          "size": 358
        },
        {
          "path": "plugins/worklog/mcp/README.md",
          "type": "blob",
          "size": 2625
        },
        {
          "path": "plugins/worklog/mcp/pyproject.toml",
          "type": "blob",
          "size": 1208
        },
        {
          "path": "plugins/worklog/mcp/src",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/worklog/mcp/src/worklog_mcp",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/worklog/mcp/src/worklog_mcp/__init__.py",
          "type": "blob",
          "size": 162
        },
        {
          "path": "plugins/worklog/mcp/src/worklog_mcp/__main__.py",
          "type": "blob",
          "size": 131
        },
        {
          "path": "plugins/worklog/mcp/src/worklog_mcp/config.py",
          "type": "blob",
          "size": 6156
        },
        {
          "path": "plugins/worklog/mcp/src/worklog_mcp/database.py",
          "type": "blob",
          "size": 12559
        },
        {
          "path": "plugins/worklog/mcp/src/worklog_mcp/server.py",
          "type": "blob",
          "size": 91700
        },
        {
          "path": "plugins/worklog/mcp/src/worklog_mcp/tools",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/worklog/mcp/src/worklog_mcp/tools/__init__.py",
          "type": "blob",
          "size": 78
        },
        {
          "path": "plugins/worklog/mcp/tests",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/worklog/mcp/tests/__init__.py",
          "type": "blob",
          "size": 36
        },
        {
          "path": "plugins/worklog/mcp/tests/test_tools.py",
          "type": "blob",
          "size": 6542
        },
        {
          "path": "plugins/worklog/schema",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/worklog/schema/core.sql",
          "type": "blob",
          "size": 4755
        },
        {
          "path": "plugins/worklog/schema/domain-agency.sql",
          "type": "blob",
          "size": 2323
        },
        {
          "path": "plugins/worklog/schema/extended.sql",
          "type": "blob",
          "size": 4268
        },
        {
          "path": "plugins/worklog/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/worklog/scripts/detect-python-env.sh",
          "type": "blob",
          "size": 7389
        },
        {
          "path": "plugins/worklog/scripts/setup-mcp-venv.sh",
          "type": "blob",
          "size": 3450
        },
        {
          "path": "plugins/worklog/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/worklog/skills/curate",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/worklog/skills/curate/skill.md",
          "type": "blob",
          "size": 12573
        },
        {
          "path": "plugins/worklog/skills/memory-recall",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/worklog/skills/memory-recall/skill.md",
          "type": "blob",
          "size": 6884
        },
        {
          "path": "plugins/worklog/skills/memory-store",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/worklog/skills/memory-store/skill.md",
          "type": "blob",
          "size": 7306
        },
        {
          "path": "plugins/worklog/skills/memory-sync",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/worklog/skills/memory-sync/skill.md",
          "type": "blob",
          "size": 12301
        },
        {
          "path": "plugins/worklog/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/worklog/templates/full.md",
          "type": "blob",
          "size": 4687
        },
        {
          "path": "plugins/worklog/templates/minimal.md",
          "type": "blob",
          "size": 1320
        },
        {
          "path": "plugins/worklog/templates/standard.md",
          "type": "blob",
          "size": 2759
        },
        {
          "path": "plugins/worklog/worklog-viewer",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/worklog/worklog-viewer/README.md",
          "type": "blob",
          "size": 4894
        },
        {
          "path": "plugins/worklog/worklog-viewer/index.html",
          "type": "blob",
          "size": 59768
        },
        {
          "path": "verify-taskflow-integration.sh",
          "type": "blob",
          "size": 3432
        }
      ],
      "marketplace": {
        "name": "gsc-plugins",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "gs",
          "email": "gaurang.r.shah@gmail.com"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "webgen",
            "description": "Transform natural language descriptions into complete, production-ready web projects",
            "source": "./plugins/webgen",
            "category": null,
            "version": "1.6.0",
            "author": null,
            "install_commands": [
              "/plugin marketplace add gaurangrshah/gsc-plugins",
              "/plugin install webgen@gsc-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-12T03:40:00Z",
              "created_at": "2025-12-13T22:09:06Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/webgen",
                "description": "Generate websites, components, or features from natural language",
                "path": "plugins/webgen/commands/webgen.md",
                "frontmatter": {
                  "description": "Generate websites, components, or features from natural language",
                  "arguments": [
                    {
                      "name": "description",
                      "description": "What to generate (e.g., \"restaurant landing page\", \"pricing component\")",
                      "required": false
                    }
                  ]
                },
                "content": "# WebGen Command\n\nGenerate web projects from natural language descriptions with orchestrated quality control.\n\n## Usage\n\n```\n/webgen [description]\n```\n\n## Examples\n\n```\n/webgen restaurant landing page for Bistro Bliss\n/webgen portfolio site for a freelance designer\n/webgen pricing component with 3 tiers\n/webgen multi-page healthcare site for Clarity Health\n/webgen                  # Interactive mode - will ask questions\n```\n\n## Configuration\n\n### Output Directory\n\nProjects are created in a configurable location:\n\n| Variable | Default | Description |\n|----------|---------|-------------|\n| `WEBGEN_OUTPUT_DIR` | `./webgen-projects` | Base directory for generated projects |\n\nSet via environment variable or the orchestrator will use the default.\n\n### Database (Optional)\n\n| Variable | Default | Description |\n|----------|---------|-------------|\n| `WEBGEN_DB_PATH` | *(empty)* | SQLite for cross-session learning. Empty = disabled |\n\n---\n\n## Orchestrated Workflow\n\nWebGen uses **@webgen-orchestrator** as Product Manager to ensure quality at every phase:\n\n```\nUser Request\n    ↓\n┌─────────────────────────────────────┐\n│   @webgen-orchestrator (PM Agent)   │\n│  Validates requirements, approves   │\n│  each phase, manages iterations     │\n└─────────────────────────────────────┘\n    ↓\n[Checkpoint 1: Requirements]\nPM validates scope and requirements\n    ↓\n[Checkpoint 2: Research Review]\nPM reviews competitive analysis\n    ↓\n[Checkpoint 3: Architecture Review]\nPM reviews structure and tech stack\n    ↓\n[Checkpoint 4: Code Review]\n@webgen-code-reviewer validates implementation\n    ↓\n[Checkpoint 4.5: Legal Pages]\n(Conditional - if applicable)\n    ↓\n[Checkpoint 5: Final Sign-off]\nPM confirms all requirements met\n    ↓\nDone\n```\n\n## Key Features\n\n- **PM Orchestration:** Every phase reviewed before proceeding\n- **Quality Gates:** 2-iteration max per phase, then escalates to user\n- **Configurable Output:** Projects go to `{WEBGEN_OUTPUT_DIR}/{slug} - webgen/`\n- **Competitive Research:** Saves competitor analysis to `research/` folder\n- **Comprehensive Documentation:** README, design decisions, asset sources\n- **Screenshot Capture:** Saves preview to docs/screenshots/preview.png\n- **Accessibility Baseline:** WCAG 2.1 AA compliance\n- **Performance Targets:** Documents Lighthouse and bundle size goals\n- **Legal Pages:** Industry-specific privacy, terms, disclosures with disclaimers\n- **Signed Work:** All commits include webgen v1.4 signature\n- **Feature Branches:** Uses git feature branch workflow\n- **Testing:** Automatic test setup for API/server projects\n- **Template Promotion:** Offers to save successful projects as reusable templates\n\n## Bundled Agents\n\nThis plugin includes all required agents:\n\n| Agent | Purpose |\n|-------|---------|\n| `@webgen` | Core website generation agent |\n| `@webgen-orchestrator` | PM coordination and quality gates |\n| `@webgen-code-reviewer` | Code quality and accessibility validation |\n\nNo external agent dependencies required.\n\n## Invoke Orchestrator\n\nThis command invokes the **@webgen-orchestrator** agent to manage the workflow.\n\nThe orchestrator will:\n1. Validate requirements with user (Checkpoint 1)\n2. Dispatch @webgen for research phase, then review (Checkpoint 2)\n3. Dispatch @webgen for scaffold phase, then review (Checkpoint 3)\n4. Dispatch @webgen for code generation, dispatch @webgen-code-reviewer (Checkpoint 4)\n5. Dispatch @webgen for legal pages if applicable (Checkpoint 4.5)\n6. Final sign-off confirming all requirements met (Checkpoint 5)\n\n**Orchestration Context:**\n\n```\nDomain: webgen\nCreator Agent: @webgen\nReviewer Agent: @webgen-code-reviewer\nOrchestrator: @webgen-orchestrator\nPhases: requirements → research → architecture → implementation → legal → final\nOutput: ${WEBGEN_OUTPUT_DIR:-./webgen-projects}/{project-slug} - webgen/\nPreferences: ${WEBGEN_OUTPUT_DIR:-./webgen-projects}/preferences.md (optional)\nDatabase: ${WEBGEN_DB_PATH} (optional, empty = disabled)\nMax Iterations: 2 per phase (then escalate to user)\n```\n\n$ARGUMENTS"
              }
            ],
            "skills": []
          },
          {
            "name": "appgen",
            "description": "Generate full-stack applications and APIs from natural language descriptions",
            "source": "./plugins/appgen",
            "category": null,
            "version": "1.1.0",
            "author": null,
            "install_commands": [
              "/plugin marketplace add gaurangrshah/gsc-plugins",
              "/plugin install appgen@gsc-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-12T03:40:00Z",
              "created_at": "2025-12-13T22:09:06Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/appgen",
                "description": "Generate full-stack applications and APIs from natural language",
                "path": "plugins/appgen/commands/appgen.md",
                "frontmatter": {
                  "description": "Generate full-stack applications and APIs from natural language",
                  "arguments": [
                    {
                      "name": "description",
                      "description": "What application to build (e.g., \"inventory management system\", \"REST API for a blog\")",
                      "required": false
                    }
                  ]
                },
                "content": "# AppGen Command\n\nGenerate full-stack applications and APIs from natural language descriptions with orchestrated quality control.\n\n## Usage\n\n```\n/appgen [description]\n```\n\n## Examples\n\n```\n/appgen inventory management system for a warehouse\n/appgen REST API for a blog with auth and comments\n/appgen SaaS dashboard for subscription management\n/appgen task tracking app with teams and notifications\n/appgen e-commerce backend with Stripe integration\n/appgen                  # Interactive mode - will ask questions\n```\n\n## Configuration\n\n### Output Directory\n\nProjects are created in a configurable location:\n\n| Variable | Default | Description |\n|----------|---------|-------------|\n| `APPGEN_OUTPUT_DIR` | `~/projects/appgen` | Base directory for generated applications |\n\nSet via environment variable or the orchestrator will use the default.\n\n### Database (Optional)\n\n| Variable | Default | Description |\n|----------|---------|-------------|\n| `APPGEN_DB_PATH` | *(empty)* | SQLite for cross-session learning. Empty = disabled |\n\n---\n\n## Orchestrated Workflow\n\nAppGen uses **@appgen-orchestrator** as Product Manager to ensure quality at every phase:\n\n```\nUser Request\n    ↓\n┌─────────────────────────────────────┐\n│  @appgen-orchestrator (PM Agent)    │\n│  Validates requirements, approves   │\n│  each phase, manages iterations     │\n└─────────────────────────────────────┘\n    ↓\n[Checkpoint 1: Requirements]\nPM validates scope and requirements\n    ↓\n[Checkpoint 2: Research Review]\nPM reviews tech stack decisions\n    ↓\n[Checkpoint 3: Database Design]\nPM reviews schema and relationships\n    ↓\n[Checkpoint 4: API Design]\nPM reviews endpoints and auth strategy\n    ↓\n[Checkpoint 5: Architecture Review]\nPM reviews component structure\n    ↓\n[Checkpoint 6: Implementation]\n@appgen-code-reviewer validates code\n    ↓\n[Checkpoint 7: Testing]\nPM validates test coverage\n    ↓\n[Checkpoint 8: Deployment Config]\nPM confirms deployment readiness\n    ↓\nDone\n```\n\n## Key Features\n\n- **PM Orchestration:** Every phase reviewed before proceeding\n- **Quality Gates:** 2-iteration max per phase, then escalates to user\n- **Database-First:** Schema design before implementation\n- **API-First:** Endpoint design before UI\n- **Configurable Output:** Projects go to `{APPGEN_OUTPUT_DIR}/{slug} - appgen/`\n- **Tech Stack Research:** Analysis of framework and library options\n- **Comprehensive Testing:** Unit, integration, and E2E test setup\n- **Authentication:** Auth.js/Clerk/Lucia integration options\n- **Database ORMs:** Prisma or Drizzle with migrations\n- **Deployment Config:** Docker, CI/CD, environment setup\n- **Signed Work:** All commits include appgen v1.0 signature\n- **Feature Branches:** Uses git feature branch workflow\n\n## Bundled Agents\n\nThis plugin includes all required agents:\n\n| Agent | Purpose |\n|-------|---------|\n| `@appgen` | Core application generation agent |\n| `@appgen-orchestrator` | PM coordination and quality gates |\n| `@appgen-code-reviewer` | Code quality and testing validation |\n\nNo external agent dependencies required.\n\n## Invoke Orchestrator\n\nThis command invokes the **@appgen-orchestrator** agent to manage the workflow.\n\nThe orchestrator will:\n1. Validate requirements with user (Checkpoint 1)\n2. Dispatch @appgen for research phase, then review (Checkpoint 2)\n3. Dispatch @appgen for database design, then review (Checkpoint 3)\n4. Dispatch @appgen for API design, then review (Checkpoint 4)\n5. Dispatch @appgen for architecture, then review (Checkpoint 5)\n6. Dispatch @appgen for implementation, dispatch @appgen-code-reviewer (Checkpoint 6)\n7. Dispatch @appgen for testing setup, then review (Checkpoint 7)\n8. Dispatch @appgen for deployment config, then review (Checkpoint 8)\n\n**Orchestration Context:**\n\n```\nDomain: appgen\nCreator Agent: @appgen\nReviewer Agent: @appgen-code-reviewer\nOrchestrator: @appgen-orchestrator\nPhases: requirements → research → database → api → architecture → implementation → testing → deployment\nOutput: ${APPGEN_OUTPUT_DIR:-~/projects/appgen}/{project-slug} - appgen/\nPreferences: ${APPGEN_OUTPUT_DIR:-~/projects/appgen}/preferences.md (optional)\nDatabase: ${APPGEN_DB_PATH} (optional, empty = disabled)\nMax Iterations: 2 per phase (then escalate to user)\n```\n\n$ARGUMENTS"
              }
            ],
            "skills": []
          },
          {
            "name": "worklog",
            "description": "Cross-session knowledge persistence with SQLite/PostgreSQL for maintaining context across sessions",
            "source": "./plugins/worklog",
            "category": null,
            "version": "1.6.1",
            "author": null,
            "install_commands": [
              "/plugin marketplace add gaurangrshah/gsc-plugins",
              "/plugin install worklog@gsc-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-12T03:40:00Z",
              "created_at": "2025-12-13T22:09:06Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/worklog-configure",
                "description": "Setting to change: profile, backend, or show",
                "path": "plugins/worklog/commands/worklog-configure.md",
                "frontmatter": {
                  "description": "Setting to change: profile, backend, or show",
                  "arguments": [
                    {
                      "name": "setting",
                      "description": "Setting to change: profile, backend, or show",
                      "required": false
                    }
                  ]
                },
                "content": "# Worklog Configure\n\nModify worklog settings after initial setup.\n\n## Usage\n\n```\n/worklog-configure              # Interactive menu\n/worklog-configure show         # Show current settings\n/worklog-configure backend      # Change database backend\n/worklog-configure profile      # Change profile level\n```\n\n## Workflow\n\n### Step 1: Read Current Configuration\n\nLoad settings from `~/.gsc-plugins/worklog.local.md`:\n- `backend`: sqlite or postgresql\n- `profile`: minimal/standard/full\n- `db_path`: SQLite database path\n- `database_url`: PostgreSQL connection (if applicable)\n\nIf config not found:\n```\nWorklog not configured.\nRun /worklog-init to set up.\n```\n\n### Step 2: Show Current Settings\n\n**For SQLite:**\n```bash\nDB=\"${WORKLOG_DB_PATH:-$HOME/.claude/worklog/worklog.db}\"\n[ -f \"$DB\" ] && echo \"Database: ✅ Found\" || echo \"Database: ❌ Not found\"\nsqlite3 \"$DB\" \"SELECT COUNT(*) as count FROM entries;\" 2>/dev/null\n```\n\n**For PostgreSQL:**\n```bash\npsql -c \"SELECT 1;\" > /dev/null 2>&1 && echo \"Connection: ✅ OK\" || echo \"Connection: ❌ Failed\"\npsql -t -c \"SELECT COUNT(*) FROM entries;\"\n```\n\n```\nCurrent Worklog Configuration:\n==============================\n\nBackend:        {sqlite|postgresql}\nProfile:        {profile}\nHook Mode:      {hook_mode}\n\n{For SQLite:}\nDatabase Path:  {db_path}\nDatabase Size:  {size}\n\n{For PostgreSQL:}\nHost:           {host}\nPort:           {port}\nDatabase:       {database}\n\nContent Stats:\n- Entries:      {count}\n- Knowledge:    {count}\n- Memories:     {count}\n\nWhat would you like to change?\n[1] Backend (switch between SQLite/PostgreSQL)\n[2] Profile (minimal/standard/full)\n[3] Test connection\n[4] Exit\n```\n\n### Step 3: Change Backend\n\nIf switching from SQLite to PostgreSQL:\n```\nSwitching to PostgreSQL requires:\n1. A running PostgreSQL server\n2. Connection credentials\n\nConfigure connection:\n[A] DATABASE_URL\n[B] Individual PG* variables\n\nNote: Your SQLite data will NOT be migrated automatically.\n```\n\nIf switching from PostgreSQL to SQLite:\n```\nSwitching to SQLite will create a local database at:\n~/.claude/worklog/worklog.db\n\nNote: Your PostgreSQL data will NOT be migrated automatically.\nContinue? (y/n)\n```\n\n### Step 4: Change Profile\n\n```\nSelect new profile:\n\n[1] MINIMAL - Manual store/recall only\n[2] STANDARD - Light boot queries (Recommended)\n[3] FULL - Aggressive context loading\n```\n\nUpdate `~/.gsc-plugins/worklog.local.md` and replace CLAUDE.md section with new template.\n\n### Step 5: Test Connection\n\n**SQLite:**\n```bash\nDB=\"${WORKLOG_DB_PATH:-$HOME/.claude/worklog/worklog.db}\"\nsqlite3 \"$DB\" \"SELECT 'Connection OK' as status, COUNT(*) as entries FROM entries;\"\n```\n\n**PostgreSQL:**\n```bash\npsql -c \"SELECT 'Connection OK' as status, COUNT(*) as entries FROM entries;\"\n```\n\n### Step 6: Update Configuration File\n\nRewrite `~/.gsc-plugins/worklog.local.md`:\n\n```markdown\n---\nprofile: {new_profile}\nhook_mode: {new_hook_mode}\nbackend: {backend}\ndb_path: {path}                    # for SQLite\ndatabase_url: {url}                # for PostgreSQL\nsystem_name: {hostname}\ninitialized: {original_timestamp}\nlast_modified: {now}\n---\n\n# Worklog Configuration\n\n## Change History\n- {timestamp}: {what changed}\n```\n\n### Step 7: Confirm Changes\n\n```\nConfiguration updated!\n\nBackend:  {backend}\nProfile:  {profile}\nStatus:   ✅ Connected\n\nRun `/worklog-status` to verify.\n```\n\n## Troubleshooting\n\n### SQLite Issues\n\n**Database not found:**\n```\nThe database file doesn't exist at the expected path.\nRun /worklog-init to create it.\n```\n\n**Permission denied:**\n```\nCannot write to database. Check permissions:\nls -la ~/.claude/worklog/\n```\n\n### PostgreSQL Issues\n\n**Connection refused:**\n```\n1. Check if PostgreSQL server is running\n2. Verify host and port are correct\n3. Check network connectivity\n```\n\n**Authentication failed:**\n```\n1. Verify credentials\n2. Check username and password\n3. Verify database name\n```\n\n### Environment Not Set\n\n**For PostgreSQL:**\n```bash\n# Check environment\necho \"DATABASE_URL: ${DATABASE_URL:-not set}\"\necho \"PGHOST: ${PGHOST:-not set}\"\n\n# Set if needed\nexport DATABASE_URL=\"postgresql://user:pass@host:port/db\"\nsource ~/.zshrc\n```\n\n$ARGUMENTS"
              },
              {
                "name": "/worklog-connect",
                "description": "Path to the shared worklog database",
                "path": "plugins/worklog/commands/worklog-connect.md",
                "frontmatter": {
                  "description": "Path to the shared worklog database",
                  "arguments": [
                    {
                      "name": "db_path",
                      "description": "Path to SQLite database or PostgreSQL connection string",
                      "required": false
                    }
                  ]
                },
                "content": "# Worklog Connect\n\nConnect to an existing worklog database. Supports both SQLite (default) and PostgreSQL backends.\n\n**Note:** This is a quick-connect alias for `/worklog-init`. For full configuration including profile selection, run `/worklog-init` instead.\n\n## Workflow\n\n### Step 1: Detect Backend\n\nIf `db_path` argument provided:\n- If ends with `.db` → SQLite\n- If starts with `postgresql://` → PostgreSQL\n- If empty → Interactive selection\n\n```\nChoose database backend:\n\n[A] SQLite (Recommended for most users)\n    Connect to local or shared SQLite database file\n    - No external dependencies\n    - Works offline\n\n[B] PostgreSQL (For multi-system setups)\n    Connect to PostgreSQL server\n    - Shared database across systems\n    - Requires network connectivity\n```\n\n---\n\n### If SQLite Selected:\n\n#### Step 2a: Get Database Path\n\n```\nEnter path to SQLite database:\n- Local: ~/.claude/worklog/worklog.db (default)\n- Shared: /mnt/nas/worklog.db\n\nPath: _\n```\n\n#### Step 3a: Test Connection\n\n```bash\nDB=\"$PROVIDED_PATH\"\n[ -f \"$DB\" ] && echo \"Database: ✅ Found\" || echo \"Database: ❌ Not found\"\nsqlite3 \"$DB\" \"SELECT COUNT(*) as count FROM entries;\"\n```\n\nIf database exists and is readable:\n```\nSQLite Connection Test:\n=======================\nDatabase:  ✅ Found\nEntries:   127\nTables:    6 core tables detected\n\nConnection successful!\n```\n\nIf not found:\n```\nDatabase not found at: /path/to/db\n\nOptions:\n[1] Run /worklog-init to create new database\n[2] Provide different path\n[3] Cancel\n```\n\n---\n\n### If PostgreSQL Selected:\n\n#### Step 2b: Configure Connection\n\n```\nHow would you like to configure the PostgreSQL connection?\n\n[A] DATABASE_URL (Recommended)\n    Single environment variable with full connection string\n\n[B] Individual PG* variables\n    Separate PGHOST, PGPORT, PGDATABASE, PGUSER, PGPASSWORD\n```\n\n**Option A - DATABASE_URL:**\n\n```bash\n# Add to ~/.zshrc or ~/.bashrc:\nexport DATABASE_URL=\"postgresql://user:password@host:port/database\"\n\n# Reload:\nsource ~/.zshrc\n```\n\n**Option B - Individual Variables:**\n\n```bash\n# Add to ~/.zshrc or ~/.bashrc:\nexport PGHOST=your-host\nexport PGPORT=5432\nexport PGDATABASE=worklog\nexport PGUSER=worklog\nexport PGPASSWORD=\"your-password\"\n\n# Reload:\nsource ~/.zshrc\n```\n\n#### Step 3b: Test Connection\n\n```bash\npsql -c \"SELECT 'Connected!' as status, COUNT(*) as entries FROM entries;\"\n```\n\nIf successful:\n```\nPostgreSQL Connection Test:\n===========================\nHost:      your-host:5432\nDatabase:  worklog\nStatus:    ✅ Connected\nEntries:   127\n\nConnection successful!\n```\n\nIf fails:\n```\nPostgreSQL Connection Test:\n===========================\nStatus:    ❌ Failed\nError:     {error_message}\n\nTroubleshooting:\n----------------\n{If \"connection refused\":}\n1. Check server is running\n2. Verify host and port\n\n{If \"authentication failed\":}\n1. Verify credentials\n2. Check DATABASE_URL or PG* variables\n\n{If \"could not translate host name\":}\n1. Check PGHOST is set correctly\n2. Verify DNS/network connectivity\n```\n\n---\n\n### Step 4: Create Configuration\n\nCreate `~/.gsc-plugins/worklog.local.md`:\n\n```markdown\n---\nprofile: standard\nbackend: {sqlite|postgresql}\ndb_path: {path}                    # for SQLite\n# database_url: {url}             # for PostgreSQL (if using DATABASE_URL)\nsystem_name: {hostname}\ninitialized: {timestamp}\n---\n\n# Worklog Configuration\n\nConnected to existing database via /worklog-connect.\nRun /worklog-configure to change settings.\n```\n\n### Step 5: Confirmation\n\n```\nWorklog connected!\n\nBackend:  {sqlite|postgresql}\nStatus:   ✅ Connected\nEntries:  {count}\n\nFor full configuration (profile, hooks), run:\n/worklog-init\n\nCommands available:\n- /worklog-status - Check connectivity\n- /worklog-configure - Change settings\n```\n\n## Quick Connect Examples\n\n**SQLite (local):**\n```\n/worklog-connect ~/.claude/worklog/worklog.db\n```\n\n**SQLite (network share):**\n```\n/worklog-connect /Volumes/nas/shared/worklog.db\n```\n\n**PostgreSQL (via DATABASE_URL):**\n```\n/worklog-connect postgresql://user:pass@host:5432/worklog\n```\n\n## Troubleshooting\n\n### SQLite Issues\n\n**Database not found:**\n```\n1. Verify the file exists: ls -la /path/to/db\n2. Check you have read permissions\n3. If new setup, run /worklog-init instead\n```\n\n**Permission denied:**\n```\n1. Check file permissions: ls -la /path/to/db\n2. For network shares, verify mount is writable\n3. Check directory permissions for journal file\n```\n\n### PostgreSQL Issues\n\n**Connection refused:**\n```\n1. Check if PostgreSQL server is running\n2. Verify host and port are correct\n3. Check network/firewall settings\n```\n\n**Authentication failed:**\n```\n1. Verify credentials in DATABASE_URL or PG* vars\n2. Check username and password\n3. Verify database name exists\n```\n\n**Environment not set:**\n```bash\n# Check environment\necho \"DATABASE_URL: ${DATABASE_URL:-not set}\"\necho \"PGHOST: ${PGHOST:-not set}\"\n\n# Set if needed\nexport DATABASE_URL=\"postgresql://user:pass@host:port/db\"\nsource ~/.zshrc\n```\n\n$ARGUMENTS"
              },
              {
                "name": "/worklog-init",
                "description": "Initialize worklog database for cross-session persistence (primary system setup)",
                "path": "plugins/worklog/commands/worklog-init.md",
                "frontmatter": {
                  "description": "Initialize worklog database for cross-session persistence (primary system setup)",
                  "arguments": []
                },
                "content": "# Worklog Init\n\nInitialize the worklog plugin for cross-session knowledge persistence.\n\n## Overview\n\nThis command sets up the worklog database on your system. Choose between:\n\n- **SQLite (Default)**: Local database, no external dependencies\n- **PostgreSQL (Optional)**: Shared database for multi-system setups\n\n## Workflow\n\n### Step 1: Check Existing Configuration\n\n```python\n# Check for existing config\nconfig_path = os.path.expanduser(\"~/.gsc-plugins/worklog.local.md\")\n\nif os.path.exists(config_path):\n    print(\"Worklog already configured.\")\n    print(f\"Config: {config_path}\")\n\n    response = AskUserQuestion({\n        \"question\": \"What would you like to do?\",\n        \"header\": \"Config exists\",\n        \"options\": [\n            {\"label\": \"Keep existing\", \"description\": \"Exit without changes\"},\n            {\"label\": \"Reconfigure\", \"description\": \"Update configuration\"},\n            {\"label\": \"View config\", \"description\": \"Show current settings\"}\n        ]\n    })\n\n    if response == \"Keep existing\":\n        return\n    elif response == \"View config\":\n        showConfig(config_path)\n        return\n```\n\n### Step 2: Choose Database Backend\n\n```\nWhich database backend would you like to use?\n\n[A] SQLite (Recommended for most users)\n    - Local database at ~/.claude/worklog/worklog.db\n    - No external dependencies\n    - Works offline\n    - Single system use\n\n[B] PostgreSQL (For multi-system setups)\n    - Shared database across systems\n    - Requires PostgreSQL server\n    - Enables cross-agent collaboration\n    - Requires network connectivity\n```\n\n---\n\n### If SQLite Selected:\n\n#### Step 3a: Choose Integration Profile\n\n**[1] MINIMAL** - Lightweight persistence\n- Manual store/recall via skills\n- No automatic boot queries\n- CLAUDE.md addition: ~20 lines\n- Best for: Occasional use, minimal overhead\n\n**[2] STANDARD** - Balanced integration (Recommended)\n- Light boot queries for recent context\n- Prompts to store learnings at task end\n- CLAUDE.md addition: ~50 lines\n- Best for: Daily use, cross-session continuity\n\n**[3] FULL** - Maximum context awareness\n- Aggressive boot queries (protocols, recent work, errors)\n- Auto-store task outcomes\n- CLAUDE.md addition: ~100 lines\n- Best for: Power users wanting full automation\n\n#### Step 4a: Create Database\n\n```bash\n# Create directory\nmkdir -p ~/.claude/worklog\n\n# Database will be auto-created by the MCP server on first use\n# Or create manually with schema:\nsqlite3 ~/.claude/worklog/worklog.db < {plugin_root}/schema/core.sql\n```\n\n---\n\n### If PostgreSQL Selected:\n\n#### Step 3b: Choose Integration Profile\n\nSame options as SQLite (MINIMAL, STANDARD, FULL)\n\n#### Step 4b: Configure Connection\n\n```\nHow would you like to configure the PostgreSQL connection?\n\n[A] DATABASE_URL (Recommended)\n    Single environment variable with full connection string\n\n[B] Individual PG* variables\n    Separate PGHOST, PGPORT, PGDATABASE, PGUSER, PGPASSWORD\n```\n\n**Option A - DATABASE_URL:**\n\n```bash\n# Add to ~/.zshrc or ~/.bashrc:\nexport DATABASE_URL=\"postgresql://user:password@host:port/database\"\n\n# Then run: source ~/.zshrc\n```\n\n**Option B - Individual Variables:**\n\n```bash\n# Add to ~/.zshrc or ~/.bashrc:\nexport PGHOST=your-host\nexport PGPORT=5432\nexport PGDATABASE=worklog\nexport PGUSER=worklog\nexport PGPASSWORD=\"your-password\"\n\n# Then run: source ~/.zshrc\n```\n\n#### Step 5b: Test Connection\n\n```bash\npsql -c \"SELECT 1;\"\n```\n\n---\n\n### Step 5: Create Backups (Safety Protocol)\n\n**Before making ANY changes**, backup existing files:\n\n```bash\nBACKUP_TS=$(date +%Y%m%d%H%M%S)\nBACKUP_DIR=~/.claude/.worklog-backup-$BACKUP_TS\n\nmkdir -p $BACKUP_DIR\n\n# Backup CLAUDE.md if exists\nif [ -f ~/.claude/CLAUDE.md ]; then\n  cp ~/.claude/CLAUDE.md $BACKUP_DIR/CLAUDE.md\n  echo \"Backed up: CLAUDE.md\"\nfi\n\necho $BACKUP_DIR > ~/.claude/.worklog-backup-path\n```\n\n### Step 6: Create Plugin Configuration\n\nCreate `~/.gsc-plugins/worklog.local.md`:\n\n```markdown\n---\nprofile: {selected_profile}\nhook_mode: {selected_hook_mode}\nbackend: {sqlite|postgresql}\ndb_path: ~/.claude/worklog/worklog.db  # for SQLite\n# database_url: postgresql://...       # for PostgreSQL\nsystem_name: {hostname}\ninitialized: {timestamp}\n---\n\n# Worklog Configuration\n\n## Backend\n- **Type:** {backend}\n- **Path/URL:** {path_or_url}\n\n## Settings\n- **Profile:** {profile}\n- **Hook Mode:** {hook_mode}\n\nTo reconfigure, run `/worklog-configure`.\n```\n\n### Step 7: Inject CLAUDE.md Section\n\nRead appropriate template from `{plugin_root}/templates/` based on profile:\n- `minimal.md` for MINIMAL profile\n- `standard.md` for STANDARD profile\n- `full.md` for FULL profile\n\nReplace `{DB_PATH}` or `{DATABASE_URL}` placeholders with actual values.\n\nFor SQLite, boot queries use `sqlite3`:\n```bash\nsqlite3 ~/.claude/worklog/worklog.db \"SELECT ...\"\n```\n\nFor PostgreSQL, boot queries use `psql`:\n```bash\npsql -c \"SELECT ...\"\n```\n\n### Step 8: Plugin Discovery\n\n**Detect other GSC plugins and offer integration:**\n\n```python\n# Scan for other GSC plugin configs\ngsc_plugins_dir = os.path.expanduser(\"~/.gsc-plugins\")\nplugin_configs = glob.glob(f\"{gsc_plugins_dir}/*.local.md\")\n\n# Check for known plugins\ndetected_plugins = []\nfor config in plugin_configs:\n    name = os.path.basename(config).replace(\".local.md\", \"\")\n    if name != \"worklog\":\n        detected_plugins.append(name)\n\n# Check for plugin directories\nplugin_dirs = [\n    \"~/.claude/plugins/local-plugins\",\n    \"~/.claude/plugins/marketplaces/gsc-plugins\"\n]\n\nfor base_dir in plugin_dirs:\n    expanded = os.path.expanduser(base_dir)\n    if os.path.exists(expanded):\n        for item in os.listdir(expanded):\n            if item in [\"appgen\", \"webgen\", \"taskflow\", \"docs\"]:\n                if item not in detected_plugins:\n                    detected_plugins.append(item)\n\n# Report discovered plugins\nif detected_plugins:\n    print(f\"\\nDiscovered GSC plugins: {', '.join(detected_plugins)}\")\n    print(\"\\nWorklog can provide cross-session context for these plugins:\")\n    print(\"- SessionStart hooks inject recent context\")\n    print(\"- SessionStop hooks capture learnings\")\n    print(\"- Knowledge base shared across all plugins\")\n```\n\n**Scan for existing knowledge to import:**\n\n```python\n# Check for markdown knowledge directories\nknowledge_sources = []\n\n# AppGen knowledge\nappgen_kb = os.path.expanduser(\"~/.gsc-plugins/knowledge\")\nif os.path.exists(appgen_kb):\n    md_files = glob.glob(f\"{appgen_kb}/**/*.md\", recursive=True)\n    if md_files:\n        knowledge_sources.append({\n            \"source\": \"appgen/webgen\",\n            \"type\": \"markdown\",\n            \"path\": appgen_kb,\n            \"count\": len(md_files)\n        })\n\n# Docs knowledge base\ndocs_config = loadLocalMdConfig(\"~/.gsc-plugins/docs.local.md\")\nif docs_config and docs_config.get(\"knowledge_base\"):\n    kb_path = os.path.expanduser(docs_config[\"knowledge_base\"])\n    if os.path.exists(kb_path):\n        md_files = glob.glob(f\"{kb_path}/**/*.md\", recursive=True)\n        if md_files:\n            knowledge_sources.append({\n                \"source\": \"docs\",\n                \"type\": \"markdown\",\n                \"path\": kb_path,\n                \"count\": len(md_files)\n            })\n\n# Offer import if knowledge found\nif knowledge_sources:\n    total_files = sum(k[\"count\"] for k in knowledge_sources)\n    print(f\"\\nFound {total_files} knowledge files from other plugins:\")\n    for ks in knowledge_sources:\n        print(f\"  - {ks['source']}: {ks['count']} files at {ks['path']}\")\n\n    response = AskUserQuestion({\n        \"question\": \"Import existing knowledge into worklog?\",\n        \"header\": \"Knowledge Import\",\n        \"options\": [\n            {\"label\": \"Yes (Recommended)\", \"description\": \"Import and centralize all knowledge\"},\n            {\"label\": \"No\", \"description\": \"Start fresh, keep separate\"}\n        ]\n    })\n\n    if \"Yes\" in response:\n        importKnowledge(knowledge_sources)\n```\n\n### Step 9: Import Knowledge (if requested)\n\n```python\ndef importKnowledge(sources):\n    \"\"\"Import markdown knowledge files into worklog database.\"\"\"\n    imported = 0\n\n    for source in sources:\n        if source[\"type\"] == \"markdown\":\n            for md_file in glob.glob(f\"{source['path']}/**/*.md\", recursive=True):\n                # Parse frontmatter\n                with open(md_file, 'r') as f:\n                    content = f.read()\n\n                frontmatter, body = parseFrontmatter(content)\n\n                # Map to knowledge_base entry\n                title = frontmatter.get(\"title\", os.path.basename(md_file))\n                category = frontmatter.get(\"type\", \"general\")\n                tags = frontmatter.get(\"tags\", source[\"source\"])\n\n                # Insert into worklog\n                mcp__worklog__store_knowledge(\n                    category=category,\n                    title=title,\n                    content=body,\n                    tags=tags,\n                    source_agent=f\"import:{source['source']}\"\n                )\n                imported += 1\n\n    print(f\"\\nImported {imported} knowledge entries to worklog.\")\n    print(\"Original files preserved (non-destructive import).\")\n```\n\n### Step 10: Run Verification\n\n**SQLite Verification:**\n```bash\nDB=~/.claude/worklog/worklog.db\n[ -f \"$DB\" ] && echo \"Database: OK\" || echo \"Database: MISSING\"\nsqlite3 \"$DB\" \"SELECT COUNT(*) FROM sqlite_master WHERE type='table';\" && echo \"Schema: OK\"\ngrep -q \"WORKLOG_START\" ~/.claude/CLAUDE.md && echo \"CLAUDE.md: OK\" || echo \"CLAUDE.md: MISSING\"\n[ -f ~/.gsc-plugins/worklog.local.md ] && echo \"Config: OK\" || echo \"Config: MISSING\"\n```\n\n**PostgreSQL Verification:**\n```bash\npsql -c \"SELECT 1;\" && echo \"Connection: OK\" || echo \"Connection: FAILED\"\npsql -c \"SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='public';\" && echo \"Schema: OK\"\ngrep -q \"WORKLOG_START\" ~/.claude/CLAUDE.md && echo \"CLAUDE.md: OK\" || echo \"CLAUDE.md: MISSING\"\n[ -f ~/.gsc-plugins/worklog.local.md ] && echo \"Config: OK\" || echo \"Config: MISSING\"\n```\n\n### Step 11: User Confirmation\n\n```\nInstallation complete!\n\nBackend:  {sqlite|postgresql}\nProfile:  {profile}\nHook:     {hook_mode}\n\nChanges made:\n- Created: ~/.gsc-plugins/worklog.local.md\n- Updated: ~/.claude/CLAUDE.md\n{If SQLite: - Created: ~/.claude/worklog/worklog.db}\n{If imported: - Imported {n} knowledge entries}\n\nKeep these changes? (y/n)\n```\n\n**If YES:** Finalize installation\n**If NO:** Rollback from backup\n\n### Step 12: Provide Next Steps\n\n```\nWorklog initialized successfully!\n\nBackend: {backend}\nProfile: {profile}\n{If plugins discovered:}\nIntegrates with: {detected_plugins}\n\nNext steps:\n- Use `memory-store` skill to save learnings\n- Use `memory-recall` skill to query context\n- Run `/worklog-status` to check connectivity\n\nMCP tools available:\n- store_memory, recall_context, search_knowledge\n- log_entry, store_knowledge, query_table\n```\n\n## Error Handling\n\n**SQLite creation fails:**\n- Check write permissions to ~/.claude/\n- Verify disk space available\n\n**PostgreSQL connection fails:**\n- Verify environment variables are set\n- Check network connectivity\n- Verify credentials\n\n**CLAUDE.md not found:**\n- Create minimal CLAUDE.md with worklog section\n\n**Import fails:**\n- Original files are preserved\n- Check file permissions\n- Verify frontmatter format\n\n## Rollback Command\n\n```bash\nBACKUP=$(ls -td ~/.claude/.worklog-backup-* 2>/dev/null | head -1)\nif [ -n \"$BACKUP\" ]; then\n  cp $BACKUP/CLAUDE.md ~/.claude/CLAUDE.md 2>/dev/null\n  rm -f ~/.gsc-plugins/worklog.local.md\n  echo \"Restored from $BACKUP\"\nfi\n```"
              },
              {
                "name": "/worklog-setup-mcp",
                "description": "Set up Python environment for worklog MCP server (cross-platform)",
                "path": "plugins/worklog/commands/worklog-setup-mcp.md",
                "frontmatter": {
                  "description": "Set up Python environment for worklog MCP server (cross-platform)",
                  "arguments": []
                },
                "content": "# Worklog Setup MCP\n\nSet up the Python virtual environment for the worklog MCP server with intelligent cross-platform detection.\n\n## What This Command Does\n\n1. **Detects Python Environment** - Checks for existing version managers in order:\n   - pyenv (if installed, respects user's explicit choice)\n   - mise (if installed)\n   - Homebrew Python (macOS only)\n   - System Python\n\n2. **Creates Virtual Environment** - Isolated venv for MCP dependencies\n\n3. **Installs Dependencies** - fastmcp, aiosqlite, and plugin code\n\n4. **Outputs Configuration** - Shows .mcp.json settings to use\n\n## Workflow\n\n### Step 1: Run Detection\n\nExecute the detection script to find suitable Python:\n\n```bash\nPLUGIN_DIR=$(dirname $(dirname $(realpath ~/.claude/plugins.json 2>/dev/null || echo ~/.claude)))/gsc-plugins/plugins/worklog\n\n# Or use known paths\nif [[ -d /volume2/dev-env/workspace/gsc-plugins ]]; then\n    PLUGIN_DIR=\"/volume2/dev-env/workspace/gsc-plugins/plugins/worklog\"\nelif [[ -d /Volumes/dev-env/workspace/gsc-plugins ]]; then\n    PLUGIN_DIR=\"/Volumes/dev-env/workspace/gsc-plugins/plugins/worklog\"\nelif [[ -d /mnt/nasdevenv/workspace/gsc-plugins ]]; then\n    PLUGIN_DIR=\"/mnt/nasdevenv/workspace/gsc-plugins/plugins/worklog\"\nelif [[ -d ~/workspace/gsc-plugins ]]; then\n    PLUGIN_DIR=\"$HOME/workspace/gsc-plugins/plugins/worklog\"\nfi\n\n# Run detection\nsource \"$PLUGIN_DIR/scripts/detect-python-env.sh\"\n```\n\nShow the user the detection results:\n\n```\nPython Environment Detection\n==============================\nOS: {macos|linux}\n\n{If PYTHON_OK == \"yes\":}\n✓ Found suitable Python\n  Command: {PYTHON_CMD}\n  Version: {PYTHON_VERSION}\n  Source:  {PYTHON_SOURCE}\n\n{If PYTHON_OK == \"no\":}\n✗ No suitable Python found\n  Required: Python >= 3.10\n\nRecommendation:\n  {PYTHON_RECOMMENDATION}\n```\n\n### Step 2: Handle Missing Python\n\nIf `PYTHON_OK` is \"no\", present the recommendation and ask:\n\n> \"Python 3.10+ is required for the MCP server. Would you like me to help install it?\"\n>\n> **Recommendation:** `{PYTHON_RECOMMENDATION}`\n>\n> Options:\n> - [A] Run the recommended command\n> - [B] I'll install Python myself, then re-run this command\n> - [C] Cancel setup\n\n**If user chooses A:**\n\nExecute the recommendation command. For example:\n- macOS with brew: `brew install python@3.12`\n- Linux with apt: `sudo apt-get install python3.12 python3.12-venv`\n- mise: `mise use python@3.12`\n- pyenv: `pyenv install 3.12 && pyenv global 3.12`\n\nAfter installation, re-run detection to verify.\n\n### Step 3: Create Virtual Environment\n\nOnce Python is available:\n\n```bash\n\"$PLUGIN_DIR/scripts/setup-mcp-venv.sh\"\n```\n\nThis creates the venv at `$PLUGIN_DIR/mcp/.venv` and installs dependencies.\n\n### Step 4: Configure MCP\n\nRead the Python path from the setup output and help configure `.mcp.json`:\n\n```bash\nVENV_PYTHON=$(cat \"$PLUGIN_DIR/mcp/.python-path\")\n```\n\nDetermine the correct database path based on your setup:\n\n| Setup | Database Path |\n|-------|---------------|\n| Local (default) | ~/.claude/worklog/worklog.db |\n| Shared (network mount) | /path/to/shared/worklog.db |\n| PostgreSQL | Set via DATABASE_URL environment variable |\n\nCreate or update `~/.claude/.mcp.json`:\n\n```json\n{\n  \"mcpServers\": {\n    \"worklog\": {\n      \"type\": \"stdio\",\n      \"command\": \"{VENV_PYTHON}\",\n      \"args\": [\"-m\", \"worklog_mcp\"],\n      \"env\": {\n        \"WORKLOG_DB\": \"{DB_PATH}\"\n      }\n    }\n  }\n}\n```\n\n### Step 5: Verify Setup\n\nTest the MCP server:\n\n```bash\n$VENV_PYTHON -m worklog_mcp --help\n```\n\nOr run a quick tool test:\n\n```bash\n$VENV_PYTHON -c \"from worklog_mcp import server; print('MCP server loads OK')\"\n```\n\n### Step 6: Restart Claude Code\n\nInform the user:\n\n> \"Setup complete! Restart Claude Code to load the MCP server.\"\n>\n> After restart, verify with: `claude mcp list`\n>\n> You should see `worklog` with tools like:\n> - query_table\n> - search_knowledge\n> - store_memory\n> - log_entry\n\n## Error Handling\n\n**Python version too old:**\n- Show current version and required version\n- Provide upgrade instructions for the detected source\n\n**venv creation fails:**\n- Check disk space\n- Check write permissions\n- Try alternative venv location: `~/.local/share/gsc-plugins-venv`\n\n**pip install fails:**\n- Check network connectivity\n- Try: `pip install --upgrade pip` first\n- Check if behind proxy (offer to set PIP_PROXY)\n\n**Database not found:**\n- Verify NAS mount (network drive paths)\n- Check if database was initialized with /worklog-init\n- Offer to create new database or set custom WORKLOG_DB path\n\n## Notes\n\n- This command is idempotent - safe to run multiple times\n- Existing venv will prompt before recreation\n- The detection prioritizes user-managed tools (pyenv) over system Python\n- On macOS, prefers Homebrew Python over the ancient system Python (3.9.6)"
              },
              {
                "name": "/worklog-status",
                "description": "Check worklog database connectivity and display statistics",
                "path": "plugins/worklog/commands/worklog-status.md",
                "frontmatter": {
                  "description": "Check worklog database connectivity and display statistics",
                  "arguments": []
                },
                "content": "# Worklog Status\n\nCheck worklog database connectivity and display usage statistics.\n\n## Workflow\n\n### Step 1: Load Configuration\n\nRead `~/.gsc-plugins/worklog.local.md` for settings:\n- `backend`: sqlite or postgresql\n- `profile`\n- `db_path` or `database_url`\n\nIf config not found:\n```\nWorklog not configured.\nRun /worklog-init to set up.\n```\n\n### Step 2: Detect Backend\n\n```bash\n# Auto-detect backend from environment\nif [ -n \"$DATABASE_URL\" ] || [ -n \"$PGHOST\" ]; then\n    BACKEND=\"postgresql\"\nelse\n    BACKEND=\"sqlite\"\nfi\necho \"Backend: $BACKEND\"\n```\n\n### Step 3: Test Connectivity\n\n**SQLite:**\n```bash\nDB=\"${WORKLOG_DB_PATH:-$HOME/.claude/worklog/worklog.db}\"\nsqlite3 \"$DB\" \"SELECT 1;\" 2>&1\n```\n\n**PostgreSQL:**\n```bash\npsql -c \"SELECT 1;\" 2>&1\n```\n\n### Step 4: Gather Statistics\n\n**SQLite:**\n```bash\nDB=\"${WORKLOG_DB_PATH:-$HOME/.claude/worklog/worklog.db}\"\n\n# Table counts\nsqlite3 \"$DB\" \"\nSELECT\n  (SELECT COUNT(*) FROM entries) as entries,\n  (SELECT COUNT(*) FROM knowledge_base) as knowledge,\n  (SELECT COUNT(*) FROM memories) as memories;\n\"\n\n# Recent activity\nsqlite3 \"$DB\" \"\nSELECT agent, COUNT(*) as count\nFROM entries\nWHERE timestamp > datetime('now', '-7 days')\nGROUP BY agent;\n\"\n\n# Database size\nls -lh \"$DB\" | awk '{print $5}'\n```\n\n**PostgreSQL:**\n```bash\n# Table counts\npsql -t -c \"\nSELECT\n  (SELECT COUNT(*) FROM entries) as entries,\n  (SELECT COUNT(*) FROM knowledge_base) as knowledge,\n  (SELECT COUNT(*) FROM memories) as memories;\n\"\n\n# Recent activity\npsql -t -c \"\nSELECT agent, COUNT(*) as count\nFROM entries\nWHERE timestamp > NOW() - INTERVAL '7 days'\nGROUP BY agent;\n\"\n\n# Database size\npsql -t -c \"SELECT pg_size_pretty(pg_database_size(current_database()));\"\n```\n\n### Step 5: Display Status\n\n```\nWorklog Status\n==============\n\nBackend:     {sqlite|postgresql}\nConnection:  ✅ Connected\nProfile:     {profile}\n\n{For SQLite:}\nDatabase:    {db_path}\nSize:        {size}\n\n{For PostgreSQL:}\nHost:        {host}:{port}\nDatabase:    {database}\nSize:        {size}\n\nContent:\n--------\nEntries:         {count}\nKnowledge Base:  {count}\nMemories:        {count}\nOpen Issues:     {count}\nError Patterns:  {count}\n\nRecent Activity (7 days):\n-------------------------\n{agent}: {count} entries\n{agent}: {count} entries\n\nLast Entry:\n-----------\n{timestamp} | {agent} | {title}\n```\n\n### Step 6: Test Write Access\n\n**SQLite:**\n```bash\nsqlite3 \"$DB\" \"INSERT INTO entries (agent, task_type, title) VALUES ('_test', '_test', '_test'); DELETE FROM entries WHERE agent='_test';\"\necho \"Write: ✅\"\n```\n\n**PostgreSQL:**\n```bash\npsql -c \"INSERT INTO entries (agent, task_type, title) VALUES ('_test', '_test', '_test'); DELETE FROM entries WHERE agent='_test';\"\necho \"Write: ✅\"\n```\n\n### Troubleshooting Output\n\nIf connectivity fails:\n\n**SQLite:**\n```\nWorklog Status\n==============\n\nBackend:     SQLite\nConnection:  ❌ Failed\nDatabase:    {db_path}\nError:       {error_message}\n\nTroubleshooting:\n----------------\n1. Check if file exists: ls -la {db_path}\n2. Check permissions: test -w {db_path} && echo \"Writable\"\n3. Check directory exists: ls -la ~/.claude/worklog/\n\nRun /worklog-init to create database.\n```\n\n**PostgreSQL:**\n```\nWorklog Status\n==============\n\nBackend:     PostgreSQL\nConnection:  ❌ Failed\nError:       {error_message}\n\nTroubleshooting:\n----------------\n{If \"connection refused\":}\n1. Check server is running\n2. Verify host and port\n3. Check network connectivity\n\n{If \"authentication failed\":}\n1. Verify credentials\n2. Check DATABASE_URL or PG* variables\n\n{If \"could not translate host name\":}\n1. Check PGHOST is set\n2. Verify environment variables\n\nRun /worklog-configure to update settings.\n```\n\n## Quick Check Commands\n\n**SQLite:**\n```bash\nsqlite3 ~/.claude/worklog/worklog.db \"SELECT 'OK', COUNT(*) FROM entries;\"\n```\n\n**PostgreSQL:**\n```bash\npsql -c \"SELECT 'OK', COUNT(*) FROM entries;\"\n```"
              }
            ],
            "skills": []
          },
          {
            "name": "taskflow",
            "description": "AI-powered task management - transform PRDs into structured, dependency-aware tasks",
            "source": "./plugins/taskflow",
            "category": null,
            "version": "1.1.0",
            "author": null,
            "install_commands": [
              "/plugin marketplace add gaurangrshah/gsc-plugins",
              "/plugin install taskflow@gsc-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-12T03:40:00Z",
              "created_at": "2025-12-13T22:09:06Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/task-add",
                "description": "Add a new task to TaskFlow (ad-hoc, no PRD required)",
                "path": "plugins/taskflow/commands/task-add.md",
                "frontmatter": {
                  "name": "task-add",
                  "description": "Add a new task to TaskFlow (ad-hoc, no PRD required)",
                  "args": "<title> [--priority=high|medium|low] [--type=task|epic] [--description=\"...\"]",
                  "version": "2.0"
                },
                "content": "# /task-add\n\nAdd a task directly to TaskFlow without needing a PRD.\n\n## Usage\n\n```bash\n# Simple task\n/task-add \"Fix login button styling\"\n\n# With priority\n/task-add \"Implement user auth\" --priority=high\n\n# Create an epic\n/task-add \"User Management System\" --type=epic\n\n# With description\n/task-add \"Add dark mode toggle\" --description=\"Should respect system preference\"\n```\n\n---\n\n## Workflow\n\n### Step 1: Load Backend\n\n```python\n# Load configured backend (or trigger first-run setup)\nbackend = loadBackend()\n\nif not backend:\n    # First run - trigger setup flow\n    # See: _core/backend-loader.md\n    return runFirstTimeSetup()\n```\n\n### Step 2: Parse Arguments\n\n```python\ndef parseArgs(args):\n    # Extract title (required)\n    title = args[0] if args else None\n    if not title:\n        error(\"Task title required. Usage: /task-add \\\"Your task title\\\"\")\n        return\n\n    # Parse flags\n    priority = extractFlag(args, \"--priority\") or \"medium\"\n    task_type = extractFlag(args, \"--type\") or \"task\"\n    description = extractFlag(args, \"--description\") or \"\"\n\n    return {\n        \"title\": title,\n        \"priority\": priority,\n        \"type\": task_type,\n        \"description\": description\n    }\n```\n\n### Step 3: Create Task\n\n```python\ndef createTask(parsed):\n    backend = loadBackend()\n\n    task = backend.createTask({\n        \"title\": parsed[\"title\"],\n        \"description\": parsed[\"description\"],\n        \"priority\": parsed[\"priority\"],\n        \"type\": parsed[\"type\"],\n        \"createdBy\": \"claude\"\n    })\n\n    return task\n```\n\n### Step 4: Confirm & Offer Next Steps\n\n```markdown\n## Task Created\n\n**ID:** {task.id}\n**Title:** {task.title}\n**Priority:** {task.priority}\n**Status:** pending\n\n{if backend.type != \"local\"}\n**Synced to:** {backend.externalUrl}\n{/if}\n\n---\n\n**Next steps:**\n- Start working: `/task-status {task.id} in_progress`\n- Add subtasks: `/task-add \"Subtask\" --parent={task.id}`\n- View all tasks: `/task-list`\n```\n\n---\n\n## Examples\n\n### Basic Task\n\n```bash\n/task-add \"Update README with installation instructions\"\n```\n\nOutput:\n```\nTask Created\n\nID: task-001\nTitle: Update README with installation instructions\nPriority: medium\nStatus: pending\n\nNext steps:\n- Start working: /task-status task-001 in_progress\n- View all tasks: /task-list\n```\n\n### High Priority Task\n\n```bash\n/task-add \"Fix production database connection timeout\" --priority=high\n```\n\nOutput:\n```\nTask Created\n\nID: task-002\nTitle: Fix production database connection timeout\nPriority: high\nStatus: pending\n\nThis is marked HIGH PRIORITY.\n\nNext steps:\n- Start immediately: /task-status task-002 in_progress\n```\n\n### Create Epic\n\n```bash\n/task-add \"Authentication System\" --type=epic --description=\"Complete auth flow with JWT, refresh tokens, and OAuth\"\n```\n\nOutput:\n```\nEpic Created\n\nID: task-003\nTitle: Authentication System\nType: epic\nPriority: medium\nStatus: pending\n\nDescription:\nComplete auth flow with JWT, refresh tokens, and OAuth\n\nEpics can have subtasks. Add them with:\n  /task-add \"Subtask title\" --parent=task-003\n\nOr expand from a description:\n  /task-expand task-003\n```\n\n### With Plane Backend\n\n```bash\n/task-add \"Implement search feature\" --priority=high\n```\n\nOutput:\n```\nTask Created\n\nID: abc123-def456\nTitle: Implement search feature\nPriority: high (urgent in Plane)\nStatus: pending\n\nSynced to: https://plane.internal.muhaha.dev/gsdev/work\nIssue: WORK-42\n\nNext steps:\n- Start working: /task-status abc123-def456 in_progress\n- View in Plane: https://plane.internal.muhaha.dev/issue/WORK-42\n```\n\n---\n\n## Interactive Mode\n\nIf called without arguments, enter interactive mode:\n\n```bash\n/task-add\n```\n\nPrompts:\n```\n┌─────────────────────────────────────────────────────────────┐\n│  Add New Task                                               │\n├─────────────────────────────────────────────────────────────┤\n│                                                             │\n│  Title: _                                                   │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘\n```\n\nThen use AskUserQuestion for priority:\n\n```json\n{\n  \"question\": \"What priority level?\",\n  \"header\": \"Priority\",\n  \"options\": [\n    {\"label\": \"Medium (default)\", \"description\": \"Standard priority\"},\n    {\"label\": \"High\", \"description\": \"Urgent or blocking other work\"},\n    {\"label\": \"Low\", \"description\": \"Nice to have, not urgent\"}\n  ],\n  \"multiSelect\": false\n}\n```\n\n---\n\n## Flags Reference\n\n| Flag | Values | Default | Description |\n|------|--------|---------|-------------|\n| `--priority` | high, medium, low | medium | Task priority |\n| `--type` | task, epic | task | Task type |\n| `--description` | string | \"\" | Detailed description |\n| `--parent` | task-id | null | Parent epic ID (creates subtask) |\n| `--no-sync` | flag | false | Skip syncing to external backend |\n\n---\n\n## Error Handling\n\n### No Title Provided\n\n```\nError: Task title required.\n\nUsage: /task-add \"Your task title\"\n\nExamples:\n  /task-add \"Fix login bug\"\n  /task-add \"New feature\" --priority=high\n```\n\n### Backend Not Configured\n\n```\nTaskFlow not configured.\n\nRunning first-time setup...\n\n[Triggers backend-loader first-run flow]\n```\n\n### Backend Connection Failed\n\n```\nWarning: Could not connect to Plane backend.\n\nTask saved locally to .tasks/tasks.json\nSync will retry when backend is available.\n\nTo switch to local-only mode:\n  /task config --backend=local\n```\n\n---\n\n## Integration with TodoWrite\n\nWhen a task is created, optionally add to Claude's TodoWrite:\n\n```python\nif config.defaults.get(\"syncTodoWrite\", True):\n    TodoWrite([\n        {\n            \"content\": task.title,\n            \"status\": \"pending\",\n            \"activeForm\": f\"Working on {task.title[:30]}...\"\n        }\n    ])\n```\n\nThis keeps Claude's visible todo list in sync with TaskFlow.\n\n---\n\n**Command Version:** 2.0\n**Requires:** Backend configured or first-run setup"
              },
              {
                "name": "/task-expand",
                "description": "Break a task into smaller subtasks",
                "path": "plugins/taskflow/commands/task-expand.md",
                "frontmatter": {
                  "description": "Break a task into smaller subtasks"
                },
                "content": "# /task-expand\n\nBreak down a complex task into smaller, manageable subtasks using AI analysis.\n\n## What This Command Does\n\n1. Load task by ID from `.tasks/tasks.json`\n2. Analyze task complexity and generate subtasks\n3. **CHECKPOINT**: Present subtasks for human review\n4. On approval, save subtasks to task\n5. Update task status if needed\n\n## Arguments\n\n- `<task-id>` - **Required.** Task ID to expand (e.g., `3`)\n- `--num=N` - Optional. Target number of subtasks (default: 3-5)\n- `--force` - Expand even if subtasks already exist (replaces them)\n\n## Prerequisites\n\n- Project must have tasks (`.tasks/tasks.json` exists)\n- Task must exist and not already have subtasks (unless `--force`)\n\n## Workflow\n\n### Step 1: Load Task\n\nRead `.tasks/tasks.json` and find the specified task.\n\nIf task already has subtasks:\n```\nTask 3 already has 4 subtasks:\n  3.1 Create registration endpoint (done)\n  3.2 Create login endpoint (in_progress)\n  3.3 Create token refresh endpoint (pending)\n  3.4 Create logout endpoint (pending)\n\nUse --force to replace existing subtasks, or work with current ones.\n```\n\n### Step 2: Generate Subtasks with AI\n\nUse the following prompt:\n\n---\n\n**SYSTEM PROMPT FOR SUBTASK GENERATION:**\n\n```\nBreak down this task into smaller, actionable subtasks.\n\n## Parent Task\nID: <TASK_ID>\nTitle: <TASK_TITLE>\nDescription: <TASK_DESCRIPTION>\nPriority: <TASK_PRIORITY>\n\nAcceptance Criteria:\n<ACCEPTANCE_CRITERIA>\n\n## Instructions\n1. Create <NUM_SUBTASKS> subtasks that together complete the parent task\n2. Each subtask should be completable in 30-90 minutes\n3. Subtasks should be sequential where there are natural dependencies\n4. First subtask should be the logical starting point\n5. Final subtask should complete/verify the parent task\n\n## Output Format\nReturn ONLY valid JSON (no markdown, no explanation):\n\n{\n  \"subtasks\": [\n    {\n      \"id\": \"<TASK_ID>.1\",\n      \"title\": \"<action-oriented title>\",\n      \"status\": \"pending\"\n    },\n    {\n      \"id\": \"<TASK_ID>.2\",\n      \"title\": \"<action-oriented title>\",\n      \"status\": \"pending\"\n    }\n  ]\n}\n\n## Rules\n- Subtask IDs must be <parent_id>.<sequential_number> (e.g., 3.1, 3.2, 3.3)\n- All subtasks start with status \"pending\"\n- Titles should start with action verbs\n- Together, subtasks should fully address all acceptance criteria\n```\n\n---\n\n### Step 3: Validate Subtasks\n\nBefore presenting to user:\n\n1. **JSON Valid**: Parse without errors\n2. **IDs Correct**: Format is `<parent_id>.<number>`, sequential\n3. **Status Valid**: All are \"pending\"\n4. **Coverage**: Subtasks should address acceptance criteria\n\n### Step 4: CHECKPOINT - Human Review\n\nPresent generated subtasks:\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│ Expanding Task 3: Implement user authentication                 │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│ Generated 4 subtasks:                                           │\n│                                                                 │\n│   3.1 Set up authentication middleware and JWT utilities        │\n│   3.2 Create user registration endpoint with validation         │\n│   3.3 Create login endpoint with token generation               │\n│   3.4 Implement token refresh and logout endpoints              │\n│                                                                 │\n│ Criteria coverage:                                              │\n│   ✓ Users can register with email/password → 3.2                │\n│   ✓ Users can log in and receive JWT token → 3.3                │\n│   ✓ Tokens expire after 24 hours → 3.1, 3.3                     │\n│   ✓ Refresh token flow extends session → 3.4                    │\n│                                                                 │\n├─────────────────────────────────────────────────────────────────┤\n│ Approve these subtasks?                                         │\n└─────────────────────────────────────────────────────────────────┘\n```\n\nUse AskUserQuestion:\n\n```json\n{\n  \"question\": \"Approve these subtasks?\",\n  \"header\": \"Subtask Review\",\n  \"options\": [\n    {\"label\": \"Approve\", \"description\": \"Save subtasks to task\"},\n    {\"label\": \"Edit\", \"description\": \"Modify before saving\"},\n    {\"label\": \"Regenerate\", \"description\": \"Try again with different breakdown\"},\n    {\"label\": \"Cancel\", \"description\": \"Keep task without subtasks\"}\n  ],\n  \"multiSelect\": false\n}\n```\n\n### Step 5: Handle Response\n\n**If Approve:**\n- Proceed to save\n\n**If Edit:**\n- Ask which subtask(s) to modify\n- Allow adding/removing/renaming\n- Re-display and confirm\n\n**If Regenerate:**\n- Ask for guidance (more/fewer subtasks, different focus)\n- Re-run Step 2 with adjusted prompt\n- Return to Step 4\n\n**If Cancel:**\n- Exit without changes\n\n### Step 6: Save Subtasks\n\nUpdate the task in `tasks.json`:\n\n```python\ntask.subtasks = generated_subtasks\ntask.updated = now_iso8601()\n\n# If task was pending, could mark as ready for subtask work\n# Status remains unchanged - user starts work via /task-next\n```\n\n### Step 7: Confirm Success\n\n```\nTask expanded successfully!\n\nTask 3: Implement user authentication\n  └── 4 subtasks created:\n      ○ 3.1 Set up authentication middleware and JWT utilities\n      ○ 3.2 Create user registration endpoint with validation\n      ○ 3.3 Create login endpoint with token generation\n      ○ 3.4 Implement token refresh and logout endpoints\n\nNext steps:\n  - Run /task-next to start with subtask 3.1\n  - Run /task-show 3 to see full task details\n  - Run /task-status 3.1 in_progress to start manually\n```\n\n## Error Handling\n\n| Error | Resolution |\n|-------|------------|\n| Task not found | Show available task IDs |\n| Task already has subtasks | Suggest --force or work with existing |\n| Cannot expand subtask | Subtasks cannot have sub-subtasks |\n| Task is done | Cannot expand completed tasks |\n| Generation failed | Retry once, then show error |\n\n## Examples\n\n```bash\n# Expand task 3 into subtasks\n/task-expand 3\n\n# Expand with specific subtask count\n/task-expand 3 --num=6\n\n# Replace existing subtasks\n/task-expand 3 --force\n```\n\n## Related\n\n- Command: /task-show (view task and subtasks)\n- Command: /task-next (start working on subtask)\n- Command: /task-status (update subtask status)\n- Command: /task-parse (initial task generation)"
              },
              {
                "name": "/task-init",
                "description": null,
                "path": "plugins/taskflow/commands/task-init.md",
                "frontmatter": null,
                "content": "---\nname: task-init\ndescription: Initialize TaskFlow in current project\nargs: [--backend=local|plane|github] [--global]\nversion: \"2.0\"\n---\n\n# /task-init\n\nInitialize TaskFlow task tracking with backend selection.\n\n## Usage\n\n```bash\n/task-init                           # Interactive setup\n/task-init --backend=local           # Quick local setup\n/task-init --backend=plane --global  # Plane as global default\n```\n\n## Arguments\n\n| Flag | Description |\n|------|-------------|\n| `--backend` | Skip detection, use specified backend |\n| `--global` | Save config globally (all projects) |\n| `--project` | Save config for this project only |\n\n---\n\n## Workflow\n\n### Step 1: Check Existing Config\n\n```python\n# Check for existing config\nif exists(\"./.taskflow.local.md\"):\n    print(\"TaskFlow already configured for this project.\")\n    print(\"Use /task config to view or change settings.\")\n    return\n\nif exists(\"~/.gsc-plugins/taskflow.local.md\") and not args.project:\n    print(\"Global TaskFlow config exists.\")\n    response = AskUserQuestion({\n        \"question\": \"Use global config or create project-specific?\",\n        \"header\": \"Config\",\n        \"options\": [\n            {\"label\": \"Use global\", \"description\": \"Apply existing global settings\"},\n            {\"label\": \"Project config\", \"description\": \"Create settings for this project only\"}\n        ]\n    })\n    if response == \"Use global\":\n        print(\"Using global TaskFlow config.\")\n        return\n```\n\n### Step 2: Detect Available Backends\n\n→ See `_core/backend-loader.md` for detection logic\n\n```python\nbackends = detectBackends()\n# Returns: [\n#   {\"name\": \"local\", \"available\": True, ...},\n#   {\"name\": \"plane\", \"available\": True, \"workspace\": \"gsdev\", ...},\n#   {\"name\": \"github\", \"available\": True, \"owner\": \"user\", ...}\n# ]\n```\n\n### Step 3: Display Detection Results\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│  TaskFlow Setup                                             │\n├─────────────────────────────────────────────────────────────┤\n│                                                             │\n│  Detected integrations:                                     │\n│    ✓ Plane   - workspace: gsdev                             │\n│    ✓ GitHub  - authenticated as myuser                      │\n│    ✗ Linear  - not detected                                 │\n│                                                             │\n│  Default: Local .tasks/ (no setup required)                 │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘\n```\n\n### Step 4: Select Backend\n\n```python\nif args.backend:\n    selected = args.backend\nelse:\n    # Build options - local always first\n    options = [\n        {\"label\": \"Local only (Recommended)\", \"description\": \"Use .tasks/ - works offline\"}\n    ]\n    for b in backends:\n        if b[\"name\"] != \"local\" and b[\"available\"]:\n            options.append({\"label\": b[\"label\"], \"description\": b[\"description\"]})\n\n    selected = AskUserQuestion({\n        \"question\": \"Where should TaskFlow store tasks?\",\n        \"header\": \"Backend\",\n        \"options\": options\n    })\n```\n\n### Step 5: Backend-Specific Config\n\n#### Local (default)\n\nNo additional config needed.\n\n#### Plane\n\n```python\nif selected == \"Plane\":\n    # Get projects\n    projects = mcp__plane__list_projects(workspace_slug=detected_workspace)\n\n    project = AskUserQuestion({\n        \"question\": \"Which Plane project?\",\n        \"header\": \"Project\",\n        \"options\": [{\"label\": p[\"name\"], \"description\": \"\"} for p in projects[\"results\"]]\n    })\n\n    backend_config = {\n        \"workspace\": detected_workspace,\n        \"project\": project\n    }\n```\n\n#### GitHub\n\n```python\nif selected == \"GitHub\":\n    if detected_repo:\n        confirm = AskUserQuestion({\n            \"question\": f\"Use {detected_owner}/{detected_repo}?\",\n            \"header\": \"Repo\",\n            \"options\": [\n                {\"label\": \"Yes\", \"description\": f\"Use current repo\"},\n                {\"label\": \"Different\", \"description\": \"Specify another\"}\n            ]\n        })\n        if confirm == \"Yes\":\n            backend_config = {\"owner\": detected_owner, \"repo\": detected_repo}\n        else:\n            # Manual input needed\n            pass\n```\n\n### Step 6: Select Scope\n\n```python\nif not args.global and not args.project:\n    scope = AskUserQuestion({\n        \"question\": \"Save configuration for?\",\n        \"header\": \"Scope\",\n        \"options\": [\n            {\"label\": \"This project\", \"description\": \"Save to ./.taskflow.local.md\"},\n            {\"label\": \"All projects\", \"description\": \"Save to ~/.gsc-plugins/taskflow.local.md\"}\n        ]\n    })\nelse:\n    scope = \"All projects\" if args.global else \"This project\"\n```\n\n### Step 7: Write Config\n\n```python\nconfig_content = f\"\"\"---\nbackend: {selected.lower()}\n\n{selected.lower()}:\n{yaml_dump(backend_config)}\n\nhygiene:\n  requireCompletionNotes: true\n  requireBlockerReason: true\n  promptForNotes: true\n  autoSyncToWorklog: false\n---\n\n# TaskFlow Configuration\n\nInitialized: {datetime.now().isoformat()}\n\"\"\"\n\nif scope == \"This project\":\n    path = \"./.taskflow.local.md\"\nelse:\n    path = os.path.expanduser(\"~/.gsc-plugins/taskflow.local.md\")\n    os.makedirs(os.path.dirname(path), exist_ok=True)\n\nwrite_file(path, config_content)\n```\n\n### Step 8: Initialize Local Storage (if local backend)\n\n```python\nif selected.lower() == \"local\":\n    os.makedirs(\".tasks\", exist_ok=True)\n    write_json(\".tasks/tasks.json\", {\n        \"version\": \"2.0\",\n        \"project\": os.path.basename(os.getcwd()),\n        \"created\": datetime.now().isoformat(),\n        \"tasks\": []\n    })\n```\n\n### Step 9: Confirm\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│  TaskFlow initialized!                                      │\n├─────────────────────────────────────────────────────────────┤\n│                                                             │\n│  Backend: Local (.tasks/)                                   │\n│  Config:  ./.taskflow.local.md                              │\n│                                                             │\n│  Get started:                                               │\n│    /task-add \"Your first task\"                              │\n│    /task-parse docs/PRD/feature.md                          │\n│    /task-list                                               │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## Quick Setup (No Prompts)\n\n```bash\n# Local backend, project scope\n/task-init --backend=local\n\n# Plane backend, global scope\n/task-init --backend=plane --global\n\n# GitHub backend with current repo\n/task-init --backend=github\n```\n\n---\n\n## Reconfigure\n\n```bash\n# View current config\n/task config\n\n# Change backend\n/task config --backend=plane\n\n# Reset and re-init\n/task config --reset\n```\n\n---\n\n**Command Version:** 2.0\n**Triggers:** First-run setup flow\n"
              },
              {
                "name": "/task-list",
                "description": null,
                "path": "plugins/taskflow/commands/task-list.md",
                "frontmatter": null,
                "content": "---\nname: task-list\ndescription: List all tasks with status and filtering\nargs: [--status=...] [--priority=...] [--type=...] [--search=\"...\"]\nversion: \"2.0\"\n---\n\n# /task-list\n\nList tasks from the configured backend with optional filtering.\n\n## Usage\n\n```bash\n/task-list [--status=pending,in_progress] [--priority=high] [--type=epic] [--search=\"auth\"]\n```\n\n## Filters\n\n| Flag | Values | Description |\n|------|--------|-------------|\n| `--status` | pending, in_progress, done, blocked, deferred, cancelled | Filter by status |\n| `--priority` | high, medium, low | Filter by priority |\n| `--type` | epic, task, subtask | Filter by type |\n| `--search` | string | Full-text search |\n| `--limit` | number | Max results (default: 20) |\n\n---\n\n## Workflow\n\n### Step 1: Load Backend\n\n```python\nbackend = loadBackend()\nif not backend:\n    triggerSetup()\n    return\n```\n\n### Step 2: Build Filters & Fetch\n\n```python\nfilters = {}\nif args.status:\n    filters[\"status\"] = args.status.split(\",\")\nif args.priority:\n    filters[\"priority\"] = args.priority.split(\",\")\nif args.type:\n    filters[\"type\"] = args.type.split(\",\")\nif args.search:\n    filters[\"search\"] = args.search\nfilters[\"limit\"] = args.limit or 20\n\ntasks = backend.listTasks(filters)\n```\n\n### Step 3: Display\n\n```python\ninfo = backend.getBackendInfo()\n\n# Header\nprint(f\"TaskFlow Tasks ({info['type']})\")\nif info.get(\"externalUrl\"):\n    print(f\"→ {info['externalUrl']}\")\nprint()\n\n# Group by status\nfor status in [\"in_progress\", \"pending\", \"blocked\", \"done\"]:\n    group = [t for t in tasks if t[\"status\"] == status]\n    if group:\n        print(f\"{STATUS_LABELS[status]} ({len(group)})\")\n        for task in group:\n            print(formatTask(task))\n        print()\n\n# Summary\nprint(f\"Total: {len(tasks)} tasks\")\n```\n\n---\n\n## Output Format\n\n```\nTaskFlow Tasks (plane)\n→ https://plane.internal.muhaha.dev/gsdev/work\n\nIn Progress (2)\n● [HIGH] task-001: Implement user authentication\n● [MED]  task-002: Add input validation\n\nPending (3)\n○ [HIGH] task-003: Create API endpoints\n○ [MED]  task-004: Write unit tests\n○ [LOW]  task-005: Update documentation\n\nDone (1)\n✓ task-006: Set up project structure\n\nTotal: 6 tasks\n```\n\n---\n\n## Examples\n\n```bash\n/task-list                              # All tasks\n/task-list --status=pending             # Pending only\n/task-list --priority=high              # High priority\n/task-list --search=\"auth\"              # Search\n/task-list --type=epic                  # Epics only\n```\n\n---\n\n**Command Version:** 2.0\n"
              },
              {
                "name": "/task-migrate-config",
                "description": null,
                "path": "plugins/taskflow/commands/task-migrate-config.md",
                "frontmatter": null,
                "content": "---\nname: task-migrate-config\ndescription: Migrate from old JSON config to new .local.md format\nargs: [--dry-run] [--force] [--global]\nversion: \"2.0\"\n---\n\n# /task-migrate-config\n\nMigrate TaskFlow configuration from old JSON format to new `.local.md` format.\n\n## Usage\n\n```bash\n/task-migrate-config                    # Interactive migration\n/task-migrate-config --dry-run          # Preview changes without writing\n/task-migrate-config --force            # Overwrite existing .local.md\n/task-migrate-config --global           # Migrate to global config only\n```\n\n---\n\n## Old Config Format (v1.x)\n\n**Location:** `~/.claude/task-config.json`\n\n```json\n{\n  \"version\": \"1.1\",\n  \"environments\": {\n    \"my-machine\": {\n      \"hostname\": \"my-machine\",\n      \"workspacePath\": \"/home/user/projects\",\n      \"indexPath\": \"/home/user/projects/.task-index.json\"\n    }\n  },\n  \"defaults\": {\n    \"checkpoints\": [\"parse\", \"execute\", \"complete\"],\n    \"syncTodoWrite\": true,\n    \"defaultPriority\": \"medium\",\n    \"defaultNumTasks\": 10,\n    \"defaultTag\": \"master\"\n  }\n}\n```\n\n---\n\n## New Config Format (v2.x)\n\n**Location:** `~/.gsc-plugins/taskflow.local.md` (global) or `./.taskflow.local.md` (project)\n\n```yaml\n---\nbackend: local\n\nlocal:\n  path: .tasks/\n\n# Legacy settings preserved\nlegacy:\n  environments:\n    my-machine:\n      workspacePath: /home/user/projects\n      indexPath: /home/user/projects/.task-index.json\n\ndefaults:\n  defaultPriority: medium\n  defaultTag: master\n  checkpoints:\n    - parse\n    - execute\n    - complete\n  syncTodoWrite: true\n\nhygiene:\n  requireCompletionNotes: true\n  requireBlockerReason: true\n  promptForNotes: true\n  autoSyncToWorklog: false\n---\n\n# TaskFlow Configuration\n\nMigrated from ~/.claude/task-config.json on <timestamp>\n```\n\n---\n\n## Workflow\n\n### Step 1: Check for Existing Config\n\n```python\nold_config_path = os.path.expanduser(\"~/.claude/task-config.json\")\nnew_global_path = os.path.expanduser(\"~/.gsc-plugins/taskflow.local.md\")\nnew_project_path = \"./.taskflow.local.md\"\n\n# Check if old config exists\nif not os.path.exists(old_config_path):\n    print(\"No old config found at ~/.claude/task-config.json\")\n    print(\"Nothing to migrate. Use /task-init to create new config.\")\n    return\n\n# Check if new config already exists\nif os.path.exists(new_global_path) and not args.force:\n    print(f\"New config already exists: {new_global_path}\")\n    print(\"Use --force to overwrite, or delete it first.\")\n    return\n```\n\n### Step 2: Read Old Config\n\n```python\nwith open(old_config_path, 'r') as f:\n    old_config = json.load(f)\n\nversion = old_config.get(\"version\", \"1.0\")\nenvironments = old_config.get(\"environments\", {})\ndefaults = old_config.get(\"defaults\", {})\n\nprint(f\"Found TaskFlow config v{version}\")\nprint(f\"  Environments: {len(environments)}\")\nprint(f\"  Defaults: {len(defaults)} settings\")\n```\n\n### Step 3: Detect Available Backends\n\n```python\n# Detect what backends are available\nbackends = detectBackends()\n\n# Default to local (preserving v1.x behavior)\nsuggested_backend = \"local\"\n\n# If Plane or GitHub available, suggest but don't require\nif any(b[\"name\"] == \"plane\" and b[\"available\"] for b in backends):\n    print(\"\\n  Plane integration detected - you can switch after migration\")\nif any(b[\"name\"] == \"github\" and b[\"available\"] for b in backends):\n    print(\"  GitHub integration detected - you can switch after migration\")\n```\n\n### Step 4: Build New Config\n\n```python\ndef buildNewConfig(old_config, backend=\"local\"):\n    \"\"\"Convert old JSON config to new YAML format.\"\"\"\n\n    new_config = {\n        \"backend\": backend,\n        backend: {\"path\": \".tasks/\"} if backend == \"local\" else {},\n        \"defaults\": {},\n        \"hygiene\": {\n            \"requireCompletionNotes\": True,\n            \"requireBlockerReason\": True,\n            \"promptForNotes\": True,\n            \"autoSyncToWorklog\": False\n        }\n    }\n\n    # Map old defaults to new\n    old_defaults = old_config.get(\"defaults\", {})\n\n    if \"defaultPriority\" in old_defaults:\n        new_config[\"defaults\"][\"defaultPriority\"] = old_defaults[\"defaultPriority\"]\n\n    if \"defaultTag\" in old_defaults:\n        new_config[\"defaults\"][\"defaultTag\"] = old_defaults[\"defaultTag\"]\n\n    if \"checkpoints\" in old_defaults:\n        new_config[\"defaults\"][\"checkpoints\"] = old_defaults[\"checkpoints\"]\n\n    if \"syncTodoWrite\" in old_defaults:\n        new_config[\"defaults\"][\"syncTodoWrite\"] = old_defaults[\"syncTodoWrite\"]\n\n    # Preserve environment configs in legacy section (for reference)\n    if old_config.get(\"environments\"):\n        new_config[\"legacy\"] = {\n            \"environments\": old_config[\"environments\"],\n            \"note\": \"Preserved from v1.x config. Environments are no longer used in v2.x.\"\n        }\n\n    return new_config\n```\n\n### Step 5: Preview Changes (--dry-run)\n\n```python\nif args.dry_run:\n    print(\"\\n--- DRY RUN - No changes will be made ---\\n\")\n    print(\"Old config: ~/.claude/task-config.json\")\n    print(f\"New config: {new_global_path if args.global else 'auto-selected'}\")\n    print(\"\\nNew configuration would be:\")\n    print(\"---\")\n    print(yaml.dump(new_config, default_flow_style=False))\n    print(\"---\")\n    return\n```\n\n### Step 6: Choose Scope\n\n```python\nif not args.global:\n    scope = AskUserQuestion({\n        \"question\": \"Where should the migrated config be saved?\",\n        \"header\": \"Scope\",\n        \"options\": [\n            {\n                \"label\": \"Global (Recommended)\",\n                \"description\": f\"Save to {new_global_path}\"\n            },\n            {\n                \"label\": \"This project only\",\n                \"description\": f\"Save to {new_project_path}\"\n            }\n        ],\n        \"multiSelect\": False\n    })\n\n    target_path = new_global_path if \"Global\" in scope else new_project_path\nelse:\n    target_path = new_global_path\n```\n\n### Step 7: Backup Old Config\n\n```python\n# Create backup directory\nbackup_dir = os.path.expanduser(\"~/.claude/.backups\")\nos.makedirs(backup_dir, exist_ok=True)\n\n# Backup with timestamp\ntimestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\nbackup_path = f\"{backup_dir}/task-config.json.{timestamp}.bak\"\n\nshutil.copy2(old_config_path, backup_path)\nprint(f\"\\nBackup created: {backup_path}\")\n```\n\n### Step 8: Write New Config\n\n```python\n# Ensure target directory exists\nos.makedirs(os.path.dirname(target_path), exist_ok=True)\n\n# Convert to YAML frontmatter format\nyaml_content = f\"\"\"---\nbackend: {new_config[\"backend\"]}\n\n{new_config[\"backend\"]}:\n{indent(yaml.dump(new_config[new_config[\"backend\"]], default_flow_style=False), \"  \")}\n\ndefaults:\n{indent(yaml.dump(new_config[\"defaults\"], default_flow_style=False), \"  \")}\n\nhygiene:\n{indent(yaml.dump(new_config[\"hygiene\"], default_flow_style=False), \"  \")}\n\n{f\"legacy:\" + chr(10) + indent(yaml.dump(new_config.get(\"legacy\", {}), default_flow_style=False), \"  \") if new_config.get(\"legacy\") else \"\"}\n---\n\n# TaskFlow Configuration\n\nMigrated from ~/.claude/task-config.json\nDate: {datetime.now().isoformat()}\nOriginal version: {old_config.get(\"version\", \"unknown\")}\n\n## Changes in v2.0\n\n- Backend abstraction: Local, Plane, GitHub, Linear support\n- Task hygiene: Notes for decisions, gotchas, workarounds\n- Epic support: Complex tasks become epics with subtasks\n- Project/global scope: Per-project or global settings\n\n## Switch Backend\n\nTo use a different backend:\n\n```bash\n/task config --backend=plane\n/task config --backend=github\n```\n\"\"\"\n\nwith open(target_path, 'w') as f:\n    f.write(yaml_content)\n\nprint(f\"New config written: {target_path}\")\n```\n\n### Step 9: Offer to Remove Old Config\n\n```python\nresponse = AskUserQuestion({\n    \"question\": \"Remove old config file?\",\n    \"header\": \"Cleanup\",\n    \"options\": [\n        {\n            \"label\": \"Yes, remove it\",\n            \"description\": \"Delete ~/.claude/task-config.json (backup preserved)\"\n        },\n        {\n            \"label\": \"No, keep both\",\n            \"description\": \"Keep old config for reference\"\n        }\n    ],\n    \"multiSelect\": False\n})\n\nif \"Yes\" in response:\n    os.remove(old_config_path)\n    print(\"Old config removed.\")\nelse:\n    print(\"Old config preserved at ~/.claude/task-config.json\")\n```\n\n### Step 10: Confirm Success\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│  Migration Complete!                                        │\n├─────────────────────────────────────────────────────────────┤\n│                                                             │\n│  Old config: ~/.claude/task-config.json                     │\n│  New config: ~/.gsc-plugins/taskflow.local.md               │\n│  Backup: ~/.claude/.backups/task-config.json.20260112.bak   │\n│                                                             │\n│  Backend: local (default - preserves v1.x behavior)         │\n│  Environments: Preserved in 'legacy' section                │\n│                                                             │\n│  To switch backends:                                        │\n│    /task config --backend=plane                             │\n│    /task config --backend=github                            │\n│                                                             │\n│  Test your setup:                                           │\n│    /task-list                                               │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## Field Mapping\n\n| Old Field (v1.x) | New Field (v2.x) | Notes |\n|------------------|------------------|-------|\n| `version` | *(removed)* | Version in plugin.json |\n| `environments.*.workspacePath` | `legacy.environments.*.workspacePath` | Preserved for reference |\n| `environments.*.indexPath` | `legacy.environments.*.indexPath` | No longer used |\n| `defaults.checkpoints` | `defaults.checkpoints` | Direct mapping |\n| `defaults.syncTodoWrite` | `defaults.syncTodoWrite` | Direct mapping |\n| `defaults.defaultPriority` | `defaults.defaultPriority` | Direct mapping |\n| `defaults.defaultNumTasks` | *(removed)* | No longer configurable |\n| `defaults.defaultTag` | `defaults.defaultTag` | Direct mapping |\n| *(new)* | `backend` | Backend type |\n| *(new)* | `hygiene.*` | Task hygiene settings |\n\n---\n\n## Error Handling\n\n### Old Config Not Found\n\n```\nNo old config found at ~/.claude/task-config.json\n\nNothing to migrate. TaskFlow v2.0 will auto-configure on first use.\nRun /task-init or any /task-* command to get started.\n```\n\n### New Config Already Exists\n\n```\nTaskFlow v2.0 config already exists:\n  ~/.gsc-plugins/taskflow.local.md\n\nOptions:\n  1. Use --force to overwrite\n  2. Delete existing file and run migration again\n  3. Keep existing config (no migration needed)\n```\n\n### Invalid JSON in Old Config\n\n```\nError reading old config: ~/.claude/task-config.json\n\n  JSON parse error at line 5: unexpected token\n\nFix the JSON syntax error and try again, or use:\n  /task-init --force\nto create fresh config (old settings will be lost).\n```\n\n---\n\n## Examples\n\n```bash\n# Preview what migration would do\n/task-migrate-config --dry-run\n\n# Migrate to global config\n/task-migrate-config --global\n\n# Force overwrite existing config\n/task-migrate-config --force\n\n# Full migration with cleanup\n/task-migrate-config\n# Follow prompts to choose scope and cleanup\n```\n\n---\n\n**Command Version:** 2.0\n**One-time operation:** Only needed when upgrading from v1.x to v2.x\n"
              },
              {
                "name": "/task-next",
                "description": "Get the recommended next task to work on",
                "path": "plugins/taskflow/commands/task-next.md",
                "frontmatter": {
                  "description": "Get the recommended next task to work on"
                },
                "content": "# /task-next\n\nDetermine and display the optimal next task based on dependencies, priority, and status.\n\n## What This Command Does\n\n1. Load tasks from current tag's `tasks.json`\n2. Apply selection algorithm (dependencies satisfied, priority, blocking factor)\n3. **CHECKPOINT**: Present task for approval before starting\n4. On approval, mark as `in_progress` and sync to TodoWrite\n\n## Arguments\n\n- `--skip` - Skip the recommended task and show the next alternative\n- `--no-checkpoint` - Start immediately without confirmation\n- `--tag=<name>` - Get next task from specific tag (default: current tag)\n\n## Prerequisites\n\n- Project must be initialized (`.tasks/state.json` exists)\n- Current tag must have tasks\n- At least one task must be actionable (pending with satisfied dependencies)\n\n## Workflow\n\n### Step 1: Load Tasks\n\n**Load current tag and tasks:**\n\n```python\nif not exists(\".tasks/state.json\"):\n    error(\"TaskFlow not initialized.\")\n    suggest(\"Run /task-init first\")\n    exit()\n\nstate = read_json(\".tasks/state.json\")\ncurrent_tag = args.tag or state[\"currentTag\"]\ntasks_file = f\".tasks/tags/{current_tag}/tasks.json\"\n\nif not exists(tasks_file):\n    error(f\"Tag '{current_tag}' has no tasks file.\")\n    suggest(\"Run /task-parse to generate tasks\")\n    exit()\n\ndata = read_json(tasks_file)\ntasks = data[\"tasks\"]\n\nif not tasks:\n    error(\"No tasks in current tag.\")\n    suggest(\"Run /task-parse docs/PRD/your-feature.md\")\n    exit()\n```\n\n**Show tag context in output:**\n```\n[Tag: feat-auth]  # Only show if not 'master'\n```\n\n### Step 2: Check for In-Progress Tasks\n\nFirst, check if there's already a task in progress:\n\n```python\n# Check both top-level tasks and subtasks\nin_progress = []\nfor task in tasks:\n    if task[\"status\"] == \"in_progress\":\n        in_progress.append(task)\n    for subtask in task.get(\"subtasks\", []):\n        if subtask[\"status\"] == \"in_progress\":\n            in_progress.append({\"parent\": task, \"subtask\": subtask})\n\nif in_progress:\n    display_current_task(in_progress[0])\n    ask_continue_or_switch()\n```\n\n**If task already in progress:**\n```\n┌─────────────────────────────────────────────────────────────────┐\n│ You have a task in progress                                     │\n│ [Tag: master]                                                   │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│ ● Task 3: Implement user authentication                         │\n│   Priority: HIGH                                                │\n│   Started: 2025-11-29 14:30 (2 hours ago)                       │\n│                                                                 │\n│   Subtasks:                                                     │\n│   ✓ 3.1 Create registration endpoint                            │\n│   ● 3.2 Create login endpoint (in progress)                     │\n│   ○ 3.3 Create token refresh endpoint                           │\n│                                                                 │\n│   Acceptance Criteria remaining:                                │\n│   ☐ Users can log in and receive JWT token                      │\n│   ☐ Refresh token flow extends session                          │\n│                                                                 │\n├─────────────────────────────────────────────────────────────────┤\n│ Continue with this task?                                        │\n└─────────────────────────────────────────────────────────────────┘\n```\n\nUse AskUserQuestion:\n\n```json\n{\n  \"question\": \"Continue with current task?\",\n  \"header\": \"In Progress\",\n  \"options\": [\n    {\"label\": \"Continue\", \"description\": \"Keep working on this task\"},\n    {\"label\": \"Complete\", \"description\": \"Mark as done and get next\"},\n    {\"label\": \"Switch\", \"description\": \"Work on different task\"},\n    {\"label\": \"Block\", \"description\": \"Mark as blocked, get next\"}\n  ],\n  \"multiSelect\": false\n}\n```\n\n### Step 3: Select Next Task\n\nApply selection algorithm:\n\n```python\ndef get_next_task(tasks, skip_ids=None):\n    skip_ids = skip_ids or set()\n\n    # Build task lookup for dependency checking\n    task_map = {t[\"id\"]: t for t in tasks}\n\n    # Filter to actionable tasks\n    candidates = [t for t in tasks\n                  if t[\"status\"] in (\"pending\", \"blocked\")\n                  and t[\"id\"] not in skip_ids]\n\n    # Check dependency satisfaction\n    actionable = []\n    for task in candidates:\n        deps_satisfied = all(\n            task_map.get(dep_id, {}).get(\"status\") == \"done\"\n            for dep_id in task.get(\"dependencies\", [])\n        )\n        if deps_satisfied:\n            # If task was blocked but deps now satisfied, it's actionable\n            actionable.append(task)\n\n    if not actionable:\n        return None\n\n    # Calculate blocking factor (how many tasks depend on this one)\n    def count_dependents(task_id):\n        return sum(1 for t in tasks if task_id in t.get(\"dependencies\", []))\n\n    # Priority weights\n    priority_weight = {\"high\": 3, \"medium\": 2, \"low\": 1}\n\n    # Sort by: priority DESC, blocking_count DESC, id ASC\n    actionable.sort(key=lambda t: (\n        -priority_weight.get(t.get(\"priority\", \"medium\"), 2),\n        -count_dependents(t[\"id\"]),\n        t[\"id\"]\n    ))\n\n    return actionable[0]\n```\n\n**Handle subtask selection:**\n\nIf selected task has subtasks, return the first pending subtask instead:\n\n```python\ntask = get_next_task(tasks)\nif task and task.get(\"subtasks\"):\n    pending_subtasks = [s for s in task[\"subtasks\"] if s[\"status\"] == \"pending\"]\n    if pending_subtasks:\n        return {\"parent\": task, \"subtask\": pending_subtasks[0]}\nreturn task\n```\n\n### Step 4: Handle No Available Tasks\n\n**If all tasks blocked:**\n```\n┌─────────────────────────────────────────────────────────────────┐\n│ No actionable tasks available                                   │\n│ [Tag: master]                                                   │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│ Current status:                                                 │\n│   ✓ Done: 3 tasks                                               │\n│   ● In Progress: 1 task (Task 4)                                │\n│   ◌ Blocked: 2 tasks (waiting on Task 4)                        │\n│   ○ Pending: 0 tasks                                            │\n│                                                                 │\n│ Blocked tasks and their blockers:                               │\n│   Task 5 ← waiting on: Task 4 (in_progress)                     │\n│   Task 6 ← waiting on: Task 4 (in_progress), Task 5 (blocked)   │\n│                                                                 │\n│ Action needed:                                                  │\n│   Complete Task 4 to unblock Tasks 5, 6                         │\n│                                                                 │\n│ Run /task-show 4 to see details.                                │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n**If all tasks done:**\n```\n┌─────────────────────────────────────────────────────────────────┐\n│ All tasks complete!                                             │\n│ [Tag: master]                                                   │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│ Project: my-project                                             │\n│ Tasks completed: 8/8                                            │\n│ Duration: Started 2025-11-28, completed 2025-11-29              │\n│                                                                 │\n│ What's next?                                                    │\n│   • Parse another PRD: /task-parse docs/PRD/next-feature.md     │\n│   • Create new tag: /task-tag create phase-2                    │\n│   • Switch tags: /task-tag use feat-auth                        │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n**If no tasks at all:**\n```\n┌─────────────────────────────────────────────────────────────────┐\n│ No tasks in tag 'master'                                        │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│ Get started:                                                    │\n│   1. Create a PRD in docs/PRD/your-feature.md                   │\n│   2. Run: /task-parse docs/PRD/your-feature.md                  │\n│                                                                 │\n│ Or switch to a tag with tasks:                                  │\n│   /task-tag list                                                │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n### Step 5: CHECKPOINT - Confirm Task Start\n\nPresent the selected task for approval:\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│ Recommended Next Task                                           │\n│ [Tag: master]                                                   │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│ Task 3: Implement user authentication                           │\n│                                                                 │\n│ Priority:     HIGH                                              │\n│ Dependencies: ✓ All satisfied                                   │\n│   ✓ Task 1: Set up project structure (done)                     │\n│   ✓ Task 2: Implement database schema (done)                    │\n│                                                                 │\n│ Description:                                                    │\n│ Set up JWT-based authentication flow with login, logout, and    │\n│ token refresh capabilities.                                     │\n│                                                                 │\n│ Acceptance Criteria:                                            │\n│ ☐ Users can register with email/password                        │\n│ ☐ Users can log in and receive JWT token                        │\n│ ☐ Tokens expire after 24 hours                                  │\n│ ☐ Refresh token flow extends session                            │\n│                                                                 │\n│ Impact:                                                         │\n│ This task blocks 2 other tasks (4, 5)                           │\n│                                                                 │\n│ Alternatives available: 1 other actionable task                 │\n│                                                                 │\n├─────────────────────────────────────────────────────────────────┤\n│ Ready to start this task?                                       │\n└─────────────────────────────────────────────────────────────────┘\n```\n\nUse AskUserQuestion:\n\n```json\n{\n  \"question\": \"Ready to start this task?\",\n  \"header\": \"Start Task\",\n  \"options\": [\n    {\"label\": \"Yes\", \"description\": \"Mark as in_progress and begin\"},\n    {\"label\": \"Skip\", \"description\": \"Show next available task\"},\n    {\"label\": \"Expand\", \"description\": \"Break into subtasks first\"},\n    {\"label\": \"Details\", \"description\": \"Show full task details\"}\n  ],\n  \"multiSelect\": false\n}\n```\n\n### Step 6: Handle Response\n\n**If Yes:**\n- Update task status to `in_progress`\n- Update `updated` timestamp\n- Save to tasks.json\n- Sync to TodoWrite\n- Display \"Task started\" confirmation\n\n**If Skip:**\n- Add task ID to session skip list\n- Re-run selection excluding skipped tasks\n- If no more tasks available after skipping, inform user\n- Return to Step 5 with next candidate\n\n```\nSkipped Task 3. Checking for alternatives...\n\n[Shows next task or \"No other actionable tasks available\"]\n```\n\n**If Expand:**\n- Trigger `/task-expand <id>` flow\n- After expansion, return and show first subtask\n\n**If Details:**\n- Trigger `/task-show <id>` flow\n- After viewing, return to checkpoint\n\n### Step 7: Sync to TodoWrite\n\nOn task start, sync current state to TodoWrite:\n\n```python\ntodos = []\n\n# Current task (with subtasks if any)\nif task.get(\"subtasks\"):\n    for subtask in task[\"subtasks\"]:\n        todos.append({\n            \"content\": subtask[\"title\"],\n            \"status\": map_status(subtask[\"status\"]),\n            \"activeForm\": to_active_form(subtask[\"title\"])\n        })\nelse:\n    todos.append({\n        \"content\": task[\"title\"],\n        \"status\": \"in_progress\",\n        \"activeForm\": to_active_form(task[\"title\"])\n    })\n\n# Upcoming tasks for context (max 3)\nupcoming = get_next_tasks(tasks, exclude=task[\"id\"], limit=3)\nfor t in upcoming:\n    todos.append({\n        \"content\": t[\"title\"],\n        \"status\": \"pending\",\n        \"activeForm\": to_active_form(t[\"title\"])\n    })\n\nTodoWrite(todos=todos)\n\ndef map_status(task_status):\n    return {\n        \"done\": \"completed\",\n        \"in_progress\": \"in_progress\",\n        \"pending\": \"pending\",\n        \"blocked\": \"pending\",\n        \"deferred\": \"pending\"\n    }.get(task_status, \"pending\")\n\ndef to_active_form(title):\n    \"\"\"Convert 'Create login endpoint' to 'Creating login endpoint'\"\"\"\n    verb_mappings = {\n        \"Create\": \"Creating\",\n        \"Implement\": \"Implementing\",\n        \"Add\": \"Adding\",\n        \"Configure\": \"Configuring\",\n        \"Set up\": \"Setting up\",\n        \"Build\": \"Building\",\n        \"Write\": \"Writing\",\n        \"Fix\": \"Fixing\",\n        \"Update\": \"Updating\",\n        \"Remove\": \"Removing\",\n        \"Refactor\": \"Refactoring\",\n        \"Test\": \"Testing\",\n        \"Deploy\": \"Deploying\",\n    }\n    for verb, active in verb_mappings.items():\n        if title.startswith(verb + \" \"):\n            return title.replace(verb + \" \", active + \" \", 1)\n        if title.startswith(verb.lower() + \" \"):\n            return title.replace(verb.lower() + \" \", active.lower() + \" \", 1)\n    # Fallback: prepend \"Working on\"\n    return f\"Working on {title}\"\n```\n\n### Step 8: Confirm Start\n\n```\nTask started: Implement user authentication\n\n  Status: in_progress ●\n  Tag: master\n  Started: 2025-11-29 14:30\n\nAcceptance Criteria to complete:\n  ☐ Users can register with email/password\n  ☐ Users can log in and receive JWT token\n  ☐ Tokens expire after 24 hours\n  ☐ Refresh token flow extends session\n\nWhen done, run: /task-status 3 done\n\nTodoWrite synced ✓\n```\n\n## Edge Cases\n\n### Multiple Tasks In Progress\n\nIf somehow multiple tasks are in progress (shouldn't happen normally):\n\n```\nWarning: Multiple tasks are in progress:\n  ● Task 3: Implement authentication\n  ● Task 5: Add caching\n\nThis may indicate interrupted work. Please choose one to continue:\n```\n\n### All Skipped\n\nIf user skips all actionable tasks:\n\n```\nAll actionable tasks have been skipped.\n\nSkipped: Task 3, Task 5, Task 7\n\nOptions:\n  • Clear skips and start over: /task-next\n  • View all tasks: /task-list\n  • Work on a specific task: /task-status <id> in_progress\n```\n\n### Task Has Already-Started Subtasks\n\nIf task has subtasks and some are already in progress:\n\n```\nTask 3 has a subtask in progress:\n  ● 3.2 Create login endpoint\n\nContinue with subtask 3.2?\n```\n\n### Circular Skip Detection\n\nIf skip would create circular situation:\n\n```\nCannot skip Task 3 - it's the only actionable task.\n\nOptions:\n  • Start Task 3\n  • Mark a blocking task as done: /task-status <id> done\n  • Defer Task 3: /task-status 3 deferred\n```\n\n## Error Handling\n\n| Error | Resolution |\n|-------|------------|\n| No `.tasks/state.json` | Prompt to run `/task-init` |\n| Tag doesn't exist | Suggest valid tags or create new |\n| No tasks in tag | Prompt to run `/task-parse` |\n| No tasks file | Tag exists but no tasks.json - suggest parse |\n| All tasks blocked | Show blocking chain and how to unblock |\n| All tasks done | Celebrate and suggest next steps |\n| All tasks skipped | Offer to clear skips |\n\n## Examples\n\n```bash\n# Get next recommended task\n/task-next\n\n# Skip current recommendation\n/task-next --skip\n\n# Start without confirmation\n/task-next --no-checkpoint\n\n# Get next from specific tag\n/task-next --tag=feat-auth\n```\n\n## Related\n\n- Command: /task-list (see all tasks)\n- Command: /task-show (detailed task view)\n- Command: /task-status (mark task done)\n- Command: /task-expand (break into subtasks)\n- Command: /task-tag (manage tags)"
              },
              {
                "name": "/task-parse",
                "description": "Parse PRD document into structured tasks",
                "path": "plugins/taskflow/commands/task-parse.md",
                "frontmatter": {
                  "description": "Parse PRD document into structured tasks"
                },
                "content": "# /task-parse\n\nParse a Product Requirements Document (PRD) and generate structured, dependency-aware tasks.\n\n## What This Command Does\n\n1. Read the specified PRD file\n2. Analyze content using AI to extract tasks\n3. Generate structured tasks with dependencies and acceptance criteria\n4. **CHECKPOINT**: Present tasks for human review\n5. On approval, save to current tag's `tasks.json`\n6. Update central index stats\n\n## Arguments\n\n- `<prd-path>` - **Required.** Path to PRD file (relative to project root, typically `docs/PRD/*.md`)\n- `--num-tasks=N` - Optional. Hint for target number of tasks (default: 10)\n- `--append` - Append to existing tasks instead of replacing\n- `--tag=<name>` - Parse into specific tag (default: current tag)\n\n## Prerequisites\n\n- Project must be initialized (`/task-init` run first)\n- `.tasks/` directory must exist\n- PRD file should exist (typically in `docs/PRD/` directory)\n\n## PRD Location Convention\n\nPRD files should be stored in:\n```\n<project-root>/docs/PRD/<feature-name>.md\n```\n\nExamples:\n- `docs/PRD/user-authentication.md`\n- `docs/PRD/api-v2.md`\n- `docs/PRD/dashboard-redesign.md`\n\n## Workflow\n\n### Step 1: Validate Setup\n\n**Check TaskFlow initialized:**\n```python\nif not exists(\".tasks/state.json\"):\n    error(\"TaskFlow not initialized in this project.\")\n    suggest(\"Run /task-init first\")\n    exit()\n```\n\n**Load current tag:**\n```python\nstate = read_json(\".tasks/state.json\")\ncurrent_tag = args.tag or state[\"currentTag\"]\ntasks_file = f\".tasks/tags/{current_tag}/tasks.json\"\n\nif not exists(tasks_file):\n    error(f\"Tag '{current_tag}' does not exist.\")\n    suggest(f\"Run /task-tag create {current_tag}\")\n    exit()\n```\n\n### Step 2: Read PRD\n\n**Try to find and read PRD file:**\n\n```python\nprd_path = args.prd_path\n\n# Handle relative paths\nif not prd_path.startswith('/'):\n    prd_path = os.path.join(project_root, prd_path)\n\nif not exists(prd_path):\n    # Try common variations\n    alternatives = [\n        f\"docs/PRD/{prd_path}\",\n        f\"docs/PRD/{prd_path}.md\",\n        f\"docs/{prd_path}\",\n    ]\n    # Check each alternative...\n```\n\n**If file doesn't exist:**\n```\nPRD file not found: docs/PRD/feature.md\n\nSearched locations:\n  ✗ docs/PRD/feature.md\n  ✗ docs/PRD/feature\n  ✗ docs/feature.md\n\nAvailable PRDs in docs/PRD/:\n  • user-authentication.md (3.2 KB)\n  • api-redesign.md (5.1 KB)\n  • dashboard-v2.md (2.8 KB)\n\nUsage: /task-parse docs/PRD/<filename>.md\n```\n\n**If file is empty or too short:**\n```\nPRD file appears to be empty or incomplete: docs/PRD/feature.md\n\nSize: 45 bytes (expected: 500+ bytes for meaningful task generation)\n\nA good PRD typically includes:\n  • Feature description and goals\n  • User stories or use cases\n  • Technical requirements\n  • Success criteria\n  • Dependencies\n\nSee: ~/.claude/knowledge/guides/taskflow-design.md for PRD tips\n```\n\n**If file is very large (>50KB):**\n```\nPRD file is large: docs/PRD/full-spec.md (127 KB)\n\nLarge PRDs may generate many tasks. Options:\n  1. Parse anyway (may generate 20+ tasks)\n  2. Specify --num-tasks=N to limit scope\n  3. Split PRD into smaller feature documents\n\nProceed with full PRD? [Y/n]\n```\n\n### Step 3: Check Existing Tasks\n\n**If tag already has tasks and not using --append:**\n```\n┌─────────────────────────────────────────────────────────────────┐\n│ Tag 'master' already has tasks                                  │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│ Current tasks: 8 (3 done, 1 in progress, 4 pending)             │\n│ PRD source: docs/PRD/original-feature.md                        │\n│                                                                 │\n│ Parsing new PRD will REPLACE existing tasks.                    │\n│                                                                 │\n├─────────────────────────────────────────────────────────────────┤\n│ Options:                                                        │\n│   • Replace all tasks (existing progress lost)                  │\n│   • Append new tasks (use --append)                             │\n│   • Create new tag (use --tag=<name>)                           │\n│   • Cancel                                                      │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n### Step 4: Parse with AI\n\nUse the following prompt to generate tasks:\n\n---\n\n**SYSTEM PROMPT FOR TASK GENERATION:**\n\n```\nAnalyze this Product Requirements Document and generate a structured task breakdown.\n\n## Instructions\n1. Identify discrete, implementable units of work\n2. Establish dependencies (what must complete before what)\n3. Order by logical implementation sequence\n4. Each task should be completable in a focused work session (1-4 hours)\n5. Include clear, measurable acceptance criteria for each task\n6. Assign priority based on:\n   - high: Foundational work, blocks other tasks\n   - medium: Important features, some dependencies\n   - low: Nice-to-have, no blockers\n\n## Output Format\nReturn ONLY valid JSON matching this exact schema (no markdown, no explanation, no code fences):\n\n{\n  \"tasks\": [\n    {\n      \"id\": 1,\n      \"title\": \"<concise action-oriented title - start with verb>\",\n      \"description\": \"<what needs to be done and why - 1-3 sentences>\",\n      \"status\": \"pending\",\n      \"priority\": \"high|medium|low\",\n      \"dependencies\": [],\n      \"subtasks\": [],\n      \"acceptanceCriteria\": [\n        \"<specific, measurable criterion>\",\n        \"<another criterion>\"\n      ]\n    }\n  ]\n}\n\n## Rules\n- IDs must be sequential integers starting at 1\n- No circular dependencies allowed\n- Task 1 MUST have empty dependencies array (entry point)\n- Dependencies reference task IDs that must complete first\n- Each task needs 2-5 acceptance criteria\n- Titles should start with action verbs (Create, Implement, Add, Configure, etc.)\n- Keep descriptions focused on WHAT and WHY, not HOW\n- Do NOT include markdown code fences or any text outside the JSON\n\n## Target Task Count\nAim for approximately <NUM_TASKS> top-level tasks. Break down further only if a task would take more than 4 hours.\n\n## PRD Content\n<PRD_CONTENT>\n```\n\n---\n\n### Step 5: Validate Generated Tasks\n\n**Validation checks (in order):**\n\n1. **JSON Valid**: Parse without errors\n   - Strip markdown code fences if present\n   - Handle common JSON errors (trailing commas, single quotes)\n\n2. **Schema Complete**: All required fields present\n   ```python\n   required_fields = [\"id\", \"title\", \"description\", \"status\", \"priority\", \"dependencies\", \"acceptanceCriteria\"]\n   for task in tasks:\n       missing = [f for f in required_fields if f not in task]\n       if missing:\n           error(f\"Task {task.get('id', '?')} missing fields: {missing}\")\n   ```\n\n3. **No Circular Dependencies**: Build and validate graph\n   ```python\n   def has_cycle(tasks):\n       # Build adjacency list\n       # Run DFS cycle detection\n       # Return cycle path if found\n   ```\n\n4. **Dependencies Exist**: All referenced IDs valid\n   ```python\n   task_ids = {t[\"id\"] for t in tasks}\n   for task in tasks:\n       for dep in task[\"dependencies\"]:\n           if dep not in task_ids:\n               error(f\"Task {task['id']} depends on non-existent task {dep}\")\n   ```\n\n5. **Has Entry Point**: At least one task with no dependencies\n   ```python\n   entry_points = [t for t in tasks if not t[\"dependencies\"]]\n   if not entry_points:\n       error(\"No entry point task (all tasks have dependencies)\")\n   ```\n\n6. **IDs Sequential**: No gaps or duplicates\n   ```python\n   ids = sorted([t[\"id\"] for t in tasks])\n   expected = list(range(1, len(tasks) + 1))\n   if ids != expected:\n       error(f\"IDs should be {expected}, got {ids}\")\n   ```\n\n**If validation fails:**\n```\nValidation errors in generated tasks:\n\n  ✗ Task 3 depends on non-existent task 7\n  ✗ Circular dependency: 4 → 5 → 6 → 4\n  ✗ Task 2 missing 'acceptanceCriteria' field\n\nAttempting to fix automatically...\n[If fixable, show fixed version]\n[If not, offer to regenerate]\n```\n\n### Step 6: CHECKPOINT - Human Review\n\nPresent generated tasks for approval:\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│ PRD Parsed: <N> tasks generated                                 │\n│ Source: <prd-path>                                              │\n│ Tag: <current-tag>                                              │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  1. [HIGH] <Task 1 title>                                       │\n│     └── No dependencies                                         │\n│     └── Criteria: <count> acceptance criteria                   │\n│                                                                 │\n│  2. [HIGH] <Task 2 title>                          (needs: 1)   │\n│     └── Depends on: Task 1                                      │\n│     └── Criteria: <count> acceptance criteria                   │\n│                                                                 │\n│  3. [MED]  <Task 3 title>                          (needs: 1,2) │\n│     └── Depends on: Task 1, Task 2                              │\n│     └── Criteria: <count> acceptance criteria                   │\n│                                                                 │\n│  ... (show all tasks)                                           │\n│                                                                 │\n│ Summary:                                                        │\n│   HIGH: <count> | MEDIUM: <count> | LOW: <count>                │\n│   Estimated entry points: <count>                               │\n│   Max dependency depth: <count>                                 │\n│                                                                 │\n├─────────────────────────────────────────────────────────────────┤\n│ Review the task breakdown above.                                │\n└─────────────────────────────────────────────────────────────────┘\n```\n\nUse AskUserQuestion:\n\n```json\n{\n  \"question\": \"Approve this task breakdown?\",\n  \"header\": \"Task Review\",\n  \"options\": [\n    {\"label\": \"Approve\", \"description\": \"Save tasks and continue\"},\n    {\"label\": \"Edit\", \"description\": \"Modify specific tasks before saving\"},\n    {\"label\": \"Regenerate\", \"description\": \"Parse PRD again with different approach\"},\n    {\"label\": \"Cancel\", \"description\": \"Discard and exit\"}\n  ],\n  \"multiSelect\": false\n}\n```\n\n### Step 7: Handle Response\n\n**If Approve:**\n- Proceed to save\n\n**If Edit:**\n- Ask: \"Which task(s) to modify? (e.g., 1,3,5 or 'all')\"\n- For each task, ask what to change:\n  - Title\n  - Description\n  - Priority\n  - Dependencies\n  - Acceptance criteria\n- Re-display modified tasks and confirm\n\n**If Regenerate:**\n- Ask for guidance with AskUserQuestion:\n  ```json\n  {\n    \"question\": \"How should I adjust the task generation?\",\n    \"header\": \"Regenerate\",\n    \"options\": [\n      {\"label\": \"More tasks\", \"description\": \"Break down into smaller pieces\"},\n      {\"label\": \"Fewer tasks\", \"description\": \"Higher-level groupings\"},\n      {\"label\": \"Different focus\", \"description\": \"I'll provide specific guidance\"},\n      {\"label\": \"Try again\", \"description\": \"Same settings, fresh attempt\"}\n    ],\n    \"multiSelect\": false\n  }\n  ```\n- Adjust prompt based on response\n- Re-run Step 4\n\n**If Cancel:**\n- Exit without saving\n- Display: \"No changes made. PRD not parsed.\"\n\n### Step 8: Save Tasks\n\n**For --append mode:**\n```python\nexisting = read_json(tasks_file)\nmax_id = max([t[\"id\"] for t in existing[\"tasks\"]], default=0)\n\n# Renumber new tasks\nfor i, task in enumerate(new_tasks):\n    old_id = task[\"id\"]\n    task[\"id\"] = max_id + i + 1\n    # Update any internal dependencies\n    for t in new_tasks:\n        t[\"dependencies\"] = [\n            (max_id + d) if d == old_id else d\n            for d in t[\"dependencies\"]\n        ]\n\nexisting[\"tasks\"].extend(new_tasks)\nexisting[\"updated\"] = now_iso8601()\n```\n\n**Write to tag's tasks.json:**\n\n```json\n{\n  \"version\": \"1.0\",\n  \"project\": \"<project-name>\",\n  \"tag\": \"<current-tag>\",\n  \"prdSource\": \"<prd-path>\",\n  \"created\": \"<original-or-now>\",\n  \"updated\": \"<ISO-8601-now>\",\n  \"tasks\": [<generated-tasks>]\n}\n```\n\n### Step 9: Update Central Index\n\nUpdate project stats in central index:\n\n```python\nstats = {\n    \"total\": len(tasks),\n    \"pending\": len([t for t in tasks if t[\"status\"] == \"pending\"]),\n    \"in_progress\": len([t for t in tasks if t[\"status\"] == \"in_progress\"]),\n    \"done\": len([t for t in tasks if t[\"status\"] == \"done\"])\n}\nupdate_index(project_slug, stats, current_tag)\n```\n\n### Step 10: Confirm Success\n\n```\nTasks saved successfully!\n\n  Project: <project-name>\n  Tag: <current-tag>\n  PRD Source: <prd-path>\n  Tasks Created: <N>\n\n  Breakdown:\n    HIGH priority: <count>\n    MEDIUM priority: <count>\n    LOW priority: <count>\n\n  Entry points (no dependencies):\n    Task 1: <title>\n\nNext steps:\n  - Run /task-list to see all tasks\n  - Run /task-next to get started\n  - Run /task-show <id> for task details\n```\n\n## Edge Cases\n\n### PRD Contains Code Blocks\n\nThe parser should handle PRDs with embedded code examples without treating them as task content.\n\n### PRD Is Not English\n\n```\nNote: PRD appears to be in a non-English language.\nTask generation will proceed, but titles/descriptions will match PRD language.\n```\n\n### Very Few Requirements in PRD\n\n```\nWarning: PRD seems minimal. Only <N> tasks generated.\n\nThis might indicate:\n  • PRD needs more detail\n  • Feature is genuinely small\n  • Consider combining with other PRDs\n\nProceed anyway? [Y/n]\n```\n\n### Conflicting Dependencies Detected\n\nIf AI generates conflicting or illogical dependencies:\n\n```\nWarning: Dependency structure may have issues:\n\n  Task 5 depends on Task 6, but Task 6 depends on Task 5\n  This creates a circular dependency.\n\nAuto-fixing by removing dependency from Task 6 → Task 5.\nPlease review after approval.\n```\n\n## Error Handling\n\n| Error | Resolution |\n|-------|------------|\n| No `.tasks/` directory | Prompt to run `/task-init` first |\n| Tag doesn't exist | Suggest creating tag or using existing |\n| PRD file not found | List available PRDs in `docs/PRD/`, suggest path |\n| PRD file empty | Error with guidance on PRD content |\n| PRD file too large | Warn and offer options |\n| JSON parse failure | Strip fences, retry once, show raw on failure |\n| Circular dependency | Show cycle, auto-fix or regenerate |\n| Existing tasks | Offer replace/append/new-tag options |\n| User cancels | Confirm no changes made |\n\n## Examples\n\n```bash\n# Parse PRD for authentication feature\n/task-parse docs/PRD/user-authentication.md\n\n# Parse with target task count hint\n/task-parse docs/PRD/api-redesign.md --num-tasks=15\n\n# Add tasks from additional PRD (phase 2)\n/task-parse docs/PRD/phase2-features.md --append\n\n# Parse into specific tag\n/task-parse docs/PRD/experiment.md --tag=experimental\n```\n\n## Tips for Good PRDs\n\nThe quality of generated tasks depends on PRD quality. Good PRDs include:\n\n- Clear feature descriptions\n- User stories or use cases\n- Technical requirements or constraints\n- Success criteria\n- Non-functional requirements (performance, security)\n- Dependencies on external systems\n\n## Related\n\n- Command: /task-init (prerequisite)\n- Command: /task-list (view generated tasks)\n- Command: /task-next (start working)\n- Command: /task-tag (manage tags)\n- Design: ~/.claude/knowledge/guides/taskflow-design.md"
              },
              {
                "name": "/task-show",
                "description": "Display detailed information for a specific task",
                "path": "plugins/taskflow/commands/task-show.md",
                "frontmatter": {
                  "description": "Display detailed information for a specific task"
                },
                "content": "# /task-show\n\nDisplay comprehensive details for a specific task or subtask.\n\n## What This Command Does\n\n1. Load task by ID from `.tasks/tasks.json`\n2. Display all task details including acceptance criteria\n3. Show dependency status and blocking information\n4. Optionally sync to TodoWrite for visibility\n\n## Arguments\n\n- `<task-id>` - **Required.** Task ID (e.g., `3` or `3.2` for subtask)\n\n## Prerequisites\n\n- Project must have tasks (`.tasks/tasks.json` exists with tasks)\n\n## Workflow\n\n### Step 1: Parse Task ID\n\nHandle both task and subtask IDs:\n\n- `3` → Top-level task with id=3\n- `3.2` → Subtask 2 of task 3\n\n### Step 2: Load Task\n\nRead `.tasks/tasks.json` and find the specified task.\n\nIf not found:\n```\nTask <id> not found.\n\nAvailable tasks: 1, 2, 3, 4, 5\nRun /task-list to see all tasks.\n```\n\n### Step 3: Resolve Dependencies\n\nFor each dependency, check its current status:\n\n```python\nfor dep_id in task.dependencies:\n    dep_task = find_task(dep_id)\n    dep_status = dep_task.status\n    # Determine if satisfied (done) or blocking\n```\n\n### Step 4: Display Task Details\n\n**For top-level task:**\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│ Task 3: Implement user authentication                           │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│ Status:      ○ pending                                          │\n│ Priority:    HIGH                                               │\n│ Created:     2025-11-29 10:00                                   │\n│ Updated:     2025-11-29 12:30                                   │\n│                                                                 │\n├─────────────────────────────────────────────────────────────────┤\n│ Description                                                     │\n├─────────────────────────────────────────────────────────────────┤\n│ Set up JWT-based authentication flow with login, logout, and    │\n│ token refresh capabilities. Should integrate with existing      │\n│ user model from task 2.                                         │\n│                                                                 │\n├─────────────────────────────────────────────────────────────────┤\n│ Dependencies                                                    │\n├─────────────────────────────────────────────────────────────────┤\n│ ✓ Task 1: Set up project structure (done)                       │\n│ ● Task 2: Implement database schema (in_progress)               │\n│                                                                 │\n│ ⚠ BLOCKED: Waiting on task 2 to complete                        │\n│                                                                 │\n├─────────────────────────────────────────────────────────────────┤\n│ Acceptance Criteria                                             │\n├─────────────────────────────────────────────────────────────────┤\n│ ☐ Users can register with email/password                        │\n│ ☐ Users can log in and receive JWT token                        │\n│ ☐ Tokens expire after 24 hours                                  │\n│ ☐ Refresh token flow extends session                            │\n│ ☐ Invalid credentials return 401                                │\n│                                                                 │\n├─────────────────────────────────────────────────────────────────┤\n│ Subtasks                                                        │\n├─────────────────────────────────────────────────────────────────┤\n│ (none - run /task-expand 3 to break down)                       │\n│                                                                 │\n├─────────────────────────────────────────────────────────────────┤\n│ Blocking                                                        │\n├─────────────────────────────────────────────────────────────────┤\n│ This task blocks:                                               │\n│   → Task 4: Create API endpoints                                │\n│   → Task 5: Add rate limiting                                   │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n**For subtask:**\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│ Subtask 3.2: Create login endpoint                              │\n│ Parent: Task 3 - Implement user authentication                  │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│ Status:      ○ pending                                          │\n│                                                                 │\n├─────────────────────────────────────────────────────────────────┤\n│ Sibling Subtasks                                                │\n├─────────────────────────────────────────────────────────────────┤\n│ ✓ 3.1 Create user registration endpoint                         │\n│ ○ 3.2 Create login endpoint (this task)                         │\n│ ○ 3.3 Create token refresh endpoint                             │\n│ ○ 3.4 Create logout endpoint                                    │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n### Acceptance Criteria Display\n\n| Status | Display | Meaning |\n|--------|---------|---------|\n| Unchecked | ☐ | Not verified |\n| Checked | ☑ | Verified (when task done) |\n\nWhen task status is `done`, all criteria show as checked.\n\n### Dependency Status Icons\n\n| Icon | Meaning |\n|------|---------|\n| ✓ | Dependency satisfied (done) |\n| ● | Dependency in progress |\n| ○ | Dependency pending |\n| ◌ | Dependency blocked |\n\n## Error Handling\n\n| Error | Resolution |\n|-------|------------|\n| No `.tasks/tasks.json` | Prompt to run `/task-init` |\n| Task ID not found | Show available task IDs |\n| Invalid ID format | Show expected format (number or number.number) |\n\n## Examples\n\n```bash\n# Show task 3 details\n/task-show 3\n\n# Show subtask 3.2 details\n/task-show 3.2\n\n# Show first task\n/task-show 1\n```\n\n## Related\n\n- Command: /task-list (overview of all tasks)\n- Command: /task-next (get recommended next task)\n- Command: /task-status (update this task's status)\n- Command: /task-expand (break into subtasks)"
              },
              {
                "name": "/task-status",
                "description": "Update the status of a task",
                "path": "plugins/taskflow/commands/task-status.md",
                "frontmatter": {
                  "name": "task-status",
                  "description": "Update the status of a task",
                  "args": "<task-id> <status> [--note=\"...\"] [--force]",
                  "version": "2.0"
                },
                "content": "# /task-status\n\nUpdate task status with hygiene prompts and backend sync.\n\n## Usage\n\n```bash\n/task-status <task-id> <status> [--note=\"...\"] [--force]\n```\n\n## Status Values\n\n| Status | Meaning |\n|--------|---------|\n| `pending` | Not started |\n| `in_progress` | Currently working |\n| `done` | Completed |\n| `blocked` | Cannot proceed |\n| `deferred` | Postponed |\n| `cancelled` | Will not do |\n\n---\n\n## Workflow\n\n### Step 1: Load Backend\n\n→ See `_core/command-preamble.md`\n\n```python\nbackend = loadBackend()\nif not backend:\n    triggerSetup()\n    return\n```\n\n### Step 2: Get Task\n\n```python\ntask = backend.getTask(task_id)\nif not task:\n    print(f\"Task not found: {task_id}\")\n    print(\"\\nUse /task-list to see available tasks.\")\n    return\n```\n\n### Step 3: Validate Transition\n\n```python\nVALID_TRANSITIONS = {\n    \"pending\": [\"in_progress\", \"deferred\", \"cancelled\"],\n    \"in_progress\": [\"done\", \"blocked\", \"deferred\", \"pending\", \"cancelled\"],\n    \"blocked\": [\"pending\", \"in_progress\", \"cancelled\"],\n    \"deferred\": [\"pending\", \"cancelled\"],\n    \"done\": [],  # Final - requires --force\n    \"cancelled\": [],  # Final - requires --force\n    \"pending_review\": [\"pending\", \"in_progress\", \"done\", \"cancelled\"]\n}\n\ncurrent = task[\"status\"]\n\nif new_status not in VALID_TRANSITIONS.get(current, []):\n    if not args.force:\n        print(f\"Invalid transition: {current} → {new_status}\")\n        print(f\"Valid: {', '.join(VALID_TRANSITIONS[current])}\")\n        if current in [\"done\", \"cancelled\"]:\n            print(\"\\nUse --force to reopen completed/cancelled tasks.\")\n        return\n```\n\n### Step 4: Hygiene - Prompt for Notes\n\n→ See `_core/task-hygiene.md`\n\n```python\nif isAutonomous():\n    # Auto-generate note based on transition\n    if new_status == \"done\" and not args.note:\n        note = \"Task completed\"\n    elif new_status == \"blocked\" and not args.note:\n        note = \"Task blocked (no reason provided)\"\n    else:\n        note = args.note\nelse:\n    # Interactive - prompt based on config\n    note = promptForNote(current, new_status, task, args.note)\n```\n\n#### Completion Prompt (→ done)\n\n```python\nif new_status == \"done\" and config.hygiene.requireCompletionNotes:\n    if task[\"priority\"] == \"high\" or not args.note:\n        # Show acceptance criteria if present\n        if task.get(\"acceptanceCriteria\"):\n            print(\"Verify acceptance criteria:\")\n            for criterion in task[\"acceptanceCriteria\"]:\n                print(f\"  ☐ {criterion}\")\n            print()\n\n        response = AskUserQuestion({\n            \"question\": \"Add completion notes?\",\n            \"header\": \"Done\",\n            \"options\": [\n                {\"label\": \"Add notes\", \"description\": \"Capture outcome, gotchas, follow-ups\"},\n                {\"label\": \"Skip\", \"description\": \"Mark done without notes\"}\n            ]\n        })\n\n        if response == \"Add notes\":\n            note = input(\"Completion notes: \")\n```\n\n#### Blocker Prompt (→ blocked)\n\n```python\nif new_status == \"blocked\":\n    if config.hygiene.requireBlockerReason and not args.note:\n        print(\"What's blocking this task?\")\n        note = input(\"Reason: \")\n        if not note:\n            print(\"Blocker reason required. Use --note or provide reason.\")\n            return\n```\n\n### Step 5: Update Status\n\n```python\n# Update via backend (handles sync to external system)\ntask = backend.setStatus(task_id, new_status, note)\n```\n\n### Step 6: Check Epic Completion\n\n```python\n# If subtask completed, check if epic should complete\nif task.get(\"parentId\") and new_status == \"done\":\n    parent = backend.getTask(task[\"parentId\"])\n    siblings = backend.listTasks({\"parentId\": task[\"parentId\"]})\n\n    all_done = all(s[\"status\"] == \"done\" for s in siblings)\n    if all_done:\n        response = AskUserQuestion({\n            \"question\": f\"All subtasks done. Complete epic '{parent['title']}'?\",\n            \"header\": \"Epic\",\n            \"options\": [\n                {\"label\": \"Yes\", \"description\": \"Mark epic as done\"},\n                {\"label\": \"No\", \"description\": \"Keep epic in progress\"}\n            ]\n        })\n        if response == \"Yes\":\n            backend.setStatus(parent[\"id\"], \"done\", \"All subtasks completed\")\n```\n\n### Step 7: Worklog Sync\n\n```python\nif config.hygiene.autoSyncToWorklog and note:\n    # Promote valuable notes to worklog\n    if any(keyword in note.lower() for keyword in [\"gotcha\", \"workaround\", \"decision\", \"learned\"]):\n        mcp__worklog__store_memory(\n            key=f\"taskflow_{task_id}_{datetime.now().strftime('%Y%m%d')}\",\n            content=note,\n            memory_type=\"fact\",\n            importance=7,\n            tags=\"taskflow,auto-captured\"\n        )\n```\n\n### Step 8: Confirm & Suggest Next\n\n```python\n# Show confirmation\nprint(f\"\\nTask updated: {task['title']}\")\nprint(f\"  Status: {current} → {new_status}\")\n\nif backend.getBackendInfo()[\"type\"] != \"local\":\n    print(f\"  Synced: {task.get('externalUrl', 'external system')}\")\n\n# Suggest next task if completed\nif new_status == \"done\":\n    next_tasks = backend.listTasks({\"status\": [\"pending\"], \"limit\": 1})\n    if next_tasks:\n        print(f\"\\nNext task: {next_tasks[0]['title']}\")\n        print(f\"  /task-status {next_tasks[0]['id']} in_progress\")\n```\n\n---\n\n## Examples\n\n```bash\n# Start working on a task\n/task-status task-001 in_progress\n\n# Complete with notes\n/task-status task-001 done --note=\"Implemented with retry logic. Gotcha: needed exponential backoff\"\n\n# Block with reason\n/task-status task-002 blocked --note=\"Waiting on API credentials from client\"\n\n# Defer task\n/task-status task-003 deferred --note=\"Moving to phase 2\"\n\n# Reopen completed task\n/task-status task-001 in_progress --force\n```\n\n---\n\n## Backend Behavior\n\n| Backend | Status Update | Note |\n|---------|---------------|------|\n| Local | Update tasks.json | Append to notes array |\n| Plane | `update_issue(state_id)` | `add_comment()` |\n| GitHub | Label change + open/close | `gh issue comment` |\n\n---\n\n**Command Version:** 2.0\n**Uses:** Backend abstraction, Task hygiene"
              },
              {
                "name": "/task-tag",
                "description": "Manage TaskFlow tags for parallel work contexts",
                "path": "plugins/taskflow/commands/task-tag.md",
                "frontmatter": {
                  "description": "Manage TaskFlow tags for parallel work contexts"
                },
                "content": "# /task-tag\n\nManage tagged task lists for parallel work streams (feature branches, phases, experiments).\n\n## What This Command Does\n\nTags provide isolated task contexts. Each tag has its own `tasks.json`, allowing:\n- Parallel feature development without conflicts\n- Phase-based project organization\n- Experimental branches without affecting main tasks\n\n## Subcommands\n\n### `/task-tag` (no args)\nShow current tag and list all available tags.\n\n### `/task-tag list`\nList all tags with stats.\n\n### `/task-tag use <name>`\nSwitch to a different tag context.\n\n### `/task-tag create <name>`\nCreate a new tag (optionally from current git branch).\n\n### `/task-tag delete <name>`\nDelete a tag (with confirmation).\n\n### `/task-tag copy <from> <to>`\nCopy tasks from one tag to another.\n\n## Directory Structure\n\n```\n.tasks/\n├── config.json           # Project config\n├── state.json            # Current tag, timestamps\n└── tags/\n    ├── master/\n    │   └── tasks.json    # Default tag\n    ├── feat-auth/\n    │   └── tasks.json\n    └── phase-2/\n        └── tasks.json\n```\n\n## State File (`.tasks/state.json`)\n\n```json\n{\n  \"currentTag\": \"master\",\n  \"lastSwitched\": \"2025-11-29T14:30:00Z\",\n  \"tags\": {\n    \"master\": {\n      \"created\": \"2025-11-29T10:00:00Z\",\n      \"description\": \"Main task list\"\n    },\n    \"feat-auth\": {\n      \"created\": \"2025-11-29T12:00:00Z\",\n      \"description\": \"Authentication feature\",\n      \"branch\": \"feat/user-authentication\"\n    }\n  }\n}\n```\n\n## Workflow\n\n### Show Current Tag (`/task-tag`)\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│ TaskFlow Tags: my-project                                       │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│ Current: master                                                 │\n│                                                                 │\n│ Available tags:                                                 │\n│   • master (active)     8 tasks (3 done, 1 in progress)         │\n│   • feat-auth           5 tasks (0 done)                        │\n│   • phase-2             0 tasks                                 │\n│                                                                 │\n├─────────────────────────────────────────────────────────────────┤\n│ Commands:                                                       │\n│   /task-tag use <name>     Switch to tag                        │\n│   /task-tag create <name>  Create new tag                       │\n│   /task-tag delete <name>  Remove tag                           │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n### Create Tag (`/task-tag create <name>`)\n\n**Arguments:**\n- `<name>` - Tag name (lowercase, hyphens allowed, no spaces)\n- `--from-branch` - Auto-name from current git branch\n- `--copy-from=<tag>` - Copy tasks from another tag\n- `--description=\"...\"` - Optional description\n\n**Workflow:**\n\n1. Validate tag name (alphanumeric + hyphens, no spaces)\n2. Check tag doesn't already exist\n3. Create directory `.tasks/tags/<name>/`\n4. Create empty `tasks.json` (or copy if `--copy-from`)\n5. Update `state.json` with new tag\n6. Optionally switch to new tag\n\n```\n/task-tag create feat-auth --description=\"User authentication feature\"\n\nCreated tag: feat-auth\nLocation: .tasks/tags/feat-auth/tasks.json\nTasks: 0\n\nSwitch to this tag now? [Y/n]\n```\n\n**With --from-branch:**\n\n```bash\n# On branch feat/user-authentication\n/task-tag create --from-branch\n\nDetected branch: feat/user-authentication\nCreating tag: feat-user-authentication\n\nCreated tag: feat-user-authentication\nBranch linked: feat/user-authentication\n\nSwitch to this tag now? [Y/n]\n```\n\n### Switch Tag (`/task-tag use <name>`)\n\n**Workflow:**\n\n1. Validate tag exists\n2. Check for unsaved work in current tag (in_progress tasks)\n3. Update `state.json` with new current tag\n4. Display new context summary\n\n```\n/task-tag use feat-auth\n\n⚠ Warning: You have 1 task in progress on 'master':\n   Task 3: Implement caching\n\nSwitch anyway? This won't lose progress - you can switch back.\n[Y]es / [N]o / [C]omplete first\n\n> Y\n\nSwitched to tag: feat-auth\nTasks: 5 (0 done, 0 in progress, 5 pending)\n\nRun /task-next to start working.\n```\n\n### Delete Tag (`/task-tag delete <name>`)\n\n**Safeguards:**\n- Cannot delete currently active tag\n- Cannot delete `master` tag (protected)\n- Requires confirmation\n- Shows task count before deletion\n\n```\n/task-tag delete feat-auth\n\n⚠ Delete tag 'feat-auth'?\n   Contains: 5 tasks (2 done, 3 pending)\n   This cannot be undone.\n\nType 'delete feat-auth' to confirm:\n```\n\n### Copy Tasks (`/task-tag copy <from> <to>`)\n\n**Options:**\n- `--status=<status>` - Only copy tasks with specific status\n- `--renumber` - Renumber task IDs in destination (default: true)\n\n```\n/task-tag copy master phase-2 --status=pending\n\nCopying from 'master' to 'phase-2':\n  - 5 pending tasks selected\n  - IDs will be renumbered starting at 1\n\nProceed? [Y/n]\n\nCopied 5 tasks to 'phase-2'.\n```\n\n## Integration with Other Commands\n\nAll task commands operate on the **current tag**:\n\n- `/task-init` creates `master` tag by default\n- `/task-parse` saves to current tag\n- `/task-list` shows current tag's tasks\n- `/task-next` selects from current tag\n- `/task-status` updates in current tag\n\n**Tag-aware output:**\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│ Tasks: my-project [feat-auth]                                   │\n│        ^^^^^^^^^^^^^^^^^^^^^ shows current tag if not master    │\n├─────────────────────────────────────────────────────────────────┤\n```\n\n## Edge Cases\n\n### Tag Name Validation\n\nValid: `master`, `feat-auth`, `phase-2`, `v1-release`\nInvalid: `Feat Auth`, `feat/auth`, `master!`, `my tag`\n\n```\n/task-tag create \"my feature\"\n\nError: Invalid tag name 'my feature'\nTag names must be lowercase alphanumeric with hyphens only.\nExamples: feat-auth, phase-2, bugfix-login\n```\n\n### Non-existent Tag\n\n```\n/task-tag use nonexistent\n\nError: Tag 'nonexistent' does not exist.\n\nAvailable tags:\n  • master\n  • feat-auth\n\nCreate it with: /task-tag create nonexistent\n```\n\n### Protected Master Tag\n\n```\n/task-tag delete master\n\nError: Cannot delete 'master' tag.\nThe master tag is protected as the default context.\n\nTo remove all tasks from master, use /task-parse with a new PRD\nor manually clear .tasks/tags/master/tasks.json\n```\n\n### Git Branch Integration\n\nWhen `autoTagFromBranch: true` in config:\n\n```\n# Automatically detect and offer to create/switch tags based on git branch\n\n$ git checkout -b feat/new-feature\n\n# Next task command detects branch change\n/task-next\n\nDetected git branch: feat/new-feature\nNo matching tag found.\n\nCreate tag 'feat-new-feature' for this branch? [Y/n]\n```\n\n## Error Handling\n\n| Error | Resolution |\n|-------|------------|\n| Invalid tag name | Show naming rules and examples |\n| Tag already exists | Suggest `use` or `--force` to overwrite |\n| Tag not found | List available tags, suggest create |\n| Delete active tag | Must switch first |\n| Delete master | Blocked (protected) |\n| No `.tasks/` directory | Run `/task-init` first |\n\n## Examples\n\n```bash\n# Show current tag and list all\n/task-tag\n\n# Create tag for feature work\n/task-tag create feat-user-auth --description=\"User authentication\"\n\n# Create from current git branch\n/task-tag create --from-branch\n\n# Switch to different tag\n/task-tag use feat-user-auth\n\n# Copy pending tasks to new phase\n/task-tag create phase-2\n/task-tag copy master phase-2 --status=pending\n\n# Clean up completed feature branch\n/task-tag use master\n/task-tag delete feat-user-auth\n```\n\n## Related\n\n- Command: /task-init (creates master tag)\n- Command: /task-list (shows current tag's tasks)\n- Design: ~/.claude/knowledge/guides/taskflow-design.md"
              },
              {
                "name": "/task",
                "description": "TaskFlow orchestrator - conversational task management",
                "path": "plugins/taskflow/commands/task.md",
                "frontmatter": {
                  "description": "TaskFlow orchestrator - conversational task management"
                },
                "content": "# /task\n\nConversational interface for TaskFlow task management. Interprets natural language requests and routes to appropriate task commands.\n\n## What This Skill Does\n\n1. Parse natural language task management requests\n2. Route to appropriate `/task-*` command\n3. Provide contextual help and suggestions\n4. Handle multi-step workflows conversationally\n\n## Usage\n\nInvoke with natural language:\n\n```\n/task <natural language request>\n```\n\nOr just `/task` for status overview.\n\n## Request Routing\n\n| User Says | Routes To |\n|-----------|-----------|\n| \"initialize\", \"init\", \"set up tasks\" | `/task-init` |\n| \"parse\", \"generate tasks from\", \"read PRD\" | `/task-parse` |\n| \"list\", \"show all\", \"what tasks\" | `/task-list` |\n| \"next\", \"what should I work on\", \"what's next\" | `/task-next` |\n| \"show task N\", \"details for N\", \"what's task N\" | `/task-show N` |\n| \"done\", \"complete\", \"finished task N\" | `/task-status N done` |\n| \"start task N\", \"working on N\" | `/task-status N in_progress` |\n| \"expand\", \"break down task N\" | `/task-expand N` |\n| \"block\", \"blocked on N\" | `/task-status N blocked` |\n| \"defer\", \"postpone task N\" | `/task-status N deferred` |\n| \"help\", \"how do I\", \"what can you do\" | Show help |\n\n## Workflow\n\n### Step 1: Parse Intent\n\nAnalyze the user's request to determine intent:\n\n```python\nintents = {\n    \"init\": [\"initialize\", \"init\", \"set up\", \"create tasks\"],\n    \"parse\": [\"parse\", \"generate\", \"from prd\", \"read prd\", \"create from\"],\n    \"list\": [\"list\", \"show all\", \"all tasks\", \"what tasks\", \"overview\"],\n    \"next\": [\"next\", \"what should\", \"recommend\", \"what's next\", \"start\"],\n    \"show\": [\"show\", \"details\", \"tell me about\", \"what's task\", \"describe\"],\n    \"done\": [\"done\", \"complete\", \"finished\", \"mark done\", \"completed\"],\n    \"start\": [\"start\", \"begin\", \"working on\", \"in progress\"],\n    \"expand\": [\"expand\", \"break down\", \"split\", \"subtasks\"],\n    \"block\": [\"block\", \"blocked\", \"stuck\", \"waiting\"],\n    \"defer\": [\"defer\", \"postpone\", \"later\", \"skip\"],\n    \"help\": [\"help\", \"how\", \"what can\", \"commands\"]\n}\n\n# Extract task ID if present\ntask_id = extract_task_id(request)  # e.g., \"task 3\" → 3\n```\n\n### Step 2: Context Check\n\nBefore routing, check project context:\n\n```python\n# Check if in a project with tasks\nhas_tasks = exists(\".tasks/tasks.json\")\n\nif not has_tasks and intent not in [\"init\", \"help\"]:\n    suggest_init()\n    return\n```\n\n### Step 3: Route to Command\n\nExecute the appropriate command:\n\n```python\nif intent == \"init\":\n    execute(\"/task-init\")\nelif intent == \"parse\":\n    prd_path = extract_path(request) or prompt_for_prd()\n    execute(f\"/task-parse {prd_path}\")\nelif intent == \"list\":\n    filters = extract_filters(request)  # --status, --priority\n    execute(f\"/task-list {filters}\")\nelif intent == \"next\":\n    execute(\"/task-next\")\nelif intent == \"show\":\n    execute(f\"/task-show {task_id}\")\nelif intent == \"done\":\n    execute(f\"/task-status {task_id} done\")\nelif intent == \"start\":\n    execute(f\"/task-status {task_id} in_progress\")\nelif intent == \"expand\":\n    execute(f\"/task-expand {task_id}\")\nelif intent == \"block\":\n    execute(f\"/task-status {task_id} blocked\")\nelif intent == \"defer\":\n    execute(f\"/task-status {task_id} deferred\")\nelif intent == \"help\":\n    show_help()\n```\n\n### Step 4: Handle Ambiguity\n\nIf intent unclear, ask for clarification:\n\n```\nI'm not sure what you want to do. Did you mean:\n\n  • /task-list - See all tasks\n  • /task-next - Get next recommended task\n  • /task-show <id> - View specific task details\n\nOr tell me more about what you need.\n```\n\n## Context-Aware Responses\n\n### No Project Initialized\n```\nNo TaskFlow project found in current directory.\n\nTo get started:\n  1. Run /task-init to initialize\n  2. Create a PRD in docs/PRD/your-feature.md\n  3. Run /task-parse docs/PRD/your-feature.md\n\nOr run /task help for more information.\n```\n\n### Project Has No Tasks\n```\nTaskFlow is initialized, but no tasks yet.\n\nTo generate tasks:\n  1. Create a PRD document in docs/PRD/\n  2. Run: /task parse docs/PRD/your-prd.md\n\nAvailable PRDs found:\n  • docs/PRD/feature-spec.md\n  • docs/PRD/api-design.md\n```\n\n### Status Overview (just `/task`)\n```\n┌─────────────────────────────────────────────────────────────────┐\n│ TaskFlow: my-project                                            │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│ Progress: ████████░░░░░░░░ 50% (4/8 tasks)                      │\n│                                                                 │\n│ Current: Task 5 - Implement caching (in_progress)               │\n│ Next up: Task 6 - Add logging                                   │\n│                                                                 │\n│ Status breakdown:                                               │\n│   ✓ Done: 4                                                     │\n│   ● In Progress: 1                                              │\n│   ○ Pending: 2                                                  │\n│   ◌ Blocked: 1                                                  │\n│                                                                 │\n├─────────────────────────────────────────────────────────────────┤\n│ Quick actions:                                                  │\n│   /task done 5     - Complete current task                      │\n│   /task next       - See next recommendation                    │\n│   /task list       - View all tasks                             │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n## Example Conversations\n\n### Starting Fresh\n```\nUser: /task initialize\n→ Executes /task-init\n\nUser: /task parse the PRD at docs/PRD/auth-feature.md\n→ Executes /task-parse docs/PRD/auth-feature.md\n\nUser: /task what should I work on first?\n→ Executes /task-next\n```\n\n### During Development\n```\nUser: /task\n→ Shows status overview with current task\n\nUser: /task I finished the authentication task\n→ Executes /task-status 3 done (infers current task)\n\nUser: /task show me task 5\n→ Executes /task-show 5\n\nUser: /task break down task 6 into smaller pieces\n→ Executes /task-expand 6\n```\n\n### Handling Issues\n```\nUser: /task I'm blocked on task 4, waiting for API access\n→ Executes /task-status 4 blocked\n→ Optionally records note about API access\n\nUser: /task let's defer the caching task for now\n→ Executes /task-status 7 deferred\n\nUser: /task what's still pending?\n→ Executes /task-list --status=pending\n```\n\n## Help Output\n\nWhen user asks for help:\n\n```\nTaskFlow - AI-Powered Task Management\n\nCommands:\n  /task                    Status overview\n  /task init               Initialize in current project\n  /task parse <prd>        Generate tasks from PRD\n  /task list               List all tasks\n  /task next               Get next recommended task\n  /task show <id>          View task details\n  /task done <id>          Mark task complete\n  /task start <id>         Start working on task\n  /task expand <id>        Break into subtasks\n  /task block <id>         Mark task as blocked\n  /task defer <id>         Postpone task\n\nNatural language examples:\n  \"What should I work on next?\"\n  \"I finished task 3\"\n  \"Show me the details for task 5\"\n  \"Break down task 4 into smaller pieces\"\n  \"Parse the PRD at docs/PRD/feature.md\"\n\nDocumentation: ~/.claude/knowledge/guides/taskflow-design.md\n```\n\n## Error Handling\n\n| Situation | Response |\n|-----------|----------|\n| No task ID when required | Ask for task ID or show list |\n| Invalid task ID | Show available task IDs |\n| Ambiguous request | Ask for clarification with options |\n| Command fails | Show error and suggest fix |\n\n## Related\n\n- Design: ~/.claude/knowledge/guides/taskflow-design.md\n- Commands: /task-init, /task-parse, /task-list, /task-show, /task-next, /task-status, /task-expand"
              }
            ],
            "skills": []
          },
          {
            "name": "docs",
            "description": "Documentation management and validation with single source of truth philosophy",
            "source": "./plugins/docs",
            "category": null,
            "version": "1.0.0",
            "author": null,
            "install_commands": [
              "/plugin marketplace add gaurangrshah/gsc-plugins",
              "/plugin install docs@gsc-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-12T03:40:00Z",
              "created_at": "2025-12-13T22:09:06Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/docs-init",
                "description": null,
                "path": "plugins/docs/commands/docs-init.md",
                "frontmatter": null,
                "content": "---\nname: docs-init\ndescription: Initialize documentation structure for a project with frontmatter standards\nargs: [--path <dir>] [--guide <name>] [--global] [--with-worklog]\nversion: \"2.0\"\n---\n\n# /docs-init\n\nInitialize documentation structure and configuration.\n\n## Usage\n\n```bash\n/docs-init                              # Interactive setup\n/docs-init --path ~/docs                # Specify docs root\n/docs-init --global                     # Save as global default\n/docs-init --with-worklog               # Enable worklog integration\n```\n\n## Options\n\n| Flag | Description |\n|------|-------------|\n| `--path <dir>` | Documentation root directory |\n| `--guide <name>` | Main guide filename (default: `guide.md`) |\n| `--global` | Save config globally (`~/.gsc-plugins/docs.local.md`) |\n| `--project` | Save config for project only (`./.docs.local.md`) |\n| `--with-worklog` | Enable worklog integration |\n\n---\n\n## Workflow\n\n### Step 1: Check Existing Config\n\n```python\n# Check for existing configs\nproject_config = \"./.docs.local.md\"\nglobal_config = os.path.expanduser(\"~/.gsc-plugins/docs.local.md\")\n\nif os.path.exists(project_config):\n    print(\"Docs already configured for this project.\")\n    print(f\"Config: {project_config}\")\n    response = AskUserQuestion({\n        \"question\": \"What would you like to do?\",\n        \"header\": \"Config exists\",\n        \"options\": [\n            {\"label\": \"Keep existing\", \"description\": \"Exit without changes\"},\n            {\"label\": \"Reconfigure\", \"description\": \"Update configuration\"},\n            {\"label\": \"View config\", \"description\": \"Show current settings\"}\n        ]\n    })\n    if response == \"Keep existing\":\n        return\n    elif response == \"View config\":\n        showConfig(project_config)\n        return\n```\n\n### Step 2: Prompt for Settings\n\n```python\n# Use arg or prompt for docs_root\nif args.path:\n    docs_root = args.path\nelse:\n    response = AskUserQuestion({\n        \"question\": \"Where should documentation be stored?\",\n        \"header\": \"Docs Root\",\n        \"options\": [\n            {\"label\": \"~/docs (Recommended)\", \"description\": \"Standard location in home directory\"},\n            {\"label\": \"./docs\", \"description\": \"In current project directory\"},\n            {\"label\": \"Custom path\", \"description\": \"Specify a different location\"}\n        ]\n    })\n\n    if \"~/docs\" in response:\n        docs_root = \"~/docs\"\n    elif \"./docs\" in response:\n        docs_root = \"./docs\"\n    else:\n        docs_root = input(\"Enter documentation path: \")\n\n# Expand path\ndocs_root = os.path.expanduser(docs_root)\n```\n\n### Step 3: Detect Worklog\n\n```python\n# Check for worklog MCP tools\nworklog_mcp = tool_exists('mcp__worklog__store_knowledge')\n\n# Check for worklog.db in common locations\nworklog_db = None\nfor path in ['~/.claude/worklog/worklog.db', '~/.gsc-plugins/worklog.db']:\n    if os.path.exists(os.path.expanduser(path)):\n        worklog_db = path\n        break\n\n# Prompt for worklog integration\nif worklog_mcp or worklog_db or args.with_worklog:\n    if worklog_mcp:\n        print(\"Worklog MCP detected - can store learnings cross-project\")\n    elif worklog_db:\n        print(f\"Worklog database found: {worklog_db}\")\n\n    if not args.with_worklog:\n        response = AskUserQuestion({\n            \"question\": \"Enable worklog integration?\",\n            \"header\": \"Worklog\",\n            \"options\": [\n                {\"label\": \"Yes (Recommended)\", \"description\": \"Store learnings to shared knowledge base\"},\n                {\"label\": \"No\", \"description\": \"Keep documentation isolated\"}\n            ]\n        })\n        enable_worklog = \"Yes\" in response\n    else:\n        enable_worklog = True\nelse:\n    enable_worklog = False\n```\n\n### Step 4: Select Scope\n\n```python\nif not args.global and not args.project:\n    response = AskUserQuestion({\n        \"question\": \"Save configuration for?\",\n        \"header\": \"Scope\",\n        \"options\": [\n            {\"label\": \"This project\", \"description\": \"Save to ./.docs.local.md\"},\n            {\"label\": \"All projects (global)\", \"description\": \"Save to ~/.gsc-plugins/docs.local.md\"}\n        ]\n    })\n    scope = \"global\" if \"global\" in response.lower() else \"project\"\nelse:\n    scope = \"global\" if args.global else \"project\"\n```\n\n### Step 5: Create Directory Structure\n\n```python\n# Create docs directories\ndirs_to_create = [\n    docs_root,\n    f\"{docs_root}/security\",\n    f\"{docs_root}/guides\",\n    f\"{docs_root}/services\",\n    f\"{docs_root}/baselines\"\n]\n\nfor dir_path in dirs_to_create:\n    os.makedirs(dir_path, exist_ok=True)\n\n# Create subdirectory READMEs\nsubdirs = ['security', 'guides', 'services']\nfor subdir in subdirs:\n    readme_path = f\"{docs_root}/{subdir}/README.md\"\n    if not os.path.exists(readme_path):\n        writeSubdirReadme(readme_path, subdir)\n```\n\n### Step 6: Create Main Guide (if needed)\n\n```python\nguide_name = args.guide or \"guide.md\"\nmain_guide = f\"{docs_root}/{guide_name}\"\n\nif not os.path.exists(main_guide):\n    writeMainGuideTemplate(main_guide)\n    print(f\"Created main guide: {main_guide}\")\nelse:\n    print(f\"Main guide exists: {main_guide}\")\n```\n\n### Step 7: Create Frontmatter Schema\n\n```python\nschema_path = f\"{docs_root}/FRONTMATTER-SCHEMA.md\"\nif not os.path.exists(schema_path):\n    writeFrontmatterSchema(schema_path)\n```\n\n### Step 8: Write Config File\n\n```python\nknowledge_base = '~/.gsc-plugins/knowledge'\n\nconfig_content = f\"\"\"---\ndocs_root: {docs_root}\nmain_guide: {main_guide}\nknowledge_base: {knowledge_base}\n\nworklog:\n  enabled: {str(enable_worklog).lower()}\n  use_mcp: {str(worklog_mcp).lower()}\n{\"  db_path: \" + worklog_db if worklog_db and not worklog_mcp else \"\"}\n\ndefaults:\n  frontmatter_required: true\n  validate_on_save: false\n  journal_dir: /tmp\n---\n\n# Docs Configuration\n\n{\"Global\" if scope == \"global\" else \"Project\"} documentation settings.\nInitialized: {datetime.now().isoformat()}\n\n## Paths\n\n- **docs_root**: {docs_root}\n- **main_guide**: {main_guide}\n- **knowledge_base**: {knowledge_base}\n\n## Integration\n\n- **Worklog**: {\"Enabled\" if enable_worklog else \"Disabled\"}\n\"\"\"\n\n# Determine config path\nif scope == \"global\":\n    config_path = os.path.expanduser(\"~/.gsc-plugins/docs.local.md\")\n    os.makedirs(os.path.dirname(config_path), exist_ok=True)\nelse:\n    config_path = \"./.docs.local.md\"\n\nwith open(config_path, 'w') as f:\n    f.write(config_content)\n\nprint(f\"Config saved: {config_path}\")\n```\n\n### Step 9: Confirm Success\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│  Docs initialized!                                          │\n├─────────────────────────────────────────────────────────────┤\n│                                                             │\n│  Structure created:                                         │\n│    ~/docs/                                                  │\n│    ├── guide.md          (main guide)                       │\n│    ├── FRONTMATTER-SCHEMA.md                                │\n│    ├── security/                                            │\n│    ├── guides/                                              │\n│    ├── services/                                            │\n│    └── baselines/                                           │\n│                                                             │\n│  Config: ~/.gsc-plugins/docs.local.md (global)              │\n│  Worklog: Enabled (MCP)                                     │\n│                                                             │\n│  Next steps:                                                │\n│    1. Edit ~/docs/guide.md with your system info            │\n│    2. Run /docs-validate to check structure                 │\n│    3. Use inline updates for all changes                    │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## Templates\n\n### Main Guide Template\n\n```python\ndef writeMainGuideTemplate(path):\n    content = \"\"\"---\ntitle: \"System Guide\"\ntype: reference\ncreated: {date}\nupdated: {date}\n---\n\n# System Guide\n\n> Single source of truth for system configuration and operations.\n\n## Current State\n\n| Component | Status | Notes |\n|-----------|--------|-------|\n| Example   | ✅ OK  | -     |\n\n## Quick Reference\n\n### Access Points\n\n- **Service A**: https://...\n- **Service B**: https://...\n\n## Configuration\n\n### Section 1\n\nConfiguration details here.\n\n**Key Lessons:**\n- Lesson 1\n- Lesson 2\n\n### Section 2\n\nMore configuration.\n\n## Troubleshooting\n\n### Common Issues\n\n**Issue:** Description\n**Solution:** How to fix\n\n## Change History\n\n### {date}\n- Initial documentation created\n\"\"\".format(date=datetime.now().strftime('%Y-%m-%d'))\n\n    with open(path, 'w') as f:\n        f.write(content)\n```\n\n---\n\n## Examples\n\n```bash\n# Basic initialization (interactive)\n/docs-init\n\n# Initialize with specific path\n/docs-init --path ~/projects/myapp/docs\n\n# Initialize as global default\n/docs-init --global\n\n# Initialize with worklog integration\n/docs-init --with-worklog\n```\n\n---\n\n**Command Version:** 2.0\n**Creates:** Directory structure, config file, main guide template\n"
              },
              {
                "name": "/docs-reconcile",
                "description": "Reconcile a journal file into permanent documentation following decision tree routing",
                "path": "plugins/docs/commands/docs-reconcile.md",
                "frontmatter": {
                  "name": "docs-reconcile",
                  "description": "Reconcile a journal file into permanent documentation following decision tree routing"
                },
                "content": "# /docs-reconcile\n\nReconcile a journal file into permanent documentation.\n\n## Usage\n\n```\n/docs-reconcile <journal-path>\n```\n\n## What It Does\n\n1. **Reads and analyzes the journal**\n   - Parses entry types (Discovery, Decision, Blocker, Checkpoint, Completed)\n   - Identifies what changed (code, config, architecture, services)\n   - Extracts key decisions and rationale\n   - Notes lessons learned or gotchas\n\n2. **Determines documentation actions** using decision tree:\n   ```\n   System config change     → Update $MAIN_GUIDE inline\n   Service deployment       → Update services/ or $MAIN_GUIDE\n   Security change          → Update security/ AND $MAIN_GUIDE\n   Architecture decision    → $KNOWLEDGE_BASE/decisions/\n   Lesson learned           → Main guide \"Key Lessons\"\n   Cross-project pattern    → $KNOWLEDGE_BASE/guides/\n   Bug fix (non-trivial)    → Troubleshooting section\n   Code change only         → Project CHANGELOG\n   Trivial change           → No documentation needed\n   ```\n\n3. **Executes documentation updates**\n   - Makes inline updates (never separate incident files)\n   - Updates \"Current State\" tables if applicable\n   - Adds to \"Change History\" sections\n   - Validates frontmatter on new files\n\n4. **Stores to worklog.db** (if configured)\n   - Reusable learnings → `knowledge_base` table\n   - Work completion → `entries` table\n\n5. **Reports reconciliation results**\n   - What was updated\n   - What was skipped (and why)\n   - Confirms journal can be deleted\n\n## Journal Format Expected\n\n```markdown\n# Journal: Task Name\n\n## Task Started - HH:MM\n**Context:** What you're working on\n\n## Discovery - HH:MM\n**Context:** What you found\n**Content:** Details\n\n## Decision - HH:MM\n**Context:** What decision was needed\n**Content:** What was decided and why\n**Next:** What to do next\n\n## Blocker - HH:MM\n**Context:** What's blocking\n**Content:** Details\n**Resolution:** How resolved (if resolved)\n\n## Checkpoint - HH:MM\n**Context:** Progress update\n**Content:** What's done so far\n\n## Completed - HH:MM\n**Context:** Task completion\n**Content:** Summary of what was accomplished\n```\n\n## Examples\n\n**Basic reconciliation:**\n```\n/docs-reconcile /tmp/journal-fix-auth-2025-01-15.md\n```\n\n## Output\n\n```\n📝 Journal Reconciliation Report\n\nJournal: /tmp/journal-fix-auth-2025-01-15.md\nEntries found: 6 (2 decisions, 1 discovery, 1 completed)\n\n✅ Documentation Updated:\n- $MAIN_GUIDE: Added firewall rule to Current State\n- $MAIN_GUIDE: Added entry to Change History\n- $KNOWLEDGE_BASE/decisions/jwt-auth-strategy.md: Created\n\n⏭️  Skipped:\n- 2 checkpoint entries (context only)\n- 1 trivial discovery (no lasting value)\n\n📦 Stored to worklog.db:\n- knowledge_base: 1 new entry (JWT auth decision)\n- entries: 1 work log entry\n\n✅ Journal can be safely deleted\n```\n\n## Post-Reconciliation\n\nAfter successful reconciliation:\n1. Review the documentation updates\n2. Commit changes to git\n3. Delete the journal file\n4. Run `/docs-validate --quick` to verify\n\n## Integration\n\n- Works with docs-manager skill for documentation updates\n- Logs to worklog.db if configured\n- Respects frontmatter standards\n- Never creates separate incident files"
              },
              {
                "name": "/docs-validate",
                "description": "Run documentation validation checks for frontmatter, links, and structure compliance",
                "path": "plugins/docs/commands/docs-validate.md",
                "frontmatter": {
                  "name": "docs-validate",
                  "description": "Run documentation validation checks for frontmatter, links, and structure compliance"
                },
                "content": "# /docs-validate\n\nRun documentation validation checks.\n\n## Usage\n\n```\n/docs-validate [options]\n```\n\n## Options\n\n- `--quick` - Fast validation (frontmatter + obvious issues only)\n- `--path <dir>` - Validate specific directory (default: `$DOCS_ROOT`)\n- `--fix` - Attempt to auto-fix simple issues\n- `--report` - Generate detailed report to `/tmp/docs-validation-YYYY-MM-DD.md`\n\n## What It Checks\n\n### Quick Mode (`--quick`)\n- Frontmatter exists on all .md files\n- Required fields present (title, type, created)\n- No obvious broken links\n- ~1-2 minutes\n\n### Full Mode (default)\n- All quick mode checks\n- Internal link validation\n- README completeness\n- CHANGELOG compliance\n- Structure compliance\n- ~5-10 minutes\n\n## Validation Categories\n\n| Category | Severity | Example |\n|----------|----------|---------|\n| Missing frontmatter | Critical | File has no `---` block |\n| Broken link | Critical | Link to non-existent file |\n| Missing required field | Warning | No `created` date |\n| Orphaned file | Warning | Not referenced in README |\n| Missing README | Warning | Subdirectory without README.md |\n| Stale content | Info | Not updated in 90+ days |\n\n## Examples\n\n**Quick validation before commit:**\n```\n/docs-validate --quick\n```\n\n**Full validation with report:**\n```\n/docs-validate --report\n```\n\n**Validate specific directory:**\n```\n/docs-validate --path ~/docs/security\n```\n\n**Auto-fix simple issues:**\n```\n/docs-validate --fix\n```\n\n## Output\n\n**Console output:**\n```\n📋 Documentation Validation Report\n\nChecked: 42 files\nIssues: 3 critical, 5 warnings, 2 info\n\n❌ Critical Issues:\n- security/new-policy.md: Missing frontmatter\n- guides/README.md: Broken link to old-guide.md\n\n⚠️  Warnings:\n- 5 files not referenced in READMEs\n\nℹ️  Info:\n- Consider adding tags to 2 files\n\nFull report: /tmp/docs-validation-2025-01-15.md\n```\n\n## Auto-Fix Capabilities\n\nWhen `--fix` is used:\n\n| Issue | Auto-Fix Action |\n|-------|-----------------|\n| Missing frontmatter | Add minimal frontmatter template |\n| Missing created date | Add today's date |\n| Malformed date | Convert to YYYY-MM-DD |\n\n**Note:** Auto-fix creates backups before modifying files.\n\n## Integration with Worklog\n\nIf worklog plugin is configured, validation results are logged:\n\n```sql\nINSERT INTO entries (agent, task_type, title, details, outcome, tags)\nVALUES ('hostname', 'validation', 'Docs validation', 'details', 'outcome', 'docs,validation');\n```\n\n## Recommended Schedule\n\n| Frequency | Mode | When |\n|-----------|------|------|\n| Per commit | `--quick` | Before git commit |\n| Weekly | Full | During review |\n| Monthly | Full + `--report` | First of month |"
              }
            ],
            "skills": []
          }
        ]
      }
    }
  ]
}