{
  "owner": {
    "id": "edspencer",
    "display_name": "Ed Spencer",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/6929?u=95ab99d391aad9fc6f19500941ca7fdcf50377c4&v=4",
    "url": "https://github.com/edspencer",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 1,
      "total_commands": 14,
      "total_skills": 1,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "edspencer/claude-agents",
      "url": "https://github.com/edspencer/claude-agents",
      "description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-11-14T19:18:29Z",
        "created_at": "2025-11-12T18:07:31Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 541
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 329
        },
        {
          "path": "CLAUDE.md",
          "type": "blob",
          "size": 10216
        },
        {
          "path": "LICENSE",
          "type": "blob",
          "size": 1067
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 3736
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/product-team",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/product-team/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/product-team/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 439
        },
        {
          "path": "plugins/product-team/LICENSE",
          "type": "blob",
          "size": 1067
        },
        {
          "path": "plugins/product-team/README.md",
          "type": "blob",
          "size": 7668
        },
        {
          "path": "plugins/product-team/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/product-team/agents/agent-maker.md",
          "type": "blob",
          "size": 20723
        },
        {
          "path": "plugins/product-team/agents/browser-tester.md",
          "type": "blob",
          "size": 8458
        },
        {
          "path": "plugins/product-team/agents/code-checker.md",
          "type": "blob",
          "size": 6790
        },
        {
          "path": "plugins/product-team/agents/code-writer.md",
          "type": "blob",
          "size": 10922
        },
        {
          "path": "plugins/product-team/agents/documentation-manager.md",
          "type": "blob",
          "size": 26775
        },
        {
          "path": "plugins/product-team/agents/engineering-manager.md",
          "type": "blob",
          "size": 12327
        },
        {
          "path": "plugins/product-team/agents/plan-checker.md",
          "type": "blob",
          "size": 8948
        },
        {
          "path": "plugins/product-team/agents/plan-writer.md",
          "type": "blob",
          "size": 11054
        },
        {
          "path": "plugins/product-team/agents/process-manager.md",
          "type": "blob",
          "size": 19938
        },
        {
          "path": "plugins/product-team/agents/spec-checker.md",
          "type": "blob",
          "size": 7575
        },
        {
          "path": "plugins/product-team/agents/spec-writer.md",
          "type": "blob",
          "size": 8960
        },
        {
          "path": "plugins/product-team/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/product-team/commands/add-to-test-plan.md",
          "type": "blob",
          "size": 1060
        },
        {
          "path": "plugins/product-team/commands/agentic-create-plan.md",
          "type": "blob",
          "size": 5158
        },
        {
          "path": "plugins/product-team/commands/agentic-create-spec.md",
          "type": "blob",
          "size": 4115
        },
        {
          "path": "plugins/product-team/commands/agentic-implement-plan.md",
          "type": "blob",
          "size": 5137
        },
        {
          "path": "plugins/product-team/commands/agentic-spec-and-plan.md",
          "type": "blob",
          "size": 1445
        },
        {
          "path": "plugins/product-team/commands/check-code.md",
          "type": "blob",
          "size": 1122
        },
        {
          "path": "plugins/product-team/commands/check-plan.md",
          "type": "blob",
          "size": 3673
        },
        {
          "path": "plugins/product-team/commands/check-spec.md",
          "type": "blob",
          "size": 4442
        },
        {
          "path": "plugins/product-team/commands/create-issue.md",
          "type": "blob",
          "size": 2204
        },
        {
          "path": "plugins/product-team/commands/finish.md",
          "type": "blob",
          "size": 4260
        },
        {
          "path": "plugins/product-team/commands/run-integration-tests.md",
          "type": "blob",
          "size": 5147
        },
        {
          "path": "plugins/product-team/commands/write-code.md",
          "type": "blob",
          "size": 1861
        },
        {
          "path": "plugins/product-team/commands/write-plan.md",
          "type": "blob",
          "size": 7956
        },
        {
          "path": "plugins/product-team/commands/write-spec.md",
          "type": "blob",
          "size": 5049
        },
        {
          "path": "plugins/product-team/docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/product-team/docs/DOCUMENTATION-LOOKUP.md",
          "type": "blob",
          "size": 3328
        },
        {
          "path": "plugins/product-team/docs/processes",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/product-team/docs/processes/agent-rules.md",
          "type": "blob",
          "size": 731
        },
        {
          "path": "plugins/product-team/docs/processes/code-rules.md",
          "type": "blob",
          "size": 639
        },
        {
          "path": "plugins/product-team/docs/processes/plan-rules.md",
          "type": "blob",
          "size": 12744
        },
        {
          "path": "plugins/product-team/docs/processes/process-manager-rules.md",
          "type": "blob",
          "size": 16489
        },
        {
          "path": "plugins/product-team/docs/processes/spec-rules.md",
          "type": "blob",
          "size": 2658
        },
        {
          "path": "plugins/product-team/docs/standing-orders.md",
          "type": "blob",
          "size": 5942
        },
        {
          "path": "plugins/product-team/docs/team.md",
          "type": "blob",
          "size": 13241
        },
        {
          "path": "plugins/product-team/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/product-team/skills/github-task-sync",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/product-team/skills/github-task-sync/SKILL.md",
          "type": "blob",
          "size": 15155
        },
        {
          "path": "plugins/product-team/skills/github-task-sync/create-issue.sh",
          "type": "blob",
          "size": 4141
        },
        {
          "path": "plugins/product-team/skills/github-task-sync/lib-repo-detect.sh",
          "type": "blob",
          "size": 2515
        },
        {
          "path": "plugins/product-team/skills/github-task-sync/log-entry.sh",
          "type": "blob",
          "size": 3182
        },
        {
          "path": "plugins/product-team/skills/github-task-sync/pull-file.sh",
          "type": "blob",
          "size": 3248
        },
        {
          "path": "plugins/product-team/skills/github-task-sync/pull.sh",
          "type": "blob",
          "size": 4246
        },
        {
          "path": "plugins/product-team/skills/github-task-sync/push-file.sh",
          "type": "blob",
          "size": 4541
        },
        {
          "path": "plugins/product-team/skills/github-task-sync/push.sh",
          "type": "blob",
          "size": 5205
        },
        {
          "path": "plugins/product-team/skills/github-task-sync/read-issue-file.sh",
          "type": "blob",
          "size": 2967
        }
      ],
      "marketplace": {
        "name": "edspencer-agents",
        "version": "1.0.0",
        "description": null,
        "owner_info": {
          "name": "Ed Spencer",
          "email": "ed@edspencer.net"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "product-team",
            "description": "Comprehensive product development workflow with spec writing, planning, implementation, and testing agents plus GitHub integration",
            "source": "./plugins/product-team",
            "category": "Development",
            "version": "0.1.0",
            "author": {
              "name": "Ed Spencer",
              "email": "ed@edspencer.net"
            },
            "install_commands": [
              "/plugin marketplace add edspencer/claude-agents",
              "/plugin install product-team@edspencer-agents"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-11-14T19:18:29Z",
              "created_at": "2025-11-12T18:07:31Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/add-to-test-plan",
                "description": "Adds tests from a specific test file into our ongoing test plan",
                "path": "plugins/product-team/commands/add-to-test-plan.md",
                "frontmatter": {
                  "allowed-tools": "Bash, Edit, Grep, Read, WebSearch, WebFetch, Write(PLAN.md)",
                  "argument-hint": [
                    "test-file"
                  ],
                  "description": "Adds tests from a specific test file into our ongoing test plan"
                },
                "content": "# Add Tests to UI Test Plan\n\nYou are tasked with maintaining our UI test plan located at ./test/integration/TEST-PLAN.md.\n\nYour task is to add tests from the provided test file ($1) into the existing UI test plan. When adding tests:\n\n1. **Review the existing test plan** to understand current test coverage\n2. **Extract relevant tests** from the source test file ($1)\n3. **Avoid duplicates** - don't add tests that already exist in the plan\n4. **Merge intelligently** - combine similar tests rather than duplicating them\n5. **Maintain organization** - keep tests grouped by category/feature\n6. **Update test results** section if the source file contains test execution results\n7. **Add to \"Known Issues\"** section if any issues are documented in the source\n\nThe run-integration-tests SlashCommand will be used separately to run these tests via the Playwright test runner."
              },
              {
                "name": "/agentic-create-plan",
                "description": null,
                "path": "plugins/product-team/commands/agentic-create-plan.md",
                "frontmatter": null,
                "content": "---\nallowed-tools: Bash, Edit, Grep, Read, WebSearch, WebFetch, Write\nargument-hint: [spec-file] [instructions]\ndescription: Fully create a plan using sub agents, including comprehensive review and revision\n---\n\n## Task: Use sub agents to create an entire plan from start to finish\n\nYou will make extensive use of the following sub-agents:\n\n@plan-writer - Use this agent to create the plan\n@plan-checker - Use this agent to review and revise the plan\n\nThe sub-agents have specialized knowledge and abilities, but also, delegating to them allows you to use less of your LLM context on solving issues, as you are playing an orchestrator role. Try to delegate to these sub-agents as much as possible.\n\n## Process\n\n1. Read the entire SPEC.md file for the task at hand (unless you were just given a text description of the specification)\n2. Ask the plan writer agent to create a plan for the task at hand.\n3. Ask the plan checker agent to review and revise the plan.\n4. If the plan checker agent asks you to make changes to the plan, make those changes\n5. **Sync plan files to GitHub**: If working with a GitHub issue (task directory named `{issue-number}-{task-name}`), use the github-task-sync skill to push all plan files (PLAN.md, TEST_PLAN.md, COMMIT_MESSAGE.md) to the GitHub issue\n\nOnce you are done, please report back with the status of the plan.\n\n## Critical File Management Instructions\n\n**IMPORTANT:** The plan creation process should produce THREE FILES: `PLAN.md`, `TEST_PLAN.md`, and `COMMIT_MESSAGE.md`\n\n**When delegating to sub-agents, explicitly instruct them:**\n- The plan-writer agent will create PLAN.md, TEST_PLAN.md, and COMMIT_MESSAGE.md as part of the planning phase\n- Make all refinements directly within PLAN.md and TEST_PLAN.md rather than creating support documents\n- Do NOT create additional files such as:\n  - VALIDATION-REPORT.md\n  - IMPLEMENTATION-NOTES.md\n  - REVIEW-SUMMARY.md\n  - QUICK-REFERENCE.md\n  - IMPROVEMENTS-SUMMARY.md\n  - Or any other support documents\n- Include any validation findings, implementation notes, or review feedback directly in the appropriate sections of PLAN.md\n- All architectural decisions and technical details belong in PLAN.md, not separate files\n\n**Rationale:**\n- Keeps task directories clean and focused on core deliverables\n- Users expect PLAN.md, TEST_PLAN.md, and COMMIT_MESSAGE.md as standard outputs\n- COMMIT_MESSAGE.md provides a draft commit message that can be verified/updated at completion\n- Easier to version control and track changes\n- Reduces cognitive load for developers following the plan\n- Simplifies onboarding (fewer files to read)\n\n## Instructions\n\n- If, during investigation and creation of the plan, it becomes clear that the specification was not possible, immediately stop what you're doing and ask the user for how to proceed.\n\n## GitHub Sync Instructions\n\nWhen working with a GitHub issue:\n\n1. **Detect GitHub Issue**: Check if the task directory follows the pattern `tasks/{issue-number}-{task-name}/` (e.g., `tasks/196-team-page/`)\n2. **Extract Issue Number**: Parse the issue number from the directory name\n3. **Create Status Summary**: After plan-checker validation is complete, create a 2-paragraph summary of what the implementation plan covers (NOT a summary of the process that created it)\n4. **Push Plan to GitHub**: Use `push-file.sh` to sync with status summary:\n   ```bash\n   ~/.claude/plugins/marketplaces/edspencer-agents/plugins/product-team/skills/github-task-sync/push-file.sh {issue-number} PLAN {status-file} PLAN.md\n   ```\n5. **Push Other Files**: Use `push.sh` to sync TEST_PLAN.md and COMMIT_MESSAGE.md:\n   ```bash\n   ~/.claude/plugins/marketplaces/edspencer-agents/plugins/product-team/skills/github-task-sync/push.sh {issue-number} {task-directory}\n   ```\n\n**Status Summary Format:**\n\nThe status summary should be a 2-paragraph overview describing WHAT the plan will implement:\n\n```markdown\n**Status:** Complete\n\nThe implementation plan uses a phased approach to build [feature description] over [timeline]. It begins with [initial phases], progresses through [middle phases], and concludes with [final phases].\n\nKey phases include: (1) [Phase 1 description], (2) [Phase 2 description], (3) [Phase 3 description], and (4) [Final phase]. Each phase builds on previous work with clear dependencies and success criteria.\n\n- Key phase 1 (optional bullet points)\n- Key phase 2\n- Key phase 3\n```\n\n**Example:**\n```bash\n# After creating 2-paragraph status summary\n~/.claude/plugins/marketplaces/edspencer-agents/plugins/product-team/skills/github-task-sync/push-file.sh 196 PLAN plan-status.txt ./tasks/196-team-page/PLAN.md\n~/.claude/plugins/marketplaces/edspencer-agents/plugins/product-team/skills/github-task-sync/push.sh 196 ./tasks/196-team-page\n```\n\nThis creates/updates the PLAN comment on GitHub with:\n- Heading: \"Implementation Plan:\"\n- Status summary visible at top\n- Full plan content in collapsible `<details>` section\n- TEST_PLAN.md and COMMIT_MESSAGE.md as separate collapsible comments\n\n**Reference:** See `~/.claude/plugins/marketplaces/edspencer-agents/plugins/product-team/skills/github-task-sync/SKILL.md` for complete documentation.\n"
              },
              {
                "name": "/agentic-create-spec",
                "description": "Fully create a spec using sub agents, including comprehensive review and revision",
                "path": "plugins/product-team/commands/agentic-create-spec.md",
                "frontmatter": {
                  "allowed-tools": "Bash, Edit, Grep, Read, WebSearch, WebFetch, Write",
                  "argument-hint": [
                    "instructions"
                  ],
                  "description": "Fully create a spec using sub agents, including comprehensive review and revision"
                },
                "content": "## Task: Use sub agents to create an entire spec from start to finish\n\nYou will make extensive use of the following sub-agents:\n\n@spec-writer - Use this agent to create the spec\n@spec-checker - Use this agent to review and revise the spec\n\nThe sub-agents have specialized knowledge and abilities, but also, delegating to them allows you to use less of your LLM context on solving issues, as you are playing an orchestrator role. Try to delegate to these sub-agents as much as possible.\n\n## Process\n\n1. Ask the spec writer agent to create a spec for the task at hand.\n2. Ask the spec checker agent to review and revise the spec.\n3. If the spec checker agent asks you to make changes to the spec, make those changes\n4. **Sync SPEC.md to GitHub**: If working with a GitHub issue (task directory named `{issue-number}-{task-name}`), use the github-task-sync skill to push the completed SPEC.md to the GitHub issue as a collapsible comment\n5. Once you are done, please report back with the status of the spec.\n\n## Critical File Management Instructions\n\n**IMPORTANT:** The spec creation process should produce ONLY ONE FILE: `SPEC.md`\n\n**When delegating to sub-agents, explicitly instruct them:**\n- Make all refinements directly within SPEC.md rather than creating new support documents\n- Do NOT create additional files such as:\n  - VALIDATION-REPORT.md\n  - QUICK-REFERENCE.md\n  - IMPROVEMENTS-SUMMARY.md\n  - REVIEW-NOTES.md\n  - Or any other support documents\n- Include any review notes, validation findings, or improvement suggestions as inline comments or in a \"Review Summary\" section at the end of SPEC.md\n- All feedback and refinements must be incorporated directly into the SPEC.md content\n\n**Rationale:**\n- Keeps task directories clean and focused on core deliverables\n- Users expect only SPEC.md as the output\n- Easier to version control and track changes\n- Reduces cognitive load for developers reading the spec\n\n## Instructions\n\n- If, during investigation and creation of the spec, it becomes clear that the specification was not possible, immediately stop what you're doing and ask the user for how to proceed.\n\n## GitHub Sync Instructions\n\nWhen working with a GitHub issue:\n\n1. **Detect GitHub Issue**: Check if the task directory follows the pattern `tasks/{issue-number}-{task-name}/` (e.g., `tasks/196-team-page/`)\n2. **Extract Issue Number**: Parse the issue number from the directory name\n3. **Create Status Summary**: After spec-checker validation is complete, create a 2-paragraph summary of what the specification covers (NOT a summary of the process that created it)\n4. **Push to GitHub**: Use `push-file.sh` to sync with status summary:\n   ```bash\n   ~/.claude/plugins/marketplaces/edspencer-agents/plugins/product-team/skills/github-task-sync/push-file.sh {issue-number} SPEC {status-file} SPEC.md\n   ```\n\n**Status Summary Format:**\n\nThe status summary should be a 2-paragraph overview describing WHAT the spec covers:\n\n```markdown\n**Status:** Complete\n\nThis specification outlines requirements for [high-level feature description]. [Explain the scope and what problem it solves].\n\nKey requirements include: [list 3-5 most important requirements]. [Mention any important constraints, integrations, or technical considerations].\n\n- Key requirement 1 (optional bullet points)\n- Key requirement 2\n- Key requirement 3\n```\n\n**Example:**\n```bash\n# After creating 2-paragraph status summary in a temp file or variable\n~/.claude/plugins/marketplaces/edspencer-agents/plugins/product-team/skills/github-task-sync/push-file.sh 196 SPEC spec-status.txt ./tasks/196-team-page/SPEC.md\n```\n\nThis creates/updates the SPEC comment on GitHub with:\n- Heading: \"Specification:\"\n- Status summary visible at top\n- Full spec content in collapsible `<details>` section\n\n**Reference:** See `~/.claude/plugins/marketplaces/edspencer-agents/plugins/product-team/skills/github-task-sync/SKILL.md` for complete documentation."
              },
              {
                "name": "/agentic-implement-plan",
                "description": null,
                "path": "plugins/product-team/commands/agentic-implement-plan.md",
                "frontmatter": null,
                "content": "---\nallowed-tools: Bash, Edit, Grep, Read, WebSearch, WebFetch, Write\nargument-hint: [plan-file] [instructions]\ndescription: Fully implement a plan using sub agents\n---\n\n## Task: Use sub agents to implement an entire plan from start to finish\n\nYou will make extensive use of the following sub-agents:\n\n@code-writer - Use this agent to implement each phase of the plan\n@browser-tester - Use this agent to test the web app using Playwright after each phase of the plan (if there were UI changes)\n\nThe sub-agents have specialized knowledge and abilities, but also, delegating to them allows you to use less of your LLM context on solving issues, as you are playing an orchestrator role. Try to delegate to these sub-agents as much as possible.\n\n## Process\n\nRead the entire PLAN.md file you are given.\n\nStarting with Phase 1, delegate the implementation of the phase to the code writer agent. The code writer agent will have minimal context so you will have to give it the information it needs, which should include a reference to the PLAN.md file, which phase the agent should work on, any relevant context about the implementation so far, and so on. The code writer agent does have general context about this application, and understands how to look up technical docs.\n\nAfter the code writer agent finishes a batch of work and you check it: if it got something wrong that you can easily fix, fix it. If it got something wrong that needs extensive correction, stop and ask me for help\n\n### Process for each phase\n\nThe process for each phase is as follows (in order):\n\n1. Ask the code writer agent to implement the phase\n2. Check the code writer agent's implementation\n3. If it got something wrong that you can easily fix, fix it, else escalate to me\n4. Run the `lint`, `format`, `test`, and `build` commands at the project root to catch any issues early\n5. If the phase contains UI changes, ask the web app tester agent to test the web app using Playwright after the phase\n6. Check that the PLAN.md and LOG.md have been updated to reflect the completed work\n\nIf all of those checks pass, then the phase is complete and you can move on to the next phase. If any of those checks fail, you should stop and ask me for help.\n\n## Example run\n\nA typical full agentic implementation might look like this, for a PLAN.md containing 4 stages, where stages 2 and 3 contain UI changes that should be checked:\n\n1. You read the PLAN.md file\n2. You asked the code writer agent to implement phase 1\n3. You check what the code writer agent did in its phase 1 implementation and decided it was correct\n4. You asked the code writer agent to implement phase 2 (which contains UI changes)\n5. You check what the code writer agent did in its phase 2 implementation and decided it was correct\n6. You asked the web app tester agent to test the web app using Playwright after phase 2, because it contains UI changes\n7. You asked the code writer agent to implement phase 3 (which contains UI changes)\n8. You check what the code writer agent did in its phase 3 implementation and decided it was correct\n9. You asked the web app tester agent to test the web app using Playwright after phase 3, because it contains UI changes\n10. You asked the code writer agent to implement phase 4\n11. You check what the code writer agent did in its phase 4 implementation and decided it was correct\n\nAt this point, you should prepare your final report:\n\n## Creating the Final Commit Message\n\nBefore reporting back to the user, create a commit message for the completed work:\n\n1. **Check for COMMIT_MESSAGE.md**: Look for a COMMIT_MESSAGE.md file in the task directory\n2. **If COMMIT_MESSAGE.md exists:**\n   - Read the draft commit message that was created during planning\n   - Verify it still accurately reflects what was actually implemented across all phases\n   - If the implementation deviated significantly from the original plan (e.g., additional features added, approaches changed, scope adjusted):\n     - Update COMMIT_MESSAGE.md to reflect the actual implementation\n     - Ensure it mentions any major deviations or additions\n   - Use the (possibly updated) COMMIT_MESSAGE.md as the basis for your suggested commit message\n3. **If COMMIT_MESSAGE.md does not exist:**\n   - Create a commit message from scratch based on the actual changes made across all phases\n   - Follow the commit message guidelines below\n\n### Commit Message Guidelines\n\nThe commit message should:\n\n- Start with a 1-sentence summary on its own line\n- Briefly explain what was done and why\n- Typically be 2-4 paragraphs long (shorter for small changes, ~1-2 paragraphs for <300 LOC)\n- Call out any key architectural or API changes\n- Call out any key dependencies or tools being added/removed\n- Call out any key data model changes\n- Call out any key environment variable changes\n- Avoid value judgments (e.g., don't say \"improves\" or \"better\")\n- Keep it factual and not boastful\n\n## Final Report\n\nGive a full report back to the user, including:\n\n- Summary of all phases completed\n- Any issues encountered and how they were resolved\n- The suggested git commit message (based on COMMIT_MESSAGE.md if it existed)\n"
              },
              {
                "name": "/agentic-spec-and-plan",
                "description": "Write a spec and plan using sub agents",
                "path": "plugins/product-team/commands/agentic-spec-and-plan.md",
                "frontmatter": {
                  "allowed-tools": "Bash, Edit, Grep, Read, WebSearch, WebFetch, Write",
                  "argument-hint": [
                    "instructions"
                  ],
                  "description": "Write a spec and plan using sub agents"
                },
                "content": "## Task: Use sub agents to create an entire plan from start to finish\n\nThis SlashCommand is just a wrapper around the /agentic-create-spec and /agentic-create-plan SlashCommands. It should just call those SlashCommands in order.\n\n## Process\n\n1. Call the /agentic-create-spec SlashCommand\n2. Call the /agentic-create-plan SlashCommand\n3. Report back with the status of the plan\n\n## Instructions\n\n- If, during investigation and creation of the plan, it becomes clear that the specification was not possible, immediately stop what you're doing and ask the user for how to proceed.\n- You may be given a reference to a github issue or other ticket; if so, attempt to read the issue/ticket yourself first to make sure you have a clear understanding of the task at hand. Use that information to aid in your prompting of the sub agents via the slash commands.\n\n## GitHub Sync\n\n**Note:** If working with a GitHub issue, the `/agentic-create-spec` and `/agentic-create-plan` SlashCommands will automatically sync task files to GitHub:\n\n- After spec creation: SPEC.md will be pushed to GitHub issue\n- After plan creation: PLAN.md, TEST_PLAN.md, and COMMIT_MESSAGE.md will be pushed to GitHub issue\n\nThis ensures the GitHub issue stays synchronized throughout the specification and planning process."
              },
              {
                "name": "/check-code",
                "description": null,
                "path": "plugins/product-team/commands/check-code.md",
                "frontmatter": null,
                "content": "---\nallowed-tools: Bash, Edit, Grep, Read, WebSearch, WebFetch, Write\nargument-hint: [plan-file] [instructions]\ndescription: Check code implementation against plan and rules\n---\n\n# Check code implementation against plan and rules\n\nYour task is to check the code implementation of a plan ($1) against the plan requirements and code-rules.md. If you were given additional instructions ($2), please pay attention to them. Output a REVIEW.md of your findings and recommendations, and then offer to implement any of them that you think are most pressing (if any).\n\n## Instructions\n\n- Read the plan document carefully before starting to review the implementation\n- Look at the staged git changes to see what has been implemented (if nothing is staged, look at unstaged instead)\n- Check each part of the plan to see if it has been implemented fully and correctly\n- Do not build the apps/web app - the developer already has a dev build running on port 3000 and running build interferes with this\n- If you find any areas where the plan does not appear to have been implemented fully or correctly, please note them in the REVIEW.md\n"
              },
              {
                "name": "/check-plan",
                "description": null,
                "path": "plugins/product-team/commands/check-plan.md",
                "frontmatter": null,
                "content": "---\nallowed-tools: Bash, Edit, Grep, Read, WebSearch, WebFetch, Write\nargument-hint: [plan-file] [spec-file]\ndescription: Check a plan document against rules and suggest improvements\n---\n\n# Check a plan document against rules and suggest improvements\n\nYou have been given a plan document to check ($1). Your task is to fully read and understand the plan document, validate it against plan-rules.md, and suggest improvements if needed.\n\nYou may be given a spec document ($2) that the plan was based on, and you should compare the plan document against this spec document to ensure it is up to date and accurate.\n\n## Output\n\nYou should provide two outputs:\n\n### Output 1: Content Summary (For GitHub Comments)\n\nCreate a file called `PLAN-STATUS.md` containing a 2-paragraph content overview that someone can read to understand what the implementation plan covers. This should answer: \"What will be done if we follow this plan? What are the important phases, approach, and scope?\"\n\nFormat:\n- **First paragraph:** High-level overview of the implementation approach (phases, methodology, overall strategy)\n- **Second paragraph:** Key phases/components, timeline structure, and major deliverables\n- **Optional bullet points:** 3-5 bullet points highlighting the most important implementation phases or deliverables\n\nExample:\n```\nThe implementation plan uses a phased approach to build the user account deletion feature over 6 weeks. It begins with infrastructure setup and verification workflows, progresses through database cleanup and notification systems, and concludes with testing and documentation.\n\nKey phases include: (1) Creating the deletion request and verification system, (2) Implementing database cleanup with transaction safety, (3) Building notification to third parties, (4) Performance optimization and gradual deletion, and (5) Comprehensive testing and documentation. Each phase builds on previous work with clear dependencies and success criteria.\n\n- Phased implementation over 6 weeks with clear dependencies\n- Transaction-safe database cleanup with gradual removal\n- Comprehensive testing (unit, integration, performance)\n- Full audit logging and compliance documentation\n- Backwards compatibility maintained throughout\n```\n\n### Output 2: Validation Feedback Report\n\nReturn a comprehensive list of issues found and suggested improvements. Propose a set of edits to the file, but do not actually make them without user approval.\n\n## Instructions\n\n- Read the plan document carefully before starting to check it\n- Compare the plan document against the spec document if provided, extract any ways in which the plan deviates from the spec\n- Compare the plan document against ./.claude/docs/processes/plan-rules.md, extract any ways in which the plan deviates from the plan requirements\n- Check to see if the plan calls for the creation of any functions or features that don't seem to be used or called for and highlight them\n\n## Syncing Status to GitHub\n\nAfter generating PLAN-STATUS.md and your validation feedback, sync the status to the GitHub issue:\n\n1. **Determine issue number**: Extract from task directory name (format: `tasks/{issue-number}-{task-name}/`)\n2. **Push status to GitHub**: Use the `github-task-sync/push-file.sh` script to update the PLAN comment with status summary\n   ```bash\n   ~/.claude/plugins/marketplaces/edspencer-agents/plugins/product-team/skills/github-task-sync/push-file.sh <issue-number> PLAN PLAN-STATUS.md PLAN.md\n   ```\n\nThis keeps the GitHub issue updated with the current plan validation status. The PLAN-STATUS.md file provides the 2-paragraph summary that appears at the top of the collapsible PLAN comment on GitHub.\n"
              },
              {
                "name": "/check-spec",
                "description": "Validate a specification document against spec-rules.md",
                "path": "plugins/product-team/commands/check-spec.md",
                "frontmatter": {
                  "allowed-tools": "Bash, Grep, Read",
                  "argument-hint": [
                    "spec-file"
                  ],
                  "description": "Validate a specification document against spec-rules.md"
                },
                "content": "# Check a specification document against rules\n\nYour task is to validate a SPEC.md file ($1) against the requirements in spec-rules.md and provide structured feedback.\n\n## Your Task\n\nRead the specification document and validate it against Check `.claude/docs/processes/spec-rules.md` (project) OR `~/.claude/plugins/marketplaces/edspencer-agents/plugins/product-team/docs/processes/spec-rules.md` (plugin). This is a read-only validation task - do not modify the spec file.\n\n### Validation Checklist\n\nCheck the following aspects:\n\n**File Location and Naming:**\n- [ ] File is in `./tasks/[task-name]/SPEC.md` format\n- [ ] Task name is clear and descriptive\n\n**Required Structure:**\n- [ ] Has clear Task heading stating what needs to be done\n- [ ] Includes Background section explaining context and problem\n- [ ] Includes Current State section describing what exists\n- [ ] Includes Requirements section with detailed, numbered list\n- [ ] Includes Success Criteria section with testable criteria\n\n**Content Quality:**\n- [ ] Description is clear and comprehensive\n- [ ] Has enough detail for plan-writer to create implementation plan\n- [ ] Avoids large code snippets (except to illustrate patterns)\n- [ ] New dependencies are clearly called out\n- [ ] Includes relevant links to code, docs, or resources\n- [ ] Uses proper markdown formatting\n\n**Completeness:**\n- [ ] All necessary context is provided\n- [ ] Requirements are specific and actionable\n- [ ] Success criteria are testable and clear\n- [ ] No implementation details mixed with requirements\n\n## Output Format\n\nProvide a structured feedback report with two parts:\n\n### Part 1: Content Summary (For GitHub Comments)\n\nCreate a file called `SPEC-STATUS.md` containing a 2-paragraph content overview that someone can read to understand what the specification covers. This should answer: \"What requirements does this specification define? What is the scope and key goals?\"\n\nFormat:\n- **First paragraph:** High-level overview of what the spec calls for\n- **Second paragraph:** Key requirements, scope, and important constraints\n- **Optional bullet points:** 3-5 bullet points highlighting the most important requirements\n\nExample:\n```\nThis specification outlines requirements for implementing user account deletion functionality. The feature must allow users to permanently delete their accounts and associated data while maintaining system integrity and compliance with data protection regulations.\n\nKey requirements include: database cleanup of all user records, notification of deletion to third-party services, verification steps to prevent accidental deletion, and audit logging of all deletions. The implementation must support gradual data removal to avoid performance impact on the production system.\n\n- Permanent and irreversible account deletion with full data cleanup\n- Compliance with GDPR and data protection requirements\n- Deletion verification workflow to prevent accidents\n- Audit trail for compliance and security\n```\n\n### Part 2: Validation Feedback Report\n\n### Validation Summary\n- Overall assessment (Pass / Pass with suggestions / Needs revision)\n- Number of critical issues\n- Number of suggestions\n\n### Critical Issues\nList any missing required sections or major problems that must be fixed.\n\n### Suggestions\nList improvements that would enhance the spec quality.\n\n### Positive Observations\nNote what the spec does well.\n\n## Syncing Status to GitHub\n\nAfter generating SPEC-STATUS.md and your validation feedback, sync the status to the GitHub issue:\n\n1. **Determine issue number**: Extract from task directory name (format: `tasks/{issue-number}-{task-name}/`)\n2. **Push status to GitHub**: Use the `github-task-sync/push-file.sh` script to update the SPEC comment with status summary\n   ```bash\n   ~/.claude/plugins/marketplaces/edspencer-agents/plugins/product-team/skills/github-task-sync/push-file.sh <issue-number> SPEC SPEC-STATUS.md SPEC.md\n   ```\n\nThis keeps the GitHub issue updated with the current spec validation status. The SPEC-STATUS.md file provides the 2-paragraph summary that appears at the top of the collapsible SPEC comment on GitHub.\n\n## Next Steps\n\nIf there are critical issues, recommend revisions before proceeding to plan creation.\nIf the spec passes validation, confirm it's ready for the plan-writer agent."
              },
              {
                "name": "/create-issue",
                "description": "Create an issue based on instructions, optionally creating a spec and plan",
                "path": "plugins/product-team/commands/create-issue.md",
                "frontmatter": {
                  "allowed-tools": "Bash, Edit, Grep, Read, WebSearch, WebFetch, Write",
                  "argument-hint": [
                    "instructions"
                  ],
                  "description": "Create an issue based on instructions, optionally creating a spec and plan"
                },
                "content": "# Create an issue based on instructions\n\nYou're going to be given a variety of different possible instructions, but typically you're going to need to use the Github Task Sync skill to create an issue in the Github issues for this repository and potentially create a spec and a plan using the /agentic-create-spec and /agentic-create-plan commands. If the instructions don't specifically say don't do either one or both of those, then the default is that you should do so.\n\nYou are playing the role of orchestrator of these sub-agents, so it's important that you understand the issue yourself. However, you're going to delegate most of the work to the sub-agents to create spec and the plan. Then, you're going to report back afterwards as to what happened.\n\n## Label Determination\n\nBefore creating the issue, analyze the title and description to determine appropriate GitHub labels:\n\n**Available labels:**\n- `UI` - User interface related (buttons, styling, layout, components, forms, mobile responsiveness, themes)\n- `CLI` - Command-line interface related (commands, terminal, Git operations, flags, arguments)\n- `bug` - Bug fixes and issue resolutions (fix, broken, crash, error, regression)\n- `feature` - New features and enhancements (add, implement, support, new capability)\n\n**Decision process:**\n1. Scan the title and description for keyword patterns\n2. Apply multiple labels if the issue touches multiple areas (e.g., `UI,bug` for styling bug)\n3. Pass comma-separated labels to the `create-issue.sh` script via the 4th parameter\n4. Never apply both `bug` and `feature` to the same issue\n5. Tags are optional - only apply if context clearly matches\n\n**Example label decisions:**\n- \"Fix login button styling on mobile\" → `UI,bug` (UI styling + bug fix)\n- \"Add new extract command for filtering by date\" → `CLI,feature` (CLI command + new feature)\n- \"Resolve authentication redirect loop\" → `bug` (bug fix only)\n- \"Implement dark mode toggle in settings\" → `UI,feature` (UI component + new feature)"
              },
              {
                "name": "/finish",
                "description": null,
                "path": "plugins/product-team/commands/finish.md",
                "frontmatter": null,
                "content": "---\nallowed-tools: Bash, Edit, Grep, Read, WebSearch, WebFetch, Write\nargument-hint: [plan-file] [instructions]\ndescription: Finish a planned piece of work\n---\n\n# Finish a planned piece of work\n\nYou have been given a plan document that has been implemented ($1). Your task is to run final cleanup commands and propose a git commit message\n\n## Instructions\n\nYou should be able to do some or all of these in parallel:\n\n- Run `pnpm run build` at the project root, so we can catch any build failures early\n- Run `pnpm run test` at the project root, so we can catch any test failures early\n- Run `pnpm run format` at the project root, so we can catch any formatting issues early\n- Run `pnpm run lint` at the project root, so we can catch any lint issues early. Fix any lint issues that affect files you have edited\n\nGive your final thoughts on the implementation. If you find any issues, please note them now but do not attempt to fix them.\n\nIf everything looks like it was completely successful, archive this task by moving it from ./tasks/TASK-NAME to ./tasks/archive/TASK-NAME (use git mv for this)\n\n## Creating the Final Commit Message\n\nFollow these steps to create the final commit message:\n\n1. **Check for COMMIT_MESSAGE.md**: Look for a COMMIT_MESSAGE.md file in the task directory\n2. **If COMMIT_MESSAGE.md exists:**\n   - Read the draft commit message that was created during planning\n   - Verify it still accurately reflects what was actually implemented\n   - **Verify GitHub closing syntax** (if applicable): If the task directory follows `tasks/{issue-number}-{task-name}/` pattern:\n     - Check that the commit message includes the GitHub issue closing syntax at the end\n     - For bug fixes: Should end with `Fixes #{issue-number}`\n     - For features/other tasks: Should end with `Closes #{issue-number}`\n     - If missing, add the appropriate closing line before finalizing\n   - If the implementation deviated significantly from the original plan (e.g., additional features added, approaches changed, scope adjusted):\n     - Update COMMIT_MESSAGE.md to reflect the actual implementation\n     - Ensure it mentions any major deviations or additions\n     - Verify the GitHub closing syntax is still appropriate and present\n   - Use the (possibly updated) COMMIT_MESSAGE.md as the basis for your final commit message\n3. **If COMMIT_MESSAGE.md does not exist:**\n   - Create a commit message from scratch based on the actual changes made\n   - If the task directory follows `tasks/{issue-number}-{task-name}/` pattern, include the appropriate GitHub closing syntax (Fixes or Closes followed by the issue number)\n   - Follow the commit message guidelines below\n\n### Commit Message Guidelines\n\nYour git commit message should:\n- Start with a 1-sentence summary on its own line\n- Be a sentence or two if only a file or two were changed, many paragraphs if dozens of files were changed, and anything in between\n- Keep it factual and not boastful\n- Briefly explain what we're doing and why\n- Not just summarize the changes\n- Typically be 2-4 paragraphs long (shorter for small changes, ~1-2 paragraphs for <300 LOC)\n- Call out any key architectural or API changes\n- Call out any key dependencies or tools being added/removed\n- Call out any key data model changes\n- Call out any key environment variable changes\n- Avoid value judgments (e.g., don't say \"improves\" or \"better\")\n\n## Syncing Task Files to GitHub\n\nBefore archiving the task, sync all task files to the GitHub issue as the final step:\n\n1. **Determine the issue number**: Extract it from the task directory name (format: `tasks/{issue-number}-{task-name}/`)\n2. **Sync all files**: Run the push.sh skill to upload SPEC.md, PLAN.md, TEST_PLAN.md, and COMMIT_MESSAGE.md to the issue\n   ```bash\n   ~/.claude/plugins/marketplaces/edspencer-agents/plugins/product-team/skills/github-task-sync/push.sh <issue-number> <task-directory>\n   ```\n3. **Verify**: Confirm all files appear on the GitHub issue as collapsible comments\n4. **Archive task**: After syncing, move the task directory to ./tasks/archive/ using `git mv`\n\nThis ensures all documentation is centralized on the GitHub issue before the task is archived.\n\n---\n\nDon't stage anything or commit anything, just propose the final git commit message now:\n"
              },
              {
                "name": "/run-integration-tests",
                "description": "Run Integration tests from the test plan via Playwright hitting the live UI",
                "path": "plugins/product-team/commands/run-integration-tests.md",
                "frontmatter": {
                  "allowed-tools": "Bash, Edit, Grep, Read, WebSearch, WebFetch, Write(test/REPORT.md)",
                  "argument-hint": [
                    "optional-instructions"
                  ],
                  "description": "Run Integration tests from the test plan via Playwright hitting the live UI"
                },
                "content": "# Run Integration Tests\n\nIf not given specific instructions otherwise, run all tests listed in `./test/integration/TEST-PLAN.md` systematically, using their Comprehensive Tests section. If given a more specific set of instructions, follow them instead.\n\nExecute the test plan using Playwright automation. Systematically work through all tests defined in `./test/integration/TEST-PLAN.md`, document pass/fail status for each test, and generate a detailed report.\n\n## Execution Process\n\n### 1. Session Initialization\n\nALWAYS begin by:\n\n1. Navigate to http://ngrok.edspencer.net/demo\n2. Click the button to create a demo account\n3. Wait for successful authentication before proceeding\n\nALWAYS finish by:\n\n1. Logging out of the application (just navigate to /logout) - this will clear the database of cruft demo data\n\n### 2. Test Execution\n\nWork through ALL test sections in `./test/integration/TEST-PLAN.md` systematically. For each test:\n\n- Execute the test steps using Playwright MCP tools\n- Record PASS or FAIL status\n- Note any console errors or warnings\n- Do NOT attempt to debug failures - just document them\n\n### 3. Testing Guidelines\n\n**DO:**\n\n- Navigate by clicking links and UI elements (not direct URLs except /demo)\n- Check browser console regularly\n- Test systematically through all items\n- Record exact error messages when failures occur\n- Note visual issues or unexpected behavior\n\n**DO NOT:**\n\n- Skip tests or categories\n- Attempt to debug or fix issues found\n- Make code changes\n- Stop testing when failures are found - continue through all tests\n- Navigate to URLs directly (except initial /demo)\n\n### 4. Playwright MCP Usage\n\nUse Playwright MCP tools extensively:\n\n- `browser_navigate` - Navigate to pages\n- `browser_snapshot` - Capture accessibility snapshots (preferred for testing)\n- `browser_take_screenshot` - Take visual screenshots\n- `browser_click` - Click elements\n- `browser_type` - Fill forms\n- `browser_console_messages` - Check for errors\n- `browser_wait_for` - Wait for elements or text\n\n### 5. Report Generation\n\nAfter testing is complete, generate a comprehensive report at `./test/integration/runs/YYYY-MM-DD-N/REPORT.md` (where N is an index for multiple runs on the same day).\n\nThe report should have the following structure:\n\n```markdown\n# UI Test Execution Report\n\n**Date**: [Current date]\n**Tested By**: Claude Code (UI Test Runner)\n**Environment**: http://ngrok.edspencer.net\n**Browser**: Playwright Chromium\n\n---\n\n## Executive Summary\n\n- **Total Tests**: [number]\n- **Passed**: [number] ([percentage]%)\n- **Failed**: [number] ([percentage]%)\n- **Skipped**: [number] (if any)\n- **Overall Status**: PASS | FAIL | PARTIAL\n\n**Critical Issues Found**: [number]\n**Major Issues Found**: [number]\n**Minor Issues Found**: [number]\n\n---\n\n## Test Results by Category\n\n### 1. Navigation - Sidebar\n\n**Status**: PASS | FAIL | PARTIAL\n**Tests Passed**: X/Y\n\n#### 1.1 Sidebar Structure\n\n- [x] Test name - PASS\n- [ ] Test name - FAIL: [brief reason]\n- [x] Test name - PASS\n\n[Continue for each test...]\n\n---\n\n### 2. Navigation - Careers Section\n\n[Same format as above]\n\n---\n\n### 3. Coming Soon Pages\n\n[Same format as above]\n\n---\n\n[Continue for all categories...]\n\n---\n\n## Issues Found\n\n### Critical Issues\n\n[None found] OR:\n\n1. **Issue**: [Brief description]\n   - **Location**: [Where it occurs]\n   - **Steps to Reproduce**: [Exact steps]\n   - **Expected**: [What should happen]\n   - **Actual**: [What actually happens]\n   - **Evidence**: [Screenshot references, console errors]\n\n### Major Issues\n\n[Format same as critical]\n\n### Minor Issues\n\n[Format same as critical]\n\n---\n\n## Console Errors\n\n[List all console errors found during testing with page context]\n\n---\n\n## Test Coverage\n\n**Categories Completed**: X/7\n**Individual Tests Completed**: X/Y\n\n**Not Tested** (if any):\n\n- [List any tests that couldn't be executed with reasons]\n\n---\n\n## Recommendations\n\n[High-level recommendations for addressing failures, but no specific debugging or code changes]\n\n---\n\n## Conclusion\n\n[Summary paragraph of overall test execution]\n```\n\n## Important Constraints\n\n- **DO NOT debug issues** - only document them\n- **DO NOT examine code** unless needed to understand what to test\n- **DO NOT propose fixes** - only report findings\n- **DO continue testing** even after failures\n- **DO be thorough** - test every checkbox in the test plan\n- **DO capture evidence** - error messages and console logs\n- **ALWAYS create demo account** at start of session\n- **SAVE report to ./test/integration/runs/YYYY-MM-DD-N/REPORT.md** when complete\n\n## Success Criteria\n\nA successful test run means:\n\n1. All tests in TEST-PLAN.md were attempted\n2. Clear PASS/FAIL status recorded for each test\n3. Console errors documented\n4. Comprehensive report generated at `./test/integration/runs/YYYY-MM-DD-N/REPORT.md`\n\nThe tests themselves may pass or fail - your job is to execute them all and report accurately, not to achieve 100% pass rate."
              },
              {
                "name": "/write-code",
                "description": null,
                "path": "plugins/product-team/commands/write-code.md",
                "frontmatter": null,
                "content": "---\nallowed-tools: Bash, Edit, Grep, Read, WebSearch, WebFetch, Write\nargument-hint: [plan-file] [instructions]\ndescription: Write code to implement part of a plan\n---\n\n# Write code to implement a plan document\n\nYou have been given a plan document to implement ($1). Your task is to fully read and understand the plan document, and then write the code to implement it. If you were given additional instructions ($2), please pay attention to them.\n\n## Instructions\n\n- Read the plan document carefully before starting to implement it\n- Update the plan document as you go; each time you complete a task, mark it as done in the plan document using the checkbox\n- Keep a LOG.md file in the same directory as the plan document, and update it as you go. This should be a log of all key decisions you make, and any issues you encounter and how you resolved them, deviations from the plan, updated guidance from the user, and so on.\n- Do run a `pnpm run build` for the `apps/web` project when you think you are done with a phase or entire implementation, so we can catch any build failures early\n- Do run `pnpm run test` at the project root when you think you are done with a phase or entire implementation, so we can catch any test failures early\n- Do run `pnpm run format` at the project root when you think you are done with a phase or entire implementation, so we can catch any formatting issues early\n- Do run `pnpm run lint` at the project root when you think you are done with a phase or entire implementation, so we can catch any lint issues early. Fix any lint issues that affect files you have edited\n- The dev server is almost always running whenever you are working. The server runs on port 3000, and its logs are continually written to ./apps/web/.next-dev.log in the root of the project. Scan this file for errors and warnings, and use it to debug issues.\n"
              },
              {
                "name": "/write-plan",
                "description": "Create a plan to implement a certain specification",
                "path": "plugins/product-team/commands/write-plan.md",
                "frontmatter": {
                  "allowed-tools": "Bash, Edit, Grep, Read, WebSearch, WebFetch, Write(PLAN.md)",
                  "argument-hint": [
                    "spec-file"
                  ],
                  "description": "Create a plan to implement a certain specification"
                },
                "content": "# Create a plan for implementing a certain specification\n\nYour task is to create a PLAN.md file that outlines the steps required to implement a certain specification.\n\n## Data you have access to\n\n### Spec file (argument 1)\n\nThe spec file argument ($1) to understand what we're importing this time. It will provide you will some or all of the following sections of information:\n\n- Task - overall short description of the task\n- Background Reading - any additional information you should read to understand the context of the task\n- Specific Requirements - any specific requirements for the task\n\nIt may contain other information too, which you should pay attention to.\n\n## Your Task\n\nYour task is to use the details in the spec file, read and understand any content it refers to, and ultrathink to create a detailed PLAN.md document in the same directory as the spec file ($1). The PLAN.md document should contain a thorough plan for implementing the specification, following any additional instructions outlined in the spec file.\n\n### Plan requirements\n\nIMPORTANT: Our PLAN.md documents follow very strict plan requirements, as detailed in .claude/docs/processes/plan-rules.md. Read that file very carefully and adhere strictly to its guidance.\n\n**CRITICAL REQUIREMENTS FROM plan-rules.md:**\n\n1. **Documentation Manager Consultation**: After drafting the initial plan but BEFORE using `/check-plan`, you MUST consult the documentation-manager agent to identify which documentation files in `.claude/docs/tech/` and `.claude/docs/user/` need updates. Include their specific guidance in your plan's Documentation section.\n2. **GitHub Task Sync**: Include tasks to sync task files to GitHub at appropriate points using the `github-task-sync` skill. Plans should pull latest files from GitHub before starting work and push updates after major phases. See plan-rules.md section \"GitHub Task Sync Integration\" for complete workflow details.\n3. **After-Action Report Phase**: Every plan MUST include a final phase for submitting an after-action report to the process-manager agent. See plan-rules.md for the exact structure required.\n\n### GitHub Task Sync Workflow\n\nBefore beginning work, check if a GitHub issue exists for this task:\n- If the task directory is named `{issue-number}-{task-name}/`, pull latest files from GitHub using `pull.sh`\n- Include sync tasks in the plan for pushing updates after completing major phases\n- The `/finish` SlashCommand will handle final sync to GitHub before archiving\n\nAfter creating the plan files, sync them to GitHub:\n\n1. **Create Status Summary**: Write a 2-paragraph summary describing WHAT the plan will implement (NOT the process):\n   - **Status:** Draft\n   - First paragraph: High-level overview of implementation approach and phases\n   - Second paragraph: Key phases/components and major deliverables\n   - Optional: 3-5 bullet points highlighting most important phases\n\n2. **Push to GitHub**: Extract the issue number from the directory name and sync:\n   ```bash\n   ~/.claude/plugins/marketplaces/edspencer-agents/plugins/product-team/skills/github-task-sync/push-file.sh {issue-number} PLAN {status-file} PLAN.md\n   ~/.claude/plugins/marketplaces/edspencer-agents/plugins/product-team/skills/github-task-sync/push.sh {issue-number} {task-directory}\n   ```\n\nThis creates/updates the PLAN comment with status summary visible and full plan in collapsible section, plus syncs TEST_PLAN.md and COMMIT_MESSAGE.md.\n\n### Separate Test Plan Requirements\n\nMost plans you will be asked to make will involve some level of testing. You should create a separate TEST_PLAN.md file in the same directory as the spec file ($1). The TEST_PLAN.md file should contain a thorough plan for testing the specification, following any additional instructions outlined in the spec file.\n\nIf the plan genuinely does not call for any testing, do not create a TEST_PLAN.md file.\n\nIf you do create a TEST_PLAN.md file, refer to its existence in the main PLAN.md file, which should also contain a very high level summary of what the test plan calls for.\n\n### Commit Message\n\nYou should create a commit message for the changeset you propose in the PLAN.md. You should save this in a file called COMMIT_MESSAGE.md in the same directory as the spec file ($1). The commit message should correspond in detail to the changeset you propose in the PLAN.md, but at most should run to about 5-6 paragraphs. It should usually be 2-3 paragraphs unless the changeset are enormous.\n\nCommit message instructions:\n\n- should start with a 1-sentence summary on its own line\n- should briefly explain what we're doing any why\n- should not just summarize the changeset\n- should typically be 2-4 paragraphs long\n- should be shorter than this if only a small amount of code is being changed (e.g. if less than ~300LOC changed, a paragraph or two should suffice)\n- should call out any key architectural or API changes\n- should call out any key dependencies or tools being added/removed\n- should call out any key data model changes\n- should call out any key environment variable changes\n- do not attempt to assess the value of the changes, e.g. don't say things like \"This change improves the information architecture by separating document management from the primary navigation flow while keeping career-focused features prominently displayed and easily accessible.\"\n\n#### GitHub Issue Closing Syntax\n\nIf the task directory follows the pattern `tasks/{issue-number}-{task-name}/`, the commit message MUST include GitHub's issue closing syntax at the end:\n\n- Extract the issue number from the directory name\n- For bug fixes (check SPEC.md labels): Use `Fixes #{issue-number}`\n- For features and other tasks: Use `Closes #{issue-number}`\n- Add this as a separate line at the end of the commit message body\n\nGitHub will automatically close the associated issue when the commit is merged.\n\n**Example with closing syntax:**\n\n```\nfix: invalidate top projects cache when creating projects\n\nWhen users create a project via the dashboard, the TopProjects component and NavProjects sidebar don't refresh to show the new project until they manually refresh the page. This occurs because useCreateProject() only invalidates the `/api/projects` SWR cache key, while TopProjects and NavProjects use the `/api/projects/top?limit=5` cache key.\n\nThis fix adds useTopProjects() to useCreateProject() and calls mutate() on both cache keys after successful creation, ensuring all components receive updated data immediately.\n\nCloses #213\n```\n\n#### Example commit messages (without closing syntax for context)\n\nIn this paragraph:\n\n```\nThis change restructures the main sidebar navigation by removing the Documents section and introducing a new \"Careers\" section that consolidates career-related features. The Careers section groups together existing features (Standup and \"Reports\") with two new coming-soon pages (Performance Review and Workstreams), creating a more intuitive organization for users focused on career advancement and documentation.\n```\n\nAll was fine until the \", creating a more intuitive ...\" stuff - just don't include value judgments like that, leave them out.\n\nSimilarly, here, the final sentence is completely unnecessary and should not be present in a commit message:\n\n```\nThe Documents section has been completely removed from the navigation sidebar, though the `/documents` page and its associated functionality remain accessible via direct URL. This change improves the information architecture by separating document management from the primary navigation flow while keeping career-focused features prominently displayed and easily accessible.\n```\n\nThat was fine until the \"direct URL.\", which is where it should have ended.\n\n# Get started\n\nPlease start your plan and save it to PLAN.md"
              },
              {
                "name": "/write-spec",
                "description": "Create a specification document for a task",
                "path": "plugins/product-team/commands/write-spec.md",
                "frontmatter": {
                  "allowed-tools": "Bash, Edit, Grep, Read, WebSearch, WebFetch, Write(SPEC.md)",
                  "argument-hint": [
                    "topic"
                  ],
                  "description": "Create a specification document for a task"
                },
                "content": "# Create a specification document for a task\n\nYour task is to create a SPEC.md file from the topic or requirements provided by the user.\n\n## Data you have access to\n\n### Topic (argument 1)\n\nThe topic argument ($1) provides the initial description of what needs to be specified. This may be:\n- A brief task description\n- User requirements or goals\n- A problem statement that needs solving\n\n## Your Task\n\nYour task is to gather all necessary information (through questions if needed) and create a comprehensive SPEC.md document in `./tasks/[task-name]/SPEC.md` following the spec-rules.md guidelines.\n\n### Spec Requirements\n\nIMPORTANT: All SPEC.md documents must follow the strict requirements in Check `.claude/docs/processes/spec-rules.md` (project) OR `~/.claude/plugins/marketplaces/edspencer-agents/plugins/product-team/docs/processes/spec-rules.md` (plugin). Read that file very carefully and adhere to its guidance.\n\n**Key Requirements:**\n1. **File Location**: Always create in `./tasks/[task-name]/SPEC.md` where [task-name] is derived from the task\n2. **Required Structure**:\n   - Task heading with clear statement\n   - Background section explaining context and problem\n   - Current State section describing what exists today\n   - Requirements section with detailed, numbered list\n   - Success Criteria section with testable criteria\n3. **Content Guidelines**:\n   - Clear, comprehensive description with all relevant context\n   - No large code snippets (except to illustrate patterns)\n   - Enough detail for plan-writer to create implementation plan\n   - Call out new dependencies clearly\n   - Include links to relevant code, docs, or resources\n\n### Gathering Requirements\n\nIf the initial topic ($1) lacks sufficient detail:\n- Ask clarifying questions about the problem and goals\n- Understand what currently exists\n- Identify what needs to change or be added\n- Determine success criteria\n- Identify any constraints or dependencies\n\n### Task Naming\n\nChoose a clear, descriptive task name for the directory:\n- Use lowercase with hyphens: `add-user-auth`, `fix-login-bug`, `refactor-api`\n- Keep it concise but meaningful\n- Ensure it matches the task heading\n\n### GitHub Issue Creation\n\nIf the user explicitly requests that a GitHub issue be created, or if this is a significant feature requiring tracking:\n\n1. **Ask the user** if a GitHub issue should be created for this task\n2. **If yes**, use the github-task-sync skill's `create-issue.sh` script to create the issue and initialize the task directory:\n   ```bash\n   ~/.claude/plugins/marketplaces/edspencer-agents/plugins/product-team/skills/github-task-sync/create-issue.sh \"<task-title>\" \"<brief-description>\"\n   ```\n3. **Directory naming**: The script automatically creates a directory named `{issue-number}-{task-slug}/`\n4. **Work locally**: Create SPEC.md in the task directory as usual\n5. **Sync to GitHub**: After creating SPEC.md, sync it with a status summary (see below)\n\n**Note:** GitHub issues serve as the source of truth for task documentation. Local task files are a working cache that agents can edit easily.\n\n### GitHub Sync After Spec Creation\n\nAfter creating SPEC.md, if the task directory follows the pattern `tasks/{issue-number}-{task-name}/`:\n\n1. **Create Status Summary**: Write a 2-paragraph summary describing WHAT the specification covers (NOT the process):\n   - **Status:** Draft\n   - First paragraph: High-level overview of what the spec calls for\n   - Second paragraph: Key requirements, scope, and important constraints\n   - Optional: 3-5 bullet points highlighting most important requirements\n\n2. **Push to GitHub**: Extract the issue number from the directory name and sync:\n   ```bash\n   ~/.claude/plugins/marketplaces/edspencer-agents/plugins/product-team/skills/github-task-sync/push-file.sh {issue-number} SPEC {status-file} SPEC.md\n   ```\n\n**Status Summary Format Example:**\n```\n**Status:** Draft\n\nThis specification outlines requirements for implementing user account deletion functionality. The feature must allow users to permanently delete their accounts and associated data while maintaining system integrity and compliance with data protection regulations.\n\nKey requirements include: database cleanup of all user records, notification of deletion to third-party services, verification steps to prevent accidental deletion, and audit logging of all deletions. The implementation must support gradual data removal to avoid performance impact on the production system.\n\n- Permanent and irreversible account deletion with full data cleanup\n- Compliance with GDPR and data protection requirements\n- Deletion verification workflow to prevent accidents\n- Audit trail for compliance and security\n```\n\nThis creates/updates the SPEC comment on GitHub with the status summary visible and full spec in a collapsible section.\n\n# Get started\n\nPlease gather requirements and create the SPEC.md file."
              }
            ],
            "skills": [
              {
                "name": "github-task-sync",
                "description": "Manage task documentation by syncing between local task directories and GitHub issues",
                "path": "plugins/product-team/skills/github-task-sync/SKILL.md",
                "frontmatter": {
                  "name": "github-task-sync",
                  "description": "Manage task documentation by syncing between local task directories and GitHub issues"
                },
                "content": "# GitHub Task Sync Skill\n\nSeamlessly manage task documentation by syncing between local task directories and GitHub issues. All task documentation (SPEC, PLAN, TEST_PLAN, COMMIT_MESSAGE) lives both locally and on GitHub, with easy push/pull synchronization.\n\n## Overview\n\nThis skill provides a complete workflow for managing tasks:\n\n1. **Create** a new GitHub issue with `create-issue.sh`\n2. **Push** local task files to GitHub with `push.sh` or `push-file.sh`\n3. **Pull** task files from GitHub with `pull.sh` or `pull-file.sh`\n4. **Read** task files from GitHub to stdout with `read-issue-file.sh`\n5. **Log** work progress with `log-entry.sh` (creates AI Work Log comment with timestamped entries)\n\n## Quick Start\n\n```bash\n# Create a new GitHub issue and task directory\n./create-issue.sh \"Add dark mode toggle\" \"Implement dark/light theme switcher\"\n\n# Work on files locally (SPEC.md, PLAN.md, etc.)\n\n# Push all files to GitHub\n./push.sh 188 ./tasks/188-add-dark-mode-toggle\n\n# Or pull the latest from GitHub (automatically creates task directory from issue title)\n./pull.sh 188\n```\n\n## Scripts\n\nThere are 7 scripts in this skill:\n\n1. **create-issue.sh** - Create GitHub issue and initialize task directory\n2. **push.sh** - Push all task files to GitHub\n3. **push-file.sh** - Push single task file with status summary\n4. **pull.sh** - Pull all task files from GitHub\n5. **pull-file.sh** - Pull single task file from GitHub\n6. **read-issue-file.sh** - Read task file from GitHub to stdout\n7. **log-entry.sh** - Add timestamped entry to AI Work Log\n\n### create-issue.sh\n\nCreate a new GitHub issue and initialize a task directory. Can also convert existing task directories to GitHub issues. Automatically applies GitHub labels based on issue context.\n\n**Usage:**\n```bash\n./create-issue.sh <title> [description] [existing-task-dir] [labels]\n```\n\n**Arguments:**\n- `title` - GitHub issue title\n- `description` - Issue description (optional)\n- `existing-task-dir` - Path to existing task directory to convert (optional)\n- `labels` - Comma-separated labels to apply (optional, e.g., \"UI,bug\" or \"CLI,feature\")\n\n**Available labels:**\n- `UI` - User interface related issues\n- `CLI` - Command-line interface related issues\n- `bug` - Bug fixes and issue resolutions\n- `feature` - New features and enhancements\n\n**Examples:**\n```bash\n# Create new issue with title only\n./create-issue.sh \"Add dark mode toggle\"\n\n# Create new issue with title, description, and labels\n./create-issue.sh \"Add dark mode toggle\" \"Implement dark/light theme switcher in settings\" \"\" \"UI,feature\"\n\n# Convert existing task directory to GitHub issue with labels\n./create-issue.sh \"Fix login button styling\" \"\" ./tasks/login-styling \"UI,bug\"\n\n# Create issue with description and labels (no existing task dir)\n./create-issue.sh \"Add date filter to extract\" \"Filter commits by date range\" \"\" \"CLI,feature\"\n```\n\n**What it does:**\n1. Analyzes issue content to determine appropriate labels (optional)\n2. Creates a new GitHub issue with the provided title, description, and labels\n3. Creates local task directory named `{issue-number}-{title-slug}/`\n4. If task files exist, automatically syncs them to GitHub\n5. Outputs issue URL and task directory path\n\n**Output:**\n```\nCreating GitHub issue...\nApplying labels: UI,feature\n✓ GitHub issue created: https://github.com/<github-user>/<repo-name>/issues/189\n✓ Created task directory: tasks/189-add-dark-mode-toggle\n\n✅ Task setup complete!\nIssue: https://github.com/<github-user>/<repo-name>/issues/189\nTask Directory: tasks/189-add-dark-mode-toggle\nTask Number: 189\n```\n\n### push.sh\n\nPush all task documentation files (SPEC.md, PLAN.md, TEST_PLAN.md, COMMIT_MESSAGE.md) to a GitHub issue as collapsible comments.\n\n**Usage:**\n```bash\n./push.sh <issue-url-or-number> [task-directory]\n```\n\n**Arguments:**\n- `issue-url-or-number` - Full GitHub URL or just the issue number\n- `task-directory` - Directory containing task files (optional, defaults to current directory)\n\n**Examples:**\n```bash\n# Using issue number\n./push.sh 188 ./tasks/188-account-deletion\n\n# Using full URL\n./push.sh https://github.com/<github-user>/<repo-name>/issues/188 ./tasks/188-account-deletion\n\n# Using current directory\n./push.sh 188\n```\n\n**What it does:**\n- Uploads all four task file types as separate collapsible comments\n- Each file type gets a unique marker so it can be updated independently\n- Creates new comments or updates existing ones\n- Each file wrapped in `<details>` section that starts collapsed\n\n**Output:**\n```\n📤 Syncing task files to GitHub issue #188 in <github-user>/<repo-name>\n\nProcessing SPEC.md...\n  + Creating new comment...\n  ✓ Created\n\nProcessing PLAN.md...\n  ↻ Updating existing comment (ID: 123456789)...\n  ✓ Updated\n\n...\n✅ Sync complete!\nView the issue: https://github.com/<github-user>/<repo-name>/issues/188\n```\n\n### push-file.sh\n\nUpdate a single task file comment on a GitHub issue with a status summary and file content.\n\n**Usage:**\n```bash\n./push-file.sh <issue-url-or-number> <file-type> <status-file> <content-file>\n```\n\n**Arguments:**\n- `issue-url-or-number` - GitHub issue URL or issue number\n- `file-type` - One of: `SPEC`, `PLAN`, `TEST_PLAN`, `COMMIT_MESSAGE`\n- `status-file` - File containing status summary (2 paragraphs + optional bullets)\n- `content-file` - File containing the full file content\n\n**Examples:**\n```bash\n# Update SPEC with status and content\n./push-file.sh 188 SPEC SPEC-STATUS.md SPEC.md\n\n# Update PLAN after review\n./push-file.sh 188 PLAN plan-status.txt PLAN.md\n```\n\n**Status File Format:**\nThe status file should contain a 2-paragraph summary describing the document state:\n\n```markdown\n**Status:** [Draft | Complete | Review Needed | etc.]\n\nThis is the first paragraph explaining the current state of the document.\nIt should describe what has been completed, what's pending, or any key status information.\n\nThis is the second paragraph providing additional context or details about the document state.\n\n- Key point 1 (optional)\n- Key point 2 (optional)\n```\n\n**What it does:**\n- Creates or updates a single comment for the specified file type\n- Combines the status summary with the file content in a collapsible section\n- Each file type has a unique marker for independent updates\n\n**Output:**\n```\n↻ Updating SPEC comment on issue #188 (ID: 123456789)...\n✓ Updated successfully\n\nView the issue: https://github.com/<github-user>/<repo-name>/issues/188\n```\n\n### pull.sh\n\nPull all task documentation files from a GitHub issue to a local task directory. **Automatically determines the task directory name** from the issue title.\n\n**Usage:**\n```bash\n./pull.sh <issue-url-or-number>\n```\n\n**Arguments:**\n- `issue-url-or-number` - GitHub issue URL or issue number\n\n**Examples:**\n```bash\n# Pull using issue number\n./pull.sh 188\n\n# Pull using full URL\n./pull.sh https://github.com/<github-user>/<repo-name>/issues/188\n```\n\n**What it does:**\n1. Fetches the issue title from GitHub\n2. Converts the title to a URL-safe slug\n3. Creates task directory as `tasks/{issue-number}-{title-slug}/`\n4. Fetches all four task files from GitHub issue comments\n5. Extracts content from collapsible sections\n6. Writes each to local file (SPEC.md, PLAN.md, etc.)\n\n**Output:**\n```\n📥 Fetching issue #188 from <github-user>/<repo-name>...\n📥 Pulling task files from GitHub issue #188: \"Account deletion and data export\"\n📁 Task directory: tasks/188-account-deletion-and-data-export\n\nPulling SPEC.md...\n  ✓ Pulled to SPEC.md\n\nPulling PLAN.md...\n  ✓ Pulled to PLAN.md\n\n...\n✅ Pull complete!\nTask directory: tasks/188-account-deletion-and-data-export\n```\n\n### pull-file.sh\n\nPull a single task file from a GitHub issue to a local file.\n\n**Usage:**\n```bash\n./pull-file.sh <issue-url-or-number> <file-type> [output-file]\n```\n\n**Arguments:**\n- `issue-url-or-number` - GitHub issue URL or issue number\n- `file-type` - One of: `SPEC`, `PLAN`, `TEST_PLAN`, `COMMIT_MESSAGE`\n- `output-file` - File to write to (default: `{file-type}.md` in current directory)\n\n**Examples:**\n```bash\n# Pull SPEC to SPEC.md\n./pull-file.sh 188 SPEC\n\n# Pull PLAN to specific file\n./pull-file.sh 188 PLAN ./my-plan.md\n\n# Pull and pipe to stdout\n./pull-file.sh 188 SPEC | head -20\n```\n\n**Output:**\nPure file content (great for piping or redirecting)\n\n### read-issue-file.sh\n\nRead a task file from a GitHub issue and output to stdout. Useful for debugging, piping, or quick content inspection.\n\n**Usage:**\n```bash\n./read-issue-file.sh <issue-url-or-number> <file-type>\n```\n\n**Arguments:**\n- `issue-url-or-number` - GitHub issue URL or issue number\n- `file-type` - One of: `SPEC`, `PLAN`, `TEST_PLAN`, `COMMIT_MESSAGE`\n\n**Examples:**\n```bash\n# Read SPEC to stdout\n./read-issue-file.sh 188 SPEC\n\n# Pipe to file\n./read-issue-file.sh 188 PLAN > my-plan.md\n\n# View first 20 lines\n./read-issue-file.sh 188 SPEC | head -20\n```\n\n**Output:**\nPure file content sent to stdout\n\n### log-entry.sh\n\nAdd timestamped entries to a task's AI Work Log on a GitHub issue. Creates or updates a running log of work progress throughout the task lifecycle.\n\n**Usage:**\n```bash\n./log-entry.sh <issue-url-or-number> <entry-text>\n```\n\n**Arguments:**\n- `issue-url-or-number` - GitHub issue URL or issue number\n- `entry-text` - Description of work being done (e.g., \"Started writing spec\")\n\n**Examples:**\n```bash\n# Log that spec writing started\n./log-entry.sh 188 \"Started writing spec\"\n\n# Log that plan writing finished\n./log-entry.sh 188 \"Finished writing plan\"\n\n# Use full URL\n./log-entry.sh https://github.com/<github-user>/<repo-name>/issues/190 \"Started implementation\"\n```\n\n**What it does:**\n- Creates a new \"AI Work Log\" comment on the issue if it doesn't exist\n- Appends timestamped entries to the work log (one per line with format: `- YYYY-MM-DD HH:MM:SS: entry-text`)\n- Each entry is timestamped and represents a work milestone\n- Useful for tracking progress through spec writing, planning, implementation, testing, and completion\n\n**Output:**\n```\n↻ Adding entry to work log on issue #188...\n✓ Entry added\n\nView the issue: https://github.com/<github-user>/<repo-name>/issues/188\n```\n\n## Task Directory Structure\n\nWhen using `create-issue.sh`, directories are automatically named with the issue number:\n\n```\ntasks/\n├── 188-account-deletion/\n│   ├── SPEC.md                   (Specification)\n│   ├── PLAN.md                   (Implementation plan)\n│   ├── TEST_PLAN.md              (Test scenarios)\n│   └── COMMIT_MESSAGE.md         (Git commit message)\n├── 189-add-dark-mode/\n│   └── [similar structure]\n└── archive/\n    └── [completed tasks]\n```\n\n**Naming Convention:** `{issue-number}-{task-name-slug}`\n\nThe issue number in the directory name provides direct reference to the GitHub issue.\n\n## Workflow\n\n### Creating a New Task\n\n```bash\n# 1. Create GitHub issue and task directory\n./create-issue.sh \"Add authentication\" \"Implement magic link authentication\"\n\n# 2. Log that work is starting\n./log-entry.sh 190 \"Started writing spec\"\n\n# 3. Work on files locally\n# - Create SPEC.md\n# - Create PLAN.md\n# - Create TEST_PLAN.md\n# - Create COMMIT_MESSAGE.md\n\n# 4. Push files to GitHub\n./push.sh 190 ./tasks/190-add-authentication\n\n# 5. Log work progress\n./log-entry.sh 190 \"Finished writing spec\"\n./log-entry.sh 190 \"Started writing plan\"\n\n# 6. Continue development...\n# When you update files, push again\n./push.sh 190 ./tasks/190-add-authentication\n./log-entry.sh 190 \"Finished writing plan\"\n./log-entry.sh 190 \"Started implementation\"\n```\n\n### Converting Existing Tasks to GitHub Issues\n\nIf you have an existing task directory without a GitHub issue:\n\n```bash\n# 1. Create GitHub issue from existing directory\n./create-issue.sh \"My feature\" \"Description\" ./tasks/my-feature\n\n# 2. Files are automatically synced to GitHub\n# Task directory renamed to: tasks/191-my-feature\n```\n\n### Syncing During Work\n\n**Push workflow** (local → GitHub):\n```bash\n# Log that you're starting work\n./log-entry.sh 188 \"Started writing code\"\n\n# Update single file on GitHub with status\n./push-file.sh 188 SPEC SPEC-STATUS.md SPEC.md\n\n# Update all files on GitHub\n./push.sh 188 ./tasks/188-account-deletion\n\n# Log when work is complete\n./log-entry.sh 188 \"Finished writing code\"\n```\n\n**Pull workflow** (GitHub → local):\n```bash\n# Pull all files from GitHub\n./pull.sh 188 ./tasks/188-account-deletion\n\n# Pull single file from GitHub\n./pull-file.sh 188 PLAN\n\n# Log that you pulled latest\n./log-entry.sh 188 \"Pulled latest files from GitHub\"\n```\n\n### Task Completion\n\nWhen finishing a task (via `/finish` command):\n\n1. All work is complete and tested\n2. Run `push.sh` one final time to sync latest versions\n3. Task directory is archived from `tasks/` to `tasks/archive/`\n4. GitHub issue remains as permanent record\n\n## Key Features\n\n- ✅ **Bidirectional sync** - Push changes to GitHub or pull from GitHub\n- ✅ **Selective updates** - Push/pull individual files or all at once\n- ✅ **Status tracking** - Each file can have a 2-paragraph status summary\n- ✅ **Collapsible display** - Large files stay organized on GitHub\n- ✅ **AI Work Log** - Timestamped activity log tracking progress (spec writing, planning, implementation, etc.)\n- ✅ **Issue creation** - Automatically initialize task structure\n- ✅ **Directory conversion** - Convert existing tasks to GitHub issues\n- ✅ **No git commits** - Task files never committed (in `.gitignore`)\n- ✅ **GitHub-centric** - Documentation source of truth lives on GitHub\n\n## Requirements\n\n- `gh` CLI installed and authenticated\n- Bash shell\n- Read/write access to the GitHub repository\n- Git repository with GitHub remote (for auto-detection)\n\n## Integration with Other Commands\n\n**With `/write-spec`:**\n- Creates SPEC.md locally\n- Agent calls `push-file.sh` to sync status + content to GitHub\n\n**With `/write-plan`:**\n- Creates PLAN.md locally\n- Agent calls `push-file.sh` to sync to GitHub\n\n**With `/finish`:**\n- Calls `push.sh` to sync all files to GitHub as final step\n- Task archived and GitHub issue contains complete documentation\n\n## Setup & Configuration\n\nThe scripts **automatically detect** the GitHub repository from your current git remote (origin). No configuration needed!\n\n**Repository Detection:**\n1. **Auto-detect** (recommended): Scripts automatically extract owner/repo from `git remote get-url origin`\n   - Supports both HTTPS: `https://github.com/owner/repo.git`\n   - Supports SSH: `git@github.com:owner/repo.git`\n\n2. **Environment variables** (optional override):\n   ```bash\n   export GITHUB_OWNER=\"myorg\"\n   export GITHUB_REPO=\"myrepo\"\n   ```\n\n3. **Full URLs** (always works):\n   ```bash\n   # Use full URL instead of issue number to override auto-detection\n   ./push.sh \"https://github.com/otherorg/otherrepo/issues/42\" ./tasks/42-myfeature\n   ```\n\n**Error Handling:**\nIf you run scripts outside a git repository or without a GitHub remote, you'll see a helpful error:\n```\nError: Not in a git repository\nPlease run this command from within a git repository, or set GITHUB_OWNER and GITHUB_REPO environment variables\n```"
              }
            ]
          }
        ]
      }
    }
  ]
}