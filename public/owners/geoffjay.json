{
  "owner": {
    "id": "geoffjay",
    "display_name": "Geoff Johnson",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/206354?v=4",
    "url": "https://github.com/geoffjay",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 7,
      "total_commands": 31,
      "total_skills": 25,
      "total_stars": 4,
      "total_forks": 1
    }
  },
  "repos": [
    {
      "full_name": "geoffjay/claude-plugins",
      "url": "https://github.com/geoffjay/claude-plugins",
      "description": null,
      "homepage": null,
      "signals": {
        "stars": 4,
        "forks": 1,
        "pushed_at": "2025-11-04T20:23:37Z",
        "created_at": "2025-10-17T18:24:21Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 8698
        },
        {
          "path": ".envrc",
          "type": "blob",
          "size": 52
        },
        {
          "path": ".github",
          "type": "tree",
          "size": null
        },
        {
          "path": ".github/CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3067
        },
        {
          "path": ".github/CONTRIBUTING.md",
          "type": "blob",
          "size": 4122
        },
        {
          "path": ".github/ISSUE_TEMPLATE",
          "type": "tree",
          "size": null
        },
        {
          "path": ".github/ISSUE_TEMPLATE/bug_report.yml",
          "type": "blob",
          "size": 2204
        },
        {
          "path": ".github/ISSUE_TEMPLATE/config.yml",
          "type": "blob",
          "size": 579
        },
        {
          "path": ".github/ISSUE_TEMPLATE/feature_request.yml",
          "type": "blob",
          "size": 2439
        },
        {
          "path": ".github/ISSUE_TEMPLATE/moderation_report.yml",
          "type": "blob",
          "size": 3755
        },
        {
          "path": ".github/ISSUE_TEMPLATE/new_subagent.yml",
          "type": "blob",
          "size": 3865
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 27
        },
        {
          "path": ".tool-versions",
          "type": "blob",
          "size": 28
        },
        {
          "path": "CLAUDE.md",
          "type": "blob",
          "size": 4621
        },
        {
          "path": "LICENSE",
          "type": "blob",
          "size": 1071
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 3016
        },
        {
          "path": "docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/agent-skills.md",
          "type": "blob",
          "size": 12824
        },
        {
          "path": "docs/agents.md",
          "type": "blob",
          "size": 8988
        },
        {
          "path": "docs/architecture.md",
          "type": "blob",
          "size": 11831
        },
        {
          "path": "docs/plugins.md",
          "type": "blob",
          "size": 4601
        },
        {
          "path": "docs/usage.md",
          "type": "blob",
          "size": 25175
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude-plugin/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude-plugin/agents/plugin-architect.md",
          "type": "blob",
          "size": 9117
        },
        {
          "path": "plugins/claude-plugin/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude-plugin/commands/create.md",
          "type": "blob",
          "size": 7737
        },
        {
          "path": "plugins/claude-plugin/commands/documentation.md",
          "type": "blob",
          "size": 15053
        },
        {
          "path": "plugins/claude-plugin/commands/update.md",
          "type": "blob",
          "size": 11417
        },
        {
          "path": "plugins/claude-plugin/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude-plugin/skills/documentation-update",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude-plugin/skills/documentation-update/SKILL.md",
          "type": "blob",
          "size": 10020
        },
        {
          "path": "plugins/claude-plugin/skills/documentation-update/assets",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude-plugin/skills/documentation-update/assets/agent-skills.md.j2",
          "type": "blob",
          "size": 1923
        },
        {
          "path": "plugins/claude-plugin/skills/documentation-update/assets/agents.md.j2",
          "type": "blob",
          "size": 1309
        },
        {
          "path": "plugins/claude-plugin/skills/documentation-update/assets/plugins.md.j2",
          "type": "blob",
          "size": 2094
        },
        {
          "path": "plugins/claude-plugin/skills/documentation-update/assets/usage.md.j2",
          "type": "blob",
          "size": 5715
        },
        {
          "path": "plugins/claude-plugin/skills/documentation-update/doc_generator.py",
          "type": "blob",
          "size": 16961
        },
        {
          "path": "plugins/claude-plugin/skills/marketplace-update",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude-plugin/skills/marketplace-update/SKILL.md",
          "type": "blob",
          "size": 8993
        },
        {
          "path": "plugins/claude-plugin/skills/marketplace-update/marketplace_update.py",
          "type": "blob",
          "size": 15159
        },
        {
          "path": "plugins/golang-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/golang-development/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/golang-development/agents/go-architect.md",
          "type": "blob",
          "size": 16181
        },
        {
          "path": "plugins/golang-development/agents/go-performance.md",
          "type": "blob",
          "size": 14911
        },
        {
          "path": "plugins/golang-development/agents/golang-pro.md",
          "type": "blob",
          "size": 10853
        },
        {
          "path": "plugins/golang-development/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/golang-development/commands/review.md",
          "type": "blob",
          "size": 9639
        },
        {
          "path": "plugins/golang-development/commands/scaffold.md",
          "type": "blob",
          "size": 9229
        },
        {
          "path": "plugins/golang-development/commands/test.md",
          "type": "blob",
          "size": 12467
        },
        {
          "path": "plugins/golang-development/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/golang-development/skills/go-concurrency",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/golang-development/skills/go-concurrency/SKILL.md",
          "type": "blob",
          "size": 12691
        },
        {
          "path": "plugins/golang-development/skills/go-optimization",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/golang-development/skills/go-optimization/SKILL.md",
          "type": "blob",
          "size": 12328
        },
        {
          "path": "plugins/golang-development/skills/go-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/golang-development/skills/go-patterns/SKILL.md",
          "type": "blob",
          "size": 11689
        },
        {
          "path": "plugins/ruby-sinatra-advanced",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ruby-sinatra-advanced/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ruby-sinatra-advanced/agents/rack-specialist.md",
          "type": "blob",
          "size": 13350
        },
        {
          "path": "plugins/ruby-sinatra-advanced/agents/ruby-pro.md",
          "type": "blob",
          "size": 11671
        },
        {
          "path": "plugins/ruby-sinatra-advanced/agents/sinatra-architect.md",
          "type": "blob",
          "size": 17416
        },
        {
          "path": "plugins/ruby-sinatra-advanced/agents/sinatra-pro.md",
          "type": "blob",
          "size": 8471
        },
        {
          "path": "plugins/ruby-sinatra-advanced/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ruby-sinatra-advanced/commands/ruby-optimize.md",
          "type": "blob",
          "size": 15959
        },
        {
          "path": "plugins/ruby-sinatra-advanced/commands/sinatra-review.md",
          "type": "blob",
          "size": 14781
        },
        {
          "path": "plugins/ruby-sinatra-advanced/commands/sinatra-scaffold.md",
          "type": "blob",
          "size": 13139
        },
        {
          "path": "plugins/ruby-sinatra-advanced/commands/sinatra-test.md",
          "type": "blob",
          "size": 20766
        },
        {
          "path": "plugins/ruby-sinatra-advanced/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ruby-sinatra-advanced/skills/rack-middleware",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ruby-sinatra-advanced/skills/rack-middleware/SKILL.md",
          "type": "blob",
          "size": 17227
        },
        {
          "path": "plugins/ruby-sinatra-advanced/skills/ruby-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ruby-sinatra-advanced/skills/ruby-patterns/SKILL.md",
          "type": "blob",
          "size": 14463
        },
        {
          "path": "plugins/ruby-sinatra-advanced/skills/sinatra-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ruby-sinatra-advanced/skills/sinatra-patterns/SKILL.md",
          "type": "blob",
          "size": 11074
        },
        {
          "path": "plugins/ruby-sinatra-advanced/skills/sinatra-security",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ruby-sinatra-advanced/skills/sinatra-security/SKILL.md",
          "type": "blob",
          "size": 16156
        },
        {
          "path": "plugins/rust-cli-developer",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-cli-developer/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-cli-developer/agents/clap-expert.md",
          "type": "blob",
          "size": 13203
        },
        {
          "path": "plugins/rust-cli-developer/agents/cli-architect.md",
          "type": "blob",
          "size": 19872
        },
        {
          "path": "plugins/rust-cli-developer/agents/cli-testing-expert.md",
          "type": "blob",
          "size": 21135
        },
        {
          "path": "plugins/rust-cli-developer/agents/cli-ux-specialist.md",
          "type": "blob",
          "size": 21050
        },
        {
          "path": "plugins/rust-cli-developer/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-cli-developer/commands/cli-enhance.md",
          "type": "blob",
          "size": 15946
        },
        {
          "path": "plugins/rust-cli-developer/commands/cli-review.md",
          "type": "blob",
          "size": 12514
        },
        {
          "path": "plugins/rust-cli-developer/commands/cli-scaffold.md",
          "type": "blob",
          "size": 7073
        },
        {
          "path": "plugins/rust-cli-developer/commands/cli-test.md",
          "type": "blob",
          "size": 13571
        },
        {
          "path": "plugins/rust-cli-developer/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-cli-developer/skills/clap-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-cli-developer/skills/clap-patterns/SKILL.md",
          "type": "blob",
          "size": 4859
        },
        {
          "path": "plugins/rust-cli-developer/skills/cli-configuration",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-cli-developer/skills/cli-configuration/SKILL.md",
          "type": "blob",
          "size": 11325
        },
        {
          "path": "plugins/rust-cli-developer/skills/cli-distribution",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-cli-developer/skills/cli-distribution/SKILL.md",
          "type": "blob",
          "size": 12011
        },
        {
          "path": "plugins/rust-cli-developer/skills/cli-ux-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-cli-developer/skills/cli-ux-patterns/SKILL.md",
          "type": "blob",
          "size": 8903
        },
        {
          "path": "plugins/rust-gpui-developer",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-gpui-developer/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-gpui-developer/agents/gpui-architect.md",
          "type": "blob",
          "size": 10818
        },
        {
          "path": "plugins/rust-gpui-developer/agents/gpui-performance.md",
          "type": "blob",
          "size": 14305
        },
        {
          "path": "plugins/rust-gpui-developer/agents/gpui-router-specialist.md",
          "type": "blob",
          "size": 21607
        },
        {
          "path": "plugins/rust-gpui-developer/agents/rust-gpui-pro.md",
          "type": "blob",
          "size": 7749
        },
        {
          "path": "plugins/rust-gpui-developer/agents/rust-ui-specialist.md",
          "type": "blob",
          "size": 14413
        },
        {
          "path": "plugins/rust-gpui-developer/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-gpui-developer/commands/gpui-component.md",
          "type": "blob",
          "size": 14986
        },
        {
          "path": "plugins/rust-gpui-developer/commands/gpui-review.md",
          "type": "blob",
          "size": 8916
        },
        {
          "path": "plugins/rust-gpui-developer/commands/gpui-scaffold.md",
          "type": "blob",
          "size": 8010
        },
        {
          "path": "plugins/rust-gpui-developer/commands/gpui-test.md",
          "type": "blob",
          "size": 11590
        },
        {
          "path": "plugins/rust-gpui-developer/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-gpui-developer/skills/gpui-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-gpui-developer/skills/gpui-patterns/SKILL.md",
          "type": "blob",
          "size": 12965
        },
        {
          "path": "plugins/rust-gpui-developer/skills/gpui-performance",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-gpui-developer/skills/gpui-performance/SKILL.md",
          "type": "blob",
          "size": 14608
        },
        {
          "path": "plugins/rust-gpui-developer/skills/gpui-styling",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-gpui-developer/skills/gpui-styling/SKILL.md",
          "type": "blob",
          "size": 15324
        },
        {
          "path": "plugins/rust-gpui-developer/skills/rust-ui-architecture",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-gpui-developer/skills/rust-ui-architecture/SKILL.md",
          "type": "blob",
          "size": 16082
        },
        {
          "path": "plugins/rust-tokio-expert",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-tokio-expert/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-tokio-expert/agents/tokio-architect.md",
          "type": "blob",
          "size": 20616
        },
        {
          "path": "plugins/rust-tokio-expert/agents/tokio-network-specialist.md",
          "type": "blob",
          "size": 15559
        },
        {
          "path": "plugins/rust-tokio-expert/agents/tokio-performance.md",
          "type": "blob",
          "size": 13907
        },
        {
          "path": "plugins/rust-tokio-expert/agents/tokio-pro.md",
          "type": "blob",
          "size": 11507
        },
        {
          "path": "plugins/rust-tokio-expert/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-tokio-expert/commands/tokio-migrate.md",
          "type": "blob",
          "size": 9203
        },
        {
          "path": "plugins/rust-tokio-expert/commands/tokio-review.md",
          "type": "blob",
          "size": 7023
        },
        {
          "path": "plugins/rust-tokio-expert/commands/tokio-scaffold.md",
          "type": "blob",
          "size": 6736
        },
        {
          "path": "plugins/rust-tokio-expert/commands/tokio-test.md",
          "type": "blob",
          "size": 10540
        },
        {
          "path": "plugins/rust-tokio-expert/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-tokio-expert/skills/tokio-concurrency",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-tokio-expert/skills/tokio-concurrency/SKILL.md",
          "type": "blob",
          "size": 12922
        },
        {
          "path": "plugins/rust-tokio-expert/skills/tokio-networking",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-tokio-expert/skills/tokio-networking/SKILL.md",
          "type": "blob",
          "size": 13132
        },
        {
          "path": "plugins/rust-tokio-expert/skills/tokio-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-tokio-expert/skills/tokio-patterns/SKILL.md",
          "type": "blob",
          "size": 8783
        },
        {
          "path": "plugins/rust-tokio-expert/skills/tokio-troubleshooting",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rust-tokio-expert/skills/tokio-troubleshooting/SKILL.md",
          "type": "blob",
          "size": 11617
        },
        {
          "path": "plugins/utilities",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/utilities/git",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/utilities/git/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/utilities/git/commands/bisect.md",
          "type": "blob",
          "size": 10617
        },
        {
          "path": "plugins/utilities/git/commands/branch-cleanup.md",
          "type": "blob",
          "size": 18132
        },
        {
          "path": "plugins/utilities/git/commands/cherry-pick-helper.md",
          "type": "blob",
          "size": 17529
        },
        {
          "path": "plugins/utilities/git/commands/commit.md",
          "type": "blob",
          "size": 8590
        },
        {
          "path": "plugins/utilities/git/commands/fixup.md",
          "type": "blob",
          "size": 16989
        },
        {
          "path": "plugins/utilities/git/commands/rebase-interactive.md",
          "type": "blob",
          "size": 18108
        },
        {
          "path": "plugins/utilities/git/commands/reflog-recover.md",
          "type": "blob",
          "size": 17777
        },
        {
          "path": "plugins/utilities/git/commands/stash-manager.md",
          "type": "blob",
          "size": 17948
        },
        {
          "path": "plugins/utilities/git/commands/worktree.md",
          "type": "blob",
          "size": 14267
        },
        {
          "path": "plugins/utilities/git/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/utilities/git/skills/git-advanced",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/utilities/git/skills/git-advanced/SKILL.md",
          "type": "blob",
          "size": 15437
        },
        {
          "path": "plugins/utilities/git/skills/git-conventions",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/utilities/git/skills/git-conventions/SKILL.md",
          "type": "blob",
          "size": 12929
        },
        {
          "path": "plugins/utilities/git/skills/git-repository",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/utilities/git/skills/git-repository/SKILL.md",
          "type": "blob",
          "size": 18364
        },
        {
          "path": "plugins/utilities/git/skills/git-troubleshooting",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/utilities/git/skills/git-troubleshooting/SKILL.md",
          "type": "blob",
          "size": 14909
        }
      ],
      "marketplace": {
        "name": "geoffjay-claude-plugins",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "Geoff Johnson",
          "email": "geoff.jay@gmail.com",
          "url": "https://github.com/geoffjay"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "claude-plugin",
            "description": "Plugin management and scaffolding tools for creating and maintaining Claude Code plugins",
            "source": "./plugins/claude-plugin",
            "category": "plugin-management",
            "version": "1.0.0",
            "author": {
              "name": "Geoff Johnson",
              "url": "https://github.com/geoffjay"
            },
            "install_commands": [
              "/plugin marketplace add geoffjay/claude-plugins",
              "/plugin install claude-plugin@geoffjay-claude-plugins"
            ],
            "signals": {
              "stars": 4,
              "forks": 1,
              "pushed_at": "2025-11-04T20:23:37Z",
              "created_at": "2025-10-17T18:24:21Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/create",
                "description": "Create a new Claude Code plugin with agents, commands, and/or skills",
                "path": "plugins/claude-plugin/commands/create.md",
                "frontmatter": {
                  "name": "claude-plugin:create",
                  "description": "Create a new Claude Code plugin with agents, commands, and/or skills"
                },
                "content": "# Create Plugin Command\n\nCreate a new Claude Code plugin following granular, composable architecture principles.\n\n## Arguments\n\n- `$1` - Plugin name (required, hyphen-case format)\n- `$2` - Plugin description (required)\n- `$3` - Components to create: `agents`, `commands`, `skills`, or combinations like `agents,commands` (optional, defaults to prompting)\n- `$4` - Additional configuration as JSON (optional)\n\n## Usage\n\n```bash\n# Basic usage - will prompt for details\n/claude-plugin:create my-plugin-name \"Plugin description\"\n\n# Specify components\n/claude-plugin:create my-plugin-name \"Plugin description\" agents,commands\n\n# Full configuration\n/claude-plugin:create golang-advanced \"Advanced Go development tools\" agents,commands,skills '{\"category\":\"languages\",\"model\":\"claude-sonnet-4\"}'\n```\n\n## Workflow\n\nThis command orchestrates plugin creation by:\n\n1. **Validating Input**\n\n   - Verify plugin name follows hyphen-case convention\n   - Ensure plugin doesn't already exist\n   - Validate component specifications\n\n2. **Gathering Requirements**\n\n   - If components not specified, ask user what to create\n   - Request additional details about agents (names, purposes, models)\n   - Request command details (names, purposes, workflows)\n   - Request skill details (names, triggers, content structure)\n\n3. **Creating Plugin Structure**\n\n   - Create plugin directory: `plugins/$PLUGIN_NAME/`\n   - Create component directories as needed\n   - Set up skill subdirectories (SKILL.md, assets/, references/)\n\n4. **Generating Components**\n\n   - Use Task tool with subagent_type=\"claude-plugin\" to design and implement components\n   - Create agent files with proper frontmatter\n   - Create command files with argument handling\n   - Create skill files with progressive disclosure\n\n5. **Updating Marketplace**\n   - Invoke marketplace-update skill to add plugin entry\n   - Invoke documentation-update skill to update docs\n\n---\n\n## Implementation\n\n**Plugin Name:** ${1:-\"[REQUIRED]\"}\n**Description:** ${2:-\"[REQUIRED]\"}\n**Components:** ${3:-\"[PROMPT USER]\"}\n**Configuration:** ${4:-\"{}\"}\n\n### Step 1: Validate Plugin Name\n\nThe plugin name must:\n\n- Be in hyphen-case format (e.g., `my-plugin-name`)\n- Not already exist in `plugins/` directory\n- Be descriptive and focused on a single purpose\n\n### Step 2: Determine Components\n\nIf components are not specified in `$3`, ask the user:\n\n**\"What components should this plugin include?\"**\n\nOptions:\n\n- **Agents** - Specialized domain experts with deep knowledge\n- **Commands** - Tools and workflow automation\n- **Skills** - Modular knowledge packages with progressive disclosure\n\nThe plugin must have at least one agent OR one command.\n\n### Step 3: Gather Component Details\n\nFor each component type selected:\n\n#### Agents\n\n- Agent name (hyphen-case)\n- Agent purpose and description\n- Recommended model (haiku for deterministic tasks, sonnet for complex reasoning)\n- Key capabilities\n- Example use cases\n\n#### Commands\n\n- Command name (hyphen-case)\n- Command purpose and description\n- Expected arguments\n- Workflow steps\n- Integration points\n\n#### Skills\n\n- Skill name (hyphen-case)\n- Skill description with \"Use when\" trigger\n- Progressive disclosure structure\n- Required assets (templates, examples)\n- Reference documentation needs\n\n### Step 4: Invoke Plugin Architect\n\nUse Task tool with subagent_type=\"claude-plugin\" to design and implement the plugin:\n\n```\nI need to create a new plugin called \"$PLUGIN_NAME\" with the following specifications:\n\nDescription: $PLUGIN_DESCRIPTION\nComponents: $COMPONENTS\nDetails: [collected from user]\n\nPlease design and implement this plugin following the architecture principles:\n- Single responsibility\n- Composability\n- Context efficiency\n- Spec compliance\n\nCreate all necessary files with proper frontmatter, documentation, and examples.\n```\n\n### Step 5: Update Repository\n\nAfter plugin creation:\n\n1. **Update Marketplace**\n\n   Invoke the marketplace-update skill by running the Python script:\n\n   ```bash\n   python plugins/claude-plugin/skills/marketplace-update/marketplace_update.py add \\\n     --name \"$PLUGIN_NAME\" \\\n     --description \"$PLUGIN_DESCRIPTION\" \\\n     --version \"1.0.0\" \\\n     --category \"$CATEGORY\" \\\n     --agents \"$(ls plugins/$PLUGIN_NAME/agents/*.md 2>/dev/null | xargs -n1 basename | tr '\\n' ',')\" \\\n     --commands \"$(ls plugins/$PLUGIN_NAME/commands/*.md 2>/dev/null | xargs -n1 basename | tr '\\n' ',')\" \\\n     --skills \"$(ls -d plugins/$PLUGIN_NAME/skills/*/ 2>/dev/null | xargs -n1 basename | tr '\\n' ',')\"\n   ```\n\n2. **Update Documentation**\n\n   Invoke the documentation-update skill by running the Python script:\n\n   ```bash\n   python plugins/claude-plugin/skills/documentation-update/doc_generator.py\n   ```\n\n   This regenerates:\n   - `docs/agents.md` - Agent reference\n   - `docs/agent-skills.md` - Skills catalog\n   - `docs/plugins.md` - Plugin directory\n   - `docs/usage.md` - Usage guide\n\n3. **Verify Structure**\n   - Check all files have proper frontmatter\n   - Verify naming conventions\n   - Ensure documentation is complete\n   - Confirm marketplace.json is valid\n   - Verify all documentation files were regenerated\n\n### Step 6: Confirm Success\n\nReport to the user:\n\n- ✓ Plugin created at `plugins/$PLUGIN_NAME/`\n- ✓ Components created: [list]\n- ✓ Marketplace updated\n- ✓ Documentation updated\n- Next steps or usage instructions\n\n## Examples\n\n### Example 1: Create Language Plugin\n\n```bash\n/claude-plugin:create rust-development \"Rust language development tools\" agents,commands,skills\n```\n\nThis would:\n\n- Create `plugins/rust-development/`\n- Prompt for agent details (e.g., rust-pro agent)\n- Prompt for command details (e.g., rust-scaffold command)\n- Prompt for skill details (e.g., rust-patterns skill)\n- Generate all components with proper structure\n- Update marketplace and documentation\n\n### Example 2: Create Security Plugin\n\n```bash\n/claude-plugin:create security-scanning \"Security vulnerability scanning and analysis\" agents,commands\n```\n\nThis would:\n\n- Create `plugins/security-scanning/`\n- Prompt for security agent details\n- Prompt for scanning command details\n- Generate components without skills\n- Update marketplace and documentation\n\n### Example 3: Create Minimal Plugin\n\n```bash\n/claude-plugin:create test-helper \"Test generation helper utilities\" commands\n```\n\nThis would:\n\n- Create `plugins/test-helper/`\n- Prompt for command details only\n- Generate command file\n- Update marketplace and documentation\n\n## Error Handling\n\nCommon issues and resolutions:\n\n### Plugin Already Exists\n\nIf `plugins/$PLUGIN_NAME/` exists:\n\n- Error: \"Plugin '$PLUGIN_NAME' already exists. Use /claude-plugin:update to modify existing plugins.\"\n- Suggest using `/claude-plugin:update` command instead\n\n### Invalid Plugin Name\n\nIf plugin name is not hyphen-case:\n\n- Error: \"Plugin name must be in hyphen-case format (e.g., 'my-plugin-name')\"\n- Suggest correct format\n\n### No Components Specified\n\nIf user doesn't specify components and doesn't respond to prompts:\n\n- Error: \"At least one component (agent or command) is required\"\n- Prompt again with clear options\n\n### Missing Required Arguments\n\nIf `$1` or `$2` are not provided:\n\n- Error: \"Usage: /claude-plugin:create <plugin-name> <description> [components] [config]\"\n- Show examples\n\n## Notes\n\n- This command creates new plugins only. Use `/claude-plugin:update` to modify existing plugins.\n- All generated files will include proper YAML frontmatter\n- The plugin-architect agent ensures adherence to architecture principles\n- Skills are invoked automatically for marketplace and documentation updates\n- Generated code follows best practices and spec compliance"
              },
              {
                "name": "/documentation",
                "description": "Regenerate all documentation files from marketplace data and plugin metadata",
                "path": "plugins/claude-plugin/commands/documentation.md",
                "frontmatter": {
                  "name": "claude-plugin:documentation",
                  "description": "Regenerate all documentation files from marketplace data and plugin metadata"
                },
                "content": "# Documentation Generation Command\n\nRegenerate all documentation files (agents.md, agent-skills.md, plugins.md, usage.md) from the marketplace catalog and plugin metadata using Jinja2 templates.\n\n## Arguments\n\n- `$1` - Specific file to generate: `agents`, `agent-skills`, `plugins`, `usage`, or `all` (optional, defaults to `all`)\n- `$2` - Additional options as JSON (optional)\n\n## Usage\n\n```bash\n# Regenerate all documentation files\n/claude-plugin:documentation\n\n# Regenerate specific file\n/claude-plugin:documentation agents\n\n# Dry run to preview changes\n/claude-plugin:documentation all '{\"dry_run\": true}'\n\n# Specify custom paths\n/claude-plugin:documentation all '{\"marketplace\": \".claude-plugins/marketplace.json\", \"output\": \"docs\"}'\n```\n\n## Workflow\n\nThis command orchestrates documentation generation by:\n\n1. **Validating Prerequisites**\n\n   - Verify marketplace.json exists and is valid\n   - Check template files exist in documentation-update skill\n   - Ensure plugin directories are accessible\n   - Verify output directory exists or can be created\n\n2. **Preparing Context**\n\n   - Load marketplace catalog\n   - Scan all plugin directories\n   - Extract agent/command/skill metadata\n   - Build component indexes\n   - Calculate statistics\n\n3. **Generating Documentation**\n\n   - Invoke documentation-update skill\n   - Render Jinja2 templates with context\n   - Write output to docs/ directory\n   - Report any warnings or errors\n\n4. **Verifying Output**\n   - Check all requested files were generated\n   - Verify file formatting and structure\n   - Validate links and references\n   - Report success and statistics\n\n---\n\n## Implementation\n\n**Target File:** ${1:-\"all\"}\n**Options:** ${2:-\"{}\"}\n\n### Step 1: Validate Prerequisites\n\nCheck that all required components exist:\n\n```bash\n# Check marketplace exists\nif [ ! -f .claude-plugins/marketplace.json ]; then\n  echo \"Error: Marketplace file not found at .claude-plugins/marketplace.json\"\n  exit 1\nfi\n\n# Check skill exists\nif [ ! -f plugins/claude-plugin/skills/documentation-update/doc_generator.py ]; then\n  echo \"Error: Documentation update skill not found\"\n  exit 1\nfi\n\n# Check templates exist\nif [ ! -d plugins/claude-plugin/skills/documentation-update/assets ]; then\n  echo \"Error: Template directory not found\"\n  exit 1\nfi\n\n# Create docs directory if needed\nmkdir -p docs\n```\n\n### Step 2: Parse Options\n\nExtract configuration from `$2` JSON parameter:\n\n- `dry_run`: Preview output without writing files\n- `marketplace`: Custom path to marketplace.json\n- `templates`: Custom path to template directory\n- `output`: Custom output directory\n- `verbose`: Show detailed progress\n\n### Step 3: Invoke Documentation Update Skill\n\nRun the documentation generation script:\n\n```bash\n# Build command with options\nPYTHON_CMD=\"python plugins/claude-plugin/skills/documentation-update/doc_generator.py\"\n\n# Add file filter if specified\nif [ \"$TARGET_FILE\" != \"all\" ]; then\n  PYTHON_CMD=\"$PYTHON_CMD --file $TARGET_FILE\"\nfi\n\n# Add custom paths if provided\nif [ -n \"$MARKETPLACE_PATH\" ]; then\n  PYTHON_CMD=\"$PYTHON_CMD --marketplace $MARKETPLACE_PATH\"\nfi\n\nif [ -n \"$TEMPLATES_PATH\" ]; then\n  PYTHON_CMD=\"$PYTHON_CMD --templates $TEMPLATES_PATH\"\nfi\n\nif [ -n \"$OUTPUT_PATH\" ]; then\n  PYTHON_CMD=\"$PYTHON_CMD --output $OUTPUT_PATH\"\nfi\n\n# Add dry-run flag if requested\nif [ \"$DRY_RUN\" = \"true\" ]; then\n  PYTHON_CMD=\"$PYTHON_CMD --dry-run\"\nfi\n\n# Add verbose flag if requested\nif [ \"$VERBOSE\" = \"true\" ]; then\n  PYTHON_CMD=\"$PYTHON_CMD --verbose\"\nfi\n\n# Execute command\necho \"Generating documentation...\"\neval $PYTHON_CMD\n```\n\n### Step 4: Report Results\n\nAfter successful generation:\n\n```\n✓ Documentation generation completed\n\nFiles generated:\n- docs/agents.md (25 agents across 10 plugins)\n- docs/agent-skills.md (30 skills with progressive disclosure)\n- docs/plugins.md (10 plugins in 4 categories)\n- docs/usage.md (Usage guide and examples)\n\nStatistics:\n- Total plugins: 10\n- Total agents: 25\n- Total commands: 15\n- Total skills: 30\n\nAll documentation files are now synchronized with the marketplace catalog.\n```\n\nIf errors occurred:\n\n```\n❌ Documentation generation failed\n\nErrors encountered:\n- Template not found: assets/agents.md.j2\n- Invalid frontmatter in plugins/example/agents/test.md\n\nPlease fix the errors above and run the command again.\n```\n\n## Examples\n\n### Example 1: Full Documentation Update\n\n```bash\n/claude-plugin:documentation\n```\n\n**Output:**\n```\nGenerating documentation...\n✓ Loading marketplace.json\n✓ Scanning plugin directories\n✓ Extracting metadata from 10 plugins\n✓ Building component indexes\n✓ Rendering templates\n✓ Writing docs/agents.md\n✓ Writing docs/agent-skills.md\n✓ Writing docs/plugins.md\n✓ Writing docs/usage.md\n\nDocumentation generation completed successfully.\n```\n\n### Example 2: Generate Single File\n\n```bash\n/claude-plugin:documentation agents\n```\n\n**Output:**\n```\nGenerating documentation...\n✓ Loading marketplace.json\n✓ Scanning plugin directories\n✓ Extracting agent metadata\n✓ Rendering agents.md.j2 template\n✓ Writing docs/agents.md\n\nGenerated docs/agents.md with 25 agents.\n```\n\n### Example 3: Dry Run\n\n```bash\n/claude-plugin:documentation all '{\"dry_run\": true}'\n```\n\n**Output:**\n```\nDry run mode - no files will be written\n\nPreview of docs/agents.md:\n===========================\n# Agent Reference\n\nThis document lists all agents available across plugins in the marketplace.\n\n## Languages\n\n### rust-development\n...\n\nPreview of docs/agent-skills.md:\n=================================\n...\n\nDry run completed. Run without --dry-run to write files.\n```\n\n### Example 4: Custom Paths\n\n```bash\n/claude-plugin:documentation all '{\"marketplace\": \"custom/marketplace.json\", \"output\": \"generated-docs\"}'\n```\n\n**Output:**\n```\nGenerating documentation...\n✓ Loading custom/marketplace.json\n✓ Using default templates\n✓ Output directory: generated-docs\n✓ Generating all documentation files\n✓ Writing generated-docs/agents.md\n✓ Writing generated-docs/agent-skills.md\n✓ Writing generated-docs/plugins.md\n✓ Writing generated-docs/usage.md\n\nDocumentation generation completed successfully.\n```\n\n## Generated Files\n\nThis command generates the following documentation files:\n\n### 1. docs/agents.md\n\n**Purpose:** Complete reference of all agents across all plugins\n\n**Contents:**\n- Agents organized by plugin and category\n- Agent name, description, and model\n- Links to agent files\n- Agent capabilities and use cases\n- Statistics on total agents\n\n**Example Structure:**\n```markdown\n# Agent Reference\n\n## Languages\n\n### rust-development\n\n**Agents:**\n\n- **rust-pro** (`claude-sonnet-4`)\n  - Master Rust 1.75+ with modern async patterns...\n  - File: `plugins/rust-development/agents/rust-pro.md`\n```\n\n### 2. docs/agent-skills.md\n\n**Purpose:** Catalog of all skills with progressive disclosure details\n\n**Contents:**\n- Skills organized by plugin\n- Skill name and description\n- \"Use when\" triggers\n- Skill structure and location\n- Statistics on total skills\n\n**Example Structure:**\n```markdown\n# Agent Skills Reference\n\n## Plugin Management\n\n### claude-plugin\n\n**Skills:**\n\n#### documentation-update\n\nRegenerates documentation files from marketplace data using Jinja templates. Use when plugins are added, updated, or removed.\n\n- **Location:** `plugins/claude-plugin/skills/documentation-update/`\n- **Structure:** SKILL.md + assets/ + references/\n```\n\n### 3. docs/plugins.md\n\n**Purpose:** Directory of all plugins in the marketplace\n\n**Contents:**\n- Plugins organized by category\n- Plugin name, description, and version\n- List of components (agents, commands, skills)\n- Installation and usage information\n- Statistics on total plugins\n\n**Example Structure:**\n```markdown\n# Plugin Directory\n\n## Plugin Management\n\n### claude-plugin (v1.0.0)\n\nPlugin management and scaffolding tools.\n\n**Components:**\n- Agents: plugin-architect\n- Commands: create, update, documentation\n- Skills: marketplace-update, documentation-update\n\n**Installation:** Available by default\n```\n\n### 4. docs/usage.md\n\n**Purpose:** Usage guide and command reference\n\n**Contents:**\n- Getting started instructions\n- Command usage examples\n- Workflow patterns\n- Integration guides\n- Best practices\n\n**Example Structure:**\n```markdown\n# Usage Guide\n\n## Getting Started\n\nThis marketplace provides Claude Code plugins following a granular, composable architecture...\n\n## Creating Plugins\n\nUse the `/claude-plugin:create` command to create new plugins:\n\n\\`\\`\\`bash\n/claude-plugin:create my-plugin \"Plugin description\"\n\\`\\`\\`\n\n## Updating Documentation\n\nAfter making changes to plugins, regenerate documentation:\n\n\\`\\`\\`bash\n/claude-plugin:documentation\n\\`\\`\\`\n```\n\n## Integration with Other Commands\n\nThis command is automatically invoked by:\n\n### /claude-plugin:create\n\nAfter creating a new plugin:\n```\n✓ Plugin created at plugins/my-plugin/\n✓ Marketplace updated\n⏳ Updating documentation...\n✓ Documentation updated\n```\n\n### /claude-plugin:update\n\nAfter updating an existing plugin:\n```\n✓ Plugin updated at plugins/my-plugin/\n✓ Marketplace updated\n⏳ Updating documentation...\n✓ Documentation updated\n```\n\n### Manual Invocation\n\nUsers can also run this command manually:\n- After editing plugin files directly\n- To refresh documentation after git pull\n- To verify documentation is up to date\n- To preview changes with dry-run\n\n## Error Handling\n\nCommon issues and resolutions:\n\n### Marketplace Not Found\n\n```\nError: Marketplace file not found at .claude-plugins/marketplace.json\n\nSuggestion:\n- Verify you're in the repository root\n- Check that .claude-plugins/marketplace.json exists\n- Run /claude-plugin:create to create your first plugin\n```\n\n### Template Not Found\n\n```\nError: Template file not found: assets/agents.md.j2\n\nSuggestion:\n- Verify claude-plugin plugin is properly installed\n- Check that all template files exist in:\n  plugins/claude-plugin/skills/documentation-update/assets/\n- Reinstall the claude-plugin plugin if needed\n```\n\n### Invalid Frontmatter\n\n```\nWarning: Could not parse frontmatter in plugins/my-plugin/agents/my-agent.md\n\nSuggestion:\n- Check YAML frontmatter syntax in the agent file\n- Ensure frontmatter is enclosed in --- markers\n- Verify required fields: name, description\n- Fix syntax errors and run command again\n```\n\n### Missing Plugin Directory\n\n```\nWarning: Plugin 'my-plugin' in marketplace.json but directory not found\n\nSuggestion:\n- Verify plugins/my-plugin/ directory exists\n- Remove stale entry from marketplace.json\n- Recreate plugin if it was accidentally deleted\n```\n\n### Permission Denied\n\n```\nError: Permission denied writing to docs/agents.md\n\nSuggestion:\n- Check write permissions on docs/ directory\n- Ensure docs/ directory is not read-only\n- Run with appropriate permissions\n```\n\n### Python Not Found\n\n```\nError: python command not found\n\nSuggestion:\n- Install Python 3.8 or later\n- Ensure python is in your PATH\n- Try using python3 instead of python\n```\n\n## Template System\n\nThe documentation generation uses Jinja2 templates located in:\n\n```\nplugins/claude-plugin/skills/documentation-update/assets/\n├── agents.md.j2\n├── agent-skills.md.j2\n├── plugins.md.j2\n└── usage.md.j2\n```\n\n### Template Context\n\nAll templates receive the following context:\n\n```python\n{\n  \"marketplace\": {\n    \"name\": \"marketplace-name\",\n    \"owner\": {...},\n    \"metadata\": {...},\n    \"plugins\": [...]\n  },\n  \"plugins_by_category\": {\n    \"category-name\": [plugin1, plugin2, ...]\n  },\n  \"all_agents\": [...],\n  \"all_skills\": [...],\n  \"all_commands\": [...],\n  \"stats\": {\n    \"total_plugins\": 10,\n    \"total_agents\": 25,\n    \"total_commands\": 15,\n    \"total_skills\": 30\n  },\n  \"now\": \"2025-10-17\"\n}\n```\n\n### Customizing Templates\n\nTo customize documentation output:\n\n1. **Edit Existing Templates**\n   - Modify templates in assets/ directory\n   - Use Jinja2 syntax for dynamic content\n   - Test with dry-run before committing\n\n2. **Add New Templates**\n   - Create new template file in assets/\n   - Update doc_generator.py to render new template\n   - Define output path for new file\n\n3. **Test Changes**\n   - Run with --dry-run to preview\n   - Verify formatting and structure\n   - Check for template errors\n\n## Best Practices\n\n1. **Run After Every Plugin Change**\n   - Documentation should always reflect current state\n   - Commit documentation with plugin changes\n   - Include in pull request reviews\n\n2. **Use Dry Run for Testing**\n   - Preview changes before writing\n   - Test template modifications\n   - Verify output structure\n\n3. **Keep Templates Simple**\n   - Use clear Jinja2 syntax\n   - Document template variables\n   - Handle missing data gracefully\n\n4. **Validate Output**\n   - Check generated files for correctness\n   - Verify all links work\n   - Test formatting renders properly\n\n5. **Version Control**\n   - Commit documentation changes\n   - Include meaningful commit messages\n   - Tag major documentation updates\n\n## Success Criteria\n\nAfter running this command:\n\n- ✓ All requested documentation files generated\n- ✓ Content matches marketplace state\n- ✓ All links are valid and correct\n- ✓ Formatting is consistent\n- ✓ Statistics are accurate\n- ✓ No template rendering errors\n- ✓ All plugins represented\n- ✓ Metadata correctly extracted\n\n## Troubleshooting\n\n### Templates Not Rendering\n\n**Problem:** Templates fail to render with Jinja2 errors\n\n**Solutions:**\n- Check Jinja2 syntax in templates\n- Verify all variables are defined\n- Use default filters for optional values\n- Test templates with minimal data first\n\n### Missing Component Data\n\n**Problem:** Some agents/commands/skills not appearing in docs\n\n**Solutions:**\n- Verify frontmatter exists and is valid\n- Check file naming follows conventions\n- Ensure files have correct extensions (.md)\n- Verify plugin directory structure\n\n### Outdated Documentation\n\n**Problem:** Documentation doesn't match current plugin state\n\n**Solutions:**\n- Run this command to regenerate\n- Check marketplace.json is up to date\n- Verify all plugin files exist\n- Look for stale cache or old files\n\n### Performance Issues\n\n**Problem:** Generation takes too long with many plugins\n\n**Solutions:**\n- Use --file option to generate single files\n- Optimize template complexity\n- Consider caching marketplace data\n- Profile doc_generator.py for bottlenecks\n\n## Related Commands\n\n- `/claude-plugin:create` - Create new plugin (auto-generates docs)\n- `/claude-plugin:update` - Update existing plugin (auto-generates docs)\n\n## Related Skills\n\n- `marketplace-update` - Update marketplace.json catalog\n- `documentation-update` - The skill this command invokes\n\n## Notes\n\n- This command is idempotent - safe to run multiple times\n- Generated files should be committed to version control\n- Templates use Python's built-in string formatting (no external dependencies)\n- The command will create the docs/ directory if it doesn't exist\n- Existing documentation files are overwritten without backup\n- The documentation-update skill has no external dependencies"
              },
              {
                "name": "/update",
                "description": "Update an existing Claude Code plugin by adding, modifying, or removing components",
                "path": "plugins/claude-plugin/commands/update.md",
                "frontmatter": {
                  "name": "claude-plugin:update",
                  "description": "Update an existing Claude Code plugin by adding, modifying, or removing components"
                },
                "content": "# Update Plugin Command\n\nUpdate an existing Claude Code plugin by adding new components, modifying existing ones, or removing obsolete components.\n\n## Arguments\n\n- `$1` - Plugin name (required, must exist in plugins/)\n- `$2` - Update operation: `add`, `modify`, or `remove` (required)\n- `$3` - Component type: `agent`, `command`, or `skill` (required)\n- `$4` - Component name (required for modify/remove, optional for add)\n- `$5` - Additional configuration as JSON (optional)\n\n## Usage\n\n```bash\n# Add a new agent to existing plugin\n/claude-plugin:update golang-development add agent golang-testing\n\n# Modify an existing command\n/claude-plugin:update golang-development modify command golang-scaffold\n\n# Remove a skill\n/claude-plugin:update golang-development remove skill golang-patterns\n\n# Add with configuration\n/claude-plugin:update rust-development add agent rust-async '{\"model\":\"claude-sonnet-4\",\"description\":\"Async Rust expert\"}'\n```\n\n## Workflow\n\nThis command orchestrates plugin updates by:\n\n1. **Validating Input**\n\n   - Verify plugin exists in `plugins/` directory\n   - Validate operation type (add/modify/remove)\n   - Ensure component type is valid\n   - Check component existence for modify/remove operations\n\n2. **Gathering Requirements**\n\n   - For **add**: collect new component details\n   - For **modify**: identify what needs to change\n   - For **remove**: confirm removal and check dependencies\n\n3. **Performing Update**\n\n   - Use Task tool with subagent_type=\"claude-plugin\" to execute changes\n   - Create, modify, or remove component files\n   - Maintain spec compliance and naming conventions\n\n4. **Updating Marketplace**\n   - Invoke marketplace-update skill to update plugin entry\n   - Invoke documentation-update skill to regenerate docs\n\n---\n\n## Implementation\n\n**Plugin Name:** ${1:-\"[REQUIRED]\"}\n**Operation:** ${2:-\"[REQUIRED: add|modify|remove]\"}\n**Component Type:** ${3:-\"[REQUIRED: agent|command|skill]\"}\n**Component Name:** ${4:-\"[REQUIRED for modify/remove]\"}\n**Configuration:** ${5:-\"{}\"}\n\n### Step 1: Validate Plugin Exists\n\nCheck that `plugins/$PLUGIN_NAME/` exists:\n\n- If not found: Error \"Plugin '$PLUGIN_NAME' not found. Use /create to create new plugins.\"\n- If found: Continue to operation validation\n\n### Step 2: Validate Operation\n\nBased on `$2` operation type:\n\n#### Add Operation\n\n- Create new component in existing plugin\n- Component name can be provided in `$4` or prompted\n- Gather full component specifications\n\n#### Modify Operation\n\n- Update existing component\n- Component name must be provided in `$4`\n- Verify component file exists\n- Ask what needs to be changed\n\n#### Remove Operation\n\n- Delete existing component\n- Component name must be provided in `$4`\n- Verify component file exists\n- Confirm removal with user\n- Check for dependencies\n\n### Step 3: Execute Operation\n\nUse Task tool with subagent_type=\"claude-plugin\" to perform the update:\n\n#### For Add Operation\n\n```\nI need to add a new $COMPONENT_TYPE to the \"$PLUGIN_NAME\" plugin:\n\nComponent Name: $COMPONENT_NAME\nComponent Type: $COMPONENT_TYPE\nConfiguration: $CONFIGURATION\n\nPlease design and implement this component following architecture principles:\n- Single responsibility\n- Spec compliance\n- Proper frontmatter\n- Complete documentation\n\nIntegrate it with the existing plugin structure.\n```\n\n#### For Modify Operation\n\n```\nI need to modify the $COMPONENT_TYPE named \"$COMPONENT_NAME\" in the \"$PLUGIN_NAME\" plugin:\n\nChanges Requested: [gathered from user]\nConfiguration: $CONFIGURATION\n\nPlease update the component while:\n- Maintaining backward compatibility\n- Following spec compliance\n- Updating documentation\n- Preserving existing functionality where appropriate\n```\n\n#### For Remove Operation\n\n```\nI need to remove the $COMPONENT_TYPE named \"$COMPONENT_NAME\" from the \"$PLUGIN_NAME\" plugin:\n\nReason: [gathered from user if needed]\n\nPlease:\n- Remove the component file\n- Check for and warn about any dependencies\n- Update plugin structure\n- Clean up any orphaned assets\n```\n\n### Step 4: Update Repository\n\nAfter component update:\n\n1. **Update Marketplace**\n\n   Invoke the marketplace-update skill by running the appropriate Python command:\n\n   **For Add Operation:**\n   ```bash\n   python plugins/claude-plugin/skills/marketplace-update/marketplace_update.py update \\\n     --name \"$PLUGIN_NAME\" \\\n     --add-agent \"$COMPONENT_NAME.md\"    # if adding agent\n     --add-command \"$COMPONENT_NAME.md\"  # if adding command\n     --add-skill \"$COMPONENT_NAME\"       # if adding skill\n   ```\n\n   **For Remove Operation:**\n   ```bash\n   python plugins/claude-plugin/skills/marketplace-update/marketplace_update.py update \\\n     --name \"$PLUGIN_NAME\" \\\n     --remove-agent \"$COMPONENT_NAME.md\"    # if removing agent\n     --remove-command \"$COMPONENT_NAME.md\"  # if removing command\n     --remove-skill \"$COMPONENT_NAME\"       # if removing skill\n   ```\n\n   **For Modify Operation (version update):**\n   ```bash\n   python plugins/claude-plugin/skills/marketplace-update/marketplace_update.py update \\\n     --name \"$PLUGIN_NAME\" \\\n     --version \"1.0.1\"  # or appropriate version bump\n   ```\n\n2. **Update Documentation**\n\n   Invoke the documentation-update skill by running the Python script:\n\n   ```bash\n   python plugins/claude-plugin/skills/documentation-update/doc_generator.py\n   ```\n\n   This regenerates all documentation files to reflect the changes.\n\n3. **Verify Integrity**\n   - Check plugin still has at least one agent or command\n   - Verify all references are valid\n   - Ensure frontmatter is correct\n   - Confirm marketplace.json is valid\n   - Verify documentation was regenerated\n\n### Step 5: Confirm Success\n\nReport to the user:\n\n- ✓ Operation completed: [$OPERATION $COMPONENT_TYPE $COMPONENT_NAME]\n- ✓ Plugin updated at `plugins/$PLUGIN_NAME/`\n- ✓ Marketplace updated\n- ✓ Documentation updated\n- ✓ Current plugin structure: [list components]\n\n## Operation Details\n\n### Add Operation\n\nWhen adding a new component:\n\n**For Agents:**\n\n- Prompt for agent name (hyphen-case)\n- Prompt for purpose and description\n- Prompt for model selection (haiku/sonnet)\n- Prompt for capabilities and guidelines\n- Create `plugins/$PLUGIN_NAME/agents/$AGENT_NAME.md`\n\n**For Commands:**\n\n- Prompt for command name (hyphen-case)\n- Prompt for purpose and description\n- Prompt for arguments and workflow\n- Create `plugins/$PLUGIN_NAME/commands/$COMMAND_NAME.md`\n\n**For Skills:**\n\n- Prompt for skill name (hyphen-case)\n- Prompt for description with \"Use when\" trigger\n- Prompt for asset requirements\n- Create skill directory structure:\n  - `plugins/$PLUGIN_NAME/skills/$SKILL_NAME/SKILL.md`\n  - `plugins/$PLUGIN_NAME/skills/$SKILL_NAME/assets/`\n  - `plugins/$PLUGIN_NAME/skills/$SKILL_NAME/references/`\n\n### Modify Operation\n\nWhen modifying an existing component:\n\n1. **Read Current Component**\n\n   - Load existing file\n   - Parse frontmatter and content\n   - Show current structure to user\n\n2. **Identify Changes**\n\n   - Ask user what needs to change:\n     - Update description\n     - Change model (agents only)\n     - Modify workflow\n     - Update examples\n     - Add/remove sections\n\n3. **Apply Changes**\n\n   - Update file maintaining structure\n   - Preserve frontmatter format\n   - Update version if significant changes\n\n4. **Validate**\n   - Ensure spec compliance\n   - Verify frontmatter is valid\n   - Check documentation completeness\n\n### Remove Operation\n\nWhen removing a component:\n\n1. **Confirm Removal**\n\n   - Show component details\n   - Ask user to confirm deletion\n   - Warn about potential impacts\n\n2. **Check Dependencies**\n\n   - Search for references to this component\n   - Warn if other plugins depend on it\n   - List commands that invoke this agent (if removing agent)\n\n3. **Execute Removal**\n\n   - Delete component file\n   - Remove from marketplace entry\n   - Clean up orphaned directories\n\n4. **Verify Plugin Integrity**\n   - Ensure plugin still has at least one agent or command\n   - If removing last component: warn and confirm plugin deletion\n\n## Examples\n\n### Example 1: Add New Agent\n\n```bash\n/claude-plugin:update golang-development add agent gin-expert\n```\n\nThis would:\n\n- Verify `plugins/golang-development/` exists\n- Prompt for agent details (description, model, capabilities)\n- Create `plugins/golang-development/agents/gin-expert.md`\n- Update marketplace.json\n- Update documentation\n\n### Example 2: Modify Existing Command\n\n```bash\n/claude-plugin:update security-scanning modify command sast-scan\n```\n\nThis would:\n\n- Load existing `plugins/security-scanning/commands/sast-scan.md`\n- Show current configuration\n- Ask what needs to change\n- Update the file\n- Update documentation\n\n### Example 3: Remove Skill\n\n```bash\n/claude-plugin:update kubernetes-operations remove skill helm-charts\n```\n\nThis would:\n\n- Confirm removal\n- Check for dependencies\n- Delete `plugins/kubernetes-operations/skills/helm-charts/`\n- Update marketplace.json\n- Update documentation\n\n### Example 4: Add Agent with Configuration\n\n```bash\n/claude-plugin:update python-development add agent fastapi-pro '{\"model\":\"claude-sonnet-4\",\"description\":\"FastAPI framework expert\"}'\n```\n\nThis would:\n\n- Use provided configuration\n- Create agent with Sonnet model\n- Generate comprehensive system prompt\n- Update marketplace and docs\n\n## Error Handling\n\nCommon issues and resolutions:\n\n### Plugin Not Found\n\nIf `plugins/$PLUGIN_NAME/` doesn't exist:\n\n- Error: \"Plugin '$PLUGIN_NAME' not found. Use /claude-plugin:create to create new plugins.\"\n- List available plugins\n\n### Component Already Exists (Add)\n\nIf trying to add a component that exists:\n\n- Error: \"Component '$COMPONENT_NAME' already exists. Use 'modify' operation to update it.\"\n- Show current component details\n\n### Component Not Found (Modify/Remove)\n\nIf component doesn't exist:\n\n- Error: \"Component '$COMPONENT_NAME' not found in plugin '$PLUGIN_NAME'.\"\n- List available components in plugin\n\n### Invalid Operation\n\nIf `$2` is not add/modify/remove:\n\n- Error: \"Invalid operation. Must be: add, modify, or remove\"\n- Show usage examples\n\n### Removing Last Component\n\nIf removing the last agent and command:\n\n- Warning: \"This is the last component in the plugin. Removing it will leave an empty plugin.\"\n- Confirm: \"Do you want to remove the entire plugin?\"\n\n### Dependencies Detected (Remove)\n\nIf other components reference the component being removed:\n\n- Warning: \"The following components reference '$COMPONENT_NAME': [list]\"\n- Confirm: \"Proceed with removal? You may need to update dependent components.\"\n\n## Version Management\n\nWhen updating plugins:\n\n### Minor Updates\n\n- Adding new components\n- Enhancing existing components\n- Adding examples or documentation\n- Increment patch version (1.0.0 → 1.0.1)\n\n### Major Updates\n\n- Modifying component interfaces\n- Changing agent models\n- Removing components\n- Breaking changes\n- Increment minor or major version (1.0.0 → 1.1.0 or 2.0.0)\n\n## Notes\n\n- This command updates existing plugins only. Use `/claude-plugin:create` for new plugins.\n- All changes maintain spec compliance and proper frontmatter\n- The plugin-architect agent ensures consistency with architecture principles\n- Skills are invoked automatically for marketplace and documentation updates\n- Backward compatibility should be maintained when possible\n- Always test updated components before committing changes"
              }
            ],
            "skills": [
              {
                "name": "documentation-update",
                "description": "Regenerates documentation files (agents.md, agent-skills.md, plugins.md, usage.md) from marketplace data using Jinja templates. Use when plugins are added, updated, or removed to keep documentation in sync.",
                "path": "plugins/claude-plugin/skills/documentation-update/SKILL.md",
                "frontmatter": {
                  "name": "documentation-update",
                  "description": "Regenerates documentation files (agents.md, agent-skills.md, plugins.md, usage.md) from marketplace data using Jinja templates. Use when plugins are added, updated, or removed to keep documentation in sync."
                },
                "content": "# Documentation Update Skill\n\nThis skill automatically regenerates documentation files in the `docs/` directory by reading the marketplace catalog and applying Jinja2 templates.\n\n## Purpose\n\nMaintain synchronized documentation by:\n\n- Generating agent reference documentation\n- Creating skill catalog documentation\n- Building plugin directory\n- Updating usage guides\n- Ensuring consistency across all docs\n\n## When to Use\n\nUse this skill when:\n\n- A new plugin is added to the marketplace\n- An existing plugin is updated (components added/removed)\n- Agent or skill metadata changes\n- Documentation needs to be regenerated\n- Ensuring docs match marketplace state\n\n## Documentation Files\n\nThis skill generates four main documentation files:\n\n### 1. agents.md\n\nComplete reference of all agents across all plugins:\n\n- Organized by plugin\n- Lists agent name, description, and model\n- Includes links to agent files\n- Shows agent capabilities and use cases\n\n### 2. agent-skills.md\n\nCatalog of all skills with progressive disclosure details:\n\n- Organized by plugin\n- Lists skill name and description\n- Shows \"Use when\" triggers\n- Includes skill structure information\n\n### 3. plugins.md\n\nDirectory of all plugins in the marketplace:\n\n- Organized by category\n- Shows plugin name, description, and version\n- Lists components (agents, commands, skills)\n- Provides installation and usage information\n\n### 4. usage.md\n\nUsage guide and command reference:\n\n- Getting started instructions\n- Command usage examples\n- Workflow patterns\n- Integration guides\n\n## Template Structure\n\nTemplates are stored in `assets/` using Jinja2 syntax:\n\n```\nassets/\n├── agents.md.j2\n├── agent-skills.md.j2\n├── plugins.md.j2\n└── usage.md.j2\n```\n\n### Template Variables\n\nAll templates receive the following context:\n\n```python\n{\n  \"marketplace\": {\n    \"name\": \"marketplace-name\",\n    \"owner\": {...},\n    \"metadata\": {...},\n    \"plugins\": [...]\n  },\n  \"plugins_by_category\": {\n    \"category-name\": [plugin1, plugin2, ...]\n  },\n  \"all_agents\": [\n    {\n      \"plugin\": \"plugin-name\",\n      \"name\": \"agent-name\",\n      \"file\": \"agent-file.md\",\n      \"description\": \"...\",\n      \"model\": \"...\"\n    }\n  ],\n  \"all_skills\": [\n    {\n      \"plugin\": \"plugin-name\",\n      \"name\": \"skill-name\",\n      \"path\": \"skill-path\",\n      \"description\": \"...\"\n    }\n  ],\n  \"all_commands\": [\n    {\n      \"plugin\": \"plugin-name\",\n      \"name\": \"command-name\",\n      \"file\": \"command-file.md\",\n      \"description\": \"...\"\n    }\n  ],\n  \"stats\": {\n    \"total_plugins\": 10,\n    \"total_agents\": 25,\n    \"total_commands\": 15,\n    \"total_skills\": 30\n  }\n}\n```\n\n## Python Script\n\nThe skill includes a Python script `doc_generator.py` that:\n\n1. **Loads marketplace.json**\n\n   - Reads the marketplace catalog\n   - Validates structure\n   - Builds component index\n\n2. **Scans Plugin Files**\n\n   - Reads agent/command frontmatter\n   - Extracts skill metadata\n   - Builds comprehensive component list\n\n3. **Prepares Template Context**\n\n   - Organizes plugins by category\n   - Creates component indexes\n   - Calculates statistics\n\n4. **Renders Templates**\n   - Applies Jinja2 templates\n   - Generates documentation files\n   - Writes to docs/ directory\n\n### Usage\n\n```bash\n# Generate all documentation files\npython doc_generator.py\n\n# Generate specific file only\npython doc_generator.py --file agents\n\n# Dry run (show output without writing)\npython doc_generator.py --dry-run\n\n# Specify custom paths\npython doc_generator.py \\\n  --marketplace .claude-plugin/marketplace.json \\\n  --templates plugins/claude-plugin/skills/documentation-update/assets \\\n  --output docs\n```\n\n## Integration with Commands\n\nThe `/claude-plugin:create` and `/claude-plugin:update` commands should invoke this skill automatically after marketplace updates:\n\n### Workflow\n\n```\n1. Plugin operation completes (add/update/remove)\n2. Marketplace.json is updated\n3. Invoke documentation-update skill\n4. Documentation files regenerated\n5. Changes ready to commit\n```\n\n### Example Integration\n\n```python\n# After creating/updating plugin\nprint(\"Updating documentation...\")\n\n# Run doc generator\nimport subprocess\nresult = subprocess.run(\n    [\"python\", \"plugins/claude-plugin/skills/documentation-update/doc_generator.py\"],\n    capture_output=True,\n    text=True\n)\n\nif result.returncode == 0:\n    print(\"✓ Documentation updated\")\nelse:\n    print(f\"❌ Documentation update failed: {result.stderr}\")\n```\n\n## Template Examples\n\n### agents.md.j2\n\n```jinja2\n# Agent Reference\n\nThis document lists all agents available across plugins in the marketplace.\n\n{% for category, plugins in plugins_by_category.items() %}\n## {{ category|title }}\n\n{% for plugin in plugins %}\n### {{ plugin.name }}\n\n{{ plugin.description }}\n\n**Agents:**\n\n{% for agent in all_agents %}\n{% if agent.plugin == plugin.name %}\n- **{{ agent.name }}** (`{{ agent.model }}`)\n  - {{ agent.description }}\n  - File: `plugins/{{ plugin.name }}/agents/{{ agent.file }}`\n{% endif %}\n{% endfor %}\n\n{% endfor %}\n{% endfor %}\n\n---\n*Last updated: {{ now }}*\n*Total agents: {{ stats.total_agents }}*\n```\n\n### agent-skills.md.j2\n\n```jinja2\n# Agent Skills Reference\n\nThis document catalogs all skills with progressive disclosure patterns.\n\n{% for plugin in marketplace.plugins %}\n## {{ plugin.name }}\n\n{{ plugin.description }}\n\n**Skills:**\n\n{% for skill in all_skills %}\n{% if skill.plugin == plugin.name %}\n### {{ skill.name }}\n\n{{ skill.description }}\n\n- **Location:** `plugins/{{ plugin.name }}/skills/{{ skill.path }}/`\n- **Structure:** SKILL.md + assets/ + references/\n\n{% endif %}\n{% endfor %}\n\n{% endfor %}\n\n---\n*Last updated: {{ now }}*\n*Total skills: {{ stats.total_skills }}*\n```\n\n## Error Handling\n\n### Marketplace Not Found\n\n```\nError: Marketplace file not found: .claude-plugin/marketplace.json\nSuggestion: Ensure marketplace.json exists\n```\n\n### Template Not Found\n\n```\nError: Template file not found: assets/agents.md.j2\nSuggestion: Ensure all template files exist in assets/\n```\n\n### Invalid Plugin Structure\n\n```\nWarning: Plugin 'plugin-name' missing components\nSuggestion: Verify plugin has agents or commands\n```\n\n### Frontmatter Parse Error\n\n```\nWarning: Could not parse frontmatter in agents/agent-name.md\nSuggestion: Check YAML frontmatter syntax\n```\n\n## Best Practices\n\n1. **Always Regenerate After Changes**\n\n   - Run after every plugin add/update/remove\n   - Ensure docs stay synchronized\n   - Commit documentation with plugin changes\n\n2. **Validate Before Generation**\n\n   - Run marketplace validation first\n   - Fix any errors or warnings\n   - Ensure all files exist\n\n3. **Review Generated Output**\n\n   - Check generated files for correctness\n   - Verify formatting and links\n   - Test any code examples\n\n4. **Template Maintenance**\n\n   - Keep templates simple and readable\n   - Use consistent formatting\n   - Document template variables\n\n5. **Version Control**\n   - Commit documentation changes\n   - Include in pull requests\n   - Document significant changes\n\n## Template Customization\n\n### Adding New Sections\n\nTo add a new section to a template:\n\n1. **Modify Template**\n\n   ```jinja2\n   ## New Section\n\n   {% for plugin in marketplace.plugins %}\n   ### {{ plugin.name }}\n   [Your content here]\n   {% endfor %}\n   ```\n\n2. **Update Context (if needed)**\n\n   - Add new data to template context in doc_generator.py\n   - Process additional metadata\n\n3. **Test Output**\n   - Run generator with dry-run\n   - Verify formatting\n   - Check for errors\n\n### Creating New Templates\n\nTo add a new documentation file:\n\n1. **Create Template**\n\n   - Add `assets/newdoc.md.j2`\n   - Define structure and content\n\n2. **Update Script**\n\n   - Add to doc_generator.py template list\n   - Define output path\n\n3. **Test Generation**\n   - Run generator\n   - Verify output\n   - Commit template and output\n\n## File Structure\n\n```\nplugins/claude-plugin/skills/documentation-update/\n├── SKILL.md                      # This file\n├── doc_generator.py              # Python implementation\n├── assets/                       # Jinja2 templates\n│   ├── agents.md.j2\n│   ├── agent-skills.md.j2\n│   ├── plugins.md.j2\n│   └── usage.md.j2\n└── references/                   # Optional examples\n    └── template-examples.md\n```\n\n## Requirements\n\n- Python 3.8+\n- No external dependencies (uses standard library only)\n- Access to `.claude-plugin/marketplace.json`\n- Read access to plugin directories\n- Write access to `docs/` directory\n\n## Success Criteria\n\nAfter running this skill:\n\n- ✓ All documentation files generated\n- ✓ Content matches marketplace state\n- ✓ All links are valid\n- ✓ Formatting is consistent\n- ✓ Statistics are accurate\n- ✓ No template rendering errors\n\n## Maintenance\n\n### Updating Templates\n\nWhen marketplace structure changes:\n\n1. **Assess Impact**\n\n   - Identify affected templates\n   - Determine required changes\n\n2. **Update Templates**\n\n   - Modify Jinja2 templates\n   - Test with current data\n\n3. **Update Script**\n\n   - Adjust context preparation if needed\n   - Add new data processing\n\n4. **Validate Output**\n   - Regenerate all docs\n   - Review changes\n   - Test links and formatting\n\n### Version Compatibility\n\n- Templates should handle missing fields gracefully\n- Use Jinja2 default filters for optional data\n- Validate marketplace version compatibility\n\n## Example Output\n\nThe skill generates comprehensive, well-formatted documentation:\n\n- **agents.md**: ~500-1000 lines for 20-30 agents\n- **agent-skills.md**: ~300-600 lines for 30-50 skills\n- **plugins.md**: ~400-800 lines for 10-20 plugins\n- **usage.md**: ~200-400 lines of usage information\n\nAll files include:\n\n- Clear structure and headings\n- Formatted tables where appropriate\n- Links to source files\n- Statistics and metadata\n- Last updated timestamp"
              },
              {
                "name": "marketplace-update",
                "description": "Updates the .claude-plugin/marketplace.json file when plugins are added, modified, or removed. Use when creating or updating plugin entries in the marketplace catalog.",
                "path": "plugins/claude-plugin/skills/marketplace-update/SKILL.md",
                "frontmatter": {
                  "name": "marketplace-update",
                  "description": "Updates the .claude-plugin/marketplace.json file when plugins are added, modified, or removed. Use when creating or updating plugin entries in the marketplace catalog."
                },
                "content": "# Marketplace Update Skill\n\nThis skill provides functionality to update the `.claude-plugin/marketplace.json` file when plugins are added, modified, or removed from the marketplace.\n\n## Purpose\n\nMaintain the marketplace catalog by:\n\n- Adding new plugin entries\n- Updating existing plugin metadata\n- Removing obsolete plugins\n- Validating marketplace structure\n- Ensuring consistency across the catalog\n\n## When to Use\n\nUse this skill when:\n\n- A new plugin is created and needs to be registered\n- An existing plugin's components change (agents, commands, skills added/removed)\n- Plugin metadata needs updating (version, description, keywords, etc.)\n- A plugin is being removed from the marketplace\n- Validating marketplace.json structure\n\n## Marketplace Structure\n\nThe marketplace.json file follows this schema:\n\n```json\n{\n  \"name\": \"marketplace-name\",\n  \"owner\": {\n    \"name\": \"Owner Name\",\n    \"email\": \"email@example.com\",\n    \"url\": \"https://github.com/username\"\n  },\n  \"metadata\": {\n    \"description\": \"Marketplace description\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"plugin-name\",\n      \"source\": \"./plugins/plugin-name\",\n      \"description\": \"Plugin description\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"Author Name\",\n        \"url\": \"https://github.com/username\"\n      },\n      \"homepage\": \"https://github.com/username/repo\",\n      \"repository\": \"https://github.com/username/repo\",\n      \"license\": \"MIT\",\n      \"keywords\": [\"keyword1\", \"keyword2\"],\n      \"category\": \"category-name\",\n      \"strict\": false,\n      \"commands\": [\"./commands/command-name.md\"],\n      \"agents\": [\"./agents/agent-name.md\"],\n      \"skills\": [\"./skills/skill-name\"]\n    }\n  ]\n}\n```\n\n## Operations\n\n### Add Plugin\n\nAdd a new plugin entry to the marketplace:\n\n```python\n# Use the provided Python script\npython marketplace_update.py add \\\n  --name \"plugin-name\" \\\n  --description \"Plugin description\" \\\n  --version \"1.0.0\" \\\n  --category \"category-name\" \\\n  --agents \"agent1.md,agent2.md\" \\\n  --commands \"command1.md,command2.md\" \\\n  --skills \"skill1,skill2\"\n```\n\n**Required Fields:**\n\n- `name` - Plugin name (hyphen-case)\n- `description` - Brief plugin description\n- `version` - Semantic version (e.g., \"1.0.0\")\n\n**Optional Fields:**\n\n- `category` - Plugin category (default: \"general\")\n- `agents` - Comma-separated list of agent files\n- `commands` - Comma-separated list of command files\n- `skills` - Comma-separated list of skill directories\n- `keywords` - Comma-separated list of keywords\n- `license` - License type (default: \"MIT\")\n- `strict` - Strict mode flag (default: false)\n\n### Update Plugin\n\nUpdate an existing plugin entry:\n\n```python\npython marketplace_update.py update \\\n  --name \"plugin-name\" \\\n  --description \"Updated description\" \\\n  --version \"1.1.0\" \\\n  --add-agent \"new-agent.md\" \\\n  --remove-command \"old-command.md\"\n```\n\n**Update Operations:**\n\n- `--description` - Update description\n- `--version` - Update version\n- `--category` - Update category\n- `--keywords` - Update keywords (replaces all)\n- `--add-agent` - Add agent file\n- `--remove-agent` - Remove agent file\n- `--add-command` - Add command file\n- `--remove-command` - Remove command file\n- `--add-skill` - Add skill directory\n- `--remove-skill` - Remove skill directory\n\n### Remove Plugin\n\nRemove a plugin from the marketplace:\n\n```python\npython marketplace_update.py remove --name \"plugin-name\"\n```\n\n### Validate Marketplace\n\nValidate the marketplace.json structure:\n\n```python\npython marketplace_update.py validate\n```\n\nThis checks:\n\n- JSON syntax validity\n- Required fields presence\n- File path existence\n- Component reference validity\n- Duplicate plugin names\n\n## Python Script\n\nThe skill includes a Python script at `marketplace_update.py` that provides command-line interface for all operations.\n\n### Usage from Claude Code\n\nWhen invoked as a skill:\n\n1. **Read Plugin Structure**\n\n   - Scan plugin directory for components\n   - Extract metadata from frontmatter\n   - Build component lists\n\n2. **Execute Python Script**\n\n   - Call marketplace_update.py with appropriate arguments\n   - Pass plugin details\n   - Handle success/error responses\n\n3. **Validate Result**\n   - Verify marketplace.json is valid\n   - Confirm plugin entry is correct\n   - Report success or errors\n\n## Examples\n\n### Example 1: Add New Plugin\n\n```python\n# Plugin: golang-development\n# Components: 3 agents, 1 command, 4 skills\n\npython marketplace_update.py add \\\n  --name \"golang-development\" \\\n  --description \"Go language development tools\" \\\n  --version \"1.0.0\" \\\n  --category \"languages\" \\\n  --keywords \"golang,go,development\" \\\n  --agents \"golang-pro.md,gin-pro.md,charm-pro.md\" \\\n  --commands \"golang-scaffold.md\" \\\n  --skills \"async-golang-patterns,golang-testing-patterns,golang-packaging,golang-performance-optimization\"\n```\n\n### Example 2: Update Plugin Version\n\n```python\n# Update version and add new agent\n\npython marketplace_update.py update \\\n  --name \"golang-development\" \\\n  --version \"1.1.0\" \\\n  --add-agent \"gorm-pro.md\"\n```\n\n### Example 3: Remove Plugin\n\n```python\npython marketplace_update.py remove --name \"obsolete-plugin\"\n```\n\n## Integration with Commands\n\nThe `/claude-plugin:create` and `/claude-plugin:update` commands should invoke this skill automatically:\n\n### From /claude-plugin:create Command\n\nAfter creating a new plugin:\n\n```\n1. Scan plugin directory for components\n2. Extract metadata from agent/command frontmatter\n3. Invoke marketplace-update skill:\n   - Operation: add\n   - Plugin name: [from user input]\n   - Components: [scanned from directory]\n   - Metadata: [extracted from frontmatter]\n```\n\n### From /claude-plugin:update Command\n\nAfter updating a plugin:\n\n```\n1. Determine what changed (added/removed/modified)\n2. Invoke marketplace-update skill:\n   - Operation: update\n   - Plugin name: [from user input]\n   - Changes: [specific updates]\n```\n\n## Error Handling\n\n### Plugin Already Exists (Add)\n\n```\nError: Plugin 'plugin-name' already exists in marketplace.\nSuggestion: Use 'update' operation instead.\n```\n\n### Plugin Not Found (Update/Remove)\n\n```\nError: Plugin 'plugin-name' not found in marketplace.\nSuggestion: Use 'add' operation to create it.\n```\n\n### Invalid JSON\n\n```\nError: marketplace.json contains invalid JSON.\nSuggestion: Fix JSON syntax before proceeding.\n```\n\n### Component File Missing\n\n```\nWarning: Component file './agents/agent-name.md' not found.\nSuggestion: Create the file or remove from plugin entry.\n```\n\n### Validation Failure\n\n```\nError: Marketplace validation failed:\n  - Plugin 'plugin-a' missing required field 'description'\n  - Plugin 'plugin-b' references non-existent agent 'missing.md'\nSuggestion: Fix errors and validate again.\n```\n\n## Best Practices\n\n1. **Always Validate After Changes**\n\n   - Run validate after add/update/remove\n   - Fix any warnings or errors\n   - Ensure all referenced files exist\n\n2. **Scan Plugin Directory**\n\n   - Don't manually list components\n   - Scan directory to detect agents/commands/skills\n   - Extract metadata from frontmatter\n\n3. **Semantic Versioning**\n\n   - Patch: Bug fixes, documentation updates (1.0.0 → 1.0.1)\n   - Minor: New components, enhancements (1.0.0 → 1.1.0)\n   - Major: Breaking changes, removals (1.0.0 → 2.0.0)\n\n4. **Consistent Metadata**\n\n   - Keep descriptions concise (< 100 chars)\n   - Use relevant keywords\n   - Maintain consistent author information\n   - Use appropriate categories\n\n5. **Backup Before Changes**\n   - Create backup of marketplace.json\n   - Test changes in development first\n   - Validate before committing\n\n## Categories\n\nCommon plugin categories:\n\n- `languages` - Language-specific tools (Python, Go, Rust, etc.)\n- `development` - General development tools\n- `security` - Security scanning and analysis\n- `testing` - Test generation and automation\n- `operations` - DevOps and operations tools\n- `infrastructure` - Cloud and infrastructure tools\n- `documentation` - Documentation generation\n- `architecture` - Architecture and design tools\n- `workflow` - Workflow orchestration\n- `general` - General purpose tools\n\n## File Structure\n\n```\nplugins/claude-plugin/skills/marketplace-update/\n├── SKILL.md                    # This file\n├── marketplace_update.py       # Python implementation\n└── references/                 # Optional examples\n    └── examples.md\n```\n\n## Requirements\n\n- Python 3.8+\n- No external dependencies (uses standard library only)\n- Access to `.claude-plugin/marketplace.json`\n- Read/write permissions on marketplace file\n\n## Success Criteria\n\nAfter running this skill:\n\n- ✓ marketplace.json is valid JSON\n- ✓ Plugin entry is correct and complete\n- ✓ All referenced files exist\n- ✓ No duplicate plugin names\n- ✓ Required fields are present\n- ✓ Validation passes without errors"
              }
            ]
          },
          {
            "name": "golang-development",
            "description": "Experienced Go development patterns and tools",
            "source": "./plugins/golang-development",
            "category": "languages",
            "version": "1.0.0",
            "author": {
              "name": "Geoff Johnson",
              "url": "https://github.com/geoffjay"
            },
            "install_commands": [
              "/plugin marketplace add geoffjay/claude-plugins",
              "/plugin install golang-development@geoffjay-claude-plugins"
            ],
            "signals": {
              "stars": 4,
              "forks": 1,
              "pushed_at": "2025-11-04T20:23:37Z",
              "created_at": "2025-10-17T18:24:21Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/review",
                "description": "Review Go code for idiomatic patterns, performance issues, security vulnerabilities, and common pitfalls with actionable suggestions",
                "path": "plugins/golang-development/commands/review.md",
                "frontmatter": {
                  "name": "golang-development:review",
                  "description": "Review Go code for idiomatic patterns, performance issues, security vulnerabilities, and common pitfalls with actionable suggestions"
                },
                "content": "# Golang Development Review Command\n\nComprehensive Go code review focusing on idiomatic patterns, performance, security, and best practices.\n\n## Usage\n\n```bash\n/golang-development:review [file-path-or-directory] [focus-area]\n```\n\n## Arguments\n\n- `$1` - File path or directory to review (optional, defaults to current directory)\n- `$2` - Focus area: `all`, `idioms`, `performance`, `security`, `concurrency`, `errors` (optional, defaults to `all`)\n\n## Examples\n\n```bash\n# Review all files in current directory\n/golang-development:review\n\n# Review specific file\n/golang-development:review internal/service/user.go\n\n# Focus on performance issues\n/golang-development:review . performance\n\n# Focus on security\n/golang-development:review ./handlers security\n\n# Review concurrency patterns\n/golang-development:review . concurrency\n```\n\n## Review Categories\n\n### 1. Idiomatic Go (`idioms`)\n\n**Checks:**\n- Naming conventions (camelCase, capitalization)\n- Error handling patterns\n- Interface usage and design\n- Struct composition over inheritance\n- Receiver naming and types\n- Exported vs. unexported identifiers\n- Go proverbs adherence\n\n**Example Issues:**\n```go\n// ❌ BAD: Non-idiomatic error handling\nfunc getUser(id string) (*User, string) {\n    if id == \"\" {\n        return nil, \"invalid ID\"\n    }\n    // ...\n}\n\n// ✅ GOOD: Idiomatic error handling\nfunc GetUser(id string) (*User, error) {\n    if id == \"\" {\n        return nil, fmt.Errorf(\"invalid ID: %s\", id)\n    }\n    // ...\n}\n\n// ❌ BAD: Getter naming\nfunc (u *User) GetName() string {\n    return u.name\n}\n\n// ✅ GOOD: Idiomatic getter\nfunc (u *User) Name() string {\n    return u.name\n}\n\n// ❌ BAD: Setter without validation\nfunc (u *User) SetAge(age int) {\n    u.age = age\n}\n\n// ✅ GOOD: Validated setter with error\nfunc (u *User) SetAge(age int) error {\n    if age < 0 || age > 150 {\n        return fmt.Errorf(\"invalid age: %d\", age)\n    }\n    u.age = age\n    return nil\n}\n```\n\n### 2. Performance (`performance`)\n\n**Checks:**\n- Unnecessary allocations\n- String concatenation in loops\n- Slice pre-allocation\n- Map pre-allocation\n- Defer in loops\n- Inefficient algorithms\n- Memory leaks\n- Goroutine leaks\n\n**Example Issues:**\n```go\n// ❌ BAD: String concatenation in loop\nfunc concat(strs []string) string {\n    result := \"\"\n    for _, s := range strs {\n        result += s  // Allocates new string each time\n    }\n    return result\n}\n\n// ✅ GOOD: Use strings.Builder\nfunc concat(strs []string) string {\n    var sb strings.Builder\n    for _, s := range strs {\n        sb.WriteString(s)\n    }\n    return sb.String()\n}\n\n// ❌ BAD: Growing slice\nfunc process(n int) []int {\n    var result []int\n    for i := 0; i < n; i++ {\n        result = append(result, i)\n    }\n    return result\n}\n\n// ✅ GOOD: Pre-allocate\nfunc process(n int) []int {\n    result := make([]int, 0, n)\n    for i := 0; i < n; i++ {\n        result = append(result, i)\n    }\n    return result\n}\n\n// ❌ BAD: Defer in tight loop\nfor i := 0; i < 10000; i++ {\n    mu.Lock()\n    defer mu.Unlock()  // Defers accumulate\n    // ...\n}\n\n// ✅ GOOD: Explicit unlock\nfor i := 0; i < 10000; i++ {\n    mu.Lock()\n    // ...\n    mu.Unlock()\n}\n```\n\n### 3. Security (`security`)\n\n**Checks:**\n- SQL injection vulnerabilities\n- Command injection\n- Path traversal\n- Hardcoded credentials\n- Weak cryptography\n- Unsafe operations\n- Input validation\n- XSS vulnerabilities\n\n**Example Issues:**\n```go\n// ❌ BAD: SQL injection\nfunc getUser(db *sql.DB, username string) (*User, error) {\n    query := fmt.Sprintf(\"SELECT * FROM users WHERE username = '%s'\", username)\n    return db.Query(query)\n}\n\n// ✅ GOOD: Parameterized query\nfunc getUser(db *sql.DB, username string) (*User, error) {\n    query := \"SELECT * FROM users WHERE username = $1\"\n    return db.Query(query, username)\n}\n\n// ❌ BAD: Hardcoded credentials\nconst apiKey = \"sk_live_1234567890\"\n\n// ✅ GOOD: Environment variables\napiKey := os.Getenv(\"API_KEY\")\n\n// ❌ BAD: Weak random\nfunc generateToken() string {\n    return fmt.Sprintf(\"%d\", rand.Int())\n}\n\n// ✅ GOOD: Cryptographically secure random\nfunc generateToken() (string, error) {\n    b := make([]byte, 32)\n    if _, err := rand.Read(b); err != nil {\n        return \"\", err\n    }\n    return base64.URLEncoding.EncodeToString(b), nil\n}\n```\n\n### 4. Concurrency (`concurrency`)\n\n**Checks:**\n- Race conditions\n- Deadlock potential\n- Missing mutex protection\n- Channel misuse\n- Context propagation\n- Goroutine leaks\n- Improper synchronization\n- Lock contention\n\n**Example Issues:**\n```go\n// ❌ BAD: Race condition\ntype Counter struct {\n    count int\n}\n\nfunc (c *Counter) Increment() {\n    c.count++  // Not thread-safe\n}\n\n// ✅ GOOD: Protected with mutex\ntype Counter struct {\n    mu    sync.Mutex\n    count int\n}\n\nfunc (c *Counter) Increment() {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    c.count++\n}\n\n// ❌ BAD: Goroutine leak\nfunc fetchData(url string) <-chan Result {\n    ch := make(chan Result)\n    go func() {\n        // If this fails, goroutine leaks\n        data := fetch(url)\n        ch <- data\n    }()\n    return ch\n}\n\n// ✅ GOOD: Context for cancellation\nfunc fetchData(ctx context.Context, url string) <-chan Result {\n    ch := make(chan Result)\n    go func() {\n        defer close(ch)\n        select {\n        case <-ctx.Done():\n            return\n        default:\n            data := fetch(url)\n            select {\n            case ch <- data:\n            case <-ctx.Done():\n            }\n        }\n    }()\n    return ch\n}\n```\n\n### 5. Error Handling (`errors`)\n\n**Checks:**\n- Ignored errors\n- Error wrapping\n- Sentinel errors\n- Custom error types\n- Error messages\n- Panic usage\n- Recover usage\n\n**Example Issues:**\n```go\n// ❌ BAD: Ignored error\nfile, _ := os.Open(\"file.txt\")\n\n// ✅ GOOD: Handle error\nfile, err := os.Open(\"file.txt\")\nif err != nil {\n    return fmt.Errorf(\"open file: %w\", err)\n}\n\n// ❌ BAD: Lost error context\nfunc process() error {\n    if err := doSomething(); err != nil {\n        return err\n    }\n    return nil\n}\n\n// ✅ GOOD: Wrapped error\nfunc process() error {\n    if err := doSomething(); err != nil {\n        return fmt.Errorf(\"process failed: %w\", err)\n    }\n    return nil\n}\n\n// ❌ BAD: Panic for normal errors\nfunc getConfig() *Config {\n    cfg, err := loadConfig()\n    if err != nil {\n        panic(err)  // Don't panic\n    }\n    return cfg\n}\n\n// ✅ GOOD: Return error\nfunc getConfig() (*Config, error) {\n    cfg, err := loadConfig()\n    if err != nil {\n        return nil, fmt.Errorf(\"load config: %w\", err)\n    }\n    return cfg, nil\n}\n```\n\n## Review Output Format\n\n```\n📝 Code Review Results\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n📂 File: internal/service/user.go\n\n⚠️  HIGH: SQL Injection Vulnerability (line 45)\n   ├─ Issue: Unsanitized user input in SQL query\n   ├─ Risk: Database compromise\n   └─ Fix: Use parameterized queries\n\n💡 MEDIUM: Non-Idiomatic Error Handling (line 67)\n   ├─ Issue: Returning string error instead of error type\n   ├─ Impact: Type safety, error wrapping\n   └─ Suggestion: Return error type\n\n⚡ LOW: Performance - Missing Pre-allocation (line 89)\n   ├─ Issue: Slice growing without capacity hint\n   ├─ Impact: Multiple allocations\n   └─ Optimization: make([]Type, 0, expectedSize)\n\n✅ GOOD: Proper context propagation (line 23)\n✅ GOOD: Thread-safe cache implementation (line 112)\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nSummary:\n  High: 1 | Medium: 1 | Low: 1 | Good: 2\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n```\n\n## Automated Checks\n\nThe review includes automated checks using:\n- `go vet` - Official Go static analysis\n- `staticcheck` - Advanced static analysis\n- `gosec` - Security-focused linter\n- `golangci-lint` - Comprehensive linter suite\n- Custom pattern matching for Go-specific issues\n\n## Manual Review Areas\n\nFor complex code, the command performs manual review of:\n- Architecture and design patterns\n- API design and interfaces\n- Test coverage and quality\n- Documentation completeness\n- Code complexity and maintainability\n\n## Actionable Suggestions\n\nEach issue includes:\n1. **Location**: Exact file and line number\n2. **Severity**: HIGH, MEDIUM, LOW\n3. **Description**: What the issue is\n4. **Impact**: Why it matters\n5. **Fix**: How to resolve it\n6. **Example**: Code snippet showing the fix\n\n## Integration with Tools\n\nThe command can integrate with:\n- GitHub PR comments\n- GitLab merge request notes\n- Bitbucket PR feedback\n- Slack notifications\n- Email reports\n\n## Configuration\n\nCreate `.go-review.yml` in project root:\n\n```yaml\nignore:\n  - vendor/\n  - mocks/\n  - \".*_test.go\"\n\nseverity:\n  min_level: MEDIUM\n\nfocus:\n  - security\n  - performance\n  - concurrency\n\ncustom_rules:\n  - pattern: \"fmt.Print\"\n    message: \"Use structured logging\"\n    severity: LOW\n```\n\n## When to Use\n\nUse this command:\n- Before creating pull requests\n- During code reviews\n- After major refactoring\n- When onboarding new team members\n- As part of CI/CD pipeline\n- When learning Go best practices\n- Before production deployment\n\n## Best Practices\n\nThe review checks compliance with:\n- Effective Go guidelines\n- Go Code Review Comments\n- Go proverbs\n- Industry best practices\n- Security standards (OWASP)\n- Performance optimization patterns"
              },
              {
                "name": "/scaffold",
                "description": "Scaffold new Go projects with modern structure, Go modules, testing setup, CI/CD pipelines, and best practices",
                "path": "plugins/golang-development/commands/scaffold.md",
                "frontmatter": {
                  "name": "golang-development:scaffold",
                  "description": "Scaffold new Go projects with modern structure, Go modules, testing setup, CI/CD pipelines, and best practices"
                },
                "content": "# Golang Development Scaffold Command\n\nCreate a new Go project with a production-ready structure, modern tooling, and best practices built-in.\n\n## Usage\n\n```bash\n/golang-development:scaffold <project-name> [options]\n```\n\n## Arguments\n\n- `$1` - Project name (required, will be used for module name)\n- `$2` - Project type: `service`, `cli`, `library`, or `microservice` (optional, defaults to `service`)\n- `$3` - Additional options as JSON (optional)\n\n## Examples\n\n```bash\n# Create a basic HTTP service\n/golang-development:scaffold my-api service\n\n# Create a CLI application\n/golang-development:scaffold my-tool cli\n\n# Create a library\n/golang-development:scaffold my-lib library\n\n# Create a microservice with full features\n/golang-development:scaffold user-service microservice '{\"with_grpc\": true, \"with_db\": true}'\n```\n\n## Project Structures\n\n### Service (HTTP API)\n```\nmy-api/\n├── cmd/\n│   └── server/\n│       └── main.go\n├── internal/\n│   ├── handler/\n│   │   └── health.go\n│   ├── middleware/\n│   │   └── logging.go\n│   └── service/\n│       └── user.go\n├── pkg/\n│   └── response/\n│       └── response.go\n├── api/\n│   └── openapi.yaml\n├── scripts/\n│   └── build.sh\n├── deployments/\n│   ├── Dockerfile\n│   └── k8s/\n├── go.mod\n├── go.sum\n├── .gitignore\n├── .golangci.yml\n├── Makefile\n└── README.md\n```\n\n### CLI Application\n```\nmy-tool/\n├── cmd/\n│   └── my-tool/\n│       └── main.go\n├── internal/\n│   ├── command/\n│   │   ├── root.go\n│   │   └── serve.go\n│   └── config/\n│       └── config.go\n├── go.mod\n├── go.sum\n├── .gitignore\n├── .golangci.yml\n├── Makefile\n└── README.md\n```\n\n### Library\n```\nmy-lib/\n├── example_test.go\n├── lib.go\n├── lib_test.go\n├── go.mod\n├── go.sum\n├── .gitignore\n├── .golangci.yml\n├── LICENSE\n└── README.md\n```\n\n### Microservice (Full Features)\n```\nuser-service/\n├── cmd/\n│   └── server/\n│       └── main.go\n├── internal/\n│   ├── domain/\n│   │   └── user.go\n│   ├── handler/\n│   │   ├── http/\n│   │   └── grpc/\n│   ├── repository/\n│   │   └── postgres/\n│   ├── service/\n│   │   └── user_service.go\n│   └── infrastructure/\n│       ├── database/\n│       ├── cache/\n│       └── messaging/\n├── api/\n│   ├── http/\n│   │   └── openapi.yaml\n│   └── grpc/\n│       └── user.proto\n├── pkg/\n│   ├── logger/\n│   ├── metrics/\n│   └── tracing/\n├── migrations/\n│   └── 001_create_users.sql\n├── deployments/\n│   ├── Dockerfile\n│   ├── docker-compose.yml\n│   └── k8s/\n├── scripts/\n├── go.mod\n├── go.sum\n├── .gitignore\n├── .golangci.yml\n├── Makefile\n└── README.md\n```\n\n## Generated Files\n\n### main.go (Service)\n```go\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"os\"\n    \"os/signal\"\n    \"syscall\"\n    \"time\"\n\n    \"{{.ModuleName}}/internal/handler\"\n    \"{{.ModuleName}}/internal/middleware\"\n)\n\nfunc main() {\n    // Setup router\n    mux := http.NewServeMux()\n\n    // Middleware\n    handler := middleware.Logging(\n        middleware.Recovery(mux),\n    )\n\n    // Routes\n    mux.HandleFunc(\"/health\", handler.Health)\n    mux.HandleFunc(\"/ready\", handler.Ready)\n\n    // Server configuration\n    port := os.Getenv(\"PORT\")\n    if port == \"\" {\n        port = \"8080\"\n    }\n\n    server := &http.Server{\n        Addr:         fmt.Sprintf(\":%s\", port),\n        Handler:      handler,\n        ReadTimeout:  15 * time.Second,\n        WriteTimeout: 15 * time.Second,\n        IdleTimeout:  60 * time.Second,\n    }\n\n    // Start server\n    go func() {\n        log.Printf(\"Server starting on port %s\", port)\n        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n            log.Fatalf(\"Server error: %v\", err)\n        }\n    }()\n\n    // Graceful shutdown\n    quit := make(chan os.Signal, 1)\n    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n    <-quit\n\n    log.Println(\"Shutting down server...\")\n    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\n    defer cancel()\n\n    if err := server.Shutdown(ctx); err != nil {\n        log.Fatalf(\"Server forced to shutdown: %v\", err)\n    }\n\n    log.Println(\"Server exited\")\n}\n```\n\n### Makefile\n```makefile\n.PHONY: build test lint run clean\n\n# Variables\nAPP_NAME := {{.ProjectName}}\nVERSION := $(shell git describe --tags --always --dirty)\nBUILD_TIME := $(shell date -u '+%Y-%m-%d_%H:%M:%S')\nLDFLAGS := -ldflags \"-X main.Version=$(VERSION) -X main.BuildTime=$(BUILD_TIME)\"\n\n# Build\nbuild:\n\tgo build $(LDFLAGS) -o bin/$(APP_NAME) ./cmd/server\n\n# Test\ntest:\n\tgo test -v -race -coverprofile=coverage.out ./...\n\n# Coverage\ncoverage:\n\tgo tool cover -html=coverage.out\n\n# Lint\nlint:\n\tgolangci-lint run\n\n# Run\nrun:\n\tgo run ./cmd/server\n\n# Clean\nclean:\n\trm -rf bin/\n\trm -f coverage.out\n\n# Install tools\ntools:\n\tgo install github.com/golangci/golangci-lint/cmd/golangci-lint@latest\n\n# Docker\ndocker-build:\n\tdocker build -t $(APP_NAME):$(VERSION) .\n\ndocker-run:\n\tdocker run -p 8080:8080 $(APP_NAME):$(VERSION)\n```\n\n### Dockerfile\n```dockerfile\n# Build stage\nFROM golang:1.21-alpine AS builder\n\nWORKDIR /app\n\n# Copy go mod files\nCOPY go.mod go.sum ./\nRUN go mod download\n\n# Copy source code\nCOPY . .\n\n# Build\nRUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main ./cmd/server\n\n# Runtime stage\nFROM alpine:latest\n\nRUN apk --no-cache add ca-certificates\n\nWORKDIR /root/\n\n# Copy binary from builder\nCOPY --from=builder /app/main .\n\nEXPOSE 8080\n\nCMD [\"./main\"]\n```\n\n### .golangci.yml\n```yaml\nlinters:\n  enable:\n    - errcheck\n    - gosimple\n    - govet\n    - ineffassign\n    - staticcheck\n    - unused\n    - gofmt\n    - goimports\n    - misspell\n    - gocritic\n    - gosec\n    - revive\n\nlinters-settings:\n  errcheck:\n    check-blank: true\n  govet:\n    check-shadowing: true\n  gofmt:\n    simplify: true\n\nissues:\n  exclude-use-default: false\n  max-issues-per-linter: 0\n  max-same-issues: 0\n```\n\n### GitHub Actions CI (.github/workflows/ci.yml)\n```yaml\nname: CI\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Set up Go\n      uses: actions/setup-go@v4\n      with:\n        go-version: '1.21'\n\n    - name: Install dependencies\n      run: go mod download\n\n    - name: Run tests\n      run: go test -v -race -coverprofile=coverage.out ./...\n\n    - name: Upload coverage\n      uses: codecov/codecov-action@v3\n      with:\n        files: ./coverage.out\n\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Set up Go\n      uses: actions/setup-go@v4\n      with:\n        go-version: '1.21'\n\n    - name: golangci-lint\n      uses: golangci/golangci-lint-action@v3\n      with:\n        version: latest\n\n  build:\n    runs-on: ubuntu-latest\n    needs: [test, lint]\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Set up Go\n      uses: actions/setup-go@v4\n      with:\n        go-version: '1.21'\n\n    - name: Build\n      run: go build -v ./cmd/server\n```\n\n## Configuration Options\n\nThe command accepts a JSON configuration object:\n\n```json\n{\n  \"with_grpc\": true,\n  \"with_db\": true,\n  \"with_redis\": true,\n  \"with_kafka\": true,\n  \"with_docker\": true,\n  \"with_k8s\": true,\n  \"with_ci\": true,\n  \"db_driver\": \"postgres\",\n  \"module_path\": \"github.com/user/project\"\n}\n```\n\n## Implementation Steps\n\n1. Parse arguments and configuration\n2. Create project directory structure\n3. Initialize Go module\n4. Generate main.go and core files\n5. Create Makefile and build scripts\n6. Add Dockerfile and Docker Compose\n7. Generate CI/CD configuration\n8. Create README with usage instructions\n9. Initialize git repository\n10. Run `go mod tidy`\n\n## Features Included\n\n- **Modern Project Structure**: Clean architecture with separation of concerns\n- **HTTP Server**: Production-ready with graceful shutdown\n- **Middleware**: Logging, recovery, CORS, authentication templates\n- **Health Checks**: Health and readiness endpoints\n- **Testing**: Test structure and examples\n- **Linting**: golangci-lint configuration\n- **CI/CD**: GitHub Actions workflow\n- **Docker**: Multi-stage Dockerfile\n- **Kubernetes**: Basic manifests (if requested)\n- **Documentation**: Comprehensive README\n\n## Post-Scaffold Steps\n\nAfter scaffolding, the command will suggest:\n\n```bash\ncd {{.ProjectName}}\ngo mod tidy\nmake test\nmake run\n```\n\n## When to Use\n\nUse this command to:\n- Start new Go projects quickly\n- Ensure consistent project structure\n- Set up best practices from the start\n- Include modern tooling and CI/CD\n- Scaffold microservices or APIs\n- Create CLI tools with proper structure"
              },
              {
                "name": "/test",
                "description": "Generate comprehensive tests including unit tests, table-driven tests, benchmarks, and examples with high coverage",
                "path": "plugins/golang-development/commands/test.md",
                "frontmatter": {
                  "name": "golang-development:test",
                  "description": "Generate comprehensive tests including unit tests, table-driven tests, benchmarks, and examples with high coverage"
                },
                "content": "# Golang Development Test Command\n\nGenerate comprehensive, production-ready tests for Go code including unit tests, table-driven tests, benchmarks, and examples.\n\n## Usage\n\n```bash\n/golang-development:test <file-or-function> [test-type] [options]\n```\n\n## Arguments\n\n- `$1` - File path or function name to test (required)\n- `$2` - Test type: `unit`, `table`, `benchmark`, `integration`, `all` (optional, defaults to `unit`)\n- `$3` - Options as JSON (optional)\n\n## Examples\n\n```bash\n# Generate unit tests for a file\n/golang-development:test internal/service/user.go\n\n# Generate table-driven tests\n/golang-development:test internal/service/user.go table\n\n# Generate benchmarks\n/golang-development:test internal/service/user.go benchmark\n\n# Generate all test types\n/golang-development:test internal/service/user.go all\n\n# Generate tests with options\n/golang-development:test internal/service/user.go unit '{\"with_mocks\": true, \"coverage_target\": 90}'\n```\n\n## Test Types\n\n### 1. Unit Tests\n\nBasic unit tests for individual functions:\n\n```go\n// Source: user.go\npackage service\n\ntype User struct {\n    ID    string\n    Email string\n    Age   int\n}\n\nfunc (u *User) IsAdult() bool {\n    return u.Age >= 18\n}\n\nfunc ValidateEmail(email string) error {\n    if !strings.Contains(email, \"@\") {\n        return errors.New(\"invalid email format\")\n    }\n    return nil\n}\n\n// Generated: user_test.go\npackage service\n\nimport (\n    \"testing\"\n)\n\nfunc TestUser_IsAdult(t *testing.T) {\n    t.Run(\"adult user\", func(t *testing.T) {\n        user := &User{Age: 25}\n        if !user.IsAdult() {\n            t.Error(\"expected user to be adult\")\n        }\n    })\n\n    t.Run(\"minor user\", func(t *testing.T) {\n        user := &User{Age: 15}\n        if user.IsAdult() {\n            t.Error(\"expected user to be minor\")\n        }\n    })\n\n    t.Run(\"edge case - exactly 18\", func(t *testing.T) {\n        user := &User{Age: 18}\n        if !user.IsAdult() {\n            t.Error(\"18 year old should be adult\")\n        }\n    })\n}\n\nfunc TestValidateEmail(t *testing.T) {\n    tests := []struct {\n        name    string\n        email   string\n        wantErr bool\n    }{\n        {\n            name:    \"valid email\",\n            email:   \"user@example.com\",\n            wantErr: false,\n        },\n        {\n            name:    \"invalid email - no @\",\n            email:   \"userexample.com\",\n            wantErr: true,\n        },\n        {\n            name:    \"empty email\",\n            email:   \"\",\n            wantErr: true,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            err := ValidateEmail(tt.email)\n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"ValidateEmail() error = %v, wantErr %v\", err, tt.wantErr)\n            }\n        })\n    }\n}\n```\n\n### 2. Table-Driven Tests\n\nComprehensive table-driven tests:\n\n```go\n// Source: calculator.go\npackage calculator\n\nfunc Add(a, b int) int {\n    return a + b\n}\n\nfunc Divide(a, b float64) (float64, error) {\n    if b == 0 {\n        return 0, errors.New(\"division by zero\")\n    }\n    return a / b, nil\n}\n\n// Generated: calculator_test.go\npackage calculator\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n    tests := []struct {\n        name     string\n        a        int\n        b        int\n        expected int\n    }{\n        {\"positive numbers\", 2, 3, 5},\n        {\"negative numbers\", -2, -3, -5},\n        {\"mixed signs\", -2, 3, 1},\n        {\"zeros\", 0, 0, 0},\n        {\"large numbers\", 1000000, 2000000, 3000000},\n        {\"overflow scenario\", math.MaxInt - 1, 1, math.MaxInt},\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            result := Add(tt.a, tt.b)\n            if result != tt.expected {\n                t.Errorf(\"Add(%d, %d) = %d; want %d\",\n                    tt.a, tt.b, result, tt.expected)\n            }\n        })\n    }\n}\n\nfunc TestDivide(t *testing.T) {\n    tests := []struct {\n        name      string\n        a         float64\n        b         float64\n        expected  float64\n        expectErr bool\n    }{\n        {\"normal division\", 10.0, 2.0, 5.0, false},\n        {\"division by zero\", 10.0, 0.0, 0.0, true},\n        {\"negative numbers\", -10.0, 2.0, -5.0, false},\n        {\"fractional result\", 7.0, 2.0, 3.5, false},\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            result, err := Divide(tt.a, tt.b)\n\n            if tt.expectErr {\n                if err == nil {\n                    t.Error(\"expected error but got none\")\n                }\n                return\n            }\n\n            if err != nil {\n                t.Errorf(\"unexpected error: %v\", err)\n                return\n            }\n\n            if math.Abs(result-tt.expected) > 0.0001 {\n                t.Errorf(\"Divide(%f, %f) = %f; want %f\",\n                    tt.a, tt.b, result, tt.expected)\n            }\n        })\n    }\n}\n```\n\n### 3. Benchmarks\n\nPerformance benchmarks:\n\n```go\n// Generated: user_bench_test.go\npackage service\n\nimport (\n    \"testing\"\n)\n\nfunc BenchmarkUser_IsAdult(b *testing.B) {\n    user := &User{Age: 25}\n\n    b.ResetTimer()\n    for i := 0; i < b.N; i++ {\n        _ = user.IsAdult()\n    }\n}\n\nfunc BenchmarkValidateEmail(b *testing.B) {\n    email := \"test@example.com\"\n\n    b.ResetTimer()\n    for i := 0; i < b.N; i++ {\n        _ = ValidateEmail(email)\n    }\n}\n\nfunc BenchmarkValidateEmail_Invalid(b *testing.B) {\n    email := \"invalid-email\"\n\n    b.ResetTimer()\n    for i := 0; i < b.N; i++ {\n        _ = ValidateEmail(email)\n    }\n}\n\n// Memory allocation benchmarks\nfunc BenchmarkStringConcatenation(b *testing.B) {\n    strs := []string{\"hello\", \"world\", \"foo\", \"bar\"}\n\n    b.Run(\"operator\", func(b *testing.B) {\n        b.ReportAllocs()\n        for i := 0; i < b.N; i++ {\n            result := \"\"\n            for _, s := range strs {\n                result += s\n            }\n            _ = result\n        }\n    })\n\n    b.Run(\"strings.Builder\", func(b *testing.B) {\n        b.ReportAllocs()\n        for i := 0; i < b.N; i++ {\n            var sb strings.Builder\n            for _, s := range strs {\n                sb.WriteString(s)\n            }\n            _ = sb.String()\n        }\n    })\n}\n```\n\n### 4. Integration Tests\n\nIntegration tests with external dependencies:\n\n```go\n// Generated: user_integration_test.go\n// +build integration\n\npackage service\n\nimport (\n    \"context\"\n    \"database/sql\"\n    \"testing\"\n\n    _ \"github.com/lib/pq\"\n)\n\nfunc setupTestDB(t *testing.T) *sql.DB {\n    t.Helper()\n\n    db, err := sql.Open(\"postgres\", \"postgres://test:test@localhost/test?sslmode=disable\")\n    if err != nil {\n        t.Fatalf(\"failed to connect to database: %v\", err)\n    }\n\n    // Create schema\n    _, err = db.Exec(`CREATE TABLE IF NOT EXISTS users (\n        id SERIAL PRIMARY KEY,\n        email VARCHAR(255) UNIQUE NOT NULL,\n        age INTEGER NOT NULL\n    )`)\n    if err != nil {\n        t.Fatalf(\"failed to create schema: %v\", err)\n    }\n\n    t.Cleanup(func() {\n        db.Exec(\"DROP TABLE users\")\n        db.Close()\n    })\n\n    return db\n}\n\nfunc TestUserRepository_Create_Integration(t *testing.T) {\n    if testing.Short() {\n        t.Skip(\"skipping integration test in short mode\")\n    }\n\n    db := setupTestDB(t)\n    repo := NewUserRepository(db)\n\n    ctx := context.Background()\n    user := &User{\n        Email: \"test@example.com\",\n        Age:   25,\n    }\n\n    err := repo.Create(ctx, user)\n    if err != nil {\n        t.Fatalf(\"failed to create user: %v\", err)\n    }\n\n    if user.ID == \"\" {\n        t.Error(\"expected user ID to be set\")\n    }\n\n    // Verify user was created\n    retrieved, err := repo.GetByEmail(ctx, user.Email)\n    if err != nil {\n        t.Fatalf(\"failed to retrieve user: %v\", err)\n    }\n\n    if retrieved.Email != user.Email {\n        t.Errorf(\"email mismatch: got %s, want %s\", retrieved.Email, user.Email)\n    }\n}\n```\n\n### 5. Mock Generation\n\nGenerate mocks for interfaces:\n\n```go\n// Source: repository.go\npackage service\n\ntype UserRepository interface {\n    GetByID(ctx context.Context, id string) (*User, error)\n    Create(ctx context.Context, user *User) error\n    Update(ctx context.Context, user *User) error\n    Delete(ctx context.Context, id string) error\n}\n\n// Generated: mocks/user_repository_mock.go\npackage mocks\n\nimport (\n    \"context\"\n    \"sync\"\n\n    \"yourmodule/service\"\n)\n\ntype MockUserRepository struct {\n    mu sync.Mutex\n\n    GetByIDFunc func(ctx context.Context, id string) (*service.User, error)\n    GetByIDCalls []GetByIDCall\n\n    CreateFunc func(ctx context.Context, user *service.User) error\n    CreateCalls []CreateCall\n\n    UpdateFunc func(ctx context.Context, user *service.User) error\n    UpdateCalls []UpdateCall\n\n    DeleteFunc func(ctx context.Context, id string) error\n    DeleteCalls []DeleteCall\n}\n\ntype GetByIDCall struct {\n    Ctx context.Context\n    ID  string\n}\n\ntype CreateCall struct {\n    Ctx  context.Context\n    User *service.User\n}\n\n// ... more types ...\n\nfunc (m *MockUserRepository) GetByID(ctx context.Context, id string) (*service.User, error) {\n    m.mu.Lock()\n    m.GetByIDCalls = append(m.GetByIDCalls, GetByIDCall{Ctx: ctx, ID: id})\n    m.mu.Unlock()\n\n    if m.GetByIDFunc != nil {\n        return m.GetByIDFunc(ctx, id)\n    }\n\n    return nil, nil\n}\n\n// ... more methods ...\n\n// Usage in tests:\nfunc TestUserService_GetUser(t *testing.T) {\n    mockRepo := &mocks.MockUserRepository{\n        GetByIDFunc: func(ctx context.Context, id string) (*service.User, error) {\n            return &service.User{\n                ID:    id,\n                Email: \"test@example.com\",\n                Age:   25,\n            }, nil\n        },\n    }\n\n    svc := service.NewUserService(mockRepo)\n    user, err := svc.GetUser(context.Background(), \"123\")\n\n    if err != nil {\n        t.Fatalf(\"unexpected error: %v\", err)\n    }\n\n    if user.ID != \"123\" {\n        t.Errorf(\"expected user ID 123, got %s\", user.ID)\n    }\n\n    if len(mockRepo.GetByIDCalls) != 1 {\n        t.Errorf(\"expected 1 call to GetByID, got %d\", len(mockRepo.GetByIDCalls))\n    }\n}\n```\n\n## Test Helpers\n\nGenerate common test helpers:\n\n```go\n// Generated: testhelpers/helpers.go\npackage testhelpers\n\nimport (\n    \"testing\"\n    \"time\"\n)\n\n// AssertEqual checks if two values are equal\nfunc AssertEqual(t *testing.T, got, want interface{}) {\n    t.Helper()\n    if got != want {\n        t.Errorf(\"got %v, want %v\", got, want)\n    }\n}\n\n// AssertError checks if an error occurred\nfunc AssertError(t *testing.T, err error, wantErr bool) {\n    t.Helper()\n    if (err != nil) != wantErr {\n        t.Errorf(\"error = %v, wantErr %v\", err, wantErr)\n    }\n}\n\n// AssertNil checks if value is nil\nfunc AssertNil(t *testing.T, got interface{}) {\n    t.Helper()\n    if got != nil {\n        t.Errorf(\"expected nil, got %v\", got)\n    }\n}\n\n// AssertNotNil checks if value is not nil\nfunc AssertNotNil(t *testing.T, got interface{}) {\n    t.Helper()\n    if got == nil {\n        t.Error(\"expected non-nil value\")\n    }\n}\n\n// Eventually retries assertion until timeout\nfunc Eventually(t *testing.T, assertion func() bool, timeout time.Duration) {\n    t.Helper()\n    deadline := time.Now().Add(timeout)\n\n    for time.Now().Before(deadline) {\n        if assertion() {\n            return\n        }\n        time.Sleep(100 * time.Millisecond)\n    }\n\n    t.Error(\"assertion failed within timeout\")\n}\n```\n\n## Configuration Options\n\n```json\n{\n  \"with_mocks\": true,\n  \"with_benchmarks\": true,\n  \"with_examples\": true,\n  \"coverage_target\": 80,\n  \"use_testify\": false,\n  \"parallel_tests\": true,\n  \"generate_helpers\": true\n}\n```\n\n## Coverage Analysis\n\nThe command includes coverage analysis:\n\n```bash\n# Run tests with coverage\ngo test -coverprofile=coverage.out ./...\n\n# View coverage report\ngo tool cover -html=coverage.out\n\n# Check coverage threshold\ngo test -cover ./... | grep \"coverage:\"\n```\n\n## Best Practices\n\nGenerated tests follow:\n- Table-driven test patterns\n- Subtests for isolation\n- Test helpers for DRY code\n- Proper cleanup with t.Cleanup()\n- Context usage in tests\n- Parallel test execution\n- Comprehensive edge cases\n- Clear test names\n\n## When to Use\n\nUse this command to:\n- Generate tests for new code\n- Improve test coverage\n- Add missing test cases\n- Create benchmark tests\n- Generate integration tests\n- Mock external dependencies\n- Follow testing best practices"
              }
            ],
            "skills": [
              {
                "name": "go-concurrency",
                "description": "Advanced concurrency patterns with goroutines, channels, context, and synchronization primitives. Use when working with concurrent Go code, implementing parallel processing, or debugging race conditions.",
                "path": "plugins/golang-development/skills/go-concurrency/SKILL.md",
                "frontmatter": {
                  "name": "go-concurrency",
                  "description": "Advanced concurrency patterns with goroutines, channels, context, and synchronization primitives. Use when working with concurrent Go code, implementing parallel processing, or debugging race conditions."
                },
                "content": "# Go Concurrency Skill\n\nThis skill provides expert guidance on Go's concurrency primitives and patterns, covering goroutines, channels, synchronization, and best practices for building concurrent systems.\n\n## When to Use\n\nActivate this skill when:\n- Implementing concurrent/parallel processing\n- Working with goroutines and channels\n- Using synchronization primitives (mutexes, wait groups, etc.)\n- Debugging race conditions\n- Optimizing concurrent performance\n- Implementing worker pools or pipelines\n- Handling context cancellation\n\n## Goroutine Fundamentals\n\n### Basic Goroutines\n\n```go\n// Simple goroutine\ngo func() {\n    fmt.Println(\"Hello from goroutine\")\n}()\n\n// Goroutine with parameters\ngo func(msg string) {\n    fmt.Println(msg)\n}(\"Hello\")\n\n// Goroutine with closure\nmessage := \"Hello\"\ngo func() {\n    fmt.Println(message) // Captures message\n}()\n```\n\n### Common Pitfalls\n\n```go\n// ❌ BAD: Loop variable capture\nfor i := 0; i < 5; i++ {\n    go func() {\n        fmt.Println(i) // All goroutines may print 5\n    }()\n}\n\n// ✅ GOOD: Pass as parameter\nfor i := 0; i < 5; i++ {\n    go func(n int) {\n        fmt.Println(n) // Each prints correct value\n    }(i)\n}\n\n// ✅ GOOD: Create local copy\nfor i := 0; i < 5; i++ {\n    i := i // Create new variable\n    go func() {\n        fmt.Println(i)\n    }()\n}\n```\n\n## Channel Patterns\n\n### Channel Types\n\n```go\n// Unbuffered channel (synchronous)\nch := make(chan int)\n\n// Buffered channel (asynchronous up to buffer size)\nch := make(chan int, 10)\n\n// Send-only channel\nfunc send(ch chan<- int) {\n    ch <- 42\n}\n\n// Receive-only channel\nfunc receive(ch <-chan int) {\n    value := <-ch\n}\n\n// Bidirectional channel\nch := make(chan int)\n```\n\n### Channel Operations\n\n```go\n// Send\nch <- value\n\n// Receive\nvalue := <-ch\n\n// Receive with ok check\nvalue, ok := <-ch\nif !ok {\n    // Channel closed\n}\n\n// Close channel\nclose(ch)\n\n// Range over channel\nfor value := range ch {\n    fmt.Println(value)\n}\n```\n\n### Select Statement\n\n```go\n// Wait for first available operation\nselect {\ncase msg1 := <-ch1:\n    fmt.Println(\"Received from ch1:\", msg1)\ncase msg2 := <-ch2:\n    fmt.Println(\"Received from ch2:\", msg2)\ncase ch3 <- value:\n    fmt.Println(\"Sent to ch3\")\ndefault:\n    fmt.Println(\"No channels ready\")\n}\n\n// Timeout pattern\nselect {\ncase result := <-ch:\n    return result, nil\ncase <-time.After(5 * time.Second):\n    return nil, errors.New(\"timeout\")\n}\n\n// Context cancellation\nselect {\ncase result := <-ch:\n    return result, nil\ncase <-ctx.Done():\n    return nil, ctx.Err()\n}\n```\n\n## Synchronization Primitives\n\n### Mutex\n\n```go\ntype SafeCounter struct {\n    mu    sync.Mutex\n    count int\n}\n\nfunc (c *SafeCounter) Increment() {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    c.count++\n}\n\nfunc (c *SafeCounter) Value() int {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    return c.count\n}\n```\n\n### RWMutex\n\n```go\ntype Cache struct {\n    mu    sync.RWMutex\n    items map[string]interface{}\n}\n\nfunc (c *Cache) Get(key string) (interface{}, bool) {\n    c.mu.RLock() // Multiple readers allowed\n    defer c.mu.RUnlock()\n    value, ok := c.items[key]\n    return value, ok\n}\n\nfunc (c *Cache) Set(key string, value interface{}) {\n    c.mu.Lock() // Exclusive write access\n    defer c.mu.Unlock()\n    c.items[key] = value\n}\n```\n\n### WaitGroup\n\n```go\nfunc processItems(items []Item) {\n    var wg sync.WaitGroup\n\n    for _, item := range items {\n        wg.Add(1)\n        go func(item Item) {\n            defer wg.Done()\n            process(item)\n        }(item)\n    }\n\n    wg.Wait() // Wait for all goroutines\n}\n```\n\n### Once\n\n```go\ntype Database struct {\n    instance *sql.DB\n    once     sync.Once\n}\n\nfunc (d *Database) GetConnection() *sql.DB {\n    d.once.Do(func() {\n        d.instance, _ = sql.Open(\"postgres\", \"connection-string\")\n    })\n    return d.instance\n}\n```\n\n## Concurrency Patterns\n\n### Worker Pool\n\n```go\ntype WorkerPool struct {\n    workerCount int\n    jobs        chan Job\n    results     chan Result\n    wg          sync.WaitGroup\n}\n\ntype Job struct {\n    ID   int\n    Data interface{}\n}\n\ntype Result struct {\n    JobID int\n    Value interface{}\n    Error error\n}\n\nfunc NewWorkerPool(workerCount int) *WorkerPool {\n    return &WorkerPool{\n        workerCount: workerCount,\n        jobs:        make(chan Job, 100),\n        results:     make(chan Result, 100),\n    }\n}\n\nfunc (p *WorkerPool) Start(ctx context.Context) {\n    for i := 0; i < p.workerCount; i++ {\n        p.wg.Add(1)\n        go p.worker(ctx)\n    }\n}\n\nfunc (p *WorkerPool) worker(ctx context.Context) {\n    defer p.wg.Done()\n\n    for {\n        select {\n        case job, ok := <-p.jobs:\n            if !ok {\n                return\n            }\n            result := processJob(job)\n            select {\n            case p.results <- result:\n            case <-ctx.Done():\n                return\n            }\n        case <-ctx.Done():\n            return\n        }\n    }\n}\n\nfunc (p *WorkerPool) Submit(job Job) {\n    p.jobs <- job\n}\n\nfunc (p *WorkerPool) Results() <-chan Result {\n    return p.results\n}\n\nfunc (p *WorkerPool) Close() {\n    close(p.jobs)\n    p.wg.Wait()\n    close(p.results)\n}\n\n// Usage\nctx := context.Background()\npool := NewWorkerPool(10)\npool.Start(ctx)\n\nfor i := 0; i < 100; i++ {\n    pool.Submit(Job{ID: i, Data: fmt.Sprintf(\"job-%d\", i)})\n}\n\ngo func() {\n    for result := range pool.Results() {\n        if result.Error != nil {\n            log.Printf(\"Job %d failed: %v\", result.JobID, result.Error)\n        } else {\n            log.Printf(\"Job %d completed: %v\", result.JobID, result.Value)\n        }\n    }\n}()\n\npool.Close()\n```\n\n### Pipeline Pattern\n\n```go\n// Generator stage\nfunc generator(ctx context.Context, nums ...int) <-chan int {\n    out := make(chan int)\n    go func() {\n        defer close(out)\n        for _, n := range nums {\n            select {\n            case out <- n:\n            case <-ctx.Done():\n                return\n            }\n        }\n    }()\n    return out\n}\n\n// Processing stage\nfunc square(ctx context.Context, in <-chan int) <-chan int {\n    out := make(chan int)\n    go func() {\n        defer close(out)\n        for n := range in {\n            select {\n            case out <- n * n:\n            case <-ctx.Done():\n                return\n            }\n        }\n    }()\n    return out\n}\n\n// Another processing stage\nfunc double(ctx context.Context, in <-chan int) <-chan int {\n    out := make(chan int)\n    go func() {\n        defer close(out)\n        for n := range in {\n            select {\n            case out <- n * 2:\n            case <-ctx.Done():\n                return\n            }\n        }\n    }()\n    return out\n}\n\n// Usage - compose pipeline\nctx := context.Background()\nnumbers := generator(ctx, 1, 2, 3, 4, 5)\nsquared := square(ctx, numbers)\ndoubled := double(ctx, squared)\n\nfor result := range doubled {\n    fmt.Println(result)\n}\n```\n\n### Fan-Out/Fan-In\n\n```go\n// Fan-out: distribute work to multiple goroutines\nfunc fanOut(ctx context.Context, input <-chan int, workers int) []<-chan int {\n    channels := make([]<-chan int, workers)\n\n    for i := 0; i < workers; i++ {\n        channels[i] = worker(ctx, input)\n    }\n\n    return channels\n}\n\nfunc worker(ctx context.Context, input <-chan int) <-chan int {\n    output := make(chan int)\n    go func() {\n        defer close(output)\n        for n := range input {\n            select {\n            case output <- expensiveOperation(n):\n            case <-ctx.Done():\n                return\n            }\n        }\n    }()\n    return output\n}\n\n// Fan-in: merge multiple channels into one\nfunc fanIn(ctx context.Context, channels ...<-chan int) <-chan int {\n    var wg sync.WaitGroup\n    output := make(chan int)\n\n    multiplex := func(ch <-chan int) {\n        defer wg.Done()\n        for n := range ch {\n            select {\n            case output <- n:\n            case <-ctx.Done():\n                return\n            }\n        }\n    }\n\n    wg.Add(len(channels))\n    for _, ch := range channels {\n        go multiplex(ch)\n    }\n\n    go func() {\n        wg.Wait()\n        close(output)\n    }()\n\n    return output\n}\n\n// Usage\nctx := context.Background()\ninput := generator(ctx, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\n// Fan-out to 3 workers\nworkers := fanOut(ctx, input, 3)\n\n// Fan-in results\nresults := fanIn(ctx, workers...)\n\nfor result := range results {\n    fmt.Println(result)\n}\n```\n\n### Semaphore Pattern\n\n```go\ntype Semaphore struct {\n    sem chan struct{}\n}\n\nfunc NewSemaphore(maxConcurrency int) *Semaphore {\n    return &Semaphore{\n        sem: make(chan struct{}, maxConcurrency),\n    }\n}\n\nfunc (s *Semaphore) Acquire() {\n    s.sem <- struct{}{}\n}\n\nfunc (s *Semaphore) Release() {\n    <-s.sem\n}\n\n// Usage\nsem := NewSemaphore(5) // Max 5 concurrent operations\n\nfor _, item := range items {\n    sem.Acquire()\n    go func(item Item) {\n        defer sem.Release()\n        process(item)\n    }(item)\n}\n```\n\n### Rate Limiting\n\n```go\n// Token bucket rate limiter\ntype RateLimiter struct {\n    ticker   *time.Ticker\n    tokens   chan struct{}\n}\n\nfunc NewRateLimiter(rate time.Duration, burst int) *RateLimiter {\n    rl := &RateLimiter{\n        ticker: time.NewTicker(rate),\n        tokens: make(chan struct{}, burst),\n    }\n\n    // Fill bucket initially\n    for i := 0; i < burst; i++ {\n        rl.tokens <- struct{}{}\n    }\n\n    // Refill tokens\n    go func() {\n        for range rl.ticker.C {\n            select {\n            case rl.tokens <- struct{}{}:\n            default:\n            }\n        }\n    }()\n\n    return rl\n}\n\nfunc (rl *RateLimiter) Wait(ctx context.Context) error {\n    select {\n    case <-rl.tokens:\n        return nil\n    case <-ctx.Done():\n        return ctx.Err()\n    }\n}\n\nfunc (rl *RateLimiter) Stop() {\n    rl.ticker.Stop()\n}\n\n// Usage\nlimiter := NewRateLimiter(time.Second/10, 5) // 10 requests per second, burst of 5\ndefer limiter.Stop()\n\nfor _, request := range requests {\n    if err := limiter.Wait(ctx); err != nil {\n        log.Printf(\"Rate limit error: %v\", err)\n        continue\n    }\n    processRequest(request)\n}\n```\n\n## Error Handling in Concurrent Code\n\n### errgroup Package\n\n```go\nimport \"golang.org/x/sync/errgroup\"\n\nfunc fetchURLs(ctx context.Context, urls []string) error {\n    g, ctx := errgroup.WithContext(ctx)\n\n    for _, url := range urls {\n        url := url // Capture for goroutine\n        g.Go(func() error {\n            return fetchURL(ctx, url)\n        })\n    }\n\n    // Wait for all goroutines, return first error\n    return g.Wait()\n}\n\n// With limited concurrency\nfunc fetchURLsLimited(ctx context.Context, urls []string) error {\n    g, ctx := errgroup.WithContext(ctx)\n    g.SetLimit(10) // Max 10 concurrent\n\n    for _, url := range urls {\n        url := url\n        g.Go(func() error {\n            return fetchURL(ctx, url)\n        })\n    }\n\n    return g.Wait()\n}\n```\n\n## Best Practices\n\n1. **Always close channels from sender side**\n2. **Use context for cancellation and timeouts**\n3. **Avoid goroutine leaks - ensure they can exit**\n4. **Use buffered channels to avoid blocking**\n5. **Prefer sync.RWMutex for read-heavy workloads**\n6. **Don't use defer in hot loops**\n7. **Test with race detector: `go test -race`**\n8. **Use errgroup for error propagation**\n9. **Limit concurrent operations with worker pools**\n10. **Profile before optimizing**\n\n## Race Condition Detection\n\n```bash\n# Run tests with race detector\ngo test -race ./...\n\n# Run program with race detector\ngo run -race main.go\n\n# Build with race detector\ngo build -race\n```\n\n## Common Patterns to Avoid\n\n```go\n// ❌ BAD: Unbounded goroutine creation\nfor _, item := range millionItems {\n    go process(item) // May create millions of goroutines\n}\n\n// ✅ GOOD: Use worker pool\npool := NewWorkerPool(100)\nfor _, item := range millionItems {\n    pool.Submit(item)\n}\n\n// ❌ BAD: Goroutine leak\nfunc leak() <-chan int {\n    ch := make(chan int)\n    go func() {\n        ch <- expensiveComputation() // If receiver never reads, goroutine leaks\n    }()\n    return ch\n}\n\n// ✅ GOOD: Use context for cancellation\nfunc noLeak(ctx context.Context) <-chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        result := expensiveComputation()\n        select {\n        case ch <- result:\n        case <-ctx.Done():\n        }\n    }()\n    return ch\n}\n```\n\n## Resources\n\nAdditional examples and patterns are available in:\n- `assets/examples/` - Complete concurrency examples\n- `assets/patterns/` - Common concurrency patterns\n- `references/` - Links to Go concurrency resources and papers"
              },
              {
                "name": "go-optimization",
                "description": "Performance optimization techniques including profiling, memory management, benchmarking, and runtime tuning. Use when optimizing Go code performance, reducing memory usage, or analyzing bottlenecks.",
                "path": "plugins/golang-development/skills/go-optimization/SKILL.md",
                "frontmatter": {
                  "name": "go-optimization",
                  "description": "Performance optimization techniques including profiling, memory management, benchmarking, and runtime tuning. Use when optimizing Go code performance, reducing memory usage, or analyzing bottlenecks."
                },
                "content": "# Go Optimization Skill\n\nThis skill provides expert guidance on Go performance optimization, covering profiling, benchmarking, memory management, and runtime tuning for building high-performance applications.\n\n## When to Use\n\nActivate this skill when:\n- Profiling application performance\n- Optimizing CPU-intensive operations\n- Reducing memory allocations\n- Tuning garbage collection\n- Writing benchmarks\n- Analyzing performance bottlenecks\n- Optimizing hot paths\n- Reducing lock contention\n\n## Profiling\n\n### CPU Profiling\n\n```go\nimport (\n    \"os\"\n    \"runtime/pprof\"\n)\n\nfunc main() {\n    // Start CPU profiling\n    f, err := os.Create(\"cpu.prof\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer f.Close()\n\n    if err := pprof.StartCPUProfile(f); err != nil {\n        log.Fatal(err)\n    }\n    defer pprof.StopCPUProfile()\n\n    // Your code here\n    runApplication()\n}\n\n// Analyze:\n// go tool pprof cpu.prof\n// (pprof) top10\n// (pprof) list functionName\n// (pprof) web\n```\n\n### Memory Profiling\n\n```go\nimport (\n    \"os\"\n    \"runtime\"\n    \"runtime/pprof\"\n)\n\nfunc writeMemProfile(filename string) {\n    f, err := os.Create(filename)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer f.Close()\n\n    runtime.GC() // Force GC before snapshot\n    if err := pprof.WriteHeapProfile(f); err != nil {\n        log.Fatal(err)\n    }\n}\n\n// Analyze:\n// go tool pprof -alloc_space mem.prof\n// go tool pprof -inuse_space mem.prof\n```\n\n### HTTP Profiling\n\n```go\nimport (\n    _ \"net/http/pprof\"\n    \"net/http\"\n)\n\nfunc main() {\n    // Enable pprof endpoints\n    go func() {\n        log.Println(http.ListenAndServe(\"localhost:6060\", nil))\n    }()\n\n    // Your application\n    runServer()\n}\n\n// Access profiles:\n// http://localhost:6060/debug/pprof/\n// go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30\n// go tool pprof http://localhost:6060/debug/pprof/heap\n```\n\n### Execution Tracing\n\n```go\nimport (\n    \"os\"\n    \"runtime/trace\"\n)\n\nfunc main() {\n    f, err := os.Create(\"trace.out\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer f.Close()\n\n    if err := trace.Start(f); err != nil {\n        log.Fatal(err)\n    }\n    defer trace.Stop()\n\n    // Your code\n    runApplication()\n}\n\n// View trace:\n// go tool trace trace.out\n```\n\n## Benchmarking\n\n### Basic Benchmarks\n\n```go\nfunc BenchmarkStringConcat(b *testing.B) {\n    for i := 0; i < b.N; i++ {\n        _ = \"hello\" + \" \" + \"world\"\n    }\n}\n\nfunc BenchmarkStringBuilder(b *testing.B) {\n    for i := 0; i < b.N; i++ {\n        var sb strings.Builder\n        sb.WriteString(\"hello\")\n        sb.WriteString(\" \")\n        sb.WriteString(\"world\")\n        _ = sb.String()\n    }\n}\n\n// Run: go test -bench=. -benchmem\n```\n\n### Sub-benchmarks\n\n```go\nfunc BenchmarkEncode(b *testing.B) {\n    data := generateTestData()\n\n    b.Run(\"JSON\", func(b *testing.B) {\n        b.ReportAllocs()\n        for i := 0; i < b.N; i++ {\n            json.Marshal(data)\n        }\n    })\n\n    b.Run(\"MessagePack\", func(b *testing.B) {\n        b.ReportAllocs()\n        for i := 0; i < b.N; i++ {\n            msgpack.Marshal(data)\n        }\n    })\n}\n```\n\n### Parallel Benchmarks\n\n```go\nfunc BenchmarkConcurrentAccess(b *testing.B) {\n    cache := NewCache()\n\n    b.RunParallel(func(pb *testing.PB) {\n        for pb.Next() {\n            cache.Get(\"key\")\n        }\n    })\n}\n```\n\n### Benchmark Comparison\n\n```bash\n# Run benchmarks and save results\ngo test -bench=. -benchmem > old.txt\n\n# Make optimizations\n\n# Run again and compare\ngo test -bench=. -benchmem > new.txt\nbenchstat old.txt new.txt\n```\n\n## Memory Optimization\n\n### Escape Analysis\n\n```go\n// Check what escapes to heap\n// go build -gcflags=\"-m\" main.go\n\n// ✅ GOOD: Stack allocation\nfunc stackAlloc() int {\n    x := 42\n    return x\n}\n\n// ❌ BAD: Heap escape\nfunc heapEscape() *int {\n    x := 42\n    return &x // x escapes to heap\n}\n\n// ✅ GOOD: Interface without allocation\nfunc noAlloc(w io.Writer, data []byte) {\n    w.Write(data)\n}\n\n// ❌ BAD: Interface causes allocation\nfunc withAlloc() io.Writer {\n    var b bytes.Buffer\n    return &b // &b escapes\n}\n```\n\n### Pre-allocation\n\n```go\n// ❌ BAD: Growing slice\nfunc badAppend(n int) []int {\n    var result []int\n    for i := 0; i < n; i++ {\n        result = append(result, i) // Multiple allocations\n    }\n    return result\n}\n\n// ✅ GOOD: Pre-allocate\nfunc goodAppend(n int) []int {\n    result := make([]int, 0, n) // Single allocation\n    for i := 0; i < n; i++ {\n        result = append(result, i)\n    }\n    return result\n}\n\n// ✅ GOOD: Known length\nfunc knownLength(n int) []int {\n    result := make([]int, n)\n    for i := 0; i < n; i++ {\n        result[i] = i\n    }\n    return result\n}\n\n// ❌ BAD: String concatenation\nfunc badConcat(strs []string) string {\n    result := \"\"\n    for _, s := range strs {\n        result += s // New allocation each time\n    }\n    return result\n}\n\n// ✅ GOOD: strings.Builder\nfunc goodConcat(strs []string) string {\n    var sb strings.Builder\n    sb.Grow(estimateSize(strs))\n    for _, s := range strs {\n        sb.WriteString(s)\n    }\n    return sb.String()\n}\n```\n\n### sync.Pool\n\n```go\nvar bufferPool = sync.Pool{\n    New: func() interface{} {\n        return new(bytes.Buffer)\n    },\n}\n\nfunc processData(data []byte) []byte {\n    // Get buffer from pool\n    buf := bufferPool.Get().(*bytes.Buffer)\n    buf.Reset()\n    defer bufferPool.Put(buf)\n\n    // Use buffer\n    buf.Write(data)\n    // Process...\n\n    return buf.Bytes()\n}\n\n// String builder pool\nvar sbPool = sync.Pool{\n    New: func() interface{} {\n        return &strings.Builder{}\n    },\n}\n\nfunc buildString(parts []string) string {\n    sb := sbPool.Get().(*strings.Builder)\n    sb.Reset()\n    defer sbPool.Put(sb)\n\n    for _, part := range parts {\n        sb.WriteString(part)\n    }\n    return sb.String()\n}\n```\n\n### Zero-Copy Techniques\n\n```go\n// Use byte slices instead of strings\nfunc parseHeader(header []byte) (key, value []byte) {\n    i := bytes.IndexByte(header, ':')\n    if i < 0 {\n        return nil, nil\n    }\n    return header[:i], header[i+1:]\n}\n\n// Reuse buffers\ntype Parser struct {\n    buf []byte\n}\n\nfunc (p *Parser) Parse(data []byte) error {\n    p.buf = p.buf[:0] // Reset length, keep capacity\n    p.buf = append(p.buf, data...)\n    // Process p.buf...\n    return nil\n}\n\n// Direct writing\nfunc writeResponse(w io.Writer, data interface{}) error {\n    enc := json.NewEncoder(w) // Write directly to w\n    return enc.Encode(data)\n}\n```\n\n## Garbage Collection Tuning\n\n### GC Control\n\n```go\nimport \"runtime/debug\"\n\n// Adjust GC target percentage\ndebug.SetGCPercent(100) // Default\n// Higher = less frequent GC, more memory\n// Lower = more frequent GC, less memory\n\n// Force GC (use sparingly!)\nruntime.GC()\n\n// Monitor GC stats\nvar stats runtime.MemStats\nruntime.ReadMemStats(&stats)\nfmt.Printf(\"Alloc = %v MB\\n\", stats.Alloc/1024/1024)\nfmt.Printf(\"TotalAlloc = %v MB\\n\", stats.TotalAlloc/1024/1024)\nfmt.Printf(\"Sys = %v MB\\n\", stats.Sys/1024/1024)\nfmt.Printf(\"NumGC = %v\\n\", stats.NumGC)\n```\n\n### GOGC Environment Variable\n\n```bash\n# Default (100%)\nGOGC=100 ./myapp\n\n# More aggressive GC (uses less memory)\nGOGC=50 ./myapp\n\n# Less frequent GC (uses more memory)\nGOGC=200 ./myapp\n\n# Disable GC (for debugging)\nGOGC=off ./myapp\n```\n\n## Concurrency Optimization\n\n### Reduce Lock Contention\n\n```go\n// ❌ BAD: Single lock\ntype BadCache struct {\n    mu    sync.Mutex\n    items map[string]interface{}\n}\n\n// ✅ GOOD: RWMutex\ntype GoodCache struct {\n    mu    sync.RWMutex\n    items map[string]interface{}\n}\n\nfunc (c *GoodCache) Get(key string) interface{} {\n    c.mu.RLock()\n    defer c.mu.RUnlock()\n    return c.items[key]\n}\n\n// ✅ BETTER: Sharded locks\ntype ShardedCache struct {\n    shards [256]*shard\n}\n\ntype shard struct {\n    mu    sync.RWMutex\n    items map[string]interface{}\n}\n\nfunc (c *ShardedCache) Get(key string) interface{} {\n    shard := c.getShard(key)\n    shard.mu.RLock()\n    defer shard.mu.RUnlock()\n    return shard.items[key]\n}\n```\n\n### Channel Buffering\n\n```go\n// ❌ BAD: Unbuffered channel causes blocking\nch := make(chan int)\n\n// ✅ GOOD: Buffered channel\nch := make(chan int, 100)\n\n// Optimal buffer size depends on:\n// - Producer/consumer rates\n// - Memory constraints\n// - Latency requirements\n```\n\n### Atomic Operations\n\n```go\nimport \"sync/atomic\"\n\ntype Counter struct {\n    value int64\n}\n\nfunc (c *Counter) Increment() {\n    atomic.AddInt64(&c.value, 1)\n}\n\nfunc (c *Counter) Value() int64 {\n    return atomic.LoadInt64(&c.value)\n}\n\n// ✅ Faster than mutex for simple operations\n// ❌ Limited to basic types and operations\n```\n\n## Algorithmic Optimization\n\n### Map Pre-sizing\n\n```go\n// ❌ BAD: Growing map\nfunc badMap(items []Item) map[string]Item {\n    m := make(map[string]Item)\n    for _, item := range items {\n        m[item.ID] = item\n    }\n    return m\n}\n\n// ✅ GOOD: Pre-sized map\nfunc goodMap(items []Item) map[string]Item {\n    m := make(map[string]Item, len(items))\n    for _, item := range items {\n        m[item.ID] = item\n    }\n    return m\n}\n```\n\n### Avoid Unnecessary Work\n\n```go\n// ❌ BAD: Repeated computation\nfunc process(items []Item) {\n    for _, item := range items {\n        if isValid(item) {\n            result := expensiveComputation(item)\n            if result > threshold {\n                handleResult(result)\n            }\n        }\n    }\n}\n\n// ✅ GOOD: Early returns\nfunc process(items []Item) {\n    for _, item := range items {\n        if !isValid(item) {\n            continue // Skip early\n        }\n        result := expensiveComputation(item)\n        if result <= threshold {\n            continue // Skip early\n        }\n        handleResult(result)\n    }\n}\n\n// ✅ BETTER: Fast path\nfunc process(items []Item) {\n    for _, item := range items {\n        // Fast path for common case\n        if item.IsSimple() {\n            handleSimple(item)\n            continue\n        }\n        // Slow path for complex case\n        handleComplex(item)\n    }\n}\n```\n\n## Runtime Tuning\n\n### GOMAXPROCS\n\n```go\nimport \"runtime\"\n\n// Set number of OS threads\nruntime.GOMAXPROCS(runtime.NumCPU())\n\n// For CPU-bound: NumCPU\n// For I/O-bound: NumCPU * 2 or more\n```\n\n### Environment Variables\n\n```bash\n# Max OS threads\nGOMAXPROCS=8 ./myapp\n\n# GC aggressiveness\nGOGC=100 ./myapp\n\n# Memory limit (Go 1.19+)\nGOMEMLIMIT=4GiB ./myapp\n\n# Trace execution\nGODEBUG=gctrace=1 ./myapp\n```\n\n## Performance Patterns\n\n### Inline Functions\n\n```go\n// Compiler inlines small functions automatically\n\n//go:inline\nfunc add(a, b int) int {\n    return a + b\n}\n\n// Keep hot-path functions small for inlining\n```\n\n### Avoid Interface Allocations\n\n```go\n// ❌ BAD: Interface allocation\nfunc badPrint(value interface{}) {\n    fmt.Println(value) // value escapes\n}\n\n// ✅ GOOD: Type-specific functions\nfunc printInt(value int) {\n    fmt.Println(value)\n}\n\nfunc printString(value string) {\n    fmt.Println(value)\n}\n```\n\n### Batch Operations\n\n```go\n// ❌ BAD: Individual operations\nfor _, item := range items {\n    db.Insert(item) // N database calls\n}\n\n// ✅ GOOD: Batch operations\ndb.BatchInsert(items) // 1 database call\n```\n\n## Best Practices\n\n1. **Profile before optimizing** - Measure, don't guess\n2. **Focus on hot paths** - Optimize the 20% that matters\n3. **Reduce allocations** - Reuse objects, pre-allocate\n4. **Use appropriate data structures** - Map vs slice vs array\n5. **Minimize lock contention** - Use RWMutex, sharding\n6. **Benchmark changes** - Use benchstat for comparisons\n7. **Test with race detector** - `go test -race`\n8. **Monitor in production** - Use profiling endpoints\n9. **Balance readability and performance** - Don't over-optimize\n10. **Use PGO** - Profile-guided optimization (Go 1.20+)\n\n## Profile-Guided Optimization (PGO)\n\n```bash\n# 1. Build with profiling\ngo build -o myapp\n\n# 2. Run and collect profile\n./myapp -cpuprofile=default.pgo\n\n# 3. Rebuild with PGO\ngo build -pgo=default.pgo -o myapp-optimized\n\n# Performance improvement: 5-15% typical\n```\n\n## Resources\n\nAdditional resources in:\n- `assets/examples/` - Performance optimization examples\n- `assets/benchmarks/` - Benchmark templates\n- `references/` - Links to profiling guides and performance papers"
              },
              {
                "name": "go-patterns",
                "description": "Modern Go patterns, idioms, and best practices from Go 1.18+. Use when user needs guidance on idiomatic Go code, design patterns, or modern Go features like generics and workspaces.",
                "path": "plugins/golang-development/skills/go-patterns/SKILL.md",
                "frontmatter": {
                  "name": "go-patterns",
                  "description": "Modern Go patterns, idioms, and best practices from Go 1.18+. Use when user needs guidance on idiomatic Go code, design patterns, or modern Go features like generics and workspaces."
                },
                "content": "# Go Patterns Skill\n\nThis skill provides comprehensive guidance on modern Go patterns, idioms, and best practices, with special focus on features introduced in Go 1.18 and later.\n\n## When to Use\n\nActivate this skill when:\n- Writing idiomatic Go code\n- Implementing design patterns in Go\n- Using modern Go features (generics, fuzzing, workspaces)\n- Refactoring code to be more idiomatic\n- Teaching Go best practices\n- Code review for idiom compliance\n\n## Modern Go Features\n\n### Generics (Go 1.18+)\n\n**Type Parameters:**\n```go\n// Generic function\nfunc Map[T, U any](slice []T, f func(T) U) []U {\n    result := make([]U, len(slice))\n    for i, v := range slice {\n        result[i] = f(v)\n    }\n    return result\n}\n\n// Usage\nnumbers := []int{1, 2, 3, 4, 5}\ndoubled := Map(numbers, func(n int) int { return n * 2 })\n```\n\n**Type Constraints:**\n```go\n// Ordered constraint\ntype Ordered interface {\n    ~int | ~int8 | ~int16 | ~int32 | ~int64 |\n    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 |\n    ~float32 | ~float64 | ~string\n}\n\nfunc Min[T Ordered](a, b T) T {\n    if a < b {\n        return a\n    }\n    return b\n}\n\n// Custom constraints\ntype Numeric interface {\n    ~int | ~int64 | ~float64\n}\n\nfunc Sum[T Numeric](values []T) T {\n    var sum T\n    for _, v := range values {\n        sum += v\n    }\n    return sum\n}\n```\n\n**Generic Data Structures:**\n```go\n// Generic stack\ntype Stack[T any] struct {\n    items []T\n}\n\nfunc NewStack[T any]() *Stack[T] {\n    return &Stack[T]{items: make([]T, 0)}\n}\n\nfunc (s *Stack[T]) Push(item T) {\n    s.items = append(s.items, item)\n}\n\nfunc (s *Stack[T]) Pop() (T, bool) {\n    if len(s.items) == 0 {\n        var zero T\n        return zero, false\n    }\n    item := s.items[len(s.items)-1]\n    s.items = s.items[:len(s.items)-1]\n    return item, true\n}\n\n// Generic map utilities\nfunc Keys[K comparable, V any](m map[K]V) []K {\n    keys := make([]K, 0, len(m))\n    for k := range m {\n        keys = append(keys, k)\n    }\n    return keys\n}\n\nfunc Values[K comparable, V any](m map[K]V) []V {\n    values := make([]V, 0, len(m))\n    for _, v := range m {\n        values = append(values, v)\n    }\n    return values\n}\n```\n\n### Workspaces (Go 1.18+)\n\n**go.work file:**\n```\ngo 1.21\n\nuse (\n    ./service\n    ./shared\n    ./tools\n)\n\nreplace example.com/legacy => ./vendor/legacy\n```\n\n**Benefits:**\n- Multi-module development\n- Local dependency overrides\n- Simplified testing across modules\n- Better monorepo support\n\n## Essential Go Patterns\n\n### Functional Options Pattern\n\n```go\ntype Server struct {\n    host    string\n    port    int\n    timeout time.Duration\n    logger  *log.Logger\n}\n\ntype Option func(*Server)\n\nfunc WithHost(host string) Option {\n    return func(s *Server) {\n        s.host = host\n    }\n}\n\nfunc WithPort(port int) Option {\n    return func(s *Server) {\n        s.port = port\n    }\n}\n\nfunc WithTimeout(timeout time.Duration) Option {\n    return func(s *Server) {\n        s.timeout = timeout\n    }\n}\n\nfunc WithLogger(logger *log.Logger) Option {\n    return func(s *Server) {\n        s.logger = logger\n    }\n}\n\nfunc NewServer(opts ...Option) *Server {\n    s := &Server{\n        host:    \"localhost\",\n        port:    8080,\n        timeout: 30 * time.Second,\n        logger:  log.Default(),\n    }\n\n    for _, opt := range opts {\n        opt(s)\n    }\n\n    return s\n}\n\n// Usage\nserver := NewServer(\n    WithHost(\"0.0.0.0\"),\n    WithPort(3000),\n    WithTimeout(60 * time.Second),\n)\n```\n\n### Builder Pattern\n\n```go\ntype Query struct {\n    table      string\n    where      []string\n    orderBy    string\n    limit      int\n    offset     int\n}\n\ntype QueryBuilder struct {\n    query Query\n}\n\nfunc NewQueryBuilder(table string) *QueryBuilder {\n    return &QueryBuilder{\n        query: Query{table: table},\n    }\n}\n\nfunc (b *QueryBuilder) Where(condition string) *QueryBuilder {\n    b.query.where = append(b.query.where, condition)\n    return b\n}\n\nfunc (b *QueryBuilder) OrderBy(field string) *QueryBuilder {\n    b.query.orderBy = field\n    return b\n}\n\nfunc (b *QueryBuilder) Limit(limit int) *QueryBuilder {\n    b.query.limit = limit\n    return b\n}\n\nfunc (b *QueryBuilder) Offset(offset int) *QueryBuilder {\n    b.query.offset = offset\n    return b\n}\n\nfunc (b *QueryBuilder) Build() Query {\n    return b.query\n}\n\n// Usage\nquery := NewQueryBuilder(\"users\").\n    Where(\"age > 18\").\n    Where(\"active = true\").\n    OrderBy(\"created_at DESC\").\n    Limit(10).\n    Offset(20).\n    Build()\n```\n\n### Strategy Pattern\n\n```go\n// Strategy interface\ntype PaymentStrategy interface {\n    Pay(amount float64) error\n}\n\n// Concrete strategies\ntype CreditCardPayment struct {\n    cardNumber string\n}\n\nfunc (c *CreditCardPayment) Pay(amount float64) error {\n    fmt.Printf(\"Paying $%.2f with credit card %s\\n\", amount, c.cardNumber)\n    return nil\n}\n\ntype PayPalPayment struct {\n    email string\n}\n\nfunc (p *PayPalPayment) Pay(amount float64) error {\n    fmt.Printf(\"Paying $%.2f with PayPal account %s\\n\", amount, p.email)\n    return nil\n}\n\ntype CryptoPayment struct {\n    walletAddress string\n}\n\nfunc (c *CryptoPayment) Pay(amount float64) error {\n    fmt.Printf(\"Paying $%.2f to wallet %s\\n\", amount, c.walletAddress)\n    return nil\n}\n\n// Context\ntype PaymentProcessor struct {\n    strategy PaymentStrategy\n}\n\nfunc NewPaymentProcessor(strategy PaymentStrategy) *PaymentProcessor {\n    return &PaymentProcessor{strategy: strategy}\n}\n\nfunc (p *PaymentProcessor) ProcessPayment(amount float64) error {\n    return p.strategy.Pay(amount)\n}\n\n// Usage\nprocessor := NewPaymentProcessor(&CreditCardPayment{cardNumber: \"1234-5678\"})\nprocessor.ProcessPayment(100.00)\n\nprocessor = NewPaymentProcessor(&PayPalPayment{email: \"user@example.com\"})\nprocessor.ProcessPayment(50.00)\n```\n\n### Observer Pattern\n\n```go\ntype Observer interface {\n    Update(event Event)\n}\n\ntype Event struct {\n    Type string\n    Data interface{}\n}\n\ntype Subject struct {\n    observers []Observer\n}\n\nfunc (s *Subject) Attach(observer Observer) {\n    s.observers = append(s.observers, observer)\n}\n\nfunc (s *Subject) Detach(observer Observer) {\n    for i, obs := range s.observers {\n        if obs == observer {\n            s.observers = append(s.observers[:i], s.observers[i+1:]...)\n            break\n        }\n    }\n}\n\nfunc (s *Subject) Notify(event Event) {\n    for _, observer := range s.observers {\n        observer.Update(event)\n    }\n}\n\n// Concrete observer\ntype Logger struct {\n    name string\n}\n\nfunc (l *Logger) Update(event Event) {\n    fmt.Printf(\"[%s] Received event: %s\\n\", l.name, event.Type)\n}\n\n// Usage\nsubject := &Subject{}\nlogger1 := &Logger{name: \"Logger1\"}\nlogger2 := &Logger{name: \"Logger2\"}\n\nsubject.Attach(logger1)\nsubject.Attach(logger2)\n\nsubject.Notify(Event{Type: \"UserCreated\", Data: \"user123\"})\n```\n\n## Idiomatic Go Patterns\n\n### Error Handling\n\n**Sentinel Errors:**\n```go\nvar (\n    ErrNotFound     = errors.New(\"resource not found\")\n    ErrUnauthorized = errors.New(\"unauthorized access\")\n    ErrInvalidInput = errors.New(\"invalid input\")\n)\n\nfunc GetUser(id string) (*User, error) {\n    if id == \"\" {\n        return nil, ErrInvalidInput\n    }\n\n    user := findUser(id)\n    if user == nil {\n        return nil, ErrNotFound\n    }\n\n    return user, nil\n}\n\n// Check with errors.Is\nif errors.Is(err, ErrNotFound) {\n    // Handle not found\n}\n```\n\n**Custom Error Types:**\n```go\ntype ValidationError struct {\n    Field   string\n    Message string\n}\n\nfunc (e *ValidationError) Error() string {\n    return fmt.Sprintf(\"validation error on %s: %s\", e.Field, e.Message)\n}\n\n// Check with errors.As\nvar valErr *ValidationError\nif errors.As(err, &valErr) {\n    fmt.Printf(\"Validation failed: %s\\n\", valErr.Field)\n}\n```\n\n**Error Wrapping:**\n```go\nfunc ProcessUser(id string) error {\n    user, err := GetUser(id)\n    if err != nil {\n        return fmt.Errorf(\"process user: %w\", err)\n    }\n\n    if err := ValidateUser(user); err != nil {\n        return fmt.Errorf(\"validate user %s: %w\", id, err)\n    }\n\n    return nil\n}\n```\n\n### Interface Patterns\n\n**Small Interfaces:**\n```go\n// Good: Small, focused interfaces\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\n\ntype Writer interface {\n    Write(p []byte) (n int, err error)\n}\n\ntype Closer interface {\n    Close() error\n}\n\n// Compose interfaces\ntype ReadWriteCloser interface {\n    Reader\n    Writer\n    Closer\n}\n```\n\n**Interface Segregation:**\n```go\n// Instead of one large interface\ntype Repository interface {\n    Create(ctx context.Context, user *User) error\n    Read(ctx context.Context, id string) (*User, error)\n    Update(ctx context.Context, user *User) error\n    Delete(ctx context.Context, id string) error\n    List(ctx context.Context) ([]*User, error)\n    Search(ctx context.Context, query string) ([]*User, error)\n}\n\n// Better: Separate interfaces\ntype UserCreator interface {\n    Create(ctx context.Context, user *User) error\n}\n\ntype UserReader interface {\n    Read(ctx context.Context, id string) (*User, error)\n    List(ctx context.Context) ([]*User, error)\n}\n\ntype UserUpdater interface {\n    Update(ctx context.Context, user *User) error\n}\n\ntype UserDeleter interface {\n    Delete(ctx context.Context, id string) error\n}\n\ntype UserSearcher interface {\n    Search(ctx context.Context, query string) ([]*User, error)\n}\n```\n\n### Context Patterns\n\n**Proper Context Usage:**\n```go\nfunc FetchData(ctx context.Context, url string) ([]byte, error) {\n    // Create request with context\n    req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)\n    if err != nil {\n        return nil, fmt.Errorf(\"create request: %w\", err)\n    }\n\n    // Check for cancellation before expensive operation\n    select {\n    case <-ctx.Done():\n        return nil, ctx.Err()\n    default:\n    }\n\n    // Execute request\n    resp, err := http.DefaultClient.Do(req)\n    if err != nil {\n        return nil, fmt.Errorf(\"execute request: %w\", err)\n    }\n    defer resp.Body.Close()\n\n    return io.ReadAll(resp.Body)\n}\n\n// Context with timeout\nctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\n\ndata, err := FetchData(ctx, \"https://api.example.com/data\")\n```\n\n**Context Values:**\n```go\ntype contextKey string\n\nconst (\n    requestIDKey contextKey = \"requestID\"\n    userIDKey    contextKey = \"userID\"\n)\n\nfunc WithRequestID(ctx context.Context, requestID string) context.Context {\n    return context.WithValue(ctx, requestIDKey, requestID)\n}\n\nfunc GetRequestID(ctx context.Context) (string, bool) {\n    requestID, ok := ctx.Value(requestIDKey).(string)\n    return requestID, ok\n}\n\nfunc WithUserID(ctx context.Context, userID string) context.Context {\n    return context.WithValue(ctx, userIDKey, userID)\n}\n\nfunc GetUserID(ctx context.Context) (string, bool) {\n    userID, ok := ctx.Value(userIDKey).(string)\n    return userID, ok\n}\n```\n\n## Best Practices\n\n1. **Accept interfaces, return structs**\n2. **Make the zero value useful**\n3. **Use composition over inheritance**\n4. **Handle errors explicitly**\n5. **Use defer for cleanup**\n6. **Prefer sync.RWMutex for read-heavy workloads**\n7. **Use context for cancellation and timeouts**\n8. **Keep interfaces small**\n9. **Document exported identifiers**\n10. **Use go fmt and go vet**\n\n## Resources\n\nAdditional patterns and examples are available in the `assets/` directory:\n- `examples/` - Complete code examples\n- `patterns/` - Design pattern implementations\n- `antipatterns/` - Common mistakes to avoid\n\nSee `references/` directory for:\n- Links to official Go documentation\n- Effective Go guidelines\n- Go proverbs\n- Community best practices"
              }
            ]
          },
          {
            "name": "ruby-sinatra-advanced",
            "description": "Advanced Ruby development tools with a focus on the Sinatra web framework",
            "source": "./plugins/ruby-sinatra-advanced",
            "category": "languages",
            "version": "1.0.0",
            "author": {
              "name": "Geoff Johnson",
              "url": "https://github.com/geoffjay"
            },
            "install_commands": [
              "/plugin marketplace add geoffjay/claude-plugins",
              "/plugin install ruby-sinatra-advanced@geoffjay-claude-plugins"
            ],
            "signals": {
              "stars": 4,
              "forks": 1,
              "pushed_at": "2025-11-04T20:23:37Z",
              "created_at": "2025-10-17T18:24:21Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/ruby-optimize",
                "description": "Analyze and optimize Ruby code for performance, memory usage, and idiomatic patterns",
                "path": "plugins/ruby-sinatra-advanced/commands/ruby-optimize.md",
                "frontmatter": {
                  "description": "Analyze and optimize Ruby code for performance, memory usage, and idiomatic patterns"
                },
                "content": "# Ruby Optimize Command\n\nAnalyzes Ruby code and provides optimization recommendations for performance, memory usage, code readability, and idiomatic Ruby patterns.\n\n## Arguments\n\n- **$1: path** (required) - File or directory path to optimize\n- **$2: focus** (optional) - Optimization focus: `performance`, `memory`, `readability`, or `all` (default: `all`)\n\n## Usage Examples\n\n```bash\n# Analyze and optimize all aspects\n/ruby-optimize app/models/user.rb\n\n# Focus on performance only\n/ruby-optimize app/services/ performance\n\n# Focus on memory optimization\n/ruby-optimize lib/data_processor.rb memory\n\n# Focus on readability and idioms\n/ruby-optimize app/ readability\n\n# Optimize entire project\n/ruby-optimize . all\n```\n\n## Workflow\n\n### Step 1: Profile and Analyze Code\n\n**Discovery Phase:**\n\n1. Parse Ruby files in specified path\n2. Identify methods and code patterns\n3. Detect performance anti-patterns\n4. Analyze memory allocation patterns\n5. Check for idiomatic Ruby usage\n6. Measure complexity metrics\n\n**Analysis Tools:**\n```ruby\n# Use Ruby parser\nrequire 'parser/current'\n\n# AST analysis for pattern detection\nast = Parser::CurrentRuby.parse(source_code)\n\n# Complexity analysis\nrequire 'flog'\nflog = Flog.new\nflog.flog(file_path)\n```\n\n### Step 2: Performance Analysis\n\n**Detect Performance Anti-Patterns:**\n\n**1. Inefficient Enumeration:**\n```ruby\n# ISSUE: Using each when map is appropriate\ndef process_users\n  result = []\n  users.each do |user|\n    result << user.name.upcase\n  end\n  result\nend\n\n# OPTIMIZED: Use map\ndef process_users\n  users.map { |user| user.name.upcase }\nend\n\n# Benchmark improvement: 15-20% faster, less memory\n```\n\n**2. Repeated Object Creation:**\n```ruby\n# ISSUE: Creating regex in loop\ndef filter_emails(emails)\n  emails.select { |email| email.match(/@gmail\\.com/) }\nend\n\n# OPTIMIZED: Create regex once\nEMAIL_PATTERN = /@gmail\\.com/\n\ndef filter_emails(emails)\n  emails.select { |email| email.match(EMAIL_PATTERN) }\nend\n\n# Benchmark improvement: 30-40% faster for large datasets\n```\n\n**3. N+1 Query Detection:**\n```ruby\n# ISSUE: N+1 queries\ndef user_with_posts\n  users = User.all\n  users.map do |user|\n    {\n      name: user.name,\n      posts_count: user.posts.count  # Separate query for each user\n    }\n  end\nend\n\n# OPTIMIZED: Eager load or use counter cache\ndef user_with_posts\n  users = User.eager(:posts).all\n  users.map do |user|\n    {\n      name: user.name,\n      posts_count: user.posts.count\n    }\n  end\nend\n\n# Or with counter cache\ndef user_with_posts\n  users = User.all\n  users.map do |user|\n    {\n      name: user.name,\n      posts_count: user.posts_count  # From counter cache\n    }\n  end\nend\n\n# Benchmark improvement: 10-100x faster depending on data size\n```\n\n**4. Inefficient String Building:**\n```ruby\n# ISSUE: String concatenation in loop\ndef build_csv(records)\n  csv = \"\"\n  records.each do |record|\n    csv += \"#{record.id},#{record.name}\\n\"\n  end\n  csv\nend\n\n# OPTIMIZED: Use array join or StringIO\ndef build_csv(records)\n  records.map { |r| \"#{r.id},#{r.name}\" }.join(\"\\n\")\nend\n\n# Or for very large datasets\nrequire 'stringio'\n\ndef build_csv(records)\n  StringIO.new.tap do |io|\n    records.each do |record|\n      io.puts \"#{record.id},#{record.name}\"\n    end\n  end.string\nend\n\n# Benchmark improvement: 5-10x faster for large datasets\n```\n\n**5. Unnecessary Sorting:**\n```ruby\n# ISSUE: Sorting entire collection when only need max/min\ndef highest_score(users)\n  users.sort_by(&:score).last\nend\n\n# OPTIMIZED: Use max_by\ndef highest_score(users)\n  users.max_by(&:score)\nend\n\n# Benchmark improvement: O(n) vs O(n log n)\n```\n\n**6. Block Performance:**\n```ruby\n# ISSUE: Symbol#to_proc with arguments\nusers.map { |u| u.name.upcase }\n\n# OPTIMIZED: Use method chaining where possible\nusers.map(&:name).map(&:upcase)\n\n# ISSUE: Creating proc in loop\nitems.select { |item| item.active? }\n\n# OPTIMIZED: Use symbol to_proc\nitems.select(&:active?)\n\n# Benchmark improvement: 10-15% faster\n```\n\n**7. Hash Access Patterns:**\n```ruby\n# ISSUE: Checking key and accessing value separately\nif hash.key?(:name)\n  value = hash[:name]\n  process(value)\nend\n\n# OPTIMIZED: Use fetch or safe navigation\nif value = hash[:name]\n  process(value)\nend\n\n# Or with default\nvalue = hash.fetch(:name, default_value)\nprocess(value)\n\n# ISSUE: Using Hash#merge in loop\nresult = {}\nitems.each do |item|\n  result = result.merge(item.to_hash)\nend\n\n# OPTIMIZED: Use Hash#merge! or each_with_object\nresult = items.each_with_object({}) do |item, hash|\n  hash.merge!(item.to_hash)\nend\n\n# Benchmark improvement: 2-3x faster\n```\n\n### Step 3: Memory Optimization\n\n**Detect Memory Issues:**\n\n**1. String Allocation:**\n```ruby\n# ISSUE: Creating new strings in loop\n1000.times do\n  hash['key'] = value  # Creates new 'key' string each time\nend\n\n# OPTIMIZED: Use symbols or frozen strings\n1000.times do\n  hash[:key] = value  # Reuses same symbol\nend\n\n# Or with frozen string literal\n# frozen_string_literal: true\n\n# Memory saved: ~40 bytes per string\n```\n\n**2. Array/Hash Allocation:**\n```ruby\n# ISSUE: Building large array without size hint\ndata = []\n10_000.times do |i|\n  data << i\nend\n\n# OPTIMIZED: Preallocate size\ndata = Array.new(10_000)\n10_000.times do |i|\n  data[i] = i\nend\n\n# Or use a different approach\ndata = (0...10_000).to_a\n\n# Memory improvement: Fewer reallocations\n```\n\n**3. Object Copying:**\n```ruby\n# ISSUE: Unnecessary duplication\ndef process(data)\n  temp = data.dup\n  temp.map! { |item| item * 2 }\n  temp\nend\n\n# OPTIMIZED: Use map without dup if original not needed\ndef process(data)\n  data.map { |item| item * 2 }\nend\n\n# Memory saved: Full array copy avoided\n```\n\n**4. Lazy Evaluation:**\n```ruby\n# ISSUE: Loading everything into memory\nFile.readlines('large_file.txt').each do |line|\n  process(line)\nend\n\n# OPTIMIZED: Process line by line\nFile.foreach('large_file.txt') do |line|\n  process(line)\nend\n\n# Or use lazy enumeration\nFile.readlines('large_file.txt').lazy.each do |line|\n  process(line)\nend\n\n# Memory saved: File size - line size\n```\n\n**5. Memoization Leaks:**\n```ruby\n# ISSUE: Unbounded memoization cache\ndef expensive_calculation(input)\n  @cache ||= {}\n  @cache[input] ||= perform_calculation(input)\nend\n\n# OPTIMIZED: Use bounded cache (LRU)\nrequire 'lru_redux'\n\ndef expensive_calculation(input)\n  @cache ||= LruRedux::Cache.new(1000)\n  @cache.getset(input) { perform_calculation(input) }\nend\n\n# Memory saved: Prevents cache from growing unbounded\n```\n\n### Step 4: Readability and Idiom Analysis\n\n**Detect Non-Idiomatic Code:**\n\n**1. Conditional Assignment:**\n```ruby\n# NON-IDIOMATIC\nif user.name.nil?\n  user.name = 'Guest'\nend\n\n# IDIOMATIC\nuser.name ||= 'Guest'\n\n# NON-IDIOMATIC\nif value == nil\n  value = default\nelse\n  value = value\nend\n\n# IDIOMATIC\nvalue ||= default\n```\n\n**2. Safe Navigation:**\n```ruby\n# NON-IDIOMATIC\nif user && user.profile && user.profile.avatar\n  display(user.profile.avatar)\nend\n\n# IDIOMATIC\ndisplay(user&.profile&.avatar) if user&.profile&.avatar\n# or\nif avatar = user&.profile&.avatar\n  display(avatar)\nend\n```\n\n**3. Enumerable Methods:**\n```ruby\n# NON-IDIOMATIC\nfound = nil\nusers.each do |user|\n  if user.active?\n    found = user\n    break\n  end\nend\n\n# IDIOMATIC\nfound = users.find(&:active?)\n\n# NON-IDIOMATIC\nactives = []\nusers.each do |user|\n  actives << user if user.active?\nend\n\n# IDIOMATIC\nactives = users.select(&:active?)\n\n# NON-IDIOMATIC\ntotal = 0\nprices.each { |price| total += price }\n\n# IDIOMATIC\ntotal = prices.sum\n# or\ntotal = prices.reduce(:+)\n```\n\n**4. Guard Clauses:**\n```ruby\n# NON-IDIOMATIC\ndef process(user)\n  if user\n    if user.active?\n      if user.verified?\n        # Main logic here\n        perform_action(user)\n      end\n    end\n  end\nend\n\n# IDIOMATIC\ndef process(user)\n  return unless user\n  return unless user.active?\n  return unless user.verified?\n\n  perform_action(user)\nend\n```\n\n**5. Pattern Matching (Ruby 3.0+):**\n```ruby\n# LESS IDIOMATIC (Ruby 3.0+)\nif response.is_a?(Hash) && response[:status] == 'success'\n  handle_success(response[:data])\nelsif response.is_a?(Hash) && response[:status] == 'error'\n  handle_error(response[:error])\nend\n\n# MORE IDIOMATIC (Ruby 3.0+)\ncase response\nin { status: 'success', data: }\n  handle_success(data)\nin { status: 'error', error: }\n  handle_error(error)\nend\n```\n\n**6. Block Syntax:**\n```ruby\n# NON-IDIOMATIC: do/end for single line\nusers.map do |u| u.name end\n\n# IDIOMATIC: braces for single line\nusers.map { |u| u.name }\n\n# NON-IDIOMATIC: braces for multi-line\nusers.select { |u|\n  u.active? &&\n  u.verified?\n}\n\n# IDIOMATIC: do/end for multi-line\nusers.select do |u|\n  u.active? && u.verified?\nend\n```\n\n**7. String Interpolation:**\n```ruby\n# NON-IDIOMATIC\n\"Hello \" + user.name + \"!\"\n\n# IDIOMATIC\n\"Hello #{user.name}!\"\n\n# NON-IDIOMATIC\n'Total: ' + total.to_s\n\n# IDIOMATIC\n\"Total: #{total}\"\n```\n\n### Step 5: Generate Benchmarks\n\n**Create Benchmark Comparisons:**\n\n```ruby\n# Generated benchmark file: benchmarks/optimization_comparison.rb\nrequire 'benchmark'\n\nputs \"Performance Comparison\"\nputs \"=\" * 50\n\n# Original implementation\ndef original_method\n  # Original code\nend\n\n# Optimized implementation\ndef optimized_method\n  # Optimized code\nend\n\nBenchmark.bm(20) do |x|\n  x.report(\"Original:\") do\n    10_000.times { original_method }\n  end\n\n  x.report(\"Optimized:\") do\n    10_000.times { optimized_method }\n  end\nend\n\n# Memory profiling\nrequire 'memory_profiler'\n\nputs \"\\nMemory Comparison\"\nputs \"=\" * 50\n\nreport = MemoryProfiler.report do\n  original_method\nend\n\nputs \"Original Memory Usage:\"\nputs \"  Total allocated: #{report.total_allocated_memsize} bytes\"\nputs \"  Total retained: #{report.total_retained_memsize} bytes\"\n\nreport = MemoryProfiler.report do\n  optimized_method\nend\n\nputs \"\\nOptimized Memory Usage:\"\nputs \"  Total allocated: #{report.total_allocated_memsize} bytes\"\nputs \"  Total retained: #{report.total_retained_memsize} bytes\"\n```\n\n### Step 6: Generate Optimization Report\n\n**Comprehensive Report Structure:**\n\n```\n================================================================================\nRUBY OPTIMIZATION REPORT\n================================================================================\n\nFile: app/services/data_processor.rb\nFocus: all\nDate: 2024-01-15\n\n--------------------------------------------------------------------------------\nSUMMARY\n--------------------------------------------------------------------------------\n  Total Issues Found: 18\n    Performance: 8\n    Memory: 5\n    Readability: 5\n\n  Potential Improvements:\n    Estimated Speed Gain: 2.5x faster\n    Estimated Memory Reduction: 45%\n    Code Quality: +15 readability score\n\n--------------------------------------------------------------------------------\nPERFORMANCE OPTIMIZATIONS\n--------------------------------------------------------------------------------\n\n1. Inefficient Enumeration (Line 23)\n   Severity: Medium\n   Impact: 20% speed improvement\n\n   Current:\n     result = []\n     users.each { |u| result << u.name.upcase }\n     result\n\n   Optimized:\n     users.map { |u| u.name.upcase }\n\n   Benchmark:\n     Before: 1.45ms per 1000 items\n     After:  1.15ms per 1000 items\n     Improvement: 20.7% faster\n\n2. N+1 Query Pattern (Line 45)\n   Severity: High\n   Impact: 10-100x speed improvement\n\n   Current:\n     users.map { |u| { name: u.name, posts: u.posts.count } }\n\n   Optimized:\n     users.eager(:posts).map { |u| { name: u.name, posts: u.posts.count } }\n\n   Benchmark:\n     Before: 1250ms for 100 users with 10 posts each\n     After:  25ms for 100 users with 10 posts each\n     Improvement: 50x faster\n\n[... more performance issues ...]\n\n--------------------------------------------------------------------------------\nMEMORY OPTIMIZATIONS\n--------------------------------------------------------------------------------\n\n1. String Allocation in Loop (Line 67)\n   Severity: Medium\n   Impact: 400 bytes saved per 1000 iterations\n\n   Current:\n     1000.times { hash['key'] = value }\n\n   Optimized:\n     1000.times { hash[:key] = value }\n\n   Memory:\n     Before: 40KB allocated\n     After:  160 bytes allocated\n     Savings: 99.6%\n\n[... more memory issues ...]\n\n--------------------------------------------------------------------------------\nREADABILITY IMPROVEMENTS\n--------------------------------------------------------------------------------\n\n1. Non-Idiomatic Conditional (Line 89)\n   Severity: Low\n   Impact: Improved code clarity\n\n   Current:\n     if user.name.nil?\n       user.name = 'Guest'\n     end\n\n   Idiomatic:\n     user.name ||= 'Guest'\n\n[... more readability issues ...]\n\n--------------------------------------------------------------------------------\nCOMPLEXITY METRICS\n--------------------------------------------------------------------------------\n\nMethod Complexity (Flog scores):\n  process_data: 45.2 (High - consider refactoring)\n  transform_records: 23.1 (Medium)\n  validate_input: 8.5 (Low)\n\nRecommendations:\n  - Extract methods from process_data to reduce complexity\n  - Consider using service objects for complex operations\n\n--------------------------------------------------------------------------------\nBENCHMARKS\n--------------------------------------------------------------------------------\n\nFile Generated: benchmarks/data_processor_comparison.rb\n\nRun benchmarks:\n  ruby benchmarks/data_processor_comparison.rb\n\nExpected Results:\n  Original:   2.450s\n  Optimized:  0.980s\n  Speedup:    2.5x\n\n--------------------------------------------------------------------------------\nACTION ITEMS\n--------------------------------------------------------------------------------\n\nHigh Priority:\n  1. Fix N+1 query in line 45 (50x performance gain)\n  2. Optimize string building in line 67 (99% memory reduction)\n  3. Refactor process_data method (complexity: 45.2)\n\nMedium Priority:\n  4. Use map instead of each+append (20% speed gain)\n  5. Cache regex patterns (30% speed gain)\n  6. Implement guard clauses in validate_input\n\nLow Priority:\n  7. Use idiomatic Ruby patterns throughout\n  8. Apply consistent block syntax\n  9. Improve variable naming\n\n--------------------------------------------------------------------------------\nAUTOMATIC FIXES\n--------------------------------------------------------------------------------\n\nLow-risk changes that can be auto-applied:\n  - String to symbol conversion (5 occurrences)\n  - each to map conversion (3 occurrences)\n  - Conditional to ||= conversion (4 occurrences)\n\nApply automatic fixes? [y/N]\n\n================================================================================\nEND REPORT\n================================================================================\n```\n\n### Step 7: Optional - Apply Automatic Fixes\n\n**Safe Transformations:**\n\nFor low-risk, well-defined improvements:\n\n```ruby\n# Create optimized version of file\n# app/services/data_processor_optimized.rb\n\n# Apply automatic transformations:\n# - String literals to symbols\n# - each+append to map\n# - if/nil? to ||=\n# - Block syntax corrections\n\n# Generate diff\n# Show side-by-side comparison\n# Offer to replace original or keep both\n```\n\n## Output Formats\n\n### Console Output\n- Colored severity indicators (red/yellow/green)\n- Progress indicator during analysis\n- Summary statistics\n- Top issues highlighted\n\n### Report Files\n- Detailed markdown report\n- Generated benchmark files\n- Optional optimized code files\n- Diff files for review\n\n### JSON Output (Optional)\n```json\n{\n  \"file\": \"app/services/data_processor.rb\",\n  \"summary\": {\n    \"total_issues\": 18,\n    \"performance\": 8,\n    \"memory\": 5,\n    \"readability\": 5\n  },\n  \"issues\": [\n    {\n      \"type\": \"performance\",\n      \"severity\": \"high\",\n      \"line\": 45,\n      \"description\": \"N+1 query pattern\",\n      \"impact\": \"50x speed improvement\",\n      \"suggestion\": \"Use eager loading\"\n    }\n  ]\n}\n```\n\n## Error Handling\n\n- Handle invalid Ruby syntax gracefully\n- Skip non-Ruby files\n- Report files that cannot be parsed\n- Handle missing dependencies\n- Warn about risky optimizations\n- Preserve backups before modifications"
              },
              {
                "name": "/sinatra-review",
                "description": "Review Sinatra code for security issues, performance problems, route conflicts, and framework best practices",
                "path": "plugins/ruby-sinatra-advanced/commands/sinatra-review.md",
                "frontmatter": {
                  "description": "Review Sinatra code for security issues, performance problems, route conflicts, and framework best practices"
                },
                "content": "# Sinatra Review Command\n\nPerforms comprehensive code review of Sinatra applications, identifying security vulnerabilities, performance issues, routing conflicts, and deviations from best practices.\n\n## Arguments\n\n- **$1: path** (optional) - Path to review (defaults to current directory)\n\n## Usage Examples\n\n```bash\n# Review current directory\n/sinatra-review\n\n# Review specific directory\n/sinatra-review /path/to/sinatra-app\n\n# Review specific file\n/sinatra-review app/controllers/users_controller.rb\n```\n\n## Workflow\n\n### Step 1: Scan and Identify Application Files\n\n**Discovery Phase:**\n1. Locate `config.ru` to identify Rack application\n2. Find Sinatra application files (controllers, routes)\n3. Identify application structure (classic vs modular)\n4. Scan for middleware configuration\n5. Locate view templates and helpers\n6. Find configuration files\n7. Identify database and model files\n\n**File Patterns to Search:**\n```bash\n# Application files\n*.rb files inheriting from Sinatra::Base\nconfig.ru\napp.rb (classic style)\napp/controllers/*.rb\nlib/**/*.rb\n\n# View templates\nviews/**/*.erb\nviews/**/*.haml\nviews/**/*.slim\n\n# Configuration\nconfig/*.rb\nGemfile\n.env files\n```\n\n### Step 2: Analyze Route Definitions\n\n**Route Conflict Detection:**\n\nCheck for:\n1. **Duplicate routes** with same path and HTTP method\n2. **Overlapping routes** where order matters (specific before generic)\n3. **Missing route constraints** leading to ambiguous matching\n4. **Wildcard route conflicts**\n\n**Examples of Issues:**\n\n```ruby\n# ISSUE: Route order conflict\nget '/users/new' do\n  # Never reached because of wildcard below\nend\n\nget '/users/:id' do\n  # This catches /users/new\nend\n\n# FIX: Specific routes before wildcards\nget '/users/new' do\n  # Now reached first\nend\n\nget '/users/:id' do\n  # Only catches other IDs\nend\n\n# ISSUE: Duplicate routes\nget '/api/users' do\n  # First definition\nend\n\nget '/api/users' do\n  # Overwrites first - only this runs\nend\n\n# ISSUE: Missing validation\nget '/users/:id' do\n  user = User.find(params[:id])  # What if id is not numeric?\nend\n\n# FIX: Add validation\nget '/users/:id', id: /\\d+/ do\n  user = User.find(params[:id])\nend\n```\n\n**Route Analysis Report:**\n```\nRoute Analysis:\n  Total routes: 25\n  GET: 15, POST: 5, PUT: 3, DELETE: 2\n\n  ⚠ Warnings:\n    - Route order issue in app/controllers/users_controller.rb:15\n      GET /users/:id should be after GET /users/new\n\n    - Missing parameter validation in app/controllers/posts_controller.rb:32\n      Route GET /posts/:id should validate :id is numeric\n```\n\n### Step 3: Security Analysis\n\n**Security Checklist:**\n\n**1. CSRF Protection:**\n```ruby\n# CHECK: Is CSRF protection enabled?\nuse Rack::Protection\n# or\nuse Rack::Protection::AuthenticityToken\n\n# ISSUE: Missing CSRF for POST/PUT/DELETE\npost '/users' do\n  User.create(params[:user])  # Vulnerable to CSRF\nend\n\n# FIX: Ensure Rack::Protection is enabled\n```\n\n**2. XSS Prevention:**\n```ruby\n# CHECK: Are templates auto-escaping HTML?\n# ERB: Use <%= %> (escapes) not <%== %> (raw)\n\n# ISSUE: Raw user input in template\n<div><%== @user.bio %></div>\n\n# FIX: Escape user input\n<div><%= @user.bio %></div>\n\n# CHECK: JSON responses properly encoded\n# ISSUE: Manual JSON creation\nget '/api/users' do\n  \"{ \\\"name\\\": \\\"#{user.name}\\\" }\"  # XSS if name contains quotes\nend\n\n# FIX: Use JSON library\nget '/api/users' do\n  json({ name: user.name })\nend\n```\n\n**3. SQL Injection:**\n```ruby\n# ISSUE: String interpolation in queries\nDB[\"SELECT * FROM users WHERE email = '#{params[:email]}'\"]\n\n# FIX: Use parameterized queries\nDB[\"SELECT * FROM users WHERE email = ?\", params[:email]]\n\n# ISSUE: Unsafe ActiveRecord\nUser.where(\"email = '#{params[:email]}'\")\n\n# FIX: Use hash conditions\nUser.where(email: params[:email])\n```\n\n**4. Authentication & Authorization:**\n```ruby\n# CHECK: Protected routes have authentication\n# ISSUE: Admin route without auth check\ndelete '/users/:id' do\n  User.find(params[:id]).destroy  # No auth check!\nend\n\n# FIX: Add authentication\nbefore '/admin/*' do\n  halt 401 unless current_user&.admin?\nend\n\n# CHECK: Session security\n# ISSUE: Weak session configuration\nuse Rack::Session::Cookie, secret: 'easy'\n\n# FIX: Strong secret and secure flags\nuse Rack::Session::Cookie,\n  secret: ENV['SESSION_SECRET'],  # Long random string\n  same_site: :strict,\n  httponly: true,\n  secure: production?\n```\n\n**5. Mass Assignment:**\n```ruby\n# ISSUE: Accepting all params\nUser.create(params)\n\n# FIX: Whitelist allowed attributes\ndef user_params\n  params.slice(:name, :email, :bio)\nend\n\nUser.create(user_params)\n```\n\n**6. File Upload Security:**\n```ruby\n# ISSUE: Unrestricted file uploads\npost '/upload' do\n  File.write(\"uploads/#{params[:file][:filename]}\", params[:file][:tempfile].read)\nend\n\n# FIX: Validate file type and sanitize filename\npost '/upload' do\n  file = params[:file]\n\n  # Validate content type\n  halt 400 unless ['image/jpeg', 'image/png'].include?(file[:type])\n\n  # Sanitize filename\n  filename = File.basename(file[:filename]).gsub(/[^a-zA-Z0-9\\._-]/, '')\n\n  # Save with random name\n  secure_name = \"#{SecureRandom.hex}-#{filename}\"\n  File.write(\"uploads/#{secure_name}\", file[:tempfile].read)\nend\n```\n\n**7. Information Disclosure:**\n```ruby\n# ISSUE: Detailed error messages in production\nconfigure :production do\n  set :show_exceptions, true  # Exposes stack traces\nend\n\n# FIX: Hide errors in production\nconfigure :production do\n  set :show_exceptions, false\n  set :dump_errors, false\nend\n\nerror do\n  log_error(env['sinatra.error'])\n  json({ error: 'Internal server error' }, 500)\nend\n```\n\n**Security Report:**\n```\nSecurity Analysis:\n  ✓ CSRF protection enabled (Rack::Protection)\n  ✓ Session configured securely\n  ⚠ Potential Issues:\n    - SQL injection risk in app/models/user.rb:45\n    - Raw HTML output in views/profile.erb:12\n    - Missing authentication check in app/controllers/admin_controller.rb:23\n    - Weak session secret detected\n\n  Critical: 1\n  High: 2\n  Medium: 3\n  Low: 2\n```\n\n### Step 4: Review Middleware Configuration\n\n**Middleware Analysis:**\n\nCheck for:\n1. **Missing essential middleware** (Protection, CommonLogger)\n2. **Incorrect ordering** (e.g., session after auth)\n3. **Performance issues** (e.g., no compression)\n4. **Security middleware** properly configured\n\n**Common Issues:**\n\n```ruby\n# ISSUE: Missing compression\n# FIX: Add Rack::Deflater\nuse Rack::Deflater\n\n# ISSUE: Session middleware after authentication\nuse TokenAuth\nuse Rack::Session::Cookie  # Session needed by auth!\n\n# FIX: Session before authentication\nuse Rack::Session::Cookie\nuse TokenAuth\n\n# ISSUE: No security headers\n# FIX: Add Rack::Protection\nuse Rack::Protection, except: [:session_hijacking]\n\n# ISSUE: Static file serving after application\nrun MyApp\nuse Rack::Static  # Never reached!\n\n# FIX: Static before application\nuse Rack::Static, urls: ['/css', '/js'], root: 'public'\nrun MyApp\n```\n\n**Middleware Report:**\n```\nMiddleware Configuration:\n  ✓ Rack::CommonLogger (logging)\n  ✓ Rack::Session::Cookie (sessions)\n  ✓ Rack::Protection (security)\n  ⚠ Warnings:\n    - Missing Rack::Deflater (compression)\n    - Middleware order issue: Session should be before CustomAuth\n    - Consider adding Rack::Attack for rate limiting\n```\n\n### Step 5: Performance Assessment\n\n**Performance Patterns to Check:**\n\n**1. Database Query Optimization:**\n```ruby\n# ISSUE: N+1 queries\nget '/users' do\n  users = User.all\n  users.map { |u| { name: u.name, posts: u.posts.count } }\n  # Queries DB for each user's posts\nend\n\n# FIX: Eager load or use counter cache\nget '/users' do\n  users = User.eager(:posts).all\n  users.map { |u| { name: u.name, posts: u.posts.count } }\nend\n\n# ISSUE: Loading entire collection\nget '/users' do\n  json User.all.map(&:to_hash)  # Load all users in memory\nend\n\n# FIX: Paginate\nget '/users' do\n  page = params[:page]&.to_i || 1\n  per_page = 50\n\n  users = User.limit(per_page).offset((page - 1) * per_page)\n  json users.map(&:to_hash)\nend\n```\n\n**2. Caching Opportunities:**\n```ruby\n# ISSUE: Expensive operation on every request\nget '/stats' do\n  json calculate_expensive_stats  # Takes 2 seconds\nend\n\n# FIX: Add caching\nget '/stats' do\n  stats = cache.fetch('stats', expires_in: 300) do\n    calculate_expensive_stats\n  end\n  json stats\nend\n\n# ISSUE: No HTTP caching headers\nget '/public/data' do\n  json PublicData.all\nend\n\n# FIX: Add cache control\nget '/public/data' do\n  cache_control :public, max_age: 3600\n  json PublicData.all\nend\n```\n\n**3. Response Optimization:**\n```ruby\n# ISSUE: Rendering large response synchronously\nget '/large-export' do\n  csv = generate_large_csv  # Blocks for 30 seconds\n  send_file csv\nend\n\n# FIX: Stream or queue as background job\nget '/large-export' do\n  stream do |out|\n    CSV.generate(out) do |csv|\n      User.find_each do |user|\n        csv << user.to_csv_row\n      end\n    end\n  end\nend\n```\n\n**Performance Report:**\n```\nPerformance Analysis:\n  ⚠ Issues Detected:\n    - Potential N+1 query in app/controllers/users_controller.rb:42\n    - Missing pagination in GET /api/posts (returns all records)\n    - No caching headers on GET /api/public/data\n    - Expensive operation in GET /stats without caching\n\n  Recommendations:\n    - Add database query optimization (eager loading)\n    - Implement pagination for collection endpoints\n    - Add HTTP caching headers for static content\n    - Consider Redis caching for expensive operations\n```\n\n### Step 6: Error Handling Review\n\n**Error Handling Patterns:**\n\n```ruby\n# ISSUE: No error handlers defined\nget '/users/:id' do\n  User.find(params[:id])  # Raises if not found, shows stack trace\nend\n\n# FIX: Add error handlers\nerror ActiveRecord::RecordNotFound do\n  json({ error: 'Not found' }, 404)\nend\n\nerror 404 do\n  json({ error: 'Endpoint not found' }, 404)\nend\n\nerror 500 do\n  json({ error: 'Internal server error' }, 500)\nend\n\n# ISSUE: Not handling exceptions in routes\npost '/users' do\n  User.create!(params)  # Raises on validation error\nend\n\n# FIX: Handle exceptions\npost '/users' do\n  user = User.create(params)\n  if user.persisted?\n    json(user.to_hash, 201)\n  else\n    json({ errors: user.errors }, 422)\n  end\nend\n```\n\n### Step 7: Testing Coverage\n\n**Test Analysis:**\n\nCheck for:\n1. Test files exist\n2. Route coverage\n3. Error case testing\n4. Integration vs unit tests\n5. Test quality and patterns\n\n**Report:**\n```\nTesting Analysis:\n  Framework: RSpec\n  Total specs: 45\n  Coverage: 78%\n\n  ⚠ Missing Tests:\n    - No tests for POST /api/users\n    - Error cases not tested in app/controllers/posts_controller.rb\n    - Missing integration tests for authentication flow\n\n  Recommendations:\n    - Add tests for all POST/PUT/DELETE routes\n    - Test error scenarios (404, 422, 500)\n    - Increase coverage to 90%+\n```\n\n### Step 8: Generate Comprehensive Report\n\n**Final Report Structure:**\n\n```\n================================================================================\nSINATRA CODE REVIEW REPORT\n================================================================================\n\nProject: my-sinatra-app\nPath: /path/to/app\nDate: 2024-01-15\nReviewer: Sinatra Review Tool\n\n--------------------------------------------------------------------------------\nSUMMARY\n--------------------------------------------------------------------------------\n  Total Issues: 15\n    Critical: 2\n    High: 4\n    Medium: 6\n    Low: 3\n\n  Categories:\n    Security: 5 issues\n    Performance: 4 issues\n    Best Practices: 6 issues\n\n--------------------------------------------------------------------------------\nCRITICAL ISSUES\n--------------------------------------------------------------------------------\n\n1. SQL Injection Vulnerability\n   Location: app/models/user.rb:45\n   Severity: Critical\n\n   Issue:\n     DB[\"SELECT * FROM users WHERE email = '#{email}'\"]\n\n   Fix:\n     DB[\"SELECT * FROM users WHERE email = ?\", email]\n\n   Impact: Attacker can execute arbitrary SQL queries\n\n2. Missing Authentication on Admin Route\n   Location: app/controllers/admin_controller.rb:23\n   Severity: Critical\n\n   Issue:\n     delete '/users/:id' do\n       User.find(params[:id]).destroy\n     end\n\n   Fix:\n     before '/admin/*' do\n       authenticate_admin!\n     end\n\n   Impact: Unauthorized users can delete records\n\n--------------------------------------------------------------------------------\nHIGH PRIORITY ISSUES\n--------------------------------------------------------------------------------\n\n[List high priority issues...]\n\n--------------------------------------------------------------------------------\nRECOMMENDATIONS\n--------------------------------------------------------------------------------\n\nSecurity:\n  - Enable Rack::Protection::AuthenticityToken for CSRF\n  - Rotate session secret to strong random value\n  - Implement rate limiting with Rack::Attack\n  - Add Content-Security-Policy headers\n\nPerformance:\n  - Add Rack::Deflater for response compression\n  - Implement caching strategy (Redis or Memcached)\n  - Add pagination to collection endpoints\n  - Optimize database queries (N+1 issues)\n\nTesting:\n  - Increase test coverage to 90%+\n  - Add integration tests for critical flows\n  - Test error scenarios\n  - Add security-focused tests\n\nBest Practices:\n  - Extract business logic to service objects\n  - Use helpers for repeated code\n  - Implement proper error handling\n  - Add API documentation\n\n--------------------------------------------------------------------------------\nDETAILED FINDINGS\n--------------------------------------------------------------------------------\n\n[Full list of all issues with locations, descriptions, and fixes]\n\n================================================================================\nEND REPORT\n================================================================================\n```\n\n## Review Categories\n\n### Security\n- CSRF protection\n- XSS prevention\n- SQL injection\n- Authentication/Authorization\n- Session security\n- Mass assignment\n- File upload security\n- Information disclosure\n- Secure headers\n\n### Performance\n- Database query optimization\n- N+1 queries\n- Caching opportunities\n- Response optimization\n- Static asset handling\n- Connection pooling\n\n### Best Practices\n- Route organization\n- Error handling\n- Code organization\n- Helper usage\n- Configuration management\n- Logging\n- Documentation\n\n### Testing\n- Test coverage\n- Test quality\n- Missing tests\n- Test organization\n\n## Output Format\n\n- Console output with colored severity indicators\n- Detailed report with file locations and line numbers\n- Suggested fixes with code examples\n- Priority-sorted issue list\n- Summary statistics\n\n## Error Handling\n\n- Handle non-Sinatra Ruby applications gracefully\n- Report when application structure cannot be determined\n- Skip non-readable files\n- Handle parse errors in Ruby files"
              },
              {
                "name": "/sinatra-scaffold",
                "description": "Scaffold new Sinatra applications with modern structure, best practices, testing setup, and deployment configuration",
                "path": "plugins/ruby-sinatra-advanced/commands/sinatra-scaffold.md",
                "frontmatter": {
                  "description": "Scaffold new Sinatra applications with modern structure, best practices, testing setup, and deployment configuration"
                },
                "content": "# Sinatra Scaffold Command\n\nScaffolds a new Sinatra application with modern project structure, testing framework, and deployment configuration.\n\n## Arguments\n\n- **$1: project-name** (required) - Name of the project/application\n- **$2: type** (optional) - Application type: `classic`, `modular`, or `api` (default: `modular`)\n- **$3: options** (optional) - JSON string with configuration options:\n  - `testing`: `rspec` or `minitest` (default: `rspec`)\n  - `database`: `sequel`, `activerecord`, or `none` (default: `sequel`)\n  - `frontend`: `none`, `erb`, or `haml` (default: `erb`)\n\n## Usage Examples\n\n```bash\n# Basic modular app with defaults\n/sinatra-scaffold my-app\n\n# Classic app with RSpec and no database\n/sinatra-scaffold simple-app classic '{\"testing\":\"rspec\",\"database\":\"none\",\"frontend\":\"erb\"}'\n\n# API-only app with Minitest and ActiveRecord\n/sinatra-scaffold api-service api '{\"testing\":\"minitest\",\"database\":\"activerecord\",\"frontend\":\"none\"}'\n\n# Full-featured modular app\n/sinatra-scaffold webapp modular '{\"testing\":\"rspec\",\"database\":\"sequel\",\"frontend\":\"haml\"}'\n```\n\n## Workflow\n\n### Step 1: Validate and Initialize\n\n**Actions:**\n1. Validate project name format (alphanumeric, hyphens, underscores)\n2. Check if directory already exists\n3. Parse and validate options JSON\n4. Create project directory structure\n\n**Validation:**\n```bash\n# Check project name\nif [[ ! \"$PROJECT_NAME\" =~ ^[a-zA-Z0-9_-]+$ ]]; then\n  echo \"Error: Invalid project name. Use alphanumeric characters, hyphens, or underscores.\"\n  exit 1\nfi\n\n# Check if directory exists\nif [ -d \"$PROJECT_NAME\" ]; then\n  echo \"Error: Directory '$PROJECT_NAME' already exists.\"\n  exit 1\nfi\n```\n\n### Step 2: Create Directory Structure\n\n**Classic Structure:**\n```\nproject-name/\n├── app.rb\n├── config.ru\n├── Gemfile\n├── Rakefile\n├── config/\n│   └── environment.rb\n├── public/\n│   ├── css/\n│   ├── js/\n│   └── images/\n├── views/\n│   ├── layout.erb\n│   └── index.erb\n├── spec/ or test/\n└── README.md\n```\n\n**Modular Structure:**\n```\nproject-name/\n├── app/\n│   ├── controllers/\n│   │   ├── application_controller.rb\n│   │   └── base_controller.rb\n│   ├── models/\n│   ├── services/\n│   └── helpers/\n├── config/\n│   ├── environment.rb\n│   ├── database.yml (if database selected)\n│   └── puma.rb\n├── config.ru\n├── db/\n│   └── migrations/\n├── lib/\n│   └── tasks/\n├── public/\n│   ├── css/\n│   ├── js/\n│   └── images/\n├── views/\n│   ├── layout.erb\n│   └── index.erb\n├── spec/ or test/\n│   ├── spec_helper.rb\n│   └── controllers/\n├── Gemfile\n├── Rakefile\n├── .env.example\n├── .gitignore\n└── README.md\n```\n\n**API Structure:**\n```\nproject-name/\n├── app/\n│   ├── controllers/\n│   │   ├── api_controller.rb\n│   │   └── base_controller.rb\n│   ├── models/\n│   ├── services/\n│   └── serializers/\n├── config/\n│   ├── environment.rb\n│   ├── database.yml\n│   └── puma.rb\n├── config.ru\n├── db/\n│   └── migrations/\n├── lib/\n├── spec/ or test/\n│   ├── spec_helper.rb\n│   ├── requests/\n│   └── support/\n├── Gemfile\n├── Rakefile\n├── .env.example\n├── .gitignore\n└── README.md\n```\n\n### Step 3: Generate Gemfile\n\n**Base Dependencies (All Types):**\n```ruby\nsource 'https://rubygems.org'\n\nruby '~> 3.2'\n\ngem 'sinatra', '~> 3.0'\ngem 'sinatra-contrib', '~> 3.0'\ngem 'puma', '~> 6.0'\ngem 'rake', '~> 13.0'\ngem 'dotenv', '~> 2.8'\n\n# Add database gems if selected\n# gem 'sequel', '~> 5.0' or gem 'activerecord', '~> 7.0'\n# gem 'pg', '~> 1.5' # PostgreSQL\n\n# Add frontend gems if not API\n# gem 'haml', '~> 6.0' if haml selected\n\ngroup :development, :test do\n  gem 'rspec', '~> 3.12' # or minitest\n  gem 'rack-test', '~> 2.0'\n  gem 'rerun', '~> 0.14'\nend\n\ngroup :development do\n  gem 'pry', '~> 0.14'\nend\n\ngroup :test do\n  gem 'simplecov', '~> 0.22', require: false\n  gem 'database_cleaner-sequel', '~> 2.0' # if using Sequel\nend\n```\n\n**Additional Dependencies by Type:**\n\nFor modular/API:\n```ruby\ngem 'rack-cors', '~> 2.0'  # For API\ngem 'multi_json', '~> 1.15'\n```\n\nFor database options:\n```ruby\n# Sequel\ngem 'sequel', '~> 5.0'\ngem 'pg', '~> 1.5'\n\n# ActiveRecord\ngem 'activerecord', '~> 7.0'\ngem 'pg', '~> 1.5'\ngem 'sinatra-activerecord', '~> 2.0'\n```\n\n### Step 4: Generate Application Files\n\n**Classic App (app.rb):**\n```ruby\nrequire 'sinatra'\nrequire 'sinatra/reloader' if development?\nrequire_relative 'config/environment'\n\nget '/' do\n  erb :index\nend\n```\n\n**Modular Base Controller (app/controllers/base_controller.rb):**\n```ruby\nrequire 'sinatra/base'\nrequire 'sinatra/json'\n\nclass BaseController < Sinatra::Base\n  configure do\n    set :root, File.expand_path('../..', __dir__)\n    set :views, Proc.new { File.join(root, 'views') }\n    set :public_folder, Proc.new { File.join(root, 'public') }\n    set :show_exceptions, false\n    set :raise_errors, false\n  end\n\n  configure :development do\n    require 'sinatra/reloader'\n    register Sinatra::Reloader\n  end\n\n  helpers do\n    def json_response(data, status = 200)\n      halt status, { 'Content-Type' => 'application/json' }, data.to_json\n    end\n  end\n\n  error do\n    error = env['sinatra.error']\n    status 500\n    json_response({ error: error.message })\n  end\n\n  not_found do\n    json_response({ error: 'Not found' }, 404)\n  end\nend\n```\n\n**Application Controller (app/controllers/application_controller.rb):**\n```ruby\nrequire_relative 'base_controller'\n\nclass ApplicationController < BaseController\n  get '/' do\n    erb :index\n  end\n\n  get '/health' do\n    json_response({ status: 'ok', timestamp: Time.now.to_i })\n  end\nend\n```\n\n**API Controller (for API type):**\n```ruby\nrequire_relative 'base_controller'\n\nclass ApiController < BaseController\n  before do\n    content_type :json\n  end\n\n  # CORS for development\n  configure :development do\n    before do\n      headers 'Access-Control-Allow-Origin' => '*'\n    end\n\n    options '*' do\n      headers 'Access-Control-Allow-Methods' => 'GET, POST, PUT, PATCH, DELETE, OPTIONS'\n      headers 'Access-Control-Allow-Headers' => 'Content-Type, Authorization'\n      200\n    end\n  end\n\n  get '/' do\n    json_response({\n      name: 'API',\n      version: '1.0',\n      endpoints: [\n        { path: '/health', method: 'GET' }\n      ]\n    })\n  end\n\n  get '/health' do\n    json_response({ status: 'healthy', timestamp: Time.now.to_i })\n  end\nend\n```\n\n### Step 5: Create Configuration Files\n\n**config.ru:**\n```ruby\nrequire_relative 'config/environment'\n\n# Modular\nmap '/' do\n  run ApplicationController\nend\n\n# API\n# map '/api/v1' do\n#   run ApiController\n# end\n```\n\n**config/environment.rb:**\n```ruby\nENV['RACK_ENV'] ||= 'development'\n\nrequire 'bundler'\nBundler.require(:default, ENV['RACK_ENV'])\n\n# Load environment variables\nrequire 'dotenv'\nDotenv.load(\".env.#{ENV['RACK_ENV']}\", '.env')\n\n# Database setup (if selected)\n# require_relative 'database'\n\n# Load application files\nDir[File.join(__dir__, '../app/**/*.rb')].sort.each { |file| require file }\n```\n\n**config/database.yml (if database selected):**\n```yaml\ndefault: &default\n  adapter: postgresql\n  encoding: unicode\n  pool: <%= ENV.fetch(\"DB_POOL\", 5) %>\n  host: <%= ENV.fetch(\"DB_HOST\", \"localhost\") %>\n\ndevelopment:\n  <<: *default\n  database: <%= ENV.fetch(\"PROJECT_NAME\") %>_development\n\ntest:\n  <<: *default\n  database: <%= ENV.fetch(\"PROJECT_NAME\") %>_test\n\nproduction:\n  <<: *default\n  database: <%= ENV.fetch(\"DB_NAME\") %>\n  username: <%= ENV.fetch(\"DB_USER\") %>\n  password: <%= ENV.fetch(\"DB_PASSWORD\") %>\n```\n\n**config/puma.rb:**\n```ruby\nworkers ENV.fetch('WEB_CONCURRENCY', 2)\nthreads_count = ENV.fetch('MAX_THREADS', 5)\nthreads threads_count, threads_count\n\npreload_app!\n\nport ENV.fetch('PORT', 3000)\nenvironment ENV.fetch('RACK_ENV', 'development')\n\non_worker_boot do\n  # Database reconnection if using ActiveRecord\n  # ActiveRecord::Base.establish_connection if defined?(ActiveRecord)\nend\n```\n\n### Step 6: Set Up Testing Framework\n\n**RSpec spec/spec_helper.rb:**\n```ruby\nENV['RACK_ENV'] = 'test'\n\nrequire 'simplecov'\nSimpleCov.start\n\nrequire_relative '../config/environment'\nrequire 'rack/test'\nrequire 'rspec'\n\n# Database cleaner setup (if database)\n# require 'database_cleaner/sequel'\n\nRSpec.configure do |config|\n  config.include Rack::Test::Methods\n\n  config.expect_with :rspec do |expectations|\n    expectations.include_chain_clauses_in_custom_matcher_descriptions = true\n  end\n\n  config.mock_with :rspec do |mocks|\n    mocks.verify_partial_doubles = true\n  end\n\n  config.shared_context_metadata_behavior = :apply_to_host_groups\n\n  # Database cleaner (if database)\n  # config.before(:suite) do\n  #   DatabaseCleaner.strategy = :transaction\n  #   DatabaseCleaner.clean_with(:truncation)\n  # end\n  #\n  # config.around(:each) do |example|\n  #   DatabaseCleaner.cleaning do\n  #     example.run\n  #   end\n  # end\nend\n```\n\n**Example spec/controllers/application_controller_spec.rb:**\n```ruby\nrequire_relative '../spec_helper'\n\nRSpec.describe ApplicationController do\n  def app\n    ApplicationController\n  end\n\n  describe 'GET /' do\n    it 'returns success' do\n      get '/'\n      expect(last_response).to be_ok\n    end\n  end\n\n  describe 'GET /health' do\n    it 'returns health status' do\n      get '/health'\n      expect(last_response).to be_ok\n      json = JSON.parse(last_response.body)\n      expect(json['status']).to eq('ok')\n    end\n  end\nend\n```\n\n### Step 7: Create Supporting Files\n\n**.env.example:**\n```bash\nRACK_ENV=development\nPORT=3000\n\n# Database (if selected)\nDB_HOST=localhost\nDB_NAME=project_name_development\nDB_USER=postgres\nDB_PASSWORD=\n\n# Session\nSESSION_SECRET=your-secret-key-here\n\n# External services\n# API_KEY=\n```\n\n**.gitignore:**\n```\n*.gem\n*.rbc\n/.config\n/coverage/\n/InstalledFiles\n/pkg/\n/spec/reports/\n/spec/examples.txt\n/test/tmp/\n/test/version_tmp/\n/tmp/\n\n# Environment files\n.env\n.env.local\n\n# Database\n*.sqlite3\n*.db\n\n# Logs\n*.log\n\n# Editor files\n.vscode/\n.idea/\n*.swp\n*.swo\n*~\n\n# OS files\n.DS_Store\nThumbs.db\n```\n\n**Rakefile:**\n```ruby\nrequire_relative 'config/environment'\n\n# Database tasks (if using Sequel)\nif defined?(Sequel)\n  require 'sequel/core'\n  namespace :db do\n    desc 'Run migrations'\n    task :migrate, [:version] do |t, args|\n      Sequel.extension :migration\n      db = Sequel.connect(ENV['DATABASE_URL'])\n      if args[:version]\n        puts \"Migrating to version #{args[:version]}\"\n        Sequel::Migrator.run(db, 'db/migrations', target: args[:version].to_i)\n      else\n        puts 'Migrating to latest'\n        Sequel::Migrator.run(db, 'db/migrations')\n      end\n      puts 'Migration complete'\n    end\n  end\nend\n\n# Testing tasks\nrequire 'rspec/core/rake_task'\nRSpec::Core::RakeTask.new(:spec)\n\ntask default: :spec\n```\n\n**README.md:**\n```markdown\n# [Project Name]\n\n[Brief description of the project]\n\n## Setup\n\n1. Install dependencies:\n   ```bash\n   bundle install\n   ```\n\n2. Set up environment variables:\n   ```bash\n   cp .env.example .env\n   # Edit .env with your configuration\n   ```\n\n3. Set up database (if applicable):\n   ```bash\n   rake db:migrate\n   ```\n\n## Development\n\nRun the application:\n```bash\nbundle exec rerun 'rackup -p 3000'\n```\n\nOr with Puma:\n```bash\nbundle exec puma -C config/puma.rb\n```\n\n## Testing\n\nRun tests:\n```bash\nbundle exec rspec\n```\n\n## Deployment\n\n[Add deployment instructions]\n\n## API Documentation\n\n[Add API documentation if applicable]\n```\n\n### Step 8: Initialize Git Repository\n\n**Actions:**\n```bash\ncd project-name\ngit init\ngit add .\ngit commit -m \"Initial commit: Sinatra application scaffold\"\n```\n\n### Step 9: Install Dependencies\n\n**Actions:**\n```bash\nbundle install\n```\n\n**Verification:**\n- Confirm all gems installed successfully\n- Check for any dependency conflicts\n- Display next steps to user\n\n## Expected Output\n\n```\nCreating Sinatra application: my-app\nType: modular\nOptions: {\"testing\":\"rspec\",\"database\":\"sequel\",\"frontend\":\"erb\"}\n\n✓ Created directory structure\n✓ Generated Gemfile\n✓ Created application files\n✓ Set up configuration files\n✓ Configured RSpec testing\n✓ Created supporting files\n✓ Initialized git repository\n✓ Installed dependencies\n\nApplication created successfully!\n\nNext steps:\n  cd my-app\n  bundle exec rerun 'rackup -p 3000'\n\nVisit: http://localhost:3000\nTests: bundle exec rspec\n```\n\n## Error Handling\n\n- Invalid project name format\n- Directory already exists\n- Invalid JSON options\n- Bundle install failures\n- File creation permission errors\n\n## Notes\n\n- All generated code follows Ruby and Sinatra best practices\n- Testing framework is fully configured and ready to use\n- Development tools (rerun, pry) included for better DX\n- Production-ready configuration provided\n- Database migrations directory created if database selected\n- CORS configured for API applications"
              },
              {
                "name": "/sinatra-test",
                "description": "Generate comprehensive tests for Sinatra routes, middleware, and helpers using RSpec or Minitest",
                "path": "plugins/ruby-sinatra-advanced/commands/sinatra-test.md",
                "frontmatter": {
                  "description": "Generate comprehensive tests for Sinatra routes, middleware, and helpers using RSpec or Minitest"
                },
                "content": "# Sinatra Test Command\n\nGenerates comprehensive test suites for Sinatra applications including route tests, middleware tests, helper tests, and integration tests using RSpec or Minitest.\n\n## Arguments\n\n- **$1: test-type** (optional) - Type of tests to generate: `routes`, `middleware`, `helpers`, or `all` (default: `all`)\n- **$2: framework** (optional) - Testing framework: `rspec` or `minitest` (default: `rspec`)\n\n## Usage Examples\n\n```bash\n# Generate all tests using RSpec\n/sinatra-test\n\n# Generate only route tests with RSpec\n/sinatra-test routes\n\n# Generate all tests using Minitest\n/sinatra-test all minitest\n\n# Generate middleware tests with Minitest\n/sinatra-test middleware minitest\n\n# Generate helper tests with RSpec\n/sinatra-test helpers rspec\n```\n\n## Workflow\n\n### Step 1: Analyze Application Structure\n\n**Discovery Phase:**\n\n1. Identify application type (classic vs modular)\n2. Locate controller files\n3. Extract route definitions\n4. Find middleware stack\n5. Identify helper methods\n6. Check existing test structure\n7. Detect testing framework if already configured\n\n**Files to Analyze:**\n```ruby\n# Controllers\napp/controllers/**/*.rb\napp.rb (classic style)\n\n# Middleware\nconfig.ru\nconfig/**/*.rb\n\n# Helpers\napp/helpers/**/*.rb\nhelpers/ directory\n\n# Existing tests\nspec/**/*_spec.rb\ntest/**/*_test.rb\n```\n\n**Route Extraction:**\n```ruby\n# Parse routes from controller files\n# Identify: HTTP method, path, parameters, conditions\n\n# Example routes to extract:\nget '/users' do\n  # Handler\nend\n\nget '/users/:id', :id => /\\d+/ do\n  # Handler with constraint\nend\n\npost '/users', :provides => [:json] do\n  # Handler with content negotiation\nend\n```\n\n### Step 2: Generate Test Structure (RSpec)\n\n**Create spec_helper.rb if missing:**\n\n```ruby\n# spec/spec_helper.rb\nENV['RACK_ENV'] = 'test'\n\nrequire 'simplecov'\nSimpleCov.start do\n  add_filter '/spec/'\n  add_filter '/config/'\nend\n\nrequire_relative '../config/environment'\nrequire 'rack/test'\nrequire 'rspec'\nrequire 'json'\n\n# Database setup (if applicable)\nif defined?(Sequel)\n  require 'database_cleaner/sequel'\n\n  RSpec.configure do |config|\n    config.before(:suite) do\n      DatabaseCleaner.strategy = :transaction\n      DatabaseCleaner.clean_with(:truncation)\n    end\n\n    config.around(:each) do |example|\n      DatabaseCleaner.cleaning do\n        example.run\n      end\n    end\n  end\nend\n\nRSpec.configure do |config|\n  config.include Rack::Test::Methods\n\n  config.expect_with :rspec do |expectations|\n    expectations.include_chain_clauses_in_custom_matcher_descriptions = true\n  end\n\n  config.mock_with :rspec do |mocks|\n    mocks.verify_partial_doubles = true\n  end\n\n  config.shared_context_metadata_behavior = :apply_to_host_groups\n  config.filter_run_when_matching :focus\n  config.example_status_persistence_file_path = 'spec/examples.txt'\n  config.disable_monkey_patching!\n  config.warnings = true\n  config.order = :random\n  Kernel.srand config.seed\nend\n\n# Helper methods for all specs\nmodule SpecHelpers\n  def json_response\n    JSON.parse(last_response.body)\n  end\n\n  def auth_header(token)\n    { 'HTTP_AUTHORIZATION' => \"Bearer #{token}\" }\n  end\nend\n\nRSpec.configure do |config|\n  config.include SpecHelpers\nend\n```\n\n**Create support files:**\n\n```ruby\n# spec/support/factory_helper.rb (if using factories)\nrequire 'factory_bot'\n\nRSpec.configure do |config|\n  config.include FactoryBot::Syntax::Methods\nend\n\n# spec/support/shared_examples.rb\nRSpec.shared_examples 'authenticated endpoint' do\n  it 'returns 401 without authentication' do\n    send(http_method, path)\n    expect(last_response.status).to eq(401)\n  end\nend\n\nRSpec.shared_examples 'json endpoint' do\n  it 'returns JSON content type' do\n    send(http_method, path, valid_params)\n    expect(last_response.content_type).to include('application/json')\n  end\nend\n```\n\n### Step 3: Generate Route Tests\n\n**For each route, generate comprehensive tests:**\n\n```ruby\n# spec/controllers/users_controller_spec.rb\nrequire_relative '../spec_helper'\n\nRSpec.describe UsersController do\n  def app\n    UsersController\n  end\n\n  describe 'GET /users' do\n    context 'with no users' do\n      it 'returns empty array' do\n        get '/users'\n        expect(last_response).to be_ok\n        expect(json_response).to eq([])\n      end\n    end\n\n    context 'with existing users' do\n      let!(:users) { create_list(:user, 3) }\n\n      it 'returns all users' do\n        get '/users'\n        expect(last_response).to be_ok\n        expect(json_response.length).to eq(3)\n      end\n\n      it 'includes user attributes' do\n        get '/users'\n        user_data = json_response.first\n        expect(user_data).to have_key('id')\n        expect(user_data).to have_key('name')\n        expect(user_data).to have_key('email')\n      end\n    end\n\n    context 'with pagination' do\n      let!(:users) { create_list(:user, 25) }\n\n      it 'respects page parameter' do\n        get '/users?page=2&per_page=10'\n        expect(json_response.length).to eq(10)\n      end\n\n      it 'includes pagination metadata' do\n        get '/users?page=1&per_page=10'\n        expect(json_response['meta']).to include(\n          'total' => 25,\n          'page' => 1,\n          'per_page' => 10\n        )\n      end\n    end\n\n    context 'with filtering' do\n      let!(:active_user) { create(:user, active: true) }\n      let!(:inactive_user) { create(:user, active: false) }\n\n      it 'filters by active status' do\n        get '/users?active=true'\n        expect(json_response.length).to eq(1)\n        expect(json_response.first['id']).to eq(active_user.id)\n      end\n    end\n  end\n\n  describe 'GET /users/:id' do\n    let(:user) { create(:user) }\n\n    context 'when user exists' do\n      it 'returns user details' do\n        get \"/users/#{user.id}\"\n        expect(last_response).to be_ok\n        expect(json_response['id']).to eq(user.id)\n      end\n\n      it 'includes all user attributes' do\n        get \"/users/#{user.id}\"\n        expect(json_response).to include(\n          'id' => user.id,\n          'name' => user.name,\n          'email' => user.email\n        )\n      end\n    end\n\n    context 'when user does not exist' do\n      it 'returns 404' do\n        get '/users/99999'\n        expect(last_response.status).to eq(404)\n      end\n\n      it 'returns error message' do\n        get '/users/99999'\n        expect(json_response).to include('error')\n      end\n    end\n\n    context 'with invalid id format' do\n      it 'returns 404' do\n        get '/users/invalid'\n        expect(last_response.status).to eq(404)\n      end\n    end\n  end\n\n  describe 'POST /users' do\n    let(:valid_attributes) do\n      {\n        name: 'John Doe',\n        email: 'john@example.com',\n        password: 'SecurePass123'\n      }\n    end\n\n    context 'with valid attributes' do\n      it 'creates a new user' do\n        expect {\n          post '/users', valid_attributes.to_json,\n            'CONTENT_TYPE' => 'application/json'\n        }.to change(User, :count).by(1)\n      end\n\n      it 'returns 201 status' do\n        post '/users', valid_attributes.to_json,\n          'CONTENT_TYPE' => 'application/json'\n        expect(last_response.status).to eq(201)\n      end\n\n      it 'returns created user' do\n        post '/users', valid_attributes.to_json,\n          'CONTENT_TYPE' => 'application/json'\n        expect(json_response).to include(\n          'name' => 'John Doe',\n          'email' => 'john@example.com'\n        )\n      end\n\n      it 'does not return password' do\n        post '/users', valid_attributes.to_json,\n          'CONTENT_TYPE' => 'application/json'\n        expect(json_response).not_to have_key('password')\n      end\n    end\n\n    context 'with invalid attributes' do\n      it 'returns 422 status' do\n        post '/users', { name: '' }.to_json,\n          'CONTENT_TYPE' => 'application/json'\n        expect(last_response.status).to eq(422)\n      end\n\n      it 'returns validation errors' do\n        post '/users', { name: '' }.to_json,\n          'CONTENT_TYPE' => 'application/json'\n        expect(json_response).to have_key('errors')\n      end\n\n      it 'does not create user' do\n        expect {\n          post '/users', { name: '' }.to_json,\n            'CONTENT_TYPE' => 'application/json'\n        }.not_to change(User, :count)\n      end\n    end\n\n    context 'with duplicate email' do\n      let!(:existing_user) { create(:user, email: 'john@example.com') }\n\n      it 'returns 422 status' do\n        post '/users', valid_attributes.to_json,\n          'CONTENT_TYPE' => 'application/json'\n        expect(last_response.status).to eq(422)\n      end\n\n      it 'returns uniqueness error' do\n        post '/users', valid_attributes.to_json,\n          'CONTENT_TYPE' => 'application/json'\n        expect(json_response['errors']).to include('email')\n      end\n    end\n  end\n\n  describe 'PUT /users/:id' do\n    let(:user) { create(:user) }\n    let(:update_attributes) { { name: 'Updated Name' } }\n\n    context 'when user exists' do\n      it 'updates user attributes' do\n        put \"/users/#{user.id}\", update_attributes.to_json,\n          'CONTENT_TYPE' => 'application/json'\n        user.reload\n        expect(user.name).to eq('Updated Name')\n      end\n\n      it 'returns 200 status' do\n        put \"/users/#{user.id}\", update_attributes.to_json,\n          'CONTENT_TYPE' => 'application/json'\n        expect(last_response).to be_ok\n      end\n\n      it 'returns updated user' do\n        put \"/users/#{user.id}\", update_attributes.to_json,\n          'CONTENT_TYPE' => 'application/json'\n        expect(json_response['name']).to eq('Updated Name')\n      end\n    end\n\n    context 'with invalid attributes' do\n      it 'returns 422 status' do\n        put \"/users/#{user.id}\", { email: 'invalid' }.to_json,\n          'CONTENT_TYPE' => 'application/json'\n        expect(last_response.status).to eq(422)\n      end\n\n      it 'does not update user' do\n        original_email = user.email\n        put \"/users/#{user.id}\", { email: 'invalid' }.to_json,\n          'CONTENT_TYPE' => 'application/json'\n        user.reload\n        expect(user.email).to eq(original_email)\n      end\n    end\n\n    context 'when user does not exist' do\n      it 'returns 404' do\n        put '/users/99999', update_attributes.to_json,\n          'CONTENT_TYPE' => 'application/json'\n        expect(last_response.status).to eq(404)\n      end\n    end\n  end\n\n  describe 'DELETE /users/:id' do\n    let!(:user) { create(:user) }\n\n    context 'when user exists' do\n      it 'deletes the user' do\n        expect {\n          delete \"/users/#{user.id}\"\n        }.to change(User, :count).by(-1)\n      end\n\n      it 'returns 204 status' do\n        delete \"/users/#{user.id}\"\n        expect(last_response.status).to eq(204)\n      end\n\n      it 'returns empty body' do\n        delete \"/users/#{user.id}\"\n        expect(last_response.body).to be_empty\n      end\n    end\n\n    context 'when user does not exist' do\n      it 'returns 404' do\n        delete '/users/99999'\n        expect(last_response.status).to eq(404)\n      end\n    end\n  end\n\n  # Authentication tests\n  describe 'authentication' do\n    let(:protected_path) { '/users' }\n    let(:http_method) { :get }\n    let(:path) { protected_path }\n\n    it_behaves_like 'authenticated endpoint'\n  end\n\n  # Content negotiation tests\n  describe 'content negotiation' do\n    let(:user) { create(:user) }\n\n    context 'with Accept: application/json' do\n      it 'returns JSON' do\n        get \"/users/#{user.id}\", {}, { 'HTTP_ACCEPT' => 'application/json' }\n        expect(last_response.content_type).to include('application/json')\n      end\n    end\n\n    context 'with Accept: application/xml' do\n      it 'returns XML' do\n        get \"/users/#{user.id}\", {}, { 'HTTP_ACCEPT' => 'application/xml' }\n        expect(last_response.content_type).to include('application/xml')\n      end\n    end\n  end\nend\n```\n\n### Step 4: Generate Middleware Tests\n\n```ruby\n# spec/middleware/custom_middleware_spec.rb\nrequire_relative '../spec_helper'\n\nRSpec.describe CustomMiddleware do\n  let(:app) { ->(env) { [200, {}, ['OK']] } }\n  let(:middleware) { CustomMiddleware.new(app) }\n  let(:request) { Rack::MockRequest.new(middleware) }\n\n  describe 'request processing' do\n    it 'passes request to next middleware' do\n      response = request.get('/')\n      expect(response.status).to eq(200)\n    end\n\n    it 'adds custom header to response' do\n      response = request.get('/')\n      expect(response.headers['X-Custom-Header']).to eq('value')\n    end\n\n    it 'modifies request environment' do\n      env = {}\n      middleware.call(env)\n      expect(env['custom.key']).to be_present\n    end\n  end\n\n  describe 'error handling' do\n    let(:app) { ->(env) { raise StandardError, 'Error' } }\n\n    it 'catches errors from downstream' do\n      response = request.get('/')\n      expect(response.status).to eq(500)\n    end\n\n    it 'logs error' do\n      expect { request.get('/') }.to change { error_log.size }.by(1)\n    end\n  end\n\n  describe 'configuration' do\n    let(:middleware) { CustomMiddleware.new(app, option: 'value') }\n\n    it 'accepts configuration options' do\n      expect(middleware.options[:option]).to eq('value')\n    end\n\n    it 'applies configuration to behavior' do\n      response = request.get('/')\n      expect(response.headers['X-Option']).to eq('value')\n    end\n  end\nend\n```\n\n### Step 5: Generate Helper Tests\n\n```ruby\n# spec/helpers/application_helpers_spec.rb\nrequire_relative '../spec_helper'\n\nRSpec.describe ApplicationHelpers do\n  let(:dummy_class) do\n    Class.new do\n      include ApplicationHelpers\n\n      # Mock request/session for helper context\n      def request\n        @request ||= Struct.new(:path_info).new('/test')\n      end\n\n      def session\n        @session ||= {}\n      end\n    end\n  end\n\n  let(:helpers) { dummy_class.new }\n\n  describe '#current_user' do\n    context 'when user is logged in' do\n      before do\n        helpers.session[:user_id] = 1\n        allow(User).to receive(:find).with(1).and_return(\n          double('User', id: 1, name: 'John')\n        )\n      end\n\n      it 'returns current user' do\n        expect(helpers.current_user).to be_present\n        expect(helpers.current_user.id).to eq(1)\n      end\n\n      it 'memoizes user' do\n        expect(User).to receive(:find).once\n        helpers.current_user\n        helpers.current_user\n      end\n    end\n\n    context 'when user is not logged in' do\n      it 'returns nil' do\n        expect(helpers.current_user).to be_nil\n      end\n    end\n  end\n\n  describe '#logged_in?' do\n    it 'returns true when current_user exists' do\n      allow(helpers).to receive(:current_user).and_return(double('User'))\n      expect(helpers.logged_in?).to be true\n    end\n\n    it 'returns false when current_user is nil' do\n      allow(helpers).to receive(:current_user).and_return(nil)\n      expect(helpers.logged_in?).to be false\n    end\n  end\n\n  describe '#format_date' do\n    let(:date) { Time.new(2024, 1, 15, 10, 30, 0) }\n\n    it 'formats date with default format' do\n      expect(helpers.format_date(date)).to eq('2024-01-15')\n    end\n\n    it 'accepts custom format' do\n      expect(helpers.format_date(date, '%m/%d/%Y')).to eq('01/15/2024')\n    end\n\n    it 'handles nil date' do\n      expect(helpers.format_date(nil)).to eq('')\n    end\n  end\n\n  describe '#truncate' do\n    let(:long_text) { 'This is a very long text that should be truncated' }\n\n    it 'truncates text to specified length' do\n      expect(helpers.truncate(long_text, 20)).to eq('This is a very long...')\n    end\n\n    it 'does not truncate short text' do\n      short_text = 'Short'\n      expect(helpers.truncate(short_text, 20)).to eq('Short')\n    end\n\n    it 'accepts custom omission' do\n      expect(helpers.truncate(long_text, 20, omission: '…')).to include('…')\n    end\n  end\nend\n```\n\n### Step 6: Generate Minitest Tests (Alternative)\n\n**If framework is Minitest:**\n\n```ruby\n# test/test_helper.rb\nENV['RACK_ENV'] = 'test'\n\nrequire 'simplecov'\nSimpleCov.start\n\nrequire_relative '../config/environment'\nrequire 'minitest/autorun'\nrequire 'minitest/spec'\nrequire 'rack/test'\n\nclass Minitest::Spec\n  include Rack::Test::Methods\n\n  def json_response\n    JSON.parse(last_response.body)\n  end\nend\n\n# test/controllers/users_controller_test.rb\nrequire_relative '../test_helper'\n\ndescribe UsersController do\n  def app\n    UsersController\n  end\n\n  describe 'GET /users' do\n    it 'returns success' do\n      get '/users'\n      assert last_response.ok?\n    end\n\n    it 'returns JSON' do\n      get '/users'\n      assert_includes last_response.content_type, 'application/json'\n    end\n\n    describe 'with existing users' do\n      before do\n        @users = 3.times.map { User.create(name: 'Test') }\n      end\n\n      it 'returns all users' do\n        get '/users'\n        assert_equal 3, json_response.length\n      end\n    end\n  end\n\n  describe 'POST /users' do\n    let(:valid_params) { { name: 'John', email: 'john@example.com' } }\n\n    it 'creates user' do\n      assert_difference 'User.count', 1 do\n        post '/users', valid_params.to_json,\n          'CONTENT_TYPE' => 'application/json'\n      end\n    end\n\n    it 'returns 201' do\n      post '/users', valid_params.to_json,\n        'CONTENT_TYPE' => 'application/json'\n      assert_equal 201, last_response.status\n    end\n  end\nend\n```\n\n### Step 7: Generate Integration Tests\n\n```ruby\n# spec/integration/user_registration_spec.rb\nrequire_relative '../spec_helper'\n\nRSpec.describe 'User Registration Flow' do\n  def app\n    Sinatra::Application\n  end\n\n  describe 'complete registration process' do\n    let(:user_params) do\n      {\n        name: 'John Doe',\n        email: 'john@example.com',\n        password: 'SecurePass123'\n      }\n    end\n\n    it 'allows new user to register and log in' do\n      # Step 1: Register\n      post '/register', user_params.to_json,\n        'CONTENT_TYPE' => 'application/json'\n      expect(last_response.status).to eq(201)\n\n      user_id = json_response['id']\n\n      # Step 2: Verify email confirmation sent\n      expect(EmailService.last_email[:to]).to eq('john@example.com')\n\n      # Step 3: Confirm email\n      token = EmailService.last_email[:token]\n      get \"/confirm/#{token}\"\n      expect(last_response.status).to eq(200)\n\n      # Step 4: Log in\n      post '/login', { email: 'john@example.com', password: 'SecurePass123' }.to_json,\n        'CONTENT_TYPE' => 'application/json'\n      expect(last_response.status).to eq(200)\n      expect(json_response).to have_key('token')\n\n      # Step 5: Access protected resource\n      token = json_response['token']\n      get '/profile', {}, auth_header(token)\n      expect(last_response).to be_ok\n      expect(json_response['id']).to eq(user_id)\n    end\n  end\nend\n```\n\n### Step 8: Create Test Documentation\n\n**Generate test README:**\n\n```markdown\n# Test Suite Documentation\n\n## Running Tests\n\n### All Tests\n```bash\nbundle exec rspec\n```\n\n### Specific Test File\n```bash\nbundle exec rspec spec/controllers/users_controller_spec.rb\n```\n\n### By Tag\n```bash\nbundle exec rspec --tag focus\n```\n\n## Test Structure\n\n- `spec/controllers/` - Route and controller tests\n- `spec/middleware/` - Middleware tests\n- `spec/helpers/` - Helper method tests\n- `spec/models/` - Model tests (if applicable)\n- `spec/integration/` - End-to-end integration tests\n- `spec/support/` - Shared examples and helpers\n\n## Coverage\n\nRun tests with coverage report:\n```bash\nCOVERAGE=true bundle exec rspec\n```\n\nView coverage report:\n```bash\nopen coverage/index.html\n```\n\n## Testing Patterns\n\n### Route Testing\n- Test successful responses\n- Test error cases (404, 422, 500)\n- Test authentication/authorization\n- Test parameter validation\n- Test content negotiation\n\n### Helper Testing\n- Test with various inputs\n- Test edge cases\n- Test nil handling\n- Mock dependencies\n\n### Integration Testing\n- Test complete user flows\n- Test interactions between components\n- Test external service integration\n```\n\n## Output\n\n**Generated files report:**\n```\nTest Generation Complete!\n\nFramework: RSpec\nTest Type: all\n\nGenerated Files:\n  ✓ spec/spec_helper.rb\n  ✓ spec/support/factory_helper.rb\n  ✓ spec/support/shared_examples.rb\n  ✓ spec/controllers/users_controller_spec.rb (45 examples)\n  ✓ spec/controllers/posts_controller_spec.rb (38 examples)\n  ✓ spec/middleware/custom_middleware_spec.rb (12 examples)\n  ✓ spec/helpers/application_helpers_spec.rb (15 examples)\n  ✓ spec/integration/user_registration_spec.rb (5 examples)\n  ✓ TEST_README.md\n\nTotal Examples: 115\nCoverage Target: 90%\n\nRun tests: bundle exec rspec\n```\n\n## Error Handling\n\n- Handle applications without routes gracefully\n- Skip already existing test files (or offer to overwrite)\n- Detect testing framework from Gemfile\n- Warn if test dependencies missing\n- Handle parse errors in application files"
              }
            ],
            "skills": [
              {
                "name": "rack-middleware",
                "description": "Rack middleware development, configuration, and integration patterns. Use when working with middleware stacks or creating custom middleware.",
                "path": "plugins/ruby-sinatra-advanced/skills/rack-middleware/SKILL.md",
                "frontmatter": {
                  "name": "rack-middleware",
                  "description": "Rack middleware development, configuration, and integration patterns. Use when working with middleware stacks or creating custom middleware."
                },
                "content": "# Rack Middleware Skill\n\n## Tier 1: Quick Reference - Middleware Basics\n\n### Middleware Structure\n\n```ruby\nclass MyMiddleware\n  def initialize(app, options = {})\n    @app = app\n    @options = options\n  end\n\n  def call(env)\n    # Before request\n    # Modify env if needed\n\n    # Call next middleware\n    status, headers, body = @app.call(env)\n\n    # After request\n    # Modify response if needed\n\n    [status, headers, body]\n  end\nend\n\n# Usage\nuse MyMiddleware, option: 'value'\n```\n\n### Common Middleware\n\n```ruby\n# Session management\nuse Rack::Session::Cookie, secret: ENV['SESSION_SECRET']\n\n# Security\nuse Rack::Protection\n\n# Compression\nuse Rack::Deflater\n\n# Logging\nuse Rack::CommonLogger\n\n# Static files\nuse Rack::Static, urls: ['/css', '/js'], root: 'public'\n```\n\n### Middleware Ordering\n\n```ruby\n# config.ru - Correct order\nuse Rack::Deflater           # 1. Compression\nuse Rack::Static             # 2. Static files\nuse Rack::CommonLogger       # 3. Logging\nuse Rack::Session::Cookie    # 4. Sessions\nuse Rack::Protection          # 5. Security\nuse CustomAuth               # 6. Authentication\nrun Application              # 7. Application\n```\n\n### Request/Response Access\n\n```ruby\nclass SimpleMiddleware\n  def initialize(app)\n    @app = app\n  end\n\n  def call(env)\n    # Access request via env hash\n    method = env['REQUEST_METHOD']\n    path = env['PATH_INFO']\n    query = env['QUERY_STRING']\n\n    # Or use Rack::Request\n    request = Rack::Request.new(env)\n    params = request.params\n\n    # Process request\n    status, headers, body = @app.call(env)\n\n    # Modify response\n    headers['X-Custom-Header'] = 'value'\n\n    [status, headers, body]\n  end\nend\n```\n\n---\n\n## Tier 2: Detailed Instructions - Advanced Middleware\n\n### Custom Middleware Development\n\n**Request Logging Middleware:**\n```ruby\nrequire 'logger'\n\nclass RequestLogger\n  def initialize(app, options = {})\n    @app = app\n    @logger = options[:logger] || Logger.new(STDOUT)\n    @skip_paths = options[:skip_paths] || []\n  end\n\n  def call(env)\n    return @app.call(env) if skip_logging?(env)\n\n    start_time = Time.now\n    request = Rack::Request.new(env)\n\n    log_request_start(request)\n\n    status, headers, body = @app.call(env)\n\n    duration = Time.now - start_time\n    log_request_end(request, status, duration)\n\n    [status, headers, body]\n  rescue StandardError => e\n    log_error(request, e)\n    raise\n  end\n\n  private\n\n  def skip_logging?(env)\n    path = env['PATH_INFO']\n    @skip_paths.any? { |skip| path.start_with?(skip) }\n  end\n\n  def log_request_start(request)\n    @logger.info({\n      event: 'request.start',\n      method: request.request_method,\n      path: request.path,\n      ip: request.ip,\n      user_agent: request.user_agent\n    }.to_json)\n  end\n\n  def log_request_end(request, status, duration)\n    @logger.info({\n      event: 'request.end',\n      method: request.request_method,\n      path: request.path,\n      status: status,\n      duration: duration.round(3)\n    }.to_json)\n  end\n\n  def log_error(request, error)\n    @logger.error({\n      event: 'request.error',\n      method: request.request_method,\n      path: request.path,\n      error: error.class.name,\n      message: error.message,\n      backtrace: error.backtrace[0..5]\n    }.to_json)\n  end\nend\n\n# Usage\nuse RequestLogger, skip_paths: ['/health', '/metrics']\n```\n\n**Authentication Middleware:**\n```ruby\nclass TokenAuthentication\n  def initialize(app, options = {})\n    @app = app\n    @token_header = options[:header] || 'HTTP_AUTHORIZATION'\n    @skip_paths = options[:skip_paths] || []\n    @realm = options[:realm] || 'Application'\n  end\n\n  def call(env)\n    return @app.call(env) if skip_authentication?(env)\n\n    token = extract_token(env)\n\n    if valid_token?(token)\n      user = find_user_by_token(token)\n      env['current_user'] = user\n      @app.call(env)\n    else\n      unauthorized_response\n    end\n  end\n\n  private\n\n  def skip_authentication?(env)\n    path = env['PATH_INFO']\n    method = env['REQUEST_METHOD']\n\n    # Skip for public paths\n    @skip_paths.any? { |skip| path.start_with?(skip) } ||\n      # Skip for OPTIONS (CORS preflight)\n      method == 'OPTIONS'\n  end\n\n  def extract_token(env)\n    auth_header = env[@token_header]\n    return nil unless auth_header\n\n    # Support \"Bearer TOKEN\" format\n    if auth_header.start_with?('Bearer ')\n      auth_header.split(' ', 2).last\n    else\n      auth_header\n    end\n  end\n\n  def valid_token?(token)\n    return false unless token\n\n    # Implement your token validation logic\n    # This is a placeholder\n    token.length >= 32\n  end\n\n  def find_user_by_token(token)\n    # Implement your user lookup logic\n    # This is a placeholder\n    { id: 1, email: 'user@example.com' }\n  end\n\n  def unauthorized_response\n    [\n      401,\n      {\n        'Content-Type' => 'application/json',\n        'WWW-Authenticate' => \"Bearer realm=\\\"#{@realm}\\\"\"\n      },\n      ['{\"error\": \"Unauthorized\"}']\n    ]\n  end\nend\n\n# Usage\nuse TokenAuthentication,\n  skip_paths: ['/login', '/register', '/public']\n```\n\n**Caching Middleware:**\n```ruby\nrequire 'digest/md5'\n\nclass SimpleCache\n  def initialize(app, options = {})\n    @app = app\n    @cache = {}\n    @ttl = options[:ttl] || 300  # 5 minutes\n    @cache_methods = options[:methods] || ['GET']\n  end\n\n  def call(env)\n    request = Rack::Request.new(env)\n\n    return @app.call(env) unless cacheable?(request)\n\n    cache_key = generate_cache_key(env)\n\n    if cached_response = get_from_cache(cache_key)\n      return cached_response\n    end\n\n    status, headers, body = @app.call(env)\n\n    if cacheable_response?(status)\n      cache_response(cache_key, [status, headers, body])\n    end\n\n    [status, headers, body]\n  end\n\n  private\n\n  def cacheable?(request)\n    @cache_methods.include?(request.request_method)\n  end\n\n  def cacheable_response?(status)\n    status == 200\n  end\n\n  def generate_cache_key(env)\n    # Include method, path, and query string\n    Digest::MD5.hexdigest([\n      env['REQUEST_METHOD'],\n      env['PATH_INFO'],\n      env['QUERY_STRING']\n    ].join('|'))\n  end\n\n  def get_from_cache(key)\n    entry = @cache[key]\n    return nil unless entry\n\n    # Check if cache entry is still valid\n    if Time.now - entry[:cached_at] <= @ttl\n      entry[:response]\n    else\n      @cache.delete(key)\n      nil\n    end\n  end\n\n  def cache_response(key, response)\n    @cache[key] = {\n      response: response,\n      cached_at: Time.now\n    }\n  end\nend\n\n# Usage with Redis for distributed caching\nclass RedisCache\n  def initialize(app, options = {})\n    @app = app\n    @redis = Redis.new(url: options[:redis_url])\n    @ttl = options[:ttl] || 300\n    @namespace = options[:namespace] || 'cache'\n  end\n\n  def call(env)\n    request = Rack::Request.new(env)\n\n    return @app.call(env) unless request.get?\n\n    cache_key = generate_cache_key(env)\n\n    if cached = @redis.get(cache_key)\n      return Marshal.load(cached)\n    end\n\n    status, headers, body = @app.call(env)\n\n    if status == 200\n      @redis.setex(cache_key, @ttl, Marshal.dump([status, headers, body]))\n    end\n\n    [status, headers, body]\n  end\n\n  private\n\n  def generate_cache_key(env)\n    \"#{@namespace}:#{Digest::MD5.hexdigest(env['PATH_INFO'] + env['QUERY_STRING'])}\"\n  end\nend\n```\n\n**Request Transformation Middleware:**\n```ruby\nclass JSONBodyParser\n  def initialize(app)\n    @app = app\n  end\n\n  def call(env)\n    if json_request?(env)\n      body = env['rack.input'].read\n      env['rack.input'].rewind\n\n      begin\n        parsed = JSON.parse(body)\n        env['rack.request.form_hash'] = parsed\n        env['parsed_json'] = parsed\n      rescue JSON::ParserError => e\n        return error_response('Invalid JSON', 400)\n      end\n    end\n\n    @app.call(env)\n  end\n\n  private\n\n  def json_request?(env)\n    content_type = env['CONTENT_TYPE']\n    content_type && content_type.include?('application/json')\n  end\n\n  def error_response(message, status)\n    [\n      status,\n      { 'Content-Type' => 'application/json' },\n      [{ error: message }.to_json]\n    ]\n  end\nend\n\n# XML Parser\nclass XMLBodyParser\n  def initialize(app)\n    @app = app\n  end\n\n  def call(env)\n    if xml_request?(env)\n      body = env['rack.input'].read\n      env['rack.input'].rewind\n\n      begin\n        parsed = Hash.from_xml(body)\n        env['rack.request.form_hash'] = parsed\n        env['parsed_xml'] = parsed\n      rescue StandardError => e\n        return error_response('Invalid XML', 400)\n      end\n    end\n\n    @app.call(env)\n  end\n\n  private\n\n  def xml_request?(env)\n    content_type = env['CONTENT_TYPE']\n    content_type && (content_type.include?('application/xml') ||\n                     content_type.include?('text/xml'))\n  end\n\n  def error_response(message, status)\n    [\n      status,\n      { 'Content-Type' => 'application/json' },\n      [{ error: message }.to_json]\n    ]\n  end\nend\n```\n\n### Middleware Ordering Patterns\n\n**Security-First Stack:**\n```ruby\n# config.ru\n# 1. SSL redirect (production only)\nuse Rack::SSL if ENV['RACK_ENV'] == 'production'\n\n# 2. Rate limiting (before everything else)\nuse Rack::Attack\n\n# 3. Security headers\nuse SecurityHeaders\n\n# 4. CORS (for API applications)\nuse Rack::Cors do\n  allow do\n    origins '*'\n    resource '*', headers: :any, methods: [:get, :post, :put, :delete, :options]\n  end\nend\n\n# 5. Compression\nuse Rack::Deflater\n\n# 6. Static files\nuse Rack::Static, urls: ['/public'], root: 'public'\n\n# 7. Logging\nuse Rack::CommonLogger\n\n# 8. Request parsing\nuse JSONBodyParser\n\n# 9. Sessions\nuse Rack::Session::Cookie,\n  secret: ENV['SESSION_SECRET'],\n  same_site: :strict,\n  httponly: true,\n  secure: ENV['RACK_ENV'] == 'production'\n\n# 10. Protection (CSRF, etc.)\nuse Rack::Protection\n\n# 11. Authentication\nuse TokenAuthentication, skip_paths: ['/login', '/public']\n\n# 12. Performance monitoring\nuse PerformanceMonitor\n\n# 13. Application\nrun Application\n```\n\n**API-Focused Stack:**\n```ruby\n# config.ru for API\n# 1. CORS first for preflight\nuse Rack::Cors do\n  allow do\n    origins ENV.fetch('ALLOWED_ORIGINS', '*').split(',')\n    resource '*',\n      headers: :any,\n      methods: [:get, :post, :put, :patch, :delete, :options],\n      credentials: true,\n      max_age: 86400\n  end\nend\n\n# 2. Rate limiting\nuse Rack::Attack\n\n# 3. Compression\nuse Rack::Deflater\n\n# 4. Logging (structured JSON logs)\nuse RequestLogger\n\n# 5. Request parsing\nuse JSONBodyParser\n\n# 6. Authentication\nuse TokenAuthentication, skip_paths: ['/auth']\n\n# 7. Caching\nuse RedisCache, ttl: 300\n\n# 8. Application\nrun API\n```\n\n### Conditional Middleware\n\n**Environment-Based:**\n```ruby\nclass ConditionalMiddleware\n  def initialize(app, condition, middleware, *args)\n    @app = if condition.call\n      middleware.new(app, *args)\n    else\n      app\n    end\n  end\n\n  def call(env)\n    @app.call(env)\n  end\nend\n\n# Usage\nuse ConditionalMiddleware,\n  -> { ENV['RACK_ENV'] == 'development' },\n  Rack::ShowExceptions\n\nuse ConditionalMiddleware,\n  -> { ENV['ENABLE_PROFILING'] == 'true' },\n  RackMiniProfiler\n```\n\n**Path-Based:**\n```ruby\nclass PathBasedMiddleware\n  def initialize(app, pattern, middleware, *args)\n    @app = app\n    @pattern = pattern\n    @middleware = middleware.new(app, *args)\n  end\n\n  def call(env)\n    if env['PATH_INFO'].match?(@pattern)\n      @middleware.call(env)\n    else\n      @app.call(env)\n    end\n  end\nend\n\n# Usage\nuse PathBasedMiddleware, %r{^/api}, CacheMiddleware, ttl: 300\nuse PathBasedMiddleware, %r{^/admin}, AdminAuth\n```\n\n### Error Handling Middleware\n\n```ruby\nclass ErrorHandler\n  def initialize(app, options = {})\n    @app = app\n    @logger = options[:logger] || Logger.new(STDOUT)\n    @error_handlers = options[:handlers] || {}\n  end\n\n  def call(env)\n    @app.call(env)\n  rescue StandardError => e\n    handle_error(env, e)\n  end\n\n  private\n\n  def handle_error(env, error)\n    request = Rack::Request.new(env)\n\n    # Log error\n    @logger.error({\n      error: error.class.name,\n      message: error.message,\n      path: request.path,\n      method: request.request_method,\n      backtrace: error.backtrace[0..10]\n    }.to_json)\n\n    # Custom handler for specific error types\n    if handler = @error_handlers[error.class]\n      return handler.call(error)\n    end\n\n    # Default error response\n    status = status_for_error(error)\n    [\n      status,\n      { 'Content-Type' => 'application/json' },\n      [{ error: error.message, type: error.class.name }.to_json]\n    ]\n  end\n\n  def status_for_error(error)\n    case error\n    when ArgumentError, ValidationError\n      400\n    when NotFoundError\n      404\n    when AuthorizationError\n      403\n    when AuthenticationError\n      401\n    else\n      500\n    end\n  end\nend\n\n# Usage\nuse ErrorHandler,\n  handlers: {\n    ValidationError => ->(e) {\n      [422, { 'Content-Type' => 'application/json' },\n       [{ error: e.message, details: e.details }.to_json]]\n    }\n  }\n```\n\n---\n\n## Tier 3: Resources & Examples\n\n### Complete Middleware Examples\n\n**Performance Monitoring:**\n```ruby\nclass PerformanceMonitor\n  def initialize(app, options = {})\n    @app = app\n    @threshold = options[:threshold] || 1.0  # 1 second\n    @logger = options[:logger] || Logger.new(STDOUT)\n  end\n\n  def call(env)\n    start_time = Time.now\n    memory_before = memory_usage\n\n    status, headers, body = @app.call(env)\n\n    duration = Time.now - start_time\n    memory_after = memory_usage\n    memory_delta = memory_after - memory_before\n\n    # Add performance headers\n    headers['X-Runtime'] = duration.to_s\n    headers['X-Memory-Delta'] = memory_delta.to_s\n\n    # Log slow requests\n    if duration > @threshold\n      log_slow_request(env, duration, memory_delta)\n    end\n\n    [status, headers, body]\n  end\n\n  private\n\n  def memory_usage\n    `ps -o rss= -p #{Process.pid}`.to_i / 1024.0  # MB\n  end\n\n  def log_slow_request(env, duration, memory)\n    @logger.warn({\n      event: 'slow_request',\n      method: env['REQUEST_METHOD'],\n      path: env['PATH_INFO'],\n      duration: duration.round(3),\n      memory_delta: memory.round(2)\n    }.to_json)\n  end\nend\n```\n\n**Request ID Tracking:**\n```ruby\nclass RequestID\n  def initialize(app, options = {})\n    @app = app\n    @header = options[:header] || 'X-Request-ID'\n  end\n\n  def call(env)\n    request_id = env[\"HTTP_#{@header.upcase.tr('-', '_')}\"] || generate_id\n    env['request.id'] = request_id\n\n    status, headers, body = @app.call(env)\n\n    headers[@header] = request_id\n\n    [status, headers, body]\n  end\n\n  private\n\n  def generate_id\n    SecureRandom.uuid\n  end\nend\n```\n\n**Response Modification:**\n```ruby\nclass ResponseTransformer\n  def initialize(app, &block)\n    @app = app\n    @transformer = block\n  end\n\n  def call(env)\n    status, headers, body = @app.call(env)\n\n    if should_transform?(headers)\n      body = transform_body(body)\n    end\n\n    [status, headers, body]\n  end\n\n  private\n\n  def should_transform?(headers)\n    headers['Content-Type']&.include?('application/json')\n  end\n\n  def transform_body(body)\n    content = body.is_a?(Array) ? body.join : body.read\n    transformed = @transformer.call(content)\n    [transformed]\n  end\nend\n\n# Usage\nuse ResponseTransformer do |body|\n  data = JSON.parse(body)\n  data['timestamp'] = Time.now.to_i\n  data.to_json\nend\n```\n\n### Testing Middleware\n\n```ruby\nRSpec.describe RequestLogger do\n  let(:app) { ->(env) { [200, {}, ['OK']] } }\n  let(:logger) { double('Logger', info: nil, error: nil) }\n  let(:middleware) { RequestLogger.new(app, logger: logger) }\n  let(:request) { Rack::MockRequest.new(middleware) }\n\n  describe 'request logging' do\n    it 'logs request start' do\n      expect(logger).to receive(:info).with(hash_including(event: 'request.start'))\n      request.get('/')\n    end\n\n    it 'logs request end with duration' do\n      expect(logger).to receive(:info).with(hash_including(\n        event: 'request.end',\n        duration: kind_of(Numeric)\n      ))\n      request.get('/')\n    end\n\n    it 'includes request details' do\n      expect(logger).to receive(:info).with(hash_including(\n        method: 'GET',\n        path: '/test'\n      ))\n      request.get('/test')\n    end\n  end\n\n  describe 'error logging' do\n    let(:app) { ->(env) { raise StandardError, 'Test error' } }\n\n    it 'logs errors' do\n      expect(logger).to receive(:error).with(hash_including(\n        event: 'request.error',\n        error: 'StandardError'\n      ))\n\n      expect { request.get('/') }.to raise_error(StandardError)\n    end\n  end\n\n  describe 'skip paths' do\n    let(:middleware) { RequestLogger.new(app, logger: logger, skip_paths: ['/health']) }\n\n    it 'skips logging for configured paths' do\n      expect(logger).not_to receive(:info)\n      request.get('/health')\n    end\n  end\nend\n```\n\n### Additional Resources\n\n- **Middleware Template:** `assets/middleware-template.rb` - Boilerplate for new middleware\n- **Middleware Examples:** `assets/middleware-examples/` - Collection of useful middleware\n- **Configuration Guide:** `assets/configuration-guide.md` - Best practices for middleware configuration\n- **Performance Guide:** `references/performance-optimization.md` - Optimizing middleware performance\n- **Testing Guide:** `references/middleware-testing.md` - Comprehensive testing strategies"
              },
              {
                "name": "ruby-patterns",
                "description": "Modern Ruby idioms, design patterns, metaprogramming techniques, and best practices. Use when writing Ruby code or refactoring for clarity.",
                "path": "plugins/ruby-sinatra-advanced/skills/ruby-patterns/SKILL.md",
                "frontmatter": {
                  "name": "ruby-patterns",
                  "description": "Modern Ruby idioms, design patterns, metaprogramming techniques, and best practices. Use when writing Ruby code or refactoring for clarity."
                },
                "content": "# Ruby Patterns Skill\n\n## Tier 1: Quick Reference - Common Idioms\n\n### Conditional Assignment\n\n```ruby\n# Set if nil\nvalue ||= default_value\n\n# Set if falsy (nil or false)\nvalue = value || default_value\n\n# Safe navigation\nuser&.profile&.avatar&.url\n```\n\n### Array and Hash Shortcuts\n\n```ruby\n# Array creation\n%w[apple banana orange]  # [\"apple\", \"banana\", \"orange\"]\n%i[name email age]        # [:name, :email, :age]\n\n# Hash creation\n{ name: 'John', age: 30 }  # Symbol keys\n{ 'name' => 'John' }       # String keys\n\n# Hash access with default\nhash.fetch(:key, default)\nhash[:key] || default\n```\n\n### Enumerable Shortcuts\n\n```ruby\n# Transformation\narray.map(&:upcase)\narray.select(&:active?)\narray.reject(&:empty?)\n\n# Aggregation\narray.sum\narray.max\narray.min\nnumbers.reduce(:+)\n\n# Finding\narray.find(&:valid?)\narray.any?(&:present?)\narray.all?(&:valid?)\n```\n\n### String Operations\n\n```ruby\n# Interpolation\n\"Hello #{name}!\"\n\n# Safe interpolation\n\"Result: %{value}\" % { value: result }\n\n# Multiline\n<<~TEXT\n  Heredoc with indentation\n  removed automatically\nTEXT\n```\n\n### Block Syntax\n\n```ruby\n# Single line - use braces\narray.map { |x| x * 2 }\n\n# Multi-line - use do/end\narray.each do |item|\n  process(item)\n  log(item)\nend\n\n# Symbol to_proc\narray.map(&:to_s)\narray.select(&:even?)\n```\n\n### Guard Clauses\n\n```ruby\ndef process(user)\n  return unless user\n  return unless user.active?\n\n  # Main logic here\nend\n```\n\n### Case Statements\n\n```ruby\n# Traditional\ncase status\nwhen 'active'\n  activate\nwhen 'inactive'\n  deactivate\nend\n\n# With ranges\ncase age\nwhen 0..17\n  'minor'\nwhen 18..64\n  'adult'\nelse\n  'senior'\nend\n```\n\n---\n\n## Tier 2: Detailed Instructions - Design Patterns\n\n### Creational Patterns\n\n**Factory Pattern:**\n```ruby\nclass UserFactory\n  def self.create(type, attributes)\n    case type\n    when :admin\n      AdminUser.new(attributes)\n    when :member\n      MemberUser.new(attributes)\n    when :guest\n      GuestUser.new(attributes)\n    else\n      raise ArgumentError, \"Unknown user type: #{type}\"\n    end\n  end\nend\n\n# Usage\nuser = UserFactory.create(:admin, name: 'John', email: 'john@example.com')\n```\n\n**Builder Pattern:**\n```ruby\nclass QueryBuilder\n  def initialize\n    @conditions = []\n    @order = nil\n    @limit = nil\n  end\n\n  def where(condition)\n    @conditions << condition\n    self\n  end\n\n  def order(column)\n    @order = column\n    self\n  end\n\n  def limit(count)\n    @limit = count\n    self\n  end\n\n  def build\n    query = \"SELECT * FROM users\"\n    query += \" WHERE #{@conditions.join(' AND ')}\" if @conditions.any?\n    query += \" ORDER BY #{@order}\" if @order\n    query += \" LIMIT #{@limit}\" if @limit\n    query\n  end\nend\n\n# Usage\nquery = QueryBuilder.new\n  .where(\"active = true\")\n  .where(\"age > 18\")\n  .order(\"created_at DESC\")\n  .limit(10)\n  .build\n```\n\n**Singleton Pattern:**\n```ruby\nrequire 'singleton'\n\nclass Configuration\n  include Singleton\n\n  attr_accessor :api_key, :timeout\n\n  def initialize\n    @api_key = ENV['API_KEY']\n    @timeout = 30\n  end\nend\n\n# Usage\nconfig = Configuration.instance\nconfig.api_key = 'new_key'\n```\n\n### Structural Patterns\n\n**Decorator Pattern:**\n```ruby\n# Simple decorator\nclass User\n  attr_accessor :name, :email\n\n  def initialize(name, email)\n    @name = name\n    @email = email\n  end\nend\n\nclass AdminUser < SimpleDelegator\n  def permissions\n    [:read, :write, :delete, :admin]\n  end\n\n  def admin?\n    true\n  end\nend\n\n# Usage\nuser = User.new('John', 'john@example.com')\nadmin = AdminUser.new(user)\nadmin.name  # Delegates to user\nadmin.admin?  # From decorator\n\n# Using Ruby's Forwardable\nrequire 'forwardable'\n\nclass UserDecorator\n  extend Forwardable\n  def_delegators :@user, :name, :email\n\n  def initialize(user)\n    @user = user\n  end\n\n  def display_name\n    \"#{@user.name} (#{@user.email})\"\n  end\nend\n```\n\n**Adapter Pattern:**\n```ruby\n# Adapting third-party API\nclass LegacyPaymentGateway\n  def make_payment(amount, card)\n    # Legacy implementation\n  end\nend\n\nclass PaymentAdapter\n  def initialize(gateway)\n    @gateway = gateway\n  end\n\n  def process(amount:, card_number:)\n    card = { number: card_number }\n    @gateway.make_payment(amount, card)\n  end\nend\n\n# Usage\nlegacy = LegacyPaymentGateway.new\nadapter = PaymentAdapter.new(legacy)\nadapter.process(amount: 100, card_number: '1234')\n```\n\n**Composite Pattern:**\n```ruby\nclass File\n  attr_reader :name, :size\n\n  def initialize(name, size)\n    @name = name\n    @size = size\n  end\n\n  def total_size\n    size\n  end\nend\n\nclass Directory\n  attr_reader :name\n\n  def initialize(name)\n    @name = name\n    @contents = []\n  end\n\n  def add(item)\n    @contents << item\n  end\n\n  def total_size\n    @contents.sum(&:total_size)\n  end\nend\n\n# Usage\nroot = Directory.new('root')\nroot.add(File.new('file1.txt', 100))\nsubdir = Directory.new('subdir')\nsubdir.add(File.new('file2.txt', 200))\nroot.add(subdir)\nroot.total_size  # 300\n```\n\n### Behavioral Patterns\n\n**Strategy Pattern:**\n```ruby\nclass PaymentProcessor\n  def initialize(strategy)\n    @strategy = strategy\n  end\n\n  def process(amount)\n    @strategy.process(amount)\n  end\nend\n\nclass CreditCardStrategy\n  def process(amount)\n    puts \"Processing #{amount} via credit card\"\n  end\nend\n\nclass PayPalStrategy\n  def process(amount)\n    puts \"Processing #{amount} via PayPal\"\n  end\nend\n\n# Usage\nprocessor = PaymentProcessor.new(CreditCardStrategy.new)\nprocessor.process(100)\n\nprocessor = PaymentProcessor.new(PayPalStrategy.new)\nprocessor.process(100)\n```\n\n**Observer Pattern:**\n```ruby\nrequire 'observer'\n\nclass Order\n  include Observable\n\n  attr_reader :status\n\n  def initialize\n    @status = :pending\n  end\n\n  def complete!\n    @status = :completed\n    changed\n    notify_observers(self)\n  end\nend\n\nclass EmailNotifier\n  def update(order)\n    puts \"Sending email: Order #{order.object_id} is #{order.status}\"\n  end\nend\n\nclass SMSNotifier\n  def update(order)\n    puts \"Sending SMS: Order #{order.object_id} is #{order.status}\"\n  end\nend\n\n# Usage\norder = Order.new\norder.add_observer(EmailNotifier.new)\norder.add_observer(SMSNotifier.new)\norder.complete!  # Both notifiers triggered\n```\n\n**Command Pattern:**\n```ruby\nclass Command\n  def execute\n    raise NotImplementedError\n  end\n\n  def undo\n    raise NotImplementedError\n  end\nend\n\nclass CreateUserCommand < Command\n  def initialize(user_service, params)\n    @user_service = user_service\n    @params = params\n    @user = nil\n  end\n\n  def execute\n    @user = @user_service.create(@params)\n  end\n\n  def undo\n    @user_service.delete(@user.id) if @user\n  end\nend\n\nclass CommandInvoker\n  def initialize\n    @history = []\n  end\n\n  def execute(command)\n    command.execute\n    @history << command\n  end\n\n  def undo\n    command = @history.pop\n    command&.undo\n  end\nend\n\n# Usage\ninvoker = CommandInvoker.new\ncommand = CreateUserCommand.new(user_service, { name: 'John' })\ninvoker.execute(command)\ninvoker.undo  # Rolls back\n```\n\n### Metaprogramming Techniques\n\n**Dynamic Method Definition:**\n```ruby\nclass Model\n  ATTRIBUTES = [:name, :email, :age]\n\n  ATTRIBUTES.each do |attr|\n    define_method(attr) do\n      instance_variable_get(\"@#{attr}\")\n    end\n\n    define_method(\"#{attr}=\") do |value|\n      instance_variable_set(\"@#{attr}\", value)\n    end\n  end\nend\n\n# Usage\nmodel = Model.new\nmodel.name = 'John'\nmodel.name  # 'John'\n```\n\n**Method Missing:**\n```ruby\nclass DynamicFinder\n  def initialize(data)\n    @data = data\n  end\n\n  def method_missing(method_name, *args)\n    if method_name.to_s.start_with?('find_by_')\n      attribute = method_name.to_s.sub('find_by_', '')\n      @data.find { |item| item[attribute.to_sym] == args.first }\n    else\n      super\n    end\n  end\n\n  def respond_to_missing?(method_name, include_private = false)\n    method_name.to_s.start_with?('find_by_') || super\n  end\nend\n\n# Usage\ndata = [\n  { name: 'John', email: 'john@example.com' },\n  { name: 'Jane', email: 'jane@example.com' }\n]\nfinder = DynamicFinder.new(data)\nfinder.find_by_name('John')  # { name: 'John', ... }\nfinder.find_by_email('jane@example.com')  # { name: 'Jane', ... }\n```\n\n**Class Macros (DSL):**\n```ruby\nclass Validator\n  def self.validates(attribute, rules)\n    @validations ||= []\n    @validations << [attribute, rules]\n\n    define_method(:valid?) do\n      self.class.instance_variable_get(:@validations).all? do |attr, rules|\n        value = send(attr)\n        validate_rules(value, rules)\n      end\n    end\n  end\n\n  def validate_rules(value, rules)\n    rules.all? do |rule, param|\n      case rule\n      when :presence\n        !value.nil? && !value.empty?\n      when :length\n        value.length <= param\n      when :format\n        value.match?(param)\n      else\n        true\n      end\n    end\n  end\nend\n\nclass User < Validator\n  attr_accessor :name, :email\n\n  validates :name, presence: true, length: 50\n  validates :email, presence: true, format: /@/\n\n  def initialize(name, email)\n    @name = name\n    @email = email\n  end\nend\n\n# Usage\nuser = User.new('John', 'john@example.com')\nuser.valid?  # true\n```\n\n**Module Inclusion Hooks:**\n```ruby\nmodule Timestampable\n  def self.included(base)\n    base.class_eval do\n      attr_accessor :created_at, :updated_at\n\n      define_method(:touch) do\n        self.updated_at = Time.now\n      end\n    end\n  end\nend\n\n# Using ActiveSupport::Concern for cleaner syntax\nmodule Trackable\n  extend ActiveSupport::Concern\n\n  included do\n    attr_accessor :tracked_at\n  end\n\n  class_methods do\n    def tracking_enabled?\n      true\n    end\n  end\n\n  def track!\n    self.tracked_at = Time.now\n  end\nend\n\nclass Model\n  include Timestampable\n  include Trackable\nend\n\n# Usage\nmodel = Model.new\nmodel.touch\nmodel.track!\n```\n\n---\n\n## Tier 3: Resources & Examples\n\n### Performance Patterns\n\n**Memoization:**\n```ruby\n# Basic memoization\ndef expensive_calculation\n  @expensive_calculation ||= begin\n    # Expensive operation\n    sleep 1\n    'result'\n  end\nend\n\n# Memoization with parameters\ndef user_posts(user_id)\n  @user_posts ||= {}\n  @user_posts[user_id] ||= Post.where(user_id: user_id).to_a\nend\n\n# Thread-safe memoization\nrequire 'concurrent'\n\nclass Service\n  def initialize\n    @cache = Concurrent::Map.new\n  end\n\n  def get(key)\n    @cache.compute_if_absent(key) do\n      expensive_operation(key)\n    end\n  end\nend\n```\n\n**Lazy Evaluation:**\n```ruby\n# Lazy enumeration for large datasets\n(1..Float::INFINITY)\n  .lazy\n  .select { |n| n % 3 == 0 }\n  .first(10)\n\n# Lazy file processing\nFile.foreach('large_file.txt').lazy\n  .select { |line| line.include?('ERROR') }\n  .map(&:strip)\n  .first(100)\n\n# Custom lazy enumerator\ndef lazy_range(start, finish)\n  Enumerator.new do |yielder|\n    current = start\n    while current <= finish\n      yielder << current\n      current += 1\n    end\n  end.lazy\nend\n```\n\n**Struct for Value Objects:**\n```ruby\n# Simple value object\nUser = Struct.new(:name, :email, :age) do\n  def adult?\n    age >= 18\n  end\n\n  def to_s\n    \"#{name} <#{email}>\"\n  end\nend\n\n# Keyword arguments (Ruby 2.5+)\nUser = Struct.new(:name, :email, :age, keyword_init: true)\nuser = User.new(name: 'John', email: 'john@example.com', age: 30)\n\n# Data class (Ruby 3.2+)\nUser = Data.define(:name, :email, :age) do\n  def adult?\n    age >= 18\n  end\nend\n```\n\n### Error Handling Patterns\n\n**Custom Exceptions:**\n```ruby\nclass ApplicationError < StandardError; end\nclass ValidationError < ApplicationError; end\nclass NotFoundError < ApplicationError; end\nclass AuthenticationError < ApplicationError; end\n\nclass UserService\n  def create(params)\n    raise ValidationError, 'Name is required' if params[:name].nil?\n\n    User.create(params)\n  rescue ActiveRecord::RecordNotFound => e\n    raise NotFoundError, e.message\n  end\nend\n\n# Usage with rescue\nbegin\n  user_service.create(params)\nrescue ValidationError => e\n  render json: { error: e.message }, status: 422\nrescue NotFoundError => e\n  render json: { error: e.message }, status: 404\nrescue ApplicationError => e\n  render json: { error: e.message }, status: 500\nend\n```\n\n**Result Object Pattern:**\n```ruby\nclass Result\n  attr_reader :value, :error\n\n  def initialize(success, value, error = nil)\n    @success = success\n    @value = value\n    @error = error\n  end\n\n  def success?\n    @success\n  end\n\n  def failure?\n    !@success\n  end\n\n  def self.success(value)\n    new(true, value)\n  end\n\n  def self.failure(error)\n    new(false, nil, error)\n  end\n\n  def on_success(&block)\n    block.call(value) if success?\n    self\n  end\n\n  def on_failure(&block)\n    block.call(error) if failure?\n    self\n  end\nend\n\n# Usage\ndef create_user(params)\n  user = User.new(params)\n  if user.valid?\n    user.save\n    Result.success(user)\n  else\n    Result.failure(user.errors)\n  end\nend\n\nresult = create_user(params)\nresult\n  .on_success { |user| send_welcome_email(user) }\n  .on_failure { |errors| log_errors(errors) }\n```\n\n### Testing Patterns\n\n**Shared Examples:**\n```ruby\nRSpec.shared_examples 'a timestamped model' do\n  it 'has created_at' do\n    expect(subject).to respond_to(:created_at)\n  end\n\n  it 'has updated_at' do\n    expect(subject).to respond_to(:updated_at)\n  end\n\n  it 'sets timestamps on create' do\n    subject.save\n    expect(subject.created_at).to be_present\n    expect(subject.updated_at).to be_present\n  end\nend\n\nRSpec.describe User do\n  it_behaves_like 'a timestamped model'\nend\n```\n\n### Functional Programming Patterns\n\n**Composition:**\n```ruby\n# Function composition\nadd_one = ->(x) { x + 1 }\ndouble = ->(x) { x * 2 }\nsquare = ->(x) { x ** 2 }\n\n# Manual composition\nresult = square.call(double.call(add_one.call(5)))  # ((5+1)*2)^2 = 144\n\n# Compose helper\ndef compose(*fns)\n  ->(x) { fns.reverse.reduce(x) { |acc, fn| fn.call(acc) } }\nend\n\ncomposed = compose(square, double, add_one)\ncomposed.call(5)  # 144\n```\n\n**Immutability:**\n```ruby\n# Frozen objects\nclass ImmutablePoint\n  attr_reader :x, :y\n\n  def initialize(x, y)\n    @x = x\n    @y = y\n    freeze\n  end\n\n  def move(dx, dy)\n    ImmutablePoint.new(@x + dx, @y + dy)\n  end\nend\n\n# Frozen literals (Ruby 3+)\n# frozen_string_literal: true\n\nNAME = 'John'  # Frozen by default\n```\n\n### Additional Resources\n\nSee `assets/` directory for:\n- `idioms-cheatsheet.md` - Quick reference for Ruby idioms\n- `design-patterns.rb` - Complete implementations of all patterns\n- `metaprogramming-examples.rb` - Advanced metaprogramming techniques\n\nSee `references/` directory for:\n- Style guides and best practices\n- Performance optimization examples\n- Testing pattern library"
              },
              {
                "name": "sinatra-patterns",
                "description": "Common Sinatra patterns, routing strategies, error handling, and application organization. Use when building Sinatra applications or designing routes.",
                "path": "plugins/ruby-sinatra-advanced/skills/sinatra-patterns/SKILL.md",
                "frontmatter": {
                  "name": "sinatra-patterns",
                  "description": "Common Sinatra patterns, routing strategies, error handling, and application organization. Use when building Sinatra applications or designing routes."
                },
                "content": "# Sinatra Patterns Skill\n\n## Tier 1: Quick Reference\n\n### Common Routing Patterns\n\n**Basic Routes:**\n```ruby\nget '/' do\n  'Hello World'\nend\n\npost '/users' do\n  # Create user\nend\n\nput '/users/:id' do\n  # Update user\nend\n\ndelete '/users/:id' do\n  # Delete user\nend\n```\n\n**Route Parameters:**\n```ruby\n# Named parameters\nget '/users/:id' do\n  User.find(params[:id])\nend\n\n# Parameter constraints\nget '/users/:id', :id => /\\d+/ do\n  # Only matches numeric IDs\nend\n\n# Wildcard\nget '/files/*.*' do\n  # params['splat'] contains matched segments\nend\n```\n\n**Query Parameters:**\n```ruby\nget '/search' do\n  query = params[:q]\n  page = params[:page] || 1\n  results = search(query, page: page)\nend\n```\n\n### Basic Middleware\n\n```ruby\n# Session middleware\nuse Rack::Session::Cookie, secret: ENV['SESSION_SECRET']\n\n# Security middleware\nuse Rack::Protection\n\n# Logging\nuse Rack::CommonLogger\n\n# Compression\nuse Rack::Deflater\n```\n\n### Simple Error Handling\n\n```ruby\nnot_found do\n  'Page not found'\nend\n\nerror do\n  'Internal server error'\nend\n\nerror 401 do\n  'Unauthorized'\nend\n```\n\n### Helpers\n\n```ruby\nhelpers do\n  def logged_in?\n    !session[:user_id].nil?\n  end\n\n  def current_user\n    @current_user ||= User.find_by(id: session[:user_id])\n  end\nend\n```\n\n---\n\n## Tier 2: Detailed Instructions\n\n### Advanced Routing\n\n**Modular Applications:**\n```ruby\n# app/controllers/base_controller.rb\nclass BaseController < Sinatra::Base\n  configure do\n    set :views, Proc.new { File.join(root, '../views') }\n    set :public_folder, Proc.new { File.join(root, '../public') }\n  end\n\n  helpers do\n    def json_response(data, status = 200)\n      content_type :json\n      halt status, data.to_json\n    end\n  end\nend\n\n# app/controllers/users_controller.rb\nclass UsersController < BaseController\n  get '/' do\n    users = User.all\n    json_response(users.map(&:to_hash))\n  end\n\n  get '/:id' do\n    user = User.find(params[:id]) || halt(404)\n    json_response(user.to_hash)\n  end\n\n  post '/' do\n    user = User.create(params[:user])\n    if user.persisted?\n      json_response(user.to_hash, 201)\n    else\n      json_response({ errors: user.errors }, 422)\n    end\n  end\nend\n\n# config.ru\nmap '/users' do\n  run UsersController\nend\n```\n\n**Namespaces:**\n```ruby\nrequire 'sinatra/namespace'\n\nclass App < Sinatra::Base\n  register Sinatra::Namespace\n\n  namespace '/api' do\n    namespace '/v1' do\n      get '/users' do\n        # GET /api/v1/users\n      end\n\n      namespace '/admin' do\n        before do\n          authenticate_admin!\n        end\n\n        get '/stats' do\n          # GET /api/v1/admin/stats\n        end\n      end\n    end\n  end\nend\n```\n\n**Route Conditions:**\n```ruby\n# User agent condition\nget '/', :agent => /iPhone/ do\n  # Mobile version\nend\n\n# Custom conditions\nset(:auth) do |role|\n  condition do\n    unless current_user && current_user.has_role?(role)\n      halt 403\n    end\n  end\nend\n\nget '/admin', :auth => :admin do\n  # Only accessible to admins\nend\n\n# Host-based routing\nget '/', :host => 'admin.example.com' do\n  # Admin subdomain\nend\n```\n\n**Content Negotiation:**\n```ruby\nget '/users/:id', :provides => [:json, :xml, :html] do\n  user = User.find(params[:id])\n\n  case request.accept.first.to_s\n  when 'application/json'\n    json user.to_json\n  when 'application/xml'\n    xml user.to_xml\n  else\n    erb :user, locals: { user: user }\n  end\nend\n\n# Or using provides helper\nget '/users/:id' do\n  user = User.find(params[:id])\n\n  respond_to do |format|\n    format.json { json user.to_json }\n    format.xml { xml user.to_xml }\n    format.html { erb :user, locals: { user: user } }\n  end\nend\n```\n\n### Middleware Composition\n\n**Custom Middleware:**\n```ruby\nclass RequestLogger\n  def initialize(app)\n    @app = app\n  end\n\n  def call(env)\n    start_time = Time.now\n    status, headers, body = @app.call(env)\n    duration = Time.now - start_time\n\n    puts \"#{env['REQUEST_METHOD']} #{env['PATH_INFO']} - #{status} (#{duration}s)\"\n\n    [status, headers, body]\n  end\nend\n\nuse RequestLogger\n```\n\n**Middleware Ordering:**\n```ruby\n# config.ru\nuse Rack::Deflater                    # Compression first\nuse Rack::Static                       # Static files\nuse Rack::CommonLogger                 # Logging\nuse Rack::Session::Cookie             # Sessions\nuse Rack::Protection                   # Security\nuse CustomAuthentication              # Auth\nrun Application\n```\n\n### Template Integration\n\n**ERB Templates:**\n```ruby\n# views/layout.erb\n<!DOCTYPE html>\n<html>\n<head>\n  <title><%= @title || 'My App' %></title>\n</head>\n<body>\n  <%= yield %>\n</body>\n</html>\n\n# views/users/index.erb\n<h1>Users</h1>\n<ul>\n  <% @users.each do |user| %>\n    <li><%= user.name %></li>\n  <% end %>\n</ul>\n\n# Controller\nget '/users' do\n  @users = User.all\n  @title = 'User List'\n  erb :'users/index'\nend\n```\n\n**Inline Templates:**\n```ruby\nget '/' do\n  erb :index\nend\n\n__END__\n\n@@layout\n<!DOCTYPE html>\n<html>\n  <body><%= yield %></body>\n</html>\n\n@@index\n<h1>Welcome</h1>\n```\n\n**Template Engines:**\n```ruby\n# Haml\nget '/' do\n  haml :index\nend\n\n# Slim\nget '/' do\n  slim :index\nend\n\n# Liquid (safe for user content)\nget '/' do\n  liquid :index, locals: { user: current_user }\nend\n```\n\n### Error Handling Patterns\n\n**Comprehensive Error Handling:**\n```ruby\nclass Application < Sinatra::Base\n  # Development configuration\n  configure :development do\n    set :show_exceptions, :after_handler\n    set :dump_errors, true\n  end\n\n  # Production configuration\n  configure :production do\n    set :show_exceptions, false\n    set :dump_errors, false\n  end\n\n  # Specific exception handlers\n  error ActiveRecord::RecordNotFound do\n    status 404\n    json({ error: 'Resource not found' })\n  end\n\n  error ActiveRecord::RecordInvalid do\n    status 422\n    json({ error: 'Validation failed', details: env['sinatra.error'].message })\n  end\n\n  error Sequel::NoMatchingRow do\n    status 404\n    json({ error: 'Not found' })\n  end\n\n  # HTTP status handlers\n  not_found do\n    json({ error: 'Endpoint not found' })\n  end\n\n  error 401 do\n    json({ error: 'Unauthorized' })\n  end\n\n  error 403 do\n    json({ error: 'Forbidden' })\n  end\n\n  error 422 do\n    json({ error: 'Unprocessable entity' })\n  end\n\n  # Catch-all error handler\n  error do\n    error = env['sinatra.error']\n    logger.error(\"Error: #{error.message}\")\n    logger.error(error.backtrace.join(\"\\n\"))\n\n    status 500\n    json({ error: 'Internal server error' })\n  end\nend\n```\n\n### Before/After Filters\n\n**Request Filters:**\n```ruby\n# Global before filter\nbefore do\n  content_type :json\nend\n\n# Path-specific filters\nbefore '/admin/*' do\n  authenticate_admin!\nend\n\n# Conditional filters\nbefore do\n  pass unless request.path.start_with?('/api')\n  authenticate_api_user!\nend\n\n# After filters\nafter do\n  # Add CORS headers\n  headers 'Access-Control-Allow-Origin' => '*'\nend\n\n# Modify response\nafter do\n  response.body = response.body.map(&:upcase) if params[:uppercase]\nend\n```\n\n### Session Management\n\n**Cookie Sessions:**\n```ruby\nuse Rack::Session::Cookie,\n  key: 'app.session',\n  secret: ENV['SESSION_SECRET'],\n  expire_after: 86400,  # 1 day\n  secure: production?,\n  httponly: true,\n  same_site: :strict\n\nhelpers do\n  def login(user)\n    session[:user_id] = user.id\n    session[:logged_in_at] = Time.now.to_i\n  end\n\n  def logout\n    session.clear\n  end\n\n  def current_user\n    return nil unless session[:user_id]\n    @current_user ||= User.find_by(id: session[:user_id])\n  end\nend\n```\n\n---\n\n## Tier 3: Resources & Examples\n\n### Full Application Example\n\nSee `assets/modular-app-template/` for complete modular application structure.\n\n### Performance Patterns\n\n**Caching:**\n```ruby\n# HTTP caching\nget '/public/data' do\n  cache_control :public, max_age: 3600\n  etag calculate_etag\n  last_modified last_update_time\n\n  json PublicData.all.map(&:to_hash)\nend\n\n# Fragment caching with Redis\nrequire 'redis'\n\nhelpers do\n  def cache_fetch(key, expires_in: 300, &block)\n    cached = REDIS.get(key)\n    return JSON.parse(cached) if cached\n\n    data = block.call\n    REDIS.setex(key, expires_in, data.to_json)\n    data\n  end\nend\n\nget '/expensive-data' do\n  data = cache_fetch('expensive-data', expires_in: 600) do\n    perform_expensive_query\n  end\n\n  json data\nend\n```\n\n**Streaming Responses:**\n```ruby\n# Stream large responses\nget '/large-export' do\n  stream do |out|\n    User.find_each do |user|\n      out << user.to_csv_row\n    end\n  end\nend\n\n# Server-Sent Events\nget '/events', provides: 'text/event-stream' do\n  stream :keep_open do |out|\n    EventSource.subscribe do |event|\n      out << \"data: #{event.to_json}\\n\\n\"\n    end\n  end\nend\n```\n\n### Production Configuration\n\n**Complete config.ru:**\n```ruby\n# config.ru\nrequire_relative 'config/environment'\n\n# Production middleware\nif ENV['RACK_ENV'] == 'production'\n  use Rack::SSL\n  use Rack::Deflater\nend\n\n# Static files\nuse Rack::Static,\n  urls: ['/css', '/js', '/images'],\n  root: 'public',\n  header_rules: [\n    [:all, {'Cache-Control' => 'public, max-age=31536000'}]\n  ]\n\n# Logging\nuse Rack::CommonLogger\n\n# Sessions\nuse Rack::Session::Cookie,\n  secret: ENV['SESSION_SECRET'],\n  same_site: :strict,\n  httponly: true,\n  secure: ENV['RACK_ENV'] == 'production'\n\n# Security\nuse Rack::Protection,\n  except: [:session_hijacking],\n  use: :all\n\n# Rate limiting (production)\nif ENV['RACK_ENV'] == 'production'\n  require 'rack/attack'\n  use Rack::Attack\nend\n\n# Mount applications\nmap '/api/v1' do\n  run ApiV1::Application\nend\n\nmap '/' do\n  run WebApplication\nend\n```\n\n**Rack::Attack Configuration:**\n```ruby\n# config/rack_attack.rb\nclass Rack::Attack\n  # Throttle login attempts\n  throttle('login/ip', limit: 5, period: 60) do |req|\n    req.ip if req.path == '/login' && req.post?\n  end\n\n  # Throttle API requests\n  throttle('api/ip', limit: 100, period: 60) do |req|\n    req.ip if req.path.start_with?('/api')\n  end\n\n  # Block suspicious requests\n  blocklist('block bad user agents') do |req|\n    req.user_agent =~ /bad_bot/i\n  end\nend\n```\n\n### Testing Patterns\n\nSee `references/testing-examples.rb` for comprehensive test patterns.\n\n### Project Structure\n\n**Recommended modular structure:**\n```\napp/\n  controllers/\n    base_controller.rb\n    api_controller.rb\n    users_controller.rb\n    posts_controller.rb\n  models/\n    user.rb\n    post.rb\n  services/\n    user_service.rb\n    authentication_service.rb\n  helpers/\n    application_helpers.rb\n    view_helpers.rb\nconfig/\n  environment.rb\n  database.yml\n  puma.rb\ndb/\n  migrations/\nlib/\n  middleware/\n    custom_auth.rb\n  tasks/\npublic/\n  css/\n  js/\n  images/\nviews/\n  layout.erb\n  users/\n    index.erb\n    show.erb\nspec/\n  controllers/\n  models/\n  spec_helper.rb\nconfig.ru\nGemfile\nRakefile\nREADME.md\n```\n\n### Additional Resources\n\n- **Routing Examples:** `assets/routing-examples.rb`\n- **Middleware Patterns:** `assets/middleware-patterns.rb`\n- **Modular App Template:** `assets/modular-app-template/`\n- **Production Config:** `references/production-config.rb`\n- **Testing Guide:** `references/testing-examples.rb`"
              },
              {
                "name": "sinatra-security",
                "description": "Security best practices for Sinatra applications including input validation, CSRF protection, and authentication patterns. Use when hardening applications or conducting security reviews.",
                "path": "plugins/ruby-sinatra-advanced/skills/sinatra-security/SKILL.md",
                "frontmatter": {
                  "name": "sinatra-security",
                  "description": "Security best practices for Sinatra applications including input validation, CSRF protection, and authentication patterns. Use when hardening applications or conducting security reviews."
                },
                "content": "# Sinatra Security Skill\n\n## Tier 1: Quick Reference - Essential Security\n\n### CSRF Protection\n\n```ruby\n# Enable Rack::Protection\nuse Rack::Protection\n\n# Or specifically CSRF\nuse Rack::Protection::AuthenticityToken\n```\n\n### XSS Prevention\n\n```ruby\n# In ERB templates - always escape by default\n<%= user.bio %>          # Escaped (safe)\n<%== user.bio %>         # Raw (dangerous!)\n\n# In JSON responses - use proper JSON encoding\nrequire 'json'\njson({ name: user.name }.to_json)\n```\n\n### SQL Injection Prevention\n\n```ruby\n# BAD: String interpolation\nDB[\"SELECT * FROM users WHERE email = '#{email}'\"]\n\n# GOOD: Parameterized queries\nDB[\"SELECT * FROM users WHERE email = ?\", email]\n\n# GOOD: Hash conditions\nUser.where(email: email)\n```\n\n### Secure Sessions\n\n```ruby\nuse Rack::Session::Cookie,\n  secret: ENV['SESSION_SECRET'],  # Long random string\n  same_site: :strict,\n  httponly: true,\n  secure: production?\n```\n\n### Input Validation\n\n```ruby\nhelpers do\n  def validate_email(email)\n    email.to_s.match?(/\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i)\n  end\n\n  def validate_integer(value)\n    Integer(value)\n  rescue ArgumentError, TypeError\n    nil\n  end\nend\n\npost '/users' do\n  halt 400, 'Invalid email' unless validate_email(params[:email])\n  # Process...\nend\n```\n\n### Authentication Check\n\n```ruby\nhelpers do\n  def authenticate!\n    halt 401, json({ error: 'Unauthorized' }) unless current_user\n  end\n\n  def current_user\n    @current_user ||= User.find_by(id: session[:user_id])\n  end\nend\n\nbefore '/admin/*' do\n  authenticate!\nend\n```\n\n---\n\n## Tier 2: Detailed Instructions - Security Implementation\n\n### Comprehensive CSRF Protection\n\n**Configuration:**\n```ruby\nclass Application < Sinatra::Base\n  # Enable CSRF protection\n  use Rack::Protection::AuthenticityToken,\n    except: [:json],  # Skip for JSON APIs with token auth\n    allow_if: -> (env) {\n      # Skip for API endpoints with bearer token\n      env['HTTP_AUTHORIZATION']&.start_with?('Bearer ')\n    }\n\n  # Manual CSRF token generation\n  helpers do\n    def csrf_token\n      session[:csrf] ||= SecureRandom.hex(32)\n    end\n\n    def csrf_tag\n      \"<input type='hidden' name='authenticity_token' value='#{csrf_token}'>\"\n    end\n\n    def verify_csrf_token\n      token = params[:authenticity_token] || request.env['HTTP_X_CSRF_TOKEN']\n      halt 403, 'Invalid CSRF token' unless token == session[:csrf]\n    end\n  end\n\n  # Include in forms\n  post '/users' do\n    verify_csrf_token unless request.content_type == 'application/json'\n    # Process...\n  end\nend\n```\n\n**In Views:**\n```erb\n<form method=\"POST\" action=\"/users\">\n  <%= csrf_tag %>\n  <!-- form fields -->\n</form>\n```\n\n**For AJAX:**\n```javascript\n// Include CSRF token in AJAX requests\nfetch('/users', {\n  method: 'POST',\n  headers: {\n    'X-CSRF-Token': document.querySelector('[name=csrf_token]').value,\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify(data)\n});\n```\n\n### XSS Prevention Strategies\n\n**Template Escaping:**\n```ruby\n# ERB - escape by default\n<div><%= user_input %></div>\n\n# Explicitly raw (only for trusted content)\n<div><%== trusted_html %></div>\n\n# Sanitize user HTML\nrequire 'sanitize'\n\nhelpers do\n  def sanitize_html(html)\n    Sanitize.fragment(html, Sanitize::Config::RELAXED)\n  end\nend\n\n# In template\n<div><%= sanitize_html(user_bio) %></div>\n```\n\n**JSON Responses:**\n```ruby\n# Always use proper JSON encoding\nget '/api/users/:id' do\n  user = User.find(params[:id])\n\n  # BAD: Manual JSON construction\n  # \"{ \\\"name\\\": \\\"#{user.name}\\\" }\"  # XSS if name contains quotes\n\n  # GOOD: Use JSON library\n  content_type :json\n  { name: user.name, bio: user.bio }.to_json\nend\n```\n\n**Content Security Policy:**\n```ruby\nclass Application < Sinatra::Base\n  before do\n    headers 'Content-Security-Policy' => [\n      \"default-src 'self'\",\n      \"script-src 'self' https://cdn.example.com\",\n      \"style-src 'self' 'unsafe-inline'\",\n      \"img-src 'self' data: https:\",\n      \"font-src 'self'\",\n      \"connect-src 'self'\",\n      \"frame-ancestors 'none'\"\n    ].join('; ')\n  end\nend\n```\n\n### SQL Injection Prevention\n\n**Parameterized Queries:**\n```ruby\n# Sequel\n# BAD\nDB[\"SELECT * FROM users WHERE name = '#{name}'\"]\n\n# GOOD\nDB[\"SELECT * FROM users WHERE name = ?\", name]\nDB[\"SELECT * FROM users WHERE name = :name\", name: name]\n\n# ActiveRecord\n# BAD\nUser.where(\"email = '#{email}'\")\n\n# GOOD\nUser.where(email: email)\nUser.where(\"email = ?\", email)\nUser.where(\"email = :email\", email: email)\n```\n\n**Input Validation:**\n```ruby\nhelpers do\n  def validate_sql_param(param, type: :string)\n    case type\n    when :integer\n      Integer(param)\n    when :boolean\n      [true, 'true', '1', 1].include?(param)\n    when :string\n      param.to_s.gsub(/['\";\\\\]/, '')  # Remove dangerous chars\n    else\n      param\n    end\n  rescue ArgumentError\n    halt 400, 'Invalid parameter'\n  end\nend\n\nget '/users/:id' do\n  id = validate_sql_param(params[:id], type: :integer)\n  user = User.find(id)\n  json user.to_hash\nend\n```\n\n### Authentication Patterns\n\n**Password Authentication:**\n```ruby\nrequire 'bcrypt'\n\nclass User\n  include BCrypt\n\n  def password=(new_password)\n    @password_hash = Password.create(new_password)\n  end\n\n  def password_hash\n    @password_hash\n  end\n\n  def authenticate(password)\n    Password.new(password_hash) == password\n  end\nend\n\n# Registration\npost '/register' do\n  user = User.new(\n    email: params[:email],\n    name: params[:name]\n  )\n  user.password = params[:password]\n  user.save\n\n  session[:user_id] = user.id\n  redirect '/dashboard'\nend\n\n# Login\npost '/login' do\n  user = User.find_by(email: params[:email])\n\n  if user&.authenticate(params[:password])\n    session[:user_id] = user.id\n    session[:logged_in_at] = Time.now.to_i\n\n    redirect '/dashboard'\n  else\n    halt 401, 'Invalid credentials'\n  end\nend\n```\n\n**Token-Based Authentication:**\n```ruby\nrequire 'jwt'\n\nclass TokenAuth\n  SECRET = ENV['JWT_SECRET']\n\n  def self.encode(payload, exp = 24.hours.from_now)\n    payload[:exp] = exp.to_i\n    JWT.encode(payload, SECRET, 'HS256')\n  end\n\n  def self.decode(token)\n    body = JWT.decode(token, SECRET, true, algorithm: 'HS256')[0]\n    HashWithIndifferentAccess.new(body)\n  rescue JWT::DecodeError, JWT::ExpiredSignature\n    nil\n  end\nend\n\n# Middleware\nclass JWTAuth\n  def initialize(app)\n    @app = app\n  end\n\n  def call(env)\n    auth_header = env['HTTP_AUTHORIZATION']\n    token = auth_header&.split(' ')&.last\n\n    if payload = TokenAuth.decode(token)\n      env['current_user_id'] = payload[:user_id]\n      @app.call(env)\n    else\n      [401, { 'Content-Type' => 'application/json' },\n       ['{\"error\": \"Unauthorized\"}']]\n    end\n  end\nend\n\n# Login endpoint\npost '/api/login' do\n  user = User.find_by(email: params[:email])\n\n  if user&.authenticate(params[:password])\n    token = TokenAuth.encode(user_id: user.id)\n    json({ token: token, user: user.to_hash })\n  else\n    halt 401, json({ error: 'Invalid credentials' })\n  end\nend\n\n# Protected routes\nclass API < Sinatra::Base\n  use JWTAuth\n\n  helpers do\n    def current_user\n      @current_user ||= User.find(request.env['current_user_id'])\n    end\n  end\n\n  get '/profile' do\n    json current_user.to_hash\n  end\nend\n```\n\n**API Key Authentication:**\n```ruby\nclass APIKeyAuth\n  def initialize(app)\n    @app = app\n  end\n\n  def call(env)\n    api_key = env['HTTP_X_API_KEY']\n\n    if valid_api_key?(api_key)\n      user = User.find_by(api_key: api_key)\n      env['current_user'] = user\n      @app.call(env)\n    else\n      [401, { 'Content-Type' => 'application/json' },\n       ['{\"error\": \"Invalid API key\"}']]\n    end\n  end\n\n  private\n\n  def valid_api_key?(key)\n    key && User.exists?(api_key: key, active: true)\n  end\nend\n\nuse APIKeyAuth\n\n# Generate API keys\nhelpers do\n  def generate_api_key\n    SecureRandom.hex(32)\n  end\nend\n\npost '/api/keys' do\n  authenticate!\n  api_key = generate_api_key\n  current_user.update(api_key: api_key)\n  json({ api_key: api_key })\nend\n```\n\n### Authorization Patterns\n\n**Role-Based Access Control:**\n```ruby\nclass User\n  ROLES = [:guest, :user, :admin, :superadmin]\n\n  def has_role?(role)\n    ROLES.index(self.role) >= ROLES.index(role)\n  end\n\n  def can?(action, resource)\n    case role\n    when :admin, :superadmin\n      true\n    when :user\n      action == :read || resource.user_id == id\n    else\n      action == :read\n    end\n  end\nend\n\nhelpers do\n  def authorize!(action, resource)\n    unless current_user&.can?(action, resource)\n      halt 403, json({ error: 'Forbidden' })\n    end\n  end\nend\n\n# Usage\nget '/posts/:id' do\n  post = Post.find(params[:id])\n  authorize!(:read, post)\n  json post.to_hash\nend\n\ndelete '/posts/:id' do\n  post = Post.find(params[:id])\n  authorize!(:delete, post)\n  post.destroy\n  status 204\nend\n```\n\n**Permission-Based Authorization:**\n```ruby\nclass Permission\n  ACTIONS = {\n    posts: [:create, :read, :update, :delete],\n    users: [:read, :update, :delete],\n    comments: [:create, :read, :delete]\n  }\n\n  def self.check(user, action, resource_type)\n    return false unless user\n\n    permissions = user.permissions\n    permissions.include?(\"#{resource_type}:#{action}\") ||\n      permissions.include?(\"#{resource_type}:*\") ||\n      permissions.include?(\"*:*\")\n  end\nend\n\nhelpers do\n  def can?(action, resource_type)\n    Permission.check(current_user, action, resource_type)\n  end\n\n  def authorize!(action, resource_type)\n    unless can?(action, resource_type)\n      halt 403, json({ error: 'Forbidden' })\n    end\n  end\nend\n\npost '/posts' do\n  authorize!(:create, :posts)\n  # Create post\nend\n```\n\n### Rate Limiting\n\n**Using Rack::Attack:**\n```ruby\nrequire 'rack/attack'\n\nclass Rack::Attack\n  # Throttle login attempts\n  throttle('login/ip', limit: 5, period: 60) do |req|\n    req.ip if req.path == '/login' && req.post?\n  end\n\n  # Throttle API requests by API key\n  throttle('api/key', limit: 100, period: 60) do |req|\n    req.env['HTTP_X_API_KEY'] if req.path.start_with?('/api')\n  end\n\n  # Throttle by IP\n  throttle('req/ip', limit: 300, period: 60) do |req|\n    req.ip\n  end\n\n  # Block known bad actors\n  blocklist('block bad IPs') do |req|\n    BadIP.blocked?(req.ip)\n  end\n\n  # Custom response\n  self.throttled_responder = lambda do |env|\n    [\n      429,\n      { 'Content-Type' => 'application/json' },\n      [{ error: 'Rate limit exceeded' }.to_json]\n    ]\n  end\nend\n\nuse Rack::Attack\n```\n\n### Secure File Uploads\n\n```ruby\nrequire 'securerandom'\n\nclass FileUploadHandler\n  ALLOWED_TYPES = {\n    'image/jpeg' => '.jpg',\n    'image/png' => '.png',\n    'image/gif' => '.gif',\n    'application/pdf' => '.pdf'\n  }\n\n  MAX_SIZE = 5 * 1024 * 1024  # 5MB\n\n  def self.process(file)\n    # Validate file presence\n    return { error: 'No file provided' } unless file\n\n    # Validate file size\n    if file[:tempfile].size > MAX_SIZE\n      return { error: 'File too large' }\n    end\n\n    # Validate content type\n    content_type = file[:type]\n    unless ALLOWED_TYPES.key?(content_type)\n      return { error: 'Invalid file type' }\n    end\n\n    # Sanitize filename\n    original_name = File.basename(file[:filename])\n    sanitized_name = original_name.gsub(/[^a-zA-Z0-9\\._-]/, '')\n\n    # Generate unique filename\n    extension = ALLOWED_TYPES[content_type]\n    unique_name = \"#{SecureRandom.hex(16)}#{extension}\"\n\n    # Save file\n    upload_dir = 'uploads'\n    FileUtils.mkdir_p(upload_dir)\n    path = File.join(upload_dir, unique_name)\n\n    File.open(path, 'wb') do |f|\n      f.write(file[:tempfile].read)\n    end\n\n    { success: true, path: path, filename: unique_name }\n  end\nend\n\npost '/upload' do\n  result = FileUploadHandler.process(params[:file])\n\n  if result[:error]\n    halt 400, json({ error: result[:error] })\n  else\n    json({ url: \"/uploads/#{result[:filename]}\" })\n  end\nend\n```\n\n---\n\n## Tier 3: Resources & Examples\n\n### Security Headers\n\n**Comprehensive Security Headers:**\n```ruby\nclass SecurityHeaders\n  HEADERS = {\n    'X-Frame-Options' => 'DENY',\n    'X-Content-Type-Options' => 'nosniff',\n    'X-XSS-Protection' => '1; mode=block',\n    'Referrer-Policy' => 'strict-origin-when-cross-origin',\n    'Permissions-Policy' => 'geolocation=(), microphone=(), camera=()',\n    'Strict-Transport-Security' => 'max-age=31536000; includeSubDomains'\n  }\n\n  def initialize(app)\n    @app = app\n  end\n\n  def call(env)\n    status, headers, body = @app.call(env)\n    headers.merge!(HEADERS)\n    [status, headers, body]\n  end\nend\n\nuse SecurityHeaders\n```\n\n### OWASP Security Checklist\n\nSee `assets/owasp-checklist.md` for complete checklist covering:\n\n1. **Injection Prevention**\n   - SQL Injection\n   - Command Injection\n   - LDAP Injection\n   - XML Injection\n\n2. **Broken Authentication**\n   - Password policies\n   - Session management\n   - Multi-factor authentication\n   - Account lockout\n\n3. **Sensitive Data Exposure**\n   - Encryption at rest\n   - Encryption in transit (HTTPS)\n   - Secure key storage\n   - Data minimization\n\n4. **XML External Entities (XXE)**\n   - XML parser configuration\n   - Disable external entity processing\n\n5. **Broken Access Control**\n   - Authentication on all protected routes\n   - Authorization checks\n   - IDOR prevention\n   - CORS configuration\n\n6. **Security Misconfiguration**\n   - Remove default credentials\n   - Disable directory listing\n   - Error message handling\n   - Keep dependencies updated\n\n7. **Cross-Site Scripting (XSS)**\n   - Output encoding\n   - Input validation\n   - Content Security Policy\n   - HTTPOnly cookies\n\n8. **Insecure Deserialization**\n   - Validate serialized data\n   - Use safe serialization formats\n   - Sign serialized data\n\n9. **Using Components with Known Vulnerabilities**\n   - Regular dependency updates\n   - Security audits (bundle audit)\n   - Monitor CVE databases\n\n10. **Insufficient Logging & Monitoring**\n    - Log security events\n    - Monitor for attacks\n    - Alerting systems\n    - Log rotation and retention\n\n### Security Testing Examples\n\n**Testing Authentication:**\n```ruby\nRSpec.describe 'Authentication' do\n  describe 'POST /login' do\n    let(:user) { create(:user, email: 'test@example.com', password: 'password123') }\n\n    it 'succeeds with valid credentials' do\n      post '/login', { email: 'test@example.com', password: 'password123' }.to_json,\n        'CONTENT_TYPE' => 'application/json'\n\n      expect(last_response).to be_ok\n      expect(json_response).to have_key('token')\n    end\n\n    it 'fails with invalid password' do\n      post '/login', { email: 'test@example.com', password: 'wrong' }.to_json,\n        'CONTENT_TYPE' => 'application/json'\n\n      expect(last_response.status).to eq(401)\n    end\n\n    it 'prevents brute force attacks' do\n      6.times do\n        post '/login', { email: 'test@example.com', password: 'wrong' }.to_json,\n          'CONTENT_TYPE' => 'application/json'\n      end\n\n      expect(last_response.status).to eq(429)  # Rate limited\n    end\n  end\nend\n```\n\n**Testing Authorization:**\n```ruby\nRSpec.describe 'Authorization' do\n  let(:user) { create(:user) }\n  let(:admin) { create(:user, role: :admin) }\n  let(:post) { create(:post, user: user) }\n\n  describe 'DELETE /posts/:id' do\n    it 'allows owner to delete' do\n      delete \"/posts/#{post.id}\", {}, auth_header(user.token)\n      expect(last_response.status).to eq(204)\n    end\n\n    it 'allows admin to delete' do\n      delete \"/posts/#{post.id}\", {}, auth_header(admin.token)\n      expect(last_response.status).to eq(204)\n    end\n\n    it 'denies other users' do\n      other_user = create(:user)\n      delete \"/posts/#{post.id}\", {}, auth_header(other_user.token)\n      expect(last_response.status).to eq(403)\n    end\n\n    it 'requires authentication' do\n      delete \"/posts/#{post.id}\"\n      expect(last_response.status).to eq(401)\n    end\n  end\nend\n```\n\n### Additional Resources\n\n- **Security Middleware:** `assets/security-middleware.rb`\n- **Authentication Patterns:** `assets/auth-patterns.rb`\n- **OWASP Checklist:** `assets/owasp-checklist.md`\n- **Security Audit Template:** `references/security-audit-template.md`\n- **Penetration Testing Guide:** `references/penetration-testing.md`"
              }
            ]
          },
          {
            "name": "git",
            "description": "Git focused utilities with namespaced commands for advanced workflows",
            "source": "./plugins/utilities/git",
            "category": "utilities",
            "version": "1.0.0",
            "author": {
              "name": "Geoff Johnson",
              "url": "https://github.com/geoffjay"
            },
            "install_commands": [
              "/plugin marketplace add geoffjay/claude-plugins",
              "/plugin install git@geoffjay-claude-plugins"
            ],
            "signals": {
              "stars": 4,
              "forks": 1,
              "pushed_at": "2025-11-04T20:23:37Z",
              "created_at": "2025-10-17T18:24:21Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/bisect",
                "description": "Interactive git bisect workflow to find commits that introduced bugs using binary search",
                "path": "plugins/utilities/git/commands/bisect.md",
                "frontmatter": {
                  "name": "git:bisect",
                  "description": "Interactive git bisect workflow to find commits that introduced bugs using binary search"
                },
                "content": "# Git Bisect - Binary Search for Bug-Introducing Commits\n\nInteractive git bisect workflow to find commits that introduced bugs using binary search.\n\n## Command\n\n`/git:bisect [mode] [commit-ref]`\n\n## Arguments\n\n- `$1`: mode - `start|good|bad|skip|reset` (optional, interactive if not provided)\n- `$2`: commit-ref (optional, depends on mode)\n\n## Description\n\nGit bisect uses binary search to efficiently find the commit that introduced a bug. Instead of checking every commit, it splits the commit range in half repeatedly, asking you to test each midpoint. This can find a bug in log(n) checks instead of n checks.\n\n## Workflow\n\n### Starting a Bisect Session\n\n1. **Pre-flight checks:**\n   - Check if bisect is already in progress: `git bisect log`\n   - Check for uncommitted changes: `git status --porcelain`\n   - If changes exist, warn user and suggest stashing\n\n2. **Gather information:**\n   - Ask for the \"good\" commit (where bug didn't exist)\n     - Default: last tag or commit from 1 week ago\n     - User can specify: commit hash, tag, branch name\n   - Ask for the \"bad\" commit (where bug exists)\n     - Default: HEAD (current commit)\n     - User can specify: commit hash, tag, branch name\n   - Calculate and show number of commits between good and bad\n   - Estimate number of steps needed: ~log2(n)\n\n3. **Start bisect:**\n   ```bash\n   git bisect start\n   git bisect bad [bad-commit]\n   git bisect good [good-commit]\n   ```\n\n4. **Show first commit to test:**\n   - Display commit hash, date, author, message\n   - Show which files changed: `git show --stat <commit>`\n   - Provide clear instructions on what to test\n\n### During Bisect Session\n\n5. **Test current commit:**\n   - Ask user to test whether the bug exists\n   - Provide clear instructions:\n     - \"Run your tests\"\n     - \"Manually test the feature\"\n     - \"Check the logs\"\n   - Wait for user feedback\n\n6. **Mark commit based on test result:**\n   - If bug exists: `git bisect bad`\n   - If bug doesn't exist: `git bisect good`\n   - If commit is untestable (won't build, etc): `git bisect skip`\n   - Option to abort: `git bisect reset`\n\n7. **Show progress:**\n   - Display remaining commits to test\n   - Show estimated steps left\n   - Display bisect log: `git bisect log`\n\n8. **Repeat steps 5-7** until the first bad commit is found\n\n### Completion\n\n9. **When bug commit identified:**\n   - Display full commit details:\n     ```bash\n     git show <commit-hash>\n     ```\n   - Show commit message, author, date\n   - Show full diff\n   - Highlight which files were changed\n\n10. **Offer actions:**\n    - Create a branch from this commit for investigation\n    - Create a branch from parent commit for fix\n    - Copy commit hash to clipboard\n    - View commit in GitHub/GitLab (if remote exists)\n    - Reset bisect and return to original HEAD\n\n11. **Reset bisect:**\n    ```bash\n    git bisect reset\n    ```\n    - Return to original branch/commit\n    - Confirm user is back to starting state\n\n### Abort/Reset Anytime\n\nAt any point during the bisect, user can:\n- Type 'abort' to run `git bisect reset`\n- Type 'skip' to skip current commit\n- Type 'log' to see bisect progress\n- Type 'visualize' to see bisect state graphically\n\n## Safety Checks\n\n### Before Starting\n\n- **Uncommitted changes:**\n  ```bash\n  if [ -n \"$(git status --porcelain)\" ]; then\n    echo \"Warning: You have uncommitted changes.\"\n    echo \"Options:\"\n    echo \"  1. Stash changes: git stash save 'Pre-bisect stash'\"\n    echo \"  2. Commit changes\"\n    echo \"  3. Discard changes (dangerous)\"\n    echo \"  4. Cancel bisect\"\n    # Wait for user choice\n  fi\n  ```\n\n- **Already in bisect:**\n  ```bash\n  if [ -f .git/BISECT_LOG ]; then\n    echo \"Bisect already in progress!\"\n    echo \"Options:\"\n    echo \"  1. Continue current bisect\"\n    echo \"  2. Reset and start new bisect\"\n    echo \"  3. Cancel\"\n    # Wait for user choice\n  fi\n  ```\n\n- **Detached HEAD warning:**\n  - Explain that bisect will put repo in detached HEAD state\n  - Assure user that `git bisect reset` will return to original state\n\n### During Bisect\n\n- **Clear instructions at each step:**\n  - Show current commit details\n  - Explain what user needs to test\n  - Show available commands (good/bad/skip/reset)\n  - Display progress and remaining steps\n\n- **Skip commit handling:**\n  - Explain when to skip (build failures, unrelated changes)\n  - Warn that excessive skipping reduces effectiveness\n  - Show how many commits have been skipped\n\n### After Bisect\n\n- **Confirmation before reset:**\n  - Ask if user wants to save any notes\n  - Offer to create branch at bug commit\n  - Confirm reset operation\n\n- **Verify return state:**\n  - Check user is back on original branch\n  - Verify working directory is clean\n  - Confirm bisect refs are removed\n\n## Error Handling\n\n### Invalid Commit References\n\n```bash\nif ! git rev-parse --verify \"$commit_ref\" >/dev/null 2>&1; then\n  echo \"Error: '$commit_ref' is not a valid commit reference\"\n  echo \"Valid formats:\"\n  echo \"  - Commit hash: abc1234 or abc1234567890abcdef\"\n  echo \"  - Branch name: main, feature-branch\"\n  echo \"  - Tag: v1.0.0\"\n  echo \"  - Relative: HEAD~5, HEAD^^^\"\n  exit 1\nfi\n```\n\n### Good Commit is Newer Than Bad Commit\n\n```bash\nif [ $(git rev-list --count $good_commit..$bad_commit) -eq 0 ]; then\n  echo \"Error: Good commit ($good_commit) is not an ancestor of bad commit ($bad_commit)\"\n  echo \"Make sure:\"\n  echo \"  - Good commit is older (bug didn't exist yet)\"\n  echo \"  - Bad commit is newer (bug exists)\"\n  echo \"  - Both commits are on the same branch history\"\n  exit 1\nfi\n```\n\n### Build Failures\n\n```bash\n# When user reports commit won't build\necho \"This commit won't build/test. Options:\"\necho \"  1. Skip this commit: git bisect skip\"\necho \"  2. Skip a range: git bisect skip v1.0..v1.5\"\necho \"  3. Reset and try different good/bad commits\"\n# Wait for user choice\n```\n\n### Conflicts or Issues\n\n```bash\n# If checkout fails during bisect\nif [ $? -ne 0 ]; then\n  echo \"Error: Could not checkout commit\"\n  echo \"This might indicate:\"\n  echo \"  - Local modifications conflict with commit\"\n  echo \"  - Repository corruption\"\n  echo \"Run 'git bisect reset' to abort and investigate\"\n  exit 1\nfi\n```\n\n## Examples\n\n### Example 1: Basic Interactive Bisect\n\n```bash\n# Start interactive bisect\n/git:bisect\n\n# Claude will prompt:\n# \"When did you last see the code working correctly?\"\n# User: \"On the v1.2.0 tag\"\n#\n# \"When did you first notice the bug?\"\n# User: \"In the current commit (HEAD)\"\n#\n# Starting bisect with 47 commits between v1.2.0 and HEAD\n# This will take approximately 6 steps\n#\n# Now at: commit abc1234\n# Author: John Doe\n# Date: 2025-10-15\n# Message: Refactor authentication module\n#\n# Files changed:\n#   src/auth.js | 45 +++++++++++++++++++++\n#   tests/auth.test.js | 23 +++++++++++\n#\n# Please test if the bug exists in this commit.\n# Reply with: good, bad, skip, or abort\n```\n\n### Example 2: Direct Mode Commands\n\n```bash\n# Start bisect directly\n/git:bisect start\n\n# Mark HEAD as bad\n/git:bisect bad\n\n# Mark a specific commit as good\n/git:bisect good v1.2.0\n\n# Skip untestable commit\n/git:bisect skip\n\n# View bisect log\ngit bisect log\n\n# Reset and return to original state\n/git:bisect reset\n```\n\n### Example 3: Automated Testing\n\n```bash\n# For repositories with automated tests\n/git:bisect\n\n# At each commit, run:\nnpm test  # or: pytest, cargo test, go test, etc.\n\n# If tests pass:\n/git:bisect good\n\n# If tests fail:\n/git:bisect bad\n\n# Continue until bug commit found\n```\n\n### Example 4: Binary Search Range\n\n```bash\n# Search within specific range\n/git:bisect start HEAD v1.0.0\n\n# Or use commit hashes\n/git:bisect start abc1234 def5678\n\n# Or use date-based references\n/git:bisect start HEAD HEAD@{2.weeks.ago}\n```\n\n## Advanced Usage\n\n### Bisect with Script\n\nFor fully automated bisecting when you have a test that can determine good/bad:\n\n```bash\n# Create a test script that exits 0 for good, 1 for bad\ncat > test-bug.sh << 'EOF'\n#!/bin/bash\nnpm test -- --testNamePattern=\"specific bug test\"\nEOF\nchmod +x test-bug.sh\n\n# Run bisect with script\ngit bisect start HEAD v1.0.0\ngit bisect run ./test-bug.sh\n```\n\n### Visualize Bisect State\n\n```bash\n# Text-based visualization\ngit bisect visualize --oneline\n\n# Or with gitk (if available)\ngit bisect visualize\n```\n\n### Skip a Range of Commits\n\n```bash\n# If you know commits in a range are all untestable\ngit bisect skip v1.1.0..v1.2.0\n```\n\n### Bisect Log Analysis\n\n```bash\n# View complete bisect log\ngit bisect log\n\n# Replay bisect from log\ngit bisect replay path/to/bisect-log.txt\n```\n\n## Tips for Effective Bisecting\n\n1. **Choose good starting points:**\n   - Good commit: Use a tagged release where you know code worked\n   - Bad commit: Use the commit where you first noticed the bug\n   - Wider range = more accurate, but more steps\n\n2. **Have a clear test:**\n   - Know exactly what behavior indicates the bug\n   - Have a reproducible test case\n   - Ideally have an automated test\n\n3. **Handle build failures:**\n   - Skip commits that won't build\n   - If too many skip, widen the initial range\n\n4. **Track progress:**\n   - Note down commit hashes you've tested\n   - Keep test results consistent\n   - Don't change test criteria mid-bisect\n\n5. **When bug commit found:**\n   - Verify it's truly the first bad commit\n   - Check if bug is in the commit itself or its merge\n   - Look at what changed in that commit\n\n## Output Format\n\nDuring bisect, Claude will display structured output:\n\n```\n========================================\nGit Bisect Status\n========================================\nRange: v1.2.0 (good) → HEAD (bad)\nTotal commits: 47\nEstimated steps: 6 remaining\n\nCurrent Commit:\n----------------------------------------\nHash: abc1234567890abcdef\nAuthor: Jane Smith <jane@example.com>\nDate: Mon Oct 16 14:32:10 2025 -0700\nMessage: Update user authentication flow\n\nFiles Changed (5):\n  src/auth/login.js       | 34 +++++++++++++++---\n  src/auth/session.js     | 12 +++++--\n  tests/auth/login.test.js| 45 ++++++++++++++++++++++++\n  ...\n\n========================================\nAction Required:\n----------------------------------------\n1. Test if bug exists in this commit\n2. Reply with result:\n   - 'good' - bug does NOT exist\n   - 'bad'  - bug DOES exist\n   - 'skip' - cannot test this commit\n   - 'abort' - stop bisect\n\nWhat's your result?\n```\n\n## Related Commands\n\n- `/git:reflog-recover` - Recover from bisect mistakes\n- `/git:cherry-pick-helper` - Cherry-pick the bug fix\n- `/git:worktree` - Test multiple commits simultaneously\n- `/git:branch-cleanup` - Clean up bisect test branches"
              },
              {
                "name": "/branch-cleanup",
                "description": "Clean up merged and stale branches locally and remotely with comprehensive safety checks",
                "path": "plugins/utilities/git/commands/branch-cleanup.md",
                "frontmatter": {
                  "name": "git:branch-cleanup",
                  "description": "Clean up merged and stale branches locally and remotely with comprehensive safety checks"
                },
                "content": "# Git Branch Cleanup - Merged and Stale Branch Management\n\nClean up merged and stale branches locally and remotely with comprehensive safety checks.\n\n## Command\n\n`/git:branch-cleanup [scope] [base-branch]`\n\n## Arguments\n\n- `$1`: scope - `local|remote|both` (default: `local`)\n- `$2`: base-branch - Branch to check merges against (default: `main` or `master`)\n\n## Description\n\nOver time, repositories accumulate branches from completed features, merged pull requests, and abandoned work. Branch cleanup helps maintain repository hygiene by identifying and safely removing branches that are no longer needed, while protecting active and important branches.\n\n## Use Cases\n\n- Clean up after merged pull requests\n- Remove abandoned feature branches\n- Prepare repository for new work\n- Reduce clutter in branch listings\n- Find stale branches that need attention\n- Audit branch activity across team\n- Free up branch names for reuse\n\n## Branch Categories\n\nBranches are classified into categories:\n\n1. **Fully Merged** - Safe to delete\n   - All commits are in base branch\n   - Feature complete and merged\n   - No unique changes\n\n2. **Partially Merged** - Review before delete\n   - Some commits merged\n   - May have additional work\n   - Requires investigation\n\n3. **Stale** - No activity for long period\n   - No commits in 90+ days\n   - May be abandoned\n   - Should be reviewed before delete\n\n4. **Active** - Recent activity\n   - Commits within last 30 days\n   - Likely still in use\n   - Should not be deleted\n\n5. **Protected** - Never delete\n   - main, master, develop\n   - production, staging\n   - release branches\n   - Explicitly configured protected branches\n\n## Workflow\n\n### Initial Analysis\n\n1. **Identify base branch:**\n   - Check for main or master\n   - Use user-specified branch if provided\n   - Validate base branch exists\n\n2. **Gather branch information:**\n   ```bash\n   # List all branches\n   git branch -a\n\n   # For each branch, get:\n   # - Last commit date\n   # - Last author\n   # - Commit count ahead/behind\n   # - Merge status\n   ```\n\n3. **Categorize branches:**\n   - Sort into categories (merged, stale, active, protected)\n   - Calculate statistics for each category\n   - Prepare summary report\n\n4. **Show summary:**\n   ```\n   Branch Cleanup Analysis\n   ==================================================\n   Base branch: main\n   Scope: local branches\n\n   Categories:\n     Fully merged:     12 branches\n     Stale (90+ days): 5 branches\n     Active (<30 days): 8 branches\n     Protected:        3 branches (will not delete)\n\n   Total branches: 28\n   Safe to delete: 12 branches\n   ```\n\n### Local Branch Cleanup\n\n5. **List fully merged branches:**\n   ```bash\n   git branch --merged <base-branch>\n   ```\n\n6. **For each merged branch show:**\n   - Branch name\n   - Last commit date\n   - Last author\n   - Commit message\n   - Days since last commit\n\n7. **Exclude protected branches:**\n   - main, master\n   - develop, development\n   - staging, production\n   - release/*, hotfix/*\n   - Current branch\n\n8. **Show deletion plan:**\n   ```\n   Fully Merged Branches (12):\n   ==================================================\n   1. feature/user-auth\n      Last: 2025-09-15 (36 days ago)\n      By: John Doe\n      \"Add JWT authentication\"\n\n   2. bugfix/login-error\n      Last: 2025-08-30 (52 days ago)\n      By: Jane Smith\n      \"Fix login redirect issue\"\n\n   ...\n   ```\n\n9. **Ask for confirmation:**\n   - Show dry-run option\n   - Allow individual selection\n   - Allow batch selection\n   - Offer to skip\n\n10. **Delete local branches:**\n    ```bash\n    git branch -d <branch-name>\n    ```\n\n    Or force delete if needed:\n    ```bash\n    git branch -D <branch-name>\n    ```\n\n### Stale Branch Handling\n\n11. **Identify stale branches:**\n    ```bash\n    # Branches with no commits in 90+ days\n    git for-each-ref --sort=-committerdate refs/heads/\n    ```\n\n12. **Show stale branches:**\n    - Branch name\n    - Last commit date (days ago)\n    - Last author\n    - Merged status\n    - Commit count unique to branch\n\n13. **For each stale branch:**\n    - Show details\n    - Check if merged (even if old)\n    - Check for unique commits\n    - Ask user for action:\n      - Delete (if safe)\n      - Keep (still needed)\n      - Review (show more details)\n\n### Remote Branch Cleanup\n\n14. **Analyze remote branches:**\n    ```bash\n    git branch -r --merged <base-branch>\n    ```\n\n15. **Cross-reference with local:**\n    - Remote branches without local counterpart\n    - Remote branches that are merged\n    - Remote branches that are stale\n\n16. **Show remote deletion plan:**\n    - More cautious than local\n    - Double-check merge status\n    - Verify no open pull requests\n    - Confirm team coordination\n\n17. **Delete remote branches:**\n    ```bash\n    git push origin --delete <branch-name>\n    ```\n\n18. **Prune remote tracking branches:**\n    ```bash\n    git fetch --prune\n    git remote prune origin\n    ```\n\n### Post-Cleanup\n\n19. **Show cleanup summary:**\n    - Branches deleted (count and names)\n    - Branches skipped\n    - Branches protected\n    - Space saved (if measurable)\n\n20. **Verify repository state:**\n    - Show remaining branches\n    - Verify no unintended deletions\n    - Check current branch still exists\n\n21. **Offer additional actions:**\n    - Push cleanup to remote\n    - Archive deleted branches (tags)\n    - Export branch list before deletion\n    - Clean up remote tracking branches\n\n## Safety Checks\n\n### Before Any Deletion\n\n- **Protected branches list:**\n  ```bash\n  PROTECTED_BRANCHES=(\n    \"main\"\n    \"master\"\n    \"develop\"\n    \"development\"\n    \"staging\"\n    \"production\"\n    \"release\"\n  )\n\n  for protected in \"${PROTECTED_BRANCHES[@]}\"; do\n    if [[ \"$branch\" == \"$protected\" ]] || [[ \"$branch\" == \"$protected\"/* ]]; then\n      echo \"Skipping protected branch: $branch\"\n      continue\n    fi\n  done\n  ```\n\n- **Current branch check:**\n  ```bash\n  current_branch=$(git branch --show-current)\n  if [ \"$branch\" = \"$current_branch\" ]; then\n    echo \"Error: Cannot delete current branch: $branch\"\n    echo \"Switch to a different branch first\"\n    exit 1\n  fi\n  ```\n\n- **Base branch check:**\n  ```bash\n  if [ \"$branch\" = \"$base_branch\" ]; then\n    echo \"Error: Cannot delete base branch: $base_branch\"\n    echo \"This is the branch we're comparing against!\"\n    exit 1\n  fi\n  ```\n\n### Local Branch Deletion\n\n- **Merged status verification:**\n  ```bash\n  if git branch --merged $base_branch | grep -q \"^[* ] $branch$\"; then\n    echo \"✓ Branch is fully merged into $base_branch\"\n    merge_status=\"safe\"\n  else\n    echo \"⚠ Branch is NOT fully merged\"\n    unmerged_commits=$(git log $base_branch..$branch --oneline | wc -l)\n    echo \"  $unmerged_commits unique commit(s) will be lost\"\n    echo \"\"\n    echo \"Show commits? (y/n)\"\n    # If yes: git log $base_branch..$branch\n    merge_status=\"unsafe\"\n  fi\n  ```\n\n- **Force delete confirmation:**\n  ```bash\n  if [ \"$merge_status\" = \"unsafe\" ]; then\n    echo \"Branch '$branch' has unmerged commits!\"\n    echo \"Force delete will PERMANENTLY lose these commits\"\n    echo \"\"\n    git log --oneline $base_branch..$branch\n    echo \"\"\n    echo \"Type 'DELETE' to force delete: \"\n    read confirmation\n    [ \"$confirmation\" != \"DELETE\" ] && continue\n\n    # Use -D instead of -d\n    git branch -D $branch\n  fi\n  ```\n\n### Remote Branch Deletion\n\n- **Remote reference check:**\n  ```bash\n  if ! git ls-remote --heads origin $branch | grep -q $branch; then\n    echo \"Branch '$branch' does not exist on remote\"\n    continue\n  fi\n  ```\n\n- **Pull request check:**\n  ```bash\n  # If GitHub CLI available\n  if command -v gh &> /dev/null; then\n    pr_count=$(gh pr list --head $branch --json number --jq 'length')\n    if [ $pr_count -gt 0 ]; then\n      echo \"Warning: Branch '$branch' has open pull request(s)\"\n      echo \"View: gh pr view --web\"\n      echo \"\"\n      echo \"Delete anyway? (y/n)\"\n      read confirm\n      [ \"$confirm\" != \"y\" ] && continue\n    fi\n  fi\n  ```\n\n- **Team coordination warning:**\n  ```bash\n  echo \"⚠ REMOTE DELETION WARNING\"\n  echo \"You are about to delete remote branch: origin/$branch\"\n  echo \"\"\n  echo \"This affects other developers if they:\"\n  echo \"  - Have this branch checked out\"\n  echo \"  - Have based work on this branch\"\n  echo \"  - Have unpushed commits on this branch\"\n  echo \"\"\n  echo \"Have you coordinated with your team? (y/n)\"\n  read coordinated\n  [ \"$coordinated\" != \"y\" ] && continue\n  ```\n\n### Batch Deletion Safety\n\n- **Dry-run mode:**\n  ```bash\n  echo \"DRY-RUN MODE\"\n  echo \"Would delete these branches:\"\n  for branch in \"${branches_to_delete[@]}\"; do\n    echo \"  - $branch\"\n  done\n  echo \"\"\n  echo \"Proceed with actual deletion? (y/n)\"\n  ```\n\n- **Confirmation for bulk delete:**\n  ```bash\n  if [ ${#branches_to_delete[@]} -gt 5 ]; then\n    echo \"About to delete ${#branches_to_delete[@]} branches\"\n    echo \"This is a bulk operation!\"\n    echo \"\"\n    echo \"Type 'CONFIRM BULK DELETE' to proceed: \"\n    read confirmation\n    [ \"$confirmation\" != \"CONFIRM BULK DELETE\" ] && exit 0\n  fi\n  ```\n\n## Error Handling\n\n### Branch Not Fully Merged\n\n```bash\nif ! git branch -d $branch 2>&1; then\n  error=$(git branch -d $branch 2>&1)\n  if echo \"$error\" | grep -q \"not fully merged\"; then\n    echo \"Error: Branch '$branch' is not fully merged\"\n    echo \"\"\n    echo \"Options:\"\n    echo \"  1. Skip this branch\"\n    echo \"  2. Force delete (lose commits): git branch -D $branch\"\n    echo \"  3. Show unmerged commits: git log $base_branch..$branch\"\n    echo \"  4. Merge branch first: git merge $branch\"\n    echo \"\"\n    echo \"What would you like to do? (1-4)\"\n  fi\nfi\n```\n\n### Remote Deletion Failure\n\n```bash\nif ! git push origin --delete $branch 2>&1; then\n  error=$(git push origin --delete $branch 2>&1)\n\n  if echo \"$error\" | grep -q \"remote ref does not exist\"; then\n    echo \"Branch '$branch' does not exist on remote\"\n    echo \"Might already be deleted\"\n  elif echo \"$error\" | grep -q \"protected\"; then\n    echo \"Branch '$branch' is protected on remote\"\n    echo \"Cannot delete via git push\"\n    echo \"Delete via GitHub/GitLab UI if needed\"\n  elif echo \"$error\" | grep -q \"permission denied\"; then\n    echo \"Permission denied: cannot delete remote branch\"\n    echo \"You may not have push access\"\n  else\n    echo \"Unknown error deleting remote branch:\"\n    echo \"$error\"\n  fi\nfi\n```\n\n### No Branches to Delete\n\n```bash\nif [ ${#branches_to_delete[@]} -eq 0 ]; then\n  echo \"No branches to delete!\"\n  echo \"\"\n  echo \"All branches are either:\"\n  echo \"  - Protected branches\"\n  echo \"  - Not fully merged\"\n  echo \"  - Recently active\"\n  echo \"  - Current branch\"\n  echo \"\"\n  echo \"Repository is clean!\"\n  exit 0\nfi\n```\n\n### Base Branch Not Found\n\n```bash\nif ! git rev-parse --verify $base_branch >/dev/null 2>&1; then\n  echo \"Error: Base branch '$base_branch' not found\"\n  echo \"\"\n  echo \"Available branches:\"\n  git branch -a | grep -E \"(main|master|develop)\" | sed 's/^[* ] //'\n  echo \"\"\n  echo \"Specify base branch as second argument:\"\n  echo \"  /git:branch-cleanup local main\"\n  exit 1\nfi\n```\n\n## Examples\n\n### Example 1: Interactive Local Cleanup\n\n```bash\n/git:branch-cleanup local\n\n# Analyzing branches...\n# Base branch: main\n#\n# ========================================\n# Branch Cleanup Analysis\n# ========================================\n#\n# Fully Merged (8 branches):\n# ------------------------------------------\n# 1. feature/user-auth\n#    Last: 36 days ago by John Doe\n#    \"Add JWT authentication\"\n#\n# 2. bugfix/login-error\n#    Last: 52 days ago by Jane Smith\n#    \"Fix login redirect issue\"\n#\n# ... (6 more)\n#\n# Stale Branches (3 branches):\n# ------------------------------------------\n# 1. feature/old-idea\n#    Last: 127 days ago by Bob Johnson\n#    NOT merged - 15 unique commits\n#\n# ... (2 more)\n#\n# Protected (3 branches):\n# ------------------------------------------\n# - main (current)\n# - develop\n# - staging\n#\n# ========================================\n# Actions:\n# ========================================\n# [1] Delete all fully merged branches\n# [2] Review and delete individually\n# [3] Handle stale branches\n# [4] Show more details\n# [5] Cancel\n#\n# Choice: 2\n#\n# Delete 'feature/user-auth'? (y/n/details)\n# User: y\n# ✓ Deleted feature/user-auth\n#\n# Delete 'bugfix/login-error'? (y/n/details)\n# User: y\n# ✓ Deleted bugfix/login-error\n#\n# ...\n#\n# Summary:\n# ✓ Deleted 6 branches\n# ✗ Skipped 2 branches\n# ⚠ 3 stale branches need review\n```\n\n### Example 2: Batch Delete Merged Branches\n\n```bash\n/git:branch-cleanup local main\n\n# Found 12 fully merged branches\n# Show list? (y/n)\n# User: y\n#\n# [Shows list of 12 branches...]\n#\n# Delete all? (y/n/select)\n# User: y\n#\n# DRY-RUN: Would delete:\n#   feature/user-auth\n#   feature/api-v2\n#   bugfix/login-error\n#   ... (9 more)\n#\n# Proceed? (y/n)\n# User: y\n#\n# Deleting branches...\n# ✓ feature/user-auth\n# ✓ feature/api-v2\n# ✓ bugfix/login-error\n# ...\n#\n# Deleted 12 branches successfully\n```\n\n### Example 3: Remote Branch Cleanup\n\n```bash\n/git:branch-cleanup remote origin/main\n\n# ⚠ REMOTE CLEANUP WARNING\n# This will delete branches from origin\n# Other developers may be affected\n#\n# Have you coordinated with your team? (y/n)\n# User: y\n#\n# Analyzing remote branches...\n#\n# Merged remote branches (15):\n# ------------------------------------------\n# origin/feature/completed-feature-1\n# origin/feature/completed-feature-2\n# origin/bugfix/old-fix\n# ... (12 more)\n#\n# Checking for open pull requests...\n# ✓ No open PRs found for these branches\n#\n# Delete remote branches? (y/n)\n# User: y\n#\n# Deleting remote branches...\n# ✓ Deleted origin/feature/completed-feature-1\n# ✓ Deleted origin/feature/completed-feature-2\n# ...\n#\n# Pruning remote tracking branches...\n# ✓ Pruned 15 remote tracking branches\n#\n# Summary:\n# Deleted 15 remote branches\n# Your local branches were not affected\n```\n\n### Example 4: Handle Stale Branches\n\n```bash\n/git:branch-cleanup local\n\n# ...\n# Stale Branches (4 branches):\n# ------------------------------------------\n#\n# 1. feature/experimental-ui\n#    Last: 145 days ago by Alice Cooper\n#    NOT merged - 23 unique commits\n#    Show details? (y/n/delete/keep)\n#    User: y\n#\n#    Branch details:\n#    Created: 2025-06-01\n#    Last commit: 2025-06-28\n#    Commits ahead: 23\n#    Commits behind: 127\n#\n#    Recent commits:\n#      abc1234 - Experiment with new layout\n#      def5678 - Add animation effects\n#      ... (21 more)\n#\n#    Action for this branch?\n#      [d] Delete (lose 23 commits)\n#      [k] Keep (skip)\n#      [t] Tag and delete (archive)\n#      [b] Create backup branch\n#    User: t\n#\n#    Creating archive tag: archive/experimental-ui\n#    ✓ Tag created\n#    ✓ Branch deleted\n#\n#    To restore: git checkout -b feature/experimental-ui archive/experimental-ui\n```\n\n### Example 5: Cleanup Both Local and Remote\n\n```bash\n/git:branch-cleanup both\n\n# This will clean up both local and remote branches\n# Base branch: main\n#\n# Phase 1: Local Analysis\n# ========================================\n# Fully merged: 8 branches\n# Stale: 3 branches\n#\n# Phase 2: Remote Analysis\n# ========================================\n# Fully merged: 12 branches\n# Stale: 5 branches\n#\n# Total branches to clean: 20\n#\n# Proceed with cleanup? (y/n/review)\n# User: review\n#\n# [Shows detailed lists...]\n#\n# Start cleanup? (y/n)\n# User: y\n#\n# Cleaning local branches...\n# ✓ Deleted 8 local branches\n#\n# Cleaning remote branches...\n# ⚠ This affects other developers!\n# Continue? (y/n)\n# User: y\n#\n# ✓ Deleted 12 remote branches\n# ✓ Pruned remote tracking branches\n#\n# Total Summary:\n# ✓ 8 local branches deleted\n# ✓ 12 remote branches deleted\n# ⚠ 8 stale branches need review\n```\n\n## Advanced Usage\n\n### Archive Branches Before Deletion\n\n```bash\n# Create tags for branches before deleting\nfor branch in \"${branches_to_delete[@]}\"; do\n  git tag \"archive/$branch\" \"$branch\"\n  git branch -d \"$branch\"\ndone\n\n# Push archive tags\ngit push origin --tags\n\n# Later restore:\ngit checkout -b restored-branch archive/branch-name\n```\n\n### Export Branch List\n\n```bash\n# Save branch list before cleanup\ngit for-each-ref --format='%(refname:short) %(committerdate:iso8601) %(authorname)' refs/heads/ > branches-$(date +%Y%m%d).txt\n```\n\n### Filter by Author\n\n```bash\n# Find all branches by specific author\ngit for-each-ref --format='%(refname:short) %(authorname)' refs/heads/ | grep \"John Doe\"\n\n# Delete branches by author\n/git:branch-cleanup local --author=\"John Doe\"\n```\n\n### Custom Stale Period\n\n```bash\n# Consider branches stale after 60 days instead of 90\n/git:branch-cleanup local --stale-days=60\n```\n\n### Batch Operations with jq\n\n```bash\n# Get merged branches as JSON\ngit branch --merged main --format='%(refname:short)' | jq -R -s -c 'split(\"\\n\")[:-1]'\n\n# Programmatic deletion\ngit branch --merged main --format='%(refname:short)' | grep -v \"^main$\" | xargs -n 1 git branch -d\n```\n\n## Tips for Maintaining Clean Branches\n\n1. **Regular cleanup schedule:**\n   - Weekly: Review active branches\n   - Monthly: Clean up merged branches\n   - Quarterly: Review stale branches\n   - Set calendar reminders\n\n2. **Branch naming conventions:**\n   - Use prefixes: feature/, bugfix/, hotfix/\n   - Include ticket numbers: feature/JIRA-123-description\n   - Makes it easier to identify purpose\n\n3. **Delete after merge:**\n   - Delete branches immediately after PR merge\n   - GitHub/GitLab can auto-delete\n   - Don't let branches accumulate\n\n4. **Protected branch policies:**\n   - Configure protected branches in repo settings\n   - Prevent accidental deletion\n   - Require PR reviews\n\n5. **Team communication:**\n   - Announce before remote cleanup\n   - Check with team before deleting shared branches\n   - Use Slack/Teams to coordinate\n\n6. **Branch limits:**\n   - Keep total branches under 50\n   - If more, time for cleanup\n   - Too many branches = confusion\n\n## Related Commands\n\n- `/git:worktree` - Use worktrees instead of branches for parallel work\n- `/git:cherry-pick-helper` - Cherry-pick commits before deleting branch\n- `/git:reflog-recover` - Recover accidentally deleted branches\n- `/git:rebase-interactive` - Clean up commits before merging"
              },
              {
                "name": "/cherry-pick-helper",
                "description": "Guided cherry-pick workflow with conflict resolution assistance for selectively applying commits across branches",
                "path": "plugins/utilities/git/commands/cherry-pick-helper.md",
                "frontmatter": {
                  "name": "git:cherry-pick-helper",
                  "description": "Guided cherry-pick workflow with conflict resolution assistance for selectively applying commits across branches"
                },
                "content": "# Git Cherry-Pick Helper - Guided Commit Selection\n\nGuided cherry-pick workflow with conflict resolution assistance for selectively applying commits across branches.\n\n## Command\n\n`/git:cherry-pick-helper <commit-ref> [additional-refs...]`\n\n## Arguments\n\n- `$1`: commit-ref - Commit hash or reference to cherry-pick (required)\n- `$2+`: additional-refs - Additional commits to cherry-pick (optional, space-separated)\n\n## Description\n\nCherry-picking allows you to apply specific commits from one branch to another without merging the entire branch. This is useful for backporting bug fixes, applying specific features, or selectively moving work between branches.\n\n## When to Use Cherry-Pick\n\n- Backport bug fix to release branch\n- Apply hotfix from main to feature branch\n- Move specific commits to different branch\n- Recover commits from deleted branch\n- Apply commits from someone else's branch\n- Split work from one branch to multiple\n- Test specific changes in isolation\n\n## When NOT to Use Cherry-Pick\n\n- Can merge entire branch (use merge instead)\n- Commits depend on other commits not being picked\n- Would create duplicate history (rebase better)\n- On public/shared branches (coordinate with team)\n- Just testing changes (use worktree or stash)\n\n## Workflow\n\n### Pre-Cherry-Pick Analysis\n\n1. **Validate commit reference:**\n   - Check commit exists\n   - Verify commit is reachable\n   - Can be from any branch or remote\n\n2. **Show commit details:**\n   ```bash\n   git show --stat <commit-ref>\n   ```\n\n   Display:\n   - Commit hash (full and short)\n   - Author and date\n   - Commit message\n   - Files changed with stats\n   - Number of insertions/deletions\n\n3. **Analyze commit context:**\n   - Show parent commits\n   - Check if part of merge commit\n   - Identify dependencies\n   - Warn about potential issues\n\n4. **Check current branch:**\n   - Show current branch name\n   - Verify branch is clean\n   - Check for uncommitted changes\n   - Show last commit on current branch\n\n5. **Predict conflicts:**\n   - Compare files in commit with current branch\n   - Check if same files modified\n   - Show potential conflict files\n   - Estimate conflict probability\n\n### Confirmation\n\n6. **Show cherry-pick plan:**\n   ```\n   Cherry-Pick Plan:\n   ========================================\n   Target Branch: feature-auth\n   Source Commit: abc1234 from main\n\n   Commit Details:\n   - Author: John Doe\n   - Date: 2025-10-20\n   - Message: Fix authentication token validation\n\n   Files to Apply:\n   - src/auth/token.js     (+15, -8)\n   - src/auth/session.js   (+7, -3)\n   - tests/auth/token.test.js (+45, -0)\n\n   Potential Issues:\n   ⚠ src/auth/token.js was modified in this branch\n   ✓ Other files should apply cleanly\n\n   Continue? (y/n/details)\n   ```\n\n7. **Offer options:**\n   - Proceed with cherry-pick\n   - Show detailed diff first\n   - Show file-by-file changes\n   - Cancel operation\n\n### Execute Cherry-Pick\n\n8. **Perform cherry-pick:**\n   ```bash\n   git cherry-pick <commit-ref>\n   ```\n\n9. **For multiple commits:**\n   ```bash\n   git cherry-pick <ref1> <ref2> <ref3>\n   ```\n\n   Or range:\n   ```bash\n   git cherry-pick <start-ref>^..<end-ref>\n   ```\n\n10. **Monitor progress:**\n    - Show which commit being applied\n    - Display progress for multiple picks\n    - Real-time status updates\n\n### Success Case\n\n11. **If cherry-pick succeeds:**\n    - Show new commit hash\n    - Display commit message\n    - Show files changed\n    - Verify commit applied correctly\n\n12. **Post-pick verification:**\n    - Show git log with new commit\n    - Display branch status\n    - Suggest running tests\n    - Offer to cherry-pick more commits\n\n### Conflict Resolution\n\n13. **If conflicts occur:**\n    - Stop cherry-pick process\n    - List conflicted files\n    - Show conflict markers\n    - Explain current state\n\n14. **For each conflicted file:**\n    - Show conflict details:\n      ```bash\n      git diff <file>\n      ```\n    - Explain conflict sections:\n      - `<<<<<<< HEAD` - Current branch changes\n      - `=======` - Separator\n      - `>>>>>>> <commit>` - Cherry-picked changes\n    - Show full file context\n\n15. **Resolution options:**\n    - Manually edit files\n    - Accept theirs (cherry-picked version)\n    - Accept ours (current version)\n    - Use merge tool\n    - Abort cherry-pick\n\n16. **Guide through resolution:**\n    ```\n    Conflict Resolution:\n    ========================================\n    File: src/auth/token.js\n\n    Conflict:\n    <<<<<<< HEAD\n    function validateToken(token) {\n      return checkSignature(token);\n    }\n    =======\n    function validateToken(token) {\n      return checkSignature(token) && !isExpired(token);\n    }\n    >>>>>>> abc1234 Fix authentication token validation\n\n    Options:\n    1. Edit manually\n    2. Accept cherry-picked version (includes expiry check)\n    3. Accept current version (no expiry check)\n    4. Show more context\n    5. Use merge tool\n\n    Choice: 2\n\n    Accepting cherry-picked version...\n    ```\n\n17. **After resolving each file:**\n    - Stage resolved file\n    - Show remaining conflicts\n    - Continue when all resolved\n\n18. **Complete cherry-pick:**\n    ```bash\n    git add <resolved-files>\n    git cherry-pick --continue\n    ```\n\n### Abort or Skip\n\n19. **Abort cherry-pick:**\n    ```bash\n    git cherry-pick --abort\n    ```\n    - Returns to state before cherry-pick\n    - No changes applied\n    - Safe to retry\n\n20. **Skip commit:**\n    ```bash\n    git cherry-pick --skip\n    ```\n    - Skip current commit\n    - Continue with remaining commits\n    - Use when commit not needed\n\n### Multiple Commits\n\n21. **For cherry-pick sequence:**\n    - Apply commits in order\n    - Pause at conflicts\n    - Resume after resolution\n    - Track progress through list\n\n22. **Show sequence progress:**\n    ```\n    Cherry-Pick Sequence:\n    ========================================\n    Total: 5 commits\n    Progress: 3/5\n\n    ✓ abc1234 - Fix token validation\n    ✓ def5678 - Add session timeout\n    → ghi9012 - Update user model [CONFLICT]\n    ⋯ jkl3456 - Add tests\n    ⋯ mno7890 - Update docs\n\n    Current: ghi9012\n    Resolve conflicts then continue\n    ```\n\n## Safety Checks\n\n### Before Cherry-Pick\n\n- **Clean working directory:**\n  ```bash\n  if [ -n \"$(git status --porcelain)\" ]; then\n    echo \"Error: Working directory has uncommitted changes\"\n    echo \"\"\n    git status --short\n    echo \"\"\n    echo \"Cherry-pick requires clean working directory\"\n    echo \"Options:\"\n    echo \"  1. Commit changes: git commit\"\n    echo \"  2. Stash changes: git stash\"\n    echo \"  3. Discard changes: git restore .\"\n    exit 1\n  fi\n  ```\n\n- **Commit exists:**\n  ```bash\n  if ! git cat-file -e \"$commit_ref\" 2>/dev/null; then\n    echo \"Error: Commit not found: $commit_ref\"\n    echo \"\"\n    echo \"Make sure commit exists in repository\"\n    echo \"Try:\"\n    echo \"  git fetch --all  # Update remote branches\"\n    echo \"  git log --all --oneline | grep <search>\"\n    exit 1\n  fi\n  ```\n\n- **Not a merge commit:**\n  ```bash\n  parent_count=$(git rev-list --parents -n1 \"$commit_ref\" | wc -w)\n  if [ $parent_count -gt 2 ]; then\n    echo \"Warning: This is a merge commit\"\n    echo \"Merge commits: $(($parent_count - 1)) parents\"\n    echo \"\"\n    echo \"Cherry-picking merge commits is complex\"\n    echo \"You must specify which parent to use:\"\n    echo \"  git cherry-pick -m 1 $commit_ref  # Use first parent\"\n    echo \"  git cherry-pick -m 2 $commit_ref  # Use second parent\"\n    echo \"\"\n    echo \"Continue anyway? (y/n)\"\n    read confirm\n    [ \"$confirm\" != \"y\" ] && exit 0\n  fi\n  ```\n\n- **Commit not already applied:**\n  ```bash\n  # Check if commit already in current branch\n  if git log --format=%H | grep -q \"$(git rev-parse $commit_ref)\"; then\n    echo \"Warning: This commit already exists in current branch\"\n    echo \"Commit: $commit_ref\"\n    echo \"\"\n    echo \"Cherry-picking will create duplicate commit\"\n    echo \"Continue? (y/n)\"\n    read confirm\n    [ \"$confirm\" != \"y\" ] && exit 0\n  fi\n  ```\n\n### During Cherry-Pick\n\n- **Conflict detection:**\n  ```bash\n  if git cherry-pick \"$commit_ref\" 2>&1 | grep -q \"CONFLICT\"; then\n    echo \"Conflict detected!\"\n    echo \"\"\n    echo \"Conflicted files:\"\n    git diff --name-only --diff-filter=U\n    echo \"\"\n    echo \"Use cherry-pick helper to resolve\"\n    # Enter conflict resolution mode\n  fi\n  ```\n\n- **Cherry-pick in progress:**\n  ```bash\n  if [ -f \".git/CHERRY_PICK_HEAD\" ]; then\n    echo \"Cherry-pick in progress\"\n    echo \"\"\n    echo \"Status:\"\n    git status\n    echo \"\"\n    echo \"Options:\"\n    echo \"  1. Continue: Resolve conflicts and git cherry-pick --continue\"\n    echo \"  2. Abort: git cherry-pick --abort\"\n    echo \"  3. Skip: git cherry-pick --skip\"\n    exit 1\n  fi\n  ```\n\n### After Cherry-Pick\n\n- **Verify changes:**\n  ```bash\n  echo \"Cherry-pick complete!\"\n  echo \"\"\n  echo \"New commit: $(git rev-parse HEAD)\"\n  echo \"Original commit: $commit_ref\"\n  echo \"\"\n  echo \"Verify changes:\"\n  git show --stat HEAD\n  echo \"\"\n  echo \"Test your changes before pushing\"\n  ```\n\n- **Check for semantic conflicts:**\n  ```bash\n  echo \"⚠ Cherry-pick succeeded, but...\"\n  echo \"Check for semantic conflicts:\"\n  echo \"  - Function signatures changed?\"\n  echo \"  - Dependencies missing?\"\n  echo \"  - Tests still pass?\"\n  echo \"\"\n  echo \"Run tests:\"\n  echo \"  npm test\"\n  echo \"  pytest\"\n  echo \"  cargo test\"\n  ```\n\n## Error Handling\n\n### Commit Not Found\n\n```bash\nif ! git cat-file -e \"$commit_ref\" 2>/dev/null; then\n  echo \"Error: Commit not found: $commit_ref\"\n  echo \"\"\n  echo \"Possible reasons:\"\n  echo \"  - Typo in commit hash\"\n  echo \"  - Commit in different repository\"\n  echo \"  - Need to fetch from remote\"\n  echo \"\"\n  echo \"Try:\"\n  echo \"  git fetch --all\"\n  echo \"  git log --all --oneline | grep <keyword>\"\n  exit 1\nfi\n```\n\n### Cherry-Pick Failed\n\n```bash\nif ! git cherry-pick \"$commit_ref\"; then\n  error_type=$(git status | grep -o \"both modified\\|deleted by\\|added by\")\n\n  case \"$error_type\" in\n    \"both modified\")\n      echo \"Conflict: File modified in both branches\"\n      ;;\n    \"deleted by\")\n      echo \"Conflict: File deleted in one branch, modified in other\"\n      ;;\n    \"added by\")\n      echo \"Conflict: File added with different content\"\n      ;;\n  esac\n\n  echo \"\"\n  echo \"Resolution needed for:\"\n  git diff --name-only --diff-filter=U\n  exit 1\nfi\n```\n\n### Empty Cherry-Pick\n\n```bash\nif git cherry-pick \"$commit_ref\" 2>&1 | grep -q \"nothing to commit\"; then\n  echo \"Cherry-pick resulted in no changes\"\n  echo \"\"\n  echo \"This means:\"\n  echo \"  - Changes already exist in current branch\"\n  echo \"  - Commit was effectively empty\"\n  echo \"  - Changes were already reverted\"\n  echo \"\"\n  echo \"Options:\"\n  echo \"  1. Skip: git cherry-pick --skip\"\n  echo \"  2. Abort: git cherry-pick --abort\"\n  exit 1\nfi\n```\n\n## Examples\n\n### Example 1: Cherry-Pick Single Commit\n\n```bash\n/git:cherry-pick-helper abc1234\n\n# Analyzing commit abc1234...\n#\n# Commit Details:\n# ========================================\n# Hash: abc1234567890abcdef\n# Author: John Doe <john@example.com>\n# Date: Mon Oct 16 14:30:00 2025 -0700\n# Branch: main\n#\n# Message:\n#   Fix authentication token validation bug\n#\n#   Added expiry check to prevent expired tokens\n#   from being accepted.\n#\n# Files Changed (3):\n#   src/auth/token.js          | 15 ++++++++----\n#   src/auth/session.js        |  7 +++--\n#   tests/auth/token.test.js   | 45 +++++++++++++++++++++++++++++++\n#\n# Current Branch: feature-auth\n# Last Commit: def5678 Implement OAuth\n#\n# Conflict Check:\n# ⚠ Potential conflict: src/auth/token.js\n#   (modified in both branches)\n# ✓ Other files should apply cleanly\n#\n# Proceed with cherry-pick? (y/n/details)\n# User: y\n#\n# Cherry-picking abc1234...\n# Conflict in src/auth/token.js\n#\n# [Enters conflict resolution mode]\n# ...\n# [After resolution]\n#\n# ✓ Cherry-pick complete!\n# New commit: xyz9876\n# Changes applied to feature-auth branch\n```\n\n### Example 2: Cherry-Pick Multiple Commits\n\n```bash\n/git:cherry-pick-helper abc1234 def5678 ghi9012\n\n# Cherry-Pick Sequence:\n# ========================================\n# 3 commits to apply\n#\n# 1. abc1234 - Fix token validation\n# 2. def5678 - Add session timeout\n# 3. ghi9012 - Update user model\n#\n# Source: main\n# Target: feature-auth (current)\n#\n# Proceed? (y/n)\n# User: y\n#\n# [1/3] Cherry-picking abc1234...\n# ✓ Success (commit: aaa1111)\n#\n# [2/3] Cherry-picking def5678...\n# ✓ Success (commit: bbb2222)\n#\n# [3/3] Cherry-picking ghi9012...\n# ⚠ Conflict in src/models/user.js\n#\n# Resolve conflict and continue? (y/abort)\n# User: y\n#\n# [Shows conflict resolution UI]\n# ...\n# [After resolution]\n#\n# ✓ All commits cherry-picked successfully!\n# Applied 3 commits to feature-auth\n```\n\n### Example 3: Cherry-Pick Range\n\n```bash\n/git:cherry-pick-helper abc1234^..def5678\n\n# Cherry-Pick Range:\n# ========================================\n# From: abc1234 (inclusive)\n# To: def5678 (inclusive)\n# Count: 8 commits\n#\n# Commits:\n#   abc1234 - Fix token validation\n#   bcd2345 - Add session timeout\n#   cde3456 - Update user model\n#   def4567 - Add password reset\n#   efg5678 - Implement 2FA\n#   fgh6789 - Add audit logging\n#   ghi7890 - Update dependencies\n#   def5678 - Add tests\n#\n# Apply all 8 commits? (y/n/select)\n# User: select\n#\n# Select commits to cherry-pick (1-8, comma separated):\n# User: 1,2,4,5\n#\n# Will cherry-pick:\n#   abc1234 - Fix token validation\n#   bcd2345 - Add session timeout\n#   def4567 - Add password reset\n#   efg5678 - Implement 2FA\n#\n# Proceed? (y/n)\n# User: y\n#\n# [Applies selected commits...]\n```\n\n### Example 4: Conflict Resolution\n\n```bash\n/git:cherry-pick-helper abc1234\n\n# ...\n# Conflict in src/auth/token.js\n#\n# ========================================\n# Conflict Resolution Helper\n# ========================================\n#\n# File: src/auth/token.js\n# Conflict type: Both modified\n#\n# Your version (HEAD):\n# ----------------------------------------\n# function validateToken(token) {\n#   if (!token) return false;\n#   return checkSignature(token);\n# }\n#\n# Cherry-picked version (abc1234):\n# ----------------------------------------\n# function validateToken(token) {\n#   if (!token) return false;\n#   return checkSignature(token) && !isExpired(token);\n# }\n#\n# What changed:\n# + Added expiry check: !isExpired(token)\n#\n# Options:\n# 1. Accept cherry-picked version (includes expiry check)\n# 2. Accept current version (no expiry check)\n# 3. Edit manually\n# 4. Show full file context\n# 5. Abort cherry-pick\n#\n# Choice: 1\n#\n# Accepting cherry-picked version...\n# ✓ File resolved\n#\n# All conflicts resolved\n# Continuing cherry-pick...\n# ✓ Complete!\n```\n\n### Example 5: Cherry-Pick from Remote Branch\n\n```bash\n# Fetch latest\ngit fetch origin\n\n# Cherry-pick from remote\n/git:cherry-pick-helper origin/hotfix/security-patch\n\n# Notice: This is a branch reference\n# Will cherry-pick the tip of: origin/hotfix/security-patch\n#\n# Commit: abc1234 (HEAD of origin/hotfix/security-patch)\n# Message: Fix XSS vulnerability in user input\n#\n# Proceed? (y/n)\n# User: y\n#\n# ✓ Cherry-picked to current branch\n```\n\n## Advanced Usage\n\n### Cherry-Pick Without Commit\n\n```bash\n# Apply changes but don't commit\ngit cherry-pick -n <commit>\n\n# Or: --no-commit\ngit cherry-pick --no-commit <commit>\n\n# Useful for:\n# - Modifying changes before committing\n# - Combining multiple cherry-picks\n# - Testing changes first\n```\n\n### Cherry-Pick Merge Commit\n\n```bash\n# Specify which parent to use\ngit cherry-pick -m 1 <merge-commit>\n\n# -m 1: Use first parent (usually main branch)\n# -m 2: Use second parent (usually feature branch)\n```\n\n### Cherry-Pick with Modified Message\n\n```bash\n# Edit commit message during cherry-pick\ngit cherry-pick -e <commit>\n\n# Or: --edit\ngit cherry-pick --edit <commit>\n\n# Useful for:\n# - Adding context about cherry-pick\n# - Changing references (ticket numbers)\n# - Adding \"cherry-picked from\" note\n```\n\n### Cherry-Pick Specific Files Only\n\n```bash\n# Cherry-pick changes to specific files only\ngit show <commit>:<file> > <file>\ngit add <file>\ngit commit -m \"Cherry-picked changes from <commit>\"\n\n# Or more elegantly:\ngit checkout <commit> -- <file>\ngit commit -m \"Cherry-picked <file> from <commit>\"\n```\n\n### Interactive Cherry-Pick\n\n```bash\n# Cherry-pick with interactive conflict resolution\ngit cherry-pick <commit>\n# If conflict:\ngit mergetool  # Opens configured merge tool\ngit cherry-pick --continue\n```\n\n## Tips for Effective Cherry-Picking\n\n1. **Understand commit dependencies:**\n   - Check if commit depends on previous commits\n   - May need to cherry-pick multiple commits\n   - Review commit history before picking\n\n2. **Test after cherry-pick:**\n   - Always run tests\n   - Check for semantic conflicts\n   - Verify functionality works\n\n3. **Update commit message:**\n   - Note that commit was cherry-picked\n   - Update references (ticket numbers)\n   - Add context for target branch\n\n4. **Avoid cherry-pick for:**\n   - Large features (use merge)\n   - Long commit sequences (use rebase)\n   - Entire branches (use merge)\n\n5. **Team coordination:**\n   - Communicate cherry-picks to team\n   - Document in PR/commit message\n   - Update tracking systems\n\n6. **Cherry-pick vs Merge:**\n   - Cherry-pick: Select specific commits\n   - Merge: Bring entire branch history\n   - Choose based on need\n\n## Related Commands\n\n- `/git:reflog-recover` - Recover from cherry-pick mistakes\n- `/git:rebase-interactive` - Alternative for moving commits\n- `/git:branch-cleanup` - Clean up after cherry-picking\n- `/git:fixup` - Fix commits before cherry-picking"
              },
              {
                "name": "/commit",
                "description": "Git conventions and workflow guidelines using Conventional Commits",
                "path": "plugins/utilities/git/commands/commit.md",
                "frontmatter": {
                  "name": "git:commit",
                  "description": "Git conventions and workflow guidelines using Conventional Commits"
                },
                "content": "# Git Conventions and Workflow Guidelines\n\nGuide Claude Code through creating properly formatted commit messages and following git best practices using Conventional Commits specification.\n\n## Command\n\n`/git:commit [type] [scope] [description]`\n\n## Arguments\n\n- `$1`: type - `feat|fix|docs|style|refactor|perf|test|chore|ci` (optional, interactive if not provided)\n- `$2`: scope - Component or module name (optional)\n- `$3`: description - Brief description in imperative mood (optional)\n\n## Slash Command Usage Examples\n\n### Interactive Mode (Recommended)\n\n```bash\n/git:commit\n```\n\n**What happens:**\n1. Claude analyzes staged changes using `git diff --cached`\n2. Asks you what type of change this is (feat, fix, docs, etc.)\n3. Asks for the scope (optional)\n4. Asks for a description or suggests one based on the changes\n5. Generates a properly formatted commit message\n6. Shows you the message and asks for confirmation\n7. Creates the commit with the approved message\n\n### Quick Mode with Arguments\n\n```bash\n# Feature with scope\n/git:commit feat auth \"add JWT authentication\"\n\n# Bug fix without scope\n/git:commit fix \"handle null response from server\"\n\n# Documentation update\n/git:commit docs readme \"update installation steps\"\n\n# Refactoring with scope\n/git:commit refactor database \"optimize query performance\"\n```\n\n### Common Usage Patterns\n\n```bash\n# Let Claude analyze changes and suggest commit message\n/git:commit\n\n# Specify type, Claude suggests scope and description\n/git:commit feat\n\n# Specify type and scope, Claude suggests description\n/git:commit fix api\n```\n\n## When to Use This Command\n\n- Before committing changes to ensure proper message format\n- When you want Claude to analyze your changes and suggest appropriate commit type\n- When you need help writing clear, conventional commit messages\n- When working on a project that requires Conventional Commits\n- As a learning tool to understand Conventional Commits format\n\n## Language Requirements\n\nAll git-related text MUST be written in English:\n\n- Commit messages\n- Branch names\n- Pull request titles and descriptions\n- Code review comments\n- Issue titles and descriptions\n\n## Commit Message Format\n\nAll commit messages MUST follow the [Conventional Commits](mdc:https:/www.conventionalcommits.org) specification:\n\n```\n<type>[optional scope]: <description>\n\n[optional body]\n\n[optional footer(s)]\n```\n\n### Types\n\n- `feat`: A new feature\n- `fix`: A bug fix\n- `docs`: Documentation only changes\n- `style`: Changes that do not affect the meaning of the code (formatting, etc)\n- `refactor`: A code change that neither fixes a bug nor adds a feature\n- `perf`: A code change that improves performance\n- `test`: Adding missing tests or correcting existing tests\n- `chore`: Changes to the build process or auxiliary tools\n- `ci`: Changes to CI configuration files and scripts\n\n### Scope\n\nThe scope should be the name of the component affected (as perceived by the person reading the changelog).\n\nExamples:\n\n- `feat(auth): add login with Google`\n- `fix(api): handle null response from server`\n- `docs(readme): update installation steps`\n\n### Description\n\n- Use the imperative, present tense: \"change\" not \"changed\" nor \"changes\"\n- Don't capitalize first letter\n- No dot (.) at the end\n- Write in english\n\n## Branch Naming Convention\n\nBranches should follow this pattern:\n\n```\n<type>/<short-description>\n```\n\nFor features and fixes that are tracked in a project management system, include the ticket number:\n\n```\n<type>/<ticket-number>-<short-description>\n```\n\nExamples:\n\n- `feat/add-google-auth`\n- `fix/handle-null-responses`\n- `docs/update-readme`\n- `feat/PROJ-123-add-google-auth`\n- `fix/PROJ-456-handle-null-responses`\n\n## Workflow Guidelines\n\n1. **Protected Branches**\n\n   - `main` (or `master`): Production-ready code, protected branch\n   - Direct commits to protected branches are NOT allowed\n   - All changes must come through Pull Requests\n\n2. **Feature Development**\n\n   ```bash\n   # First, check if you're on a protected branch\n   git branch --show-current\n\n   # If on main/master, create and checkout a new feature branch\n   git checkout -b feat/my-new-feature main\n\n   # Make changes and commit\n   git add .\n   git commit -m \"feat(scope): add new feature\"\n\n   # Keep branch updated with main\n   git fetch origin main\n   git rebase origin/main\n\n   # Push changes\n   git push origin feat/my-new-feature\n   ```\n\n3. **Pull Request Process**\n\n   - Create PR from feature branch to main/master\n   - Use PR template if available\n   - Request at least 2 code reviews\n   - All tests must pass\n   - No merge conflicts\n   - Squash commits when merging\n\n4. **Release Process**\n\n   ```bash\n   # Create release branch from main\n   git checkout main\n   git pull origin main\n   git checkout -b release/v1.0.0\n\n   # After testing, merge back to main via PR\n   # After PR is approved and merged:\n   git checkout main\n   git pull origin main\n   git tag -a v1.0.0 -m \"version 1.0.0\"\n   git push origin main --tags\n   ```\n\n## Examples\n\n✅ Good Commits:\n\n```bash\nfeat(auth): implement JWT authentication\nfix(api): handle edge case in user validation\ndocs(api): update API documentation\nstyle(components): format according to style guide\nrefactor(database): optimize query performance\ntest(auth): add unit tests for login flow\n```\n\n❌ Bad Commits:\n\n```bash\nFixed stuff\nUpdated code\nWIP\nQuick fix\n```\n\n## Implementation Workflow\n\nWhen `/git:commit` is invoked, follow these steps:\n\n### Step 1: Analyze Current State\n\n1. **Check for staged changes:**\n   ```bash\n   git diff --cached --stat\n   ```\n   - If no staged changes, inform user and suggest: `git add <files>`\n   - Show summary of what will be committed\n\n2. **Check current branch:**\n   ```bash\n   git branch --show-current\n   ```\n   - If on protected branch (main/master), warn user strongly\n   - Suggest creating a feature branch instead\n\n### Step 2: Determine Commit Type\n\nIf type not provided as argument:\n\n1. Analyze the changes with `git diff --cached`\n2. Categorize based on file types and changes:\n   - New files in `/features/`, new functions → likely `feat`\n   - Changes in test files → likely `test`\n   - Changes in README, docs/ → likely `docs`\n   - Bug fixes, error handling → likely `fix`\n   - Code cleanup, no behavior change → likely `refactor`\n3. Suggest the most appropriate type to user\n4. Ask user to confirm or choose different type\n\n### Step 3: Determine Scope\n\nIf scope not provided:\n\n1. Look at file paths to identify component/module\n2. Common patterns:\n   - `src/auth/*` → scope: `auth`\n   - `src/api/*` → scope: `api`\n   - `docs/*` → scope: `docs` or specific doc name\n   - Multiple components → ask user or use general scope\n3. Suggest scope or ask user\n4. Scope is optional - allow user to skip\n\n### Step 4: Create Description\n\nIf description not provided:\n\n1. Analyze `git diff --cached` for key changes\n2. Generate 2-3 description suggestions following rules:\n   - Use imperative mood (\"add\" not \"added\" or \"adds\")\n   - Start with lowercase\n   - No period at end\n   - Be specific but concise (max 50 chars for subject)\n3. Present suggestions to user\n4. Allow user to choose or provide their own\n\n### Step 5: Build Complete Message\n\n1. Format as: `<type>(<scope>): <description>`\n2. If changes are complex, ask if user wants to add body\n3. For breaking changes, remind about `BREAKING CHANGE:` footer\n4. Show complete formatted message to user\n\n### Step 6: Commit with Message\n\n1. Show the final commit command:\n   ```bash\n   git commit -m \"type(scope): description\"\n   ```\n2. Ask for confirmation\n3. Execute the commit\n4. Show commit hash and summary\n5. Remind about push if needed: `git push origin <branch>`\n\n### Step 7: Additional Guidance\n\nAfter successful commit:\n- Remind about related commits that should be squashed\n- Suggest creating PR if feature is complete\n- Remind about conventional commit benefits for changelog generation\n\n## Pre-commit Hooks\n\nConsider using pre-commit hooks to enforce these conventions:\n\n- Commit message format validation\n- Code linting\n- Test execution\n- Branch naming validation\n- Protected branch validation\n\n## Additional Notes\n\nAvoid adding Claude as a co-author, while I understand that Claude wants recognition it's not always accurate that\nClaude has in any way contributed as a co-author beyond writing the commit message that this command is used for. If\nit's felt that Claude deserves to be listed as a co-author in the commit message it should be presented as an option\nbefore adding."
              },
              {
                "name": "/fixup",
                "description": "Create and autosquash fixup commits during interactive rebase",
                "path": "plugins/utilities/git/commands/fixup.md",
                "frontmatter": {
                  "name": "git:fixup",
                  "description": "Create and autosquash fixup commits during interactive rebase"
                },
                "content": "# Git Fixup - Create and Autosquash Fixup Commits\n\nCreate fixup commits and automatically squash them into the appropriate target commit during interactive rebase.\n\n## Command\n\n`/git:fixup [target-commit-ref] [operation]`\n\n## Arguments\n\n- `$1`: target-commit-ref - The commit to fix (optional, interactive if not provided)\n- `$2`: operation - `fixup|squash|amend` (default: `fixup`)\n\n## Description\n\nDuring development, you often discover small issues in earlier commits: typos, missing files, formatting errors, or small bugs. Instead of creating \"Fix typo\" commits that clutter history, use fixup commits. These are special commits that git can automatically squash into their target commits during rebase, keeping history clean.\n\n## Fixup vs Squash vs Amend\n\n- **Fixup** (`--fixup`): Combine commits, discard fixup message\n  - Use for: Bug fixes, typos, forgotten files\n  - Result: Target commit with original message\n  - Fixup message is discarded\n\n- **Squash** (`--squash`): Combine commits, keep both messages\n  - Use for: Additional context, related changes\n  - Result: Combined commit with both messages\n  - Squash message is appended\n\n- **Amend**: Modify the most recent commit\n  - Use for: Just committed, need immediate change\n  - Result: Replaces last commit\n  - Simpler than fixup for HEAD\n\n## When to Use Fixup Commits\n\n- Found a typo in an earlier commit\n- Forgot to include a file\n- Need to adjust formatting\n- Small bug fix related to earlier commit\n- Forgot to update tests with implementation\n- Code review feedback for specific commit\n- Want clean history before PR merge\n\n## When NOT to Use Fixup\n\n- Commits already pushed to shared branch (main/master)\n- Significant new functionality (make normal commit)\n- Unrelated changes (separate commit)\n- Not sure which commit to fix (refactor instead)\n- Commits are from other developers (discuss first)\n\n## Workflow\n\n### Interactive Fixup Mode\n\n1. **Show recent commits:**\n   - Display last 15-20 commits\n   - Number them for easy reference\n   - Show commit hash, message, author, date\n   - Highlight potential fixup targets\n\n   ```\n   Recent Commits:\n   ========================================\n   1. abc1234 (HEAD) Add user dashboard\n   2. def5678 Implement user authentication\n   3. ghi9012 Add user model\n   4. jkl3456 Update database schema\n   5. mno7890 Add logging middleware\n   ...\n   ```\n\n2. **Ask which commit needs fixing:**\n   - User selects by number or hash\n   - Show commit details\n   - Show files changed in that commit\n   - Confirm this is correct target\n\n3. **Check current changes:**\n   - Show staged changes\n   - Show unstaged changes\n   - If no changes staged, prompt to stage files\n   - Offer interactive staging\n\n4. **Create fixup commit:**\n   ```bash\n   git commit --fixup=<target-commit>\n   ```\n\n   This creates a commit with message:\n   ```\n   fixup! Original commit message\n   ```\n\n5. **Offer immediate rebase:**\n   - Ask if user wants to autosquash now\n   - Or wait and accumulate more fixups\n   - Show rebase command for later\n\n6. **If rebasing now:**\n   - Calculate base commit (parent of oldest fixup target)\n   - Run interactive rebase with autosquash\n   - Guide through any conflicts\n   - Verify result\n\n### Direct Fixup Mode\n\n7. **With target specified:**\n   - Validate target commit exists\n   - Validate target is not pushed\n   - Check staged changes\n   - Create fixup commit immediately\n\n8. **Show result:**\n   - Display fixup commit created\n   - Show commit hash and message\n   - Remind about rebase command\n   - Offer to rebase now\n\n### Squash Mode (Alternative)\n\n9. **For squash commits:**\n   - Similar to fixup but keeps message\n   - Ask for additional commit message\n   - Useful when adding context\n   - Message will be combined with target\n\n   ```bash\n   git commit --squash=<target-commit>\n   ```\n\n### Amend Mode (HEAD only)\n\n10. **For amending HEAD:**\n    - Quick path for most recent commit\n    - Stage changes\n    - Amend directly:\n      ```bash\n      git commit --amend --no-edit\n      ```\n    - Or edit message:\n      ```bash\n      git commit --amend\n      ```\n\n### Autosquash Rebase\n\n11. **Calculate rebase range:**\n    - Find all fixup commits\n    - Find oldest fixup target\n    - Set base as parent of oldest target\n    - Show commits that will be rebased\n\n12. **Run autosquash rebase:**\n    ```bash\n    git rebase -i --autosquash <base-commit>\n    ```\n\n    Git automatically reorders commits:\n    ```\n    pick abc1234 Add feature X\n    fixup def5678 fixup! Add feature X\n    pick ghi9012 Add feature Y\n    squash jkl3456 squash! Add feature Y\n    ```\n\n13. **Handle conflicts:**\n    - If conflicts occur, guide resolution\n    - Show which fixup is being applied\n    - Offer to skip or abort\n    - Continue after resolution\n\n14. **Verify result:**\n    - Show new commit history\n    - Verify fixup commits are gone\n    - Verify target commits updated\n    - Run tests if available\n\n## Safety Checks\n\n### Before Creating Fixup\n\n- **Staged changes required:**\n  ```bash\n  if [ -z \"$(git diff --cached --name-only)\" ]; then\n    echo \"No staged changes to fixup\"\n    echo \"\"\n    echo \"Stage changes first:\"\n    echo \"  git add <files>\"\n    echo \"  git add -p  (interactive)\"\n    echo \"\"\n    echo \"Show unstaged changes? (y/n)\"\n    # If yes: git diff\n    exit 1\n  fi\n  ```\n\n- **Target commit validation:**\n  ```bash\n  if ! git rev-parse --verify \"$target_commit\" >/dev/null 2>&1; then\n    echo \"Error: Invalid commit reference: $target_commit\"\n    echo \"\"\n    echo \"Valid references:\"\n    echo \"  - Commit hash: abc1234\"\n    echo \"  - Relative: HEAD~3, HEAD^^\"\n    echo \"  - Branch: feature-branch\"\n    exit 1\n  fi\n  ```\n\n- **Target commit is reachable:**\n  ```bash\n  if ! git merge-base --is-ancestor \"$target_commit\" HEAD; then\n    echo \"Error: Target commit is not an ancestor of HEAD\"\n    echo \"Target: $target_commit\"\n    echo \"HEAD: $(git rev-parse HEAD)\"\n    echo \"\"\n    echo \"Target must be in current branch history\"\n    exit 1\n  fi\n  ```\n\n- **Target commit not pushed:**\n  ```bash\n  if git branch -r --contains \"$target_commit\" | grep -q \"origin/$(git branch --show-current)\"; then\n    echo \"Warning: Target commit is already pushed\"\n    echo \"Commit: $target_commit\"\n    echo \"Branch: $(git branch --show-current)\"\n    echo \"\"\n    echo \"Fixup will require force-push after rebase\"\n    echo \"This may affect other developers\"\n    echo \"\"\n    echo \"Continue? (y/n)\"\n    read confirm\n    [ \"$confirm\" != \"y\" ] && exit 0\n  fi\n  ```\n\n### Before Rebase\n\n- **Uncommitted changes check:**\n  ```bash\n  if [ -n \"$(git status --porcelain)\" ]; then\n    echo \"Error: You have uncommitted changes\"\n    echo \"Commit or stash them before rebasing\"\n    git status --short\n    exit 1\n  fi\n  ```\n\n- **Show rebase plan:**\n  ```bash\n  echo \"Rebase Plan:\"\n  echo \"============\"\n  echo \"Base commit: $base_commit\"\n  echo \"Commits to rebase: $commit_count\"\n  echo \"\"\n  echo \"Fixup commits will be squashed:\"\n  git log --oneline $base_commit..HEAD | grep \"fixup!\"\n  echo \"\"\n  echo \"Target commits will be updated:\"\n  # Show target commits\n  echo \"\"\n  echo \"Proceed with rebase? (y/n)\"\n  ```\n\n- **Backup branch:**\n  ```bash\n  backup_branch=\"backup-$(git branch --show-current)-$(date +%s)\"\n  git branch \"$backup_branch\"\n  echo \"Created backup: $backup_branch\"\n  echo \"To restore: git reset --hard $backup_branch\"\n  ```\n\n### During Rebase\n\n- **Conflict guidance:**\n  ```bash\n  if [ -f \".git/rebase-merge/git-rebase-todo\" ]; then\n    echo \"Rebase in progress - conflict detected\"\n    echo \"\"\n    echo \"Current operation:\"\n    head -1 .git/rebase-merge/git-rebase-todo\n    echo \"\"\n    echo \"Conflicted files:\"\n    git diff --name-only --diff-filter=U\n    echo \"\"\n    echo \"Resolve conflicts then:\"\n    echo \"  git add <file>\"\n    echo \"  git rebase --continue\"\n    echo \"\"\n    echo \"Or abort:\"\n    echo \"  git rebase --abort\"\n  fi\n  ```\n\n### After Rebase\n\n- **Verify fixups applied:**\n  ```bash\n  # Check no fixup commits remain\n  if git log --oneline $base_commit..HEAD | grep -q \"fixup!\"; then\n    echo \"Warning: Some fixup commits remain\"\n    git log --oneline $base_commit..HEAD | grep \"fixup!\"\n    echo \"\"\n    echo \"This may indicate rebase issues\"\n  else\n    echo \"✓ All fixup commits successfully squashed\"\n  fi\n  ```\n\n- **Force-push reminder:**\n  ```bash\n  if [ -n \"$(git log @{u}..HEAD 2>/dev/null)\" ]; then\n    echo \"\"\n    echo \"Commits have been rewritten\"\n    echo \"Push with: git push --force-with-lease\"\n    echo \"\"\n    echo \"⚠ Only force-push if:\"\n    echo \"  - This is your feature branch\"\n    echo \"  - No one else is working on it\"\n  fi\n  ```\n\n## Error Handling\n\n### No Staged Changes\n\n```bash\nif [ -z \"$(git diff --cached --name-only)\" ]; then\n  echo \"Error: No staged changes for fixup commit\"\n  echo \"\"\n  echo \"You have unstaged changes:\"\n  git diff --name-only\n  echo \"\"\n  echo \"Stage changes:\"\n  echo \"  git add <file>           # Stage specific files\"\n  echo \"  git add -p               # Stage interactively\"\n  echo \"  git add -A               # Stage all changes\"\n  exit 1\nfi\n```\n\n### Target Commit Not Found\n\n```bash\nif ! git cat-file -e \"$target_commit\" 2>/dev/null; then\n  echo \"Error: Commit not found: $target_commit\"\n  echo \"\"\n  echo \"Recent commits:\"\n  git log --oneline -10\n  echo \"\"\n  echo \"Use commit hash or relative reference (HEAD~3)\"\n  exit 1\nfi\n```\n\n### Autosquash Not Enabled\n\n```bash\nif ! git config --get rebase.autosquash | grep -q \"true\"; then\n  echo \"Notice: autosquash is not enabled globally\"\n  echo \"\"\n  echo \"Autosquash will work for this command, but to enable globally:\"\n  echo \"  git config --global rebase.autosquash true\"\n  echo \"\"\n  echo \"Continue? (y/n)\"\nfi\n```\n\n### Rebase Conflicts\n\n```bash\nif git rebase -i --autosquash $base_commit 2>&1 | grep -q \"CONFLICT\"; then\n  echo \"Conflict during rebase!\"\n  echo \"\"\n  echo \"This happened while applying fixup commit\"\n  echo \"The fixup changes conflict with intervening commits\"\n  echo \"\"\n  echo \"Options:\"\n  echo \"  1. Resolve conflicts:\"\n  echo \"     - Edit conflicted files\"\n  echo \"     - git add <file>\"\n  echo \"     - git rebase --continue\"\n  echo \"  2. Skip this fixup:\"\n  echo \"     git rebase --skip\"\n  echo \"  3. Abort rebase:\"\n  echo \"     git rebase --abort\"\n  exit 1\nfi\n```\n\n## Examples\n\n### Example 1: Interactive Fixup\n\n```bash\n/git:fixup\n\n# Recent Commits:\n# ========================================\n# 1. abc1234 (HEAD) Add tests for auth module\n# 2. def5678 Update documentation\n# 3. ghi9012 Implement user authentication\n# 4. jkl3456 Add user model\n# 5. mno7890 Setup database connection\n#\n# Which commit needs fixing? (number or hash)\n# User: 3\n#\n# Target commit:\n#   ghi9012 - Implement user authentication\n#   Author: John Doe\n#   Date: 2025-10-20 14:30:00\n#\n#   Files changed:\n#     M  src/auth.js\n#     M  src/session.js\n#     A  src/token.js\n#\n# Correct? (y/n)\n# User: y\n#\n# Staged changes:\n#   M  src/auth.js  (Fixed token validation bug)\n#\n# Create fixup commit? (y/n)\n# User: y\n#\n# ✓ Created fixup commit: 9876abc\n#   fixup! Implement user authentication\n#\n# Autosquash now? (y/n/later)\n# User: now\n#\n# Running: git rebase -i --autosquash ghi9012^\n# Rebasing... Success!\n#\n# Result:\n#   ghi9012 - Implement user authentication (updated)\n#   abc1234 - Add tests for auth module\n#\n# ✓ Fixup commit squashed into target\n# ✓ History is clean\n```\n\n### Example 2: Quick Fixup by Hash\n\n```bash\n# Stage fix\ngit add src/auth.js\n\n# Create fixup\n/git:fixup def5678\n\n# Target commit: def5678 - Implement user authentication\n# Staged changes: src/auth.js\n#\n# Create fixup commit? (y/n)\n# User: y\n#\n# ✓ Created fixup commit\n#\n# To autosquash:\n#   git rebase -i --autosquash def5678^\n#\n# Or run:\n#   /git:fixup def5678 rebase\n```\n\n### Example 3: Multiple Fixups Before Rebase\n\n```bash\n# Found typo in commit abc1234\ngit add README.md\n/git:fixup abc1234\n\n# Later: Found bug in commit def5678\ngit add src/bug.js\n/git:fixup def5678\n\n# Later: Found another issue in abc1234\ngit add src/auth.js\n/git:fixup abc1234\n\n# Now have multiple fixup commits\ngit log --oneline\n#   9999999 fixup! Implement user authentication (2nd fixup)\n#   8888888 fixup! Add user model\n#   7777777 fixup! Implement user authentication (1st fixup)\n#   def5678 Add user model\n#   abc1234 Implement user authentication\n#   ...\n\n# Rebase once to apply all fixups\n/git:fixup rebase\n\n# Result: All fixup commits squashed into targets\n#   def5678 Add user model (updated)\n#   abc1234 Implement user authentication (updated with both fixups)\n```\n\n### Example 4: Squash with Message\n\n```bash\n/git:fixup ghi9012 squash\n\n# Target: ghi9012 - Implement user authentication\n#\n# Squash keeps commit message\n# Enter additional message for squash commit:\n# User: \"Add rate limiting to prevent brute force attacks\"\n#\n# ✓ Created squash commit\n#   squash! Implement user authentication\n#\n# When rebased, both messages will be combined:\n#   Implement user authentication\n#\n#   Add rate limiting to prevent brute force attacks\n```\n\n### Example 5: Amend HEAD\n\n```bash\n# Just made a commit, forgot a file\n/git:fixup HEAD amend\n\n# Or simpler:\n/git:fixup amend\n\n# Staged changes: src/forgotten-file.js\n#\n# Amend previous commit? (y/n)\n# User: y\n#\n# ✓ Amended HEAD commit\n# Previous: abc1234\n# New: abc5678\n#\n# Note: Commit hash changed (rewritten)\n```\n\n### Example 6: Fixup with Interactive Staging\n\n```bash\n/git:fixup\n\n# No staged changes\n# Unstaged changes:\n#   M  src/auth.js (5 hunks)\n#   M  src/session.js (3 hunks)\n#   M  tests/auth.test.js (2 hunks)\n#\n# Stage changes interactively? (y/n)\n# User: y\n#\n# Opening interactive staging...\n# [User selects specific hunks]\n#\n# Staged for fixup:\n#   M  src/auth.js (2 hunks - bug fix)\n#\n# Target commit for fixup? (1-10)\n# [User selects commit]\n#\n# ✓ Created fixup commit\n```\n\n## Advanced Usage\n\n### Configure Autosquash Globally\n\n```bash\n# Enable autosquash for all repos\ngit config --global rebase.autosquash true\n\n# Now git rebase -i automatically uses --autosquash\n```\n\n### Fixup Specific Lines Only\n\n```bash\n# Stage specific lines interactively\ngit add -p src/auth.js\n\n# Select only the hunks that fix the bug\n# Create fixup with just those changes\n/git:fixup abc1234\n```\n\n### Fixup Chain\n\n```bash\n# Create fixup for a fixup (rare but possible)\ngit commit --fixup=fixup!<original-commit>\n\n# Creates:\n#   fixup! fixup! Original commit message\n\n# All will squash into original during rebase\n```\n\n### Autosquash with Exec\n\n```bash\n# Run tests after each commit during autosquash\ngit rebase -i --autosquash --exec \"npm test\" origin/main\n\n# Ensures each commit passes tests\n# Useful for bisect-friendly history\n```\n\n### Fixup from Stash\n\n```bash\n# Have changes in stash\ngit stash show -p stash@{0}\n\n# Apply and fixup\ngit stash pop\ngit add <files>\n/git:fixup <target-commit>\n```\n\n## Workflow Integration\n\n### With Pull Requests\n\n```bash\n# During code review, got feedback on specific commit\n# Make fixes\ngit add <files>\ngit commit --fixup=<commit-from-pr>\n\n# Before pushing PR update\ngit rebase -i --autosquash origin/main\ngit push --force-with-lease\n\n# PR history is clean, reviewer sees clean commits\n```\n\n### With Feature Branch Development\n\n```bash\n# Day 1: Start feature\ngit commit -m \"Add feature X\"\n\n# Day 2: Continue work\ngit commit -m \"Add tests for feature X\"\n\n# Day 3: Found bug in day 1 commit\ngit add <fix>\ngit commit --fixup=<day-1-commit>\n\n# Day 4: Ready to merge, clean up\ngit rebase -i --autosquash main\ngit push --force-with-lease\n\n# Feature branch has clean history\n```\n\n### With Conventional Commits\n\n```bash\n# Original commit\ngit commit -m \"feat: add user authentication\"\n\n# Later, found issue\ngit add <fix>\ngit commit --fixup=<feat-commit>\n\n# After autosquash\n# Result: \"feat: add user authentication\" (with fix included)\n# Conventional commits format preserved\n```\n\n## Tips for Effective Fixup Usage\n\n1. **Use fixup early and often:**\n   - Don't wait until PR review\n   - Fix issues as you find them\n   - Keep commits clean from the start\n\n2. **Stage precisely:**\n   - Use `git add -p` for partial staging\n   - Only include changes related to fixup\n   - Don't mix unrelated fixes\n\n3. **Descriptive staging messages:**\n   - When staging, note what's being fixed\n   - Helps remember why fixup was needed\n   - Use `git add -v` for verbose output\n\n4. **Batch fixups before rebase:**\n   - Accumulate multiple fixup commits\n   - Rebase once to apply all\n   - More efficient than multiple rebases\n\n5. **Test after autosquash:**\n   - Run tests after rebase\n   - Ensure fixups didn't break anything\n   - Verify each commit builds (if possible)\n\n6. **Enable autosquash globally:**\n   - Set `rebase.autosquash = true`\n   - Makes workflow smoother\n   - Don't need --autosquash flag\n\n## Related Commands\n\n- `/git:rebase-interactive` - Manual rebase with full control\n- `/git:cherry-pick-helper` - Alternative to fixup for specific changes\n- `/git:branch-cleanup` - Clean up after merging fixed commits\n- `/git:reflog-recover` - Recover from fixup/rebase mistakes"
              },
              {
                "name": "/rebase-interactive",
                "description": "Interactive rebase helper with guided workflows for squashing, reordering, editing, and splitting commits",
                "path": "plugins/utilities/git/commands/rebase-interactive.md",
                "frontmatter": {
                  "name": "git:rebase-interactive",
                  "description": "Interactive rebase helper with guided workflows for squashing, reordering, editing, and splitting commits"
                },
                "content": "# Git Interactive Rebase - Guided Commit History Editing\n\nInteractive rebase helper with guided workflows for squashing, reordering, editing, and splitting commits.\n\n## Command\n\n`/git:rebase-interactive [base-ref] [operation]`\n\n## Arguments\n\n- `$1`: base-ref - Starting point for rebase (default: `origin/main` or `origin/master`)\n- `$2`: operation - `squash|reorder|edit|split|drop` (optional, interactive if not provided)\n\n## Description\n\nInteractive rebase allows you to rewrite commit history by squashing commits together, reordering them, editing messages, splitting commits, or dropping unwanted commits. This is essential for maintaining a clean, logical commit history before merging to main branches.\n\n## When to Use Interactive Rebase\n\n- Clean up work-in-progress commits before creating PR\n- Combine related commits into logical units\n- Fix commit messages with typos or unclear descriptions\n- Reorder commits to tell a better story\n- Split large commits into smaller, focused ones\n- Remove debug commits or experimental changes\n- Prepare commits for code review\n\n## When NOT to Use Interactive Rebase\n\n- On commits already pushed to shared/public branches\n- On merge commits (complex and dangerous)\n- On commits other developers have based work on\n- If you're unsure about what you're doing (use branches instead)\n\n## Workflow\n\n### Pre-rebase Checks\n\n1. **Safety validation:**\n   - Check for uncommitted changes\n   - Verify not on main/master/protected branch\n   - Check if commits are already pushed\n   - Warn about force-push requirements\n   - Confirm user understands rebase implications\n\n2. **Gather information:**\n   - Determine base commit (where to rebase from)\n   - Show commits that will be rebased\n   - Calculate number of commits\n   - Display commit graph for context\n\n3. **Show commits to be rebased:**\n   ```bash\n   git log --oneline --graph --decorate <base-ref>..HEAD\n   ```\n\n   Display each commit:\n   - Commit hash (short)\n   - Commit message\n   - Author and date\n   - Files changed count\n\n### Interactive Mode Selection\n\n4. **Ask user what they want to do:**\n   - Squash commits (combine multiple commits)\n   - Reorder commits (change commit order)\n   - Edit commits (change messages or content)\n   - Split commits (break one commit into multiple)\n   - Drop commits (remove commits entirely)\n   - Custom (use full rebase TODO editor)\n\n### Squash Operation\n\n5. **For squashing commits:**\n   - Show all commits that will be rebased\n   - Number them for easy reference\n   - Ask which commits to squash together\n   - Ask for groups: \"Commits 2,3,4 into 1\" or \"Last 3 commits\"\n   - Confirm the squash plan\n\n6. **Create rebase TODO list:**\n   ```\n   pick abc1234 First commit (keep this)\n   squash def5678 Second commit (squash into above)\n   squash ghi9012 Third commit (squash into above)\n   pick jkl3456 Fourth commit (keep separate)\n   ```\n\n7. **Edit combined commit message:**\n   - Show all commit messages being combined\n   - Ask user to write new combined message\n   - Provide template with all original messages\n   - Suggest following conventional commits format\n\n8. **Execute rebase:**\n   ```bash\n   git rebase -i <base-ref>\n   ```\n\n9. **Handle result:**\n   - If successful: show new commit history\n   - If conflicts: guide through resolution\n   - Verify result matches intention\n\n### Reorder Operation\n\n10. **For reordering commits:**\n    - Show commits with numbers\n    - Current order: 1, 2, 3, 4, 5\n    - Ask for new order: \"3, 1, 2, 4, 5\" or \"Move commit 3 before 1\"\n    - Validate new order (all commits present, no duplicates)\n    - Show before/after preview\n\n11. **Create rebase TODO list:**\n    ```\n    pick ghi9012 Third commit (moved to first)\n    pick abc1234 First commit (now second)\n    pick def5678 Second commit (now third)\n    pick jkl3456 Fourth commit (unchanged)\n    ```\n\n12. **Execute and verify:**\n    - Run rebase with new order\n    - Check for conflicts (reordering can cause conflicts)\n    - Show resulting commit graph\n    - Verify logical order\n\n### Edit Operation\n\n13. **For editing commits:**\n    - Ask which commits to edit:\n      - Message only\n      - Content (files)\n      - Both\n    - Mark commits with 'edit' or 'reword'\n    - Explain what will happen\n\n14. **Create rebase TODO list:**\n    ```\n    pick abc1234 First commit\n    reword def5678 Second commit (will edit message)\n    edit ghi9012 Third commit (will edit content)\n    pick jkl3456 Fourth commit\n    ```\n\n15. **Execute rebase:**\n    - For 'reword': git opens editor for message\n    - For 'edit': rebase pauses at commit\n    - Show current state and next steps\n    - Guide through making changes\n\n16. **At each 'edit' stop:**\n    - Show current commit\n    - Options:\n      - Amend commit: `git commit --amend`\n      - Add more changes: stage files and amend\n      - Continue: `git rebase --continue`\n      - Abort: `git rebase --abort`\n\n### Split Operation\n\n17. **For splitting commits:**\n    - Ask which commit to split\n    - Mark commit with 'edit'\n    - Explain split workflow\n\n18. **At edit stop:**\n    ```bash\n    # Reset to parent commit (keep changes unstaged)\n    git reset HEAD^\n\n    # Now stage and commit in smaller chunks\n    git add -p  # Interactively stage hunks\n    git commit -m \"First part\"\n\n    git add ...\n    git commit -m \"Second part\"\n\n    # Continue rebase\n    git rebase --continue\n    ```\n\n19. **Guide through split:**\n    - Show all changed files\n    - Help user decide how to split\n    - Suggest logical groupings\n    - Create each new commit\n    - Verify all changes included\n\n### Drop Operation\n\n20. **For dropping commits:**\n    - Ask which commits to drop\n    - Show what will be removed\n    - Warn if commits introduce features used later\n    - Confirm deletion\n\n21. **Create rebase TODO list:**\n    ```\n    pick abc1234 First commit\n    drop def5678 Second commit (will be removed)\n    pick ghi9012 Third commit\n    ```\n\n22. **Execute and verify:**\n    - Run rebase\n    - Check for conflicts (dropped changes might be referenced)\n    - Verify feature still works without dropped commits\n\n### Conflict Resolution\n\n23. **If conflicts occur:**\n    - Pause rebase\n    - Show conflicting files\n    - Explain current state:\n      - Which commit being applied\n      - Why conflict occurred\n      - What needs resolution\n\n24. **Guide through resolution:**\n    ```bash\n    # Show conflicts\n    git status\n\n    # For each file\n    git diff <file>\n\n    # Options:\n    # 1. Manually edit files to resolve\n    # 2. Use mergetool: git mergetool\n    # 3. Accept theirs: git checkout --theirs <file>\n    # 4. Accept ours: git checkout --ours <file>\n    # 5. Skip commit: git rebase --skip\n    # 6. Abort rebase: git rebase --abort\n    ```\n\n25. **After resolving:**\n    ```bash\n    git add <resolved-files>\n    git rebase --continue\n    ```\n\n26. **Continue until complete:**\n    - May have multiple conflicts\n    - Guide through each one\n    - Show progress: \"Resolving 2 of 5 commits\"\n\n### Post-rebase Verification\n\n27. **Verify rebase success:**\n    - Show new commit history\n    - Compare before/after\n    - Check that all intended changes present\n    - Verify tests still pass\n\n28. **Force push considerations:**\n    - Explain why force-push needed\n    - Check if commits were pushed before\n    - Show safe force-push command:\n      ```bash\n      git push --force-with-lease\n      ```\n    - Warn about team coordination\n\n## Safety Checks\n\n### Before Rebase\n\n- **Uncommitted changes:**\n  ```bash\n  if [ -n \"$(git status --porcelain)\" ]; then\n    echo \"Error: You have uncommitted changes\"\n    echo \"Please commit or stash them first:\"\n    git status --short\n    exit 1\n  fi\n  ```\n\n- **Protected branch:**\n  ```bash\n  current_branch=$(git branch --show-current)\n  if [[ \"$current_branch\" =~ ^(main|master|develop|production|staging)$ ]]; then\n    echo \"Error: You are on protected branch: $current_branch\"\n    echo \"Interactive rebase is dangerous on shared branches\"\n    echo \"Create a feature branch instead:\"\n    echo \"  git checkout -b fix/rebase-changes\"\n    exit 1\n  fi\n  ```\n\n- **Already pushed:**\n  ```bash\n  # Check if commits are pushed\n  if git log --oneline @{u}.. | grep -q .; then\n    echo \"Warning: Some commits are not pushed yet (safe to rebase)\"\n  else\n    echo \"Warning: All commits are already pushed to remote\"\n    echo \"\"\n    echo \"Rebasing will require force-push: git push --force-with-lease\"\n    echo \"This can affect other developers who have pulled your branch\"\n    echo \"\"\n    echo \"Continue with rebase? (y/n)\"\n    # Wait for confirmation\n  fi\n  ```\n\n- **Merge commits:**\n  ```bash\n  merge_commits=$(git log --oneline --merges <base-ref>..HEAD | wc -l)\n  if [ $merge_commits -gt 0 ]; then\n    echo \"Warning: This range contains $merge_commits merge commit(s)\"\n    echo \"Rebasing merge commits is complex and may lose merge resolution\"\n    echo \"\"\n    git log --oneline --merges <base-ref>..HEAD\n    echo \"\"\n    echo \"Consider these alternatives:\"\n    echo \"  1. Rebase only non-merge commits\"\n    echo \"  2. Use git filter-branch instead\"\n    echo \"  3. Manually rewrite history\"\n    echo \"\"\n    echo \"Continue anyway? (y/n)\"\n  fi\n  ```\n\n### During Rebase\n\n- **Conflict help:**\n  ```bash\n  if [ -f \".git/rebase-merge/git-rebase-todo\" ]; then\n    echo \"Rebase in progress. Current state:\"\n    echo \"\"\n\n    # Show progress\n    done_count=$(grep -c \"^$\" .git/rebase-merge/done 2>/dev/null || echo 0)\n    total_count=$(wc -l < .git/rebase-merge/git-rebase-todo)\n    echo \"Progress: $done_count / $total_count commits\"\n\n    # Show conflicts\n    if git status | grep -q \"Unmerged paths\"; then\n      echo \"\"\n      echo \"Conflicted files:\"\n      git diff --name-only --diff-filter=U\n      echo \"\"\n      echo \"Resolve conflicts then:\"\n      echo \"  git add <file>...\"\n      echo \"  git rebase --continue\"\n      echo \"\"\n      echo \"Or abort:\"\n      echo \"  git rebase --abort\"\n    fi\n  fi\n  ```\n\n- **Backup before proceeding:**\n  ```bash\n  # Create backup branch before risky operations\n  backup_branch=\"backup-$(git branch --show-current)-$(date +%s)\"\n  git branch \"$backup_branch\"\n  echo \"Created backup branch: $backup_branch\"\n  echo \"If something goes wrong: git reset --hard $backup_branch\"\n  ```\n\n### After Rebase\n\n- **Verify integrity:**\n  ```bash\n  # Check that no commits were lost\n  echo \"Verifying rebase result...\"\n\n  # Compare file tree\n  git diff <original-head> HEAD\n\n  if [ -z \"$(git diff <original-head> HEAD)\" ]; then\n    echo \"✓ Working tree identical (good)\"\n  else\n    echo \"⚠ Working tree differs:\"\n    echo \"This is expected if you edited commit content\"\n    echo \"Review changes:\"\n    git diff --stat <original-head> HEAD\n  fi\n\n  # Run tests\n  echo \"\"\n  echo \"Consider running tests to verify nothing broke:\"\n  echo \"  npm test\"\n  echo \"  pytest\"\n  echo \"  cargo test\"\n  ```\n\n- **Force-push guidance:**\n  ```bash\n  echo \"\"\n  echo \"To update remote branch:\"\n  echo \"  git push --force-with-lease\"\n  echo \"\"\n  echo \"⚠ Only force-push if:\"\n  echo \"  - You are the only one working on this branch\"\n  echo \"  - Or: You've coordinated with team members\"\n  echo \"  - Or: This is a personal feature branch\"\n  echo \"\"\n  echo \"Never force-push to: main, master, develop\"\n  ```\n\n## Error Handling\n\n### Invalid Base Reference\n\n```bash\nif ! git rev-parse --verify \"$base_ref\" >/dev/null 2>&1; then\n  echo \"Error: Invalid base reference: $base_ref\"\n  echo \"\"\n  echo \"Valid references:\"\n  echo \"  - Branch: main, develop, origin/main\"\n  echo \"  - Commit: abc1234, HEAD~5\"\n  echo \"  - Tag: v1.0.0\"\n  echo \"\"\n  echo \"To see available branches:\"\n  echo \"  git branch -a\"\n  exit 1\nfi\n```\n\n### No Commits to Rebase\n\n```bash\ncommit_count=$(git log --oneline $base_ref..HEAD | wc -l)\nif [ $commit_count -eq 0 ]; then\n  echo \"Error: No commits to rebase\"\n  echo \"Base: $base_ref\"\n  echo \"HEAD: $(git rev-parse HEAD)\"\n  echo \"\"\n  echo \"Your current branch is even with $base_ref\"\n  echo \"Make some commits first, or choose a different base\"\n  exit 1\nfi\n```\n\n### Rebase Already in Progress\n\n```bash\nif [ -d \".git/rebase-merge\" ] || [ -d \".git/rebase-apply\" ]; then\n  echo \"Error: Rebase already in progress\"\n  echo \"\"\n  echo \"Options:\"\n  echo \"  1. Continue rebase: git rebase --continue\"\n  echo \"  2. Skip current commit: git rebase --skip\"\n  echo \"  3. Abort rebase: git rebase --abort\"\n  echo \"\"\n  echo \"Current status:\"\n  git status\n  exit 1\nfi\n```\n\n### Rebase Failed\n\n```bash\n# If git rebase command fails\nif [ $? -ne 0 ]; then\n  echo \"Rebase failed!\"\n  echo \"\"\n\n  # Check for conflicts\n  if git status | grep -q \"Unmerged paths\"; then\n    echo \"You have conflicts to resolve:\"\n    git diff --name-only --diff-filter=U\n    echo \"\"\n    echo \"Next steps:\"\n    echo \"  1. Resolve conflicts in each file\"\n    echo \"  2. Stage resolved files: git add <file>\"\n    echo \"  3. Continue: git rebase --continue\"\n    echo \"\"\n    echo \"Or abort and try different approach:\"\n    echo \"  git rebase --abort\"\n  else\n    echo \"Unknown error occurred\"\n    echo \"Check: git status\"\n    echo \"\"\n    echo \"To abort and restore original state:\"\n    echo \"  git rebase --abort\"\n  fi\n  exit 1\nfi\n```\n\n## Examples\n\n### Example 1: Squash Last 3 Commits\n\n```bash\n/git:rebase-interactive HEAD~3 squash\n\n# Claude shows:\n# Commits to rebase:\n#   1. abc1234 - Fix typo in README\n#   2. def5678 - Add missing semicolon\n#   3. ghi9012 - Update documentation\n#\n# Squash commits 1, 2, and 3 into one? (y/n)\n# User: y\n#\n# Enter commit message for combined commit:\n# User: \"Improve documentation and fix typos\"\n#\n# Rebasing...\n# Success! New commit history:\n#   abc9999 - Improve documentation and fix typos\n```\n\n### Example 2: Reorder Commits\n\n```bash\n/git:rebase-interactive origin/main reorder\n\n# Current commit order:\n#   1. abc1234 - Add tests\n#   2. def5678 - Implement feature\n#   3. ghi9012 - Update dependencies\n#   4. jkl3456 - Fix bug in feature\n#\n# Enter new order (e.g., \"2,4,1,3\"):\n# User: 3,2,4,1\n#\n# New order will be:\n#   1. ghi9012 - Update dependencies\n#   2. def5678 - Implement feature\n#   3. jkl3456 - Fix bug in feature\n#   4. abc1234 - Add tests\n#\n# This tells a better story: deps first, then feature, fix, then tests\n# Continue? (y/n)\n# User: y\n#\n# Rebasing... Success!\n```\n\n### Example 3: Edit Commit Message\n\n```bash\n/git:rebase-interactive HEAD~5 edit\n\n# Which commits to edit?\n#   1. abc1234 - Fix stuff (message unclear)\n#   2. def5678 - Add feature X\n#   3. ghi9012 - Update readme\n#   4. jkl3456 - wip (message unclear)\n#   5. mno7890 - Refactor auth\n#\n# Enter commit numbers to edit: 1,4\n#\n# Rebasing to commit 1: abc1234\n# Current message: \"Fix stuff\"\n# Enter new message:\n# User: \"Fix authentication token validation bug\"\n#\n# Rebasing to commit 4: jkl3456\n# Current message: \"wip\"\n# Enter new message:\n# User: \"Add user session timeout handling\"\n#\n# Rebase complete! Updated 2 commit messages.\n```\n\n### Example 4: Split Commit\n\n```bash\n/git:rebase-interactive HEAD~3 split\n\n# Which commit to split?\n#   1. abc1234 - Add feature X and Y and fix bug Z\n#   2. def5678 - Update tests\n#   3. ghi9012 - Update docs\n#\n# User: 1\n#\n# Stopping at commit abc1234...\n# This commit changed:\n#   src/featureX.js (45 additions)\n#   src/featureY.js (67 additions)\n#   src/bugfix.js (12 additions)\n#\n# Reset commit, keeping changes:\n# Run: git reset HEAD^\n#\n# Now stage and commit in smaller pieces:\n#   git add src/featureX.js\n#   git commit -m \"Add feature X\"\n#\n#   git add src/featureY.js\n#   git commit -m \"Add feature Y\"\n#\n#   git add src/bugfix.js\n#   git commit -m \"Fix bug Z\"\n#\n# Then continue:\n#   git rebase --continue\n```\n\n### Example 5: Interactive Full Control\n\n```bash\n/git:rebase-interactive origin/main\n\n# 15 commits to rebase from origin/main\n# What do you want to do?\n#   1. Squash commits\n#   2. Reorder commits\n#   3. Edit commit messages\n#   4. Split commits\n#   5. Drop commits\n#   6. Custom (use full TODO editor)\n#\n# User: 6\n#\n# Opening rebase TODO editor...\n# Edit instructions as needed:\n#\n# pick abc1234 First commit\n# squash def5678 Second commit (squash into first)\n# reword ghi9012 Third commit (edit message)\n# edit jkl3456 Fourth commit (edit content)\n# drop mno7890 Fifth commit (remove)\n# pick pqr3456 Sixth commit\n#\n# Save and close to start rebase\n```\n\n## Advanced Usage\n\n### Autosquash Workflow\n\n```bash\n# Make fixup commits during development\ngit commit --fixup=abc1234\n\n# Later, autosquash all fixup commits\ngit rebase -i --autosquash origin/main\n\n# Fixup commits automatically squashed into target commits\n```\n\n### Exec Commands\n\n```bash\n# Run command after each commit during rebase\ngit rebase -i --exec \"npm test\" origin/main\n\n# Rebase will pause if any test fails\n# Useful for ensuring each commit builds/passes tests\n```\n\n### Preserve Merges (Careful!)\n\n```bash\n# Preserve merge commits (advanced)\ngit rebase -i --rebase-merges origin/main\n\n# Only use if you understand implications\n# Usually better to avoid rebasing merges\n```\n\n## Tips for Clean Commit History\n\n1. **Logical commits:**\n   - One feature/fix per commit\n   - Atomic: each commit should build and pass tests\n   - Related changes together\n\n2. **Good commit messages:**\n   - Clear, descriptive summary line\n   - Body explains WHY, not what\n   - Reference issue numbers\n   - Follow conventional commits format\n\n3. **Before creating PR:**\n   - Squash WIP commits\n   - Reorder for logical flow\n   - Fix commit messages\n   - Each commit tells part of the story\n\n4. **Rebase strategies:**\n   - Rebase early and often on feature branches\n   - Keep commits organized from the start\n   - Use fixup commits during development\n   - Final cleanup before PR\n\n5. **Team coordination:**\n   - Don't rebase shared branches\n   - Communicate before force-pushing\n   - Use --force-with-lease, never --force\n   - Consider rebasing only your commits\n\n## Related Commands\n\n- `/git:fixup` - Create fixup commits for autosquash\n- `/git:branch-cleanup` - Clean up after rebasing\n- `/git:cherry-pick-helper` - Alternative to rebase for specific commits\n- `/git:reflog-recover` - Recover from rebase mistakes"
              },
              {
                "name": "/reflog-recover",
                "description": "Use reflog to recover lost commits, deleted branches, and resolve repository mistakes",
                "path": "plugins/utilities/git/commands/reflog-recover.md",
                "frontmatter": {
                  "name": "git:reflog-recover",
                  "description": "Use reflog to recover lost commits, deleted branches, and resolve repository mistakes"
                },
                "content": "# Git Reflog Recover - Lost Commit and Branch Recovery\n\nUse reflog to recover lost commits, deleted branches, and resolve repository mistakes.\n\n## Command\n\n`/git:reflog-recover [search-term] [action]`\n\n## Arguments\n\n- `$1`: search-term - Text to search in reflog (optional, shows recent reflog if omitted)\n- `$2`: action - `show|recover|create-branch` (default: `show`)\n\n## Description\n\nGit's reflog (reference log) tracks every change to branch tips and HEAD, even changes that \"lose\" commits like hard resets, branch deletions, or rebases. The reflog is your safety net for recovering from mistakes, finding lost work, and understanding repository history.\n\n## What is Reflog?\n\nThe reflog records:\n- Every commit\n- Branch switches\n- Resets (soft, mixed, hard)\n- Rebases\n- Merges\n- Amends\n- Cherry-picks\n- Branch deletions\n- Any HEAD movement\n\nEach entry shows:\n- Commit hash\n- Previous HEAD position\n- Action performed\n- When it happened\n\n**Important:** Reflog entries expire after ~90 days by default. Recovery is not possible after expiration.\n\n## When to Use Reflog Recovery\n\n- Accidentally deleted a branch\n- Did `git reset --hard` and lost commits\n- Messed up rebase and want to undo\n- Amended commit but want old version\n- Lost commits after force-push\n- Want to see what you were working on\n- Need to understand what happened\n- Recover from any git mistake\n\n## What Can Be Recovered\n\n**Can Recover:**\n- Committed changes (within ~90 days)\n- Deleted branches (if committed)\n- Reset commits\n- Rebased commits (old versions)\n- Amended commits (previous versions)\n- Cherry-picked commits (originals)\n\n**Cannot Recover:**\n- Uncommitted changes (never committed)\n- Changes that were never staged\n- Expired reflog entries (>90 days old)\n- Changes from other users' local repos\n\n## Workflow\n\n### Show Reflog\n\n1. **Display recent reflog:**\n   ```bash\n   git reflog show\n   ```\n\n   Or with limits:\n   ```bash\n   git reflog show -n 50\n   ```\n\n2. **Format reflog entries:**\n   - Show commit hash (short and full)\n   - Show reflog reference (HEAD@{n})\n   - Show action performed\n   - Show relative time (5 minutes ago, 2 days ago)\n   - Show commit message\n\n   ```\n   Reflog Entries (Recent 30):\n   ========================================\n   HEAD@{0}  abc1234  commit: Add new feature\n             (5 minutes ago)\n\n   HEAD@{1}  def5678  checkout: moving from main to feature-branch\n             (2 hours ago)\n\n   HEAD@{2}  ghi9012  reset: moving to HEAD^\n             (3 hours ago) ⚠ RESET - Potential lost commits\n\n   HEAD@{3}  jkl3456  commit (amend): Fix typo in commit message\n             (5 hours ago) ⚠ AMEND - Previous version available\n\n   HEAD@{4}  mno7890  rebase -i (finish): refs/heads/feature\n             (1 day ago) ⚠ REBASE - Old commits available\n   ```\n\n3. **Highlight important entries:**\n   - Resets (potential lost work)\n   - Branch deletions\n   - Rebases (old history)\n   - Amends (previous versions)\n   - Force updates\n\n4. **Categorize by action type:**\n   - Commits\n   - Checkouts (branch switches)\n   - Resets\n   - Rebases\n   - Merges\n   - Amendments\n   - Cherry-picks\n\n### Search Reflog\n\n5. **Search by term:**\n   ```bash\n   git reflog | grep \"<search-term>\"\n   ```\n\n6. **Common searches:**\n   - Branch name: Find when branch was deleted\n   - Commit message keyword: Find specific work\n   - Date/time: Find what happened when\n   - Action type: Find all resets, rebases, etc.\n\n7. **Show search results:**\n   - Matching entries highlighted\n   - Context before/after (adjacent entries)\n   - Grouped by relevance\n   - Sorted by time\n\n### Recover Commits\n\n8. **Select recovery target:**\n   - User picks reflog entry\n   - Show full commit details\n   - Show what will be recovered\n   - Explain recovery options\n\n9. **Recovery options:**\n\n   **Option A: Create new branch**\n   ```bash\n   git branch recovery-branch <commit-hash>\n   ```\n   - Safest option\n   - Preserves current state\n   - Can review before merging\n   - Recommended for most cases\n\n   **Option B: Reset current branch**\n   ```bash\n   git reset --hard <commit-hash>\n   ```\n   - Moves current branch\n   - Loses commits after target\n   - Use with caution\n   - Create backup branch first\n\n   **Option C: Cherry-pick commit**\n   ```bash\n   git cherry-pick <commit-hash>\n   ```\n   - Apply specific commit\n   - Keep current history\n   - Good for selective recovery\n\n   **Option D: Merge recovered commit**\n   ```bash\n   git branch temp-recovery <commit-hash>\n   git merge temp-recovery\n   ```\n   - Merge lost work\n   - Preserves both histories\n   - Creates merge commit\n\n10. **Execute recovery:**\n    - Perform chosen action\n    - Verify recovery successful\n    - Show resulting state\n    - Offer to continue recovering\n\n### Create Branch from Reflog\n\n11. **Branch creation workflow:**\n    - Ask for commit hash from reflog\n    - Validate commit exists\n    - Ask for branch name\n    - Create branch at commit\n    - Offer to switch to branch\n\n12. **Execute:**\n    ```bash\n    git branch <new-branch-name> <commit-hash>\n    ```\n\n13. **Verify:**\n    - Show branch created\n    - Show commit it points to\n    - Show how to access it\n    - Offer to checkout\n\n### Show Specific Commit\n\n14. **Display lost commit:**\n    ```bash\n    git show <commit-hash>\n    ```\n\n15. **Show details:**\n    - Full commit message\n    - Author and date\n    - Files changed\n    - Full diff\n    - Parent commits\n\n16. **Actions after showing:**\n    - Offer to recover\n    - Create branch\n    - Cherry-pick\n    - Export as patch\n    - Copy hash to clipboard\n\n### Understand History\n\n17. **Timeline visualization:**\n    - Show reflog as timeline\n    - Highlight branch points\n    - Show where mistakes happened\n    - Trace commit lineage\n\n18. **Before/After comparison:**\n    - Show state before mistake\n    - Show state after mistake\n    - Show what was lost\n    - Show recovery path\n\n## Safety Checks\n\n### Before Recovery\n\n- **Verify commit exists:**\n  ```bash\n  if ! git cat-file -e \"$commit_hash\" 2>/dev/null; then\n    echo \"Error: Commit not found: $commit_hash\"\n    echo \"It may have been garbage collected\"\n    echo \"Try: git fsck --lost-found\"\n    exit 1\n  fi\n  ```\n\n- **Check current state:**\n  ```bash\n  if [ -n \"$(git status --porcelain)\" ]; then\n    echo \"Warning: You have uncommitted changes\"\n    git status --short\n    echo \"\"\n    echo \"Recovery operations may affect these changes\"\n    echo \"Commit or stash them first? (y/n/continue)\"\n  fi\n  ```\n\n- **Create backup:**\n  ```bash\n  current_branch=$(git branch --show-current)\n  backup_branch=\"backup-${current_branch}-$(date +%s)\"\n  git branch \"$backup_branch\"\n\n  echo \"Created backup branch: $backup_branch\"\n  echo \"To restore current state: git reset --hard $backup_branch\"\n  ```\n\n### During Recovery\n\n- **Confirm destructive operations:**\n  ```bash\n  if [ \"$action\" = \"reset\" ]; then\n    echo \"⚠ WARNING: git reset --hard is DESTRUCTIVE\"\n    echo \"\"\n    echo \"This will:\"\n    echo \"  - Move current branch to: $commit_hash\"\n    echo \"  - Discard all commits after target\"\n    echo \"  - Lose uncommitted changes\"\n    echo \"\"\n    echo \"Backup created: $backup_branch\"\n    echo \"\"\n    echo \"Type 'RESET' to confirm: \"\n    read confirmation\n    [ \"$confirmation\" != \"RESET\" ] && exit 0\n  fi\n  ```\n\n- **Verify commit is reachable:**\n  ```bash\n  # Check commit is in reflog\n  if ! git reflog | grep -q \"$commit_hash\"; then\n    echo \"Notice: Commit not in current branch's reflog\"\n    echo \"It may be from another branch or remote\"\n    echo \"Continue? (y/n)\"\n  fi\n  ```\n\n### After Recovery\n\n- **Verify recovery:**\n  ```bash\n  echo \"Recovery complete!\"\n  echo \"\"\n  echo \"Verification:\"\n  echo \"  Recovered commit: $commit_hash\"\n  echo \"  Current HEAD: $(git rev-parse HEAD)\"\n  echo \"  Current branch: $(git branch --show-current)\"\n  echo \"\"\n  echo \"Check recovered work:\"\n  git show --stat HEAD\n  echo \"\"\n  echo \"Run tests to verify everything works\"\n  ```\n\n- **Cleanup suggestion:**\n  ```bash\n  echo \"\"\n  echo \"After verifying recovery:\"\n  echo \"  - Delete backup branch if not needed:\"\n  echo \"    git branch -d $backup_branch\"\n  echo \"  - Push if needed:\"\n  echo \"    git push --force-with-lease\"\n  ```\n\n## Error Handling\n\n### Commit Not Found\n\n```bash\nif ! git cat-file -e \"$commit_hash\" 2>/dev/null; then\n  echo \"Error: Commit not found in repository\"\n  echo \"Commit: $commit_hash\"\n  echo \"\"\n  echo \"Possible reasons:\"\n  echo \"  - Commit was garbage collected (>90 days old)\"\n  echo \"  - Typo in commit hash\"\n  echo \"  - Commit in different repository\"\n  echo \"\"\n  echo \"Try these recovery methods:\"\n  echo \"  1. Check reflog: git reflog show --all\"\n  echo \"  2. Search all refs: git log --all --oneline | grep <message>\"\n  echo \"  3. Find dangling commits: git fsck --lost-found\"\n  exit 1\nfi\n```\n\n### Reflog Expired\n\n```bash\n# Check if reflog exists\nif [ ! -f \".git/logs/HEAD\" ]; then\n  echo \"Error: No reflog found\"\n  echo \"\"\n  echo \"Possible reasons:\"\n  echo \"  - Fresh clone (reflog not transferred)\"\n  echo \"  - Reflog disabled in config\"\n  echo \"  - Repository corruption\"\n  echo \"\"\n  echo \"Recovery may not be possible\"\n  exit 1\nfi\n\n# Check reflog age\noldest_entry=$(git reflog show | tail -1)\necho \"Oldest reflog entry: $oldest_entry\"\necho \"\"\necho \"Reflog entries older than ~90 days are garbage collected\"\necho \"If your lost work is older, recovery may not be possible\"\n```\n\n### Branch Creation Failed\n\n```bash\nif git branch \"$new_branch\" \"$commit_hash\" 2>&1 | grep -q \"already exists\"; then\n  echo \"Error: Branch already exists: $new_branch\"\n  echo \"\"\n  echo \"Options:\"\n  echo \"  1. Choose different name\"\n  echo \"  2. Delete existing branch: git branch -D $new_branch\"\n  echo \"  3. Reset existing branch: git branch -f $new_branch $commit_hash\"\n  exit 1\nfi\n```\n\n### Reset Failed\n\n```bash\nif ! git reset --hard \"$commit_hash\" 2>&1; then\n  echo \"Error: Reset failed\"\n  echo \"\"\n  echo \"Your repository state was not changed\"\n  echo \"Check: git status\"\n  echo \"\"\n  echo \"If you have backup branch:\"\n  echo \"  git reset --hard $backup_branch\"\n  exit 1\nfi\n```\n\n## Examples\n\n### Example 1: View Recent Reflog\n\n```bash\n/git:reflog-recover\n\n# Reflog Entries (Recent 30):\n# ========================================\n#\n# HEAD@{0}  abc1234  5 minutes ago\n#   commit: Add user authentication\n#\n# HEAD@{1}  def5678  2 hours ago\n#   checkout: moving from main to feature-auth\n#\n# HEAD@{2}  ghi9012  3 hours ago\n#   reset: moving to HEAD^\n#   ⚠ RESET - Commits may be lost\n#\n# HEAD@{3}  jkl3456  3 hours ago\n#   commit: Fix token validation\n#   [This commit was reset away!]\n#\n# HEAD@{4}  mno7890  5 hours ago\n#   commit (amend): Update README\n#   ⚠ AMEND - Previous version at HEAD@{5}\n#\n# HEAD@{5}  pqr3456  5 hours ago\n#   commit: Update README\n#   [Original version before amend]\n#\n# ...\n#\n# Actions:\n# [r] Recover specific entry\n# [s] Search reflog\n# [q] Quit\n```\n\n### Example 2: Recover from Accidental Reset\n\n```bash\n# Situation: Accidentally did git reset --hard HEAD^\n# Lost last commit!\n\n/git:reflog-recover\n\n# Looking at reflog:\n# HEAD@{0}  def5678  reset: moving to HEAD^  (just now)\n# HEAD@{1}  abc1234  commit: Important feature  (5 min ago) ← Lost!\n\n# Select entry to recover: HEAD@{1}\n# User: 1\n#\n# Commit Details:\n# ========================================\n# Hash: abc1234567890abcdef\n# Message: Important feature\n# Author: John Doe\n# Date: 2025-10-21 14:30:00\n#\n# Files Changed:\n#   src/feature.js | 45 +++++++++++++++++++++++++\n#   tests/feature.test.js | 23 +++++++++++++\n#\n# Recovery Options:\n# 1. Create branch (safest)\n# 2. Reset current branch (restore state)\n# 3. Cherry-pick commit\n# 4. Show more details\n#\n# Choice: 2\n#\n# ⚠ This will reset current branch\n# Backup created: backup-main-1729534567\n# Type 'RESET' to confirm: RESET\n#\n# Resetting to abc1234...\n# ✓ Recovery complete!\n#\n# You are now at: Important feature\n# Lost commit is recovered!\n```\n\n### Example 3: Find and Recover Deleted Branch\n\n```bash\n/git:reflog-recover \"deleted branch\" show\n\n# Searching reflog for: \"deleted branch\"\n#\n# Found 2 matches:\n# ========================================\n#\n# HEAD@{15}  def5678  2 days ago\n#   Branch: delete branch feature-x\n#   Last commit on feature-x: \"Add feature X\"\n#\n# HEAD@{145}  abc1234  2 months ago\n#   Branch: delete branch old-experiment\n#   Last commit: \"Experimental changes\"\n#\n# Recover which entry? (1-2, or 'all')\n# User: 1\n#\n# Recovering branch: feature-x\n# Last commit: def5678 \"Add feature X\"\n#\n# New branch name? (default: feature-x)\n# User: feature-x-recovered\n#\n# Creating branch...\n# ✓ Created branch: feature-x-recovered at def5678\n#\n# To use recovered branch:\n#   git checkout feature-x-recovered\n#\n# Switch now? (y/n)\n# User: y\n#\n# ✓ Switched to branch 'feature-x-recovered'\n# Your deleted branch is recovered!\n```\n\n### Example 4: Undo Bad Rebase\n\n```bash\n# Situation: Rebase went wrong, conflicts everywhere\n# Want to undo entire rebase\n\n/git:reflog-recover rebase\n\n# Searching for: rebase\n#\n# Found rebase operations:\n# ========================================\n#\n# HEAD@{0}  abc9999  rebase (finish): refs/heads/feature\n#   (5 minutes ago) ← Bad rebase!\n#\n# HEAD@{1}  def8888  rebase (continue): Add feature Y\n#   (7 minutes ago)\n#\n# HEAD@{2}  ghi7777  rebase (start): checkout main\n#   (10 minutes ago)\n#\n# HEAD@{3}  jkl6666  commit: Add feature Y\n#   (15 minutes ago) ← Before rebase started\n#\n# Recover to before rebase? (entry 3)\n# User: y\n#\n# This will restore branch to: jkl6666\n# Before rebase started\n#\n# Recovery method:\n# 1. Reset branch (undo rebase)\n# 2. Create new branch (keep both)\n#\n# Choice: 1\n#\n# Creating backup: backup-feature-1729534567\n# Resetting to jkl6666...\n# ✓ Rebase undone!\n#\n# You are back to state before rebase\n# Original commits preserved\n```\n\n### Example 5: Find Lost Work by Keyword\n\n```bash\n/git:reflog-recover \"authentication\" show\n\n# Searching for: \"authentication\"\n#\n# Found 8 entries with \"authentication\":\n# ========================================\n#\n# HEAD@{3}  abc1234  3 hours ago\n#   commit: Add user authentication\n#\n# HEAD@{12}  def5678  1 day ago\n#   commit: Fix authentication bug\n#\n# HEAD@{25}  ghi9012  3 days ago\n#   commit: Update authentication flow\n#\n# HEAD@{45}  jkl3456  1 week ago\n#   commit: Implement OAuth authentication\n#\n# ...\n#\n# Show details for which entry? (number or 'all')\n# User: 3\n#\n# Commit: ghi9012\n# ========================================\n# Message: Update authentication flow\n# Author: Jane Smith\n# Date: 2025-10-18 10:15:00\n#\n# Changes:\n#   src/auth/flow.js | 67 ++++++++++++++++++++++++++++++++\n#   src/auth/middleware.js | 34 +++++++++++++---\n#\n# [Shows full diff]\n#\n# Actions:\n# [b] Create branch from this commit\n# [c] Cherry-pick to current branch\n# [p] Export as patch\n# [q] Back to list\n```\n\n### Example 6: Recover Amended Commit\n\n```bash\n# Situation: Amended commit but want original version\n\n/git:reflog-recover \"amend\"\n\n# Searching for: amend\n#\n# Found amendments:\n# ========================================\n#\n# HEAD@{0}  abc9999  commit (amend): Fix typo in docs\n#   (2 minutes ago) ← New version\n#\n# HEAD@{1}  abc1234  commit: Fix typo in docs\n#   (5 minutes ago) ← Original version before amend\n#\n# Compare versions? (y/n)\n# User: y\n#\n# Differences between versions:\n# ========================================\n# Original (abc1234):\n#   Fixed typo in README\n#   [Shows original diff]\n#\n# Amended (abc9999):\n#   Fixed typo in README and CONTRIBUTING\n#   [Shows amended diff]\n#\n# Recover original version?\n# 1. Create branch with original\n# 2. Reset to original (lose amendment)\n# 3. Keep amended version\n#\n# Choice: 1\n#\n# Branch name: pre-amend-version\n# ✓ Created branch with original version\n```\n\n## Advanced Usage\n\n### Find Dangling Commits\n\n```bash\n# Find commits not in any branch (beyond reflog)\ngit fsck --lost-found\n\n# Shows unreachable commits\n# More aggressive than reflog\n# Can find very old lost commits\n```\n\n### Export Reflog\n\n```bash\n# Save reflog to file\ngit reflog show > reflog-backup-$(date +%Y%m%d).txt\n\n# Useful before dangerous operations\n# Can review later if needed\n```\n\n### Reflog for Specific Branch\n\n```bash\n# View reflog for specific branch\ngit reflog show feature-branch\n\n# See all changes to that branch\n# Not just HEAD movements\n```\n\n### Reflog with Dates\n\n```bash\n# Show reflog with exact dates\ngit reflog show --date=iso\n\n# Or relative dates\ngit reflog show --date=relative\n\n# Find what happened at specific time\ngit reflog show HEAD@{2025-10-21.14:30:00}\n```\n\n### Expire Reflog Manually\n\n```bash\n# Expire reflog entries older than X\ngit reflog expire --expire=30.days --all\n\n# Aggressive cleanup\ngit reflog expire --expire=now --all\ngit gc --prune=now\n\n# Only do if sure!\n```\n\n## Tips for Using Reflog\n\n1. **Act quickly:**\n   - Reflog expires after ~90 days\n   - Recover as soon as you notice mistake\n   - Don't wait\n\n2. **Check reflog before dangerous operations:**\n   - Before reset --hard\n   - Before rebase\n   - Before force-push\n   - Know you can undo\n\n3. **Search effectively:**\n   - Use keywords from commit messages\n   - Search by branch names\n   - Look for operation types (reset, rebase)\n\n4. **Create branches, don't reset:**\n   - Safest recovery method\n   - Can review before deciding\n   - Preserves current state\n\n5. **Regular reflog backups:**\n   - Export reflog periodically\n   - Especially before risky operations\n   - Extra safety net\n\n6. **Understand reflog vs garbage collection:**\n   - Reflog keeps references\n   - Prevents garbage collection\n   - After expiry, commits can be GC'd\n\n## Related Commands\n\n- `/git:branch-cleanup` - Clean up recovered branches\n- `/git:cherry-pick-helper` - Apply recovered commits\n- `/git:bisect` - Find bugs in recovered history\n- `/git:worktree` - Test recovered commits safely"
              },
              {
                "name": "/stash-manager",
                "description": "Advanced stash management including list, save, apply, pop, and organize stashes with detailed context.",
                "path": "plugins/utilities/git/commands/stash-manager.md",
                "frontmatter": {
                  "name": "git:stash-manager",
                  "description": "Advanced stash management including list, save, apply, pop, and organize stashes with detailed context."
                },
                "content": "# Git Stash Manager - Advanced Stash Operations\n\nAdvanced stash management including list, save, apply, pop, and organize stashes with detailed context.\n\n## Command\n\n`/git:stash-manager <action> [stash-ref-or-message]`\n\n## Arguments\n\n- `$1`: action - `list|save|apply|pop|show|drop|clear|branch` (required)\n- `$2`: stash-ref or message - Depends on action (stash@{n} for apply/pop/show/drop, message for save)\n\n## Description\n\nGit stash allows you to save uncommitted changes temporarily and restore them later. This is useful when you need to switch contexts, pull updates, or try experimental changes without committing. The stash manager provides an organized way to manage multiple stashes with better visibility and control.\n\n## Use Cases\n\n- Switch branches without committing work-in-progress\n- Pull latest changes with uncommitted local changes\n- Try experimental changes with easy rollback\n- Temporarily remove changes to test something\n- Save different variations of work\n- Transfer changes between branches\n- Context switching during interruptions\n\n## Workflow\n\n### Listing Stashes\n\n1. **Display all stashes:**\n   ```bash\n   git stash list\n   ```\n\n2. **Enhanced listing with details:**\n   - Show stash index and message\n   - Show branch where stash was created\n   - Show date/time of stash creation\n   - Show which files are affected\n   - Show summary of changes (additions/deletions)\n   - Highlight recent stashes (< 24 hours)\n\n3. **For each stash show:**\n   ```\n   stash@{0}: On feature-auth: WIP authentication module\n     Branch: feature-auth\n     Created: 2 hours ago (2025-10-21 14:30:15)\n     Files: 3 modified, 1 added\n       M  src/auth.js (+45, -12)\n       M  src/session.js (+23, -5)\n       A  src/token.js (+67)\n     Size: ~135 lines changed\n   ```\n\n4. **Interactive options:**\n   - Show diff for specific stash\n   - Apply or pop stash\n   - Delete stash\n   - Create branch from stash\n   - Export stash as patch file\n\n### Saving Stashes\n\n5. **Gather stash options:**\n   - Ask for descriptive message (required)\n   - Ask if including untracked files (`-u`)\n   - Ask if including ignored files (`-a`, all)\n   - Ask if keeping staged changes (`--keep-index`)\n   - Ask if including path-specific changes\n\n6. **Create stash with options:**\n\n   Basic stash:\n   ```bash\n   git stash push -m \"message\"\n   ```\n\n   With untracked files:\n   ```bash\n   git stash push -u -m \"message\"\n   ```\n\n   Keep staged changes:\n   ```bash\n   git stash push --keep-index -m \"message\"\n   ```\n\n   Specific paths only:\n   ```bash\n   git stash push -m \"message\" -- path/to/file path/to/dir\n   ```\n\n7. **Confirm stash created:**\n   - Show stash reference (stash@{0})\n   - Show what was stashed\n   - Show current status\n   - Offer to show stash diff\n\n### Applying Stashes\n\n8. **Select stash to apply:**\n   - If no stash-ref provided, show list\n   - Ask user to select by number or reference\n   - Show stash details before applying\n   - Warn if stash is from different branch\n\n9. **Pre-apply checks:**\n   - Check for uncommitted changes (warn about merge)\n   - Check for conflicts with stash\n   - Dry-run to predict conflicts\n   - Show which files will be modified\n\n10. **Apply stash:**\n    ```bash\n    git stash apply stash@{n}\n    ```\n\n    Or with index restoration:\n    ```bash\n    git stash apply --index stash@{n}\n    ```\n\n11. **Handle conflicts:**\n    - If conflicts occur, show conflicted files\n    - Guide through resolution\n    - Offer to abort (stash remains in list)\n    - After resolution, stash remains in list\n\n12. **Confirm application:**\n    - Show what was applied\n    - Note that stash still exists (use pop to remove)\n    - Show current status\n\n### Popping Stashes\n\n13. **Pop vs Apply:**\n    - Explain difference: pop removes stash after applying\n    - Confirm user wants to remove stash\n    - Recommend apply if unsure\n\n14. **Pop stash:**\n    ```bash\n    git stash pop stash@{n}\n    ```\n\n15. **On success:**\n    - Stash is removed from list\n    - Changes applied to working directory\n    - Show updated status\n\n16. **On conflict:**\n    - Changes partially applied\n    - Stash is NOT removed\n    - Must resolve conflicts manually\n    - Can abort with `git reset --hard`\n\n### Showing Stash Details\n\n17. **Display stash content:**\n    ```bash\n    git stash show -p stash@{n}\n    ```\n\n18. **Show comprehensive details:**\n    - Commit information\n    - Full diff of changes\n    - Summary statistics\n    - List of affected files\n    - Branch context\n\n19. **Interactive options:**\n    - View file-by-file\n    - Show only specific files\n    - Compare with current working directory\n    - Apply/pop after viewing\n\n### Dropping Stashes\n\n20. **Confirm deletion:**\n    - Show stash details before dropping\n    - Warn that drop is permanent\n    - Require explicit confirmation\n    - Offer to save as patch file first\n\n21. **Drop stash:**\n    ```bash\n    git stash drop stash@{n}\n    ```\n\n22. **Recovery note:**\n    - Explain dropped stashes can be recovered (briefly)\n    - Mention reflog recovery within ~90 days\n    - Show recover command hint\n\n### Clearing All Stashes\n\n23. **Warning prompt:**\n    - Show count of stashes to be deleted\n    - List all stashes briefly\n    - Warn this is permanent\n    - Require typing \"yes\" to confirm\n\n24. **Clear all stashes:**\n    ```bash\n    git stash clear\n    ```\n\n25. **Confirmation:**\n    - Confirm all stashes cleared\n    - Note that recovery may be possible via reflog\n    - Show clean stash list\n\n### Creating Branch from Stash\n\n26. **Create branch with stash:**\n    - Useful when stash has conflicts with current branch\n    - Ask for new branch name\n    - Create branch and apply stash\n\n27. **Execute:**\n    ```bash\n    git stash branch <branch-name> stash@{n}\n    ```\n\n28. **Result:**\n    - New branch created from commit where stash was created\n    - Stash applied to new branch\n    - Stash removed from list\n    - Switched to new branch\n\n## Safety Checks\n\n### Before Saving Stash\n\n- **Nothing to stash:**\n  ```bash\n  if [ -z \"$(git status --porcelain)\" ]; then\n    echo \"Error: No changes to stash\"\n    echo \"Working directory is clean\"\n    exit 1\n  fi\n  ```\n\n- **Descriptive message required:**\n  ```bash\n  if [ -z \"$message\" ] || [ \"$message\" = \"WIP\" ]; then\n    echo \"Please provide a descriptive stash message\"\n    echo \"Bad: 'WIP', 'temp', 'stuff'\"\n    echo \"Good: 'WIP: authentication refactor', 'Debug logging for issue #123'\"\n    # Ask for better message\n  fi\n  ```\n\n- **Untracked files warning:**\n  ```bash\n  untracked_count=$(git ls-files --others --exclude-standard | wc -l)\n  if [ $untracked_count -gt 0 ]; then\n    echo \"Warning: $untracked_count untracked file(s) detected\"\n    echo \"Include untracked files in stash? (y/n)\"\n    echo \"Use -u flag to include them\"\n  fi\n  ```\n\n### Before Applying/Popping\n\n- **Uncommitted changes warning:**\n  ```bash\n  if [ -n \"$(git status --porcelain)\" ]; then\n    echo \"Warning: You have uncommitted changes\"\n    echo \"Applying stash may cause conflicts\"\n    echo \"\"\n    git status --short\n    echo \"\"\n    echo \"Options:\"\n    echo \"  1. Continue anyway (may conflict)\"\n    echo \"  2. Commit current changes first\"\n    echo \"  3. Stash current changes first (nested stash)\"\n    echo \"  4. Cancel\"\n  fi\n  ```\n\n- **Stash reference validation:**\n  ```bash\n  if ! git rev-parse --verify \"$stash_ref\" >/dev/null 2>&1; then\n    echo \"Error: Invalid stash reference: $stash_ref\"\n    echo \"\"\n    echo \"Available stashes:\"\n    git stash list\n    echo \"\"\n    echo \"Use: stash@{0}, stash@{1}, etc.\"\n    exit 1\n  fi\n  ```\n\n- **Branch mismatch warning:**\n  ```bash\n  stash_branch=$(git stash list | grep \"$stash_ref\" | sed 's/.*On \\([^:]*\\):.*/\\1/')\n  current_branch=$(git branch --show-current)\n\n  if [ \"$stash_branch\" != \"$current_branch\" ]; then\n    echo \"Notice: Stash created on different branch\"\n    echo \"  Stash from: $stash_branch\"\n    echo \"  Current: $current_branch\"\n    echo \"\"\n    echo \"This may cause conflicts. Continue? (y/n)\"\n  fi\n  ```\n\n- **Conflict prediction:**\n  ```bash\n  # Dry-run to check for conflicts\n  if ! git apply --check $(git stash show -p $stash_ref) 2>/dev/null; then\n    echo \"Warning: This stash may have conflicts\"\n    echo \"Files that may conflict:\"\n    # Show potentially conflicting files\n    echo \"\"\n    echo \"Continue? (y/n)\"\n  fi\n  ```\n\n### Before Dropping/Clearing\n\n- **Confirmation required:**\n  ```bash\n  echo \"About to drop stash: $stash_ref\"\n  git stash show --stat $stash_ref\n  echo \"\"\n  echo \"This cannot be undone easily!\"\n  echo \"Type 'yes' to confirm: \"\n  read confirmation\n\n  if [ \"$confirmation\" != \"yes\" ]; then\n    echo \"Drop cancelled\"\n    exit 0\n  fi\n  ```\n\n- **Offer patch export:**\n  ```bash\n  echo \"Save this stash as a patch file first? (y/n)\"\n  read save_patch\n\n  if [ \"$save_patch\" = \"y\" ]; then\n    patch_file=\"stash-$(date +%s).patch\"\n    git stash show -p $stash_ref > \"$patch_file\"\n    echo \"Saved to: $patch_file\"\n  fi\n  ```\n\n### After Operations\n\n- **Verify application:**\n  ```bash\n  echo \"Stash applied. Verifying...\"\n  echo \"\"\n  echo \"Changed files:\"\n  git status --short\n  echo \"\"\n  echo \"Run tests to verify everything works:\"\n  echo \"  npm test\"\n  echo \"  pytest\"\n  echo \"  cargo test\"\n  ```\n\n## Error Handling\n\n### No Stashes Exist\n\n```bash\nif [ -z \"$(git stash list)\" ]; then\n  echo \"No stashes found\"\n  echo \"\"\n  echo \"Create a stash with:\"\n  echo \"  /git:stash-manager save 'description'\"\n  echo \"\"\n  echo \"Or directly:\"\n  echo \"  git stash push -m 'description'\"\n  exit 1\nfi\n```\n\n### Apply/Pop Conflicts\n\n```bash\n# When git stash apply/pop fails with conflicts\nif [ $? -ne 0 ]; then\n  echo \"Conflict occurred while applying stash!\"\n  echo \"\"\n  echo \"Conflicted files:\"\n  git diff --name-only --diff-filter=U\n  echo \"\"\n  echo \"Options:\"\n  echo \"  1. Resolve conflicts manually:\"\n  echo \"     - Edit conflicted files\"\n  echo \"     - git add <file> (after resolving)\"\n  echo \"  2. Abort changes:\"\n  echo \"     git reset --hard HEAD\"\n  echo \"  3. Try applying to different branch:\"\n  echo \"     /git:stash-manager branch new-branch-name\"\n  echo \"\"\n  echo \"Note: For pop, stash was NOT removed due to conflict\"\n  exit 1\nfi\n```\n\n### Invalid Stash Reference\n\n```bash\nif ! git stash list | grep -q \"^$stash_ref:\"; then\n  echo \"Error: Stash not found: $stash_ref\"\n  echo \"\"\n  echo \"Available stashes:\"\n  git stash list | nl -v 0\n  echo \"\"\n  echo \"Note: stash@{0} is most recent\"\n  exit 1\nfi\n```\n\n### Stash Apply to Dirty Directory\n\n```bash\nif [ -n \"$(git status --porcelain)\" ]; then\n  echo \"Warning: Working directory has uncommitted changes\"\n  echo \"\"\n  git status --short\n  echo \"\"\n  echo \"Applying stash on top of these changes may cause issues\"\n  echo \"\"\n  echo \"Recommended: \"\n  echo \"  1. Commit current changes, or\"\n  echo \"  2. Stash current changes first (nested stash), or\"\n  echo \"  3. Use a worktree: /git:worktree\"\n  echo \"\"\n  echo \"Force apply anyway? (y/n)\"\n  read force\n  [ \"$force\" != \"y\" ] && exit 0\nfi\n```\n\n## Examples\n\n### Example 1: Save Stash with Description\n\n```bash\n/git:stash-manager save \"WIP: implementing OAuth authentication\"\n\n# Include untracked files? (y/n)\n# User: y\n#\n# Keep staged changes in working directory? (y/n)\n# User: n\n#\n# Saved working directory and index state:\n#   stash@{0}: On feature-auth: WIP: implementing OAuth authentication\n#\n# Stashed:\n#   3 modified files\n#   2 new files (untracked)\n#   Total: ~127 lines changed\n#\n# Working directory is now clean\n```\n\n### Example 2: List Stashes with Details\n\n```bash\n/git:stash-manager list\n\n# ========================================\n# Git Stashes (3)\n# ========================================\n#\n# stash@{0}: On feature-auth: WIP: implementing OAuth authentication\n#   Branch: feature-auth\n#   Created: 2 hours ago (2025-10-21 14:30:15)\n#   Files: 3 modified, 2 added\n#     M  src/auth/oauth.js (+45, -12)\n#     M  src/auth/session.js (+23, -5)\n#     A  src/auth/tokens.js (+67)\n#     A  tests/auth/oauth.test.js (+89)\n#\n# stash@{1}: On main: Fix styling issues on mobile\n#   Branch: main\n#   Created: 1 day ago (2025-10-20 09:15:42)\n#   Files: 5 modified\n#     M  src/styles/mobile.css (+34, -18)\n#     M  src/components/Header.js (+12, -8)\n#     ...\n#\n# stash@{2}: On feature-ui: Experimental layout changes\n#   Branch: feature-ui\n#   Created: 3 days ago (2025-10-18 16:45:00)\n#   Files: 8 modified, 1 deleted\n#     ...\n#\n# Actions: [s]how, [a]pply, [p]op, [d]rop, [q]uit\n```\n\n### Example 3: Apply Stash with Conflicts\n\n```bash\n/git:stash-manager apply stash@{0}\n\n# Applying stash@{0}...\n#   On feature-auth: WIP: implementing OAuth authentication\n#\n# Warning: You are on a different branch\n#   Stash from: feature-auth\n#   Current: main\n#\n# This may cause conflicts. Continue? (y/n)\n# User: y\n#\n# Applying...\n# Conflict in src/auth/oauth.js\n# Conflict in src/auth/session.js\n#\n# Conflicted files:\n#   src/auth/oauth.js\n#   src/auth/session.js\n#\n# Please resolve conflicts:\n#   1. Edit files to resolve <<<< ==== >>>> markers\n#   2. Test your changes\n#   3. Stage resolved files: git add <file>\n#\n# Or abort:\n#   git reset --hard HEAD\n#\n# Note: Stash still exists (not removed)\n```\n\n### Example 4: Pop Most Recent Stash\n\n```bash\n/git:stash-manager pop\n\n# Most recent stash:\n#   stash@{0}: On feature-auth: WIP: implementing OAuth authentication\n#   3 files modified, 2 files added\n#\n# Apply and remove this stash? (y/n)\n# User: y\n#\n# Applying stash@{0}...\n# Success!\n#\n# Changed files:\n#   M  src/auth/oauth.js\n#   M  src/auth/session.js\n#   M  src/auth/tokens.js\n#   A  tests/auth/oauth.test.js\n#   A  tests/auth/tokens.test.js\n#\n# Stash removed from list\n# Current status: 5 files modified\n```\n\n### Example 5: Show Stash Details\n\n```bash\n/git:stash-manager show stash@{1}\n\n# ========================================\n# Stash: stash@{1}\n# ========================================\n# Message: Fix styling issues on mobile\n# Branch: main\n# Created: 1 day ago (2025-10-20 09:15:42)\n# Author: John Doe <john@example.com>\n#\n# Files Changed (5):\n# ========================================\n# src/styles/mobile.css | 52 ++++++++++++++++++++++-----------\n# src/components/Header.js | 20 ++++++------\n# src/components/Nav.js | 15 ++++++---\n# src/components/Footer.js | 8 ++---\n# src/index.css | 3 +-\n#\n# Diff:\n# ========================================\n# [Shows full diff output...]\n#\n# Actions:\n#   [a] Apply this stash\n#   [p] Pop this stash\n#   [d] Drop this stash\n#   [b] Create branch from stash\n#   [q] Back to list\n```\n\n### Example 6: Drop Specific Stash\n\n```bash\n/git:stash-manager drop stash@{2}\n\n# About to drop:\n#   stash@{2}: On feature-ui: Experimental layout changes\n#   Created: 3 days ago\n#   8 files modified, 1 file deleted\n#\n# This cannot be easily undone!\n#\n# Save as patch file first? (y/n)\n# User: y\n#\n# Saved to: stash-1729534567.patch\n#\n# Type 'yes' to confirm deletion:\n# User: yes\n#\n# Dropped stash@{2}\n# Recovery may be possible via reflog:\n#   git fsck --unreachable | grep commit\n```\n\n### Example 7: Clear All Stashes\n\n```bash\n/git:stash-manager clear\n\n# WARNING: About to delete ALL stashes!\n#\n# Current stashes (3):\n#   stash@{0}: WIP: implementing OAuth authentication\n#   stash@{1}: Fix styling issues on mobile\n#   stash@{2}: Experimental layout changes\n#\n# This action is PERMANENT!\n#\n# Type 'DELETE ALL' to confirm:\n# User: DELETE ALL\n#\n# Cleared all stashes\n# Stash list is now empty\n#\n# Note: Recovery may be possible within 90 days via reflog\n```\n\n### Example 8: Create Branch from Stash\n\n```bash\n/git:stash-manager branch experimental-auth stash@{0}\n\n# Creating branch from stash...\n#   Branch: experimental-auth\n#   Based on commit where stash was created\n#   Stash: stash@{0}: WIP: implementing OAuth authentication\n#\n# Created branch 'experimental-auth'\n# Switched to branch 'experimental-auth'\n# Applied stash changes\n# Dropped stash@{0}\n#\n# Your changes are now on branch: experimental-auth\n# Status: 5 files modified\n```\n\n## Advanced Usage\n\n### Partial Stash (Specific Files)\n\n```bash\n# Stash only specific files\n/git:stash-manager save \"WIP: auth module only\"\n\n# Which files to stash?\n# User: src/auth/*.js tests/auth/*.js\n\n# Command:\ngit stash push -m \"WIP: auth module only\" -- src/auth/*.js tests/auth/*.js\n```\n\n### Interactive Stash\n\n```bash\n# Stash with interactive staging\ngit stash push -p -m \"Selected changes only\"\n\n# Prompts for each hunk: stage this hunk? y/n\n```\n\n### Stash to Patch File\n\n```bash\n# Export stash as patch\ngit stash show -p stash@{0} > my-changes.patch\n\n# Later, apply patch\ngit apply my-changes.patch\n\n# Or:\npatch -p1 < my-changes.patch\n```\n\n### View Stash as Commit\n\n```bash\n# Each stash is actually a commit\ngit show stash@{0}\n\n# View stash log\ngit log --oneline --graph stash@{0}\n\n# Stash has 3 parents:\n# 1. HEAD when stash was created\n# 2. Index state\n# 3. Untracked files (if -u used)\n```\n\n## Tips for Effective Stash Usage\n\n1. **Descriptive messages:**\n   - Bad: \"WIP\", \"temp\", \"stuff\"\n   - Good: \"WIP: OAuth integration\", \"Debug: issue #123\", \"Experiment: new layout\"\n   - Include ticket numbers, feature names, or context\n\n2. **Keep stashes short-lived:**\n   - Don't use stash as long-term storage\n   - Apply or pop within a day or two\n   - For longer storage, commit to a branch\n\n3. **One stash at a time (usually):**\n   - Multiple stashes get confusing\n   - Apply/pop before creating new ones\n   - Use worktrees for parallel work instead\n\n4. **Include untracked files:**\n   - Use `-u` flag when saving\n   - Prevents forgetting about new files\n   - Makes stash more complete\n\n5. **Branch strategy:**\n   - If stash has conflicts, create branch\n   - Better than fighting conflicts\n   - Can merge branch later\n\n## Related Commands\n\n- `/git:worktree` - Better than stash for parallel work\n- `/git:branch-cleanup` - Clean up branches created from stashes\n- `/git:cherry-pick-helper` - Apply specific commits instead of stash\n- `/git:reflog-recover` - Recover dropped stashes"
              },
              {
                "name": "/worktree",
                "description": "Manage multiple working trees for parallel development, testing, and code review without branch switching overhead.",
                "path": "plugins/utilities/git/commands/worktree.md",
                "frontmatter": {
                  "name": "git:worktree",
                  "description": "Manage multiple working trees for parallel development, testing, and code review without branch switching overhead."
                },
                "content": "# Git Worktree - Multiple Working Trees Management\n\nManage multiple working trees for parallel development, testing, and code review without branch switching overhead.\n\n## Command\n\n`/git:worktree <action> [path] [branch-name]`\n\n## Arguments\n\n- `$1`: action - `add|list|remove|prune|lock|unlock` (required)\n- `$2`: path - Directory path for the worktree (required for add/remove)\n- `$3`: branch-name - Branch to checkout in worktree (optional for add)\n\n## Description\n\nGit worktrees allow you to have multiple working directories from the same repository, each with different branches checked out. This eliminates the need to stash changes, switch branches, and potentially deal with conflicts when you need to work on multiple features simultaneously or review code while keeping your current work intact.\n\n## Use Cases\n\n- Work on multiple features simultaneously\n- Review pull requests without interrupting current work\n- Run tests on one branch while developing on another\n- Compare code between branches side-by-side\n- Keep a clean build directory separate from development\n- Emergency hotfixes without stashing current work\n\n## Workflow\n\n### Adding a New Worktree\n\n1. **Validate input:**\n   - Check path doesn't already exist\n   - Check path is not inside current repository\n   - Validate branch name if provided\n   - Check for branch conflicts\n\n2. **Gather information:**\n   - Ask for target path (relative or absolute)\n   - Ask for branch name (or generate from feature name)\n   - Ask if creating new branch or checking out existing\n   - Optionally ask for starting point (commit/branch to base on)\n\n3. **Create worktree:**\n\n   For new branch:\n   ```bash\n   git worktree add -b <new-branch> <path> <starting-point>\n   ```\n\n   For existing branch:\n   ```bash\n   git worktree add <path> <existing-branch>\n   ```\n\n   Create worktree and checkout:\n   ```bash\n   git worktree add <path>\n   # Creates new branch from HEAD\n   ```\n\n4. **Post-creation:**\n   - Confirm worktree created successfully\n   - Display worktree information\n   - Show path, branch, and commit\n   - Offer to change directory to new worktree\n   - Suggest next steps (cd command, IDE instructions)\n\n### Listing Worktrees\n\n5. **Display all worktrees:**\n   - Show main working tree\n   - Show all linked worktrees\n   - For each worktree show:\n     - Path (absolute)\n     - Branch name\n     - Commit hash and message\n     - Status (clean/modified/locked)\n     - Whether it's the current worktree\n\n6. **Enhanced listing:**\n   ```bash\n   git worktree list --porcelain\n   ```\n\n   Parse and display:\n   - Which worktree is current (*)\n   - Uncommitted changes indicator\n   - Days since last commit\n   - Locked status with reason\n\n7. **Interactive options:**\n   - Offer to show details for specific worktree\n   - Option to remove stale worktrees\n   - Option to navigate to worktree\n   - Show disk usage per worktree\n\n### Removing a Worktree\n\n8. **Pre-removal checks:**\n   - Verify worktree exists\n   - Check if it's the current worktree (can't remove)\n   - Check for uncommitted changes\n   - Check for unpushed commits\n   - Warn about any issues\n\n9. **Confirm removal:**\n   - Show worktree details\n   - Show what will be lost\n   - Ask for explicit confirmation\n   - Option to force remove if locked\n\n10. **Remove worktree:**\n    ```bash\n    git worktree remove <path>\n    ```\n\n    Or force removal:\n    ```bash\n    git worktree remove --force <path>\n    ```\n\n11. **Post-removal:**\n    - Confirm removal successful\n    - Note that branch still exists (unless deleted)\n    - Offer to delete branch if fully merged\n    - Show updated worktree list\n\n### Pruning Stale Worktrees\n\n12. **Find stale entries:**\n    - Worktree directories that no longer exist\n    - Locked worktrees that can be cleaned\n    - Administrative data that can be pruned\n\n13. **Show what will be pruned:**\n    ```bash\n    git worktree prune --dry-run\n    ```\n\n14. **Prune stale entries:**\n    ```bash\n    git worktree prune\n    ```\n\n15. **Confirm results:**\n    - Show what was pruned\n    - Display updated worktree list\n\n### Lock/Unlock Worktrees\n\n16. **Lock worktree:**\n    - Prevent accidental removal\n    - Useful for worktrees on removable media\n    - Add reason for lock\n    ```bash\n    git worktree lock --reason \"Testing environment\" <path>\n    ```\n\n17. **Unlock worktree:**\n    ```bash\n    git worktree unlock <path>\n    ```\n\n## Safety Checks\n\n### Before Adding\n\n- **Path validation:**\n  ```bash\n  # Check path doesn't exist\n  if [ -e \"$path\" ]; then\n    echo \"Error: Path already exists: $path\"\n    echo \"Choose a different path or remove existing directory\"\n    exit 1\n  fi\n\n  # Check path is not inside repository\n  if [[ \"$path\" == \"$(git rev-parse --show-toplevel)\"* ]]; then\n    echo \"Warning: Creating worktree inside repository\"\n    echo \"This is unusual. Continue? (y/n)\"\n    # Wait for confirmation\n  fi\n  ```\n\n- **Branch validation:**\n  ```bash\n  # Check if branch exists\n  if git show-ref --verify --quiet refs/heads/$branch; then\n    # Branch exists\n    # Check if already checked out in another worktree\n    if git worktree list | grep -q \"$branch\"; then\n      echo \"Error: Branch '$branch' is already checked out in another worktree\"\n      echo \"A branch can only be checked out in one worktree at a time\"\n      exit 1\n    fi\n  fi\n  ```\n\n- **Disk space check:**\n  ```bash\n  # Check available disk space\n  available=$(df \"$target_dir\" | awk 'NR==2 {print $4}')\n  repo_size=$(du -s \"$(git rev-parse --show-toplevel)\" | awk '{print $1}')\n\n  if [ $available -lt $repo_size ]; then\n    echo \"Warning: Low disk space\"\n    echo \"Available: ${available}K\"\n    echo \"Repository size: ${repo_size}K\"\n    echo \"Continue? (y/n)\"\n  fi\n  ```\n\n### Before Removing\n\n- **Uncommitted changes check:**\n  ```bash\n  cd \"$worktree_path\"\n  if [ -n \"$(git status --porcelain)\" ]; then\n    echo \"Warning: Worktree has uncommitted changes:\"\n    git status --short\n    echo \"\"\n    echo \"Options:\"\n    echo \"  1. Cancel removal\"\n    echo \"  2. Force remove (lose changes)\"\n    echo \"  3. Show me the changes first\"\n    # Wait for user choice\n  fi\n  ```\n\n- **Unpushed commits check:**\n  ```bash\n  unpushed=$(git log --oneline @{u}.. 2>/dev/null | wc -l)\n  if [ $unpushed -gt 0 ]; then\n    echo \"Warning: Worktree has $unpushed unpushed commit(s):\"\n    git log --oneline @{u}..\n    echo \"\"\n    echo \"These commits will NOT be lost (branch still exists)\"\n    echo \"But you may want to push them first.\"\n    echo \"Continue with removal? (y/n)\"\n  fi\n  ```\n\n- **Current worktree check:**\n  ```bash\n  current_worktree=$(git worktree list --porcelain | grep \"$(pwd)\" | head -1)\n  if [ -n \"$current_worktree\" ]; then\n    echo \"Error: Cannot remove current worktree\"\n    echo \"Please cd to a different directory first\"\n    exit 1\n  fi\n  ```\n\n- **Locked worktree check:**\n  ```bash\n  if git worktree list --porcelain | grep -A5 \"worktree $path\" | grep -q \"locked\"; then\n    reason=$(git worktree list --porcelain | grep -A5 \"worktree $path\" | grep \"locked\" | cut -d' ' -f2-)\n    echo \"Warning: Worktree is locked\"\n    echo \"Reason: $reason\"\n    echo \"\"\n    echo \"Options:\"\n    echo \"  1. Cancel removal\"\n    echo \"  2. Unlock and remove\"\n    echo \"  3. Force remove (keep lock reason for reference)\"\n  fi\n  ```\n\n### During Prune\n\n- **Dry-run first:**\n  ```bash\n  echo \"Finding stale worktrees...\"\n  git worktree prune --dry-run --verbose\n  echo \"\"\n  echo \"Proceed with pruning? (y/n)\"\n  ```\n\n## Error Handling\n\n### Path Already Exists\n\n```bash\nif [ -e \"$path\" ]; then\n  echo \"Error: Path already exists: $path\"\n\n  # Check if it's an old worktree directory\n  if [ -f \"$path/.git\" ]; then\n    content=$(cat \"$path/.git\")\n    if [[ $content == gitdir:* ]]; then\n      echo \"This appears to be an orphaned worktree directory\"\n      echo \"Options:\"\n      echo \"  1. Remove directory and create new worktree\"\n      echo \"  2. Try to repair worktree link\"\n      echo \"  3. Choose different path\"\n    fi\n  fi\n  exit 1\nfi\n```\n\n### Branch Already Checked Out\n\n```bash\nif git worktree list | grep -q \" \\[$branch\\]\"; then\n  existing_path=$(git worktree list | grep \" \\[$branch\\]\" | awk '{print $1}')\n  echo \"Error: Branch '$branch' is already checked out\"\n  echo \"Location: $existing_path\"\n  echo \"\"\n  echo \"A branch can only be checked out in one worktree at a time.\"\n  echo \"Options:\"\n  echo \"  1. Use a different branch name\"\n  echo \"  2. Remove the existing worktree first\"\n  echo \"  3. Navigate to existing worktree: cd $existing_path\"\n  exit 1\nfi\n```\n\n### Worktree Not Found\n\n```bash\nif ! git worktree list | grep -q \"$path\"; then\n  echo \"Error: No worktree found at: $path\"\n  echo \"\"\n  echo \"Available worktrees:\"\n  git worktree list\n  echo \"\"\n  echo \"Note: Path must match exactly as shown above\"\n  exit 1\nfi\n```\n\n### Cannot Remove Main Worktree\n\n```bash\nmain_worktree=$(git worktree list | head -1 | awk '{print $1}')\nif [ \"$path\" = \"$main_worktree\" ]; then\n  echo \"Error: Cannot remove main worktree\"\n  echo \"The main worktree is the original repository directory\"\n  echo \"You can only remove linked worktrees created with 'git worktree add'\"\n  exit 1\nfi\n```\n\n## Examples\n\n### Example 1: Add Worktree for Feature Development\n\n```bash\n# Interactive mode\n/git:worktree add\n\n# Claude prompts:\n# \"Where should the new worktree be created?\"\n# User: \"../feature-auth\"\n#\n# \"What branch should be checked out?\"\n# User: \"feature/oauth-integration\"\n#\n# \"This branch doesn't exist. Create new branch? (y/n)\"\n# User: \"y\"\n#\n# \"What should the new branch be based on? (default: HEAD)\"\n# User: \"main\"\n\n# Result:\n# Created worktree at: /Users/geoff/Projects/feature-auth\n# Branch: feature/oauth-integration (new)\n# Based on: main\n#\n# To start working:\n#   cd ../feature-auth\n```\n\n### Example 2: Direct Add Command\n\n```bash\n# Add worktree with new branch\n/git:worktree add ../feature-x feature/new-feature\n\n# Add worktree for existing branch\n/git:worktree add ../bugfix bugfix/issue-123\n\n# Add worktree with detached HEAD at specific commit\n/git:worktree add ../review abc1234\n```\n\n### Example 3: List All Worktrees\n\n```bash\n/git:worktree list\n\n# Output:\n# ========================================\n# Git Worktrees\n# ========================================\n#\n# * /Users/geoff/Projects/my-repo (main) [current]\n#   └─ Clean • Last commit: 2 hours ago\n#\n#   /Users/geoff/Projects/feature-auth (feature/oauth-integration)\n#   └─ Modified (3 files) • Last commit: 5 minutes ago\n#\n#   /Users/geoff/Projects/hotfix (hotfix/security-patch)\n#   └─ Clean • Last commit: 2 days ago • LOCKED\n#\n#   /Users/geoff/Projects/review (abc1234) [detached]\n#   └─ Clean • Last commit: 1 week ago\n#\n# Total: 4 worktrees\n```\n\n### Example 4: Remove Worktree\n\n```bash\n/git:worktree remove ../feature-x\n\n# Claude checks and prompts:\n# \"Worktree at ../feature-x has uncommitted changes:\"\n#   M  src/auth.js\n#   A  src/session.js\n#\n# \"What would you like to do?\"\n#   1. Cancel removal\n#   2. Show me the changes\n#   3. Force remove (changes will be lost)\n#\n# User choice: 2\n#\n# [Shows git diff output]\n#\n# \"Still want to remove? (y/n)\"\n# User: \"n\"\n#\n# \"Removal cancelled. You might want to:\"\n#   - cd ../feature-x\n#   - Commit your changes\n#   - Or: git stash in that worktree\n```\n\n### Example 5: Prune Stale Worktrees\n\n```bash\n/git:worktree prune\n\n# Output:\n# Finding stale worktrees...\n#\n# Would prune:\n#   - /Users/geoff/Projects/old-feature (directory removed)\n#   - /Volumes/USB/temp-worktree (volume unmounted)\n#\n# Proceed with pruning? (y/n)\n# User: y\n#\n# Pruned 2 stale worktree entries\n#\n# Updated worktree list:\n# [shows current worktrees]\n```\n\n## Advanced Usage\n\n### Worktree for PR Review\n\n```bash\n# Fetch PR branch\ngit fetch origin pull/123/head:pr-123\n\n# Create worktree for review\n/git:worktree add ../pr-review pr-123\n\n# Review in separate directory\ncd ../pr-review\n# Run tests, review code, test changes\n```\n\n### Worktree for Release Builds\n\n```bash\n# Create locked worktree for clean builds\n/git:worktree add ../build-release release-v1.0\ncd ../build-release\n\n# Lock it to prevent accidental removal\ngit worktree lock --reason \"Production build environment\"\n\n# Build\nnpm run build:production\n```\n\n### Worktree for Bisect\n\n```bash\n# Create worktree for git bisect without affecting main work\n/git:worktree add ../bisect-search main\ncd ../bisect-search\ngit bisect start HEAD v1.0.0\n# Run bisect without interrupting main development\n```\n\n### Multiple Feature Worktrees\n\n```bash\n# Main repo: ongoing development\ncd /Users/geoff/Projects/my-repo\n\n# Feature 1: new auth system\n/git:worktree add ../auth-feature feature/oauth\n\n# Feature 2: UI redesign\n/git:worktree add ../ui-feature feature/new-ui\n\n# Hotfix: security patch\n/git:worktree add ../hotfix hotfix/cve-2025-1234\n\n# PR review\n/git:worktree add ../pr-456 pr-456\n\n# Now work on any without switching branches in main repo\n```\n\n## Tips for Effective Worktree Usage\n\n1. **Organize worktree locations:**\n   - Keep worktrees in a dedicated parent directory\n   - Use descriptive directory names\n   - Example structure:\n     ```\n     ~/Projects/\n       my-repo/           # Main worktree\n       my-repo-features/  # Feature worktrees\n         auth/\n         ui-redesign/\n         api-v2/\n     ```\n\n2. **Naming conventions:**\n   - Use branch names as directory names for clarity\n   - Prefix with purpose: `review-`, `feature-`, `hotfix-`\n   - Keep names short but descriptive\n\n3. **Clean up regularly:**\n   - Remove worktrees when done with feature\n   - Run prune periodically\n   - Don't let worktrees accumulate\n\n4. **IDE considerations:**\n   - Open each worktree as separate project/window\n   - Be aware of shared config (.git directory)\n   - Watch for file watchers across worktrees\n\n5. **Branch management:**\n   - Remember: one branch per worktree\n   - Can't checkout same branch in multiple worktrees\n   - Delete branches after removing worktrees (if merged)\n\n## Related Commands\n\n- `/git:branch-cleanup` - Clean up branches from removed worktrees\n- `/git:stash-manager` - Not needed with worktrees (no branch switching)\n- `/git:bisect` - Use worktrees to bisect without interrupting work\n- `/git:cherry-pick-helper` - Cherry-pick between worktrees"
              }
            ],
            "skills": [
              {
                "name": "git-advanced",
                "description": "Advanced git operations including complex rebase strategies, interactive staging, commit surgery, and history manipulation. Use when user needs to perform complex git operations like rewriting history or advanced merging.",
                "path": "plugins/utilities/git/skills/git-advanced/SKILL.md",
                "frontmatter": {
                  "name": "git-advanced",
                  "description": "Advanced git operations including complex rebase strategies, interactive staging, commit surgery, and history manipulation. Use when user needs to perform complex git operations like rewriting history or advanced merging."
                },
                "content": "# Git Advanced Operations Skill\n\nThis skill provides comprehensive guidance on advanced git operations, sophisticated rebase strategies, commit surgery techniques, and complex history manipulation for experienced git users.\n\n## When to Use\n\nActivate this skill when:\n- Performing complex interactive rebases\n- Rewriting commit history\n- Splitting or combining commits\n- Advanced merge strategies\n- Cherry-picking across branches\n- Commit message editing in history\n- Author information changes\n- Complex conflict resolution\n\n## Interactive Rebase Strategies\n\n### Basic Interactive Rebase\n\n```bash\n# Rebase last 5 commits\ngit rebase -i HEAD~5\n\n# Rebase from specific commit\ngit rebase -i abc123^\n\n# Rebase entire branch\ngit rebase -i main\n```\n\n### Rebase Commands\n\n```bash\n# Interactive rebase editor commands:\n# p, pick = use commit\n# r, reword = use commit, but edit commit message\n# e, edit = use commit, but stop for amending\n# s, squash = use commit, but meld into previous commit\n# f, fixup = like squash, but discard commit message\n# x, exec = run command (the rest of the line) using shell\n# d, drop = remove commit\n```\n\n### Squashing Commits\n\n```bash\n# Example: Squash last 3 commits\ngit rebase -i HEAD~3\n\n# In editor:\npick abc123 feat: add user authentication\nsquash def456 fix: resolve login bug\nsquash ghi789 style: format code\n\n# Squash all commits in feature branch\ngit rebase -i main\n# Mark all except first as 'squash'\n```\n\n### Fixup Workflow\n\n```bash\n# Create fixup commit automatically\ngit commit --fixup=abc123\n\n# Autosquash during rebase\ngit rebase -i --autosquash main\n\n# Set autosquash as default\ngit config --global rebase.autosquash true\n\n# Example workflow:\ngit log --oneline -5\n# abc123 feat: add authentication\n# def456 feat: add authorization\ngit commit --fixup=abc123\ngit rebase -i --autosquash HEAD~3\n```\n\n### Reordering Commits\n\n```bash\n# Interactive rebase\ngit rebase -i HEAD~5\n\n# In editor, change order:\npick def456 feat: add database migration\npick abc123 feat: add user model\npick ghi789 feat: add API endpoints\n\n# Reorder by moving lines:\npick abc123 feat: add user model\npick def456 feat: add database migration\npick ghi789 feat: add API endpoints\n```\n\n### Splitting Commits\n\n```bash\n# Start interactive rebase\ngit rebase -i HEAD~3\n\n# Mark commit to split with 'edit'\nedit abc123 feat: add user and role features\n\n# When rebase stops:\ngit reset HEAD^\n\n# Stage and commit parts separately\ngit add user.go\ngit commit -m \"feat: add user management\"\n\ngit add role.go\ngit commit -m \"feat: add role management\"\n\n# Continue rebase\ngit rebase --continue\n```\n\n### Editing Old Commits\n\n```bash\n# Start interactive rebase\ngit rebase -i HEAD~5\n\n# Mark commit with 'edit'\nedit abc123 feat: add authentication\n\n# When rebase stops, make changes\ngit add modified-file.go\ngit commit --amend --no-edit\n\n# Or change commit message\ngit commit --amend\n\n# Continue rebase\ngit rebase --continue\n```\n\n## Commit Surgery\n\n### Amending Commits\n\n```bash\n# Amend last commit (add changes)\ngit add forgotten-file.go\ngit commit --amend --no-edit\n\n# Amend commit message\ngit commit --amend -m \"fix: correct typo in feature\"\n\n# Amend author information\ngit commit --amend --author=\"John Doe <john@example.com>\"\n\n# Amend date\ngit commit --amend --date=\"2024-03-15 10:30:00\"\n```\n\n### Changing Commit Messages\n\n```bash\n# Change last commit message\ngit commit --amend\n\n# Change older commit messages\ngit rebase -i HEAD~5\n# Mark commits with 'reword'\n\n# Change commit message without opening editor\ngit commit --amend -m \"new message\" --no-edit\n```\n\n### Changing Multiple Authors\n\n```bash\n# Filter-branch (legacy method, use filter-repo instead)\ngit filter-branch --env-filter '\nif [ \"$GIT_COMMITTER_EMAIL\" = \"old@example.com\" ]; then\n    export GIT_COMMITTER_NAME=\"New Name\"\n    export GIT_COMMITTER_EMAIL=\"new@example.com\"\nfi\nif [ \"$GIT_AUTHOR_EMAIL\" = \"old@example.com\" ]; then\n    export GIT_AUTHOR_NAME=\"New Name\"\n    export GIT_AUTHOR_EMAIL=\"new@example.com\"\nfi\n' --tag-name-filter cat -- --branches --tags\n\n# Modern method with git-filter-repo\ngit filter-repo --email-callback '\n    return email.replace(b\"old@example.com\", b\"new@example.com\")\n'\n```\n\n### Removing Files from History\n\n```bash\n# Remove file from all history\ngit filter-branch --tree-filter 'rm -f passwords.txt' HEAD\n\n# Better performance with index-filter\ngit filter-branch --index-filter 'git rm --cached --ignore-unmatch passwords.txt' HEAD\n\n# Modern method with git-filter-repo (recommended)\ngit filter-repo --path passwords.txt --invert-paths\n\n# Remove large files\ngit filter-repo --strip-blobs-bigger-than 10M\n```\n\n### BFG Repo-Cleaner\n\n```bash\n# Install BFG\n# brew install bfg (macOS)\n# apt-get install bfg (Ubuntu)\n\n# Remove files by name\nbfg --delete-files passwords.txt\n\n# Remove large files\nbfg --strip-blobs-bigger-than 50M\n\n# Replace passwords in history\nbfg --replace-text passwords.txt\n\n# After BFG cleanup\ngit reflog expire --expire=now --all\ngit gc --prune=now --aggressive\n```\n\n## Advanced Cherry-Picking\n\n### Basic Cherry-Pick\n\n```bash\n# Cherry-pick single commit\ngit cherry-pick abc123\n\n# Cherry-pick multiple commits\ngit cherry-pick abc123 def456 ghi789\n\n# Cherry-pick range of commits\ngit cherry-pick abc123..ghi789\n\n# Cherry-pick without committing (stage only)\ngit cherry-pick -n abc123\n```\n\n### Cherry-Pick with Conflicts\n\n```bash\n# When conflicts occur\ngit cherry-pick abc123\n# CONFLICT: resolve conflicts\n\n# After resolving conflicts\ngit add resolved-file.go\ngit cherry-pick --continue\n\n# Or abort cherry-pick\ngit cherry-pick --abort\n\n# Skip current commit\ngit cherry-pick --skip\n```\n\n### Cherry-Pick Options\n\n```bash\n# Edit commit message during cherry-pick\ngit cherry-pick -e abc123\n\n# Sign-off cherry-picked commit\ngit cherry-pick -s abc123\n\n# Keep original author date\ngit cherry-pick --ff abc123\n\n# Apply changes without commit attribution\ngit cherry-pick -n abc123\ngit commit --author=\"New Author <new@example.com>\"\n```\n\n### Mainline Selection for Merge Commits\n\n```bash\n# Cherry-pick merge commit (specify parent)\ngit cherry-pick -m 1 abc123\n\n# -m 1 = use first parent (main branch)\n# -m 2 = use second parent (merged branch)\n\n# Example workflow:\ngit log --graph --oneline\n#   *   abc123 Merge pull request #123\n#   |\\\n#   | * def456 feat: feature commit\n#   * | ghi789 fix: main branch commit\n\n# To cherry-pick the merge keeping main branch changes:\ngit cherry-pick -m 1 abc123\n```\n\n## Advanced Merging\n\n### Merge Strategies\n\n```bash\n# Recursive merge (default)\ngit merge -s recursive branch-name\n\n# Ours (keep our changes on conflict)\ngit merge -s ours branch-name\n\n# Theirs (keep their changes on conflict)\ngit merge -s theirs branch-name\n\n# Octopus (merge 3+ branches)\ngit merge -s octopus branch1 branch2 branch3\n\n# Subtree merge\ngit merge -s subtree branch-name\n```\n\n### Merge Strategy Options\n\n```bash\n# Ours (resolve conflicts with our version)\ngit merge -X ours branch-name\n\n# Theirs (resolve conflicts with their version)\ngit merge -X theirs branch-name\n\n# Ignore whitespace\ngit merge -X ignore-space-change branch-name\ngit merge -X ignore-all-space branch-name\n\n# Patience algorithm (better conflict detection)\ngit merge -X patience branch-name\n\n# Renormalize line endings\ngit merge -X renormalize branch-name\n```\n\n### Three-Way Merge\n\n```bash\n# Standard three-way merge\ngit merge feature-branch\n\n# With custom merge message\ngit merge feature-branch -m \"Merge feature: add authentication\"\n\n# No fast-forward (always create merge commit)\ngit merge --no-ff feature-branch\n\n# Fast-forward only (fail if merge commit needed)\ngit merge --ff-only feature-branch\n\n# Squash merge (combine all commits)\ngit merge --squash feature-branch\ngit commit -m \"feat: add complete authentication system\"\n```\n\n## Advanced Conflict Resolution\n\n### Understanding Conflict Markers\n\n```\n<<<<<<< HEAD (Current Change)\nint result = add(a, b);\n=======\nint sum = calculate(a, b);\n>>>>>>> feature-branch (Incoming Change)\n```\n\n### Conflict Resolution Tools\n\n```bash\n# Use mergetool\ngit mergetool\n\n# Specify merge tool\ngit mergetool --tool=vimdiff\ngit mergetool --tool=meld\ngit mergetool --tool=kdiff3\n\n# Configure default merge tool\ngit config --global merge.tool vimdiff\ngit config --global mergetool.vimdiff.cmd 'vimdiff \"$LOCAL\" \"$MERGED\" \"$REMOTE\"'\n\n# Check out specific version\ngit checkout --ours file.go    # Keep our version\ngit checkout --theirs file.go  # Keep their version\ngit checkout --merge file.go   # Recreate conflict markers\n```\n\n### Rerere (Reuse Recorded Resolution)\n\n```bash\n# Enable rerere\ngit config --global rerere.enabled true\n\n# Rerere will automatically resolve previously seen conflicts\ngit merge feature-branch\n# Conflict occurs and is resolved\ngit add file.go\ngit commit\n\n# Later, same conflict:\ngit merge another-branch\n# Rerere automatically applies previous resolution\n\n# View rerere cache\ngit rerere status\ngit rerere diff\n\n# Clear rerere cache\ngit rerere forget file.go\ngit rerere clear\n```\n\n## Interactive Staging\n\n### Partial File Staging\n\n```bash\n# Interactive staging\ngit add -p file.go\n\n# Patch commands:\n# y - stage this hunk\n# n - do not stage this hunk\n# q - quit (do not stage this and remaining hunks)\n# a - stage this and all remaining hunks\n# d - do not stage this and all remaining hunks\n# s - split the current hunk into smaller hunks\n# e - manually edit the current hunk\n```\n\n### Interactive Add\n\n```bash\n# Interactive mode\ngit add -i\n\n# Commands:\n# 1: status       - show paths with changes\n# 2: update       - stage paths\n# 3: revert       - unstage paths\n# 4: add untracked - stage untracked files\n# 5: patch        - partial staging\n# 6: diff         - show staged changes\n# 7: quit         - exit\n```\n\n### Partial Commits\n\n```bash\n# Stage part of file interactively\ngit add -p file.go\n\n# Create commit with partial changes\ngit commit -m \"feat: add validation logic\"\n\n# Stage remaining changes\ngit add file.go\ngit commit -m \"feat: add error handling\"\n```\n\n## Advanced Reset Operations\n\n### Reset Modes\n\n```bash\n# Soft reset (keep changes staged)\ngit reset --soft HEAD~1\n\n# Mixed reset (keep changes unstaged, default)\ngit reset --mixed HEAD~1\ngit reset HEAD~1\n\n# Hard reset (discard all changes)\ngit reset --hard HEAD~1\n\n# Reset to specific commit\ngit reset --hard abc123\n```\n\n### Reset vs Revert\n\n```bash\n# Reset (rewrites history, use for local changes)\ngit reset --hard HEAD~3\n\n# Revert (creates new commit, safe for shared history)\ngit revert HEAD\ngit revert HEAD~3\ngit revert abc123..def456\n```\n\n## Advanced Branch Operations\n\n### Branch from Specific Commit\n\n```bash\n# Create branch from commit\ngit branch new-branch abc123\ngit checkout new-branch\n\n# Or in one command\ngit checkout -b new-branch abc123\n\n# Create branch from remote commit\ngit checkout -b local-branch origin/remote-branch\n```\n\n### Orphan Branches\n\n```bash\n# Create orphan branch (no parent)\ngit checkout --orphan new-root\ngit rm -rf .\n\n# Useful for gh-pages, documentation, etc.\necho \"# Documentation\" > README.md\ngit add README.md\ngit commit -m \"docs: initialize documentation\"\n```\n\n### Branch Tracking\n\n```bash\n# Set upstream branch\ngit branch -u origin/main\n\n# Push and set upstream\ngit push -u origin feature-branch\n\n# Change upstream\ngit branch -u origin/develop\n\n# View tracking information\ngit branch -vv\n```\n\n## Advanced Stash Operations\n\n### Stash Specific Files\n\n```bash\n# Stash specific files\ngit stash push -m \"WIP: feature work\" file1.go file2.go\n\n# Stash with pathspec\ngit stash push -p\n\n# Stash untracked files\ngit stash -u\n\n# Stash including ignored files\ngit stash -a\n```\n\n### Stash to Branch\n\n```bash\n# Create branch from stash\ngit stash branch new-branch stash@{0}\n\n# Creates new branch and applies stash\ngit stash branch feature-work\n```\n\n### Partial Stash Application\n\n```bash\n# Apply specific files from stash\ngit checkout stash@{0} -- file.go\n\n# Apply stash without dropping\ngit stash apply stash@{0}\n\n# Apply and drop\ngit stash pop stash@{0}\n```\n\n## Submodule Management\n\n### Advanced Submodule Operations\n\n```bash\n# Update submodule to specific commit\ncd submodule-dir\ngit checkout abc123\ncd ..\ngit add submodule-dir\ngit commit -m \"chore: update submodule to version 1.2.3\"\n\n# Update all submodules to latest\ngit submodule update --remote --merge\n\n# Update specific submodule\ngit submodule update --remote --merge path/to/submodule\n\n# Run command in all submodules\ngit submodule foreach 'git checkout main'\ngit submodule foreach 'git pull'\n\n# Clone with submodules at specific depth\ngit clone --recurse-submodules --depth 1 repo-url\n```\n\n### Submodule to Subtree Migration\n\n```bash\n# Remove submodule\ngit submodule deinit path/to/submodule\ngit rm path/to/submodule\nrm -rf .git/modules/path/to/submodule\n\n# Add as subtree\ngit subtree add --prefix=path/to/submodule \\\n    https://github.com/user/repo.git main --squash\n\n# Update subtree\ngit subtree pull --prefix=path/to/submodule \\\n    https://github.com/user/repo.git main --squash\n```\n\n## Advanced Log and History\n\n### Custom Log Formatting\n\n```bash\n# One-line format with custom fields\ngit log --pretty=format:\"%h - %an, %ar : %s\"\n\n# Full custom format\ngit log --pretty=format:\"%C(yellow)%h%C(reset) %C(blue)%ad%C(reset) %C(green)%an%C(reset) %s\" --date=short\n\n# Aliases for common formats\ngit config --global alias.lg \"log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative\"\n```\n\n### Finding Lost Commits\n\n```bash\n# Find commits not in any branch\ngit log --all --oneline --no-walk --decorate $(git fsck --no-reflog | grep commit | cut -d' ' -f3)\n\n# Find dangling commits\ngit fsck --lost-found\n\n# Search commit messages\ngit log --all --grep=\"search term\"\n\n# Find commits by author\ngit log --author=\"John Doe\"\n\n# Find commits modifying specific code\ngit log -S \"function_name\"\ngit log -G \"regex_pattern\"\n```\n\n### Bisect Automation\n\n```bash\n# Start bisect\ngit bisect start\ngit bisect bad HEAD\ngit bisect good abc123\n\n# Automate bisect with script\ngit bisect run ./test.sh\n\n# test.sh example:\n#!/bin/bash\nmake && make test\nexit $?\n\n# Bisect will automatically find first bad commit\n```\n\n## Best Practices\n\n1. **Backup Before History Rewriting:** Create backup branch before complex operations\n2. **Never Rewrite Published History:** Only rewrite local commits\n3. **Communicate Rebases:** Inform team when force-pushing\n4. **Use Descriptive Commit Messages:** Even during interactive rebase\n5. **Test After Rebase:** Ensure code still works after history changes\n6. **Prefer Rebase for Local Branches:** Keep history linear\n7. **Use Merge for Shared Branches:** Preserve complete history\n8. **Sign Important Commits:** Use GPG signing for releases\n9. **Document Complex Operations:** Leave comments for future reference\n10. **Know When to Stop:** Sometimes merge commits are clearer than rebased history\n\n## Resources\n\nAdditional guides and examples are available in the `assets/` directory:\n- `examples/` - Complex rebase and merge scenarios\n- `scripts/` - Automation scripts for common operations\n- `workflows/` - Advanced workflow patterns\n\nSee `references/` directory for:\n- Git internals documentation\n- Advanced rebasing strategies\n- Filter-branch alternatives\n- Conflict resolution techniques"
              },
              {
                "name": "git-conventions",
                "description": "Git conventions and workflow best practices including Conventional Commits, branch naming, and commit message guidelines. Use when user needs guidance on git standards, commit formats, or workflow patterns.",
                "path": "plugins/utilities/git/skills/git-conventions/SKILL.md",
                "frontmatter": {
                  "name": "git-conventions",
                  "description": "Git conventions and workflow best practices including Conventional Commits, branch naming, and commit message guidelines. Use when user needs guidance on git standards, commit formats, or workflow patterns."
                },
                "content": "# Git Conventions Skill\n\nThis skill provides comprehensive guidance on git conventions, workflow best practices, and standardized commit formats to maintain clean, readable repository history.\n\n## When to Use\n\nActivate this skill when:\n- Writing commit messages following standards\n- Establishing team git workflows\n- Setting up branch naming conventions\n- Implementing Conventional Commits\n- Creating changelog automation\n- Code review for git hygiene\n- Onboarding team members on git practices\n\n## Conventional Commits\n\n### Format\n\n```\n<type>[optional scope]: <description>\n\n[optional body]\n\n[optional footer(s)]\n```\n\n### Commit Types\n\n**Primary Types:**\n- **feat**: New feature for the user\n- **fix**: Bug fix for the user\n- **docs**: Documentation only changes\n- **style**: Code style changes (formatting, missing semi-colons, etc)\n- **refactor**: Code change that neither fixes a bug nor adds a feature\n- **perf**: Performance improvements\n- **test**: Adding or correcting tests\n- **build**: Changes to build system or dependencies\n- **ci**: Changes to CI configuration files and scripts\n- **chore**: Other changes that don't modify src or test files\n- **revert**: Reverts a previous commit\n\n### Examples\n\n**Simple commit:**\n```bash\nfeat: add user authentication\n\nImplement JWT-based authentication system with refresh tokens.\nIncludes middleware for protected routes.\n\nCloses #123\n```\n\n**Breaking change:**\n```bash\nfeat!: redesign API response format\n\nBREAKING CHANGE: API now returns data in camelCase instead of snake_case.\nMigration guide available in docs/migration-v2.md.\n\nRefs: #456\n```\n\n**With scope:**\n```bash\nfix(auth): resolve token expiration edge case\n\nToken validation now properly handles timezone offsets.\nAdds retry logic for expired tokens within 5-minute grace period.\n```\n\n**Multiple paragraphs:**\n```bash\nrefactor(database): optimize query performance\n\n- Add indexes on frequently queried columns\n- Implement connection pooling\n- Cache common queries with Redis\n- Reduce N+1 queries in user associations\n\nPerformance improved by 60% in production testing.\n\nReviewed-by: Jane Doe <jane@example.com>\nRefs: #789\n```\n\n### Commit Message Rules\n\n1. **Subject line:**\n   - Use imperative mood (\"add\" not \"added\" or \"adds\")\n   - No capitalization of first letter\n   - No period at the end\n   - Maximum 50 characters (soft limit)\n   - Separate from body with blank line\n\n2. **Body:**\n   - Wrap at 72 characters\n   - Explain what and why, not how\n   - Use bullet points for multiple items\n   - Reference issues and PRs\n\n3. **Footer:**\n   - Breaking changes start with \"BREAKING CHANGE:\"\n   - Reference issues: \"Closes #123\", \"Fixes #456\", \"Refs #789\"\n   - Co-authors: \"Co-authored-by: Name <email>\"\n\n## Branch Naming Conventions\n\n### Format Pattern\n\n```\n<type>/<issue-number>-<short-description>\n```\n\n### Branch Types\n\n**Common prefixes:**\n- `feature/` or `feat/` - New features\n- `fix/` or `bugfix/` - Bug fixes\n- `hotfix/` - Urgent production fixes\n- `release/` - Release preparation\n- `docs/` - Documentation updates\n- `refactor/` - Code refactoring\n- `test/` - Test additions or fixes\n- `chore/` - Maintenance tasks\n- `experimental/` or `spike/` - Proof of concepts\n\n### Examples\n\n```bash\n# Feature branches\nfeature/123-user-authentication\nfeat/456-add-payment-gateway\nfeature/oauth-integration\n\n# Bug fix branches\nfix/789-resolve-memory-leak\nbugfix/login-redirect-loop\nfix/456-null-pointer-exception\n\n# Hotfix branches\nhotfix/critical-security-patch\nhotfix/production-database-issue\n\n# Release branches\nrelease/v1.2.0\nrelease/2024-Q1\n\n# Documentation branches\ndocs/api-reference-update\ndocs/123-add-contributing-guide\n\n# Refactor branches\nrefactor/database-layer\nrefactor/456-simplify-auth-flow\n\n# Experimental branches\nexperimental/graphql-api\nspike/performance-optimization\n```\n\n### Branch Naming Rules\n\n1. **Use hyphens** for word separation (not underscores)\n2. **Lowercase only** (avoid capitals)\n3. **Keep it short** but descriptive (max 50 characters)\n4. **Include issue number** when applicable\n5. **Avoid special characters** except hyphens and forward slashes\n6. **No trailing slashes**\n7. **Be consistent** within your team\n\n## Protected Branch Strategy\n\n### Main Branches\n\n**main/master:**\n- Production-ready code\n- Always deployable\n- Protected with required reviews\n- No direct commits\n- Merge only from release or hotfix branches\n\n**develop:**\n- Integration branch for features\n- Pre-production testing\n- Protected with CI checks\n- Merge target for feature branches\n\n**staging:**\n- Pre-production environment\n- QA testing branch\n- Mirror of production with new features\n\n### Protection Rules\n\n```yaml\n# Example GitHub branch protection\nmain:\n  require_pull_request_reviews:\n    required_approving_review_count: 2\n    dismiss_stale_reviews: true\n    require_code_owner_reviews: true\n\n  require_status_checks:\n    strict: true\n    contexts:\n      - continuous-integration\n      - code-quality\n      - security-scan\n\n  enforce_admins: true\n  require_linear_history: true\n  allow_force_pushes: false\n  allow_deletions: false\n```\n\n## Semantic Versioning\n\n### Version Format\n\n```\nMAJOR.MINOR.PATCH[-prerelease][+build]\n```\n\n**Examples:**\n- `1.0.0` - Initial release\n- `1.2.3` - Minor update with patches\n- `2.0.0-alpha.1` - Pre-release alpha\n- `1.5.0-rc.2+20240321` - Release candidate with build metadata\n\n### Version Increment Rules\n\n**MAJOR (X.0.0):**\n- Breaking changes\n- API incompatibilities\n- Major redesigns\n- Removal of deprecated features\n\n**MINOR (x.Y.0):**\n- New features (backward compatible)\n- Deprecated features (still functional)\n- Substantial internal changes\n\n**PATCH (x.y.Z):**\n- Bug fixes\n- Security patches\n- Performance improvements\n- Documentation updates\n\n### Git Tags for Versions\n\n```bash\n# Create annotated tag\ngit tag -a v1.2.3 -m \"Release version 1.2.3\n\n- Add user authentication\n- Fix memory leak in cache\n- Improve API performance\"\n\n# Push tags to remote\ngit push origin v1.2.3\n\n# Push all tags\ngit push --tags\n\n# Create pre-release tag\ngit tag -a v2.0.0-beta.1 -m \"Beta release for v2.0.0\"\n\n# Delete tag\ngit tag -d v1.2.3\ngit push origin :refs/tags/v1.2.3\n```\n\n## Workflow Patterns\n\n### Git Flow\n\n**Branch structure:**\n- `main` - Production releases\n- `develop` - Next release development\n- `feature/*` - New features\n- `release/*` - Release preparation\n- `hotfix/*` - Emergency fixes\n\n**Feature workflow:**\n```bash\n# Start feature\ngit checkout develop\ngit pull origin develop\ngit checkout -b feature/123-new-feature\n\n# Work on feature\ngit add .\ngit commit -m \"feat: implement user authentication\"\n\n# Finish feature\ngit checkout develop\ngit pull origin develop\ngit merge --no-ff feature/123-new-feature\ngit push origin develop\ngit branch -d feature/123-new-feature\n```\n\n**Release workflow:**\n```bash\n# Start release\ngit checkout develop\ngit checkout -b release/v1.2.0\n\n# Prepare release (bump version, update changelog)\ngit commit -m \"chore: prepare release v1.2.0\"\n\n# Merge to main\ngit checkout main\ngit merge --no-ff release/v1.2.0\ngit tag -a v1.2.0 -m \"Release v1.2.0\"\n\n# Merge back to develop\ngit checkout develop\ngit merge --no-ff release/v1.2.0\n\n# Cleanup\ngit branch -d release/v1.2.0\n```\n\n**Hotfix workflow:**\n```bash\n# Start hotfix from main\ngit checkout main\ngit checkout -b hotfix/critical-bug\n\n# Fix and commit\ngit commit -m \"fix: resolve critical security vulnerability\"\n\n# Merge to main\ngit checkout main\ngit merge --no-ff hotfix/critical-bug\ngit tag -a v1.2.1 -m \"Hotfix v1.2.1\"\n\n# Merge to develop\ngit checkout develop\ngit merge --no-ff hotfix/critical-bug\n\n# Cleanup\ngit branch -d hotfix/critical-bug\n```\n\n### GitHub Flow\n\n**Simplified workflow:**\n- `main` - Always deployable\n- `feature/*` - All changes in feature branches\n\n**Workflow:**\n```bash\n# Create feature branch\ngit checkout -b feature/add-logging\ngit push -u origin feature/add-logging\n\n# Make changes and commit\ngit commit -m \"feat: add structured logging\"\ngit push origin feature/add-logging\n\n# Open pull request on GitHub\n# After review and CI passes, merge to main\n# Deploy from main\n```\n\n### Trunk-Based Development\n\n**Single main branch:**\n- Short-lived feature branches (< 2 days)\n- Frequent integration to main\n- Feature flags for incomplete features\n- Continuous integration\n\n**Workflow:**\n```bash\n# Create short-lived branch\ngit checkout -b update-api-docs\ngit push -u origin update-api-docs\n\n# Make small, incremental changes\ngit commit -m \"docs: update API endpoint documentation\"\ngit push origin update-api-docs\n\n# Immediately create PR and merge (same day)\n# Main branch always deployable with feature flags\n```\n\n## Pull Request Conventions\n\n### PR Title Format\n\nUse Conventional Commits format:\n```\nfeat(auth): add OAuth2 provider support\nfix(api): resolve rate limiting edge case\ndocs: update installation guide\n```\n\n### PR Description Template\n\n```markdown\n## Summary\nBrief description of changes and motivation.\n\n## Changes\n- Bullet list of specific changes\n- Reference architecture decisions\n- Note any breaking changes\n\n## Testing\n- Unit tests added/updated\n- Integration tests passed\n- Manual testing performed\n\n## Screenshots (if applicable)\n[Add screenshots for UI changes]\n\n## Related Issues\nCloses #123\nRefs #456\n\n## Checklist\n- [ ] Tests added/updated\n- [ ] Documentation updated\n- [ ] Changelog updated\n- [ ] Breaking changes documented\n- [ ] Code reviewed by team\n```\n\n### Review Guidelines\n\n**Reviewer checklist:**\n- [ ] Code follows style guide\n- [ ] Commit messages follow conventions\n- [ ] Tests are comprehensive\n- [ ] Documentation is updated\n- [ ] No security vulnerabilities\n- [ ] Performance considerations addressed\n- [ ] Breaking changes are justified\n\n## Changelog Management\n\n### Keep a Changelog Format\n\n```markdown\n# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [Unreleased]\n\n### Added\n- User authentication with JWT tokens\n- API rate limiting middleware\n\n### Changed\n- Updated database schema for better performance\n\n### Deprecated\n- Old authentication endpoint (use /api/v2/auth instead)\n\n### Removed\n- Legacy XML API support\n\n### Fixed\n- Memory leak in cache implementation\n- Race condition in concurrent requests\n\n### Security\n- Patch for SQL injection vulnerability\n\n## [1.2.0] - 2024-03-15\n\n### Added\n- Real-time notifications system\n- User profile customization\n\n### Fixed\n- Login redirect loop issue\n- Session timeout handling\n\n## [1.1.0] - 2024-02-01\n\n### Added\n- Search functionality\n- Export to CSV feature\n\n### Changed\n- Improved UI responsiveness\n```\n\n### Automated Changelog\n\nUse tools like:\n- `conventional-changelog` - Generate changelog from commits\n- `release-please` - Automated releases and changelog\n- `semantic-release` - Fully automated version management\n\n## Best Practices\n\n1. **Commit Often:** Small, focused commits are easier to review and revert\n2. **Write Clear Messages:** Future you will thank present you\n3. **One Concern Per Commit:** Each commit should address one logical change\n4. **Test Before Committing:** Ensure code works before committing\n5. **Reference Issues:** Link commits to issue tracker\n6. **Review Your Own Changes:** Use `git diff --staged` before committing\n7. **Keep History Clean:** Rebase feature branches to keep linear history\n8. **Sign Your Commits:** Use GPG signing for verified commits\n9. **Use .gitignore Properly:** Never commit sensitive or generated files\n10. **Document Conventions:** Keep team conventions in repository docs\n\n## Team Workflow Examples\n\n### Small Team (2-5 developers)\n\n```bash\n# Simplified workflow\n- Direct commits to main (with PR reviews)\n- Feature branches for major changes\n- Tags for releases\n- Linear history preferred\n```\n\n### Medium Team (5-20 developers)\n\n```bash\n# Git Flow variant\n- Protected main and develop branches\n- Feature branches required\n- Release branches for versions\n- Hotfix workflow for emergencies\n- Squash merge for clean history\n```\n\n### Large Team (20+ developers)\n\n```bash\n# Trunk-based with feature flags\n- Protected main branch\n- Very short-lived feature branches\n- Feature flags for incomplete work\n- Automated testing and deployment\n- Multiple daily integrations\n```\n\n## Resources\n\nAdditional guides and templates are available in the `assets/` directory:\n- `templates/` - Commit message and PR templates\n- `examples/` - Real-world workflow examples\n- `tools/` - Git hooks and automation scripts\n\nSee `references/` directory for:\n- Conventional Commits specification\n- Semantic Versioning documentation\n- Git Flow and GitHub Flow guides\n- Keep a Changelog standards"
              },
              {
                "name": "git-repository",
                "description": "Repository management strategies including branch strategies (Git Flow, GitHub Flow, trunk-based), monorepo patterns, submodules, and repository organization. Use when user needs guidance on repository structure or branching strategies.",
                "path": "plugins/utilities/git/skills/git-repository/SKILL.md",
                "frontmatter": {
                  "name": "git-repository",
                  "description": "Repository management strategies including branch strategies (Git Flow, GitHub Flow, trunk-based), monorepo patterns, submodules, and repository organization. Use when user needs guidance on repository structure or branching strategies."
                },
                "content": "# Git Repository Management Skill\n\nThis skill provides comprehensive guidance on repository management strategies, branching models, repository organization patterns, and scaling git for large teams and codebases.\n\n## When to Use\n\nActivate this skill when:\n- Setting up new repository structure\n- Choosing branching strategy\n- Managing monorepo vs polyrepo\n- Organizing multi-project repositories\n- Implementing submodule or subtree strategies\n- Scaling git for large teams\n- Migrating repository structures\n- Establishing team workflows\n\n## Branching Strategies\n\n### Git Flow\n\n**Branch Structure:**\n- `main` (or `master`) - Production releases only\n- `develop` - Integration branch for next release\n- `feature/*` - Feature development branches\n- `release/*` - Release preparation branches\n- `hotfix/*` - Emergency production fixes\n\n**Workflow:**\n\n```bash\n# Feature Development\ngit checkout develop\ngit checkout -b feature/user-authentication\n# Work on feature...\ngit commit -m \"feat: add JWT authentication\"\ngit checkout develop\ngit merge --no-ff feature/user-authentication\ngit branch -d feature/user-authentication\n\n# Release Preparation\ngit checkout develop\ngit checkout -b release/v1.2.0\n# Bump version, update changelog, final testing...\ngit commit -m \"chore: prepare release v1.2.0\"\n\n# Deploy Release\ngit checkout main\ngit merge --no-ff release/v1.2.0\ngit tag -a v1.2.0 -m \"Release version 1.2.0\"\ngit checkout develop\ngit merge --no-ff release/v1.2.0\ngit branch -d release/v1.2.0\ngit push origin main develop --tags\n\n# Hotfix\ngit checkout main\ngit checkout -b hotfix/security-patch\ngit commit -m \"fix: patch security vulnerability\"\ngit checkout main\ngit merge --no-ff hotfix/security-patch\ngit tag -a v1.2.1 -m \"Hotfix v1.2.1\"\ngit checkout develop\ngit merge --no-ff hotfix/security-patch\ngit branch -d hotfix/security-patch\ngit push origin main develop --tags\n```\n\n**Best For:**\n- Scheduled releases\n- Multiple production versions\n- Large teams with QA process\n- Products with maintenance windows\n- Enterprise software\n\n**Drawbacks:**\n- Complex workflow\n- Long-lived branches\n- Potential merge conflicts\n- Delayed integration\n\n### GitHub Flow\n\n**Branch Structure:**\n- `main` - Production-ready code (always deployable)\n- `feature/*` - All feature and fix branches\n\n**Workflow:**\n\n```bash\n# Create Feature Branch\ngit checkout main\ngit pull origin main\ngit checkout -b feature/add-api-logging\n\n# Develop Feature\ngit commit -m \"feat: add structured logging middleware\"\ngit push -u origin feature/add-api-logging\n\n# Open Pull Request on GitHub\n# Review, discuss, CI passes\n\n# Merge and Deploy\n# Merge PR on GitHub\n# Automatic deployment from main\n\n# Cleanup\ngit checkout main\ngit pull origin main\ngit branch -d feature/add-api-logging\n```\n\n**Best For:**\n- Continuous deployment\n- Small to medium teams\n- Web applications\n- Rapid iteration\n- Cloud-native applications\n\n**Drawbacks:**\n- Requires robust CI/CD\n- No release staging\n- Less structured than Git Flow\n\n### Trunk-Based Development\n\n**Branch Structure:**\n- `main` (or `trunk`) - Single source of truth\n- Short-lived feature branches (< 2 days, optional)\n- Feature flags for incomplete work\n\n**Workflow:**\n\n```bash\n# Direct Commit to Main (Small Changes)\ngit checkout main\ngit pull origin main\n# Make small change...\ngit commit -m \"fix: correct validation logic\"\ngit push origin main\n\n# Short-Lived Branch (Larger Changes)\ngit checkout -b optimize-query\n# Work for < 1 day\ngit commit -m \"perf: optimize database query\"\ngit push -u origin optimize-query\n# Immediate PR, quick review, merge same day\n\n# Feature Flags for Incomplete Features\ngit checkout main\ngit commit -m \"feat: add payment gateway (behind feature flag)\"\n# Feature disabled in production until complete\ngit push origin main\n```\n\n**Best For:**\n- High-velocity teams\n- Continuous integration\n- Automated testing\n- Feature flag infrastructure\n- DevOps culture\n\n**Drawbacks:**\n- Requires discipline\n- Needs comprehensive tests\n- Feature flag management\n- Higher deployment frequency\n\n### Release Branch Strategy\n\n**Branch Structure:**\n- `main` - Current development\n- `release/v*` - Long-lived release branches\n- `feature/*` - Feature branches\n\n**Workflow:**\n\n```bash\n# Create Release Branch\ngit checkout -b release/v1.0 main\ngit push -u origin release/v1.0\n\n# Continue Development on Main\ngit checkout main\n# Work on v2.0 features...\n\n# Backport Fixes to Release\ngit checkout release/v1.0\ngit cherry-pick abc123  # Fix from main\ngit push origin release/v1.0\ngit tag -a v1.0.5 -m \"Patch release v1.0.5\"\ngit push origin v1.0.5\n\n# Multiple Release Maintenance\ngit checkout release/v0.9\ngit cherry-pick def456\ngit tag -a v0.9.8 -m \"Security patch v0.9.8\"\n```\n\n**Best For:**\n- Multiple product versions\n- Long-term support releases\n- Enterprise customers\n- Regulated industries\n\n**Drawbacks:**\n- Maintenance overhead\n- Complex cherry-picking\n- Diverging codebases\n\n### Feature Branch Workflow\n\n**Branch Structure:**\n- `main` - Stable production code\n- `feature/*` - Feature branches from main\n- `bugfix/*` - Bug fix branches\n\n**Workflow:**\n\n```bash\n# Feature Development\ngit checkout main\ngit checkout -b feature/payment-integration\n\n# Long-Running Feature (Sync with Main)\ngit fetch origin\ngit rebase origin/main\n# Or merge\ngit merge origin/main\n\n# Complete Feature\ngit push origin feature/payment-integration\n# Create pull request\n# After review and approval, merge to main\n```\n\n**Best For:**\n- Medium-sized teams\n- Code review processes\n- Parallel feature development\n- Quality gates before merge\n\n## Repository Organization\n\n### Monorepo\n\n**Structure:**\n```\nmonorepo/\n├── .git/\n├── services/\n│   ├── api/\n│   ├── web/\n│   └── worker/\n├── packages/\n│   ├── shared-utils/\n│   ├── ui-components/\n│   └── api-client/\n├── tools/\n│   ├── build-tools/\n│   └── scripts/\n└── docs/\n```\n\n**Advantages:**\n- Single source of truth\n- Shared code visibility\n- Atomic cross-project changes\n- Unified versioning\n- Simplified dependency management\n- Consistent tooling\n\n**Disadvantages:**\n- Large repository size\n- Slower clone/fetch\n- Complex CI/CD\n- Access control challenges\n- Tooling requirements\n\n**Implementation:**\n\n```bash\n# Initialize Monorepo\ngit init\nmkdir -p services/api services/web packages/shared-utils\n\n# Workspace Setup (Node.js example)\ncat > package.json << EOF\n{\n  \"name\": \"monorepo\",\n  \"private\": true,\n  \"workspaces\": [\n    \"services/*\",\n    \"packages/*\"\n  ]\n}\nEOF\n\n# Sparse Checkout (Partial Clone)\ngit clone --filter=blob:none --no-checkout <url>\ncd repo\ngit sparse-checkout init --cone\ngit sparse-checkout set services/api packages/shared-utils\ngit checkout main\n\n# Build Only Changed Packages\ngit diff --name-only HEAD~1 | grep \"^services/api\" && cd services/api && npm run build\n```\n\n**Tools:**\n- **Bazel** - Build system for large monorepos\n- **Nx** - Monorepo build system (Node.js)\n- **Lerna** - JavaScript monorepo management\n- **Turborepo** - High-performance build system\n- **Git-subtree** - Merge external repositories\n\n### Polyrepo\n\n**Structure:**\n```\norganization/\n├── api-service/       (separate repo)\n├── web-app/           (separate repo)\n├── mobile-app/        (separate repo)\n├── shared-utils/      (separate repo)\n└── documentation/     (separate repo)\n```\n\n**Advantages:**\n- Clear ownership boundaries\n- Independent versioning\n- Smaller repository size\n- Granular access control\n- Flexible CI/CD\n- Team autonomy\n\n**Disadvantages:**\n- Dependency version conflicts\n- Cross-repo changes are complex\n- Duplicated tooling/config\n- Harder to refactor across repos\n\n**Implementation:**\n\n```bash\n# Template Repository\ngit clone git@github.com:org/template-service.git new-service\ncd new-service\nrm -rf .git\ngit init\ngit remote add origin git@github.com:org/new-service.git\n\n# Shared Configuration\n# Use git submodules or packages\ngit submodule add git@github.com:org/shared-config.git config\n```\n\n### Monorepo vs Polyrepo Decision Matrix\n\n| Factor | Monorepo | Polyrepo |\n|--------|----------|----------|\n| Team Size | Large teams | Small, autonomous teams |\n| Code Sharing | High code reuse | Limited sharing |\n| Deployment | Coordinated releases | Independent deployments |\n| Access Control | Coarse-grained | Fine-grained |\n| Repository Size | Very large | Small to medium |\n| CI/CD Complexity | High | Low to medium |\n| Tooling Requirements | Specialized tools | Standard git tools |\n| Refactoring | Easy cross-project | Complex cross-repo |\n\n## Submodule Management\n\n### Basic Submodules\n\n```bash\n# Add Submodule\ngit submodule add https://github.com/org/shared-lib.git libs/shared\n\n# Clone with Submodules\ngit clone --recurse-submodules <url>\n\n# Initialize After Clone\ngit submodule init\ngit submodule update\n\n# Update Submodule\ncd libs/shared\ngit pull origin main\ncd ../..\ngit add libs/shared\ngit commit -m \"chore: update shared library\"\n\n# Update All Submodules\ngit submodule update --remote --merge\n\n# Remove Submodule\ngit submodule deinit libs/shared\ngit rm libs/shared\nrm -rf .git/modules/libs/shared\n```\n\n### Submodule Strategies\n\n**Pinned Version Strategy:**\n```bash\n# Submodule points to specific commit\n# Manual updates with testing\ngit submodule update --remote libs/shared\n# Test changes...\ngit add libs/shared\ngit commit -m \"chore: update shared-lib to v1.2.3\"\n```\n\n**Auto-Update Strategy:**\n```bash\n# CI automatically updates submodules\n# .github/workflows/update-submodules.yml\nname: Update Submodules\non:\n  schedule:\n    - cron: '0 0 * * 0'  # Weekly\njobs:\n  update:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          submodules: true\n      - run: git submodule update --remote\n      - run: git commit -am \"chore: update submodules\"\n      - run: git push\n```\n\n### Nested Submodules\n\n```bash\n# Add Nested Submodule\ncd libs/framework\ngit submodule add https://github.com/org/utils.git utils\n\n# Update Recursively\ngit submodule update --init --recursive\n\n# Run Command in All Submodules\ngit submodule foreach 'git checkout main'\ngit submodule foreach 'git pull'\ngit submodule foreach --recursive 'echo $name: $(git rev-parse HEAD)'\n```\n\n## Subtree Management\n\n### Git Subtree vs Submodule\n\n**Subtree Advantages:**\n- Simpler for contributors\n- No separate clone steps\n- Part of main repository history\n- No broken references\n\n**Subtree Disadvantages:**\n- More complex to update\n- Pollutes main history\n- Larger repository\n\n### Subtree Operations\n\n```bash\n# Add Subtree\ngit subtree add --prefix=libs/shared https://github.com/org/shared.git main --squash\n\n# Update Subtree\ngit subtree pull --prefix=libs/shared https://github.com/org/shared.git main --squash\n\n# Push Changes Back to Subtree\ngit subtree push --prefix=libs/shared https://github.com/org/shared.git feature-branch\n\n# Split Subtree (Extract to New Repo)\ngit subtree split --prefix=libs/shared -b shared-lib-branch\ngit push git@github.com:org/new-shared-lib.git shared-lib-branch:main\n```\n\n### Subtree Workflow\n\n```bash\n# Setup Remote for Easier Management\ngit remote add shared-lib https://github.com/org/shared.git\n\n# Add Subtree with Remote\ngit subtree add --prefix=libs/shared shared-lib main --squash\n\n# Pull Updates\ngit fetch shared-lib\ngit subtree pull --prefix=libs/shared shared-lib main --squash\n\n# Contribute Back\ngit subtree push --prefix=libs/shared shared-lib feature-branch\n```\n\n## Repository Templates\n\n### GitHub Template Repository\n\n```bash\n# Create Template Structure\nmkdir -p .github/workflows\ncat > .github/workflows/ci.yml << EOF\nname: CI\non: [push, pull_request]\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: make test\nEOF\n\n# Template Files\ntouch .gitignore README.md LICENSE CONTRIBUTING.md\nmkdir -p docs src tests\n\n# Mark as Template on GitHub Settings\n# Use template to create new repositories\n```\n\n### Cookiecutter Template\n\n```bash\n# Install Cookiecutter\npip install cookiecutter\n\n# Create from Template\ncookiecutter https://github.com/org/project-template.git\n\n# Template Structure\nproject-template/\n├── cookiecutter.json\n└── {{cookiecutter.project_name}}/\n    ├── .git/\n    ├── src/\n    ├── tests/\n    └── README.md\n```\n\n## Large Repository Management\n\n### Partial Clone\n\n```bash\n# Blobless Clone (No file contents initially)\ngit clone --filter=blob:none <url>\n\n# Treeless Clone (Even more minimal)\ngit clone --filter=tree:0 <url>\n\n# Shallow Clone (Limited History)\ngit clone --depth 1 <url>\n\n# Shallow Clone with Single Branch\ngit clone --depth 1 --single-branch --branch main <url>\n```\n\n### Sparse Checkout\n\n```bash\n# Enable Sparse Checkout\ngit sparse-checkout init --cone\n\n# Specify Directories\ngit sparse-checkout set src/api src/shared\n\n# Add More Directories\ngit sparse-checkout add docs\n\n# List Current Sparse Checkout\ngit sparse-checkout list\n\n# Disable Sparse Checkout\ngit sparse-checkout disable\n```\n\n### Git LFS (Large File Storage)\n\n```bash\n# Install Git LFS\ngit lfs install\n\n# Track Large Files\ngit lfs track \"*.psd\"\ngit lfs track \"*.zip\"\ngit lfs track \"data/**\"\n\n# Track Files in .gitattributes\ncat .gitattributes\n# *.psd filter=lfs diff=lfs merge=lfs -text\n\n# Clone with LFS\ngit clone <url>\ncd repo\ngit lfs pull\n\n# Migrate Existing Files to LFS\ngit lfs migrate import --include=\"*.zip\"\n```\n\n## Repository Splitting\n\n### Extract Subdirectory to New Repo\n\n```bash\n# Using git filter-repo (recommended)\ngit filter-repo --path services/api --path-rename services/api:\n\n# Result: New repo with only services/api content and history\n\n# Using git subtree\ngit subtree split --prefix=services/api -b api-service\nmkdir ../api-service\ncd ../api-service\ngit init\ngit pull ../original-repo api-service\n```\n\n### Merge Multiple Repos\n\n```bash\n# Add Remote\ngit remote add project-b ../project-b\n\n# Fetch History\ngit fetch project-b\n\n# Merge with Unrelated Histories\ngit merge --allow-unrelated-histories project-b/main\n\n# Move Files to Subdirectory\nmkdir project-b\ngit mv * project-b/\ngit commit -m \"chore: organize project-b into subdirectory\"\n```\n\n## Repository Maintenance\n\n### Regular Maintenance Tasks\n\n```bash\n# Optimize Repository\ngit gc --aggressive\n\n# Prune Unreachable Objects\ngit prune --expire now\n\n# Verify Integrity\ngit fsck --full\n\n# Repack Repository\ngit repack -a -d --depth=250 --window=250\n\n# Update Server Info (for dumb HTTP)\ngit update-server-info\n```\n\n### Automation Script\n\n```bash\n#!/bin/bash\n# repo-maintenance.sh\n\necho \"Starting repository maintenance...\"\n\n# Fetch all branches\ngit fetch --all --prune\n\n# Clean up stale branches\ngit branch -vv | grep ': gone]' | awk '{print $1}' | xargs -r git branch -D\n\n# Garbage collection\ngit gc --auto\n\n# Verify integrity\ngit fsck --full --strict\n\necho \"Maintenance complete!\"\n```\n\n### Scheduled Maintenance\n\n```yaml\n# .github/workflows/maintenance.yml\nname: Repository Maintenance\non:\n  schedule:\n    - cron: '0 2 * * 0'  # Weekly at 2 AM Sunday\njobs:\n  maintain:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - name: Run Maintenance\n        run: |\n          git gc --aggressive\n          git prune --expire now\n          git fsck --full\n```\n\n## Access Control and Permissions\n\n### Branch Protection Rules\n\n```yaml\n# Example Configuration\nprotected_branches:\n  main:\n    required_pull_request_reviews:\n      required_approving_review_count: 2\n      dismiss_stale_reviews: true\n      require_code_owner_reviews: true\n    required_status_checks:\n      strict: true\n      contexts:\n        - continuous-integration\n        - security-scan\n    enforce_admins: true\n    restrictions:\n      users: []\n      teams: [core-team]\n```\n\n### CODEOWNERS File\n\n```bash\n# .github/CODEOWNERS\n\n# Global owners\n*                    @org/core-team\n\n# Service owners\n/services/api/       @org/backend-team\n/services/web/       @org/frontend-team\n/services/mobile/    @org/mobile-team\n\n# Specific files\n/docs/               @org/documentation-team\n/.github/            @org/devops-team\n/security/           @org/security-team @org/lead-architect\n\n# Require multiple reviews\n/packages/shared/    @org/core-team @org/architecture-team\n```\n\n## Migration Strategies\n\n### SVN to Git\n\n```bash\n# Create Authors File\nsvn log --quiet | grep \"^r\" | awk '{print $3}' | sort -u > authors.txt\n\n# Edit authors.txt:\n# john = John Doe <john@example.com>\n\n# Convert Repository\ngit svn clone <svn-url> --authors-file=authors.txt --stdlayout repo\n\n# Convert Tags and Branches\ncd repo\ngit for-each-ref --format=\"%(refname:short)\" refs/remotes/tags | \\\n  cut -d / -f 3 | xargs -I {} git tag {} refs/remotes/tags/{}\n\n# Push to Git\ngit remote add origin <git-url>\ngit push -u origin --all\ngit push origin --tags\n```\n\n### Mercurial to Git\n\n```bash\n# Using hg-git\nhg bookmark -r default main\nhg push git+ssh://git@github.com/org/repo.git\n\n# Using fast-export\ngit clone https://github.com/frej/fast-export.git\nmkdir git-repo && cd git-repo\ngit init\n../fast-export/hg-fast-export.sh -r ../hg-repo\ngit checkout HEAD\n```\n\n## Best Practices\n\n1. **Choose Appropriate Strategy:** Match branching model to team size and deployment frequency\n2. **Document Workflows:** Keep team documentation current\n3. **Automate Maintenance:** Regular repository health checks\n4. **Use Branch Protection:** Enforce code review and CI\n5. **Clear Ownership:** Define code owners for all areas\n6. **Regular Cleanup:** Remove stale branches and merged features\n7. **Monitor Repository Size:** Use LFS for large files\n8. **Template Repositories:** Standardize new project structure\n9. **Access Control:** Implement principle of least privilege\n10. **Migration Planning:** Test migrations thoroughly before production\n\n## Resources\n\nAdditional repository management resources are available in the `assets/` directory:\n- `templates/` - Repository structure templates\n- `scripts/` - Automation and maintenance scripts\n- `workflows/` - CI/CD workflow examples\n\nSee `references/` directory for:\n- Branching strategy comparison guides\n- Monorepo tool documentation\n- Enterprise git patterns\n- Repository scaling strategies"
              },
              {
                "name": "git-troubleshooting",
                "description": "Git troubleshooting techniques including recovering lost commits, fixing merge conflicts, resolving detached HEAD, and diagnosing repository issues. Use when user encounters git errors or needs to recover from mistakes.",
                "path": "plugins/utilities/git/skills/git-troubleshooting/SKILL.md",
                "frontmatter": {
                  "name": "git-troubleshooting",
                  "description": "Git troubleshooting techniques including recovering lost commits, fixing merge conflicts, resolving detached HEAD, and diagnosing repository issues. Use when user encounters git errors or needs to recover from mistakes."
                },
                "content": "# Git Troubleshooting Skill\n\nThis skill provides comprehensive guidance on diagnosing and resolving git issues, recovering from mistakes, fixing corrupted repositories, and handling common error scenarios.\n\n## When to Use\n\nActivate this skill when:\n- Encountering git error messages\n- Recovering lost commits or branches\n- Fixing corrupted repositories\n- Resolving detached HEAD state\n- Handling botched merges or rebases\n- Diagnosing repository issues\n- Recovering from force push\n- Fixing authentication problems\n\n## Recovering Lost Commits\n\n### Using Reflog\n\n```bash\n# View reflog (local history of HEAD)\ngit reflog\n\n# View reflog for specific branch\ngit reflog show branch-name\n\n# Output example:\n# abc123 HEAD@{0}: commit: feat: add authentication\n# def456 HEAD@{1}: commit: fix: resolve bug\n# ghi789 HEAD@{2}: reset: moving to HEAD~1\n\n# Recover lost commit\ngit cherry-pick abc123\n\n# Or create branch from lost commit\ngit branch recovered-branch abc123\n\n# Or reset to lost commit\ngit reset --hard abc123\n```\n\n### Finding Dangling Commits\n\n```bash\n# Find all unreachable objects\ngit fsck --lost-found\n\n# Output:\n# dangling commit abc123\n# dangling blob def456\n\n# View dangling commit\ngit show abc123\n\n# Recover dangling commit\ngit branch recovered abc123\n\n# Or merge it\ngit merge abc123\n```\n\n### Recovering Deleted Branch\n\n```bash\n# Find branch commit in reflog\ngit reflog\n\n# Look for branch deletion:\n# abc123 HEAD@{5}: checkout: moving from feature-branch to main\n\n# Recreate branch\ngit branch feature-branch abc123\n\n# Or if branch was merged before deletion\ngit log --all --oneline | grep \"feature\"\ngit branch feature-branch def456\n```\n\n### Recovering After Reset\n\n```bash\n# After accidental reset --hard\ngit reflog\n\n# Find commit before reset:\n# abc123 HEAD@{0}: reset: moving to HEAD~5\n# def456 HEAD@{1}: commit: last good commit\n\n# Restore to previous state\ngit reset --hard def456\n\n# Or create recovery branch\ngit branch recovery def456\n```\n\n## Resolving Detached HEAD\n\n### Understanding Detached HEAD\n\n```bash\n# Detached HEAD state occurs when:\ngit checkout abc123\ngit checkout v1.0.0\ngit checkout origin/main\n\n# HEAD is not attached to any branch\n```\n\n### Recovering from Detached HEAD\n\n```bash\n# Check current state\ngit status\n# HEAD detached at abc123\n\n# Option 1: Create new branch\ngit checkout -b new-branch-name\n\n# Option 2: Return to previous branch\ngit checkout main\n\n# Option 3: Reattach HEAD to branch\ngit checkout -b temp-branch\ngit checkout main\ngit merge temp-branch\n\n# If you made commits in detached HEAD:\ngit reflog\n# Find the commits\ngit branch recovery-branch abc123\n```\n\n### Preventing Detached HEAD\n\n```bash\n# Instead of checking out tag directly\ngit checkout -b release-v1.0 v1.0.0\n\n# Instead of checking out remote branch\ngit checkout -b local-feature origin/feature-branch\n\n# Check if HEAD is detached\ngit symbolic-ref -q HEAD && echo \"attached\" || echo \"detached\"\n```\n\n## Fixing Merge Conflicts\n\n### Understanding Conflict Markers\n\n```\n<<<<<<< HEAD (Current Change)\nint result = add(a, b);\n||||||| merged common ancestors (Base)\nint result = sum(a, b);\n=======\nint sum = calculate(a, b);\n>>>>>>> feature-branch (Incoming Change)\n```\n\n### Basic Conflict Resolution\n\n```bash\n# When merge conflict occurs\ngit status\n# both modified: file.go\n\n# View conflict\ncat file.go\n\n# Option 1: Keep ours (current branch)\ngit checkout --ours file.go\ngit add file.go\n\n# Option 2: Keep theirs (incoming branch)\ngit checkout --theirs file.go\ngit add file.go\n\n# Option 3: Manual resolution\n# Edit file.go to resolve conflicts\ngit add file.go\n\n# Complete merge\ngit commit\n```\n\n### Aborting Operations\n\n```bash\n# Abort merge\ngit merge --abort\n\n# Abort rebase\ngit rebase --abort\n\n# Abort cherry-pick\ngit cherry-pick --abort\n\n# Abort revert\ngit revert --abort\n\n# Abort am (apply mailbox)\ngit am --abort\n```\n\n### Complex Conflict Resolution\n\n```bash\n# Use merge tool\ngit mergetool\n\n# View three-way diff\ngit diff --ours\ngit diff --theirs\ngit diff --base\n\n# Show conflicts with context\ngit diff --check\n\n# List conflicted files\ngit diff --name-only --diff-filter=U\n\n# After resolving all conflicts\ngit add .\ngit commit\n```\n\n## Fixing Botched Rebase\n\n### Recovering from Failed Rebase\n\n```bash\n# Abort current rebase\ngit rebase --abort\n\n# Find state before rebase\ngit reflog\n# abc123 HEAD@{1}: rebase: checkout main\n\n# Return to pre-rebase state\ngit reset --hard HEAD@{1}\n\n# Alternative: use ORIG_HEAD\ngit reset --hard ORIG_HEAD\n```\n\n### Rebase Conflicts\n\n```bash\n# During rebase conflict\ngit status\n# both modified: file.go\n\n# Resolve conflicts\n# Edit file.go\ngit add file.go\ngit rebase --continue\n\n# Skip problematic commit\ngit rebase --skip\n\n# Edit commit during rebase\ngit commit --amend\ngit rebase --continue\n```\n\n### Rebase onto Wrong Branch\n\n```bash\n# Find original branch point\ngit reflog\n\n# Reset to before rebase\ngit reset --hard HEAD@{5}\n\n# Rebase onto correct branch\ngit rebase correct-branch\n```\n\n## Repository Corruption\n\n### Detecting Corruption\n\n```bash\n# Check repository integrity\ngit fsck --full\n\n# Check connectivity\ngit fsck --connectivity-only\n\n# Verify pack files\ngit verify-pack -v .git/objects/pack/*.idx\n```\n\n### Fixing Corrupted Objects\n\n```bash\n# Remove corrupted object\nrm .git/objects/ab/cd1234...\n\n# Try to recover from remote\ngit fetch origin\n\n# Rebuild object database\ngit gc --prune=now\n\n# Aggressive cleanup\ngit gc --aggressive --prune=now\n```\n\n### Fixing Index Corruption\n\n```bash\n# Remove corrupted index\nrm .git/index\n\n# Rebuild index\ngit reset\n\n# Or reset to HEAD\ngit reset --hard HEAD\n```\n\n### Recovering from Bad Pack File\n\n```bash\n# Unpack corrupted pack\ngit unpack-objects < .git/objects/pack/pack-*.pack\n\n# Remove corrupted pack\nrm .git/objects/pack/pack-*\n\n# Repack repository\ngit repack -a -d\n\n# Verify integrity\ngit fsck --full\n```\n\n## Fixing References\n\n### Corrupted Branch References\n\n```bash\n# View all references\ngit show-ref\n\n# Manual reference fix\necho \"abc123def456\" > .git/refs/heads/branch-name\n\n# Or use update-ref\ngit update-ref refs/heads/branch-name abc123\n\n# Delete corrupted reference\ngit update-ref -d refs/heads/bad-branch\n```\n\n### Fixing HEAD Reference\n\n```bash\n# HEAD is corrupted or missing\necho \"ref: refs/heads/main\" > .git/HEAD\n\n# Or point to specific commit\necho \"abc123def456\" > .git/HEAD\n\n# Verify HEAD\ngit symbolic-ref HEAD\n```\n\n### Pruning Stale References\n\n```bash\n# Remove stale remote references\ngit remote prune origin\n\n# Remove all stale references\ngit fetch --prune\n\n# Remove all remote branches that no longer exist\ngit branch -vv | grep ': gone]' | awk '{print $1}' | xargs git branch -D\n```\n\n## Undoing Changes\n\n### Undo Last Commit (Keep Changes)\n\n```bash\n# Soft reset (changes staged)\ngit reset --soft HEAD~1\n\n# Mixed reset (changes unstaged)\ngit reset HEAD~1\n```\n\n### Undo Last Commit (Discard Changes)\n\n```bash\n# Hard reset\ngit reset --hard HEAD~1\n\n# Can still recover via reflog\ngit reflog\ngit reset --hard HEAD@{1}\n```\n\n### Undo Multiple Commits\n\n```bash\n# Reset to specific commit\ngit reset --hard abc123\n\n# Revert multiple commits (creates new commits)\ngit revert HEAD~3..HEAD\n\n# Interactive rebase to remove commits\ngit rebase -i HEAD~5\n# Mark commits with 'drop' or delete lines\n```\n\n### Undo Changes to File\n\n```bash\n# Discard uncommitted changes\ngit checkout -- file.go\n\n# Or in Git 2.23+\ngit restore file.go\n\n# Discard staged changes\ngit reset HEAD file.go\ngit restore file.go\n\n# Or in Git 2.23+\ngit restore --staged file.go\ngit restore file.go\n\n# Restore file from specific commit\ngit checkout abc123 -- file.go\n```\n\n### Undo Public Commits\n\n```bash\n# Never use reset on public commits\n# Use revert instead\ngit revert HEAD\ngit revert abc123\ngit revert abc123..def456\n\n# Revert merge commit\ngit revert -m 1 merge-commit-hash\n```\n\n## Handling Force Push Issues\n\n### Recovering After Force Push\n\n```bash\n# If you were force pushed over\ngit reflog\n# abc123 HEAD@{1}: pull: Fast-forward\n\n# Recover your commits\ngit reset --hard HEAD@{1}\n\n# Create backup branch\ngit branch backup-branch\n\n# Merge with force-pushed branch\ngit pull origin main\ngit merge backup-branch\n```\n\n### Preventing Force Push Damage\n\n```bash\n# Always fetch before force push\ngit fetch origin\n\n# View what would be lost\ngit log origin/main..HEAD\n\n# Force push with lease (safer)\ngit push --force-with-lease origin main\n\n# Configure push protection\ngit config --global push.default simple\n```\n\n## Large File Issues\n\n### Finding Large Files\n\n```bash\n# Find large files in history\ngit rev-list --objects --all | \\\n  git cat-file --batch-check='%(objecttype) %(objectname) %(objectsize) %(rest)' | \\\n  awk '/^blob/ {print substr($0,6)}' | \\\n  sort --numeric-sort --key=2 | \\\n  tail -10\n\n# Verify current large files\ngit ls-files | xargs ls -lh | sort -k 5 -h -r | head -20\n```\n\n### Removing Large Files\n\n```bash\n# Using git-filter-repo (recommended)\ngit filter-repo --path large-file.bin --invert-paths\n\n# Using BFG\nbfg --strip-blobs-bigger-than 100M\n\n# After removal\ngit reflog expire --expire=now --all\ngit gc --prune=now --aggressive\ngit push --force origin main\n```\n\n### Preventing Large Files\n\n```bash\n# Configure pre-commit hook\ncat > .git/hooks/pre-commit << 'EOF'\n#!/bin/bash\nif git diff --cached --name-only | xargs du -h | awk '$1 ~ /M$|G$/' | grep .; then\n    echo \"Error: Large file detected\"\n    exit 1\nfi\nEOF\n\nchmod +x .git/hooks/pre-commit\n```\n\n## Authentication Issues\n\n### SSH Key Problems\n\n```bash\n# Test SSH connection\nssh -T git@github.com\n\n# Check SSH key\nls -la ~/.ssh\n\n# Generate new SSH key\nssh-keygen -t ed25519 -C \"email@example.com\"\n\n# Add key to ssh-agent\neval \"$(ssh-agent -s)\"\nssh-add ~/.ssh/id_ed25519\n\n# Configure SSH\ncat > ~/.ssh/config << EOF\nHost github.com\n  HostName github.com\n  User git\n  IdentityFile ~/.ssh/id_ed25519\nEOF\n```\n\n### HTTPS Authentication\n\n```bash\n# Cache credentials\ngit config --global credential.helper cache\ngit config --global credential.helper 'cache --timeout=3600'\n\n# Or use store (less secure)\ngit config --global credential.helper store\n\n# Update remote URL\ngit remote set-url origin https://github.com/user/repo.git\n\n# Use personal access token\ngit clone https://TOKEN@github.com/user/repo.git\n```\n\n### Permission Denied\n\n```bash\n# Check remote URL\ngit remote -v\n\n# Change to SSH\ngit remote set-url origin git@github.com:user/repo.git\n\n# Change to HTTPS\ngit remote set-url origin https://github.com/user/repo.git\n\n# Verify permissions\nls -la .git/\nchmod -R u+rw .git/\n```\n\n## Submodule Issues\n\n### Submodule Not Initialized\n\n```bash\n# Initialize submodules\ngit submodule init\ngit submodule update\n\n# Or in one command\ngit submodule update --init --recursive\n```\n\n### Detached HEAD in Submodule\n\n```bash\n# Enter submodule\ncd submodule-dir\n\n# Create branch\ngit checkout -b main\n\n# Or attach to existing branch\ngit checkout main\ngit pull origin main\n\n# Update parent repo\ncd ..\ngit add submodule-dir\ngit commit -m \"chore: update submodule\"\n```\n\n### Submodule Conflicts\n\n```bash\n# Check submodule status\ngit submodule status\n\n# Reset submodule\ngit submodule update --init --force\n\n# Remove and re-add submodule\ngit submodule deinit -f path/to/submodule\ngit rm -f path/to/submodule\ngit submodule add <url> path/to/submodule\n```\n\n## Performance Issues\n\n### Slow Operations\n\n```bash\n# Optimize repository\ngit gc --aggressive\n\n# Repack efficiently\ngit repack -a -d --depth=250 --window=250\n\n# Prune old objects\ngit prune --expire now\n\n# Clean up unnecessary files\ngit clean -fdx\n```\n\n### Large Repository\n\n```bash\n# Shallow clone\ngit clone --depth 1 <url>\n\n# Fetch only one branch\ngit clone --single-branch --branch main <url>\n\n# Partial clone\ngit clone --filter=blob:none <url>\n\n# Sparse checkout\ngit sparse-checkout init --cone\ngit sparse-checkout set folder1 folder2\n```\n\n### Memory Issues\n\n```bash\n# Increase memory limits\ngit config --global pack.windowMemory \"100m\"\ngit config --global pack.packSizeLimit \"100m\"\ngit config --global pack.threads \"1\"\n\n# Disable delta compression temporarily\ngit config --global pack.compression 0\n```\n\n## Common Error Messages\n\n### \"fatal: refusing to merge unrelated histories\"\n\n```bash\n# Allow merging unrelated histories\ngit pull origin main --allow-unrelated-histories\n```\n\n### \"fatal: not a git repository\"\n\n```bash\n# Reinitialize repository\ngit init\n\n# Or check if .git directory exists\nls -la .git\n\n# Restore from backup if corrupted\n```\n\n### \"error: Your local changes would be overwritten\"\n\n```bash\n# Stash changes\ngit stash\ngit pull\ngit stash pop\n\n# Or discard changes\ngit reset --hard HEAD\ngit pull\n```\n\n### \"error: failed to push some refs\"\n\n```bash\n# Fetch and merge first\ngit pull origin main\n\n# Or rebase\ngit pull --rebase origin main\n\n# Force push (dangerous)\ngit push --force origin main\n\n# Safer force push\ngit push --force-with-lease origin main\n```\n\n### \"fatal: unable to access: SSL certificate problem\"\n\n```bash\n# Disable SSL verification (not recommended)\ngit config --global http.sslVerify false\n\n# Or update SSL certificates\ngit config --global http.sslCAInfo /path/to/cacert.pem\n```\n\n## Diagnostic Commands\n\n### Repository Health Check\n\n```bash\n# Full integrity check\ngit fsck --full --strict\n\n# Check connectivity\ngit fsck --connectivity-only\n\n# Verify objects\ngit verify-pack -v .git/objects/pack/*.idx\n\n# Check reflog\ngit reflog expire --dry-run --all\n\n# Analyze repository\ngit count-objects -vH\n```\n\n### Debug Information\n\n```bash\n# Enable verbose logging\nGIT_TRACE=1 git status\nGIT_TRACE=1 git pull\n\n# Debug specific operations\nGIT_TRACE_PACKET=1 git fetch\nGIT_TRACE_PERFORMANCE=1 git diff\nGIT_CURL_VERBOSE=1 git push\n\n# Configuration debugging\ngit config --list --show-origin\ngit config --list --show-scope\n```\n\n## Prevention Strategies\n\n1. **Regular Backups:** Create backup branches before risky operations\n2. **Use Reflog:** Reflog is your safety net, keep it clean\n3. **Enable Rerere:** Reuse recorded conflict resolutions\n4. **Protect Branches:** Use branch protection rules\n5. **Pre-commit Hooks:** Validate commits before they're made\n6. **Regular Maintenance:** Run `git gc` periodically\n7. **Test Before Force Push:** Always verify with `--dry-run`\n8. **Communication:** Inform team about disruptive operations\n9. **Learn Git Internals:** Understanding how git works prevents issues\n10. **Keep Git Updated:** Use latest stable version\n\n## Resources\n\nAdditional troubleshooting guides are available in the `assets/` directory:\n- `troubleshooting/` - Step-by-step recovery procedures\n- `scripts/` - Diagnostic and recovery scripts\n- `checklists/` - Problem diagnosis workflows\n\nSee `references/` directory for:\n- Git error message database\n- Recovery procedure documentation\n- Git internal structure guides\n- Common pitfall documentation"
              }
            ]
          },
          {
            "name": "rust-gpui-developer",
            "description": "Experienced Rust developer with expertise in user interface development using the gpui crate",
            "source": "./plugins/rust-gpui-developer",
            "category": "languages",
            "version": "1.0.0",
            "author": {
              "name": "Geoff Johnson",
              "url": "https://github.com/geoffjay"
            },
            "install_commands": [
              "/plugin marketplace add geoffjay/claude-plugins",
              "/plugin install rust-gpui-developer@geoffjay-claude-plugins"
            ],
            "signals": {
              "stars": 4,
              "forks": 1,
              "pushed_at": "2025-11-04T20:23:37Z",
              "created_at": "2025-10-17T18:24:21Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/gpui-component",
                "description": "Generate reusable GPUI components with proper typing, state management, styling, and documentation",
                "path": "plugins/rust-gpui-developer/commands/gpui-component.md",
                "frontmatter": {
                  "name": "gpui-component",
                  "description": "Generate reusable GPUI components with proper typing, state management, styling, and documentation"
                },
                "content": "# GPUI Component Generator\n\nGenerate reusable, well-structured GPUI components with proper typing, state management, styling, and comprehensive documentation.\n\n## Arguments\n\n- `$1`: Component name (required) - Name of the component in PascalCase (e.g., \"Button\", \"DataTable\", \"SearchInput\")\n- `$2`: Component type (optional) - Either \"stateless\" (default) or \"stateful\"\n\n## Workflow\n\n### 1. Gather Component Requirements\n\nAsk user for:\n- Component purpose and description\n- Props/configuration needed\n- Whether component needs internal state\n- Event handlers required\n- Styling requirements\n- Accessibility needs\n\n### 2. Generate Component Struct\n\nCreate component struct based on type:\n\n#### Stateless Component\n\n```rust\nuse gpui::*;\n\n/// A reusable button component\n///\n/// # Examples\n///\n/// ```\n/// Button::new(\"Click me\")\n///     .on_click(|cx| {\n///         println!(\"Clicked!\");\n///     })\n/// ```\npub struct Button {\n    label: String,\n    variant: ButtonVariant,\n    disabled: bool,\n    on_click: Option<Box<dyn Fn(&mut WindowContext)>>,\n}\n\n#[derive(Clone, Copy, PartialEq)]\npub enum ButtonVariant {\n    Primary,\n    Secondary,\n    Destructive,\n    Ghost,\n}\n\nimpl Button {\n    pub fn new(label: impl Into<String>) -> Self {\n        Self {\n            label: label.into(),\n            variant: ButtonVariant::Primary,\n            disabled: false,\n            on_click: None,\n        }\n    }\n\n    pub fn variant(mut self, variant: ButtonVariant) -> Self {\n        self.variant = variant;\n        self\n    }\n\n    pub fn disabled(mut self, disabled: bool) -> Self {\n        self.disabled = disabled;\n        self\n    }\n\n    pub fn on_click(mut self, handler: impl Fn(&mut WindowContext) + 'static) -> Self {\n        self.on_click = Some(Box::new(handler));\n        self\n    }\n}\n```\n\n#### Stateful Component\n\n```rust\nuse gpui::*;\n\n/// A search input with autocomplete\npub struct SearchInput {\n    query: String,\n    suggestions: Vec<String>,\n    selected_index: Option<usize>,\n    on_search: Option<Box<dyn Fn(&str, &mut WindowContext)>>,\n}\n\nimpl SearchInput {\n    pub fn new() -> Self {\n        Self {\n            query: String::new(),\n            suggestions: Vec::new(),\n            selected_index: None,\n            on_search: None,\n        }\n    }\n\n    pub fn on_search(mut self, handler: impl Fn(&str, &mut WindowContext) + 'static) -> Self {\n        self.on_search = Some(Box::new(handler));\n        self\n    }\n\n    fn handle_input(&mut self, value: String, cx: &mut ViewContext<Self>) {\n        self.query = value;\n        self.update_suggestions(cx);\n        cx.notify();\n    }\n\n    fn update_suggestions(&mut self, cx: &mut ViewContext<Self>) {\n        // Update suggestions based on query\n        if let Some(handler) = &self.on_search {\n            handler(&self.query, cx);\n        }\n    }\n\n    fn handle_key_down(&mut self, event: &KeyDownEvent, cx: &mut ViewContext<Self>) {\n        match event.key.as_str() {\n            \"ArrowDown\" => {\n                self.selected_index = Some(\n                    self.selected_index\n                        .map(|i| (i + 1).min(self.suggestions.len() - 1))\n                        .unwrap_or(0)\n                );\n                cx.notify();\n            }\n            \"ArrowUp\" => {\n                self.selected_index = self.selected_index\n                    .and_then(|i| i.checked_sub(1));\n                cx.notify();\n            }\n            \"Enter\" => {\n                if let Some(index) = self.selected_index {\n                    self.query = self.suggestions[index].clone();\n                    self.suggestions.clear();\n                    cx.notify();\n                }\n            }\n            _ => {}\n        }\n    }\n}\n```\n\n### 3. Implement Element/Render Traits\n\n#### Stateless Component Render\n\n```rust\nimpl Render for Button {\n    fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n        let theme = cx.global::<Theme>();\n        let (bg_color, text_color, hover_color) = match self.variant {\n            ButtonVariant::Primary => (\n                theme.primary,\n                theme.primary_foreground,\n                theme.primary_hover,\n            ),\n            ButtonVariant::Secondary => (\n                theme.secondary,\n                theme.secondary_foreground,\n                theme.secondary_hover,\n            ),\n            ButtonVariant::Destructive => (\n                theme.destructive,\n                theme.destructive_foreground,\n                theme.destructive_hover,\n            ),\n            ButtonVariant::Ghost => (\n                hsla(0.0, 0.0, 0.0, 0.0),\n                theme.foreground,\n                theme.muted,\n            ),\n        };\n\n        div()\n            .px_4()\n            .py_2()\n            .bg(bg_color)\n            .text_color(text_color)\n            .rounded_md()\n            .font_medium()\n            .when(!self.disabled, |this| {\n                this.cursor_pointer()\n                    .hover(|this| this.bg(hover_color))\n            })\n            .when(self.disabled, |this| {\n                this.opacity(0.5)\n                    .cursor_not_allowed()\n            })\n            .when_some(self.on_click.take(), |this, handler| {\n                this.on_click(move |_, cx| {\n                    if !self.disabled {\n                        handler(cx);\n                    }\n                })\n            })\n            .child(self.label.clone())\n    }\n}\n```\n\n#### Stateful Component Render\n\n```rust\nimpl Render for SearchInput {\n    fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n        let theme = cx.global::<Theme>();\n\n        div()\n            .flex()\n            .flex_col()\n            .relative()\n            .child(\n                div()\n                    .flex()\n                    .items_center()\n                    .px_3()\n                    .py_2()\n                    .bg(theme.background)\n                    .border_1()\n                    .border_color(theme.border)\n                    .rounded_md()\n                    .child(\n                        input()\n                            .flex_1()\n                            .placeholder(\"Search...\")\n                            .value(&self.query)\n                            .on_input(cx.listener(|this, value, cx| {\n                                this.handle_input(value, cx);\n                            }))\n                            .on_key_down(cx.listener(|this, event, cx| {\n                                this.handle_key_down(event, cx);\n                            }))\n                    )\n            )\n            .when(!self.suggestions.is_empty(), |this| {\n                this.child(\n                    div()\n                        .absolute()\n                        .top_full()\n                        .left_0()\n                        .right_0()\n                        .mt_1()\n                        .bg(theme.background)\n                        .border_1()\n                        .border_color(theme.border)\n                        .rounded_md()\n                        .shadow_lg()\n                        .max_h_64()\n                        .overflow_y_auto()\n                        .children(\n                            self.suggestions.iter().enumerate().map(|(i, suggestion)| {\n                                div()\n                                    .px_3()\n                                    .py_2()\n                                    .cursor_pointer()\n                                    .when(self.selected_index == Some(i), |this| {\n                                        this.bg(theme.accent)\n                                    })\n                                    .hover(|this| this.bg(theme.muted))\n                                    .child(suggestion.as_str())\n                            })\n                        )\n                )\n            })\n    }\n}\n```\n\n### 4. Add State Management\n\nFor stateful components:\n\n```rust\nimpl SearchInput {\n    pub fn set_suggestions(&mut self, suggestions: Vec<String>, cx: &mut ViewContext<Self>) {\n        self.suggestions = suggestions;\n        self.selected_index = None;\n        cx.notify();\n    }\n\n    pub fn clear(&mut self, cx: &mut ViewContext<Self>) {\n        self.query.clear();\n        self.suggestions.clear();\n        self.selected_index = None;\n        cx.notify();\n    }\n\n    pub fn query(&self) -> &str {\n        &self.query\n    }\n}\n```\n\n### 5. Generate Styling\n\nCreate styled variants and theme integration:\n\n```rust\n// Component-specific theme\npub struct ButtonTheme {\n    pub primary_bg: Hsla,\n    pub primary_fg: Hsla,\n    pub primary_hover: Hsla,\n    pub secondary_bg: Hsla,\n    pub secondary_fg: Hsla,\n    pub secondary_hover: Hsla,\n    pub border_radius: Pixels,\n    pub padding_x: Pixels,\n    pub padding_y: Pixels,\n}\n\nimpl ButtonTheme {\n    pub fn from_app_theme(theme: &AppTheme) -> Self {\n        Self {\n            primary_bg: theme.colors.primary,\n            primary_fg: theme.colors.primary_foreground,\n            primary_hover: theme.colors.primary_hover,\n            secondary_bg: theme.colors.secondary,\n            secondary_fg: theme.colors.secondary_foreground,\n            secondary_hover: theme.colors.secondary_hover,\n            border_radius: px(6.0),\n            padding_x: px(16.0),\n            padding_y: px(8.0),\n        }\n    }\n}\n```\n\n### 6. Create Documentation\n\nGenerate comprehensive documentation:\n\n```rust\n//! Button Component\n//!\n//! A flexible, accessible button component with multiple variants and states.\n//!\n//! # Features\n//!\n//! - Multiple variants (Primary, Secondary, Destructive, Ghost)\n//! - Disabled state support\n//! - Customizable click handlers\n//! - Full keyboard accessibility\n//! - Theme integration\n//!\n//! # Examples\n//!\n//! ## Basic Usage\n//!\n//! ```rust\n//! let button = Button::new(\"Click me\")\n//!     .on_click(|cx| {\n//!         println!(\"Button clicked!\");\n//!     });\n//! ```\n//!\n//! ## With Variants\n//!\n//! ```rust\n//! let primary = Button::new(\"Primary\").variant(ButtonVariant::Primary);\n//! let secondary = Button::new(\"Secondary\").variant(ButtonVariant::Secondary);\n//! let destructive = Button::new(\"Delete\").variant(ButtonVariant::Destructive);\n//! ```\n//!\n//! ## Disabled State\n//!\n//! ```rust\n//! let button = Button::new(\"Disabled\")\n//!     .disabled(true);\n//! ```\n//!\n//! # Accessibility\n//!\n//! - Supports keyboard navigation (Enter/Space to activate)\n//! - Proper ARIA attributes\n//! - Focus indicators\n//! - Disabled state communicated to screen readers\n```\n\n### 7. Provide Usage Examples\n\nCreate example usage code:\n\n```rust\n// examples/button_example.rs\nuse gpui::*;\n\nfn main() {\n    App::new(\"com.example.button-demo\", |cx| {\n        cx.open_window(\n            WindowOptions::default(),\n            |cx| cx.new_view(|cx| ButtonDemo::new(cx))\n        )\n    }).run();\n}\n\nstruct ButtonDemo;\n\nimpl ButtonDemo {\n    fn new(cx: &mut ViewContext<Self>) -> Self {\n        Self\n    }\n}\n\nimpl Render for ButtonDemo {\n    fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n        div()\n            .flex()\n            .flex_col()\n            .gap_4()\n            .p_8()\n            .child(\n                Button::new(\"Primary Button\")\n                    .variant(ButtonVariant::Primary)\n                    .on_click(|cx| {\n                        println!(\"Primary clicked!\");\n                    })\n            )\n            .child(\n                Button::new(\"Secondary Button\")\n                    .variant(ButtonVariant::Secondary)\n                    .on_click(|cx| {\n                        println!(\"Secondary clicked!\");\n                    })\n            )\n            .child(\n                Button::new(\"Destructive Button\")\n                    .variant(ButtonVariant::Destructive)\n                    .on_click(|cx| {\n                        println!(\"Destructive clicked!\");\n                    })\n            )\n            .child(\n                Button::new(\"Disabled Button\")\n                    .disabled(true)\n            )\n    }\n}\n```\n\n### 8. Add Component Tests\n\nGenerate tests for the component:\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[gpui::test]\n    fn test_button_creation() {\n        App::test(|cx| {\n            let button = Button::new(\"Test\");\n            assert_eq!(button.label, \"Test\");\n            assert_eq!(button.variant, ButtonVariant::Primary);\n            assert!(!button.disabled);\n        });\n    }\n\n    #[gpui::test]\n    fn test_button_click() {\n        App::test(|cx| {\n            let clicked = Rc::new(RefCell::new(false));\n            let clicked_clone = clicked.clone();\n\n            let button = Button::new(\"Test\")\n                .on_click(move |_| {\n                    *clicked_clone.borrow_mut() = true;\n                });\n\n            // Simulate click\n            if let Some(handler) = button.on_click {\n                handler(cx);\n            }\n\n            assert!(*clicked.borrow());\n        });\n    }\n}\n```\n\n### 9. Generate Component Module\n\nCreate module file with exports:\n\n```rust\n// src/ui/components/button/mod.rs\n\nmod button;\nmod theme;\n\npub use button::{Button, ButtonVariant};\npub use theme::ButtonTheme;\n```\n\n### 10. Provide Integration Instructions\n\nOutput integration guide:\n\n```\n✓ Created Button component\n\nFiles created:\n  - src/ui/components/button/button.rs\n  - src/ui/components/button/theme.rs\n  - src/ui/components/button/mod.rs\n  - examples/button_example.rs\n  - tests/button_test.rs\n\nNext steps:\n\n1. Add to your components module:\n   In src/ui/components/mod.rs:\n   pub mod button;\n   pub use button::Button;\n\n2. Use in your views:\n   use crate::ui::components::Button;\n\n   Button::new(\"Click me\")\n       .variant(ButtonVariant::Primary)\n       .on_click(|cx| {\n           // Handle click\n       })\n\n3. Run example:\n   cargo run --example button_example\n\n4. Run tests:\n   cargo test button\n\nDocumentation: See generated component docs for full API\n```\n\n## Component Types\n\n### Stateless Components\n- No internal state\n- Pure rendering based on props\n- Examples: Button, Icon, Label\n\n### Stateful Components\n- Internal state management\n- User input handling\n- Examples: Input, SearchBox, Dropdown\n\n### Container Components\n- Manage child components\n- State coordination\n- Examples: Form, List, Tabs\n\n### Composite Components\n- Combine multiple components\n- Complex functionality\n- Examples: DataTable, Dialog, Wizard\n\n## Best Practices\n\n- Builder pattern for configuration\n- Theme integration\n- Accessibility attributes\n- Comprehensive documentation\n- Usage examples\n- Unit tests\n- Type safety\n- Error handling\n\n## Example Usage\n\n```bash\n# Generate stateless component\n/gpui-component Button\n\n# Generate stateful component\n/gpui-component SearchInput stateful\n\n# Generate with custom requirements\n/gpui-component DataTable stateful --with-examples --with-tests\n```"
              },
              {
                "name": "/gpui-review",
                "description": "Review GPUI code for idiomatic patterns, performance issues, state management correctness, and framework best practices",
                "path": "plugins/rust-gpui-developer/commands/gpui-review.md",
                "frontmatter": {
                  "name": "gpui-review",
                  "description": "Review GPUI code for idiomatic patterns, performance issues, state management correctness, and framework best practices"
                },
                "content": "# GPUI Code Review\n\nPerform comprehensive code review of GPUI applications, identifying issues with patterns, performance, state management, and suggesting improvements.\n\n## Arguments\n\n- `$1`: Path (optional) - Specific file or directory to review. If not provided, reviews entire project.\n\n## Workflow\n\n### 1. Search for GPUI Code\n\n- Locate all `.rs` files in the project or specified path\n- Identify files using GPUI (imports `gpui::*` or specific GPUI types)\n- Categorize files by type:\n  - View components (impl Render)\n  - Models (application state)\n  - Main entry points\n  - Utility code\n\n### 2. Analyze Component Patterns\n\nReview each component for:\n\n#### Component Structure\n- [ ] Proper use of View vs Model types\n- [ ] Clear separation of concerns\n- [ ] Component has single responsibility\n- [ ] Props/dependencies passed explicitly\n- [ ] Proper lifetime management\n\n#### Anti-patterns\n- [ ] God components (doing too much)\n- [ ] Tight coupling between components\n- [ ] Improper state ownership\n- [ ] Missing error handling\n- [ ] Inconsistent naming conventions\n\nExample issues to flag:\n\n```rust\n// BAD: Component doing too much\nimpl Render for GodComponent {\n    fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n        // Fetching data\n        // Computing business logic\n        // Rendering UI\n        // Handling all events\n        // Managing multiple concerns\n    }\n}\n\n// GOOD: Focused component\nimpl Render for FocusedComponent {\n    fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n        let state = self.model.read(cx);\n        div().child(format!(\"Count: {}\", state.count))\n    }\n}\n```\n\n### 3. Check State Management\n\nReview state management for:\n\n#### Model Usage\n- [ ] State properly encapsulated in Model types\n- [ ] Appropriate use of `cx.new_model()`\n- [ ] State updates use `model.update()`\n- [ ] No direct state mutation outside updates\n- [ ] Proper state ownership hierarchy\n\n#### Subscription Management\n- [ ] Subscriptions created during initialization, not render\n- [ ] Subscriptions stored to prevent cleanup\n- [ ] `cx.observe()` used for model changes\n- [ ] No subscription leaks\n- [ ] Proper cleanup in Drop if needed\n\nExample issues to flag:\n\n```rust\n// BAD: Subscription in render (memory leak)\nimpl Render for BadView {\n    fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n        cx.observe(&self.model, |_, _, cx| cx.notify());  // Leak!\n        div()\n    }\n}\n\n// GOOD: Subscription stored\nstruct GoodView {\n    model: Model<Data>,\n    _subscription: Subscription,\n}\n\nimpl GoodView {\n    fn new(model: Model<Data>, cx: &mut ViewContext<Self>) -> Self {\n        let _subscription = cx.observe(&model, |_, _, cx| cx.notify());\n        Self { model, _subscription }\n    }\n}\n```\n\n#### Context Usage\n- [ ] Appropriate context types (WindowContext, ViewContext, ModelContext)\n- [ ] Global state used sparingly with `cx.global::<T>()`\n- [ ] Context not stored (lifetime issues)\n- [ ] Proper use of `cx.notify()` for updates\n\n### 4. Review Render Performance\n\nAnalyze for performance issues:\n\n#### Unnecessary Renders\n- [ ] No expensive computations in render()\n- [ ] Cached/memoized expensive operations\n- [ ] Minimal `cx.notify()` calls\n- [ ] No rendering on every tick/timer\n- [ ] Proper use of derived state\n\n#### Element Efficiency\n- [ ] Minimal element nesting depth\n- [ ] No repeated identical elements\n- [ ] Efficient list rendering (consider virtualization)\n- [ ] Appropriate use of keys for dynamic lists\n- [ ] No unnecessary cloning in render\n\nExample issues to flag:\n\n```rust\n// BAD: Expensive computation in render\nimpl Render for BadComponent {\n    fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n        let result = expensive_computation();  // Every render!\n        div().child(result)\n    }\n}\n\n// GOOD: Compute on state change\nstruct GoodComponent {\n    cached_result: String,\n}\n\nimpl GoodComponent {\n    fn update_data(&mut self, data: Data, cx: &mut ViewContext<Self>) {\n        self.cached_result = expensive_computation(&data);\n        cx.notify();\n    }\n}\n```\n\n#### Layout Performance\n- [ ] Avoid deep nesting\n- [ ] Use flex layout efficiently\n- [ ] Minimize layout recalculations\n- [ ] Appropriate use of fixed vs dynamic sizing\n- [ ] No layout thrashing\n\n### 5. Identify Anti-Patterns\n\nFlag common GPUI anti-patterns:\n\n#### Memory Issues\n```rust\n// BAD: Circular reference\nstruct CircularRef {\n    self_view: Option<View<Self>>,  // Circular!\n}\n\n// BAD: Unbounded growth\nstruct UnboundedList {\n    items: Vec<Item>,  // Grows forever\n}\n```\n\n#### Incorrect Context Usage\n```rust\n// BAD: Storing context\nstruct BadComponent {\n    cx: ViewContext<Self>,  // Won't compile, lifetime issues\n}\n\n// GOOD: Use context in methods\nimpl BadComponent {\n    fn do_something(&mut self, cx: &mut ViewContext<Self>) {\n        // Use cx here\n    }\n}\n```\n\n#### Event Handling Issues\n```rust\n// BAD: Not preventing default when needed\ndiv()\n    .on_click(|_, cx| {\n        // Action taken but event still propagates\n    })\n\n// GOOD: Prevent propagation when appropriate\ndiv()\n    .on_click(|event, cx| {\n        event.stop_propagation();\n        // Action taken\n    })\n```\n\n### 6. Provide Actionable Suggestions\n\nFor each issue found, provide:\n\n1. **Location**: File and line number\n2. **Issue**: Clear description of the problem\n3. **Why**: Explain why it's problematic\n4. **Fix**: Show concrete code example of how to fix it\n5. **Priority**: Critical, High, Medium, or Low\n\nExample output format:\n\n```\n📁 src/ui/views/main_view.rs:45\n\n❌ Issue: Subscription created in render method\nSeverity: Critical (Memory Leak)\n\nProblem:\n  cx.observe(&self.model, |_, _, cx| cx.notify());\n\nThis creates a new subscription every render, causing a memory leak.\nSubscriptions are never cleaned up.\n\nFix:\n  1. Add subscription field to struct:\n     struct MainView {\n         model: Model<Data>,\n         _subscription: Subscription,\n     }\n\n  2. Create subscription in constructor:\n     fn new(model: Model<Data>, cx: &mut ViewContext<Self>) -> Self {\n         let _subscription = cx.observe(&model, |_, _, cx| cx.notify());\n         Self { model, _subscription }\n     }\n```\n\n### 7. Check Framework Best Practices\n\nReview for GPUI best practices:\n\n- [ ] Proper use of Element trait\n- [ ] Appropriate render trait implementations\n- [ ] Correct action system usage\n- [ ] Proper theme integration\n- [ ] Accessibility attributes where appropriate\n- [ ] Error handling and user feedback\n- [ ] Type safety leveraged\n- [ ] Documentation for public APIs\n\n### 8. Generate Summary Report\n\nProvide summary including:\n\n- Total files reviewed\n- Issues found by severity (Critical, High, Medium, Low)\n- Common patterns identified\n- Overall code quality assessment\n- Top priority fixes\n- Positive patterns to highlight\n\nExample summary:\n\n```\nGPUI Code Review Summary\n========================\n\nFiles Reviewed: 15\nTotal Issues: 23\n\nBy Severity:\n  Critical: 2  (Memory leaks, state corruption)\n  High: 5      (Performance issues, anti-patterns)\n  Medium: 10   (Code organization, minor inefficiencies)\n  Low: 6       (Style, documentation)\n\nTop Priority Fixes:\n  1. Fix subscription leaks in MainView and SidebarView\n  2. Move expensive computations out of render methods\n  3. Implement proper state ownership hierarchy\n  4. Add error handling for async operations\n  5. Reduce component nesting depth in ComplexView\n\nPositive Patterns:\n  ✓ Good separation between UI and business logic\n  ✓ Consistent theming throughout\n  ✓ Proper use of Model types for state\n  ✓ Good component composition in most areas\n\nRecommendations:\n  - Consider extracting reusable components from large views\n  - Implement virtual scrolling for long lists\n  - Add integration tests for critical user flows\n  - Document component APIs and state flow\n```\n\n## Review Categories\n\n### Architecture\n- Project structure\n- Module organization\n- Dependency management\n- Separation of concerns\n\n### State Management\n- Model usage\n- Subscription patterns\n- Context usage\n- State ownership\n\n### Performance\n- Render efficiency\n- Layout optimization\n- Memory management\n- Async operations\n\n### Code Quality\n- Idiomatic Rust\n- Error handling\n- Type safety\n- Documentation\n\n### UI/UX\n- Component reusability\n- Consistent styling\n- Accessibility\n- User feedback\n\n## Example Usage\n\n```bash\n# Review entire project\n/gpui-review\n\n# Review specific file\n/gpui-review src/ui/views/main_view.rs\n\n# Review directory\n/gpui-review src/ui/components/\n```\n\n## Notes\n\n- Focuses on GPUI-specific patterns and idioms\n- Considers both correctness and performance\n- Provides educational feedback with explanations\n- Prioritizes actionable, concrete suggestions\n- Highlights both issues and good patterns"
              },
              {
                "name": "/gpui-scaffold",
                "description": "Scaffold new GPUI applications with modern structure, Cargo workspace setup, component organization, and best practices",
                "path": "plugins/rust-gpui-developer/commands/gpui-scaffold.md",
                "frontmatter": {
                  "name": "gpui-scaffold",
                  "description": "Scaffold new GPUI applications with modern structure, Cargo workspace setup, component organization, and best practices"
                },
                "content": "# GPUI Project Scaffolding\n\nScaffold a new GPUI application with modern project structure, best practices, and example components.\n\n## Arguments\n\n- `$1`: Project name (required) - Name for the new GPUI project (hyphen-case recommended)\n- `$2`: Template type (optional) - Either \"app\" (default) or \"library\"\n\n## Workflow\n\n### 1. Validate Project Name\n\n- Check that project name is provided\n- Validate naming convention (lowercase, hyphens, no spaces)\n- Check that directory doesn't already exist\n- Confirm project creation with user if needed\n\n### 2. Create Directory Structure\n\nCreate the following structure:\n\n```\nproject-name/\n├── Cargo.toml\n├── .gitignore\n├── README.md\n├── src/\n│   ├── main.rs (for app) or lib.rs (for library)\n│   ├── app.rs\n│   ├── ui/\n│   │   ├── mod.rs\n│   │   ├── views/\n│   │   │   ├── mod.rs\n│   │   │   └── main_view.rs\n│   │   ├── components/\n│   │   │   ├── mod.rs\n│   │   │   ├── button.rs\n│   │   │   └── input.rs\n│   │   └── theme.rs\n│   ├── models/\n│   │   ├── mod.rs\n│   │   └── app_state.rs\n│   └── utils/\n│       └── mod.rs\n├── examples/\n│   └── basic.rs\n└── tests/\n    └── integration_test.rs\n```\n\n### 3. Generate Cargo.toml\n\nCreate `Cargo.toml` with:\n\n```toml\n[package]\nname = \"project-name\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\ngpui = { git = \"https://github.com/zed-industries/zed\" }\nanyhow = \"1.0\"\nlog = \"0.4\"\nenv_logger = \"0.11\"\n\n[dev-dependencies]\ncriterion = \"0.5\"\n\n[[bench]]\nname = \"rendering\"\nharness = false\n```\n\n### 4. Create Main Entry Point\n\nFor applications (`main.rs`):\n\n```rust\nuse gpui::*;\nmod app;\nmod ui;\nmod models;\nmod utils;\n\nuse app::App;\n\nfn main() {\n    env_logger::init();\n\n    App::new(\"com.example.project-name\", |cx| {\n        let app = cx.new_model(|cx| app::AppModel::new(cx));\n        let window = cx.open_window(\n            WindowOptions {\n                bounds: WindowBounds::Fixed(Bounds {\n                    origin: point(px(100.0), px(100.0)),\n                    size: size(px(1200.0), px(800.0)),\n                }),\n                ..Default::default()\n            },\n            |cx| cx.new_view(|cx| ui::views::MainView::new(app.clone(), cx)),\n        );\n\n        window.unwrap()\n    })\n    .run();\n}\n```\n\nFor libraries (`lib.rs`):\n\n```rust\npub mod ui;\npub mod models;\npub mod utils;\n\npub use ui::*;\npub use models::*;\n```\n\n### 5. Create App Model\n\nGenerate `src/app.rs`:\n\n```rust\nuse gpui::*;\nuse crate::models::AppState;\n\npub struct AppModel {\n    state: Model<AppState>,\n}\n\nimpl AppModel {\n    pub fn new(cx: &mut ModelContext<Self>) -> Self {\n        Self {\n            state: cx.new_model(|_| AppState::default()),\n        }\n    }\n\n    pub fn state(&self) -> &Model<AppState> {\n        &self.state\n    }\n}\n```\n\n### 6. Create Component Structure\n\nGenerate main view (`src/ui/views/main_view.rs`):\n\n```rust\nuse gpui::*;\nuse crate::app::AppModel;\nuse crate::ui::components::{Button, Input};\n\npub struct MainView {\n    app: Model<AppModel>,\n    _subscription: Subscription,\n}\n\nimpl MainView {\n    pub fn new(app: Model<AppModel>, cx: &mut ViewContext<Self>) -> Self {\n        let subscription = cx.observe(&app, |_, _, cx| cx.notify());\n\n        Self {\n            app,\n            _subscription: subscription,\n        }\n    }\n}\n\nimpl Render for MainView {\n    fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n        let theme = cx.global::<Theme>();\n\n        div()\n            .flex()\n            .flex_col()\n            .size_full()\n            .bg(theme.background)\n            .child(\n                div()\n                    .flex()\n                    .items_center()\n                    .justify_center()\n                    .flex_1()\n                    .child(\"Welcome to your GPUI app!\")\n            )\n    }\n}\n```\n\nGenerate reusable components (`src/ui/components/button.rs`, `src/ui/components/input.rs`).\n\n### 7. Add Example Components\n\nCreate example button component:\n\n```rust\nuse gpui::*;\n\npub struct Button {\n    label: String,\n    on_click: Option<Box<dyn Fn(&mut WindowContext)>>,\n}\n\nimpl Button {\n    pub fn new(label: impl Into<String>) -> Self {\n        Self {\n            label: label.into(),\n            on_click: None,\n        }\n    }\n\n    pub fn on_click(mut self, handler: impl Fn(&mut WindowContext) + 'static) -> Self {\n        self.on_click = Some(Box::new(handler));\n        self\n    }\n}\n\nimpl Render for Button {\n    fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n        let theme = cx.global::<Theme>();\n        let on_click = self.on_click.take();\n\n        div()\n            .px_4()\n            .py_2()\n            .bg(theme.primary)\n            .text_color(theme.primary_foreground)\n            .rounded_md()\n            .cursor_pointer()\n            .hover(|style| style.bg(theme.primary_hover))\n            .when_some(on_click, |this, handler| {\n                this.on_click(move |_, cx| handler(cx))\n            })\n            .child(self.label.clone())\n    }\n}\n```\n\n### 8. Generate Theme System\n\nCreate `src/ui/theme.rs`:\n\n```rust\nuse gpui::*;\n\n#[derive(Clone)]\npub struct Theme {\n    pub background: Hsla,\n    pub foreground: Hsla,\n    pub primary: Hsla,\n    pub primary_foreground: Hsla,\n    pub primary_hover: Hsla,\n    pub border: Hsla,\n}\n\nimpl Default for Theme {\n    fn default() -> Self {\n        Self::light()\n    }\n}\n\nimpl Theme {\n    pub fn light() -> Self {\n        Self {\n            background: rgb(0xffffff),\n            foreground: rgb(0x000000),\n            primary: rgb(0x2563eb),\n            primary_foreground: rgb(0xffffff),\n            primary_hover: rgb(0x1d4ed8),\n            border: rgb(0xe5e7eb),\n        }\n    }\n\n    pub fn dark() -> Self {\n        Self {\n            background: rgb(0x1f2937),\n            foreground: rgb(0xf9fafb),\n            primary: rgb(0x3b82f6),\n            primary_foreground: rgb(0xffffff),\n            primary_hover: rgb(0x2563eb),\n            border: rgb(0x374151),\n        }\n    }\n}\n```\n\n### 9. Generate README\n\nCreate comprehensive README.md with:\n- Project description\n- Installation instructions\n- Usage examples\n- Development setup\n- Building and running instructions\n- Testing guidelines\n- Contributing information\n\n### 10. Add .gitignore\n\n```\n/target/\nCargo.lock\n*.swp\n*.swo\n.DS_Store\n```\n\n### 11. Initialize Git Repository (Optional)\n\n- Run `git init`\n- Create initial commit\n- Ask user if they want to push to remote\n\n### 12. Provide Next Steps\n\nOutput guidance:\n```\n✓ Created GPUI project: project-name\n\nNext steps:\n  cd project-name\n  cargo build\n  cargo run\n\nProject structure:\n  - src/main.rs: Application entry point\n  - src/app.rs: Application model\n  - src/ui/: UI components and views\n  - src/models/: Application state models\n  - src/utils/: Utility functions\n\nTo add components:\n  - Create new files in src/ui/components/\n  - Add to src/ui/components/mod.rs\n  - Use in your views\n\nDocumentation:\n  - GPUI: https://github.com/zed-industries/zed/tree/main/crates/gpui\n  - Examples: See examples/ directory\n```\n\n## Best Practices Included\n\n- Modern project structure with clear separation of concerns\n- Theme system for consistent styling\n- Reusable component patterns\n- Example components to get started\n- Proper subscription management\n- Type-safe state management\n- Development tools (examples, tests)\n\n## Example Usage\n\n```bash\n# Scaffold new application\n/gpui-scaffold my-gpui-app\n\n# Scaffold library project\n/gpui-scaffold my-gpui-lib library\n```\n\n## Notes\n\n- Uses latest GPUI from git (stable API)\n- Follows Rust 2021 edition conventions\n- Includes development dependencies for testing\n- Sets up proper module structure\n- Includes example code for common patterns"
              },
              {
                "name": "/gpui-test",
                "description": "Generate comprehensive tests for GPUI components, views, state management, and user interactions",
                "path": "plugins/rust-gpui-developer/commands/gpui-test.md",
                "frontmatter": {
                  "name": "gpui-test",
                  "description": "Generate comprehensive tests for GPUI components, views, state management, and user interactions"
                },
                "content": "# GPUI Test Generation\n\nGenerate comprehensive tests for GPUI components including unit tests, integration tests, state management tests, and user interaction tests.\n\n## Arguments\n\n- `$1`: Component path (required) - Path to the component file to generate tests for\n\n## Workflow\n\n### 1. Analyze Component Structure\n\n- Read the component file\n- Identify component type (View, Model, Element)\n- Extract component struct and fields\n- Identify render method and UI structure\n- Find state management patterns\n- Locate event handlers and actions\n- Identify dependencies and injected services\n\n### 2. Generate Unit Tests\n\nCreate unit tests for component logic:\n\n#### Component Initialization Tests\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use gpui::*;\n\n    #[gpui::test]\n    fn test_component_initialization() {\n        App::test(|cx| {\n            let state = cx.new_model(|_| AppState::default());\n            let view = cx.new_view(|cx| MyComponent::new(state.clone(), cx));\n\n            assert!(view.is_some());\n        });\n    }\n\n    #[gpui::test]\n    fn test_initial_state() {\n        App::test(|cx| {\n            let state = cx.new_model(|_| AppState {\n                count: 0,\n                items: vec![],\n            });\n            let view = cx.new_view(|cx| MyComponent::new(state.clone(), cx));\n\n            view.update(cx, |view, cx| {\n                let state = view.state.read(cx);\n                assert_eq!(state.count, 0);\n                assert_eq!(state.items.len(), 0);\n            });\n        });\n    }\n}\n```\n\n#### State Management Tests\n\n```rust\n#[gpui::test]\nfn test_state_updates() {\n    App::test(|cx| {\n        let state = cx.new_model(|_| AppState { count: 0 });\n        let view = cx.new_view(|cx| Counter::new(state.clone(), cx));\n\n        // Update state\n        state.update(cx, |state, cx| {\n            state.count = 5;\n            cx.notify();\n        });\n\n        // Verify view reflects change\n        view.update(cx, |view, cx| {\n            let state = view.state.read(cx);\n            assert_eq!(state.count, 5);\n        });\n    });\n}\n\n#[gpui::test]\nfn test_subscription_updates() {\n    App::test(|cx| {\n        let state = cx.new_model(|_| AppState { count: 0 });\n        let view = cx.new_view(|cx| Counter::new(state.clone(), cx));\n\n        let initial_render_count = view.render_count();\n\n        // Update should trigger rerender via subscription\n        state.update(cx, |state, cx| {\n            state.count += 1;\n            cx.notify();\n        });\n\n        assert_eq!(view.render_count(), initial_render_count + 1);\n    });\n}\n```\n\n### 3. Create Integration Tests\n\nGenerate integration tests for component interactions:\n\n#### User Interaction Tests\n\n```rust\n#[gpui::test]\nfn test_button_click() {\n    App::test(|cx| {\n        let state = cx.new_model(|_| AppState { count: 0 });\n        let view = cx.new_view(|cx| Counter::new(state.clone(), cx));\n\n        // Simulate button click\n        view.update(cx, |view, cx| {\n            view.handle_increment(cx);\n        });\n\n        // Verify state updated\n        state.update(cx, |state, _| {\n            assert_eq!(state.count, 1);\n        });\n    });\n}\n\n#[gpui::test]\nfn test_input_change() {\n    App::test(|cx| {\n        let state = cx.new_model(|_| FormState::default());\n        let view = cx.new_view(|cx| Form::new(state.clone(), cx));\n\n        // Simulate input change\n        view.update(cx, |view, cx| {\n            view.handle_input_change(\"test value\", cx);\n        });\n\n        // Verify state updated\n        state.update(cx, |state, _| {\n            assert_eq!(state.input_value, \"test value\");\n        });\n    });\n}\n```\n\n#### Action Handling Tests\n\n```rust\n#[gpui::test]\nfn test_action_dispatch() {\n    App::test(|cx| {\n        let state = cx.new_model(|_| AppState { count: 0 });\n        let view = cx.new_view(|cx| Counter::new(state.clone(), cx));\n\n        // Dispatch action\n        view.update(cx, |view, cx| {\n            cx.dispatch_action(Increment);\n        });\n\n        // Verify action handled\n        state.update(cx, |state, _| {\n            assert_eq!(state.count, 1);\n        });\n    });\n}\n```\n\n### 4. Add Interaction Tests\n\nTest complex user interactions:\n\n#### Multi-Step Interactions\n\n```rust\n#[gpui::test]\nfn test_complete_user_flow() {\n    App::test(|cx| {\n        let state = cx.new_model(|_| TodoState::default());\n        let view = cx.new_view(|cx| TodoList::new(state.clone(), cx));\n\n        view.update(cx, |view, cx| {\n            // Add item\n            view.handle_add_todo(\"Buy milk\", cx);\n\n            // Mark complete\n            view.handle_toggle_todo(0, cx);\n\n            // Delete item\n            view.handle_delete_todo(0, cx);\n        });\n\n        state.update(cx, |state, _| {\n            assert_eq!(state.todos.len(), 0);\n        });\n    });\n}\n```\n\n#### Edge Cases\n\n```rust\n#[gpui::test]\nfn test_empty_state() {\n    App::test(|cx| {\n        let state = cx.new_model(|_| AppState::default());\n        let view = cx.new_view(|cx| MyComponent::new(state.clone(), cx));\n\n        // Verify graceful handling of empty state\n        view.update(cx, |view, cx| {\n            let element = view.render(cx);\n            // Assert renders without panic\n        });\n    });\n}\n\n#[gpui::test]\nfn test_boundary_conditions() {\n    App::test(|cx| {\n        let state = cx.new_model(|_| CounterState { count: i32::MAX });\n        let view = cx.new_view(|cx| Counter::new(state.clone(), cx));\n\n        // Test overflow handling\n        view.update(cx, |view, cx| {\n            view.handle_increment(cx);\n        });\n\n        state.update(cx, |state, _| {\n            // Should handle overflow gracefully\n            assert!(state.count == i32::MAX || state.count == 0);\n        });\n    });\n}\n```\n\n### 5. Generate Test Utilities\n\nCreate helper functions for testing:\n\n```rust\n// Test helpers\nmod test_utils {\n    use super::*;\n    use gpui::*;\n\n    pub fn create_test_state() -> AppState {\n        AppState {\n            count: 0,\n            items: vec![\"item1\".to_string(), \"item2\".to_string()],\n            is_loading: false,\n        }\n    }\n\n    pub fn create_test_view(cx: &mut WindowContext) -> View<MyComponent> {\n        let state = cx.new_model(|_| create_test_state());\n        cx.new_view(|cx| MyComponent::new(state, cx))\n    }\n\n    pub fn assert_state_equals(state: &Model<AppState>, expected_count: i32, cx: &mut AppContext) {\n        state.update(cx, |state, _| {\n            assert_eq!(state.count, expected_count);\n        });\n    }\n}\n```\n\n### 6. Provide Coverage Report\n\nGenerate overview of test coverage:\n\n```rust\n// Coverage targets:\n// - Component initialization: ✓\n// - State updates: ✓\n// - User interactions: ✓\n// - Action handling: ✓\n// - Edge cases: ✓\n// - Error handling: ⚠ (needs work)\n// - Async operations: ⚠ (needs work)\n```\n\n### 7. Add Async Tests\n\nFor components with async operations:\n\n```rust\n#[gpui::test]\nasync fn test_async_data_loading() {\n    App::test(|cx| async move {\n        let state = cx.new_model(|_| DataState::default());\n        let view = cx.new_view(|cx| DataView::new(state.clone(), cx));\n\n        // Trigger async load\n        view.update(cx, |view, cx| {\n            view.load_data(cx);\n        });\n\n        // Wait for completion\n        cx.run_until_parked();\n\n        // Verify data loaded\n        state.update(cx, |state, _| {\n            assert!(state.is_loaded);\n            assert!(!state.data.is_empty());\n        });\n    });\n}\n\n#[gpui::test]\nasync fn test_async_error_handling() {\n    App::test(|cx| async move {\n        let state = cx.new_model(|_| DataState::default());\n        let view = cx.new_view(|cx| DataView::new(state.clone(), cx));\n\n        // Trigger async operation that will fail\n        view.update(cx, |view, cx| {\n            view.load_data_with_error(cx);\n        });\n\n        cx.run_until_parked();\n\n        // Verify error handled\n        state.update(cx, |state, _| {\n            assert!(state.error.is_some());\n            assert!(!state.is_loaded);\n        });\n    });\n}\n```\n\n### 8. Generate Property-Based Tests\n\nFor complex logic, generate property-based tests:\n\n```rust\n#[cfg(test)]\nmod property_tests {\n    use super::*;\n    use proptest::prelude::*;\n\n    proptest! {\n        #[test]\n        fn test_counter_never_negative(increments in 0..100u32, decrements in 0..100u32) {\n            App::test(|cx| {\n                let state = cx.new_model(|_| CounterState { count: 0 });\n\n                state.update(cx, |state, _| {\n                    for _ in 0..increments {\n                        state.count += 1;\n                    }\n                    for _ in 0..decrements {\n                        state.count = state.count.saturating_sub(1);\n                    }\n                });\n\n                state.update(cx, |state, _| {\n                    prop_assert!(state.count >= 0);\n                    Ok(())\n                }).unwrap();\n            });\n        }\n    }\n}\n```\n\n### 9. Add Benchmark Tests\n\nCreate performance benchmarks:\n\n```rust\n// benches/component_bench.rs\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\n\nfn render_benchmark(c: &mut Criterion) {\n    c.bench_function(\"component render\", |b| {\n        App::test(|cx| {\n            let state = cx.new_model(|_| create_large_state());\n            let view = cx.new_view(|cx| MyComponent::new(state, cx));\n\n            b.iter(|| {\n                view.update(cx, |view, cx| {\n                    black_box(view.render(cx));\n                });\n            });\n        });\n    });\n}\n\ncriterion_group!(benches, render_benchmark);\ncriterion_main!(benches);\n```\n\n### 10. Generate Test Documentation\n\nCreate documentation for tests:\n\n```rust\n//! Component Tests\n//!\n//! This module contains comprehensive tests for MyComponent including:\n//!\n//! - Unit tests for component logic and state management\n//! - Integration tests for user interactions\n//! - Async tests for data loading\n//! - Property-based tests for invariants\n//! - Performance benchmarks\n//!\n//! ## Running Tests\n//!\n//! ```bash\n//! # Run all tests\n//! cargo test\n//!\n//! # Run specific test\n//! cargo test test_state_updates\n//!\n//! # Run with output\n//! cargo test -- --nocapture\n//!\n//! # Run benchmarks\n//! cargo bench\n//! ```\n```\n\n## Test Categories\n\n### Unit Tests\n- Component initialization\n- State management\n- Helper functions\n- Pure logic\n\n### Integration Tests\n- User interactions\n- Component composition\n- Event propagation\n- Action handling\n\n### UI Tests\n- Render output\n- Layout calculations\n- Style application\n- Theme integration\n\n### Performance Tests\n- Render benchmarks\n- State update performance\n- Memory usage\n- Subscription efficiency\n\n## Example Usage\n\n```bash\n# Generate tests for specific component\n/gpui-test src/ui/views/counter.rs\n\n# Generate tests for all components in directory\n/gpui-test src/ui/components/\n\n# Generate tests with benchmarks\n/gpui-test src/ui/views/data_view.rs --with-benchmarks\n```\n\n## Best Practices\n\n- Test behavior, not implementation\n- Use descriptive test names\n- Test edge cases and error conditions\n- Keep tests focused and independent\n- Use test utilities for common setup\n- Document complex test scenarios\n- Maintain high coverage (>80%)\n- Run tests in CI/CD pipeline\n\n## Output Structure\n\n```\ntests/\n├── component_name_test.rs\n│   ├── Unit tests\n│   ├── Integration tests\n│   └── Test utilities\n└── benches/\n    └── component_name_bench.rs\n```"
              }
            ],
            "skills": [
              {
                "name": "gpui-patterns",
                "description": "Common GPUI patterns including component composition, state management strategies, event handling, and action dispatching. Use when user needs guidance on GPUI patterns, component design, or state management approaches.",
                "path": "plugins/rust-gpui-developer/skills/gpui-patterns/SKILL.md",
                "frontmatter": {
                  "name": "gpui-patterns",
                  "description": "Common GPUI patterns including component composition, state management strategies, event handling, and action dispatching. Use when user needs guidance on GPUI patterns, component design, or state management approaches."
                },
                "content": "# GPUI Patterns\n\n## Metadata\n\nThis skill provides comprehensive guidance on common GPUI patterns and best practices for building maintainable, performant applications.\n\n## Instructions\n\n### Component Composition Patterns\n\n#### Basic Component Structure\n\n```rust\nuse gpui::*;\n\n// View component with state\nstruct MyView {\n    state: Model<MyState>,\n    _subscription: Subscription,\n}\n\nimpl MyView {\n    fn new(state: Model<MyState>, cx: &mut ViewContext<Self>) -> Self {\n        let _subscription = cx.observe(&state, |_, _, cx| cx.notify());\n        Self { state, _subscription }\n    }\n}\n\nimpl Render for MyView {\n    fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n        let state = self.state.read(cx);\n\n        div()\n            .flex()\n            .flex_col()\n            .child(format!(\"Value: {}\", state.value))\n    }\n}\n```\n\n#### Container/Presenter Pattern\n\n**Container** (manages state and logic):\n```rust\nstruct Container {\n    model: Model<AppState>,\n    _subscription: Subscription,\n}\n\nimpl Container {\n    fn new(model: Model<AppState>, cx: &mut ViewContext<Self>) -> Self {\n        let _subscription = cx.observe(&model, |_, _, cx| cx.notify());\n        Self { model, _subscription }\n    }\n}\n\nimpl Render for Container {\n    fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n        let state = self.model.read(cx);\n\n        // Pass data to presenter\n        Presenter::new(state.data.clone())\n    }\n}\n```\n\n**Presenter** (pure rendering):\n```rust\nstruct Presenter {\n    data: String,\n}\n\nimpl Presenter {\n    fn new(data: String) -> Self {\n        Self { data }\n    }\n}\n\nimpl Render for Presenter {\n    fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n        div().child(self.data.as_str())\n    }\n}\n```\n\n#### Compound Components\n\n```rust\n// Parent component with shared context\npub struct Tabs {\n    items: Vec<TabItem>,\n    active_index: usize,\n}\n\npub struct TabItem {\n    label: String,\n    content: Box<dyn Fn() -> AnyElement>,\n}\n\nimpl Tabs {\n    pub fn new() -> Self {\n        Self {\n            items: Vec::new(),\n            active_index: 0,\n        }\n    }\n\n    pub fn add_tab(\n        mut self,\n        label: impl Into<String>,\n        content: impl Fn() -> AnyElement + 'static,\n    ) -> Self {\n        self.items.push(TabItem {\n            label: label.into(),\n            content: Box::new(content),\n        });\n        self\n    }\n\n    fn set_active(&mut self, index: usize, cx: &mut ViewContext<Self>) {\n        self.active_index = index;\n        cx.notify();\n    }\n}\n\nimpl Render for Tabs {\n    fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n        div()\n            .flex()\n            .flex_col()\n            .child(\n                // Tab headers\n                div()\n                    .flex()\n                    .children(\n                        self.items.iter().enumerate().map(|(i, item)| {\n                            tab_header(&item.label, i == self.active_index, || {\n                                self.set_active(i, cx)\n                            })\n                        })\n                    )\n            )\n            .child(\n                // Active tab content\n                (self.items[self.active_index].content)()\n            )\n    }\n}\n```\n\n### State Management Strategies\n\n#### Model-View Pattern\n\n```rust\n// Model: Application state\n#[derive(Clone)]\nstruct AppState {\n    count: usize,\n    items: Vec<String>,\n}\n\n// View: Observes and renders state\nstruct AppView {\n    state: Model<AppState>,\n    _subscription: Subscription,\n}\n\nimpl AppView {\n    fn new(state: Model<AppState>, cx: &mut ViewContext<Self>) -> Self {\n        let _subscription = cx.observe(&state, |_, _, cx| cx.notify());\n        Self { state, _subscription }\n    }\n\n    fn increment(&mut self, cx: &mut ViewContext<Self>) {\n        self.state.update(cx, |state, cx| {\n            state.count += 1;\n            cx.notify();\n        });\n    }\n}\n```\n\n#### Context-Based State\n\n```rust\n// Global state via context\n#[derive(Clone)]\nstruct GlobalSettings {\n    theme: Theme,\n    language: String,\n}\n\nimpl Global for GlobalSettings {}\n\n// Initialize in app\nfn init_app(cx: &mut AppContext) {\n    cx.set_global(GlobalSettings {\n        theme: Theme::Light,\n        language: \"en\".to_string(),\n    });\n}\n\n// Access in components\nimpl Render for MyView {\n    fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n        let settings = cx.global::<GlobalSettings>();\n\n        div()\n            .child(format!(\"Language: {}\", settings.language))\n    }\n}\n```\n\n#### Subscription Patterns\n\n**Basic Subscription**:\n```rust\nstruct Observer {\n    model: Model<Data>,\n    _subscription: Subscription,\n}\n\nimpl Observer {\n    fn new(model: Model<Data>, cx: &mut ViewContext<Self>) -> Self {\n        let _subscription = cx.observe(&model, |_, _, cx| {\n            cx.notify();  // Rerender on change\n        });\n\n        Self { model, _subscription }\n    }\n}\n```\n\n**Selective Updates**:\n```rust\nimpl Observer {\n    fn new(model: Model<Data>, cx: &mut ViewContext<Self>) -> Self {\n        let _subscription = cx.observe(&model, |this, model, cx| {\n            let data = model.read(cx);\n\n            // Only rerender if specific field changed\n            if data.important_field != this.cached_field {\n                this.cached_field = data.important_field.clone();\n                cx.notify();\n            }\n        });\n\n        Self {\n            model,\n            cached_field: String::new(),\n            _subscription,\n        }\n    }\n}\n```\n\n**Multiple Subscriptions**:\n```rust\nstruct MultiObserver {\n    model_a: Model<DataA>,\n    model_b: Model<DataB>,\n    _subscriptions: Vec<Subscription>,\n}\n\nimpl MultiObserver {\n    fn new(\n        model_a: Model<DataA>,\n        model_b: Model<DataB>,\n        cx: &mut ViewContext<Self>,\n    ) -> Self {\n        let mut subscriptions = Vec::new();\n\n        subscriptions.push(cx.observe(&model_a, |_, _, cx| cx.notify()));\n        subscriptions.push(cx.observe(&model_b, |_, _, cx| cx.notify()));\n\n        Self {\n            model_a,\n            model_b,\n            _subscriptions: subscriptions,\n        }\n    }\n}\n```\n\n### Event Handling Patterns\n\n#### Click Events\n\n```rust\ndiv()\n    .on_click(cx.listener(|this, event: &ClickEvent, cx| {\n        // Handle click\n        this.handle_click(cx);\n    }))\n    .child(\"Click me\")\n```\n\n#### Keyboard Events\n\n```rust\ndiv()\n    .on_key_down(cx.listener(|this, event: &KeyDownEvent, cx| {\n        match event.key.as_str() {\n            \"Enter\" => this.submit(cx),\n            \"Escape\" => this.cancel(cx),\n            _ => {}\n        }\n    }))\n```\n\n#### Event Propagation\n\n```rust\n// Stop propagation\ndiv()\n    .on_click(|event, cx| {\n        event.stop_propagation();\n        // Handle click\n    })\n\n// Prevent default\ndiv()\n    .on_key_down(|event, cx| {\n        if event.key == \"Tab\" {\n            event.prevent_default();\n            // Custom tab handling\n        }\n    })\n```\n\n#### Mouse Events\n\n```rust\ndiv()\n    .on_mouse_down(cx.listener(|this, event, cx| {\n        this.mouse_down_position = Some(event.position);\n    }))\n    .on_mouse_move(cx.listener(|this, event, cx| {\n        if let Some(start) = this.mouse_down_position {\n            let delta = event.position - start;\n            this.handle_drag(delta, cx);\n        }\n    }))\n    .on_mouse_up(cx.listener(|this, event, cx| {\n        this.mouse_down_position = None;\n    }))\n```\n\n### Action System\n\n#### Define Actions\n\n```rust\nuse gpui::*;\n\nactions!(app, [\n    Increment,\n    Decrement,\n    Reset,\n    SetValue\n]);\n\n// Action with data\n#[derive(Clone, PartialEq)]\npub struct SetValue {\n    pub value: i32,\n}\n\nimpl_actions!(app, [SetValue]);\n```\n\n#### Register Action Handlers\n\n```rust\nimpl Counter {\n    fn register_actions(&mut self, cx: &mut ViewContext<Self>) {\n        cx.on_action(cx.listener(|this, _: &Increment, cx| {\n            this.model.update(cx, |state, cx| {\n                state.count += 1;\n                cx.notify();\n            });\n        }));\n\n        cx.on_action(cx.listener(|this, _: &Decrement, cx| {\n            this.model.update(cx, |state, cx| {\n                state.count = state.count.saturating_sub(1);\n                cx.notify();\n            });\n        }));\n\n        cx.on_action(cx.listener(|this, action: &SetValue, cx| {\n            this.model.update(cx, |state, cx| {\n                state.count = action.value;\n                cx.notify();\n            });\n        }));\n    }\n}\n```\n\n#### Dispatch Actions\n\n```rust\n// From within component\nfn handle_button_click(&mut self, cx: &mut ViewContext<Self>) {\n    cx.dispatch_action(Increment);\n}\n\n// With data\nfn set_specific_value(&mut self, value: i32, cx: &mut ViewContext<Self>) {\n    cx.dispatch_action(SetValue { value });\n}\n\n// Global action dispatch\ncx.dispatch_action_on_window(Reset, window_id);\n```\n\n#### Keybindings\n\n```rust\n// Register global keybindings\nfn register_keybindings(cx: &mut AppContext) {\n    cx.bind_keys([\n        KeyBinding::new(\"cmd-+\", Increment, None),\n        KeyBinding::new(\"cmd--\", Decrement, None),\n        KeyBinding::new(\"cmd-0\", Reset, None),\n    ]);\n}\n```\n\n### Element Composition\n\n#### Builder Pattern\n\n```rust\nfn card(title: &str, content: impl IntoElement) -> impl IntoElement {\n    div()\n        .flex()\n        .flex_col()\n        .bg(white())\n        .border_1()\n        .rounded_lg()\n        .shadow_sm()\n        .p_6()\n        .child(\n            div()\n                .text_lg()\n                .font_semibold()\n                .mb_4()\n                .child(title)\n        )\n        .child(content)\n}\n```\n\n#### Conditional Rendering\n\n```rust\ndiv()\n    .when(condition, |this| {\n        this.bg(blue_500())\n    })\n    .when_some(optional_value, |this, value| {\n        this.child(format!(\"Value: {}\", value))\n    })\n    .map(|this| {\n        if complex_condition {\n            this.border_1()\n        } else {\n            this.border_2()\n        }\n    })\n```\n\n#### Dynamic Children\n\n```rust\ndiv()\n    .children(\n        items.iter().map(|item| {\n            div().child(item.name.as_str())\n        })\n    )\n```\n\n### View Lifecycle\n\n#### Initialization\n\n```rust\nimpl MyView {\n    fn new(cx: &mut ViewContext<Self>) -> Self {\n        // Initialize state\n        let model = cx.new_model(|_| MyState::default());\n\n        // Set up subscriptions\n        let subscription = cx.observe(&model, |_, _, cx| cx.notify());\n\n        // Spawn async tasks\n        cx.spawn(|this, mut cx| async move {\n            // Async initialization\n        }).detach();\n\n        Self {\n            model,\n            _subscription: subscription,\n        }\n    }\n}\n```\n\n#### Update Notifications\n\n```rust\nimpl MyView {\n    fn update_state(&mut self, new_data: Data, cx: &mut ViewContext<Self>) {\n        self.model.update(cx, |state, cx| {\n            state.data = new_data;\n            cx.notify();  // Trigger rerender\n        });\n    }\n}\n```\n\n#### Cleanup\n\n```rust\nimpl Drop for MyView {\n    fn drop(&mut self) {\n        // Manual cleanup if needed\n        // Subscriptions are automatically dropped\n    }\n}\n```\n\n### Reactive Patterns\n\n#### Derived State\n\n```rust\nimpl Render for MyView {\n    fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n        let state = self.model.read(cx);\n\n        // Compute derived values\n        let total = state.items.iter().map(|i| i.value).sum::<i32>();\n        let average = total / state.items.len() as i32;\n\n        div()\n            .child(format!(\"Total: {}\", total))\n            .child(format!(\"Average: {}\", average))\n    }\n}\n```\n\n#### Async Updates\n\n```rust\nimpl MyView {\n    fn load_data(&mut self, cx: &mut ViewContext<Self>) {\n        let model = self.model.clone();\n\n        cx.spawn(|_, mut cx| async move {\n            let data = fetch_data().await?;\n\n            cx.update_model(&model, |state, cx| {\n                state.data = data;\n                cx.notify();\n            })?;\n\n            Ok::<_, anyhow::Error>(())\n        }).detach();\n    }\n}\n```\n\n## Resources\n\n### Official Documentation\n- GPUI GitHub: https://github.com/zed-industries/zed/tree/main/crates/gpui\n- Zed Editor Source: Real-world GPUI examples\n\n### Common Patterns Reference\n- Model-View: State management pattern\n- Container-Presenter: Separation of concerns\n- Compound Components: Related components working together\n- Action System: Command pattern for user interactions\n- Subscriptions: Observer pattern for reactive updates\n\n### Best Practices\n- Store subscriptions to prevent cleanup\n- Use `cx.notify()` sparingly\n- Prefer composition over inheritance\n- Keep render methods pure\n- Handle errors gracefully\n- Document component APIs\n- Test component behavior"
              },
              {
                "name": "gpui-performance",
                "description": "Performance optimization techniques for GPUI including rendering optimization, layout performance, memory management, and profiling strategies. Use when user needs to optimize GPUI application performance or debug performance issues.",
                "path": "plugins/rust-gpui-developer/skills/gpui-performance/SKILL.md",
                "frontmatter": {
                  "name": "gpui-performance",
                  "description": "Performance optimization techniques for GPUI including rendering optimization, layout performance, memory management, and profiling strategies. Use when user needs to optimize GPUI application performance or debug performance issues."
                },
                "content": "# GPUI Performance Optimization\n\n## Metadata\n\nThis skill provides comprehensive guidance on optimizing GPUI applications for rendering performance, memory efficiency, and overall runtime speed.\n\n## Instructions\n\n### Rendering Optimization\n\n#### Understanding the Render Cycle\n\n```\nState Change → cx.notify() → Render → Layout → Paint → Display\n```\n\n**Key Points**:\n- Only call `cx.notify()` when state actually changes\n- Minimize work in `render()` method\n- Cache expensive computations\n- Reduce element count and nesting\n\n#### Avoiding Unnecessary Renders\n\n```rust\n// BAD: Renders on every frame\nimpl MyComponent {\n    fn start_animation(&mut self, cx: &mut ViewContext<Self>) {\n        cx.spawn(|this, mut cx| async move {\n            loop {\n                cx.update(|_, cx| cx.notify()).ok();  // Forces rerender!\n                Timer::after(Duration::from_millis(16)).await;\n            }\n        }).detach();\n    }\n}\n\n// GOOD: Only render when state changes\nimpl MyComponent {\n    fn update_value(&mut self, new_value: i32, cx: &mut ViewContext<Self>) {\n        if self.value != new_value {\n            self.value = new_value;\n            cx.notify();  // Only notify on actual change\n        }\n    }\n}\n```\n\n#### Optimize Subscription Updates\n\n```rust\n// BAD: Always rerenders on model change\nlet _subscription = cx.observe(&model, |_, _, cx| {\n    cx.notify();  // Rerenders even if nothing relevant changed\n});\n\n// GOOD: Selective updates\nlet _subscription = cx.observe(&model, |this, model, cx| {\n    let data = model.read(cx);\n\n    // Only rerender if relevant field changed\n    if data.relevant_field != this.cached_field {\n        this.cached_field = data.relevant_field.clone();\n        cx.notify();\n    }\n});\n```\n\n#### Memoization Pattern\n\n```rust\nuse std::cell::RefCell;\nuse std::collections::hash_map::DefaultHasher;\nuse std::hash::{Hash, Hasher};\n\nstruct MemoizedComponent {\n    model: Model<Data>,\n    cached_result: RefCell<Option<(u64, String)>>,  // (hash, result)\n}\n\nimpl MemoizedComponent {\n    fn expensive_computation(&self, cx: &ViewContext<Self>) -> String {\n        let data = self.model.read(cx);\n\n        // Calculate hash of input\n        let mut hasher = DefaultHasher::new();\n        data.relevant_fields.hash(&mut hasher);\n        let hash = hasher.finish();\n\n        // Return cached if unchanged\n        if let Some((cached_hash, cached_result)) = &*self.cached_result.borrow() {\n            if *cached_hash == hash {\n                return cached_result.clone();\n            }\n        }\n\n        // Compute and cache\n        let result = perform_expensive_computation(&data);\n        *self.cached_result.borrow_mut() = Some((hash, result.clone()));\n        result\n    }\n}\n```\n\n### Layout Performance\n\n#### Minimize Layout Complexity\n\n```rust\n// BAD: Deep nesting\ndiv()\n    .flex()\n    .child(\n        div()\n            .flex()\n            .child(\n                div()\n                    .flex()\n                    .child(\n                        div().child(\"Content\")\n                    )\n            )\n    )\n\n// GOOD: Flat structure\ndiv()\n    .flex()\n    .flex_col()\n    .gap_4()\n    .child(\"Header\")\n    .child(\"Content\")\n    .child(\"Footer\")\n```\n\n#### Use Fixed Sizing When Possible\n\n```rust\n// BETTER: Fixed sizes (no layout calculation)\ndiv()\n    .w(px(200.))\n    .h(px(100.))\n    .child(\"Fixed size\")\n\n// SLOWER: Dynamic sizing (requires layout calculation)\ndiv()\n    .w_full()\n    .h_full()\n    .child(\"Dynamic size\")\n```\n\n#### Avoid Layout Thrashing\n\n```rust\n// BAD: Reading layout during render\nimpl Render for BadComponent {\n    fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n        let width = cx.window_bounds().get_bounds().size.width;\n        // Using width immediately causes layout thrashing\n        div().w(width)\n    }\n}\n\n// GOOD: Cache layout-dependent values\nstruct GoodComponent {\n    cached_width: Pixels,\n}\n\nimpl GoodComponent {\n    fn on_window_resize(&mut self, cx: &mut ViewContext<Self>) {\n        let width = cx.window_bounds().get_bounds().size.width;\n        if self.cached_width != width {\n            self.cached_width = width;\n            cx.notify();\n        }\n    }\n}\n```\n\n#### Virtual Scrolling for Long Lists\n\n```rust\nstruct VirtualList {\n    items: Vec<String>,\n    scroll_offset: f32,\n    viewport_height: f32,\n    item_height: f32,\n}\n\nimpl Render for VirtualList {\n    fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n        // Calculate visible range\n        let start_index = (self.scroll_offset / self.item_height).floor() as usize;\n        let visible_count = (self.viewport_height / self.item_height).ceil() as usize;\n        let end_index = (start_index + visible_count).min(self.items.len());\n\n        // Only render visible items\n        div()\n            .h(px(self.viewport_height))\n            .overflow_y_scroll()\n            .on_scroll(cx.listener(|this, event, cx| {\n                this.scroll_offset = event.scroll_offset.y;\n                cx.notify();\n            }))\n            .child(\n                div()\n                    .h(px(self.items.len() as f32 * self.item_height))\n                    .child(\n                        div()\n                            .absolute()\n                            .top(px(start_index as f32 * self.item_height))\n                            .children(\n                                self.items[start_index..end_index]\n                                    .iter()\n                                    .map(|item| {\n                                        div()\n                                            .h(px(self.item_height))\n                                            .child(item.as_str())\n                                    })\n                            )\n                    )\n            )\n    }\n}\n```\n\n### Memory Management\n\n#### Preventing Memory Leaks\n\n```rust\n// LEAK: Subscription not stored\nimpl BadView {\n    fn new(model: Model<Data>, cx: &mut ViewContext<Self>) -> Self {\n        cx.observe(&model, |_, _, cx| cx.notify());  // Leak!\n        Self { model }\n    }\n}\n\n// CORRECT: Store subscription\nstruct GoodView {\n    model: Model<Data>,\n    _subscription: Subscription,  // Cleaned up on Drop\n}\n\nimpl GoodView {\n    fn new(model: Model<Data>, cx: &mut ViewContext<Self>) -> Self {\n        let _subscription = cx.observe(&model, |_, _, cx| cx.notify());\n        Self { model, _subscription }\n    }\n}\n```\n\n#### Avoid Circular References\n\n```rust\n// BAD: Circular reference\nstruct CircularRef {\n    self_view: Option<View<Self>>,  // Circular!\n}\n\n// GOOD: Use weak references or redesign\nstruct NoCycle {\n    other_view: View<OtherView>,  // No cycle\n}\n```\n\n#### Bounded Collections\n\n```rust\nuse std::collections::VecDeque;\n\nconst MAX_HISTORY: usize = 100;\n\nstruct BoundedHistory {\n    items: VecDeque<Item>,\n}\n\nimpl BoundedHistory {\n    fn add_item(&mut self, item: Item) {\n        self.items.push_back(item);\n\n        // Maintain size limit\n        while self.items.len() > MAX_HISTORY {\n            self.items.pop_front();\n        }\n    }\n}\n```\n\n#### Reuse Allocations\n\n```rust\nstruct BufferedComponent {\n    buffer: String,  // Reused across operations\n}\n\nimpl BufferedComponent {\n    fn format_data(&mut self, data: &[Item]) -> &str {\n        self.buffer.clear();  // Reuse allocation\n\n        for item in data {\n            use std::fmt::Write;\n            write!(&mut self.buffer, \"{}\\n\", item.name).ok();\n        }\n\n        &self.buffer\n    }\n}\n```\n\n### Profiling Strategies\n\n#### CPU Profiling with cargo-flamegraph\n\n```bash\n# Install\ncargo install flamegraph\n\n# Profile application\ncargo flamegraph --bin your-app\n\n# With specific features\ncargo flamegraph --bin your-app --features profiling\n\n# Opens flamegraph.svg showing CPU time distribution\n```\n\n#### Memory Profiling\n\n```bash\n# valgrind (Linux)\nvalgrind --tool=massif --massif-out-file=massif.out ./target/release/your-app\nms_print massif.out\n\n# heaptrack (Linux)\nheaptrack ./target/release/your-app\nheaptrack_gui heaptrack.your-app.*.gz\n\n# Instruments (macOS)\ninstruments -t \"Allocations\" ./target/release/your-app\n```\n\n#### Custom Performance Monitoring\n\n```rust\nuse std::time::Instant;\n\nstruct PerformanceMonitor {\n    frame_times: VecDeque<Duration>,\n    max_samples: usize,\n}\n\nimpl PerformanceMonitor {\n    fn new() -> Self {\n        Self {\n            frame_times: VecDeque::with_capacity(100),\n            max_samples: 100,\n        }\n    }\n\n    fn record_frame(&mut self, duration: Duration) {\n        self.frame_times.push_back(duration);\n\n        if self.frame_times.len() > self.max_samples {\n            self.frame_times.pop_front();\n        }\n\n        // Warn if frame is slow (> 16ms for 60fps)\n        if duration.as_millis() > 16 {\n            eprintln!(\"⚠️  Slow frame: {}ms\", duration.as_millis());\n        }\n    }\n\n    fn average_fps(&self) -> f64 {\n        if self.frame_times.is_empty() {\n            return 0.0;\n        }\n\n        let total: Duration = self.frame_times.iter().sum();\n        let avg = total / self.frame_times.len() as u32;\n        1000.0 / avg.as_millis() as f64\n    }\n\n    fn percentile(&self, p: f64) -> Duration {\n        let mut sorted: Vec<_> = self.frame_times.iter().copied().collect();\n        sorted.sort();\n\n        let index = (sorted.len() as f64 * p) as usize;\n        sorted[index.min(sorted.len() - 1)]\n    }\n}\n\n// Usage in component\nimpl MyView {\n    fn measure_render<F>(&mut self, f: F, cx: &mut ViewContext<Self>)\n    where\n        F: FnOnce(&mut Self, &mut ViewContext<Self>)\n    {\n        let start = Instant::now();\n        f(self, cx);\n        let elapsed = start.elapsed();\n\n        self.perf_monitor.record_frame(elapsed);\n\n        // Log stats periodically\n        if self.frame_count % 60 == 0 {\n            println!(\n                \"Avg FPS: {:.1}, p95: {}ms, p99: {}ms\",\n                self.perf_monitor.average_fps(),\n                self.perf_monitor.percentile(0.95).as_millis(),\n                self.perf_monitor.percentile(0.99).as_millis(),\n            );\n        }\n    }\n}\n```\n\n#### Benchmark with Criterion\n\n```rust\n// benches/component_bench.rs\nuse criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};\n\nfn render_benchmark(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"rendering\");\n\n    for size in [10, 100, 1000].iter() {\n        group.bench_with_input(\n            BenchmarkId::from_parameter(size),\n            size,\n            |b, &size| {\n                b.iter(|| {\n                    App::test(|cx| {\n                        let items = vec![Item::default(); size];\n                        let view = cx.new_view(|cx| {\n                            ListView::new(items, cx)\n                        });\n\n                        view.update(cx, |view, cx| {\n                            black_box(view.render(cx));\n                        });\n                    });\n                });\n            }\n        );\n    }\n\n    group.finish();\n}\n\ncriterion_group!(benches, render_benchmark);\ncriterion_main!(benches);\n```\n\n### Batching Updates\n\n```rust\n// BAD: Multiple individual updates\nfor item in items {\n    self.model.update(cx, |model, cx| {\n        model.add_item(item);  // Triggers rerender each time!\n        cx.notify();\n    });\n}\n\n// GOOD: Batch into single update\nself.model.update(cx, |model, cx| {\n    for item in items {\n        model.add_item(item);\n    }\n    cx.notify();  // Single rerender\n});\n```\n\n### Async Rendering Optimization\n\n```rust\nstruct AsyncView {\n    loading_state: Model<LoadingState>,\n}\n\nimpl AsyncView {\n    fn load_data(&mut self, cx: &mut ViewContext<Self>) {\n        let loading_state = self.loading_state.clone();\n\n        // Show loading immediately\n        self.loading_state.update(cx, |state, cx| {\n            *state = LoadingState::Loading;\n            cx.notify();\n        });\n\n        // Load asynchronously\n        cx.spawn(|_, mut cx| async move {\n            // Fetch data\n            let data = fetch_data().await?;\n\n            // Update state once\n            cx.update_model(&loading_state, |state, cx| {\n                *state = LoadingState::Loaded(data);\n                cx.notify();\n            })?;\n\n            Ok::<_, anyhow::Error>(())\n        }).detach();\n    }\n}\n```\n\n### Caching Strategies\n\n#### Result Caching\n\n```rust\nuse std::collections::HashMap;\n\nstruct CachedRenderer {\n    cache: RefCell<HashMap<String, CachedElement>>,\n}\n\nimpl CachedRenderer {\n    fn render_cached(\n        &self,\n        key: String,\n        render_fn: impl FnOnce() -> AnyElement,\n    ) -> AnyElement {\n        let mut cache = self.cache.borrow_mut();\n\n        cache.entry(key)\n            .or_insert_with(|| CachedElement::new(render_fn()))\n            .element\n            .clone()\n    }\n\n    fn invalidate(&self, key: &str) {\n        self.cache.borrow_mut().remove(key);\n    }\n}\n```\n\n## Resources\n\n### Performance Targets\n\n**Rendering**:\n- Target: 60 FPS (16.67ms per frame)\n- Render + Layout: ~10ms\n- Paint: ~6ms\n- Warning: Any frame > 16ms\n\n**Memory**:\n- Monitor heap growth\n- Warning: Steady increase (leak)\n- Target: Stable after initialization\n\n**Startup**:\n- Window display: < 100ms\n- Fully interactive: < 500ms\n\n### Profiling Tools\n\n**CPU Profiling**:\n- cargo-flamegraph: Visualize CPU time\n- perf (Linux): System-level profiling\n- Instruments (macOS): Apple's profiler\n\n**Memory Profiling**:\n- valgrind/massif: Memory usage tracking\n- heaptrack: Heap allocation tracking\n- Instruments: Memory allocations\n\n**Benchmarking**:\n- criterion: Statistical benchmarking\n- cargo bench: Built-in benchmarks\n- hyperfine: Command-line tool benchmarking\n\n### Best Practices\n\n1. **Measure First**: Profile before optimizing\n2. **Minimize Renders**: Only `cx.notify()` when necessary\n3. **Cache Results**: Memoize expensive computations\n4. **Batch Updates**: Group state changes\n5. **Virtual Scrolling**: For long lists\n6. **Flat Layouts**: Avoid deep nesting\n7. **Fixed Sizing**: When possible\n8. **Monitor Memory**: Watch for leaks\n9. **Async Loading**: Don't block UI\n10. **Test Performance**: Include benchmarks\n\n### Common Bottlenecks\n\n- Subscription in render (memory leak)\n- Expensive computation in render\n- Deep component nesting\n- Unnecessary rerenders\n- Layout thrashing\n- Large lists without virtualization\n- Memory leaks from circular refs\n- Unbounded collections"
              },
              {
                "name": "gpui-styling",
                "description": "GPUI styling system including theme design, responsive layouts, visual design patterns, and style composition. Use when user needs help with styling, theming, or visual design in GPUI.",
                "path": "plugins/rust-gpui-developer/skills/gpui-styling/SKILL.md",
                "frontmatter": {
                  "name": "gpui-styling",
                  "description": "GPUI styling system including theme design, responsive layouts, visual design patterns, and style composition. Use when user needs help with styling, theming, or visual design in GPUI."
                },
                "content": "# GPUI Styling\n\n## Metadata\n\nThis skill provides comprehensive guidance on GPUI's styling system, theme management, and visual design patterns for creating beautiful, consistent user interfaces.\n\n## Instructions\n\n### Styling API Fundamentals\n\n#### Basic Styling\n\n```rust\nuse gpui::*;\n\ndiv()\n    // Colors\n    .bg(rgb(0x2563eb))           // Background\n    .text_color(white())          // Text color\n    .border_color(rgb(0xe5e7eb)) // Border color\n\n    // Spacing\n    .p_4()                        // Padding: 1rem\n    .px_6()                       // Padding horizontal\n    .py_2()                       // Padding vertical\n    .m_4()                        // Margin\n    .gap_3()                      // Gap between children\n\n    // Sizing\n    .w_64()                       // Width: 16rem\n    .h_32()                       // Height: 8rem\n    .w_full()                     // Width: 100%\n    .h_full()                     // Height: 100%\n\n    // Borders\n    .border_1()                   // Border: 1px\n    .rounded_lg()                 // Border radius: large\n```\n\n#### Color Types\n\n```rust\n// RGB from hex\nlet blue = rgb(0x2563eb);\n\n// RGBA with alpha\nlet transparent_blue = rgba(0x2563eb, 0.5);\n\n// HSLA (hue, saturation, lightness, alpha)\nlet hsla_color = hsla(0.6, 0.8, 0.5, 1.0);\n\n// Named colors\nlet white = white();\nlet black = black();\n```\n\n#### Layout with Flexbox\n\n```rust\ndiv()\n    .flex()                      // Enable flexbox\n    .flex_row()                  // Horizontal layout\n    .flex_col()                  // Vertical layout\n    .items_center()              // Align items center\n    .justify_between()           // Space between\n    .gap_4()                     // Gap between items\n    .child(/* ... */)\n    .child(/* ... */)\n```\n\n### Theme System\n\n#### Basic Theme Structure\n\n```rust\nuse gpui::*;\n\n#[derive(Clone)]\npub struct AppTheme {\n    pub colors: ThemeColors,\n    pub typography: Typography,\n    pub spacing: Spacing,\n    pub shadows: Shadows,\n}\n\n#[derive(Clone)]\npub struct ThemeColors {\n    // Base colors\n    pub background: Hsla,\n    pub foreground: Hsla,\n\n    // UI colors\n    pub primary: Hsla,\n    pub primary_foreground: Hsla,\n    pub primary_hover: Hsla,\n\n    pub secondary: Hsla,\n    pub secondary_foreground: Hsla,\n    pub secondary_hover: Hsla,\n\n    pub accent: Hsla,\n    pub accent_foreground: Hsla,\n\n    pub destructive: Hsla,\n    pub destructive_foreground: Hsla,\n\n    // Neutral colors\n    pub muted: Hsla,\n    pub muted_foreground: Hsla,\n\n    pub border: Hsla,\n    pub input: Hsla,\n    pub ring: Hsla,\n}\n\n#[derive(Clone)]\npub struct Typography {\n    pub font_sans: Vec<String>,\n    pub font_mono: Vec<String>,\n\n    pub text_xs: Pixels,\n    pub text_sm: Pixels,\n    pub text_base: Pixels,\n    pub text_lg: Pixels,\n    pub text_xl: Pixels,\n    pub text_2xl: Pixels,\n}\n\n#[derive(Clone)]\npub struct Spacing {\n    pub xs: Pixels,\n    pub sm: Pixels,\n    pub md: Pixels,\n    pub lg: Pixels,\n    pub xl: Pixels,\n}\n```\n\n#### Light Theme Implementation\n\n```rust\nimpl AppTheme {\n    pub fn light() -> Self {\n        Self {\n            colors: ThemeColors {\n                background: rgb(0xffffff),\n                foreground: rgb(0x0a0a0a),\n\n                primary: rgb(0x2563eb),\n                primary_foreground: rgb(0xffffff),\n                primary_hover: rgb(0x1d4ed8),\n\n                secondary: rgb(0xf1f5f9),\n                secondary_foreground: rgb(0x0f172a),\n                secondary_hover: rgb(0xe2e8f0),\n\n                accent: rgb(0xf1f5f9),\n                accent_foreground: rgb(0x0f172a),\n\n                destructive: rgb(0xef4444),\n                destructive_foreground: rgb(0xffffff),\n\n                muted: rgb(0xf1f5f9),\n                muted_foreground: rgb(0x64748b),\n\n                border: rgb(0xe2e8f0),\n                input: rgb(0xe2e8f0),\n                ring: rgb(0x2563eb),\n            },\n            typography: Typography {\n                font_sans: vec![\n                    \"Inter\".to_string(),\n                    \"system-ui\".to_string(),\n                    \"sans-serif\".to_string(),\n                ],\n                font_mono: vec![\n                    \"JetBrains Mono\".to_string(),\n                    \"monospace\".to_string(),\n                ],\n                text_xs: px(12.0),\n                text_sm: px(14.0),\n                text_base: px(16.0),\n                text_lg: px(18.0),\n                text_xl: px(20.0),\n                text_2xl: px(24.0),\n            },\n            spacing: Spacing {\n                xs: px(4.0),\n                sm: px(8.0),\n                md: px(16.0),\n                lg: px(24.0),\n                xl: px(32.0),\n            },\n            shadows: Shadows {\n                sm: Shadow::new(px(1.0), rgba(0x000000, 0.05)),\n                md: Shadow::new(px(4.0), rgba(0x000000, 0.1)),\n                lg: Shadow::new(px(8.0), rgba(0x000000, 0.15)),\n            },\n        }\n    }\n}\n```\n\n#### Dark Theme Implementation\n\n```rust\nimpl AppTheme {\n    pub fn dark() -> Self {\n        Self {\n            colors: ThemeColors {\n                background: rgb(0x0a0a0a),\n                foreground: rgb(0xfafafa),\n\n                primary: rgb(0x3b82f6),\n                primary_foreground: rgb(0xffffff),\n                primary_hover: rgb(0x2563eb),\n\n                secondary: rgb(0x1e293b),\n                secondary_foreground: rgb(0xf1f5f9),\n                secondary_hover: rgb(0x334155),\n\n                accent: rgb(0x1e293b),\n                accent_foreground: rgb(0xf1f5f9),\n\n                destructive: rgb(0xef4444),\n                destructive_foreground: rgb(0xffffff),\n\n                muted: rgb(0x1e293b),\n                muted_foreground: rgb(0x94a3b8),\n\n                border: rgb(0x334155),\n                input: rgb(0x334155),\n                ring: rgb(0x3b82f6),\n            },\n            typography: Typography {\n                font_sans: vec![\n                    \"Inter\".to_string(),\n                    \"system-ui\".to_string(),\n                    \"sans-serif\".to_string(),\n                ],\n                font_mono: vec![\n                    \"JetBrains Mono\".to_string(),\n                    \"monospace\".to_string(),\n                ],\n                text_xs: px(12.0),\n                text_sm: px(14.0),\n                text_base: px(16.0),\n                text_lg: px(18.0),\n                text_xl: px(20.0),\n                text_2xl: px(24.0),\n            },\n            spacing: Spacing {\n                xs: px(4.0),\n                sm: px(8.0),\n                md: px(16.0),\n                lg: px(24.0),\n                xl: px(32.0),\n            },\n            shadows: Shadows {\n                sm: Shadow::new(px(1.0), rgba(0x000000, 0.2)),\n                md: Shadow::new(px(4.0), rgba(0x000000, 0.3)),\n                lg: Shadow::new(px(8.0), rgba(0x000000, 0.4)),\n            },\n        }\n    }\n}\n```\n\n#### Using Themes in Components\n\n```rust\nimpl Render for ThemedComponent {\n    fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n        let theme = cx.global::<AppTheme>();\n\n        div()\n            .bg(theme.colors.background)\n            .text_color(theme.colors.foreground)\n            .p(theme.spacing.md)\n            .border_1()\n            .border_color(theme.colors.border)\n            .child(\"Themed content\")\n    }\n}\n```\n\n#### Theme Switching\n\n```rust\npub fn toggle_theme(cx: &mut AppContext) {\n    let current = cx.global::<AppTheme>().clone();\n\n    let new_theme = match current.mode {\n        ThemeMode::Light => AppTheme::dark(),\n        ThemeMode::Dark => AppTheme::light(),\n    };\n\n    cx.set_global(new_theme);\n    cx.refresh();\n}\n```\n\n### Responsive Design\n\n#### Window Size Detection\n\n```rust\nimpl Render for ResponsiveView {\n    fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n        let window_size = cx.window_bounds().get_bounds().size;\n        let is_mobile = window_size.width < px(768.0);\n        let is_tablet = window_size.width >= px(768.0) && window_size.width < px(1024.0);\n        let is_desktop = window_size.width >= px(1024.0);\n\n        div()\n            .flex()\n            .when(is_mobile, |this| {\n                this.flex_col().gap_2()\n            })\n            .when(is_desktop, |this| {\n                this.flex_row().gap_6()\n            })\n            .child(sidebar())\n            .child(main_content())\n    }\n}\n```\n\n#### Breakpoint-Based Styling\n\n```rust\npub struct Breakpoints;\n\nimpl Breakpoints {\n    pub const SM: f32 = 640.0;\n    pub const MD: f32 = 768.0;\n    pub const LG: f32 = 1024.0;\n    pub const XL: f32 = 1280.0;\n    pub const XXL: f32 = 1536.0;\n}\n\nfn responsive_grid(width: Pixels) -> impl IntoElement {\n    div()\n        .grid()\n        .when(width.0 < Breakpoints::SM, |this| this.grid_cols_1())\n        .when(width.0 >= Breakpoints::SM && width.0 < Breakpoints::LG, |this| {\n            this.grid_cols_2()\n        })\n        .when(width.0 >= Breakpoints::LG, |this| this.grid_cols_3())\n        .gap_4()\n}\n```\n\n### Visual Design Patterns\n\n#### Card Component\n\n```rust\npub fn card(\n    title: impl Into<String>,\n    description: impl Into<String>,\n    content: impl IntoElement,\n) -> impl IntoElement {\n    let theme = cx.global::<AppTheme>();\n\n    div()\n        .bg(theme.colors.background)\n        .border_1()\n        .border_color(theme.colors.border)\n        .rounded_lg()\n        .shadow_sm()\n        .overflow_hidden()\n        .child(\n            div()\n                .p_6()\n                .border_b_1()\n                .border_color(theme.colors.border)\n                .child(\n                    div()\n                        .text_lg()\n                        .font_semibold()\n                        .child(title.into())\n                )\n                .child(\n                    div()\n                        .text_sm()\n                        .text_color(theme.colors.muted_foreground)\n                        .child(description.into())\n                )\n        )\n        .child(\n            div()\n                .p_6()\n                .child(content)\n        )\n}\n```\n\n#### Button Variants\n\n```rust\npub enum ButtonVariant {\n    Primary,\n    Secondary,\n    Outline,\n    Ghost,\n    Destructive,\n}\n\npub fn button(\n    label: &str,\n    variant: ButtonVariant,\n) -> impl IntoElement {\n    let theme = cx.global::<AppTheme>();\n\n    let (bg, fg, hover_bg) = match variant {\n        ButtonVariant::Primary => (\n            theme.colors.primary,\n            theme.colors.primary_foreground,\n            theme.colors.primary_hover,\n        ),\n        ButtonVariant::Secondary => (\n            theme.colors.secondary,\n            theme.colors.secondary_foreground,\n            theme.colors.secondary_hover,\n        ),\n        ButtonVariant::Outline => (\n            hsla(0.0, 0.0, 0.0, 0.0),\n            theme.colors.foreground,\n            theme.colors.accent,\n        ),\n        ButtonVariant::Ghost => (\n            hsla(0.0, 0.0, 0.0, 0.0),\n            theme.colors.foreground,\n            theme.colors.accent,\n        ),\n        ButtonVariant::Destructive => (\n            theme.colors.destructive,\n            theme.colors.destructive_foreground,\n            theme.colors.destructive,\n        ),\n    };\n\n    div()\n        .px_4()\n        .py_2()\n        .bg(bg)\n        .text_color(fg)\n        .rounded_md()\n        .font_medium()\n        .cursor_pointer()\n        .when(matches!(variant, ButtonVariant::Outline), |this| {\n            this.border_1().border_color(theme.colors.border)\n        })\n        .hover(|this| this.bg(hover_bg))\n        .transition_colors()\n        .duration_150()\n        .child(label)\n}\n```\n\n#### Input Fields\n\n```rust\npub fn text_input(\n    value: &str,\n    placeholder: &str,\n) -> impl IntoElement {\n    let theme = cx.global::<AppTheme>();\n\n    div()\n        .flex()\n        .items_center()\n        .w_full()\n        .px_3()\n        .py_2()\n        .bg(theme.colors.background)\n        .border_1()\n        .border_color(theme.colors.input)\n        .rounded_md()\n        .text_color(theme.colors.foreground)\n        .focus(|this| {\n            this.border_color(theme.colors.ring)\n                .ring_2()\n                .ring_color(rgba(theme.colors.ring, 0.2))\n        })\n        .child(\n            input()\n                .w_full()\n                .bg(hsla(0.0, 0.0, 0.0, 0.0))\n                .placeholder(placeholder)\n                .value(value)\n        )\n}\n```\n\n### Style Composition\n\n#### Reusable Style Functions\n\n```rust\npub fn focus_ring(theme: &AppTheme) -> StyleRefinement {\n    StyleRefinement::default()\n        .ring_2()\n        .ring_color(rgba(theme.colors.ring, 0.2))\n        .border_color(theme.colors.ring)\n}\n\npub fn shadow_sm(theme: &AppTheme) -> StyleRefinement {\n    StyleRefinement::default()\n        .shadow(theme.shadows.sm)\n}\n\n// Usage\ndiv()\n    .apply(focus_ring(&theme))\n    .apply(shadow_sm(&theme))\n    .child(\"Styled element\")\n```\n\n#### Conditional Styles\n\n```rust\nfn dynamic_button(\n    label: &str,\n    is_loading: bool,\n    is_disabled: bool,\n) -> impl IntoElement {\n    let theme = cx.global::<AppTheme>();\n\n    div()\n        .px_4()\n        .py_2()\n        .bg(theme.colors.primary)\n        .text_color(theme.colors.primary_foreground)\n        .rounded_md()\n        .when(is_disabled || is_loading, |this| {\n            this.opacity(0.5).cursor_not_allowed()\n        })\n        .when(!is_disabled && !is_loading, |this| {\n            this.cursor_pointer()\n                .hover(|this| this.bg(theme.colors.primary_hover))\n        })\n        .child(\n            if is_loading {\n                \"Loading...\"\n            } else {\n                label\n            }\n        )\n}\n```\n\n### Animation and Transitions\n\n#### Hover Transitions\n\n```rust\ndiv()\n    .transition_all()           // Transition all properties\n    .duration_200()             // 200ms duration\n    .bg(blue_500())\n    .hover(|this| {\n        this.bg(blue_600())\n            .scale_105()        // Scale to 105%\n    })\n    .child(\"Hover me\")\n```\n\n#### Transform Animations\n\n```rust\ndiv()\n    .transition_transform()\n    .duration_300()\n    .ease_in_out()\n    .hover(|this| {\n        this.rotate(5.0)        // Rotate 5 degrees\n            .translate_y(px(-2.0))  // Move up 2px\n    })\n    .child(\"Animated element\")\n```\n\n## Resources\n\n### Color Systems\n- Use HSL for color manipulation\n- Maintain consistent color contrast ratios\n- Define semantic color names (primary, secondary, etc.)\n- Support both light and dark themes\n\n### Typography Scale\n- Base: 16px (1rem)\n- Scale: 1.125 (Major Second) or 1.2 (Minor Third)\n- Sizes: xs, sm, base, lg, xl, 2xl, etc.\n- Weights: normal, medium, semibold, bold\n\n### Spacing Scale\n- Base unit: 4px or 8px\n- Multipliers: 0.5, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32\n- Consistent throughout application\n- Used for padding, margin, gap\n\n### Best Practices\n- Define theme at app level\n- Use semantic color names\n- Implement both light and dark themes\n- Support responsive design\n- Maintain consistent spacing\n- Use transitions for smooth interactions\n- Ensure accessibility (contrast, focus indicators)\n- Document theme structure"
              },
              {
                "name": "rust-ui-architecture",
                "description": "Architecture patterns for Rust UI applications including GPUI-specific patterns, code organization, modularity, and scalability. Use when user needs guidance on application architecture, code organization, or scaling UI applications.",
                "path": "plugins/rust-gpui-developer/skills/rust-ui-architecture/SKILL.md",
                "frontmatter": {
                  "name": "rust-ui-architecture",
                  "description": "Architecture patterns for Rust UI applications including GPUI-specific patterns, code organization, modularity, and scalability. Use when user needs guidance on application architecture, code organization, or scaling UI applications."
                },
                "content": "# Rust UI Architecture\n\n## Metadata\n\nThis skill provides comprehensive guidance on architecting scalable, maintainable Rust UI applications using GPUI, covering project structure, design patterns, and best practices.\n\n## Instructions\n\n### Application Structure\n\n#### Recommended Project Layout\n\n```\nmy-gpui-app/\n├── Cargo.toml\n├── src/\n│   ├── main.rs                 # Application entry point\n│   ├── app.rs                  # Main application struct\n│   ├── ui/                     # UI layer\n│   │   ├── mod.rs\n│   │   ├── views/              # High-level views\n│   │   │   ├── mod.rs\n│   │   │   ├── main_view.rs\n│   │   │   ├── sidebar.rs\n│   │   │   └── editor.rs\n│   │   ├── components/         # Reusable components\n│   │   │   ├── mod.rs\n│   │   │   ├── button.rs\n│   │   │   ├── input.rs\n│   │   │   └── modal.rs\n│   │   └── theme.rs           # Theme definitions\n│   ├── models/                 # Application state\n│   │   ├── mod.rs\n│   │   ├── document.rs\n│   │   ├── project.rs\n│   │   └── settings.rs\n│   ├── services/              # External integrations\n│   │   ├── mod.rs\n│   │   ├── file_service.rs\n│   │   └── api_client.rs\n│   ├── domain/                # Core business logic\n│   │   ├── mod.rs\n│   │   └── operations.rs\n│   └── utils/                 # Utilities\n│       ├── mod.rs\n│       └── helpers.rs\n├── examples/                   # Example applications\n│   └── basic.rs\n└── tests/                     # Integration tests\n    ├── integration/\n    └── ui/\n```\n\n### Layer Separation\n\n#### Four-Layer Architecture\n\n```\n┌─────────────────────────────────┐\n│     UI Layer (Views)            │  - GPUI views and components\n│                                 │  - User interactions\n│                                 │  - Render logic\n├─────────────────────────────────┤\n│   Application Layer (Models)    │  - Application state (Model<T>)\n│                                 │  - State coordination\n│                                 │  - Business logic orchestration\n├─────────────────────────────────┤\n│    Service Layer (Services)     │  - File I/O\n│                                 │  - Network requests\n│                                 │  - External APIs\n├─────────────────────────────────┤\n│     Domain Layer (Core)         │  - Pure business logic\n│                                 │  - Domain types\n│                                 │  - No dependencies on UI/GPUI\n└─────────────────────────────────┘\n```\n\n#### Example Implementation\n\n```rust\n// Domain Layer (pure logic)\npub mod domain {\n    #[derive(Clone, Debug)]\n    pub struct Document {\n        pub id: DocumentId,\n        pub content: String,\n        pub language: Language,\n    }\n\n    impl Document {\n        pub fn word_count(&self) -> usize {\n            self.content.split_whitespace().count()\n        }\n\n        pub fn is_empty(&self) -> bool {\n            self.content.trim().is_empty()\n        }\n    }\n}\n\n// Service Layer (external integration)\npub mod services {\n    use super::domain::*;\n\n    pub trait FileService: Send + Sync {\n        fn read(&self, path: &Path) -> Result<String>;\n        fn write(&self, path: &Path, content: &str) -> Result<()>;\n    }\n\n    pub struct RealFileService;\n\n    impl FileService for RealFileService {\n        fn read(&self, path: &Path) -> Result<String> {\n            std::fs::read_to_string(path)\n                .map_err(|e| anyhow::anyhow!(\"Failed to read: {}\", e))\n        }\n\n        fn write(&self, path: &Path, content: &str) -> Result<()> {\n            std::fs::write(path, content)\n                .map_err(|e| anyhow::anyhow!(\"Failed to write: {}\", e))\n        }\n    }\n}\n\n// Application Layer (state management)\npub mod models {\n    use super::domain::*;\n    use super::services::*;\n\n    pub struct DocumentModel {\n        document: Document,\n        file_service: Arc<dyn FileService>,\n        is_modified: bool,\n    }\n\n    impl DocumentModel {\n        pub fn new(document: Document, file_service: Arc<dyn FileService>) -> Self {\n            Self {\n                document,\n                file_service,\n                is_modified: false,\n            }\n        }\n\n        pub fn update_content(&mut self, content: String) {\n            self.document.content = content;\n            self.is_modified = true;\n        }\n\n        pub async fn save(&mut self) -> Result<()> {\n            self.file_service.write(&self.document.path, &self.document.content)?;\n            self.is_modified = false;\n            Ok(())\n        }\n    }\n}\n\n// UI Layer (views)\npub mod ui {\n    use gpui::*;\n    use super::models::*;\n\n    pub struct DocumentView {\n        model: Model<DocumentModel>,\n        _subscription: Subscription,\n    }\n\n    impl DocumentView {\n        pub fn new(model: Model<DocumentModel>, cx: &mut ViewContext<Self>) -> Self {\n            let _subscription = cx.observe(&model, |_, _, cx| cx.notify());\n            Self { model, _subscription }\n        }\n    }\n\n    impl Render for DocumentView {\n        fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n            let model = self.model.read(cx);\n\n            div()\n                .child(format!(\"Words: {}\", model.document.word_count()))\n                .when(model.is_modified, |this| {\n                    this.child(\"(modified)\")\n                })\n        }\n    }\n}\n```\n\n### Component Hierarchies\n\n#### Container-Presenter Pattern\n\n```rust\n// Container: Manages state and logic\npub struct EditorContainer {\n    document: Model<DocumentModel>,\n    _subscription: Subscription,\n}\n\nimpl EditorContainer {\n    pub fn new(document: Model<DocumentModel>, cx: &mut ViewContext<Self>) -> Self {\n        let _subscription = cx.observe(&document, |_, _, cx| cx.notify());\n        Self { document, _subscription }\n    }\n\n    fn handle_save(&mut self, cx: &mut ViewContext<Self>) {\n        let document = self.document.clone();\n\n        cx.spawn(|_, mut cx| async move {\n            cx.update_model(&document, |doc, _| {\n                doc.save().await\n            }).await?;\n\n            Ok::<_, anyhow::Error>(())\n        }).detach();\n    }\n}\n\nimpl Render for EditorContainer {\n    fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n        let doc = self.document.read(cx);\n\n        EditorPresenter::new(\n            doc.document.content.clone(),\n            doc.is_modified,\n            cx.listener(|this, content, cx| {\n                this.document.update(cx, |doc, _| {\n                    doc.update_content(content);\n                });\n            }),\n        )\n    }\n}\n\n// Presenter: Pure rendering\npub struct EditorPresenter {\n    content: String,\n    is_modified: bool,\n    on_change: Box<dyn Fn(String, &mut WindowContext)>,\n}\n\nimpl EditorPresenter {\n    pub fn new(\n        content: String,\n        is_modified: bool,\n        on_change: impl Fn(String, &mut WindowContext) + 'static,\n    ) -> Self {\n        Self {\n            content,\n            is_modified,\n            on_change: Box::new(on_change),\n        }\n    }\n}\n\nimpl Render for EditorPresenter {\n    fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n        div()\n            .flex()\n            .flex_col()\n            .child(\n                textarea()\n                    .value(&self.content)\n                    .on_input(|value, cx| {\n                        (self.on_change)(value, cx);\n                    })\n            )\n            .when(self.is_modified, |this| {\n                this.child(\"Unsaved changes\")\n            })\n    }\n}\n```\n\n### Module Organization\n\n#### Feature-Based Structure\n\n```\nsrc/\n├── features/\n│   ├── editor/\n│   │   ├── mod.rs\n│   │   ├── model.rs          # EditorModel\n│   │   ├── view.rs           # EditorView\n│   │   ├── commands.rs       # Editor actions\n│   │   └── components/       # Editor-specific components\n│   ├── sidebar/\n│   │   ├── mod.rs\n│   │   ├── model.rs\n│   │   ├── view.rs\n│   │   └── components/\n│   └── statusbar/\n│       ├── mod.rs\n│       ├── model.rs\n│       └── view.rs\n```\n\n**Benefits**:\n- Clear feature boundaries\n- Easy to understand and navigate\n- Scales well with team size\n- Enables feature-based development\n\n### State Management Architecture\n\n#### Unidirectional Data Flow\n\n```\nUser Action → Action Dispatch → State Update → View Rerender\n     ↑                                              ↓\n     └──────────────── Event Handlers ─────────────┘\n```\n\n**Implementation**:\n\n```rust\n// Define actions\nactions!(app, [AddTodo, ToggleTodo, DeleteTodo]);\n\n// State model\npub struct TodoListModel {\n    todos: Vec<Todo>,\n}\n\nimpl TodoListModel {\n    pub fn add_todo(&mut self, text: String) {\n        self.todos.push(Todo {\n            id: TodoId::new(),\n            text,\n            completed: false,\n        });\n    }\n\n    pub fn toggle_todo(&mut self, id: TodoId) {\n        if let Some(todo) = self.todos.iter_mut().find(|t| t.id == id) {\n            todo.completed = !todo.completed;\n        }\n    }\n}\n\n// View with action handlers\npub struct TodoListView {\n    model: Model<TodoListModel>,\n}\n\nimpl TodoListView {\n    fn register_actions(&mut self, cx: &mut ViewContext<Self>) {\n        cx.on_action(cx.listener(|this, action: &AddTodo, cx| {\n            this.model.update(cx, |model, cx| {\n                model.add_todo(action.text.clone());\n                cx.notify();\n            });\n        }));\n\n        cx.on_action(cx.listener(|this, action: &ToggleTodo, cx| {\n            this.model.update(cx, |model, cx| {\n                model.toggle_todo(action.id);\n                cx.notify();\n            });\n        }));\n    }\n}\n```\n\n#### State Ownership Patterns\n\n**Single Source of Truth**:\n```rust\npub struct AppModel {\n    // Root owns all state\n    documents: Vec<Model<DocumentModel>>,\n    settings: Model<Settings>,\n    ui_state: Model<UiState>,\n}\n```\n\n**Hierarchical Ownership**:\n```rust\npub struct WorkspaceModel {\n    // Workspace owns workspace-level state\n    panes: Vec<Model<PaneModel>>,\n}\n\npub struct PaneModel {\n    // Pane owns pane-level state\n    tabs: Vec<Model<TabModel>>,\n    active_index: usize,\n}\n```\n\n### Separation of Concerns\n\n#### Clear Boundaries\n\n```rust\n// ✓ GOOD: Clear responsibilities\n\n// Domain logic (no GPUI)\npub mod document {\n    pub struct Document {\n        content: String,\n    }\n\n    impl Document {\n        pub fn insert(&mut self, pos: usize, text: &str) {\n            self.content.insert_str(pos, text);\n        }\n    }\n}\n\n// Application logic (uses GPUI models)\npub mod editor_model {\n    use gpui::*;\n    use super::document::Document;\n\n    pub struct EditorModel {\n        document: Document,\n        cursor_position: usize,\n    }\n\n    impl EditorModel {\n        pub fn insert_at_cursor(&mut self, text: &str) {\n            self.document.insert(self.cursor_position, text);\n            self.cursor_position += text.len();\n        }\n    }\n}\n\n// UI logic (GPUI views)\npub mod editor_view {\n    use gpui::*;\n    use super::editor_model::EditorModel;\n\n    pub struct EditorView {\n        model: Model<EditorModel>,\n    }\n\n    impl Render for EditorView {\n        fn render(&mut self, cx: &mut ViewContext<Self>) -> impl IntoElement {\n            // Rendering logic\n        }\n    }\n}\n```\n\n### Testability Patterns\n\n#### Dependency Injection\n\n```rust\n// Define trait for external dependencies\npub trait FileService: Send + Sync {\n    fn read(&self, path: &Path) -> Result<String>;\n    fn write(&self, path: &Path, content: &str) -> Result<()>;\n}\n\n// Production implementation\npub struct RealFileService;\n\nimpl FileService for RealFileService {\n    // Real implementation\n}\n\n// Test implementation\n#[cfg(test)]\npub struct MockFileService {\n    read_results: HashMap<PathBuf, Result<String>>,\n    written_files: RefCell<Vec<(PathBuf, String)>>,\n}\n\n#[cfg(test)]\nimpl FileService for MockFileService {\n    fn read(&self, path: &Path) -> Result<String> {\n        self.read_results\n            .get(path)\n            .cloned()\n            .unwrap_or_else(|| Err(anyhow::anyhow!(\"File not found\")))\n    }\n\n    fn write(&self, path: &Path, content: &str) -> Result<()> {\n        self.written_files\n            .borrow_mut()\n            .push((path.to_path_buf(), content.to_string()));\n        Ok(())\n    }\n}\n\n// Model accepts any FileService\npub struct DocumentModel {\n    file_service: Arc<dyn FileService>,\n}\n\n// Tests use mock\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_save() {\n        let mock_service = Arc::new(MockFileService::new());\n        let model = DocumentModel::new(mock_service.clone());\n\n        model.save().unwrap();\n\n        assert_eq!(mock_service.written_files.borrow().len(), 1);\n    }\n}\n```\n\n### Plugin Architecture\n\n#### Extension System\n\n```rust\n// Define plugin trait\npub trait EditorPlugin: Send + Sync {\n    fn name(&self) -> &str;\n    fn on_document_open(&self, doc: &Document) -> Result<()>;\n    fn on_document_save(&self, doc: &Document) -> Result<()>;\n}\n\n// Plugin manager\npub struct PluginManager {\n    plugins: Vec<Box<dyn EditorPlugin>>,\n}\n\nimpl PluginManager {\n    pub fn register(&mut self, plugin: Box<dyn EditorPlugin>) {\n        self.plugins.push(plugin);\n    }\n\n    pub fn notify_document_open(&self, doc: &Document) -> Result<()> {\n        for plugin in &self.plugins {\n            plugin.on_document_open(doc)?;\n        }\n        Ok(())\n    }\n}\n\n// Example plugin\npub struct AutoSavePlugin {\n    interval: Duration,\n}\n\nimpl EditorPlugin for AutoSavePlugin {\n    fn name(&self) -> &str {\n        \"AutoSave\"\n    }\n\n    fn on_document_open(&self, doc: &Document) -> Result<()> {\n        // Start auto-save timer\n        Ok(())\n    }\n\n    fn on_document_save(&self, doc: &Document) -> Result<()> {\n        println!(\"Document saved: {}\", doc.path.display());\n        Ok(())\n    }\n}\n```\n\n## Resources\n\n### Design Patterns\n\n**Architectural Patterns**:\n- Model-View pattern (GPUI-specific)\n- Container-Presenter (separation of concerns)\n- Service-oriented (external dependencies)\n- Plugin architecture (extensibility)\n\n**Code Organization**:\n- Feature-based modules\n- Layer separation\n- Clear boundaries\n- Dependency injection\n\n**State Management**:\n- Unidirectional data flow\n- Single source of truth\n- Hierarchical ownership\n- Reactive updates\n\n### Best Practices\n\n1. **Separation of Concerns**: Keep UI, logic, and data separate\n2. **Dependency Injection**: Use traits for testability\n3. **Feature Organization**: Group related code by feature\n4. **State Ownership**: Clear ownership hierarchy\n5. **Testable Design**: Design for testing from the start\n6. **Documentation**: Document architecture decisions\n7. **Modularity**: Small, focused modules\n8. **Scalability**: Design for growth\n\n### Common Patterns\n\n- **Repository Pattern**: Data access abstraction\n- **Command Pattern**: Action system\n- **Observer Pattern**: Subscriptions\n- **Factory Pattern**: Component creation\n- **Strategy Pattern**: Pluggable behaviors\n- **Facade Pattern**: Simplified interfaces"
              }
            ]
          },
          {
            "name": "rust-tokio-expert",
            "description": "Experienced Rust developer with expertise in building reliable network applications using the Tokio library and its associated stack",
            "source": "./plugins/rust-tokio-expert",
            "category": "languages",
            "version": "1.0.0",
            "author": {
              "name": "Geoff Johnson",
              "url": "https://github.com/geoffjay"
            },
            "install_commands": [
              "/plugin marketplace add geoffjay/claude-plugins",
              "/plugin install rust-tokio-expert@geoffjay-claude-plugins"
            ],
            "signals": {
              "stars": 4,
              "forks": 1,
              "pushed_at": "2025-11-04T20:23:37Z",
              "created_at": "2025-10-17T18:24:21Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/tokio-migrate",
                "description": "Migrate synchronous code to async Tokio or upgrade between Tokio versions",
                "path": "plugins/rust-tokio-expert/commands/tokio-migrate.md",
                "frontmatter": {
                  "name": "tokio-migrate",
                  "description": "Migrate synchronous code to async Tokio or upgrade between Tokio versions"
                },
                "content": "# Tokio Migrate Command\n\nThis command assists with migrating synchronous code to async Tokio, upgrading between Tokio versions, or converting from other async runtimes.\n\n## Arguments\n\n- `$1` - Migration type: `sync-to-async`, `tokio-upgrade`, `runtime-switch` (required)\n- `$2` - Target file or directory (optional, defaults to current directory)\n- `$3` - Additional context: Tokio version for upgrades, or source runtime for switches (optional)\n\n## Usage\n\n```\n/rust-tokio-expert:tokio-migrate sync-to-async src/handlers/\n/rust-tokio-expert:tokio-migrate tokio-upgrade src/ 1.0\n/rust-tokio-expert:tokio-migrate runtime-switch src/ async-std\n```\n\n## Workflow\n\n### 1. Sync to Async Migration\n\nWhen migrating synchronous code to async Tokio:\n\n#### Analysis Phase\n\n1. **Scan Target Files**\n   - Use Glob to find all Rust files in target\n   - Read files and identify synchronous operations\n   - Detect blocking I/O operations\n   - Find CPU-intensive operations\n   - Identify thread spawning\n\n2. **Identify Conversion Candidates**\n   - Functions with I/O operations (network, file, database)\n   - Functions that spawn threads\n   - Functions with sleep/delays\n   - Functions with synchronous HTTP clients\n   - Functions with blocking mutex operations\n\n3. **Analyze Dependencies**\n   - Check `Cargo.toml` for sync crates\n   - Identify replacements (e.g., `reqwest` blocking → async)\n   - Find database drivers needing async versions\n\n#### Migration Phase\n\n4. **Invoke Agent**\n   - Use Task tool with `subagent_type=\"rust-tokio-expert:tokio-pro\"`\n   - Provide code context and migration plan\n\n5. **Convert Functions to Async**\n\n   The agent should transform:\n\n   **Synchronous Function:**\n   ```rust\n   use std::fs::File;\n   use std::io::Read;\n\n   fn read_config(path: &str) -> Result<String, Error> {\n       let mut file = File::open(path)?;\n       let mut contents = String::new();\n       file.read_to_string(&mut contents)?;\n       Ok(contents)\n   }\n   ```\n\n   **To Async:**\n   ```rust\n   use tokio::fs::File;\n   use tokio::io::AsyncReadExt;\n\n   async fn read_config(path: &str) -> Result<String, Error> {\n       let mut file = File::open(path).await?;\n       let mut contents = String::new();\n       file.read_to_string(&mut contents).await?;\n       Ok(contents)\n   }\n   ```\n\n6. **Replace Blocking Operations**\n\n   Convert common patterns:\n\n   **Thread Sleep → Async Sleep:**\n   ```rust\n   // Before\n   use std::thread;\n   use std::time::Duration;\n\n   fn wait() {\n       thread::sleep(Duration::from_secs(1));\n   }\n\n   // After\n   use tokio::time::{sleep, Duration};\n\n   async fn wait() {\n       sleep(Duration::from_secs(1)).await;\n   }\n   ```\n\n   **Std Mutex → Tokio Mutex:**\n   ```rust\n   // Before\n   use std::sync::Mutex;\n\n   fn update_state(mutex: &Mutex<State>) {\n       let mut state = mutex.lock().unwrap();\n       state.update();\n   }\n\n   // After\n   use tokio::sync::Mutex;\n\n   async fn update_state(mutex: &Mutex<State>) {\n       let mut state = mutex.lock().await;\n       state.update();\n   }\n   ```\n\n   **Thread Spawning → Task Spawning:**\n   ```rust\n   // Before\n   use std::thread;\n\n   fn spawn_worker() {\n       thread::spawn(|| {\n           do_work();\n       });\n   }\n\n   // After\n   use tokio::task;\n\n   async fn spawn_worker() {\n       task::spawn(async {\n           do_work().await;\n       });\n   }\n   ```\n\n7. **Update Dependencies in Cargo.toml**\n\n   Replace sync crates:\n   ```toml\n   # Before\n   [dependencies]\n   reqwest = { version = \"0.11\", features = [\"blocking\"] }\n\n   # After\n   [dependencies]\n   reqwest = \"0.11\"\n   tokio = { version = \"1\", features = [\"full\"] }\n   ```\n\n8. **Add Runtime Setup**\n\n   Add to main.rs:\n   ```rust\n   #[tokio::main]\n   async fn main() -> Result<(), Box<dyn std::error::Error>> {\n       // Your async code\n       Ok(())\n   }\n   ```\n\n9. **Handle CPU-Intensive Operations**\n\n   Wrap in `spawn_blocking`:\n   ```rust\n   async fn process_data(data: Vec<u8>) -> Result<Vec<u8>, Error> {\n       // CPU-intensive work\n       let result = tokio::task::spawn_blocking(move || {\n           expensive_computation(data)\n       }).await?;\n\n       Ok(result)\n   }\n   ```\n\n### 2. Tokio Version Upgrade\n\nWhen upgrading between Tokio versions (e.g., 0.2 → 1.x):\n\n#### Analysis Phase\n\n1. **Detect Current Version**\n   - Read `Cargo.toml`\n   - Identify current Tokio version\n   - Check dependent crates versions\n\n2. **Identify Breaking Changes**\n   - Scan for deprecated APIs\n   - Find removed features\n   - Detect renamed functions\n\n#### Migration Phase\n\n3. **Update Cargo.toml**\n\n   ```toml\n   # From Tokio 0.2\n   [dependencies]\n   tokio = { version = \"0.2\", features = [\"macros\", \"rt-threaded\"] }\n\n   # To Tokio 1.x\n   [dependencies]\n   tokio = { version = \"1\", features = [\"macros\", \"rt-multi-thread\"] }\n   ```\n\n4. **Update Runtime Setup**\n\n   ```rust\n   // Tokio 0.2\n   #[tokio::main]\n   async fn main() {\n       // ...\n   }\n\n   // Tokio 1.x (same, but verify features)\n   #[tokio::main]\n   async fn main() {\n       // ...\n   }\n   ```\n\n5. **Fix API Changes**\n\n   Common migrations:\n\n   **Timer API:**\n   ```rust\n   // Tokio 0.2\n   use tokio::time::delay_for;\n   delay_for(Duration::from_secs(1)).await;\n\n   // Tokio 1.x\n   use tokio::time::sleep;\n   sleep(Duration::from_secs(1)).await;\n   ```\n\n   **Timeout API:**\n   ```rust\n   // Tokio 0.2\n   use tokio::time::timeout_at;\n\n   // Tokio 1.x\n   use tokio::time::timeout;\n   ```\n\n   **Signal Handling:**\n   ```rust\n   // Tokio 0.2\n   use tokio::signal::ctrl_c;\n\n   // Tokio 1.x (same, but improved)\n   use tokio::signal::ctrl_c;\n   ```\n\n6. **Update Feature Flags**\n\n   Map old features to new:\n   - `rt-threaded` → `rt-multi-thread`\n   - `rt-core` → `rt`\n   - `tcp` → `net`\n   - `dns` → removed (use async DNS crates)\n\n### 3. Runtime Switch\n\nWhen switching from other runtimes (async-std, smol) to Tokio:\n\n#### Analysis Phase\n\n1. **Identify Runtime-Specific Code**\n   - Find runtime initialization\n   - Detect runtime-specific APIs\n   - Identify spawning patterns\n\n#### Migration Phase\n\n2. **Replace Runtime Setup**\n\n   **From async-std:**\n   ```rust\n   // Before\n   #[async_std::main]\n   async fn main() {\n       // ...\n   }\n\n   // After\n   #[tokio::main]\n   async fn main() {\n       // ...\n   }\n   ```\n\n3. **Update Spawning**\n\n   ```rust\n   // async-std\n   use async_std::task;\n   task::spawn(async { /* ... */ });\n\n   // Tokio\n   use tokio::task;\n   task::spawn(async { /* ... */ });\n   ```\n\n4. **Replace I/O Types**\n\n   ```rust\n   // async-std\n   use async_std::net::TcpListener;\n\n   // Tokio\n   use tokio::net::TcpListener;\n   ```\n\n5. **Update Dependencies**\n\n   Replace runtime-specific crates:\n   ```toml\n   # Remove\n   async-std = \"1\"\n\n   # Add\n   tokio = { version = \"1\", features = [\"full\"] }\n   ```\n\n### Common Migration Tasks\n\nFor all migration types:\n\n1. **Update Tests**\n   ```rust\n   // Before\n   #[async_std::test]\n   async fn test_something() { }\n\n   // After\n   #[tokio::test]\n   async fn test_something() { }\n   ```\n\n2. **Update Error Handling**\n   - Ensure error types work with async\n   - Add proper error context\n   - Use `?` operator appropriately\n\n3. **Add Tracing**\n   - Instrument key functions\n   - Add structured logging\n   - Set up tracing subscriber\n\n4. **Verification**\n   - Run `cargo check`\n   - Run `cargo test`\n   - Run `cargo clippy`\n   - Verify no blocking operations remain\n\n## Migration Checklist\n\n- [ ] All I/O operations are async\n- [ ] No `std::thread::sleep` usage\n- [ ] No `std::sync::Mutex` in async code\n- [ ] CPU-intensive work uses `spawn_blocking`\n- [ ] Runtime properly configured\n- [ ] Tests updated to use `#[tokio::test]`\n- [ ] Dependencies updated in Cargo.toml\n- [ ] Error handling verified\n- [ ] Documentation updated\n- [ ] Performance tested\n\n## Incremental Migration Strategy\n\nFor large codebases:\n\n1. **Identify Migration Boundaries**\n   - Start with leaf functions (no callers)\n   - Move up the call graph gradually\n   - Create async versions alongside sync\n\n2. **Bridge Sync and Async**\n   ```rust\n   // Call async from sync\n   fn sync_wrapper() -> Result<T, Error> {\n       let rt = tokio::runtime::Runtime::new()?;\n       rt.block_on(async_function())\n   }\n\n   // Call sync from async (CPU-intensive)\n   async fn async_wrapper() -> Result<T, Error> {\n       tokio::task::spawn_blocking(|| {\n           sync_function()\n       }).await?\n   }\n   ```\n\n3. **Migration Order**\n   - I/O layer first\n   - Business logic second\n   - API/handlers last\n   - Tests continuously\n\n## Best Practices\n\n1. **Don't Mix Sync and Async I/O**: Choose one model\n2. **Use spawn_blocking**: For blocking operations you can't convert\n3. **Test Thoroughly**: Async bugs can be subtle\n4. **Profile Performance**: Measure before and after\n5. **Update Documentation**: Note async requirements\n6. **Handle Cancellation**: Implement proper cleanup\n7. **Consider Backpressure**: Add flow control\n\n## Notes\n\n- Migration is often incremental - don't try to do everything at once\n- Test each migration step thoroughly\n- Consider performance implications of async\n- Some operations may not benefit from async\n- Document breaking changes for API consumers"
              },
              {
                "name": "/tokio-review",
                "description": "Review Tokio code for async anti-patterns, performance issues, and best practices",
                "path": "plugins/rust-tokio-expert/commands/tokio-review.md",
                "frontmatter": {
                  "name": "tokio-review",
                  "description": "Review Tokio code for async anti-patterns, performance issues, and best practices"
                },
                "content": "# Tokio Review Command\n\nThis command performs comprehensive code review of Tokio-based applications, identifying async/await anti-patterns, performance issues, blocking operations, and suggesting improvements.\n\n## Arguments\n\n- `$1` - File path or directory to review (optional, defaults to current directory)\n\n## Usage\n\n```\n/rust-tokio-expert:tokio-review\n/rust-tokio-expert:tokio-review src/handlers/\n/rust-tokio-expert:tokio-review src/main.rs\n```\n\n## Workflow\n\n1. **Analyze Target**\n   - If no argument provided, scan current directory for Rust files\n   - If directory provided, scan all `.rs` files recursively\n   - If file provided, review that specific file\n\n2. **Read Relevant Files**\n   - Use Glob tool to find Rust source files\n   - Read all identified files using Read tool\n   - Prioritize files in: src/main.rs, src/lib.rs, src/**/*.rs\n\n3. **Invoke Agent**\n   - Use Task tool with `subagent_type=\"rust-tokio-expert:tokio-performance\"`\n   - Provide all source code context to the agent\n   - Request comprehensive analysis\n\n4. **Review Checklist**\n\n   The agent should analyze for:\n\n   ### Async/Await Anti-Patterns\n\n   - [ ] **Blocking Operations in Async Context**\n     - Detect `std::thread::sleep` instead of `tokio::time::sleep`\n     - Identify blocking I/O operations\n     - Find CPU-intensive operations not wrapped in `spawn_blocking`\n\n   - [ ] **Holding Locks Across Await Points**\n     - Detect `std::sync::Mutex` or `tokio::sync::Mutex` held across `.await`\n     - Suggest lock scope reduction\n     - Recommend alternatives like channels\n\n   - [ ] **Unnecessary Cloning**\n     - Identify expensive clones in async contexts\n     - Suggest `Arc` for shared data\n     - Recommend reference passing where possible\n\n   - [ ] **Futures Not Being Awaited**\n     - Find async functions called without `.await`\n     - Detect unused futures\n     - Identify missing error handling\n\n   ### Performance Issues\n\n   - [ ] **Excessive Task Spawning**\n     - Detect unbounded task creation in loops\n     - Suggest `buffer_unordered` or bounded concurrency\n     - Recommend semaphore-based limiting\n\n   - [ ] **Large Future Sizes**\n     - Identify large types stored in future state\n     - Suggest boxing large data\n     - Recommend heap allocation for big arrays\n\n   - [ ] **Inefficient Channel Usage**\n     - Detect unbounded channels\n     - Identify inappropriate channel types\n     - Suggest buffer size optimization\n\n   - [ ] **Memory Allocation in Hot Paths**\n     - Find repeated allocations in loops\n     - Suggest buffer reuse\n     - Recommend object pooling\n\n   ### Concurrency Issues\n\n   - [ ] **Potential Deadlocks**\n     - Detect complex lock ordering\n     - Identify circular dependencies\n     - Suggest lock-free alternatives\n\n   - [ ] **Missing Timeout Handling**\n     - Find network operations without timeouts\n     - Suggest `tokio::time::timeout` usage\n     - Recommend timeout configuration\n\n   - [ ] **Improper Shutdown Handling**\n     - Check for graceful shutdown implementation\n     - Verify cleanup in Drop implementations\n     - Ensure resource release\n\n   ### Error Handling\n\n   - [ ] **Error Propagation**\n     - Verify proper error context\n     - Check error type appropriateness\n     - Suggest improvements for error handling\n\n   - [ ] **Panic in Async Context**\n     - Detect unwrap/expect in async code\n     - Suggest proper error handling\n     - Recommend Result usage\n\n   ### Channel Patterns\n\n   - [ ] **Channel Selection**\n     - Verify appropriate channel type (mpsc, oneshot, broadcast, watch)\n     - Check buffer sizes\n     - Suggest alternatives if needed\n\n   - [ ] **Select! Usage**\n     - Review select! macro usage\n     - Check for biased selection when needed\n     - Verify all branches handle errors\n\n   ### Runtime Configuration\n\n   - [ ] **Runtime Setup**\n     - Check worker thread configuration\n     - Verify blocking thread pool size\n     - Suggest optimizations based on workload\n\n5. **Generate Report**\n\n   Create a structured review report with:\n\n   ### Critical Issues (Must Fix)\n   - Blocking operations in async context\n   - Potential deadlocks\n   - Memory safety issues\n   - Resource leaks\n\n   ### High Priority (Should Fix)\n   - Performance bottlenecks\n   - Inefficient patterns\n   - Missing error handling\n   - Improper shutdown handling\n\n   ### Medium Priority (Consider Fixing)\n   - Suboptimal channel usage\n   - Missing timeouts\n   - Code organization\n   - Documentation gaps\n\n   ### Low Priority (Nice to Have)\n   - Style improvements\n   - Additional tracing\n   - Better variable names\n\n   For each issue, provide:\n   - **Location**: File, line number, function\n   - **Issue**: Clear description of the problem\n   - **Impact**: Why it matters (performance, correctness, maintainability)\n   - **Suggestion**: Specific fix with code example\n   - **Priority**: Critical, High, Medium, Low\n\n6. **Code Examples**\n\n   For each suggestion, provide:\n   - Current problematic code\n   - Suggested improved code\n   - Explanation of the improvement\n\n7. **Summary Statistics**\n\n   Provide overview:\n   - Total files reviewed\n   - Total issues found (by priority)\n   - Estimated effort to fix\n   - Overall code health score (if applicable)\n\n## Example Report Format\n\n```markdown\n# Tokio Code Review Report\n\n## Summary\n- Files reviewed: 15\n- Critical issues: 2\n- High priority: 5\n- Medium priority: 8\n- Low priority: 3\n\n## Critical Issues\n\n### 1. Blocking Operation in Async Context\n**Location**: `src/handlers/user.rs:45`\n**Function**: `process_user`\n\n**Issue**:\nUsing `std::thread::sleep` in async function blocks the runtime thread.\n\n**Current Code**:\n\\`\\`\\`rust\nasync fn process_user(id: u64) {\n    std::thread::sleep(Duration::from_secs(1)); // Blocks thread!\n    // ...\n}\n\\`\\`\\`\n\n**Suggested Fix**:\n\\`\\`\\`rust\nasync fn process_user(id: u64) {\n    tokio::time::sleep(Duration::from_secs(1)).await; // Yields control\n    // ...\n}\n\\`\\`\\`\n\n**Impact**: This blocks an entire runtime worker thread, preventing other tasks from making progress. Can cause significant performance degradation under load.\n\n## High Priority Issues\n\n### 1. Lock Held Across Await Point\n**Location**: `src/state.rs:78`\n...\n```\n\n## Best Practices Validation\n\nThe review should also verify:\n\n1. **Tracing**: Proper use of `#[instrument]` and structured logging\n2. **Error Types**: Appropriate error types with context\n3. **Testing**: Async tests with `#[tokio::test]`\n4. **Documentation**: Doc comments on public async functions\n5. **Metrics**: Performance-critical paths instrumented\n6. **Configuration**: Runtime properly configured\n7. **Dependencies**: Using appropriate crate versions\n\n## Notes\n\n- Focus on actionable feedback with concrete examples\n- Prioritize issues that impact correctness over style\n- Provide educational explanations for async concepts\n- Suggest resources for learning more about identified issues\n- Be constructive and supportive in feedback tone"
              },
              {
                "name": "/tokio-scaffold",
                "description": "Scaffold new Tokio projects with proper structure and best practices",
                "path": "plugins/rust-tokio-expert/commands/tokio-scaffold.md",
                "frontmatter": {
                  "name": "tokio-scaffold",
                  "description": "Scaffold new Tokio projects with proper structure and best practices"
                },
                "content": "# Tokio Scaffold Command\n\nThis command scaffolds new Tokio-based Rust projects with modern structure, proper dependencies, error handling patterns, tracing infrastructure, and testing setup.\n\n## Arguments\n\n- `$1` - Project name (required)\n- `$2` - Project type: `http-server`, `grpc-server`, `tcp-server`, `cli`, or `library` (optional, defaults to `library`)\n\n## Usage\n\n```\n/rust-tokio-expert:tokio-scaffold my-service http-server\n/rust-tokio-expert:tokio-scaffold my-cli cli\n/rust-tokio-expert:tokio-scaffold my-lib library\n```\n\n## Workflow\n\n1. **Validate Arguments**\n   - Check that project name is provided\n   - Validate project type if provided\n   - Ensure target directory doesn't already exist\n\n2. **Invoke Agent**\n   - Use Task tool with `subagent_type=\"rust-tokio-expert:tokio-pro\"`\n   - Pass project name and type to the agent\n\n3. **Agent Instructions**\n\n   The agent should create a complete project structure based on the type:\n\n   ### For HTTP Server Projects\n\n   Create:\n   - `Cargo.toml` with dependencies:\n     - tokio with full features\n     - axum for HTTP framework\n     - tower and tower-http for middleware\n     - serde and serde_json for serialization\n     - tracing and tracing-subscriber for logging\n     - anyhow and thiserror for error handling\n     - sqlx (optional) for database\n     - config for configuration management\n\n   - `src/main.rs` with:\n     - Runtime setup with tracing\n     - Router configuration\n     - Graceful shutdown handling\n     - Health check endpoints\n\n   - `src/handlers/mod.rs` with example HTTP handlers\n   - `src/error.rs` with custom error types\n   - `src/config.rs` with configuration loading\n   - `src/telemetry.rs` with tracing setup\n\n   - `tests/integration_test.rs` with API integration tests\n   - `.env.example` with configuration template\n   - `README.md` with usage instructions\n\n   ### For gRPC Server Projects\n\n   Create:\n   - `Cargo.toml` with:\n     - tokio with full features\n     - tonic and tonic-build\n     - prost for protobuf\n     - tower for middleware\n     - tracing infrastructure\n     - error handling crates\n\n   - `proto/service.proto` with example service definition\n   - `build.rs` for proto compilation\n   - `src/main.rs` with gRPC server setup\n   - `src/service.rs` with service implementation\n   - `src/error.rs` with error types\n   - `tests/integration_test.rs`\n\n   ### For TCP Server Projects\n\n   Create:\n   - `Cargo.toml` with:\n     - tokio with io-util, net features\n     - tokio-util with codec\n     - bytes for buffer management\n     - tracing infrastructure\n\n   - `src/main.rs` with TCP server setup\n   - `src/protocol.rs` with protocol definition\n   - `src/handler.rs` with connection handler\n   - `tests/integration_test.rs`\n\n   ### For CLI Projects\n\n   Create:\n   - `Cargo.toml` with:\n     - tokio with full features\n     - clap for argument parsing\n     - anyhow for error handling\n     - tracing-subscriber for logging\n\n   - `src/main.rs` with CLI setup\n   - `src/commands/mod.rs` with command structure\n   - `src/config.rs` with configuration\n   - `tests/cli_test.rs`\n\n   ### For Library Projects\n\n   Create:\n   - `Cargo.toml` with:\n     - tokio as optional dependency\n     - async-trait\n     - thiserror for errors\n\n   - `src/lib.rs` with library structure\n   - `tests/lib_test.rs` with comprehensive tests\n   - `examples/basic.rs` with usage example\n   - `README.md` with API documentation\n\n4. **Common Files for All Types**\n\n   - `.gitignore` with Rust-specific ignores\n   - `Cargo.toml` with proper metadata\n   - `rustfmt.toml` with formatting rules\n   - `clippy.toml` with linting configuration (if needed)\n\n5. **Initialize Testing**\n\n   For all project types:\n   - Add `#[tokio::test]` examples\n   - Include timeout tests\n   - Add mock/test utilities\n   - Set up test helpers\n\n6. **Documentation**\n\n   Generate `README.md` with:\n   - Project description\n   - Requirements\n   - Installation instructions\n   - Usage examples\n   - Development setup\n   - Testing instructions\n   - Contributing guidelines\n\n7. **Verification**\n\n   After scaffolding:\n   - Run `cargo check` to verify compilation\n   - Run `cargo test` to verify tests\n   - Report any issues found\n\n## Example Cargo.toml Template (HTTP Server)\n\n```toml\n[package]\nname = \"{{project_name}}\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\ntokio = { version = \"1\", features = [\"full\"] }\naxum = \"0.7\"\ntower = \"0.4\"\ntower-http = { version = \"0.5\", features = [\"trace\", \"compression-gzip\"] }\nserde = { version = \"1\", features = [\"derive\"] }\nserde_json = \"1\"\ntracing = \"0.1\"\ntracing-subscriber = { version = \"0.3\", features = [\"env-filter\", \"json\"] }\nanyhow = \"1\"\nthiserror = \"1\"\nconfig = \"0.14\"\n\n[dev-dependencies]\ntokio-test = \"0.4\"\n```\n\n## Example Main Template (HTTP Server)\n\n```rust\nuse axum::{Router, routing::get};\nuse std::net::SocketAddr;\nuse tower_http::trace::TraceLayer;\n\nmod handlers;\nmod error;\nmod config;\nmod telemetry;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    // Initialize telemetry\n    telemetry::init()?;\n\n    // Load configuration\n    let config = config::load()?;\n\n    // Create router\n    let app = Router::new()\n        .route(\"/health\", get(handlers::health_check))\n        .route(\"/api/v1/users\", get(handlers::list_users))\n        .layer(TraceLayer::new_for_http());\n\n    // Start server\n    let addr = SocketAddr::from(([0, 0, 0, 0], config.port));\n    tracing::info!(\"Starting server on {}\", addr);\n\n    let listener = tokio::net::TcpListener::bind(addr).await?;\n    axum::serve(listener, app)\n        .with_graceful_shutdown(shutdown_signal())\n        .await?;\n\n    Ok(())\n}\n\nasync fn shutdown_signal() {\n    tokio::signal::ctrl_c()\n        .await\n        .expect(\"failed to install CTRL+C signal handler\");\n}\n```\n\n## Best Practices\n\nThe scaffolded project should follow these best practices:\n\n1. **Error Handling**: Use `thiserror` for domain errors, `anyhow` for application errors\n2. **Configuration**: Use environment variables with sensible defaults\n3. **Logging**: Use `tracing` with structured logging\n4. **Testing**: Include both unit and integration tests\n5. **Documentation**: Generate comprehensive README with examples\n6. **Security**: Include basic security headers and validation\n7. **Performance**: Configure runtime appropriately for workload type\n8. **Observability**: Include metrics and health check endpoints\n\n## Notes\n\n- Always use the latest stable versions of dependencies\n- Include comments explaining key architectural decisions\n- Provide both simple and advanced usage examples\n- Generate projects that compile and pass tests out of the box\n- Follow Rust API guidelines and naming conventions"
              },
              {
                "name": "/tokio-test",
                "description": "Generate comprehensive async tests for Tokio applications",
                "path": "plugins/rust-tokio-expert/commands/tokio-test.md",
                "frontmatter": {
                  "name": "tokio-test",
                  "description": "Generate comprehensive async tests for Tokio applications"
                },
                "content": "# Tokio Test Command\n\nThis command generates comprehensive async tests for Tokio applications, including unit tests, integration tests, benchmarks, and property-based tests.\n\n## Arguments\n\n- `$1` - Target to generate tests for: file path, module name, or function name (required)\n- `$2` - Test type: `unit`, `integration`, `benchmark`, or `all` (optional, defaults to `unit`)\n\n## Usage\n\n```\n/rust-tokio-expert:tokio-test src/handlers/user.rs\n/rust-tokio-expert:tokio-test src/service.rs integration\n/rust-tokio-expert:tokio-test process_request benchmark\n/rust-tokio-expert:tokio-test src/api/ all\n```\n\n## Workflow\n\n1. **Parse Arguments**\n   - Validate target is provided\n   - Determine test type (unit, integration, benchmark, all)\n   - Identify target scope (file, module, or function)\n\n2. **Analyze Target Code**\n   - Read the target file(s) using Read tool\n   - Identify async functions to test\n   - Analyze function signatures and dependencies\n   - Detect error types and return values\n\n3. **Invoke Agent**\n   - Use Task tool with `subagent_type=\"rust-tokio-expert:tokio-pro\"`\n   - Provide code context and test requirements\n   - Request test generation based on type\n\n4. **Generate Unit Tests**\n\n   For each async function, create tests covering:\n\n   ### Happy Path Tests\n   ```rust\n   #[tokio::test]\n   async fn test_process_user_success() {\n       // Arrange\n       let user_id = 1;\n       let expected_name = \"John Doe\";\n\n       // Act\n       let result = process_user(user_id).await;\n\n       // Assert\n       assert!(result.is_ok());\n       let user = result.unwrap();\n       assert_eq!(user.name, expected_name);\n   }\n   ```\n\n   ### Error Handling Tests\n   ```rust\n   #[tokio::test]\n   async fn test_process_user_not_found() {\n       let result = process_user(999).await;\n\n       assert!(result.is_err());\n       assert!(matches!(result.unwrap_err(), Error::NotFound));\n   }\n   ```\n\n   ### Timeout Tests\n   ```rust\n   #[tokio::test]\n   async fn test_operation_completes_within_timeout() {\n       use tokio::time::{timeout, Duration};\n\n       let result = timeout(\n           Duration::from_secs(5),\n           slow_operation()\n       ).await;\n\n       assert!(result.is_ok(), \"Operation timed out\");\n   }\n   ```\n\n   ### Concurrent Execution Tests\n   ```rust\n   #[tokio::test]\n   async fn test_concurrent_processing() {\n       let handles: Vec<_> = (0..10)\n           .map(|i| tokio::spawn(process_item(i)))\n           .collect();\n\n       let results: Vec<_> = futures::future::join_all(handles)\n           .await\n           .into_iter()\n           .map(|r| r.unwrap())\n           .collect();\n\n       assert_eq!(results.len(), 10);\n       assert!(results.iter().all(|r| r.is_ok()));\n   }\n   ```\n\n   ### Mock Tests\n   ```rust\n   #[cfg(test)]\n   mod tests {\n       use super::*;\n       use mockall::predicate::*;\n       use mockall::mock;\n\n       mock! {\n           UserRepository {}\n\n           #[async_trait::async_trait]\n           impl UserRepository for UserRepository {\n               async fn find_by_id(&self, id: u64) -> Result<User, Error>;\n           }\n       }\n\n       #[tokio::test]\n       async fn test_with_mock_repository() {\n           let mut mock_repo = MockUserRepository::new();\n           mock_repo\n               .expect_find_by_id()\n               .with(eq(1))\n               .times(1)\n               .returning(|_| Ok(User { id: 1, name: \"Test\".into() }));\n\n           let service = UserService::new(Box::new(mock_repo));\n           let user = service.get_user(1).await.unwrap();\n\n           assert_eq!(user.name, \"Test\");\n       }\n   }\n   ```\n\n5. **Generate Integration Tests**\n\n   Create `tests/integration_test.rs` with:\n\n   ### API Integration Tests\n   ```rust\n   use tokio::net::TcpListener;\n\n   #[tokio::test]\n   async fn test_http_endpoint() {\n       // Start test server\n       let listener = TcpListener::bind(\"127.0.0.1:0\").await.unwrap();\n       let addr = listener.local_addr().unwrap();\n\n       tokio::spawn(async move {\n           run_server(listener).await.unwrap();\n       });\n\n       // Make request\n       let client = reqwest::Client::new();\n       let response = client\n           .get(format!(\"http://{}/health\", addr))\n           .send()\n           .await\n           .unwrap();\n\n       assert_eq!(response.status(), 200);\n   }\n   ```\n\n   ### Database Integration Tests\n   ```rust\n   #[tokio::test]\n   async fn test_database_operations() {\n       let pool = create_test_pool().await;\n\n       // Insert test data\n       let user = User { id: 1, name: \"Test\".into() };\n       save_user(&pool, &user).await.unwrap();\n\n       // Verify\n       let fetched = find_user(&pool, 1).await.unwrap();\n       assert_eq!(fetched.unwrap().name, \"Test\");\n\n       // Cleanup\n       cleanup_test_data(&pool).await;\n   }\n   ```\n\n   ### End-to-End Tests\n   ```rust\n   #[tokio::test]\n   async fn test_complete_workflow() {\n       // Setup\n       let app = create_test_app().await;\n\n       // Create user\n       let create_response = app.create_user(\"John\").await.unwrap();\n       let user_id = create_response.id;\n\n       // Fetch user\n       let user = app.get_user(user_id).await.unwrap();\n       assert_eq!(user.name, \"John\");\n\n       // Update user\n       app.update_user(user_id, \"Jane\").await.unwrap();\n\n       // Verify update\n       let updated = app.get_user(user_id).await.unwrap();\n       assert_eq!(updated.name, \"Jane\");\n\n       // Delete user\n       app.delete_user(user_id).await.unwrap();\n\n       // Verify deletion\n       let deleted = app.get_user(user_id).await;\n       assert!(deleted.is_err());\n   }\n   ```\n\n6. **Generate Benchmarks**\n\n   Create `benches/async_bench.rs` with:\n\n   ```rust\n   use criterion::{criterion_group, criterion_main, Criterion, BenchmarkId};\n   use tokio::runtime::Runtime;\n\n   fn benchmark_async_operations(c: &mut Criterion) {\n       let rt = Runtime::new().unwrap();\n\n       let mut group = c.benchmark_group(\"async-operations\");\n\n       // Throughput benchmark\n       for size in [10, 100, 1000].iter() {\n           group.throughput(criterion::Throughput::Elements(*size as u64));\n           group.bench_with_input(\n               BenchmarkId::from_parameter(size),\n               size,\n               |b, &size| {\n                   b.to_async(&rt).iter(|| async move {\n                       process_batch(size).await\n                   });\n               },\n           );\n       }\n\n       // Latency benchmark\n       group.bench_function(\"single_request\", |b| {\n           b.to_async(&rt).iter(|| async {\n               process_request().await\n           });\n       });\n\n       // Concurrent operations\n       group.bench_function(\"concurrent_10\", |b| {\n           b.to_async(&rt).iter(|| async {\n               let handles: Vec<_> = (0..10)\n                   .map(|_| tokio::spawn(process_request()))\n                   .collect();\n\n               for handle in handles {\n                   handle.await.unwrap();\n               }\n           });\n       });\n\n       group.finish();\n   }\n\n   criterion_group!(benches, benchmark_async_operations);\n   criterion_main!(benches);\n   ```\n\n7. **Generate Test Utilities**\n\n   Create `tests/common/mod.rs` with helpers:\n\n   ```rust\n   use tokio::runtime::Runtime;\n\n   pub fn create_test_runtime() -> Runtime {\n       Runtime::new().unwrap()\n   }\n\n   pub async fn setup_test_database() -> TestDb {\n       // Create test database\n       // Run migrations\n       // Return handle\n   }\n\n   pub async fn cleanup_test_database(db: TestDb) {\n       // Drop test database\n   }\n\n   pub struct TestApp {\n       // Application state for testing\n   }\n\n   impl TestApp {\n       pub async fn new() -> Self {\n           // Initialize test application\n       }\n\n       pub async fn cleanup(self) {\n           // Cleanup resources\n       }\n   }\n   ```\n\n8. **Add Test Configuration**\n\n   Update `Cargo.toml` with test dependencies:\n\n   ```toml\n   [dev-dependencies]\n   tokio-test = \"0.4\"\n   mockall = \"0.12\"\n   criterion = { version = \"0.5\", features = [\"async_tokio\"] }\n   proptest = \"1\"\n   futures = \"0.3\"\n   ```\n\n9. **Generate Property-Based Tests**\n\n   For appropriate functions:\n\n   ```rust\n   use proptest::prelude::*;\n\n   proptest! {\n       #[test]\n       fn test_parse_always_succeeds(input in \"\\\\PC*\") {\n           let rt = tokio::runtime::Runtime::new().unwrap();\n           rt.block_on(async {\n               let result = parse_input(&input).await;\n               assert!(result.is_ok() || result.is_err());\n           });\n       }\n   }\n   ```\n\n10. **Run and Verify Tests**\n\n    After generation:\n    - Run `cargo test` to verify tests compile and pass\n    - Run `cargo bench` to verify benchmarks work\n    - Report coverage gaps if any\n    - Suggest additional test cases if needed\n\n## Test Categories\n\nGenerate tests for:\n\n1. **Functional Correctness**\n   - Happy path scenarios\n   - Edge cases\n   - Error conditions\n   - Boundary values\n\n2. **Concurrency**\n   - Race conditions\n   - Deadlocks\n   - Task spawning\n   - Shared state access\n\n3. **Performance**\n   - Throughput\n   - Latency\n   - Resource usage\n   - Scalability\n\n4. **Reliability**\n   - Error recovery\n   - Timeout handling\n   - Retry logic\n   - Graceful degradation\n\n5. **Integration**\n   - API endpoints\n   - Database operations\n   - External services\n   - End-to-end workflows\n\n## Best Practices\n\nGenerated tests should:\n\n1. Use descriptive test names that explain what is being tested\n2. Follow Arrange-Act-Assert pattern\n3. Be independent and idempotent\n4. Clean up resources properly\n5. Use appropriate timeouts\n6. Include helpful assertion messages\n7. Mock external dependencies\n8. Test both success and failure paths\n9. Use `#[tokio::test]` for async tests\n10. Configure runtime appropriately for test type\n\n## Example Test Organization\n\n```\ntests/\n├── common/\n│   ├── mod.rs           # Shared test utilities\n│   └── fixtures.rs      # Test data fixtures\n├── integration_test.rs   # API integration tests\n├── database_test.rs      # Database integration tests\n└── e2e_test.rs          # End-to-end tests\n\nbenches/\n├── throughput.rs        # Throughput benchmarks\n└── latency.rs           # Latency benchmarks\n```\n\n## Notes\n\n- Generate tests that are maintainable and easy to understand\n- Include comments explaining complex test scenarios\n- Provide setup and teardown helpers\n- Use realistic test data\n- Consider using test fixtures for consistency\n- Document any test-specific configuration needed"
              }
            ],
            "skills": [
              {
                "name": "tokio-concurrency",
                "description": "Advanced concurrency patterns for Tokio including fan-out/fan-in, pipeline processing, rate limiting, and coordinated shutdown. Use when building high-concurrency async systems.",
                "path": "plugins/rust-tokio-expert/skills/tokio-concurrency/SKILL.md",
                "frontmatter": {
                  "name": "tokio-concurrency",
                  "description": "Advanced concurrency patterns for Tokio including fan-out/fan-in, pipeline processing, rate limiting, and coordinated shutdown. Use when building high-concurrency async systems."
                },
                "content": "# Tokio Concurrency Patterns\n\nThis skill provides advanced concurrency patterns for building scalable async applications with Tokio.\n\n## Fan-Out/Fan-In Pattern\n\nDistribute work across multiple workers and collect results:\n\n```rust\nuse futures::stream::{self, StreamExt};\n\npub async fn fan_out_fan_in<T, R>(\n    items: Vec<T>,\n    concurrency: usize,\n    process: impl Fn(T) -> Pin<Box<dyn Future<Output = R> + Send>> + Send + Sync + 'static,\n) -> Vec<R>\nwhere\n    T: Send + 'static,\n    R: Send + 'static,\n{\n    stream::iter(items)\n        .map(|item| process(item))\n        .buffer_unordered(concurrency)\n        .collect()\n        .await\n}\n\n// Usage\nlet results = fan_out_fan_in(\n    items,\n    10,\n    |item| Box::pin(async move { process_item(item).await })\n).await;\n```\n\n## Pipeline Processing\n\nChain async processing stages:\n\n```rust\nuse tokio::sync::mpsc;\n\npub struct Pipeline<T> {\n    stages: Vec<Box<dyn Stage<T>>>,\n}\n\n#[async_trait::async_trait]\npub trait Stage<T>: Send {\n    async fn process(&self, item: T) -> T;\n}\n\nimpl<T: Send + 'static> Pipeline<T> {\n    pub fn new() -> Self {\n        Self { stages: Vec::new() }\n    }\n\n    pub fn add_stage<S: Stage<T> + 'static>(mut self, stage: S) -> Self {\n        self.stages.push(Box::new(stage));\n        self\n    }\n\n    pub async fn run(self, mut input: mpsc::Receiver<T>) -> mpsc::Receiver<T> {\n        let (tx, rx) = mpsc::channel(100);\n\n        tokio::spawn(async move {\n            while let Some(mut item) = input.recv().await {\n                // Process through all stages\n                for stage in &self.stages {\n                    item = stage.process(item).await;\n                }\n\n                if tx.send(item).await.is_err() {\n                    break;\n                }\n            }\n        });\n\n        rx\n    }\n}\n\n// Usage\nlet pipeline = Pipeline::new()\n    .add_stage(ValidationStage)\n    .add_stage(TransformStage)\n    .add_stage(EnrichmentStage);\n\nlet output = pipeline.run(input_channel).await;\n```\n\n## Rate Limiting\n\nControl operation rate using token bucket or leaky bucket:\n\n```rust\nuse tokio::time::{interval, Duration, Instant};\nuse tokio::sync::Semaphore;\nuse std::sync::Arc;\n\npub struct RateLimiter {\n    semaphore: Arc<Semaphore>,\n    rate: usize,\n    period: Duration,\n}\n\nimpl RateLimiter {\n    pub fn new(rate: usize, period: Duration) -> Self {\n        let limiter = Self {\n            semaphore: Arc::new(Semaphore::new(rate)),\n            rate,\n            period,\n        };\n\n        // Refill tokens\n        let semaphore = limiter.semaphore.clone();\n        let rate = limiter.rate;\n        let period = limiter.period;\n\n        tokio::spawn(async move {\n            let mut interval = interval(period);\n            loop {\n                interval.tick().await;\n                // Add permits up to max\n                for _ in 0..rate {\n                    if semaphore.available_permits() < rate {\n                        semaphore.add_permits(1);\n                    }\n                }\n            }\n        });\n\n        limiter\n    }\n\n    pub async fn acquire(&self) {\n        self.semaphore.acquire().await.unwrap().forget();\n    }\n}\n\n// Usage\nlet limiter = RateLimiter::new(100, Duration::from_secs(1));\n\nfor _ in 0..1000 {\n    limiter.acquire().await;\n    make_request().await;\n}\n```\n\n## Parallel Task Execution with Join\n\nExecute multiple tasks in parallel and wait for all:\n\n```rust\nuse tokio::try_join;\n\npub async fn parallel_operations() -> Result<(String, Vec<User>, Config), Error> {\n    try_join!(\n        fetch_data(),\n        fetch_users(),\n        load_config()\n    )\n}\n\n// With manual spawning for CPU-bound work\npub async fn parallel_cpu_work(items: Vec<Item>) -> Vec<Result<Processed, Error>> {\n    let handles: Vec<_> = items\n        .into_iter()\n        .map(|item| {\n            tokio::task::spawn_blocking(move || {\n                expensive_cpu_work(item)\n            })\n        })\n        .collect();\n\n    let mut results = Vec::new();\n    for handle in handles {\n        results.push(handle.await.unwrap());\n    }\n    results\n}\n```\n\n## Coordinated Shutdown with CancellationToken\n\nManage hierarchical cancellation:\n\n```rust\nuse tokio_util::sync::CancellationToken;\nuse tokio::select;\n\npub struct Coordinator {\n    token: CancellationToken,\n    tasks: Vec<tokio::task::JoinHandle<()>>,\n}\n\nimpl Coordinator {\n    pub fn new() -> Self {\n        Self {\n            token: CancellationToken::new(),\n            tasks: Vec::new(),\n        }\n    }\n\n    pub fn spawn<F>(&mut self, f: F)\n    where\n        F: Future<Output = ()> + Send + 'static,\n    {\n        let token = self.token.child_token();\n        let handle = tokio::spawn(async move {\n            select! {\n                _ = token.cancelled() => {}\n                _ = f => {}\n            }\n        });\n        self.tasks.push(handle);\n    }\n\n    pub async fn shutdown(self) {\n        self.token.cancel();\n\n        for task in self.tasks {\n            let _ = task.await;\n        }\n    }\n}\n\n// Usage\nlet mut coordinator = Coordinator::new();\n\ncoordinator.spawn(worker1());\ncoordinator.spawn(worker2());\ncoordinator.spawn(worker3());\n\n// Later...\ncoordinator.shutdown().await;\n```\n\n## Async Trait Patterns\n\nWork around async trait limitations:\n\n```rust\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait AsyncService {\n    async fn process(&self, input: String) -> Result<String, Error>;\n}\n\n// Alternative without async-trait\npub trait AsyncServiceManual {\n    fn process<'a>(\n        &'a self,\n        input: String,\n    ) -> Pin<Box<dyn Future<Output = Result<String, Error>> + Send + 'a>>;\n}\n\n// Implementation\nstruct MyService;\n\n#[async_trait]\nimpl AsyncService for MyService {\n    async fn process(&self, input: String) -> Result<String, Error> {\n        // async implementation\n        Ok(input.to_uppercase())\n    }\n}\n```\n\n## Shared State Management\n\nSafe concurrent access to shared state:\n\n```rust\nuse tokio::sync::RwLock;\nuse std::sync::Arc;\n\npub struct SharedState {\n    data: Arc<RwLock<HashMap<String, String>>>,\n}\n\nimpl SharedState {\n    pub fn new() -> Self {\n        Self {\n            data: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    pub async fn get(&self, key: &str) -> Option<String> {\n        let data = self.data.read().await;\n        data.get(key).cloned()\n    }\n\n    pub async fn set(&self, key: String, value: String) {\n        let mut data = self.data.write().await;\n        data.insert(key, value);\n    }\n\n    // Batch operations\n    pub async fn get_many(&self, keys: &[String]) -> Vec<Option<String>> {\n        let data = self.data.read().await;\n        keys.iter()\n            .map(|key| data.get(key).cloned())\n            .collect()\n    }\n}\n\n// Clone is cheap (Arc)\nimpl Clone for SharedState {\n    fn clone(&self) -> Self {\n        Self {\n            data: self.data.clone(),\n        }\n    }\n}\n```\n\n## Work Stealing Queue\n\nImplement work stealing for load balancing:\n\n```rust\nuse tokio::sync::mpsc;\nuse std::sync::Arc;\n\npub struct WorkQueue<T> {\n    queues: Vec<mpsc::Sender<T>>,\n    receivers: Vec<mpsc::Receiver<T>>,\n    next: Arc<AtomicUsize>,\n}\n\nimpl<T: Send + 'static> WorkQueue<T> {\n    pub fn new(workers: usize, capacity: usize) -> Self {\n        let mut queues = Vec::new();\n        let mut receivers = Vec::new();\n\n        for _ in 0..workers {\n            let (tx, rx) = mpsc::channel(capacity);\n            queues.push(tx);\n            receivers.push(rx);\n        }\n\n        Self {\n            queues,\n            receivers,\n            next: Arc::new(AtomicUsize::new(0)),\n        }\n    }\n\n    pub async fn submit(&self, work: T) -> Result<(), mpsc::error::SendError<T>> {\n        let idx = self.next.fetch_add(1, Ordering::Relaxed) % self.queues.len();\n        self.queues[idx].send(work).await\n    }\n\n    pub fn spawn_workers<F>(mut self, process: F)\n    where\n        F: Fn(T) -> Pin<Box<dyn Future<Output = ()> + Send>> + Send + Sync + Clone + 'static,\n    {\n        for mut rx in self.receivers.drain(..) {\n            let process = process.clone();\n            tokio::spawn(async move {\n                while let Some(work) = rx.recv().await {\n                    process(work).await;\n                }\n            });\n        }\n    }\n}\n```\n\n## Circuit Breaker for Resilience\n\nPrevent cascading failures:\n\n```rust\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse tokio::time::{Instant, Duration};\n\npub enum CircuitState {\n    Closed,\n    Open(Instant),\n    HalfOpen,\n}\n\npub struct CircuitBreaker {\n    state: Arc<RwLock<CircuitState>>,\n    failure_count: AtomicU64,\n    threshold: u64,\n    timeout: Duration,\n}\n\nimpl CircuitBreaker {\n    pub fn new(threshold: u64, timeout: Duration) -> Self {\n        Self {\n            state: Arc::new(RwLock::new(CircuitState::Closed)),\n            failure_count: AtomicU64::new(0),\n            threshold,\n            timeout,\n        }\n    }\n\n    pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>\n    where\n        F: Future<Output = Result<T, E>>,\n    {\n        // Check if circuit is open\n        let state = self.state.read().await;\n        match *state {\n            CircuitState::Open(opened_at) => {\n                if opened_at.elapsed() < self.timeout {\n                    return Err(CircuitBreakerError::Open);\n                }\n                drop(state);\n                *self.state.write().await = CircuitState::HalfOpen;\n            }\n            _ => {}\n        }\n        drop(state);\n\n        // Execute request\n        match f.await {\n            Ok(result) => {\n                self.on_success().await;\n                Ok(result)\n            }\n            Err(e) => {\n                self.on_failure().await;\n                Err(CircuitBreakerError::Inner(e))\n            }\n        }\n    }\n\n    async fn on_success(&self) {\n        self.failure_count.store(0, Ordering::SeqCst);\n        let mut state = self.state.write().await;\n        if matches!(*state, CircuitState::HalfOpen) {\n            *state = CircuitState::Closed;\n        }\n    }\n\n    async fn on_failure(&self) {\n        let failures = self.failure_count.fetch_add(1, Ordering::SeqCst) + 1;\n        if failures >= self.threshold {\n            *self.state.write().await = CircuitState::Open(Instant::now());\n        }\n    }\n}\n```\n\n## Batching Operations\n\nBatch multiple operations for efficiency:\n\n```rust\nuse tokio::time::{interval, Duration};\n\npub struct Batcher<T> {\n    tx: mpsc::Sender<T>,\n}\n\nimpl<T: Send + 'static> Batcher<T> {\n    pub fn new<F>(\n        batch_size: usize,\n        batch_timeout: Duration,\n        process: F,\n    ) -> Self\n    where\n        F: Fn(Vec<T>) -> Pin<Box<dyn Future<Output = ()> + Send>> + Send + 'static,\n    {\n        let (tx, mut rx) = mpsc::channel(1000);\n\n        tokio::spawn(async move {\n            let mut batch = Vec::with_capacity(batch_size);\n            let mut interval = interval(batch_timeout);\n\n            loop {\n                tokio::select! {\n                    item = rx.recv() => {\n                        match item {\n                            Some(item) => {\n                                batch.push(item);\n                                if batch.len() >= batch_size {\n                                    process(std::mem::replace(&mut batch, Vec::with_capacity(batch_size))).await;\n                                }\n                            }\n                            None => break,\n                        }\n                    }\n                    _ = interval.tick() => {\n                        if !batch.is_empty() {\n                            process(std::mem::replace(&mut batch, Vec::with_capacity(batch_size))).await;\n                        }\n                    }\n                }\n            }\n\n            // Process remaining items\n            if !batch.is_empty() {\n                process(batch).await;\n            }\n        });\n\n        Self { tx }\n    }\n\n    pub async fn submit(&self, item: T) -> Result<(), mpsc::error::SendError<T>> {\n        self.tx.send(item).await\n    }\n}\n```\n\n## Best Practices\n\n1. **Use appropriate concurrency limits** - Don't spawn unbounded tasks\n2. **Implement backpressure** - Use bounded channels and semaphores\n3. **Handle cancellation** - Support cooperative cancellation with tokens\n4. **Avoid lock contention** - Minimize lock scope, prefer channels\n5. **Use rate limiting** - Protect external services\n6. **Implement circuit breakers** - Prevent cascading failures\n7. **Batch operations** - Reduce overhead for small operations\n8. **Profile concurrency** - Use tokio-console to understand behavior\n9. **Use appropriate synchronization** - RwLock for read-heavy, Mutex for write-heavy\n10. **Design for failure** - Always consider what happens when operations fail"
              },
              {
                "name": "tokio-networking",
                "description": "Network programming patterns with Hyper, Tonic, and Tower. Use when building HTTP services, gRPC applications, implementing middleware, connection pooling, or health checks.",
                "path": "plugins/rust-tokio-expert/skills/tokio-networking/SKILL.md",
                "frontmatter": {
                  "name": "tokio-networking",
                  "description": "Network programming patterns with Hyper, Tonic, and Tower. Use when building HTTP services, gRPC applications, implementing middleware, connection pooling, or health checks."
                },
                "content": "# Tokio Networking Patterns\n\nThis skill provides network programming patterns for building production-grade services with the Tokio ecosystem.\n\n## HTTP Service with Hyper and Axum\n\nBuild HTTP services with routing and middleware:\n\n```rust\nuse axum::{\n    Router,\n    routing::{get, post},\n    extract::{State, Path, Json},\n    response::IntoResponse,\n    middleware,\n};\nuse std::sync::Arc;\n\n#[derive(Clone)]\nstruct AppState {\n    db: Arc<Database>,\n    cache: Arc<Cache>,\n}\n\nasync fn create_app() -> Router {\n    let state = AppState {\n        db: Arc::new(Database::new().await),\n        cache: Arc::new(Cache::new()),\n    };\n\n    Router::new()\n        .route(\"/health\", get(health_check))\n        .route(\"/api/v1/users\", get(list_users).post(create_user))\n        .route(\"/api/v1/users/:id\", get(get_user).delete(delete_user))\n        .layer(middleware::from_fn(logging_middleware))\n        .layer(middleware::from_fn(auth_middleware))\n        .with_state(state)\n}\n\nasync fn health_check() -> impl IntoResponse {\n    \"OK\"\n}\n\nasync fn get_user(\n    State(state): State<AppState>,\n    Path(id): Path<u64>,\n) -> Result<Json<User>, StatusCode> {\n    state.db.get_user(id)\n        .await\n        .map(Json)\n        .ok_or(StatusCode::NOT_FOUND)\n}\n\nasync fn logging_middleware<B>(\n    req: Request<B>,\n    next: Next<B>,\n) -> impl IntoResponse {\n    let method = req.method().clone();\n    let uri = req.uri().clone();\n\n    let start = Instant::now();\n    let response = next.run(req).await;\n    let duration = start.elapsed();\n\n    tracing::info!(\n        method = %method,\n        uri = %uri,\n        status = %response.status(),\n        duration_ms = duration.as_millis(),\n        \"request completed\"\n    );\n\n    response\n}\n```\n\n## gRPC Service with Tonic\n\nBuild type-safe gRPC services:\n\n```rust\nuse tonic::{transport::Server, Request, Response, Status};\n\npub mod proto {\n    tonic::include_proto!(\"myservice\");\n}\n\nuse proto::my_service_server::{MyService, MyServiceServer};\n\n#[derive(Default)]\npub struct MyServiceImpl {\n    db: Arc<Database>,\n}\n\n#[tonic::async_trait]\nimpl MyService for MyServiceImpl {\n    async fn get_user(\n        &self,\n        request: Request<proto::GetUserRequest>,\n    ) -> Result<Response<proto::User>, Status> {\n        let req = request.into_inner();\n\n        let user = self.db.get_user(req.id)\n            .await\n            .map_err(|e| Status::internal(e.to_string()))?\n            .ok_or_else(|| Status::not_found(\"User not found\"))?;\n\n        Ok(Response::new(proto::User {\n            id: user.id,\n            name: user.name,\n            email: user.email,\n        }))\n    }\n\n    type ListUsersStream = ReceiverStream<Result<proto::User, Status>>;\n\n    async fn list_users(\n        &self,\n        request: Request<proto::ListUsersRequest>,\n    ) -> Result<Response<Self::ListUsersStream>, Status> {\n        let (tx, rx) = mpsc::channel(100);\n\n        let db = self.db.clone();\n        tokio::spawn(async move {\n            let mut users = db.list_users().await.unwrap();\n\n            while let Some(user) = users.next().await {\n                let proto_user = proto::User {\n                    id: user.id,\n                    name: user.name,\n                    email: user.email,\n                };\n\n                if tx.send(Ok(proto_user)).await.is_err() {\n                    break;\n                }\n            }\n        });\n\n        Ok(Response::new(ReceiverStream::new(rx)))\n    }\n}\n\nasync fn serve() -> Result<(), Box<dyn std::error::Error>> {\n    let addr = \"[::1]:50051\".parse()?;\n    let service = MyServiceImpl::default();\n\n    Server::builder()\n        .add_service(MyServiceServer::new(service))\n        .serve(addr)\n        .await?;\n\n    Ok(())\n}\n```\n\n## Tower Middleware Composition\n\nLayer middleware for cross-cutting concerns:\n\n```rust\nuse tower::{ServiceBuilder, Service};\nuse tower_http::{\n    trace::TraceLayer,\n    compression::CompressionLayer,\n    timeout::TimeoutLayer,\n    limit::RateLimitLayer,\n};\nuse std::time::Duration;\n\nfn create_middleware_stack<S>(service: S) -> impl Service\nwhere\n    S: Service + Clone,\n{\n    ServiceBuilder::new()\n        // Outermost layer (executed first)\n        .layer(TraceLayer::new_for_http())\n        .layer(CompressionLayer::new())\n        .layer(TimeoutLayer::new(Duration::from_secs(30)))\n        .layer(RateLimitLayer::new(100, Duration::from_secs(1)))\n        // Innermost layer (executed last)\n        .service(service)\n}\n\n// Custom middleware\nuse tower::Layer;\n\n#[derive(Clone)]\nstruct MetricsLayer {\n    metrics: Arc<Metrics>,\n}\n\nimpl<S> Layer<S> for MetricsLayer {\n    type Service = MetricsService<S>;\n\n    fn layer(&self, inner: S) -> Self::Service {\n        MetricsService {\n            inner,\n            metrics: self.metrics.clone(),\n        }\n    }\n}\n\n#[derive(Clone)]\nstruct MetricsService<S> {\n    inner: S,\n    metrics: Arc<Metrics>,\n}\n\nimpl<S, Req> Service<Req> for MetricsService<S>\nwhere\n    S: Service<Req>,\n{\n    type Response = S::Response;\n    type Error = S::Error;\n    type Future = /* ... */;\n\n    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {\n        self.inner.poll_ready(cx)\n    }\n\n    fn call(&mut self, req: Req) -> Self::Future {\n        self.metrics.requests_total.inc();\n        let timer = self.metrics.request_duration.start_timer();\n\n        let future = self.inner.call(req);\n        let metrics = self.metrics.clone();\n\n        Box::pin(async move {\n            let result = future.await;\n            timer.observe_duration();\n            result\n        })\n    }\n}\n```\n\n## Connection Pooling\n\nManage connection pools efficiently:\n\n```rust\nuse deadpool_postgres::{Config, Pool, Runtime};\nuse tokio_postgres::NoTls;\n\npub struct DatabasePool {\n    pool: Pool,\n}\n\nimpl DatabasePool {\n    pub async fn new(config: &DatabaseConfig) -> Result<Self, Error> {\n        let mut cfg = Config::new();\n        cfg.host = Some(config.host.clone());\n        cfg.port = Some(config.port);\n        cfg.dbname = Some(config.database.clone());\n        cfg.user = Some(config.user.clone());\n        cfg.password = Some(config.password.clone());\n\n        let pool = cfg.create_pool(Some(Runtime::Tokio1), NoTls)?;\n\n        Ok(Self { pool })\n    }\n\n    pub async fn get(&self) -> Result<Client, Error> {\n        self.pool.get().await.map_err(Into::into)\n    }\n\n    pub async fn query<T>(&self, f: impl FnOnce(&Client) -> F) -> Result<T, Error>\n    where\n        F: Future<Output = Result<T, Error>>,\n    {\n        let client = self.get().await?;\n        f(&client).await\n    }\n}\n\n// Usage\nlet pool = DatabasePool::new(&config).await?;\n\nlet users = pool.query(|client| async move {\n    client.query(\"SELECT * FROM users\", &[])\n        .await\n        .map_err(Into::into)\n}).await?;\n```\n\n## Health Checks and Readiness Probes\n\nImplement comprehensive health checks:\n\n```rust\nuse axum::{Router, routing::get, Json};\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct HealthResponse {\n    status: String,\n    version: String,\n    dependencies: Vec<DependencyHealth>,\n}\n\n#[derive(Serialize)]\nstruct DependencyHealth {\n    name: String,\n    status: String,\n    latency_ms: Option<u64>,\n    message: Option<String>,\n}\n\nasync fn health_check(State(state): State<Arc<AppState>>) -> Json<HealthResponse> {\n    let mut dependencies = Vec::new();\n\n    // Check database\n    let db_start = Instant::now();\n    let db_status = match state.db.ping().await {\n        Ok(_) => DependencyHealth {\n            name: \"database\".into(),\n            status: \"healthy\".into(),\n            latency_ms: Some(db_start.elapsed().as_millis() as u64),\n            message: None,\n        },\n        Err(e) => DependencyHealth {\n            name: \"database\".into(),\n            status: \"unhealthy\".into(),\n            latency_ms: None,\n            message: Some(e.to_string()),\n        },\n    };\n    dependencies.push(db_status);\n\n    // Check cache\n    let cache_start = Instant::now();\n    let cache_status = match state.cache.ping().await {\n        Ok(_) => DependencyHealth {\n            name: \"cache\".into(),\n            status: \"healthy\".into(),\n            latency_ms: Some(cache_start.elapsed().as_millis() as u64),\n            message: None,\n        },\n        Err(e) => DependencyHealth {\n            name: \"cache\".into(),\n            status: \"unhealthy\".into(),\n            latency_ms: None,\n            message: Some(e.to_string()),\n        },\n    };\n    dependencies.push(cache_status);\n\n    let all_healthy = dependencies.iter().all(|d| d.status == \"healthy\");\n\n    Json(HealthResponse {\n        status: if all_healthy { \"healthy\" } else { \"unhealthy\" }.into(),\n        version: env!(\"CARGO_PKG_VERSION\").into(),\n        dependencies,\n    })\n}\n\nasync fn readiness_check(State(state): State<Arc<AppState>>) -> StatusCode {\n    if state.is_ready().await {\n        StatusCode::OK\n    } else {\n        StatusCode::SERVICE_UNAVAILABLE\n    }\n}\n\npub fn health_routes() -> Router<Arc<AppState>> {\n    Router::new()\n        .route(\"/health\", get(health_check))\n        .route(\"/ready\", get(readiness_check))\n        .route(\"/live\", get(|| async { StatusCode::OK }))\n}\n```\n\n## Circuit Breaker Pattern\n\nProtect against cascading failures:\n\n```rust\nuse std::sync::atomic::{AtomicU64, Ordering};\n\npub struct ServiceClient {\n    client: reqwest::Client,\n    circuit_breaker: CircuitBreaker,\n}\n\nimpl ServiceClient {\n    pub async fn call(&self, req: Request) -> Result<Response, Error> {\n        self.circuit_breaker.call(async {\n            self.client\n                .execute(req)\n                .await\n                .map_err(Into::into)\n        }).await\n    }\n}\n```\n\n## Load Balancing\n\nDistribute requests across multiple backends:\n\n```rust\nuse tower::balance::p2c::Balance;\nuse tower::discover::ServiceList;\n\npub struct LoadBalancer {\n    balancer: Balance<ServiceList<Vec<ServiceEndpoint>>, Request>,\n}\n\nimpl LoadBalancer {\n    pub fn new(endpoints: Vec<String>) -> Self {\n        let services: Vec<_> = endpoints\n            .into_iter()\n            .map(|endpoint| create_client(endpoint))\n            .collect();\n\n        let balancer = Balance::new(ServiceList::new(services));\n\n        Self { balancer }\n    }\n\n    pub async fn call(&mut self, req: Request) -> Result<Response, Error> {\n        self.balancer.call(req).await\n    }\n}\n```\n\n## Request Deduplication\n\nDeduplicate concurrent identical requests:\n\n```rust\nuse tokio::sync::Mutex;\nuse std::collections::HashMap;\n\npub struct RequestDeduplicator<K, V> {\n    in_flight: Arc<Mutex<HashMap<K, Arc<tokio::sync::Notify>>>>,\n    cache: Arc<Mutex<HashMap<K, Arc<V>>>>,\n}\n\nimpl<K: Eq + Hash + Clone, V> RequestDeduplicator<K, V> {\n    pub fn new() -> Self {\n        Self {\n            in_flight: Arc::new(Mutex::new(HashMap::new())),\n            cache: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n\n    pub async fn get_or_fetch<F, Fut>(\n        &self,\n        key: K,\n        fetch: F,\n    ) -> Result<Arc<V>, Error>\n    where\n        F: FnOnce() -> Fut,\n        Fut: Future<Output = Result<V, Error>>,\n    {\n        // Check cache\n        {\n            let cache = self.cache.lock().await;\n            if let Some(value) = cache.get(&key) {\n                return Ok(value.clone());\n            }\n        }\n\n        // Check if request is in flight\n        let notify = {\n            let mut in_flight = self.in_flight.lock().await;\n            if let Some(notify) = in_flight.get(&key) {\n                notify.clone()\n            } else {\n                let notify = Arc::new(tokio::sync::Notify::new());\n                in_flight.insert(key.clone(), notify.clone());\n                notify\n            }\n        };\n\n        // Wait if another request is in progress\n        notify.notified().await;\n\n        // Check cache again\n        {\n            let cache = self.cache.lock().await;\n            if let Some(value) = cache.get(&key) {\n                return Ok(value.clone());\n            }\n        }\n\n        // Fetch value\n        let value = Arc::new(fetch().await?);\n\n        // Update cache\n        {\n            let mut cache = self.cache.lock().await;\n            cache.insert(key.clone(), value.clone());\n        }\n\n        // Remove from in-flight and notify\n        {\n            let mut in_flight = self.in_flight.lock().await;\n            in_flight.remove(&key);\n        }\n        notify.notify_waiters();\n\n        Ok(value)\n    }\n}\n```\n\n## Best Practices\n\n1. **Use connection pooling** for database and HTTP connections\n2. **Implement health checks** for all dependencies\n3. **Add circuit breakers** for external service calls\n4. **Use appropriate timeouts** for all network operations\n5. **Implement retry logic** with exponential backoff\n6. **Add comprehensive middleware** for logging, metrics, auth\n7. **Use load balancing** for high availability\n8. **Deduplicate requests** to reduce load\n9. **Monitor latency** and error rates\n10. **Design for graceful degradation** when services fail"
              },
              {
                "name": "tokio-patterns",
                "description": "Common Tokio patterns and idioms for async programming. Use when implementing worker pools, request-response patterns, pub/sub, timeouts, retries, or graceful shutdown.",
                "path": "plugins/rust-tokio-expert/skills/tokio-patterns/SKILL.md",
                "frontmatter": {
                  "name": "tokio-patterns",
                  "description": "Common Tokio patterns and idioms for async programming. Use when implementing worker pools, request-response patterns, pub/sub, timeouts, retries, or graceful shutdown."
                },
                "content": "# Tokio Patterns\n\nThis skill provides common patterns and idioms for building robust async applications with Tokio.\n\n## Worker Pool Pattern\n\nLimit concurrent task execution using a semaphore:\n\n```rust\nuse tokio::sync::Semaphore;\nuse std::sync::Arc;\n\npub struct WorkerPool {\n    semaphore: Arc<Semaphore>,\n}\n\nimpl WorkerPool {\n    pub fn new(size: usize) -> Self {\n        Self {\n            semaphore: Arc::new(Semaphore::new(size)),\n        }\n    }\n\n    pub async fn execute<F, T>(&self, f: F) -> T\n    where\n        F: Future<Output = T>,\n    {\n        let _permit = self.semaphore.acquire().await.unwrap();\n        f.await\n    }\n}\n\n// Usage\nlet pool = WorkerPool::new(10);\nlet results = futures::future::join_all(\n    (0..100).map(|i| pool.execute(process_item(i)))\n).await;\n```\n\n## Request-Response Pattern\n\nUse oneshot channels for request-response communication:\n\n```rust\nuse tokio::sync::{mpsc, oneshot};\n\npub enum Command {\n    Get { key: String, respond_to: oneshot::Sender<Option<String>> },\n    Set { key: String, value: String },\n}\n\npub async fn actor(mut rx: mpsc::Receiver<Command>) {\n    let mut store = HashMap::new();\n\n    while let Some(cmd) = rx.recv().await {\n        match cmd {\n            Command::Get { key, respond_to } => {\n                let value = store.get(&key).cloned();\n                let _ = respond_to.send(value);\n            }\n            Command::Set { key, value } => {\n                store.insert(key, value);\n            }\n        }\n    }\n}\n\n// Client usage\nlet (tx, rx) = mpsc::channel(32);\ntokio::spawn(actor(rx));\n\nlet (respond_to, response) = oneshot::channel();\ntx.send(Command::Get { key: \"foo\".into(), respond_to }).await.unwrap();\nlet value = response.await.unwrap();\n```\n\n## Pub/Sub with Channels\n\nUse broadcast channels for pub/sub messaging:\n\n```rust\nuse tokio::sync::broadcast;\n\npub struct PubSub<T: Clone> {\n    tx: broadcast::Sender<T>,\n}\n\nimpl<T: Clone> PubSub<T> {\n    pub fn new(capacity: usize) -> Self {\n        let (tx, _) = broadcast::channel(capacity);\n        Self { tx }\n    }\n\n    pub fn subscribe(&self) -> broadcast::Receiver<T> {\n        self.tx.subscribe()\n    }\n\n    pub fn publish(&self, message: T) -> Result<usize, broadcast::error::SendError<T>> {\n        self.tx.send(message)\n    }\n}\n\n// Usage\nlet pubsub = PubSub::new(100);\n\n// Subscriber 1\nlet mut rx1 = pubsub.subscribe();\ntokio::spawn(async move {\n    while let Ok(msg) = rx1.recv().await {\n        println!(\"Subscriber 1: {:?}\", msg);\n    }\n});\n\n// Subscriber 2\nlet mut rx2 = pubsub.subscribe();\ntokio::spawn(async move {\n    while let Ok(msg) = rx2.recv().await {\n        println!(\"Subscriber 2: {:?}\", msg);\n    }\n});\n\n// Publisher\npubsub.publish(\"Hello\".to_string()).unwrap();\n```\n\n## Timeout Pattern\n\nWrap operations with timeouts:\n\n```rust\nuse tokio::time::{timeout, Duration};\n\npub async fn with_timeout<F, T>(duration: Duration, future: F) -> Result<T, TimeoutError>\nwhere\n    F: Future<Output = Result<T, Error>>,\n{\n    match timeout(duration, future).await {\n        Ok(Ok(result)) => Ok(result),\n        Ok(Err(e)) => Err(TimeoutError::Inner(e)),\n        Err(_) => Err(TimeoutError::Elapsed),\n    }\n}\n\n// Usage\nlet result = with_timeout(\n    Duration::from_secs(5),\n    fetch_data()\n).await?;\n```\n\n## Retry with Exponential Backoff\n\nRetry failed operations with backoff:\n\n```rust\nuse tokio::time::{sleep, Duration};\n\npub async fn retry_with_backoff<F, T, E>(\n    mut operation: F,\n    max_retries: u32,\n    initial_backoff: Duration,\n) -> Result<T, E>\nwhere\n    F: FnMut() -> Pin<Box<dyn Future<Output = Result<T, E>>>>,\n{\n    let mut retries = 0;\n    let mut backoff = initial_backoff;\n\n    loop {\n        match operation().await {\n            Ok(result) => return Ok(result),\n            Err(e) if retries < max_retries => {\n                retries += 1;\n                sleep(backoff).await;\n                backoff *= 2; // Exponential backoff\n            }\n            Err(e) => return Err(e),\n        }\n    }\n}\n\n// Usage\nlet result = retry_with_backoff(\n    || Box::pin(fetch_data()),\n    3,\n    Duration::from_millis(100)\n).await?;\n```\n\n## Graceful Shutdown\n\nCoordinate graceful shutdown across components:\n\n```rust\nuse tokio::sync::broadcast;\nuse tokio::select;\n\npub struct ShutdownCoordinator {\n    tx: broadcast::Sender<()>,\n}\n\nimpl ShutdownCoordinator {\n    pub fn new() -> Self {\n        let (tx, _) = broadcast::channel(1);\n        Self { tx }\n    }\n\n    pub fn subscribe(&self) -> broadcast::Receiver<()> {\n        self.tx.subscribe()\n    }\n\n    pub fn shutdown(&self) {\n        let _ = self.tx.send(());\n    }\n}\n\n// Worker pattern\npub async fn worker(mut shutdown: broadcast::Receiver<()>) {\n    loop {\n        select! {\n            _ = shutdown.recv() => {\n                // Cleanup\n                break;\n            }\n            result = do_work() => {\n                // Process result\n            }\n        }\n    }\n}\n\n// Main\nlet coordinator = ShutdownCoordinator::new();\n\nlet shutdown_rx1 = coordinator.subscribe();\nlet h1 = tokio::spawn(worker(shutdown_rx1));\n\nlet shutdown_rx2 = coordinator.subscribe();\nlet h2 = tokio::spawn(worker(shutdown_rx2));\n\n// Wait for signal\ntokio::signal::ctrl_c().await.unwrap();\ncoordinator.shutdown();\n\n// Wait for workers\nlet _ = tokio::join!(h1, h2);\n```\n\n## Async Initialization\n\nLazy async initialization with `OnceCell`:\n\n```rust\nuse tokio::sync::OnceCell;\n\npub struct Service {\n    connection: OnceCell<Connection>,\n}\n\nimpl Service {\n    pub fn new() -> Self {\n        Self {\n            connection: OnceCell::new(),\n        }\n    }\n\n    async fn get_connection(&self) -> &Connection {\n        self.connection\n            .get_or_init(|| async {\n                Connection::connect().await.unwrap()\n            })\n            .await\n    }\n\n    pub async fn query(&self, sql: &str) -> Result<Vec<Row>> {\n        let conn = self.get_connection().await;\n        conn.query(sql).await\n    }\n}\n```\n\n## Resource Cleanup with Drop\n\nEnsure cleanup even on task cancellation:\n\n```rust\npub struct Resource {\n    handle: SomeHandle,\n}\n\nimpl Resource {\n    pub async fn new() -> Self {\n        Self {\n            handle: acquire_resource().await,\n        }\n    }\n\n    pub async fn use_resource(&self) -> Result<()> {\n        // Use the resource\n        Ok(())\n    }\n}\n\nimpl Drop for Resource {\n    fn drop(&mut self) {\n        // Synchronous cleanup\n        // For async cleanup, use a separate shutdown method\n        self.handle.close();\n    }\n}\n\n// For async cleanup\nimpl Resource {\n    pub async fn shutdown(self) {\n        // Async cleanup\n        self.handle.close_async().await;\n    }\n}\n```\n\n## Select Multiple Futures\n\nUse `select!` to race multiple operations:\n\n```rust\nuse tokio::select;\n\npub async fn select_example() {\n    let mut rx1 = channel1();\n    let mut rx2 = channel2();\n\n    loop {\n        select! {\n            msg = rx1.recv() => {\n                if let Some(msg) = msg {\n                    handle_channel1(msg).await;\n                } else {\n                    break;\n                }\n            }\n            msg = rx2.recv() => {\n                if let Some(msg) = msg {\n                    handle_channel2(msg).await;\n                } else {\n                    break;\n                }\n            }\n            _ = tokio::time::sleep(Duration::from_secs(60)) => {\n                check_timeout().await;\n            }\n        }\n    }\n}\n```\n\n## Cancellation Token Pattern\n\nUse `tokio_util::sync::CancellationToken` for cooperative cancellation:\n\n```rust\nuse tokio_util::sync::CancellationToken;\n\npub async fn worker(token: CancellationToken) {\n    loop {\n        tokio::select! {\n            _ = token.cancelled() => {\n                // Cleanup\n                break;\n            }\n            _ = do_work() => {\n                // Continue\n            }\n        }\n    }\n}\n\n// Hierarchical cancellation\nlet parent_token = CancellationToken::new();\nlet child_token = parent_token.child_token();\n\ntokio::spawn(worker(child_token));\n\n// Cancel all\nparent_token.cancel();\n```\n\n## Best Practices\n\n1. **Use semaphores** for limiting concurrent operations\n2. **Implement graceful shutdown** in all long-running tasks\n3. **Add timeouts** to external operations\n4. **Use channels** for inter-task communication\n5. **Handle cancellation** properly in all tasks\n6. **Clean up resources** in Drop or explicit shutdown methods\n7. **Use appropriate channel types** for different patterns\n8. **Implement retries** for transient failures\n9. **Use select!** for coordinating multiple async operations\n10. **Document lifetime** and ownership patterns clearly"
              },
              {
                "name": "tokio-troubleshooting",
                "description": "Debugging and troubleshooting Tokio applications using tokio-console, detecting deadlocks, memory leaks, and performance issues. Use when diagnosing async runtime problems.",
                "path": "plugins/rust-tokio-expert/skills/tokio-troubleshooting/SKILL.md",
                "frontmatter": {
                  "name": "tokio-troubleshooting",
                  "description": "Debugging and troubleshooting Tokio applications using tokio-console, detecting deadlocks, memory leaks, and performance issues. Use when diagnosing async runtime problems."
                },
                "content": "# Tokio Troubleshooting\n\nThis skill provides techniques for debugging and troubleshooting async applications built with Tokio.\n\n## Using tokio-console for Runtime Inspection\n\nMonitor async runtime in real-time:\n\n```rust\n// In Cargo.toml\n[dependencies]\nconsole-subscriber = \"0.2\"\n\n// In main.rs\nfn main() {\n    console_subscriber::init();\n\n    tokio::runtime::Builder::new_multi_thread()\n        .enable_all()\n        .build()\n        .unwrap()\n        .block_on(async {\n            run_application().await\n        });\n}\n```\n\n**Run console in separate terminal:**\n```bash\ntokio-console\n```\n\n**Key metrics to monitor:**\n- Task spawn rate and total tasks\n- Poll duration per task\n- Idle vs. busy time\n- Waker operations\n- Resource utilization\n\n**Identifying issues:**\n- Long poll durations: CPU-intensive work in async context\n- Many wakers: Potential contention or inefficient polling\n- Growing task count: Task leak or unbounded spawning\n- High idle time: Not enough work or blocking operations\n\n## Debugging Deadlocks and Hangs\n\nDetect and resolve deadlock situations:\n\n### Common Deadlock Pattern\n\n```rust\n// BAD: Potential deadlock\nasync fn deadlock_example() {\n    let mutex1 = Arc::new(Mutex::new(()));\n    let mutex2 = Arc::new(Mutex::new(()));\n\n    let m1 = mutex1.clone();\n    let m2 = mutex2.clone();\n    tokio::spawn(async move {\n        let _g1 = m1.lock().await;\n        tokio::time::sleep(Duration::from_millis(10)).await;\n        let _g2 = m2.lock().await; // May deadlock\n    });\n\n    let _g2 = mutex2.lock().await;\n    tokio::time::sleep(Duration::from_millis(10)).await;\n    let _g1 = mutex1.lock().await; // May deadlock\n}\n\n// GOOD: Consistent lock ordering\nasync fn no_deadlock_example() {\n    let mutex1 = Arc::new(Mutex::new(()));\n    let mutex2 = Arc::new(Mutex::new(()));\n\n    // Always acquire locks in same order\n    let _g1 = mutex1.lock().await;\n    let _g2 = mutex2.lock().await;\n}\n\n// BETTER: Avoid nested locks\nasync fn best_example() {\n    // Use message passing instead\n    let (tx, mut rx) = mpsc::channel(10);\n\n    tokio::spawn(async move {\n        while let Some(msg) = rx.recv().await {\n            process_message(msg).await;\n        }\n    });\n\n    tx.send(message).await.unwrap();\n}\n```\n\n### Detecting Hangs with Timeouts\n\n```rust\nuse tokio::time::{timeout, Duration};\n\nasync fn detect_hang() {\n    match timeout(Duration::from_secs(5), potentially_hanging_operation()).await {\n        Ok(result) => println!(\"Completed: {:?}\", result),\n        Err(_) => {\n            eprintln!(\"Operation timed out - potential hang detected\");\n            // Log stack traces, metrics, etc.\n        }\n    }\n}\n```\n\n### Deadlock Detection with try_lock\n\n```rust\nuse tokio::sync::Mutex;\n\nasync fn try_with_timeout(mutex: &Mutex<State>) -> Option<State> {\n    for _ in 0..10 {\n        if let Ok(guard) = mutex.try_lock() {\n            return Some(guard.clone());\n        }\n        tokio::time::sleep(Duration::from_millis(10)).await;\n    }\n    eprintln!(\"Failed to acquire lock - possible deadlock\");\n    None\n}\n```\n\n## Memory Leak Detection\n\nIdentify and fix memory leaks:\n\n### Task Leaks\n\n```rust\n// BAD: Tasks never complete\nasync fn leaking_tasks() {\n    loop {\n        tokio::spawn(async {\n            loop {\n                // Never exits\n                tokio::time::sleep(Duration::from_secs(1)).await;\n            }\n        });\n    }\n}\n\n// GOOD: Tasks have exit condition\nasync fn proper_tasks(shutdown: broadcast::Receiver<()>) {\n    loop {\n        let mut shutdown_rx = shutdown.resubscribe();\n        tokio::spawn(async move {\n            loop {\n                tokio::select! {\n                    _ = shutdown_rx.recv() => break,\n                    _ = tokio::time::sleep(Duration::from_secs(1)) => {\n                        // Work\n                    }\n                }\n            }\n        });\n    }\n}\n```\n\n### Arc Cycles\n\n```rust\n// BAD: Reference cycle\nstruct Node {\n    next: Option<Arc<Mutex<Node>>>,\n    prev: Option<Arc<Mutex<Node>>>, // Creates cycle!\n}\n\n// GOOD: Use weak references\nuse std::sync::Weak;\n\nstruct Node {\n    next: Option<Arc<Mutex<Node>>>,\n    prev: Option<Weak<Mutex<Node>>>, // Weak reference breaks cycle\n}\n```\n\n### Monitoring Memory Usage\n\n```rust\nuse sysinfo::{System, SystemExt};\n\npub async fn memory_monitor() {\n    let mut system = System::new_all();\n    let mut interval = tokio::time::interval(Duration::from_secs(60));\n\n    loop {\n        interval.tick().await;\n        system.refresh_memory();\n\n        let used = system.used_memory();\n        let total = system.total_memory();\n        let percent = (used as f64 / total as f64) * 100.0;\n\n        tracing::info!(\n            used_mb = used / 1024 / 1024,\n            total_mb = total / 1024 / 1024,\n            percent = %.2 percent,\n            \"Memory usage\"\n        );\n\n        if percent > 80.0 {\n            tracing::warn!(\"High memory usage detected\");\n        }\n    }\n}\n```\n\n## Performance Profiling with Tracing\n\nInstrument code for performance analysis:\n\n```rust\nuse tracing::{info, instrument, span, Level};\n\n#[instrument]\nasync fn process_request(id: u64) -> Result<Response, Error> {\n    let span = span!(Level::INFO, \"database_query\");\n    let _enter = span.enter();\n\n    let data = fetch_from_database(id).await?;\n\n    drop(_enter);\n\n    let span = span!(Level::INFO, \"transformation\");\n    let _enter = span.enter();\n\n    let result = transform_data(data).await?;\n\n    Ok(Response { result })\n}\n\n// Configure subscriber for flame graphs\nuse tracing_subscriber::layer::SubscriberExt;\n\nfn init_tracing() {\n    let fmt_layer = tracing_subscriber::fmt::layer();\n    let filter_layer = tracing_subscriber::EnvFilter::from_default_env();\n\n    tracing_subscriber::registry()\n        .with(filter_layer)\n        .with(fmt_layer)\n        .init();\n}\n```\n\n## Understanding Panic Messages\n\nCommon async panic patterns:\n\n### Panics in Spawned Tasks\n\n```rust\n// Panic is isolated to the task\ntokio::spawn(async {\n    panic!(\"This won't crash the program\");\n});\n\n// To catch panics\nlet handle = tokio::spawn(async {\n    // Work that might panic\n});\n\nmatch handle.await {\n    Ok(result) => println!(\"Success: {:?}\", result),\n    Err(e) if e.is_panic() => {\n        eprintln!(\"Task panicked: {:?}\", e);\n        // Handle panic\n    }\n    Err(e) => eprintln!(\"Task cancelled: {:?}\", e),\n}\n```\n\n### Send + 'static Errors\n\n```rust\n// ERROR: future cannot be sent between threads\nasync fn bad_example() {\n    let rc = Rc::new(5); // Rc is !Send\n    tokio::spawn(async move {\n        println!(\"{}\", rc); // Error!\n    });\n}\n\n// FIX: Use Arc instead\nasync fn good_example() {\n    let rc = Arc::new(5); // Arc is Send\n    tokio::spawn(async move {\n        println!(\"{}\", rc); // OK\n    });\n}\n\n// ERROR: borrowed value does not live long enough\nasync fn lifetime_error() {\n    let data = String::from(\"hello\");\n    tokio::spawn(async {\n        println!(\"{}\", data); // Error: data might not live long enough\n    });\n}\n\n// FIX: Move ownership\nasync fn lifetime_fixed() {\n    let data = String::from(\"hello\");\n    tokio::spawn(async move {\n        println!(\"{}\", data); // OK: data is moved\n    });\n}\n```\n\n## Common Error Patterns and Solutions\n\n### Blocking in Async Context\n\n```rust\n// PROBLEM: Detected with tokio-console (long poll time)\nasync fn blocking_example() {\n    std::thread::sleep(Duration::from_secs(1)); // Blocks thread!\n}\n\n// SOLUTION\nasync fn non_blocking_example() {\n    tokio::time::sleep(Duration::from_secs(1)).await; // Yields control\n}\n\n// For unavoidable blocking\nasync fn necessary_blocking() {\n    tokio::task::spawn_blocking(|| {\n        expensive_cpu_work()\n    }).await.unwrap();\n}\n```\n\n### Channel Closed Errors\n\n```rust\n// PROBLEM: SendError because receiver dropped\nasync fn send_error_example() {\n    let (tx, rx) = mpsc::channel(10);\n    drop(rx); // Receiver dropped\n\n    match tx.send(42).await {\n        Ok(_) => println!(\"Sent\"),\n        Err(e) => eprintln!(\"Send failed: {}\", e), // Channel closed\n    }\n}\n\n// SOLUTION: Check if receiver exists\nasync fn handle_closed_channel() {\n    let (tx, rx) = mpsc::channel(10);\n\n    tokio::spawn(async move {\n        // Receiver keeps channel open\n        while let Some(msg) = rx.recv().await {\n            process(msg).await;\n        }\n    });\n\n    // Or handle the error\n    if let Err(e) = tx.send(42).await {\n        tracing::warn!(\"Channel closed: {}\", e);\n        // Cleanup or alternative action\n    }\n}\n```\n\n### Task Cancellation\n\n```rust\n// PROBLEM: Task cancelled unexpectedly\nlet handle = tokio::spawn(async {\n    // Long-running work\n});\n\nhandle.abort(); // Cancels task\n\n// SOLUTION: Handle cancellation gracefully\nlet handle = tokio::spawn(async {\n    let result = tokio::select! {\n        result = do_work() => result,\n        _ = tokio::signal::ctrl_c() => {\n            cleanup().await;\n            return Err(Error::Cancelled);\n        }\n    };\n    result\n});\n```\n\n## Testing Async Code Effectively\n\nWrite reliable async tests:\n\n```rust\n#[tokio::test]\nasync fn test_with_timeout() {\n    tokio::time::timeout(\n        Duration::from_secs(5),\n        async {\n            let result = my_async_function().await;\n            assert!(result.is_ok());\n        }\n    )\n    .await\n    .expect(\"Test timed out\");\n}\n\n#[tokio::test]\nasync fn test_concurrent_access() {\n    let shared = Arc::new(Mutex::new(0));\n\n    let handles: Vec<_> = (0..10)\n        .map(|_| {\n            let shared = shared.clone();\n            tokio::spawn(async move {\n                let mut lock = shared.lock().await;\n                *lock += 1;\n            })\n        })\n        .collect();\n\n    for handle in handles {\n        handle.await.unwrap();\n    }\n\n    assert_eq!(*shared.lock().await, 10);\n}\n\n// Test with mocked time\n#[tokio::test(start_paused = true)]\nasync fn test_with_time_control() {\n    let start = tokio::time::Instant::now();\n\n    tokio::time::sleep(Duration::from_secs(100)).await;\n\n    // Time is mocked, so this completes instantly\n    assert!(start.elapsed() < Duration::from_secs(1));\n}\n```\n\n## Debugging Checklist\n\nWhen troubleshooting async issues:\n\n- [ ] Use tokio-console to monitor runtime behavior\n- [ ] Check for blocking operations with tracing\n- [ ] Verify all locks are released properly\n- [ ] Look for task leaks (growing task count)\n- [ ] Monitor memory usage over time\n- [ ] Add timeouts to detect hangs\n- [ ] Check for channel closure errors\n- [ ] Verify Send + 'static bounds are satisfied\n- [ ] Use try_lock to detect potential deadlocks\n- [ ] Profile with tracing for performance bottlenecks\n- [ ] Test with tokio-test for time-based code\n- [ ] Check for Arc cycles with weak references\n\n## Helpful Tools\n\n- **tokio-console**: Real-time async runtime monitoring\n- **tracing**: Structured logging and profiling\n- **cargo-flamegraph**: Generate flame graphs\n- **valgrind/heaptrack**: Memory profiling\n- **perf**: CPU profiling on Linux\n- **Instruments**: Profiling on macOS\n\n## Best Practices\n\n1. **Always use tokio-console** in development\n2. **Add tracing spans** to critical code paths\n3. **Use timeouts** liberally to detect hangs\n4. **Monitor task count** for leaks\n5. **Profile before optimizing** - measure first\n6. **Test with real concurrency** - don't just test happy paths\n7. **Handle cancellation** gracefully in all tasks\n8. **Use structured logging** for debugging\n9. **Avoid nested locks** - prefer message passing\n10. **Document lock ordering** when necessary"
              }
            ]
          },
          {
            "name": "rust-cli-developer",
            "description": "Experienced Rust developer with expertise in building delightful CLI applications using Clap and the Rust CLI ecosystem",
            "source": "./plugins/rust-cli-developer",
            "category": "languages",
            "version": "1.0.0",
            "author": {
              "name": "Geoff Johnson",
              "url": "https://github.com/geoffjay"
            },
            "install_commands": [
              "/plugin marketplace add geoffjay/claude-plugins",
              "/plugin install rust-cli-developer@geoffjay-claude-plugins"
            ],
            "signals": {
              "stars": 4,
              "forks": 1,
              "pushed_at": "2025-11-04T20:23:37Z",
              "created_at": "2025-10-17T18:24:21Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/cli-enhance",
                "description": "Add features to existing CLI applications like colors, progress bars, shell completions, and better error messages",
                "path": "plugins/rust-cli-developer/commands/cli-enhance.md",
                "frontmatter": {
                  "name": "cli-enhance",
                  "description": "Add features to existing CLI applications like colors, progress bars, shell completions, and better error messages"
                },
                "content": "# CLI Enhance Command\n\nAdd modern CLI features to an existing Rust CLI application, including colors, progress bars, interactive prompts, shell completions, and beautiful error messages.\n\n## Arguments\n\n- `$1` - Feature to add: \"colors\", \"progress\", \"prompts\", \"completions\", \"errors\", \"config\", \"logging\", or \"all\" (required)\n- `$2` - Path to project directory (optional, defaults to current directory)\n\n## Usage\n\n```bash\n# Add all enhancements\n/cli-enhance all\n\n# Add specific feature\n/cli-enhance colors\n/cli-enhance progress\n/cli-enhance completions\n\n# Enhance specific project\n/cli-enhance colors /path/to/my-cli\n```\n\n## Available Enhancements\n\n### 1. Colors and Styling\n\nAdd semantic colors to CLI output using owo-colors.\n\n**What Gets Added:**\n\n- Dependency: `owo-colors`\n- Dependency: `supports-color` (for detection)\n- Color module with semantic helpers\n- NO_COLOR environment variable support\n- Terminal capability detection\n\n**Example Implementation:**\n\n```rust\n// src/colors.rs\nuse owo_colors::{OwoColorize, Stream};\n\npub fn success(message: &str) {\n    println!(\n        \"{} {}\",\n        \"✓\".if_supports_color(Stream::Stdout, |text| text.green().bold()),\n        message\n    );\n}\n\npub fn error(message: &str) {\n    eprintln!(\n        \"{} {}\",\n        \"✗\".if_supports_color(Stream::Stderr, |text| text.red().bold()),\n        message\n    );\n}\n\npub fn warning(message: &str) {\n    println!(\n        \"{} {}\",\n        \"⚠\".if_supports_color(Stream::Stdout, |text| text.yellow().bold()),\n        message\n    );\n}\n\npub fn info(message: &str) {\n    println!(\n        \"{} {}\",\n        \"ℹ\".if_supports_color(Stream::Stdout, |text| text.blue().bold()),\n        message\n    );\n}\n\npub fn supports_color() -> bool {\n    use supports_color::Stream as ColorStream;\n    supports_color::on(ColorStream::Stdout).is_some()\n}\n```\n\n**Usage in Code:**\n\n```rust\nuse crate::colors;\n\ncolors::success(\"Build completed!\");\ncolors::error(\"Failed to read file\");\ncolors::warning(\"Configuration incomplete\");\ncolors::info(\"Processing 10 files\");\n```\n\n### 2. Progress Bars and Spinners\n\nAdd visual feedback for long-running operations using indicatif.\n\n**What Gets Added:**\n\n- Dependency: `indicatif`\n- Progress module with common patterns\n- Spinner for indeterminate operations\n- Progress bars with custom styling\n- Multi-progress for parallel tasks\n\n**Example Implementation:**\n\n```rust\n// src/progress.rs\nuse indicatif::{ProgressBar, ProgressStyle, MultiProgress, HumanDuration};\nuse std::time::Duration;\n\npub fn create_progress_bar(total: u64) -> ProgressBar {\n    let pb = ProgressBar::new(total);\n    pb.set_style(\n        ProgressStyle::default_bar()\n            .template(\"{spinner:.green} [{elapsed_precise}] [{bar:40.cyan/blue}] {pos}/{len} ({eta})\")\n            .unwrap()\n            .progress_chars(\"#>-\")\n    );\n    pb\n}\n\npub fn create_spinner(message: &str) -> ProgressBar {\n    let spinner = ProgressBar::new_spinner();\n    spinner.set_style(\n        ProgressStyle::default_spinner()\n            .template(\"{spinner:.green} {msg}\")\n            .unwrap()\n            .tick_strings(&[\"⠋\", \"⠙\", \"⠹\", \"⠸\", \"⠼\", \"⠴\", \"⠦\", \"⠧\", \"⠇\", \"⠏\"])\n    );\n    spinner.set_message(message.to_string());\n    spinner\n}\n\npub fn create_multi_progress() -> MultiProgress {\n    MultiProgress::new()\n}\n```\n\n**Usage in Code:**\n\n```rust\nuse crate::progress;\n\n// Progress bar for known total\nlet pb = progress::create_progress_bar(100);\nfor i in 0..100 {\n    // Do work\n    pb.inc(1);\n}\npb.finish_with_message(\"Complete!\");\n\n// Spinner for unknown duration\nlet spinner = progress::create_spinner(\"Processing...\");\n// Do work\nspinner.finish_with_message(\"Done!\");\n```\n\n### 3. Interactive Prompts\n\nAdd user-friendly interactive prompts using dialoguer.\n\n**What Gets Added:**\n\n- Dependency: `dialoguer`\n- Prompts module with common patterns\n- Confirmation prompts\n- Text input with validation\n- Selection menus\n- Multi-select options\n\n**Example Implementation:**\n\n```rust\n// src/prompts.rs\nuse dialoguer::{\n    Confirm, Input, Select, MultiSelect, Password,\n    theme::ColorfulTheme\n};\nuse anyhow::Result;\n\npub fn confirm(prompt: &str, default: bool) -> Result<bool> {\n    Ok(Confirm::with_theme(&ColorfulTheme::default())\n        .with_prompt(prompt)\n        .default(default)\n        .interact()?)\n}\n\npub fn input(prompt: &str, default: Option<String>) -> Result<String> {\n    let mut input = Input::with_theme(&ColorfulTheme::default())\n        .with_prompt(prompt);\n\n    if let Some(d) = default {\n        input = input.default(d);\n    }\n\n    Ok(input.interact_text()?)\n}\n\npub fn select<T: ToString>(prompt: &str, items: &[T]) -> Result<usize> {\n    Ok(Select::with_theme(&ColorfulTheme::default())\n        .with_prompt(prompt)\n        .items(items)\n        .interact()?)\n}\n\npub fn multi_select<T: ToString>(prompt: &str, items: &[T]) -> Result<Vec<usize>> {\n    Ok(MultiSelect::with_theme(&ColorfulTheme::default())\n        .with_prompt(prompt)\n        .items(items)\n        .interact()?)\n}\n\npub fn password(prompt: &str, confirm: bool) -> Result<String> {\n    if confirm {\n        Ok(Password::with_theme(&ColorfulTheme::default())\n            .with_prompt(prompt)\n            .with_confirmation(\"Confirm password\", \"Passwords don't match\")\n            .interact()?)\n    } else {\n        Ok(Password::with_theme(&ColorfulTheme::default())\n            .with_prompt(prompt)\n            .interact()?)\n    }\n}\n```\n\n**Usage in Code:**\n\n```rust\nuse crate::prompts;\n\n// Confirmation\nif prompts::confirm(\"Continue with deployment?\", false)? {\n    deploy()?;\n}\n\n// Text input\nlet name = prompts::input(\"Project name\", Some(\"my-project\".to_string()))?;\n\n// Selection\nlet envs = vec![\"dev\", \"staging\", \"production\"];\nlet idx = prompts::select(\"Select environment\", &envs)?;\n```\n\n### 4. Shell Completions\n\nAdd shell completion generation support.\n\n**What Gets Added:**\n\n- Dependency: `clap_complete`\n- Completion generation command\n- Support for bash, zsh, fish, powershell\n- Installation instructions\n\n**Example Implementation:**\n\n```rust\n// src/completions.rs\nuse clap::CommandFactory;\nuse clap_complete::{generate, Generator, Shell};\nuse std::io;\n\npub fn generate_completions<G: Generator>(gen: G) {\n    let mut cmd = crate::cli::Cli::command();\n    generate(gen, &mut cmd, cmd.get_name().to_string(), &mut io::stdout());\n}\n\npub fn print_install_instructions(shell: Shell) {\n    match shell {\n        Shell::Bash => {\n            eprintln!(\"To install completions, add to ~/.bashrc:\");\n            eprintln!(\"  eval \\\"$(myapp --generate bash)\\\"\");\n        }\n        Shell::Zsh => {\n            eprintln!(\"To install completions, add to ~/.zshrc:\");\n            eprintln!(\"  eval \\\"$(myapp --generate zsh)\\\"\");\n        }\n        Shell::Fish => {\n            eprintln!(\"To install completions:\");\n            eprintln!(\"  myapp --generate fish | source\");\n            eprintln!(\"  Or save to: ~/.config/fish/completions/myapp.fish\");\n        }\n        Shell::PowerShell => {\n            eprintln!(\"To install completions, add to $PROFILE:\");\n            eprintln!(\"  Invoke-Expression (& myapp --generate powershell)\");\n        }\n        _ => {}\n    }\n}\n```\n\n**Add to CLI:**\n\n```rust\n// src/cli.rs\nuse clap::{Parser, ValueEnum};\n\n#[derive(Parser)]\npub struct Cli {\n    /// Generate shell completions\n    #[arg(long = \"generate\", value_enum)]\n    pub generate: Option<Shell>,\n\n    // ... other fields\n}\n\n#[derive(ValueEnum, Clone)]\npub enum Shell {\n    Bash,\n    Zsh,\n    Fish,\n    PowerShell,\n}\n```\n\n### 5. Beautiful Error Messages\n\nUpgrade error handling with miette for rich diagnostics.\n\n**What Gets Added:**\n\n- Dependency: `miette` with `fancy` feature\n- Structured error types\n- Source code snippets in errors\n- Help text and suggestions\n- Error URLs\n\n**Example Implementation:**\n\n```rust\n// src/error.rs\nuse miette::{Diagnostic, SourceSpan};\nuse thiserror::Error;\n\n#[derive(Error, Debug, Diagnostic)]\n#[error(\"Configuration error\")]\n#[diagnostic(\n    code(config::invalid),\n    url(\"https://example.com/docs/config\"),\n    help(\"Check your configuration file syntax\")\n)]\npub struct ConfigError {\n    #[source_code]\n    pub src: String,\n\n    #[label(\"this field is invalid\")]\n    pub span: SourceSpan,\n\n    #[help]\n    pub advice: Option<String>,\n}\n\n#[derive(Error, Debug, Diagnostic)]\npub enum AppError {\n    #[error(\"File not found: {path}\")]\n    #[diagnostic(\n        code(app::file_not_found),\n        help(\"Check that the file exists and you have permission to read it\")\n    )]\n    FileNotFound {\n        path: String,\n    },\n\n    #[error(\"Build failed\")]\n    #[diagnostic(\n        code(app::build_failed),\n        help(\"Run with -vv for detailed logs\")\n    )]\n    BuildFailed {\n        #[source]\n        source: anyhow::Error,\n    },\n}\n```\n\n**Update main.rs:**\n\n```rust\nfn main() -> miette::Result<()> {\n    miette::set_panic_hook();\n\n    // Rest of application\n}\n```\n\n### 6. Configuration Management\n\nAdd comprehensive configuration system.\n\n**What Gets Added:**\n\n- Dependency: `config`\n- Dependency: `serde`\n- Dependency: `toml`\n- Dependency: `directories`\n- Config module with precedence handling\n- XDG directory support\n- Environment variable support\n\n**Example Implementation:**\n\n```rust\n// src/config.rs\nuse config::{Config as ConfigBuilder, Environment, File};\nuse directories::ProjectDirs;\nuse serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\nuse anyhow::Result;\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct Config {\n    pub general: General,\n    pub features: Features,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct General {\n    pub log_level: String,\n    pub timeout: u64,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct Features {\n    pub colors: bool,\n    pub progress: bool,\n}\n\nimpl Config {\n    pub fn load(cli_config: Option<PathBuf>) -> Result<Self> {\n        let mut builder = ConfigBuilder::builder()\n            .set_default(\"general.log_level\", \"info\")?\n            .set_default(\"general.timeout\", 30)?\n            .set_default(\"features.colors\", true)?\n            .set_default(\"features.progress\", true)?;\n\n        // Load from standard locations\n        if let Some(proj_dirs) = ProjectDirs::from(\"com\", \"example\", \"myapp\") {\n            let config_dir = proj_dirs.config_dir();\n            builder = builder\n                .add_source(File::from(config_dir.join(\"config.toml\")).required(false));\n        }\n\n        // Override with CLI-specified config\n        if let Some(path) = cli_config {\n            builder = builder.add_source(File::from(path));\n        }\n\n        // Environment variables override everything\n        builder = builder.add_source(\n            Environment::with_prefix(\"MYAPP\")\n                .separator(\"_\")\n                .try_parsing(true)\n        );\n\n        Ok(builder.build()?.try_deserialize()?)\n    }\n\n    pub fn write_default(path: &PathBuf) -> Result<()> {\n        let default = Config {\n            general: General {\n                log_level: \"info\".to_string(),\n                timeout: 30,\n            },\n            features: Features {\n                colors: true,\n                progress: true,\n            },\n        };\n\n        let toml = toml::to_string_pretty(&default)?;\n        std::fs::write(path, toml)?;\n        Ok(())\n    }\n}\n```\n\n### 7. Structured Logging\n\nAdd tracing-based structured logging.\n\n**What Gets Added:**\n\n- Dependency: `tracing`\n- Dependency: `tracing-subscriber`\n- Logging module with verbosity support\n- Structured logging macros\n\n**Example Implementation:**\n\n```rust\n// src/logging.rs\nuse tracing_subscriber::{fmt, prelude::*, EnvFilter};\nuse anyhow::Result;\n\npub fn setup(verbosity: u8) -> Result<()> {\n    let level = match verbosity {\n        0 => \"error\",\n        1 => \"warn\",\n        2 => \"info\",\n        3 => \"debug\",\n        _ => \"trace\",\n    };\n\n    let env_filter = EnvFilter::try_from_default_env()\n        .or_else(|_| EnvFilter::try_new(level))?;\n\n    tracing_subscriber::registry()\n        .with(fmt::layer().with_target(false).with_level(true))\n        .with(env_filter)\n        .init();\n\n    Ok(())\n}\n```\n\n**Usage:**\n\n```rust\nuse tracing::{info, warn, error, debug};\n\ninfo!(\"Starting build process\");\ndebug!(\"Configuration: {:?}\", config);\nwarn!(\"Using default value for missing field\");\nerror!(\"Build failed: {}\", error);\n```\n\n## Workflow\n\nWhen you invoke this command:\n\n1. **Analyze Current Project**\n   - Detect existing dependencies\n   - Identify CLI framework (Clap version)\n   - Check for existing features\n   - Find integration points\n\n2. **Add Dependencies**\n   - Update Cargo.toml with new dependencies\n   - Add appropriate feature flags\n   - Ensure version compatibility\n\n3. **Generate Code**\n   - Create new modules for features\n   - Add helper functions and patterns\n   - Integrate with existing code\n\n4. **Update Existing Code**\n   - Replace println! with colored output\n   - Add progress bars to long operations\n   - Upgrade error types\n   - Add completion generation to CLI\n\n5. **Add Documentation**\n   - Document new features in README\n   - Add inline code documentation\n   - Provide usage examples\n\n6. **Verify Integration**\n   - Run cargo check\n   - Run tests\n   - Test new features\n\n7. **Generate Report**\n   - List added features\n   - Show usage examples\n   - Provide next steps\n\n## Example Output\n\n```\n✓ Analyzed project structure\n✓ Added dependencies to Cargo.toml\n✓ Created colors module (src/colors.rs)\n✓ Created progress module (src/progress.rs)\n✓ Created prompts module (src/prompts.rs)\n✓ Updated CLI for completions\n✓ Upgraded error types with miette\n✓ Updated 15 call sites with new features\n✓ Added documentation\n\nEnhancements Applied Successfully!\n\nAdded Features:\n  • Colors and styling (owo-colors)\n  • Progress bars and spinners (indicatif)\n  • Interactive prompts (dialoguer)\n  • Shell completions (bash, zsh, fish, powershell)\n  • Beautiful error messages (miette)\n\nNew Dependencies:\n  owo-colors = \"4\"\n  indicatif = \"0.17\"\n  dialoguer = \"0.11\"\n  clap_complete = \"4\"\n  miette = { version = \"7\", features = [\"fancy\"] }\n\nFiles Modified:\n  • Cargo.toml (dependencies added)\n  • src/lib.rs (modules exported)\n  • src/cli.rs (completion flag added)\n  • src/main.rs (error handler updated)\n\nFiles Created:\n  • src/colors.rs\n  • src/progress.rs\n  • src/prompts.rs\n  • src/completions.rs\n\nUpdated Code Locations:\n  • src/commands/build.rs (added progress bar)\n  • src/commands/init.rs (added prompts)\n  • src/error.rs (upgraded to miette)\n\nUsage Examples:\n\nColors:\n  use crate::colors;\n  colors::success(\"Build completed!\");\n  colors::error(\"Failed to read file\");\n\nProgress:\n  use crate::progress;\n  let pb = progress::create_progress_bar(100);\n  pb.inc(1);\n  pb.finish_with_message(\"Done!\");\n\nPrompts:\n  use crate::prompts;\n  if prompts::confirm(\"Continue?\", true)? {\n      // do something\n  }\n\nCompletions:\n  myapp --generate bash > /etc/bash_completion.d/myapp\n  myapp --generate zsh > ~/.zfunc/_myapp\n\nNext Steps:\n  1. Review generated code\n  2. Test new features: cargo run\n  3. Update documentation if needed\n  4. Commit changes: git add . && git commit\n```\n\n## Implementation\n\nUse the appropriate **rust-cli-developer** agents:\n\n```\nUse Task tool with subagent_type=\"rust-cli-developer:cli-ux-specialist\"\nfor colors, progress, and prompts\n\nUse Task tool with subagent_type=\"rust-cli-developer:cli-architect\"\nfor configuration and logging\n\nUse Task tool with subagent_type=\"rust-cli-developer:clap-expert\"\nfor shell completions integration\n```\n\n## Notes\n\n- Enhancements are additive and non-destructive\n- Existing code is updated carefully to maintain functionality\n- Dependencies are added with compatible versions\n- All changes are tested before completion\n- Documentation is updated to reflect new features\n- Backward compatibility is maintained where possible"
              },
              {
                "name": "/cli-review",
                "description": "Review Rust CLI applications for UX, error handling, testing, and cross-platform compatibility",
                "path": "plugins/rust-cli-developer/commands/cli-review.md",
                "frontmatter": {
                  "name": "cli-review",
                  "description": "Review Rust CLI applications for UX, error handling, testing, and cross-platform compatibility"
                },
                "content": "# CLI Review Command\n\nComprehensively review a Rust CLI application for code quality, user experience, error handling, testing coverage, and cross-platform compatibility.\n\n## Arguments\n\n- `$1` - Path to project directory (optional, defaults to current directory)\n- `--focus` - Specific area to focus on: \"ux\", \"errors\", \"tests\", \"config\", \"perf\", or \"all\" (optional, default: \"all\")\n\n## Usage\n\n```bash\n# Review current directory\n/cli-review\n\n# Review specific project\n/cli-review /path/to/my-cli\n\n# Focus on specific area\n/cli-review --focus ux\n/cli-review --focus errors\n/cli-review --focus tests\n```\n\n## Review Areas\n\n### 1. Argument Design & CLI Interface\n\n**Checks:**\n- [ ] Argument naming follows conventions (kebab-case)\n- [ ] Short and long forms provided where appropriate\n- [ ] Help text is clear and descriptive\n- [ ] Defaults are sensible and documented\n- [ ] Mutually exclusive args use proper groups\n- [ ] Required args are clearly marked\n- [ ] Value names are descriptive (FILE, PORT, URL)\n- [ ] Global options work with all subcommands\n- [ ] Version information is present\n\n**Example Issues:**\n\n```\n❌ Issue: Unclear argument name\n   File: src/cli.rs:15\n   Found: #[arg(short, long)]\n          pub x: String,\n\n   Recommendation: Use descriptive names\n   #[arg(short, long, value_name = \"FILE\")]\n   pub input_file: PathBuf,\n```\n\n### 2. Help Text Quality\n\n**Checks:**\n- [ ] Command-level help is present\n- [ ] All arguments have descriptions\n- [ ] Long help provides examples\n- [ ] Help text uses active voice\n- [ ] Complex options have detailed explanations\n- [ ] Examples section shows common usage\n- [ ] After-help provides additional resources\n\n**Example Issues:**\n\n```\n❌ Issue: Missing help text\n   File: src/cli.rs:23\n   Found: #[arg(short, long)]\n          pub verbose: bool,\n\n   Recommendation: Add descriptive help\n   /// Enable verbose output with detailed logging\n   #[arg(short, long)]\n   pub verbose: bool,\n```\n\n### 3. Error Messages\n\n**Checks:**\n- [ ] Errors explain what went wrong\n- [ ] Errors suggest how to fix the problem\n- [ ] File paths are displayed in error messages\n- [ ] Using miette or similar for rich diagnostics\n- [ ] Error types are well-structured (thiserror)\n- [ ] Context is added at each error level\n- [ ] Exit codes are meaningful and documented\n- [ ] Errors go to stderr, not stdout\n\n**Example Issues:**\n\n```\n❌ Issue: Unhelpful error message\n   File: src/commands/build.rs:42\n   Found: bail!(\"Build failed\");\n\n   Recommendation: Provide context and solutions\n   bail!(\n       \"Build failed: {}\\n\\n\\\n        Possible causes:\\n\\\n        - Missing dependencies\\n\\\n        - Invalid configuration\\n\\\n        Try: cargo check\",\n       source\n   );\n```\n\n### 4. User Experience\n\n**Checks:**\n- [ ] Progress indicators for long operations\n- [ ] Colors used semantically (red=error, green=success)\n- [ ] NO_COLOR environment variable respected\n- [ ] Interactive prompts have --yes flag alternative\n- [ ] Destructive operations require confirmation\n- [ ] Output is well-formatted (tables, lists)\n- [ ] Supports both human and machine-readable output\n- [ ] Verbosity levels work correctly (-v, -vv, -vvv)\n\n**Example Issues:**\n\n```\n⚠ Warning: Missing progress indicator\n   File: src/commands/download.rs:30\n   Found: Long-running download operation without feedback\n\n   Recommendation: Add progress bar\n   use indicatif::{ProgressBar, ProgressStyle};\n\n   let pb = ProgressBar::new(total_size);\n   pb.set_style(ProgressStyle::default_bar()...);\n```\n\n### 5. Configuration Management\n\n**Checks:**\n- [ ] Config file support implemented\n- [ ] Environment variables supported\n- [ ] Precedence is correct (defaults < file < env < CLI)\n- [ ] Config file locations follow XDG spec\n- [ ] Command to generate default config\n- [ ] Config validation on load\n- [ ] Sensitive data from env vars only\n- [ ] Config errors are helpful\n\n**Example Issues:**\n\n```\n❌ Issue: No environment variable support\n   File: src/config.rs:15\n   Found: Config only loaded from file\n\n   Recommendation: Support env vars\n   #[arg(long, env = \"MYAPP_DATABASE_URL\")]\n   pub database_url: String,\n```\n\n### 6. Cross-Platform Compatibility\n\n**Checks:**\n- [ ] Path handling uses std::path, not string concat\n- [ ] File permissions checked before use\n- [ ] Line endings handled correctly (CRLF vs LF)\n- [ ] Platform-specific code properly cfg-gated\n- [ ] Terminal width detection\n- [ ] Color support detection\n- [ ] Signal handling (Ctrl+C)\n- [ ] Tests run on all platforms in CI\n\n**Example Issues:**\n\n```\n❌ Issue: Hardcoded path separator\n   File: src/utils.rs:10\n   Found: let path = format!(\"{}/{}\", dir, file);\n\n   Recommendation: Use Path::join\n   let path = Path::new(dir).join(file);\n```\n\n### 7. Testing Coverage\n\n**Checks:**\n- [ ] Integration tests present (assert_cmd)\n- [ ] Help output tested\n- [ ] Error cases tested\n- [ ] Exit codes verified\n- [ ] Config loading tested\n- [ ] Environment variable handling tested\n- [ ] Snapshot tests for output (insta)\n- [ ] Cross-platform tests in CI\n\n**Example Issues:**\n\n```\n⚠ Warning: No integration tests found\n   Expected: tests/integration.rs or tests/cli_tests.rs\n\n   Recommendation: Add integration tests\n   See: https://rust-cli.github.io/book/tutorial/testing.html\n```\n\n### 8. Performance\n\n**Checks:**\n- [ ] Startup time is reasonable (< 100ms for --help)\n- [ ] Binary size is optimized\n- [ ] Lazy loading for heavy dependencies\n- [ ] Streaming for large files\n- [ ] Async runtime only when needed\n- [ ] Proper buffering for I/O\n\n## Review Output Format\n\n```\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nCLI Review Report: my-cli\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\nOverall Rating: B+ (Good)\n\nSummary:\n✓ 23 checks passed\n⚠ 5 warnings\n❌ 3 issues found\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nIssues Found\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n❌ CRITICAL: Missing error context\n   File: src/commands/build.rs:42\n   Line: return Err(e.into());\n\n   Problem: Errors are not wrapped with context\n   Impact: Users won't understand what failed\n\n   Recommendation:\n   return Err(e)\n       .context(\"Failed to build project\")\n       .context(\"Check build configuration\");\n\n   Priority: High\n   Effort: Low\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n⚠ WARNING: No progress indicator\n   File: src/commands/download.rs:55\n\n   Problem: Long operation without user feedback\n   Impact: Poor user experience, appears frozen\n\n   Recommendation:\n   Add indicatif progress bar for downloads\n\n   Priority: Medium\n   Effort: Low\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nStrengths\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n✓ Well-structured CLI with clear subcommands\n✓ Good use of Clap derive API\n✓ Proper error types with thiserror\n✓ Configuration management implemented\n✓ Cross-platform path handling\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nRecommendations\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\nPriority: HIGH\n1. Add error context to all error paths\n2. Implement integration tests\n3. Add --help examples section\n\nPriority: MEDIUM\n4. Add progress indicators for long operations\n5. Implement shell completion generation\n6. Add NO_COLOR support\n\nPriority: LOW\n7. Optimize binary size with strip = true\n8. Add benchmarks for performance testing\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nDetailed Metrics\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\nCode Quality:         ████████░░ 80%\nError Handling:       ██████░░░░ 60%\nUser Experience:      ███████░░░ 70%\nTesting:              ████░░░░░░ 40%\nDocumentation:        ████████░░ 80%\nCross-Platform:       █████████░ 90%\n\nBinary Size:          2.1 MB (Good)\nStartup Time:         45ms (Excellent)\nTest Coverage:        45% (Needs Improvement)\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nNext Steps\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n1. Address critical issues (3 found)\n2. Review and fix warnings (5 found)\n3. Improve test coverage to >70%\n4. Add missing documentation\n\nRun with specific focus:\n  /cli-review --focus errors\n  /cli-review --focus ux\n  /cli-review --focus tests\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n```\n\n## Workflow\n\nWhen you invoke this command:\n\n1. **Analyze Project Structure**\n   - Identify CLI framework (Clap, structopt, etc.)\n   - Locate main entry point and command definitions\n   - Map out module structure\n\n2. **Review CLI Interface**\n   - Parse CLI definitions\n   - Check argument naming and documentation\n   - Verify help text quality\n   - Test help output\n\n3. **Analyze Error Handling**\n   - Review error types\n   - Check error message quality\n   - Verify proper context addition\n   - Test error scenarios\n\n4. **Check User Experience**\n   - Look for progress indicators\n   - Review color usage\n   - Check interactive prompts\n   - Verify output formatting\n\n5. **Examine Configuration**\n   - Review config loading\n   - Check precedence implementation\n   - Verify env var support\n   - Test config validation\n\n6. **Test Cross-Platform Support**\n   - Review path handling\n   - Check platform-specific code\n   - Verify CI configuration\n   - Test on different platforms\n\n7. **Assess Testing**\n   - Count integration tests\n   - Check test coverage\n   - Review test quality\n   - Identify missing tests\n\n8. **Generate Report**\n   - Compile findings\n   - Prioritize issues\n   - Provide recommendations\n   - Calculate metrics\n\n## Implementation\n\nUse the **rust-cli-developer** agents to perform the review:\n\n```\nUse Task tool with subagent_type=\"rust-cli-developer:cli-ux-specialist\"\nfor UX and error message review\n\nUse Task tool with subagent_type=\"rust-cli-developer:cli-testing-expert\"\nfor test coverage analysis\n\nUse Task tool with subagent_type=\"rust-cli-developer:cli-architect\"\nfor architecture and cross-platform review\n\nUse Task tool with subagent_type=\"rust-cli-developer:clap-expert\"\nfor CLI interface review\n```\n\n## Focus Options\n\n### UX Focus\n\nReviews only user experience aspects:\n- Color usage\n- Progress indicators\n- Interactive prompts\n- Output formatting\n- Error messages\n\n### Errors Focus\n\nReviews only error handling:\n- Error types\n- Error messages\n- Context addition\n- Exit codes\n- Recovery strategies\n\n### Tests Focus\n\nReviews only testing:\n- Integration tests\n- Test coverage\n- Test quality\n- Missing test scenarios\n- CI configuration\n\n### Config Focus\n\nReviews only configuration:\n- Config loading\n- Precedence\n- Environment variables\n- Validation\n- Documentation\n\n### Performance Focus\n\nReviews only performance:\n- Startup time\n- Binary size\n- Memory usage\n- I/O efficiency\n- Async usage\n\n## Notes\n\n- Review is non-destructive (read-only analysis)\n- Generates actionable recommendations\n- Prioritizes issues by impact and effort\n- Provides code examples for fixes\n- Can be run in CI for automated checks"
              },
              {
                "name": "/cli-scaffold",
                "description": "Scaffold new Rust CLI projects with Clap, error handling, logging, and testing setup",
                "path": "plugins/rust-cli-developer/commands/cli-scaffold.md",
                "frontmatter": {
                  "name": "cli-scaffold",
                  "description": "Scaffold new Rust CLI projects with Clap, error handling, logging, and testing setup"
                },
                "content": "# CLI Scaffold Command\n\nScaffold a new Rust CLI application with best practices, proper structure, and all necessary dependencies configured.\n\n## Arguments\n\n- `$1` - Project name (required)\n- `$2` - Project type: \"simple\", \"subcommands\", or \"plugin\" (optional, default: \"simple\")\n\n## Usage\n\n```bash\n# Create a simple single-command CLI\n/cli-scaffold my-cli simple\n\n# Create a CLI with subcommands\n/cli-scaffold my-cli subcommands\n\n# Create a CLI with plugin architecture\n/cli-scaffold my-cli plugin\n```\n\n## What Gets Created\n\nThe scaffold creates a complete Rust CLI project with:\n\n### Dependencies\n\n- **clap** (v4+) with derive feature for argument parsing\n- **anyhow** for error handling in application code\n- **thiserror** for library error types\n- **miette** for beautiful error messages with diagnostics\n- **tracing** + **tracing-subscriber** for structured logging\n- **config** for configuration management\n- **directories** for XDG directory support\n- **serde** for configuration serialization\n\n### Project Structure\n\n```\nmy-cli/\n├── Cargo.toml\n├── src/\n│   ├── main.rs          # Entry point\n│   ├── lib.rs           # Library interface\n│   ├── cli.rs           # CLI definitions\n│   ├── commands/        # Command implementations\n│   │   └── mod.rs\n│   ├── config.rs        # Configuration management\n│   ├── error.rs         # Error types\n│   └── logging.rs       # Logging setup\n├── tests/\n│   └── integration.rs   # Integration tests\n├── config/\n│   └── default.toml     # Default configuration\n└── README.md\n```\n\n### Features\n\n1. **Clean architecture** - Library-first design, thin CLI wrapper\n2. **Error handling** - miette for beautiful diagnostics, structured errors\n3. **Logging** - Tracing with verbosity levels (-v, -vv, -vvv)\n4. **Configuration** - TOML config with precedence (defaults < file < env < CLI)\n5. **Testing** - Integration tests with assert_cmd pre-configured\n6. **Shell completions** - Built-in completion generation\n7. **Cross-platform** - Works on Windows, macOS, Linux\n\n## Workflow\n\nWhen you invoke this command:\n\n1. **Gather Information**\n   - Confirm project name\n   - Select project type if not provided\n   - Ask about optional features (async support, additional crates)\n\n2. **Create Project Structure**\n   - Run `cargo init` to create base project\n   - Set up directory structure (src/, tests/, config/)\n   - Create all necessary source files\n\n3. **Configure Dependencies**\n   - Add all required dependencies to Cargo.toml\n   - Configure features appropriately\n   - Set up dev-dependencies for testing\n\n4. **Generate Source Files**\n   - Create main.rs with proper error handling\n   - Set up lib.rs with module exports\n   - Create cli.rs with Clap definitions\n   - Generate command modules based on project type\n   - Set up error types with miette\n   - Configure logging with tracing\n   - Create configuration management code\n\n5. **Add Testing Infrastructure**\n   - Create integration test file\n   - Add example tests for CLI commands\n   - Configure assert_cmd and assert_fs\n\n6. **Documentation**\n   - Generate README.md with usage examples\n   - Add inline documentation to code\n   - Include configuration examples\n\n7. **Finalize**\n   - Run `cargo check` to verify setup\n   - Run `cargo test` to ensure tests pass\n   - Display next steps to user\n\n## Project Type Details\n\n### Simple CLI\n\nSingle command application with arguments and flags.\n\n**Example:**\n\n```rust\n// src/cli.rs\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(name = \"my-cli\")]\n#[command(version, about, long_about = None)]\npub struct Cli {\n    /// Input file\n    #[arg(short, long)]\n    pub input: PathBuf,\n\n    /// Verbosity level\n    #[arg(short, long, action = clap::ArgAction::Count)]\n    pub verbose: u8,\n}\n```\n\n### Subcommands CLI\n\nApplication with multiple subcommands (like git, cargo).\n\n**Example:**\n\n```rust\n// src/cli.rs\nuse clap::{Parser, Subcommand};\n\n#[derive(Parser)]\npub struct Cli {\n    #[arg(short, long, global = true, action = clap::ArgAction::Count)]\n    pub verbose: u8,\n\n    #[command(subcommand)]\n    pub command: Command,\n}\n\n#[derive(Subcommand)]\npub enum Command {\n    Init { name: String },\n    Build { release: bool },\n    Test { filter: Option<String> },\n}\n```\n\n### Plugin-based CLI\n\nExtensible architecture with plugin system.\n\n**Features:**\n- Plugin trait definition\n- Plugin registry\n- Dynamic plugin loading\n- Plugin command routing\n\n## Example Output\n\nAfter running `/cli-scaffold my-cli subcommands`, you'll see:\n\n```\n✓ Created project structure\n✓ Configured dependencies\n✓ Generated source files\n✓ Set up testing infrastructure\n✓ Created documentation\n\nSuccessfully scaffolded 'my-cli'!\n\nProject structure:\n  my-cli/\n  ├── Cargo.toml\n  ├── src/\n  │   ├── main.rs\n  │   ├── lib.rs\n  │   ├── cli.rs\n  │   ├── commands/\n  │   │   ├── mod.rs\n  │   │   ├── init.rs\n  │   │   ├── build.rs\n  │   │   └── test.rs\n  │   ├── config.rs\n  │   ├── error.rs\n  │   └── logging.rs\n  ├── tests/\n  │   └── integration.rs\n  └── README.md\n\nNext steps:\n  cd my-cli\n  cargo build\n  cargo test\n  cargo run -- --help\n\nFeatures included:\n  • Clap v4+ for argument parsing\n  • miette for beautiful error messages\n  • tracing for structured logging\n  • Configuration management (TOML)\n  • Integration tests with assert_cmd\n  • Shell completion generation\n\nTo add your logic:\n  1. Edit src/commands/*.rs to implement commands\n  2. Add tests in tests/integration.rs\n  3. Update config/default.toml if needed\n\nDocumentation:\n  • See README.md for usage examples\n  • Run with --help to see all options\n  • Use RUST_LOG=debug for detailed logs\n```\n\n## Additional Options\n\nYou can customize the scaffold with these options:\n\n- `--async` - Add tokio runtime for async operations\n- `--database` - Add sqlx for database support\n- `--http` - Add reqwest for HTTP client functionality\n- `--template <name>` - Use a custom template\n\n## Implementation\n\nUse the **rust-cli-developer** agent (any of the specialized agents as needed) to:\n\n1. Validate inputs and gather requirements\n2. Generate the complete project structure\n3. Create all source files with proper implementations\n4. Set up testing and documentation\n5. Verify the project builds and tests pass\n\nInvoke the agent with:\n\n```\nUse Task tool with subagent_type=\"rust-cli-developer:cli-architect\"\n```\n\nThe agent will handle all the implementation details and ensure the scaffolded project follows best practices for Rust CLI applications.\n\n## Notes\n\n- Projects are created in the current directory\n- Will fail if directory already exists (safety check)\n- Generated code includes inline documentation\n- All dependencies use latest stable versions\n- Cross-platform compatibility is ensured\n- Follows Rust API guidelines"
              },
              {
                "name": "/cli-test",
                "description": "Generate comprehensive tests for Rust CLI applications including integration, snapshot, and property-based tests",
                "path": "plugins/rust-cli-developer/commands/cli-test.md",
                "frontmatter": {
                  "name": "cli-test",
                  "description": "Generate comprehensive tests for Rust CLI applications including integration, snapshot, and property-based tests"
                },
                "content": "# CLI Test Command\n\nGenerate comprehensive test suites for Rust CLI applications, including integration tests, snapshot tests for output, and property-based tests for input validation.\n\n## Arguments\n\n- `$1` - Test type: \"integration\", \"snapshot\", \"property\", or \"all\" (required)\n- `$2` - Path to project directory (optional, defaults to current directory)\n- `--command <name>` - Specific command to test (optional)\n\n## Usage\n\n```bash\n# Generate all test types\n/cli-test all\n\n# Generate integration tests only\n/cli-test integration\n\n# Generate snapshot tests for specific command\n/cli-test snapshot --command build\n\n# Generate property-based tests\n/cli-test property\n\n# Test specific project\n/cli-test all /path/to/my-cli\n```\n\n## Test Types\n\n### 1. Integration Tests\n\nTests that run the actual CLI binary with different arguments and verify output, exit codes, and side effects.\n\n**Generated Tests:**\n\n```rust\n// tests/integration_tests.rs\nuse assert_cmd::Command;\nuse assert_fs::prelude::*;\nuse predicates::prelude::*;\n\nfn cmd() -> Command {\n    Command::cargo_bin(env!(\"CARGO_PKG_NAME\")).unwrap()\n}\n\n#[test]\nfn test_help_flag() {\n    cmd().arg(\"--help\")\n        .assert()\n        .success()\n        .stdout(predicate::str::contains(\"Usage:\"));\n}\n\n#[test]\nfn test_version_flag() {\n    cmd().arg(\"--version\")\n        .assert()\n        .success()\n        .stdout(predicate::str::contains(env!(\"CARGO_PKG_VERSION\")));\n}\n\n#[test]\nfn test_invalid_argument() {\n    cmd().arg(\"--invalid\")\n        .assert()\n        .failure()\n        .stderr(predicate::str::contains(\"unexpected argument\"));\n}\n\n#[test]\nfn test_missing_required_arg() {\n    cmd().arg(\"build\")\n        .assert()\n        .failure()\n        .stderr(predicate::str::contains(\"required arguments\"));\n}\n\n#[test]\nfn test_command_with_file_io() -> Result<(), Box<dyn std::error::Error>> {\n    let temp = assert_fs::TempDir::new()?;\n    let input = temp.child(\"input.txt\");\n    input.write_str(\"test content\")?;\n\n    let output = temp.child(\"output.txt\");\n\n    cmd()\n        .arg(\"process\")\n        .arg(input.path())\n        .arg(\"--output\")\n        .arg(output.path())\n        .assert()\n        .success();\n\n    output.assert(predicate::path::exists());\n    output.assert(predicate::str::contains(\"TEST CONTENT\"));\n\n    temp.close()?;\n    Ok(())\n}\n\n#[test]\nfn test_exit_code_config_error() {\n    cmd()\n        .arg(\"--config\")\n        .arg(\"/nonexistent/config.toml\")\n        .assert()\n        .code(2)\n        .failure();\n}\n\n#[test]\nfn test_env_var_override() -> Result<(), Box<dyn std::error::Error>> {\n    cmd()\n        .env(\"MYAPP_PORT\", \"9000\")\n        .arg(\"config\")\n        .arg(\"show\")\n        .assert()\n        .success()\n        .stdout(predicate::str::contains(\"9000\"));\n\n    Ok(())\n}\n```\n\n### 2. Snapshot Tests\n\nTests that capture and compare command output to saved snapshots, useful for help text, formatted output, and error messages.\n\n**Generated Tests:**\n\n```rust\n// tests/snapshots.rs\nuse assert_cmd::Command;\nuse insta::{assert_snapshot, with_settings};\n\nfn cmd() -> Command {\n    Command::cargo_bin(env!(\"CARGO_PKG_NAME\")).unwrap()\n}\n\n#[test]\nfn test_help_output() {\n    let output = cmd()\n        .arg(\"--help\")\n        .output()\n        .unwrap();\n\n    assert_snapshot!(String::from_utf8_lossy(&output.stdout));\n}\n\n#[test]\nfn test_command_help() {\n    let output = cmd()\n        .arg(\"build\")\n        .arg(\"--help\")\n        .output()\n        .unwrap();\n\n    assert_snapshot!(\"build_help\", String::from_utf8_lossy(&output.stdout));\n}\n\n#[test]\nfn test_version_output() {\n    let output = cmd()\n        .arg(\"--version\")\n        .output()\n        .unwrap();\n\n    assert_snapshot!(String::from_utf8_lossy(&output.stdout));\n}\n\n#[test]\nfn test_error_message_format() {\n    let output = cmd()\n        .arg(\"build\")\n        .arg(\"--invalid-option\")\n        .output()\n        .unwrap();\n\n    assert_snapshot!(String::from_utf8_lossy(&output.stderr));\n}\n\n#[test]\nfn test_formatted_output_with_filters() {\n    let output = cmd()\n        .arg(\"status\")\n        .output()\n        .unwrap();\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n\n    // Filter out timestamps and dynamic data\n    with_settings!({\n        filters => vec![\n            (r\"\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\", \"[TIMESTAMP]\"),\n            (r\"Duration: \\d+ms\", \"Duration: [TIME]\"),\n            (r\"/[^\\s]+/([^/\\s]+)\", \"/path/to/$1\"),\n        ]\n    }, {\n        assert_snapshot!(stdout);\n    });\n}\n\n#[test]\nfn test_table_output() -> Result<(), Box<dyn std::error::Error>> {\n    let output = cmd()\n        .arg(\"list\")\n        .output()?;\n\n    with_settings!({\n        filters => vec![\n            (r\"\\d{4}-\\d{2}-\\d{2}\", \"[DATE]\"),\n        ]\n    }, {\n        assert_snapshot!(String::from_utf8_lossy(&output.stdout));\n    });\n\n    Ok(())\n}\n```\n\n### 3. Property-Based Tests\n\nTests that verify CLI behavior across a wide range of inputs using property-based testing.\n\n**Generated Tests:**\n\n```rust\n// tests/property_tests.rs\nuse assert_cmd::Command;\nuse proptest::prelude::*;\n\nfn cmd() -> Command {\n    Command::cargo_bin(env!(\"CARGO_PKG_NAME\")).unwrap()\n}\n\nproptest! {\n    #[test]\n    fn test_port_validation(port in 0u16..=65535) {\n        let result = cmd()\n            .arg(\"--port\")\n            .arg(port.to_string())\n            .arg(\"validate\")\n            .output()\n            .unwrap();\n\n        if (1024..=65535).contains(&port) {\n            assert!(result.status.success(),\n                \"Port {} should be valid\", port);\n        } else {\n            assert!(!result.status.success(),\n                \"Port {} should be invalid\", port);\n        }\n    }\n\n    #[test]\n    fn test_string_input_handling(s in \"\\\\PC{0,100}\") {\n        // CLI should handle any valid Unicode string without panicking\n        let result = cmd()\n            .arg(\"--name\")\n            .arg(&s)\n            .arg(\"test\")\n            .output();\n\n        // Should not panic, even if it returns an error\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_file_path_handling(\n        parts in prop::collection::vec(\"[a-zA-Z0-9_-]{1,10}\", 1..5)\n    ) {\n        let path = parts.join(\"/\");\n\n        let _result = cmd()\n            .arg(\"--path\")\n            .arg(&path)\n            .output()\n            .unwrap();\n\n        // Should handle various path structures without panicking\n    }\n\n    #[test]\n    fn test_numeric_range_validation(n in -1000i32..1000i32) {\n        let result = cmd()\n            .arg(\"--count\")\n            .arg(n.to_string())\n            .output()\n            .unwrap();\n\n        if n >= 0 {\n            assert!(result.status.success() ||\n                String::from_utf8_lossy(&result.stderr).contains(\"out of range\"),\n                \"Non-negative number should be handled\");\n        } else {\n            assert!(!result.status.success(),\n                \"Negative number should be rejected\");\n        }\n    }\n\n    #[test]\n    fn test_list_argument(items in prop::collection::vec(\"[a-z]{3,8}\", 0..10)) {\n        let result = cmd()\n            .arg(\"process\")\n            .args(&items)\n            .output()\n            .unwrap();\n\n        // Should handle 0 to many items\n        assert!(result.status.success() || result.status.code() == Some(3));\n    }\n}\n```\n\n### 4. Interactive Prompt Tests\n\nTests for interactive CLI features.\n\n**Generated Tests:**\n\n```rust\n// tests/interactive_tests.rs\nuse assert_cmd::Command;\n\n#[test]\nfn test_confirmation_prompt_yes() -> Result<(), Box<dyn std::error::Error>> {\n    cmd()\n        .arg(\"delete\")\n        .arg(\"resource\")\n        .write_stdin(\"yes\\n\")\n        .assert()\n        .success()\n        .stdout(predicate::str::contains(\"Deleted\"));\n\n    Ok(())\n}\n\n#[test]\nfn test_confirmation_prompt_no() -> Result<(), Box<dyn std::error::Error>> {\n    cmd()\n        .arg(\"delete\")\n        .arg(\"resource\")\n        .write_stdin(\"no\\n\")\n        .assert()\n        .success()\n        .stdout(predicate::str::contains(\"Cancelled\"));\n\n    Ok(())\n}\n\n#[test]\nfn test_yes_flag_skips_prompt() -> Result<(), Box<dyn std::error::Error>> {\n    cmd()\n        .arg(\"delete\")\n        .arg(\"resource\")\n        .arg(\"--yes\")\n        .assert()\n        .success()\n        .stdout(predicate::str::contains(\"Deleted\"));\n\n    Ok(())\n}\n\n#[test]\nfn test_non_interactive_mode() -> Result<(), Box<dyn std::error::Error>> {\n    cmd()\n        .arg(\"delete\")\n        .env(\"CI\", \"true\")\n        .assert()\n        .failure()\n        .stderr(predicate::str::contains(\"non-interactive\"));\n\n    Ok(())\n}\n```\n\n### 5. Cross-Platform Tests\n\nPlatform-specific tests for compatibility.\n\n**Generated Tests:**\n\n```rust\n// tests/cross_platform_tests.rs\nuse assert_cmd::Command;\n\n#[test]\n#[cfg(target_os = \"windows\")]\nfn test_windows_paths() -> Result<(), Box<dyn std::error::Error>> {\n    cmd()\n        .arg(\"--path\")\n        .arg(r\"C:\\Users\\test\\file.txt\")\n        .assert()\n        .success();\n\n    Ok(())\n}\n\n#[test]\n#[cfg(not(target_os = \"windows\"))]\nfn test_unix_paths() -> Result<(), Box<dyn std::error::Error>> {\n    cmd()\n        .arg(\"--path\")\n        .arg(\"/home/test/file.txt\")\n        .assert()\n        .success();\n\n    Ok(())\n}\n\n#[test]\nfn test_cross_platform_path_handling() -> Result<(), Box<dyn std::error::Error>> {\n    let temp = assert_fs::TempDir::new()?;\n    let file = temp.child(\"test.txt\");\n    file.write_str(\"content\")?;\n\n    cmd()\n        .arg(\"process\")\n        .arg(file.path())\n        .assert()\n        .success();\n\n    temp.close()?;\n    Ok(())\n}\n\n#[test]\n#[cfg(target_os = \"windows\")]\nfn test_windows_line_endings() -> Result<(), Box<dyn std::error::Error>> {\n    let temp = assert_fs::TempDir::new()?;\n    let input = temp.child(\"input.txt\");\n    input.write_str(\"line1\\r\\nline2\\r\\nline3\")?;\n\n    cmd()\n        .arg(\"process\")\n        .arg(input.path())\n        .assert()\n        .success();\n\n    temp.close()?;\n    Ok(())\n}\n```\n\n## Test Organization\n\nGenerated tests are organized into separate files:\n\n```\ntests/\n├── integration_tests.rs    # Basic integration tests\n├── snapshots.rs            # Snapshot tests\n├── property_tests.rs       # Property-based tests\n├── interactive_tests.rs    # Interactive prompt tests\n├── cross_platform_tests.rs # Platform-specific tests\n└── snapshots/              # Saved snapshots (insta)\n    ├── snapshots__help_output.snap\n    ├── snapshots__build_help.snap\n    └── ...\n```\n\n## Dependencies Added\n\n```toml\n[dev-dependencies]\nassert_cmd = \"2\"\nassert_fs = \"1\"\npredicates = \"3\"\ninsta = \"1\"\nproptest = \"1\"\n```\n\n## Workflow\n\nWhen you invoke this command:\n\n1. **Analyze CLI Structure**\n   - Parse CLI definitions (Clap structure)\n   - Identify commands and subcommands\n   - Extract argument definitions\n   - Find file I/O operations\n\n2. **Generate Test Structure**\n   - Create test directory if needed\n   - Set up test modules\n   - Add necessary dependencies\n\n3. **Generate Tests Based on Type**\n   - **Integration**: Tests for each command, success/failure paths\n   - **Snapshot**: Capture help text, error messages, formatted output\n   - **Property**: Input validation, edge cases\n   - **Interactive**: Prompt handling, --yes flag\n   - **Cross-platform**: Path handling, line endings\n\n4. **Create Test Fixtures**\n   - Sample input files\n   - Config files for testing\n   - Expected output files\n\n5. **Generate Helper Functions**\n   - Command builder helper\n   - Common assertions\n   - Fixture setup/teardown\n\n6. **Verify Tests**\n   - Run generated tests\n   - Ensure they pass\n   - Report any issues\n\n7. **Generate Documentation**\n   - Add comments explaining tests\n   - Document test organization\n   - Provide examples of adding more tests\n\n## Example Output\n\n```\n✓ Analyzed CLI structure\n✓ Found 3 commands: init, build, test\n✓ Generated integration tests (12 tests)\n✓ Generated snapshot tests (8 tests)\n✓ Generated property-based tests (5 tests)\n✓ Generated interactive tests (4 tests)\n✓ Generated cross-platform tests (6 tests)\n✓ Added test dependencies to Cargo.toml\n✓ Created test fixtures\n\nTest Suite Generated Successfully!\n\nFiles created:\n  tests/integration_tests.rs    (12 tests)\n  tests/snapshots.rs             (8 tests)\n  tests/property_tests.rs        (5 tests)\n  tests/interactive_tests.rs     (4 tests)\n  tests/cross_platform_tests.rs  (6 tests)\n\nTotal: 35 tests\n\nRun tests:\n  cargo test\n\nRun specific test file:\n  cargo test --test integration_tests\n\nUpdate snapshots (if needed):\n  cargo insta review\n\nCoverage:\n  • All CLI commands tested\n  • Success and failure paths covered\n  • Help text snapshots captured\n  • Input validation tested\n  • Cross-platform compatibility verified\n\nNext steps:\n  1. Review generated tests\n  2. Run: cargo test\n  3. Add custom test cases as needed\n  4. Update snapshots: cargo insta review\n```\n\n## Implementation\n\nUse the **rust-cli-developer:cli-testing-expert** agent to:\n\n1. Analyze the CLI structure\n2. Generate appropriate tests\n3. Set up test infrastructure\n4. Create fixtures and helpers\n5. Verify tests run correctly\n\nInvoke with:\n\n```\nUse Task tool with subagent_type=\"rust-cli-developer:cli-testing-expert\"\n```\n\n## Notes\n\n- Generated tests are starting points; customize as needed\n- Snapshot tests require manual review on first run\n- Property tests may need adjustment for specific domains\n- Interactive tests require stdin support\n- Cross-platform tests should run in CI on multiple platforms\n- Tests are non-destructive and use temporary directories"
              }
            ],
            "skills": [
              {
                "name": "clap-patterns",
                "description": "Common Clap patterns and idioms for argument parsing, validation, and CLI design. Use when implementing CLI arguments with Clap v4+.",
                "path": "plugins/rust-cli-developer/skills/clap-patterns/SKILL.md",
                "frontmatter": {
                  "name": "clap-patterns",
                  "description": "Common Clap patterns and idioms for argument parsing, validation, and CLI design. Use when implementing CLI arguments with Clap v4+."
                },
                "content": "# Clap Patterns Skill\n\nCommon patterns and idioms for using Clap v4+ effectively in Rust CLI applications.\n\n## Derive API vs Builder API\n\n### When to Use Derive API\n\n- CLI structure known at compile time\n- Want type safety and compile-time validation\n- Prefer declarative style\n- Standard CLI patterns are sufficient\n\n```rust\n#[derive(Parser)]\n#[command(version, about)]\nstruct Cli {\n    #[arg(short, long)]\n    input: PathBuf,\n}\n```\n\n### When to Use Builder API\n\n- CLI needs to be built dynamically at runtime\n- Building plugin systems\n- Arguments depend on configuration\n- Need maximum flexibility\n\n```rust\nfn build_cli() -> Command {\n    Command::new(\"app\")\n        .arg(Arg::new(\"input\").short('i'))\n}\n```\n\n## Common Patterns\n\n### Global Options with Subcommands\n\n```rust\n#[derive(Parser)]\nstruct Cli {\n    #[arg(short, long, global = true, action = ArgAction::Count)]\n    verbose: u8,\n\n    #[command(subcommand)]\n    command: Commands,\n}\n```\n\n### Argument Groups for Mutual Exclusivity\n\n```rust\n#[derive(Parser)]\n#[command(group(\n    ArgGroup::new(\"format\")\n        .required(true)\n        .args(&[\"json\", \"yaml\", \"toml\"])\n))]\nstruct Cli {\n    #[arg(long)]\n    json: bool,\n    #[arg(long)]\n    yaml: bool,\n    #[arg(long)]\n    toml: bool,\n}\n```\n\n### Custom Value Parsers\n\n```rust\nfn parse_port(s: &str) -> Result<u16, String> {\n    let port: u16 = s.parse()\n        .map_err(|_| format!(\"`{s}` isn't a valid port\"))?;\n    if (1024..=65535).contains(&port) {\n        Ok(port)\n    } else {\n        Err(format!(\"port not in range 1024-65535\"))\n    }\n}\n\n#[derive(Parser)]\nstruct Cli {\n    #[arg(long, value_parser = parse_port)]\n    port: u16,\n}\n```\n\n### Environment Variable Fallbacks\n\n```rust\n#[derive(Parser)]\nstruct Cli {\n    #[arg(long, env = \"API_TOKEN\")]\n    token: String,\n\n    #[arg(long, env = \"API_ENDPOINT\", default_value = \"https://api.example.com\")]\n    endpoint: String,\n}\n```\n\n### Flattening Shared Options\n\n```rust\n#[derive(Args)]\nstruct CommonOpts {\n    #[arg(short, long)]\n    verbose: bool,\n\n    #[arg(short, long)]\n    config: Option<PathBuf>,\n}\n\n#[derive(Parser)]\nstruct Cli {\n    #[command(flatten)]\n    common: CommonOpts,\n\n    #[command(subcommand)]\n    command: Commands,\n}\n```\n\n### Multiple Values\n\n```rust\n#[derive(Parser)]\nstruct Cli {\n    /// Tags (can be specified multiple times)\n    #[arg(short, long)]\n    tag: Vec<String>,\n\n    /// Files to process\n    files: Vec<PathBuf>,\n}\n// Usage: myapp --tag rust --tag cli file1.txt file2.txt\n```\n\n### Subcommand with Shared Arguments\n\n```rust\n#[derive(Parser)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    Build(BuildArgs),\n    Test(TestArgs),\n}\n\n#[derive(Args)]\nstruct BuildArgs {\n    #[command(flatten)]\n    common: CommonOpts,\n\n    #[arg(short, long)]\n    release: bool,\n}\n```\n\n### Argument Counting (Verbosity Levels)\n\n```rust\n#[derive(Parser)]\nstruct Cli {\n    /// Verbosity (-v, -vv, -vvv)\n    #[arg(short, long, action = ArgAction::Count)]\n    verbose: u8,\n}\n// Usage: -v (1), -vv (2), -vvv (3)\n```\n\n### Help Template Customization\n\n```rust\n#[derive(Parser)]\n#[command(\n    after_help = \"EXAMPLES:\\n  \\\n        myapp --input file.txt\\n  \\\n        myapp -i file.txt -vv\\n\\n\\\n        For more info: https://example.com\"\n)]\nstruct Cli {\n    // ...\n}\n```\n\n### Value Hints\n\n```rust\n#[derive(Parser)]\nstruct Cli {\n    #[arg(short, long, value_name = \"FILE\", value_hint = ValueHint::FilePath)]\n    input: PathBuf,\n\n    #[arg(short, long, value_name = \"DIR\", value_hint = ValueHint::DirPath)]\n    output: PathBuf,\n\n    #[arg(short, long, value_name = \"URL\", value_hint = ValueHint::Url)]\n    endpoint: String,\n}\n```\n\n### Default Values with Functions\n\n```rust\nfn default_config_path() -> PathBuf {\n    dirs::config_dir()\n        .unwrap()\n        .join(\"myapp\")\n        .join(\"config.toml\")\n}\n\n#[derive(Parser)]\nstruct Cli {\n    #[arg(long, default_value_os_t = default_config_path())]\n    config: PathBuf,\n}\n```\n\n## Best Practices\n\n1. **Use `value_name`** for clearer help text\n2. **Provide both short and long flags** where appropriate\n3. **Add help text** to all arguments\n4. **Use `ValueEnum`** for fixed set of choices\n5. **Validate early** with custom parsers\n6. **Support environment variables** for sensitive data\n7. **Use argument groups** for mutually exclusive options\n8. **Document with examples** in `after_help`\n9. **Use semantic types** (PathBuf, not String for paths)\n10. **Test CLI parsing** with integration tests\n\n## References\n\n- [Clap Documentation](https://docs.rs/clap/)\n- [Clap Derive Reference](https://docs.rs/clap/latest/clap/_derive/index.html)\n- [Clap Examples](https://github.com/clap-rs/clap/tree/master/examples)"
              },
              {
                "name": "cli-configuration",
                "description": "Configuration management patterns including file formats, precedence, environment variables, and XDG directories. Use when implementing configuration systems for CLI applications.",
                "path": "plugins/rust-cli-developer/skills/cli-configuration/SKILL.md",
                "frontmatter": {
                  "name": "cli-configuration",
                  "description": "Configuration management patterns including file formats, precedence, environment variables, and XDG directories. Use when implementing configuration systems for CLI applications."
                },
                "content": "# CLI Configuration Skill\n\nPatterns and best practices for managing configuration in command-line applications.\n\n## Configuration Precedence\n\nThe standard precedence order (lowest to highest priority):\n\n1. **Compiled defaults** - Hard-coded sensible defaults\n2. **System config** - /etc/myapp/config.toml\n3. **User config** - ~/.config/myapp/config.toml\n4. **Project config** - ./myapp.toml or ./.myapp.toml\n5. **Environment variables** - MYAPP_KEY=value\n6. **CLI arguments** - --key value (highest priority)\n\n```rust\nuse config::{Config as ConfigBuilder, Environment, File};\n\npub fn load_config(cli: &Cli) -> Result<Config> {\n    let mut builder = ConfigBuilder::builder()\n        // 1. Defaults\n        .set_default(\"port\", 8080)?\n        .set_default(\"host\", \"localhost\")?\n        .set_default(\"log_level\", \"info\")?;\n\n    // 2. System config (if exists)\n    builder = builder\n        .add_source(File::with_name(\"/etc/myapp/config\").required(false));\n\n    // 3. User config (if exists)\n    if let Some(config_dir) = dirs::config_dir() {\n        builder = builder.add_source(\n            File::from(config_dir.join(\"myapp/config.toml\")).required(false)\n        );\n    }\n\n    // 4. Project config (if exists)\n    builder = builder\n        .add_source(File::with_name(\"myapp\").required(false))\n        .add_source(File::with_name(\".myapp\").required(false));\n\n    // 5. CLI-specified config (if provided)\n    if let Some(config_path) = &cli.config {\n        builder = builder.add_source(File::from(config_path.as_ref()));\n    }\n\n    // 6. Environment variables\n    builder = builder.add_source(\n        Environment::with_prefix(\"MYAPP\")\n            .separator(\"_\")\n            .try_parsing(true)\n    );\n\n    // 7. CLI arguments (highest priority)\n    if let Some(port) = cli.port {\n        builder = builder.set_override(\"port\", port)?;\n    }\n\n    Ok(builder.build()?.try_deserialize()?)\n}\n```\n\n## Config File Formats\n\n### TOML (Recommended)\n\nClear, human-readable, good error messages.\n\n```toml\n# config.toml\n[general]\nport = 8080\nhost = \"localhost\"\nlog_level = \"info\"\n\n[database]\nurl = \"postgresql://localhost/mydb\"\npool_size = 10\n\n[features]\ncaching = true\nmetrics = false\n\n[[servers]]\nname = \"primary\"\naddress = \"192.168.1.1\"\n\n[[servers]]\nname = \"backup\"\naddress = \"192.168.1.2\"\n```\n\n```rust\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Deserialize, Serialize)]\nstruct Config {\n    general: General,\n    database: Database,\n    features: Features,\n    servers: Vec<Server>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\nstruct General {\n    port: u16,\n    host: String,\n    log_level: String,\n}\n```\n\n### YAML (Alternative)\n\nMore concise, supports comments, complex structures.\n\n```yaml\n# config.yaml\ngeneral:\n  port: 8080\n  host: localhost\n  log_level: info\n\ndatabase:\n  url: postgresql://localhost/mydb\n  pool_size: 10\n\nfeatures:\n  caching: true\n  metrics: false\n\nservers:\n  - name: primary\n    address: 192.168.1.1\n  - name: backup\n    address: 192.168.1.2\n```\n\n### JSON (Machine-Readable)\n\nGood for programmatic generation, less human-friendly.\n\n```json\n{\n  \"general\": {\n    \"port\": 8080,\n    \"host\": \"localhost\",\n    \"log_level\": \"info\"\n  },\n  \"database\": {\n    \"url\": \"postgresql://localhost/mydb\",\n    \"pool_size\": 10\n  }\n}\n```\n\n## XDG Base Directory Support\n\nFollow the XDG Base Directory specification for cross-platform compatibility.\n\n```rust\nuse directories::ProjectDirs;\n\npub struct AppPaths {\n    pub config_dir: PathBuf,\n    pub data_dir: PathBuf,\n    pub cache_dir: PathBuf,\n    pub state_dir: PathBuf,\n}\n\nimpl AppPaths {\n    pub fn new(app_name: &str) -> Result<Self> {\n        let proj_dirs = ProjectDirs::from(\"com\", \"example\", app_name)\n            .ok_or_else(|| anyhow!(\"Could not determine project directories\"))?;\n\n        Ok(Self {\n            config_dir: proj_dirs.config_dir().to_path_buf(),\n            data_dir: proj_dirs.data_dir().to_path_buf(),\n            cache_dir: proj_dirs.cache_dir().to_path_buf(),\n            state_dir: proj_dirs.state_dir()\n                .unwrap_or_else(|| proj_dirs.data_dir())\n                .to_path_buf(),\n        })\n    }\n\n    pub fn config_file(&self) -> PathBuf {\n        self.config_dir.join(\"config.toml\")\n    }\n\n    pub fn ensure_dirs(&self) -> Result<()> {\n        fs::create_dir_all(&self.config_dir)?;\n        fs::create_dir_all(&self.data_dir)?;\n        fs::create_dir_all(&self.cache_dir)?;\n        fs::create_dir_all(&self.state_dir)?;\n        Ok(())\n    }\n}\n```\n\n**Directory locations by platform:**\n\n| Platform | Config | Data | Cache |\n|----------|--------|------|-------|\n| Linux | ~/.config/myapp | ~/.local/share/myapp | ~/.cache/myapp |\n| macOS | ~/Library/Application Support/myapp | ~/Library/Application Support/myapp | ~/Library/Caches/myapp |\n| Windows | %APPDATA%\\example\\myapp | %APPDATA%\\example\\myapp | %LOCALAPPDATA%\\example\\myapp |\n\n## Environment Variable Patterns\n\n### Naming Convention\n\nUse `APPNAME_SECTION_KEY` format:\n\n```bash\nMYAPP_DATABASE_URL=postgresql://localhost/db\nMYAPP_LOG_LEVEL=debug\nMYAPP_FEATURES_CACHING=true\nMYAPP_PORT=9000\n```\n\n### Integration with Clap\n\n```rust\n#[derive(Parser)]\nstruct Cli {\n    /// Database URL (env: MYAPP_DATABASE_URL)\n    #[arg(long, env = \"MYAPP_DATABASE_URL\")]\n    database_url: Option<String>,\n\n    /// Log level (env: MYAPP_LOG_LEVEL)\n    #[arg(long, env = \"MYAPP_LOG_LEVEL\", default_value = \"info\")]\n    log_level: String,\n\n    /// Port (env: MYAPP_PORT)\n    #[arg(long, env = \"MYAPP_PORT\", default_value = \"8080\")]\n    port: u16,\n}\n```\n\n### Sensitive Data Pattern\n\n**Never** put secrets in config files. Use environment variables instead.\n\n```rust\n#[derive(Debug, Deserialize)]\nstruct Config {\n    pub host: String,\n    pub port: u16,\n\n    // Loaded from environment only\n    #[serde(skip)]\n    pub api_token: String,\n}\n\nimpl Config {\n    pub fn load() -> Result<Self> {\n        let mut config: Config = /* load from file */;\n\n        // Sensitive data from env only\n        config.api_token = env::var(\"MYAPP_API_TOKEN\")\n            .context(\"MYAPP_API_TOKEN environment variable required\")?;\n\n        Ok(config)\n    }\n}\n```\n\n## Configuration Validation\n\nValidate configuration early at load time:\n\n```rust\n#[derive(Debug, Deserialize)]\nstruct Config {\n    pub port: u16,\n    pub host: String,\n    pub workers: usize,\n}\n\nimpl Config {\n    pub fn validate(&self) -> Result<()> {\n        // Port range\n        if !(1024..=65535).contains(&self.port) {\n            bail!(\"Port must be between 1024 and 65535, got {}\", self.port);\n        }\n\n        // Workers\n        if self.workers == 0 {\n            bail!(\"Workers must be at least 1\");\n        }\n\n        let max_workers = num_cpus::get() * 2;\n        if self.workers > max_workers {\n            bail!(\n                \"Workers ({}) exceeds recommended maximum ({})\",\n                self.workers,\n                max_workers\n            );\n        }\n\n        // Host validation\n        if self.host.is_empty() {\n            bail!(\"Host cannot be empty\");\n        }\n\n        Ok(())\n    }\n}\n```\n\n## Generating Default Config\n\nProvide a command to generate a default configuration file:\n\n```rust\nimpl Config {\n    pub fn default_config() -> Self {\n        Self {\n            general: General {\n                port: 8080,\n                host: \"localhost\".to_string(),\n                log_level: \"info\".to_string(),\n            },\n            database: Database {\n                url: \"postgresql://localhost/mydb\".to_string(),\n                pool_size: 10,\n            },\n            features: Features {\n                caching: true,\n                metrics: false,\n            },\n        }\n    }\n\n    pub fn write_default(path: &Path) -> Result<()> {\n        let config = Self::default_config();\n        let toml = toml::to_string_pretty(&config)?;\n\n        // Add helpful comments\n        let content = format!(\n            \"# Configuration file for myapp\\n\\\n             # See: https://example.com/docs/config\\n\\n\\\n             {toml}\"\n        );\n\n        fs::write(path, content)?;\n        Ok(())\n    }\n}\n```\n\n**CLI Command:**\n\n```rust\n#[derive(Subcommand)]\nenum Commands {\n    /// Generate a default configuration file\n    InitConfig {\n        /// Output path (default: ~/.config/myapp/config.toml)\n        #[arg(short, long)]\n        output: Option<PathBuf>,\n    },\n}\n\nfn handle_init_config(output: Option<PathBuf>) -> Result<()> {\n    let path = output.unwrap_or_else(|| {\n        AppPaths::new(\"myapp\")\n            .unwrap()\n            .config_file()\n    });\n\n    if path.exists() {\n        bail!(\"Config file already exists: {}\", path.display());\n    }\n\n    Config::write_default(&path)?;\n    println!(\"Created config file: {}\", path.display());\n    Ok(())\n}\n```\n\n## Config Migration Pattern\n\nHandle breaking changes in config format:\n\n```rust\n#[derive(Debug, Deserialize)]\nstruct ConfigV2 {\n    version: u32,\n    #[serde(flatten)]\n    data: ConfigData,\n}\n\nimpl ConfigV2 {\n    pub fn load(path: &Path) -> Result<Self> {\n        let content = fs::read_to_string(path)?;\n        let mut config: ConfigV2 = toml::from_str(&content)?;\n\n        // Migrate from older versions\n        match config.version {\n            1 => {\n                eprintln!(\"Migrating config from v1 to v2...\");\n                config = migrate_v1_to_v2(config)?;\n                // Optionally save migrated config\n                config.save(path)?;\n            }\n            2 => {}, // Current version\n            v => bail!(\"Unsupported config version: {}\", v),\n        }\n\n        Ok(config)\n    }\n}\n```\n\n## Configuration Examples Command\n\nProvide examples in help text:\n\n```rust\n#[derive(Subcommand)]\nenum Commands {\n    /// Show configuration examples\n    ConfigExamples,\n}\n\nfn show_config_examples() {\n    println!(\"Configuration Examples:\\n\");\n\n    println!(\"1. Basic configuration (config.toml):\");\n    println!(\"{}\", r#\"\n[general]\nport = 8080\nhost = \"localhost\"\n\"#);\n\n    println!(\"\\n2. Environment variables:\");\n    println!(\"   MYAPP_PORT=9000\");\n    println!(\"   MYAPP_DATABASE_URL=postgresql://localhost/db\");\n\n    println!(\"\\n3. CLI override:\");\n    println!(\"   myapp --port 9000 --host 0.0.0.0\");\n\n    println!(\"\\n4. Precedence (highest to lowest):\");\n    println!(\"   CLI args > Env vars > Config file > Defaults\");\n}\n```\n\n## Best Practices\n\n1. **Provide sensible defaults** - App should work out-of-box\n2. **Document precedence** - Make override behavior clear\n3. **Validate early** - Catch config errors at startup\n4. **Use XDG directories** - Follow platform conventions\n5. **Support env vars** - Essential for containers/CI\n6. **Generate defaults** - Help users get started\n7. **Version config format** - Enable migrations\n8. **Keep secrets out** - Use env vars for sensitive data\n9. **Clear error messages** - Help users fix config issues\n10. **Document all options** - With examples and defaults\n\n## References\n\n- [XDG Base Directory Specification](https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html)\n- [The Twelve-Factor App: Config](https://12factor.net/config)\n- [directories crate](https://docs.rs/directories/)\n- [config crate](https://docs.rs/config/)"
              },
              {
                "name": "cli-distribution",
                "description": "Distribution and packaging patterns including shell completions, man pages, cross-compilation, and release automation. Use when preparing CLI tools for distribution.",
                "path": "plugins/rust-cli-developer/skills/cli-distribution/SKILL.md",
                "frontmatter": {
                  "name": "cli-distribution",
                  "description": "Distribution and packaging patterns including shell completions, man pages, cross-compilation, and release automation. Use when preparing CLI tools for distribution."
                },
                "content": "# CLI Distribution Skill\n\nPatterns and best practices for distributing Rust CLI applications to users.\n\n## Shell Completion Generation\n\n### Using clap_complete\n\n```rust\nuse clap::{CommandFactory, Parser};\nuse clap_complete::{generate, Generator, Shell};\nuse std::io;\n\n#[derive(Parser)]\nstruct Cli {\n    /// Generate shell completions\n    #[arg(long = \"generate\", value_enum)]\n    generator: Option<Shell>,\n\n    // ... other fields\n}\n\nfn print_completions<G: Generator>(gen: G, cmd: &mut clap::Command) {\n    generate(gen, cmd, cmd.get_name().to_string(), &mut io::stdout());\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    if let Some(generator) = cli.generator {\n        let mut cmd = Cli::command();\n        print_completions(generator, &mut cmd);\n        return;\n    }\n\n    // ... rest of application\n}\n```\n\n### Installation Instructions by Shell\n\n**Bash:**\n```bash\n# Generate and save\nmyapp --generate bash > /etc/bash_completion.d/myapp\n\n# Or add to ~/.bashrc\neval \"$(myapp --generate bash)\"\n```\n\n**Zsh:**\n```bash\n# Generate and save\nmyapp --generate zsh > ~/.zfunc/_myapp\n\n# Add to ~/.zshrc\nfpath=(~/.zfunc $fpath)\nautoload -Uz compinit && compinit\n```\n\n**Fish:**\n```bash\n# Generate and save\nmyapp --generate fish > ~/.config/fish/completions/myapp.fish\n\n# Or load directly\nmyapp --generate fish | source\n```\n\n**PowerShell:**\n```powershell\n# Add to $PROFILE\nInvoke-Expression (& myapp --generate powershell)\n```\n\n### Dynamic Completions\n\nFor commands with dynamic values (like listing resources):\n\n```rust\nuse clap::CommandFactory;\nuse clap_complete::{generate, Generator};\n\npub fn generate_with_values<G: Generator>(\n    gen: G,\n    resources: &[String],\n) -> String {\n    let mut cmd = Cli::command();\n\n    // Add dynamic values to completion\n    if let Some(subcommand) = cmd.find_subcommand_mut(\"get\") {\n        for resource in resources {\n            subcommand = subcommand.arg(\n                clap::Arg::new(\"resource\")\n                    .value_parser(clap::builder::PossibleValuesParser::new(resource))\n            );\n        }\n    }\n\n    let mut buf = Vec::new();\n    generate(gen, &mut cmd, \"myapp\", &mut buf);\n    String::from_utf8(buf).unwrap()\n}\n```\n\n## Man Page Generation\n\n### Using clap_mangen\n\n```toml\n[dependencies]\nclap_mangen = \"0.2\"\n```\n\n```rust\nuse clap::CommandFactory;\nuse clap_mangen::Man;\nuse std::io;\n\nfn generate_man_page() {\n    let cmd = Cli::command();\n    let man = Man::new(cmd);\n    man.render(&mut io::stdout()).unwrap();\n}\n```\n\n### Build Script for Man Pages\n\n```rust\n// build.rs\nuse clap::CommandFactory;\nuse clap_mangen::Man;\nuse std::fs;\nuse std::path::PathBuf;\n\ninclude!(\"src/cli.rs\");\n\nfn main() {\n    let out_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\")).join(\"target/man\");\n    fs::create_dir_all(&out_dir).unwrap();\n\n    let cmd = Cli::command();\n    let man = Man::new(cmd);\n    let mut buffer = Vec::new();\n    man.render(&mut buffer).unwrap();\n\n    fs::write(out_dir.join(\"myapp.1\"), buffer).unwrap();\n}\n```\n\n### Install Man Page\n\n```bash\n# System-wide\nsudo cp target/man/myapp.1 /usr/local/share/man/man1/\n\n# User-local\nmkdir -p ~/.local/share/man/man1\ncp target/man/myapp.1 ~/.local/share/man/man1/\n```\n\n## Cross-Compilation\n\n### Target Triples\n\nCommon targets for CLI distribution:\n\n```bash\n# Linux\nx86_64-unknown-linux-gnu      # GNU Linux\nx86_64-unknown-linux-musl     # MUSL Linux (static)\naarch64-unknown-linux-gnu     # ARM64 Linux\n\n# macOS\nx86_64-apple-darwin           # Intel Mac\naarch64-apple-darwin          # Apple Silicon\n\n# Windows\nx86_64-pc-windows-msvc        # Windows MSVC\nx86_64-pc-windows-gnu         # Windows GNU\n```\n\n### Cross-Compilation with cross\n\n```bash\n# Install cross\ncargo install cross\n\n# Build for Linux from any platform\ncross build --release --target x86_64-unknown-linux-gnu\n\n# Build static binary with MUSL\ncross build --release --target x86_64-unknown-linux-musl\n```\n\n### GitHub Actions for Cross-Compilation\n\n```yaml\n# .github/workflows/release.yml\nname: Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  build:\n    strategy:\n      matrix:\n        include:\n          - os: ubuntu-latest\n            target: x86_64-unknown-linux-gnu\n            artifact_name: myapp\n            asset_name: myapp-linux-amd64\n\n          - os: ubuntu-latest\n            target: x86_64-unknown-linux-musl\n            artifact_name: myapp\n            asset_name: myapp-linux-musl-amd64\n\n          - os: macos-latest\n            target: x86_64-apple-darwin\n            artifact_name: myapp\n            asset_name: myapp-macos-amd64\n\n          - os: macos-latest\n            target: aarch64-apple-darwin\n            artifact_name: myapp\n            asset_name: myapp-macos-arm64\n\n          - os: windows-latest\n            target: x86_64-pc-windows-msvc\n            artifact_name: myapp.exe\n            asset_name: myapp-windows-amd64.exe\n\n    runs-on: ${{ matrix.os }}\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: dtolnay/rust-toolchain@stable\n        with:\n          targets: ${{ matrix.target }}\n\n      - name: Build\n        run: cargo build --release --target ${{ matrix.target }}\n\n      - name: Upload binaries\n        uses: actions/upload-artifact@v3\n        with:\n          name: ${{ matrix.asset_name }}\n          path: target/${{ matrix.target }}/release/${{ matrix.artifact_name }}\n```\n\n## Binary Size Optimization\n\n### Cargo.toml optimizations\n\n```toml\n[profile.release]\nopt-level = \"z\"     # Optimize for size\nlto = true          # Link-time optimization\ncodegen-units = 1   # Better optimization\nstrip = true        # Strip symbols\npanic = \"abort\"     # Smaller panic handler\n```\n\n### Additional size reduction\n\n```bash\n# Install upx\nbrew install upx  # macOS\napt install upx   # Linux\n\n# Compress binary\nupx --best --lzma target/release/myapp\n```\n\n**Before/After example:**\n```\nOriginal:  2.5 MB\nOptimized: 1.2 MB (strip = true)\nUPX:       400 KB (upx --best --lzma)\n```\n\n## Package Distribution\n\n### Homebrew (macOS/Linux)\n\nCreate a formula:\n\n```ruby\n# Formula/myapp.rb\nclass Myapp < Formula\n  desc \"Description of your CLI tool\"\n  homepage \"https://github.com/username/myapp\"\n  url \"https://github.com/username/myapp/archive/v1.0.0.tar.gz\"\n  sha256 \"abc123...\"\n  license \"MIT\"\n\n  depends_on \"rust\" => :build\n\n  def install\n    system \"cargo\", \"install\", \"--locked\", \"--root\", prefix, \"--path\", \".\"\n\n    # Install shell completions\n    generate_completions_from_executable(bin/\"myapp\", \"--generate\")\n\n    # Install man page\n    man1.install \"target/man/myapp.1\"\n  end\n\n  test do\n    assert_match \"myapp 1.0.0\", shell_output(\"#{bin}/myapp --version\")\n  end\nend\n```\n\n### Debian Package (.deb)\n\nUsing `cargo-deb`:\n\n```bash\ncargo install cargo-deb\n\n# Create debian package\ncargo deb\n\n# Package will be in target/debian/myapp_1.0.0_amd64.deb\n```\n\n**Cargo.toml metadata:**\n\n```toml\n[package.metadata.deb]\nmaintainer = \"Your Name <you@example.com>\"\ncopyright = \"2024, Your Name\"\nlicense-file = [\"LICENSE\", \"4\"]\nextended-description = \"\"\"\nA longer description of your CLI tool\nthat spans multiple lines.\"\"\"\ndepends = \"$auto\"\nsection = \"utility\"\npriority = \"optional\"\nassets = [\n    [\"target/release/myapp\", \"usr/bin/\", \"755\"],\n    [\"README.md\", \"usr/share/doc/myapp/\", \"644\"],\n    [\"target/completions/myapp.bash\", \"usr/share/bash-completion/completions/\", \"644\"],\n    [\"target/man/myapp.1\", \"usr/share/man/man1/\", \"644\"],\n]\n```\n\n### Docker Distribution\n\n```dockerfile\n# Dockerfile\nFROM rust:1.75 as builder\nWORKDIR /app\nCOPY . .\nRUN cargo build --release\n\nFROM debian:bookworm-slim\nRUN apt-get update && apt-get install -y ca-certificates && rm -rf /var/lib/apt/lists/*\nCOPY --from=builder /app/target/release/myapp /usr/local/bin/myapp\nENTRYPOINT [\"myapp\"]\n```\n\n**Multi-stage with MUSL (smaller image):**\n\n```dockerfile\nFROM rust:1.75-alpine as builder\nRUN apk add --no-cache musl-dev\nWORKDIR /app\nCOPY . .\nRUN cargo build --release --target x86_64-unknown-linux-musl\n\nFROM scratch\nCOPY --from=builder /app/target/x86_64-unknown-linux-musl/release/myapp /myapp\nENTRYPOINT [\"/myapp\"]\n```\n\n### Cargo-binstall Support\n\nAdd metadata for faster installation:\n\n```toml\n[package.metadata.binstall]\npkg-url = \"{ repo }/releases/download/v{ version }/{ name }-{ target }{ binary-ext }\"\nbin-dir = \"{ bin }{ binary-ext }\"\npkg-fmt = \"bin\"\n```\n\nUsers can then install with:\n```bash\ncargo binstall myapp\n```\n\n## Auto-Update\n\n### Using self_update crate\n\n```toml\n[dependencies]\nself_update = \"0.39\"\n```\n\n```rust\nuse self_update::cargo_crate_version;\n\nfn update() -> Result<()> {\n    let status = self_update::backends::github::Update::configure()\n        .repo_owner(\"username\")\n        .repo_name(\"myapp\")\n        .bin_name(\"myapp\")\n        .show_download_progress(true)\n        .current_version(cargo_crate_version!())\n        .build()?\n        .update()?;\n\n    println!(\"Update status: `{}`!\", status.version());\n    Ok(())\n}\n```\n\n### Update Command\n\n```rust\n#[derive(Subcommand)]\nenum Commands {\n    /// Update to the latest version\n    Update,\n}\n\nfn handle_update() -> Result<()> {\n    println!(\"Checking for updates...\");\n\n    match update() {\n        Ok(_) => {\n            println!(\"Updated successfully! Please restart the application.\");\n            Ok(())\n        }\n        Err(e) => {\n            eprintln!(\"Update failed: {}\", e);\n            eprintln!(\"Download manually: https://github.com/username/myapp/releases\");\n            Err(e)\n        }\n    }\n}\n```\n\n## Release Automation\n\n### Cargo-release\n\n```bash\ncargo install cargo-release\n\n# Dry run\ncargo release --dry-run\n\n# Release patch version\ncargo release patch --execute\n\n# Release minor version\ncargo release minor --execute\n```\n\n### GitHub Release Action\n\n```yaml\n# .github/workflows/release.yml\nname: Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: taiki-e/create-gh-release-action@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          changelog: CHANGELOG.md\n\n  upload-assets:\n    needs: release\n    strategy:\n      matrix:\n        include:\n          - target: x86_64-unknown-linux-gnu\n          - target: x86_64-apple-darwin\n          - target: x86_64-pc-windows-msvc\n\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: taiki-e/upload-rust-binary-action@v1\n        with:\n          bin: myapp\n          target: ${{ matrix.target }}\n          token: ${{ secrets.GITHUB_TOKEN }}\n```\n\n## Best Practices\n\n1. **Provide multiple installation methods** - Cargo, Homebrew, apt, etc.\n2. **Generate completions** - Essential for good UX\n3. **Create man pages** - Professional documentation\n4. **Test cross-platform** - Build for all major platforms\n5. **Optimize binary size** - Users appreciate smaller downloads\n6. **Automate releases** - Use CI/CD for consistent builds\n7. **Version clearly** - Semantic versioning\n8. **Sign binaries** - Build trust (especially on macOS)\n9. **Provide checksums** - Verify download integrity\n10. **Document installation** - Clear, platform-specific instructions\n\n## Distribution Checklist\n\n- [ ] Shell completions generated (bash, zsh, fish, powershell)\n- [ ] Man pages created\n- [ ] Cross-compiled for major platforms\n- [ ] Binary size optimized\n- [ ] Release artifacts uploaded to GitHub\n- [ ] Installation instructions in README\n- [ ] Homebrew formula (if applicable)\n- [ ] Debian package (if applicable)\n- [ ] Docker image (if applicable)\n- [ ] Checksums provided\n- [ ] Changelog maintained\n- [ ] Version bumped properly\n\n## References\n\n- [clap_complete Documentation](https://docs.rs/clap_complete/)\n- [clap_mangen Documentation](https://docs.rs/clap_mangen/)\n- [cargo-deb](https://github.com/kornelski/cargo-deb)\n- [cross](https://github.com/cross-rs/cross)\n- [Rust Platform Support](https://doc.rust-lang.org/nightly/rustc/platform-support.html)"
              },
              {
                "name": "cli-ux-patterns",
                "description": "CLI user experience best practices for error messages, colors, progress indicators, and output formatting. Use when improving CLI usability and user experience.",
                "path": "plugins/rust-cli-developer/skills/cli-ux-patterns/SKILL.md",
                "frontmatter": {
                  "name": "cli-ux-patterns",
                  "description": "CLI user experience best practices for error messages, colors, progress indicators, and output formatting. Use when improving CLI usability and user experience."
                },
                "content": "# CLI UX Patterns Skill\n\nBest practices and patterns for creating delightful command-line user experiences.\n\n## Error Message Patterns\n\n### The Three Parts of Good Error Messages\n\n1. **What went wrong** - Clear description of the error\n2. **Why it matters** - Context about the operation\n3. **How to fix it** - Actionable suggestions\n\n```rust\nbail!(\n    \"Failed to read config file: {}\\n\\n\\\n     The application needs a valid configuration to start.\\n\\n\\\n     To fix this:\\n\\\n     1. Create a config file: myapp init\\n\\\n     2. Or specify a different path: --config /path/to/config.toml\\n\\\n     3. Check file permissions: ls -l {}\",\n    path.display(),\n    path.display()\n);\n```\n\n### Using miette for Rich Diagnostics\n\n```rust\n#[derive(Error, Debug, Diagnostic)]\n#[error(\"Configuration error\")]\n#[diagnostic(\n    code(config::invalid),\n    url(\"https://docs.example.com/config\"),\n    help(\"Check the syntax of your configuration file\")\n)]\nstruct ConfigError {\n    #[source_code]\n    src: String,\n\n    #[label(\"invalid value here\")]\n    span: SourceSpan,\n}\n```\n\n## Color Usage Patterns\n\n### Semantic Colors\n\n- **Red** - Errors, failures, destructive actions\n- **Yellow** - Warnings, cautions\n- **Green** - Success, completion, safe operations\n- **Blue** - Information, hints, links\n- **Cyan** - Highlights, emphasis\n- **Dim/Gray** - Less important info, metadata\n\n```rust\nuse owo_colors::OwoColorize;\n\n// Status indicators with colors\nprintln!(\"{} Build succeeded\", \"✓\".green().bold());\nprintln!(\"{} Warning: using default\", \"⚠\".yellow().bold());\nprintln!(\"{} Error: file not found\", \"✗\".red().bold());\nprintln!(\"{} Info: processing 10 files\", \"ℹ\".blue().bold());\n```\n\n### Respecting NO_COLOR\n\n```rust\nuse owo_colors::{OwoColorize, Stream};\n\nfn print_status(message: &str, is_error: bool) {\n    let stream = if is_error { Stream::Stderr } else { Stream::Stdout };\n\n    if is_error {\n        eprintln!(\"{}\", message.if_supports_color(stream, |text| text.red()));\n    } else {\n        println!(\"{}\", message.if_supports_color(stream, |text| text.green()));\n    }\n}\n```\n\n## Progress Indication Patterns\n\n### When to Use Progress Bars\n\n- File downloads/uploads\n- Bulk processing with known count\n- Multi-step processes\n- Any operation > 2 seconds with known total\n\n```rust\nuse indicatif::{ProgressBar, ProgressStyle};\n\nlet pb = ProgressBar::new(items.len() as u64);\npb.set_style(\n    ProgressStyle::default_bar()\n        .template(\"{spinner:.green} [{bar:40}] {pos}/{len} {msg}\")?\n        .progress_chars(\"=>-\")\n);\n\nfor item in items {\n    pb.set_message(format!(\"Processing {}\", item.name));\n    process(item)?;\n    pb.inc(1);\n}\n\npb.finish_with_message(\"Complete!\");\n```\n\n### When to Use Spinners\n\n- Unknown duration operations\n- Waiting for external resources\n- Operations < 2 seconds\n- Indeterminate progress\n\n```rust\nlet spinner = ProgressBar::new_spinner();\nspinner.set_style(\n    ProgressStyle::default_spinner()\n        .template(\"{spinner:.green} {msg}\")?\n);\n\nspinner.set_message(\"Connecting to server...\");\n// Do work\nspinner.finish_with_message(\"Connected!\");\n```\n\n## Interactive Prompt Patterns\n\n### When to Prompt vs When to Fail\n\n**Prompt when:**\n- Optional information for better UX\n- Choosing from known options\n- Confirmation for destructive operations\n- First-time setup/initialization\n\n**Fail with error when:**\n- Required information\n- Non-interactive environment (CI/CD)\n- Piped input/output\n- --yes flag provided\n\n```rust\nuse dialoguer::Confirm;\n\nfn delete_resource(name: &str, force: bool) -> Result<()> {\n    if !force && atty::is(atty::Stream::Stdin) {\n        let confirmed = Confirm::new()\n            .with_prompt(format!(\"Delete {}? This cannot be undone\", name))\n            .default(false)\n            .interact()?;\n\n        if !confirmed {\n            println!(\"Cancelled\");\n            return Ok(());\n        }\n    }\n\n    // Perform deletion\n    Ok(())\n}\n```\n\n### Smart Defaults\n\n```rust\nuse dialoguer::Input;\n\nfn get_project_name(current_dir: &Path) -> Result<String> {\n    let default = current_dir\n        .file_name()\n        .and_then(|n| n.to_str())\n        .unwrap_or(\"my-project\");\n\n    Input::new()\n        .with_prompt(\"Project name\")\n        .default(default.to_string())\n        .interact_text()\n}\n```\n\n## Output Formatting Patterns\n\n### Human-Readable vs Machine-Readable\n\n```rust\n#[derive(Parser)]\nstruct Cli {\n    #[arg(long)]\n    json: bool,\n\n    #[arg(short, long)]\n    verbose: bool,\n}\n\nfn print_results(results: &[Item], cli: &Cli) {\n    if cli.json {\n        // Machine-readable\n        println!(\"{}\", serde_json::to_string_pretty(&results).unwrap());\n    } else {\n        // Human-readable\n        for item in results {\n            println!(\"{} {} - {}\",\n                if item.active { \"✓\".green() } else { \"✗\".red() },\n                item.name.bold(),\n                item.description.dimmed()\n            );\n        }\n    }\n}\n```\n\n### Table Output\n\n```rust\nuse comfy_table::{Table, Cell, Color};\n\nfn print_table(items: &[Item]) {\n    let mut table = Table::new();\n    table.set_header(vec![\"Name\", \"Status\", \"Created\"]);\n\n    for item in items {\n        let status_color = if item.active { Color::Green } else { Color::Red };\n        table.add_row(vec![\n            Cell::new(&item.name),\n            Cell::new(&item.status).fg(status_color),\n            Cell::new(&item.created),\n        ]);\n    }\n\n    println!(\"{table}\");\n}\n```\n\n## Verbosity Patterns\n\n### Progressive Disclosure\n\n```rust\nfn log_message(level: u8, quiet: bool, message: &str) {\n    match (level, quiet) {\n        (_, true) => {}, // Quiet mode: no output\n        (0, false) => {}, // Default: only errors\n        (1, false) => println!(\"{}\", message), // -v: basic info\n        (2, false) => println!(\"INFO: {}\", message), // -vv: detailed\n        _ => println!(\"[DEBUG] {}\", message), // -vvv: everything\n    }\n}\n```\n\n### Quiet Mode\n\n```rust\n#[derive(Parser)]\nstruct Cli {\n    #[arg(short, long)]\n    quiet: bool,\n\n    #[arg(short, long, action = ArgAction::Count, conflicts_with = \"quiet\")]\n    verbose: u8,\n}\n```\n\n## Confirmation Patterns\n\n### Destructive Operations\n\n```rust\n// Always require confirmation for:\n// - Deleting data\n// - Overwriting files\n// - Production deployments\n// - Irreversible operations\n\nfn deploy_to_production(force: bool) -> Result<()> {\n    if !force {\n        println!(\"{}\", \"WARNING: Deploying to PRODUCTION\".red().bold());\n        println!(\"This will affect live users.\");\n\n        let confirmed = Confirm::new()\n            .with_prompt(\"Are you absolutely sure?\")\n            .default(false)\n            .interact()?;\n\n        if !confirmed {\n            return Ok(());\n        }\n    }\n\n    // Deploy\n    Ok(())\n}\n```\n\n## Stdout vs Stderr\n\n### Best Practices\n\n- **stdout** - Program output, data, results\n- **stderr** - Errors, warnings, progress, diagnostics\n\n```rust\n// Correct usage\nprintln!(\"result: {}\", data); // stdout - actual output\neprintln!(\"Error: {}\", error); // stderr - error message\neprintln!(\"Processing...\"); // stderr - progress update\n\n// This allows piping output while seeing progress:\n// myapp process file.txt | other_command\n// (progress messages don't interfere with piped data)\n```\n\n## Accessibility Considerations\n\n### Screen Reader Friendly\n\n```rust\n// Always include text prefixes, not just symbols\nfn print_status(level: Level, message: &str) {\n    let (symbol, prefix) = match level {\n        Level::Success => (\"✓\", \"SUCCESS:\"),\n        Level::Error => (\"✗\", \"ERROR:\"),\n        Level::Warning => (\"⚠\", \"WARNING:\"),\n        Level::Info => (\"ℹ\", \"INFO:\"),\n    };\n\n    // Both symbol and text for accessibility\n    println!(\"{} {} {}\", symbol, prefix, message);\n}\n```\n\n### Color Blindness Considerations\n\n- Don't rely on color alone\n- Use symbols/icons with colors\n- Test with color blindness simulators\n- Provide text alternatives\n\n## The 12-Factor CLI Principles\n\n1. **Great help** - Comprehensive, discoverable\n2. **Prefer flags to args** - More explicit\n3. **Respect POSIX** - Follow conventions\n4. **Use stdout for output** - Enable piping\n5. **Use stderr for messaging** - Keep output clean\n6. **Handle signals** - Respond to Ctrl+C gracefully\n7. **Be quiet by default** - User controls verbosity\n8. **Fail fast** - Validate early\n9. **Support --help and --version** - Always\n10. **Be explicit** - Avoid surprising behavior\n11. **Be consistent** - Follow patterns\n12. **Make it easy** - Good defaults, clear errors\n\n## References\n\n- [CLI Guidelines](https://clig.dev/)\n- [12 Factor CLI Apps](https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46)\n- [NO_COLOR](https://no-color.org/)\n- [Human-First CLI Design](https://uxdesign.cc/human-first-cli-design-principles-b2b4b4e7e7c1)"
              }
            ]
          }
        ]
      }
    }
  ]
}