{
  "owner": {
    "id": "astrosteveo",
    "display_name": "Steven Mosley",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/34114851?v=4",
    "url": "https://github.com/astrosteveo",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 3,
      "total_commands": 6,
      "total_skills": 9,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "astrosteveo/marketplace",
      "url": "https://github.com/astrosteveo/marketplace",
      "description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-12T03:32:51Z",
        "created_at": "2026-01-09T21:25:44Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1370
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 25
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 1065
        },
        {
          "path": "dev-link.sh",
          "type": "blob",
          "size": 914
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/dev",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/dev/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/dev/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 442
        },
        {
          "path": "plugins/dev/.gitignore",
          "type": "blob",
          "size": 124
        },
        {
          "path": "plugins/dev/README.md",
          "type": "blob",
          "size": 4071
        },
        {
          "path": "plugins/engram-mcp",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/engram-mcp/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/engram-mcp/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 461
        },
        {
          "path": "plugins/engram-mcp/.gitignore",
          "type": "blob",
          "size": 142
        },
        {
          "path": "plugins/engram-mcp/.mcp.json",
          "type": "blob",
          "size": 188
        },
        {
          "path": "plugins/engram-mcp/CLAUDE.md",
          "type": "blob",
          "size": 1185
        },
        {
          "path": "plugins/engram-mcp/README.md",
          "type": "blob",
          "size": 1127
        },
        {
          "path": "plugins/engram-mcp/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/engram-mcp/commands/remember.md",
          "type": "blob",
          "size": 294
        },
        {
          "path": "plugins/engram-mcp/commands/resume.md",
          "type": "blob",
          "size": 245
        },
        {
          "path": "plugins/engram-mcp/commands/search.md",
          "type": "blob",
          "size": 290
        },
        {
          "path": "plugins/engram-mcp/commands/stats.md",
          "type": "blob",
          "size": 231
        },
        {
          "path": "plugins/engram-mcp/commands/sync.md",
          "type": "blob",
          "size": 231
        },
        {
          "path": "plugins/engram-mcp/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/engram-mcp/hooks/hooks.json",
          "type": "blob",
          "size": 1158
        },
        {
          "path": "plugins/engram-mcp/install.sh",
          "type": "blob",
          "size": 2156
        },
        {
          "path": "plugins/engram-mcp/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/engram-mcp/scripts/live-index.sh",
          "type": "blob",
          "size": 366
        },
        {
          "path": "plugins/engram-mcp/scripts/session-start.sh",
          "type": "blob",
          "size": 433
        },
        {
          "path": "plugins/engram-mcp/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/engram-mcp/skills/using-engram",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/engram-mcp/skills/using-engram/SKILL.md",
          "type": "blob",
          "size": 1162
        },
        {
          "path": "plugins/engram-mcp/uninstall.sh",
          "type": "blob",
          "size": 1655
        },
        {
          "path": "plugins/harness",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 484
        },
        {
          "path": "plugins/harness/.gitignore",
          "type": "blob",
          "size": 124
        },
        {
          "path": "plugins/harness/README.md",
          "type": "blob",
          "size": 3951
        },
        {
          "path": "plugins/harness/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/agents/agent-creator.md",
          "type": "blob",
          "size": 5683
        },
        {
          "path": "plugins/harness/agents/code-architect.md",
          "type": "blob",
          "size": 2257
        },
        {
          "path": "plugins/harness/agents/code-explorer.md",
          "type": "blob",
          "size": 2115
        },
        {
          "path": "plugins/harness/agents/code-reviewer.md",
          "type": "blob",
          "size": 2992
        },
        {
          "path": "plugins/harness/agents/plugin-validator.md",
          "type": "blob",
          "size": 5239
        },
        {
          "path": "plugins/harness/agents/skill-reviewer.md",
          "type": "blob",
          "size": 5051
        },
        {
          "path": "plugins/harness/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/commands/feature.md",
          "type": "blob",
          "size": 12702
        },
        {
          "path": "plugins/harness/config",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/config/workflow.yaml",
          "type": "blob",
          "size": 3321
        },
        {
          "path": "plugins/harness/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/agent-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/agent-development/SKILL.md",
          "type": "blob",
          "size": 11960
        },
        {
          "path": "plugins/harness/skills/agent-development/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/agent-development/examples/agent-creation-prompt.md",
          "type": "blob",
          "size": 9390
        },
        {
          "path": "plugins/harness/skills/agent-development/examples/complete-agent-examples.md",
          "type": "blob",
          "size": 14117
        },
        {
          "path": "plugins/harness/skills/agent-development/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/agent-development/references/agent-creation-system-prompt.md",
          "type": "blob",
          "size": 8879
        },
        {
          "path": "plugins/harness/skills/agent-development/references/system-prompt-design.md",
          "type": "blob",
          "size": 9998
        },
        {
          "path": "plugins/harness/skills/agent-development/references/triggering-examples.md",
          "type": "blob",
          "size": 11613
        },
        {
          "path": "plugins/harness/skills/agent-development/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/agent-development/scripts/validate-agent.sh",
          "type": "blob",
          "size": 5796
        },
        {
          "path": "plugins/harness/skills/command-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/command-development/README.md",
          "type": "blob",
          "size": 7651
        },
        {
          "path": "plugins/harness/skills/command-development/SKILL.md",
          "type": "blob",
          "size": 19557
        },
        {
          "path": "plugins/harness/skills/command-development/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/command-development/examples/plugin-commands.md",
          "type": "blob",
          "size": 13989
        },
        {
          "path": "plugins/harness/skills/command-development/examples/simple-commands.md",
          "type": "blob",
          "size": 8675
        },
        {
          "path": "plugins/harness/skills/command-development/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/command-development/references/advanced-workflows.md",
          "type": "blob",
          "size": 13618
        },
        {
          "path": "plugins/harness/skills/command-development/references/documentation-patterns.md",
          "type": "blob",
          "size": 14971
        },
        {
          "path": "plugins/harness/skills/command-development/references/frontmatter-reference.md",
          "type": "blob",
          "size": 9162
        },
        {
          "path": "plugins/harness/skills/command-development/references/interactive-commands.md",
          "type": "blob",
          "size": 20980
        },
        {
          "path": "plugins/harness/skills/command-development/references/marketplace-considerations.md",
          "type": "blob",
          "size": 16437
        },
        {
          "path": "plugins/harness/skills/command-development/references/plugin-features-reference.md",
          "type": "blob",
          "size": 14622
        },
        {
          "path": "plugins/harness/skills/command-development/references/testing-strategies.md",
          "type": "blob",
          "size": 14803
        },
        {
          "path": "plugins/harness/skills/hook-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/hook-development/SKILL.md",
          "type": "blob",
          "size": 20324
        },
        {
          "path": "plugins/harness/skills/hook-development/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/hook-development/examples/load-context.sh",
          "type": "blob",
          "size": 1690
        },
        {
          "path": "plugins/harness/skills/hook-development/examples/validate-bash.sh",
          "type": "blob",
          "size": 1304
        },
        {
          "path": "plugins/harness/skills/hook-development/examples/validate-write.sh",
          "type": "blob",
          "size": 1222
        },
        {
          "path": "plugins/harness/skills/hook-development/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/hook-development/references/advanced.md",
          "type": "blob",
          "size": 10148
        },
        {
          "path": "plugins/harness/skills/hook-development/references/migration.md",
          "type": "blob",
          "size": 8299
        },
        {
          "path": "plugins/harness/skills/hook-development/references/patterns.md",
          "type": "blob",
          "size": 7144
        },
        {
          "path": "plugins/harness/skills/hook-development/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/hook-development/scripts/README.md",
          "type": "blob",
          "size": 3677
        },
        {
          "path": "plugins/harness/skills/hook-development/scripts/hook-linter.sh",
          "type": "blob",
          "size": 4200
        },
        {
          "path": "plugins/harness/skills/hook-development/scripts/test-hook.sh",
          "type": "blob",
          "size": 5336
        },
        {
          "path": "plugins/harness/skills/hook-development/scripts/validate-hook-schema.sh",
          "type": "blob",
          "size": 5081
        },
        {
          "path": "plugins/harness/skills/lsp-integration",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/lsp-integration/SKILL.md",
          "type": "blob",
          "size": 11063
        },
        {
          "path": "plugins/harness/skills/lsp-integration/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/lsp-integration/examples/go-lsp.json",
          "type": "blob",
          "size": 239
        },
        {
          "path": "plugins/harness/skills/lsp-integration/examples/multi-language.json",
          "type": "blob",
          "size": 694
        },
        {
          "path": "plugins/harness/skills/lsp-integration/examples/python-lsp.json",
          "type": "blob",
          "size": 404
        },
        {
          "path": "plugins/harness/skills/mcp-integration",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/mcp-integration/SKILL.md",
          "type": "blob",
          "size": 12504
        },
        {
          "path": "plugins/harness/skills/mcp-integration/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/mcp-integration/examples/http-server.json",
          "type": "blob",
          "size": 502
        },
        {
          "path": "plugins/harness/skills/mcp-integration/examples/sse-server.json",
          "type": "blob",
          "size": 413
        },
        {
          "path": "plugins/harness/skills/mcp-integration/examples/stdio-server.json",
          "type": "blob",
          "size": 686
        },
        {
          "path": "plugins/harness/skills/mcp-integration/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/mcp-integration/references/authentication.md",
          "type": "blob",
          "size": 10196
        },
        {
          "path": "plugins/harness/skills/mcp-integration/references/server-types.md",
          "type": "blob",
          "size": 10613
        },
        {
          "path": "plugins/harness/skills/mcp-integration/references/tool-usage.md",
          "type": "blob",
          "size": 11674
        },
        {
          "path": "plugins/harness/skills/plugin-settings",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/plugin-settings/SKILL.md",
          "type": "blob",
          "size": 12082
        },
        {
          "path": "plugins/harness/skills/plugin-settings/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/plugin-settings/examples/create-settings-command.md",
          "type": "blob",
          "size": 2177
        },
        {
          "path": "plugins/harness/skills/plugin-settings/examples/example-settings.md",
          "type": "blob",
          "size": 2930
        },
        {
          "path": "plugins/harness/skills/plugin-settings/examples/read-settings-hook.sh",
          "type": "blob",
          "size": 2205
        },
        {
          "path": "plugins/harness/skills/plugin-settings/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/plugin-settings/references/parsing-techniques.md",
          "type": "blob",
          "size": 11513
        },
        {
          "path": "plugins/harness/skills/plugin-settings/references/real-world-examples.md",
          "type": "blob",
          "size": 9492
        },
        {
          "path": "plugins/harness/skills/plugin-settings/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/plugin-settings/scripts/parse-frontmatter.sh",
          "type": "blob",
          "size": 1269
        },
        {
          "path": "plugins/harness/skills/plugin-settings/scripts/validate-settings.sh",
          "type": "blob",
          "size": 2712
        },
        {
          "path": "plugins/harness/skills/plugin-structure",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/plugin-structure/README.md",
          "type": "blob",
          "size": 3210
        },
        {
          "path": "plugins/harness/skills/plugin-structure/SKILL.md",
          "type": "blob",
          "size": 17470
        },
        {
          "path": "plugins/harness/skills/plugin-structure/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/plugin-structure/examples/advanced-plugin.md",
          "type": "blob",
          "size": 18746
        },
        {
          "path": "plugins/harness/skills/plugin-structure/examples/minimal-plugin.md",
          "type": "blob",
          "size": 1731
        },
        {
          "path": "plugins/harness/skills/plugin-structure/examples/standard-plugin.md",
          "type": "blob",
          "size": 13310
        },
        {
          "path": "plugins/harness/skills/plugin-structure/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/plugin-structure/references/component-patterns.md",
          "type": "blob",
          "size": 12086
        },
        {
          "path": "plugins/harness/skills/plugin-structure/references/manifest-reference.md",
          "type": "blob",
          "size": 12061
        },
        {
          "path": "plugins/harness/skills/skill-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/skill-development/SKILL.md",
          "type": "blob",
          "size": 23778
        },
        {
          "path": "plugins/harness/skills/skill-development/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/harness/skills/skill-development/references/skill-creator-original.md",
          "type": "blob",
          "size": 11547
        }
      ],
      "marketplace": {
        "name": "astrosteveo-marketplace",
        "version": null,
        "description": "Personal plugin marketplace - feature workflows and semantic memory for Claude Code",
        "owner_info": {
          "name": "Steven Mosley",
          "email": "34114851+astrosteveo@users.noreply.github.com"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "harness",
            "description": "Feature development workflow and plugin creation skills for Claude Code",
            "source": "./plugins/harness",
            "category": "development",
            "version": null,
            "author": {
              "name": "Steven Mosley",
              "email": "34114851+astrosteveo@users.noreply.github.com"
            },
            "install_commands": [
              "/plugin marketplace add astrosteveo/marketplace",
              "/plugin install harness@astrosteveo-marketplace"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-12T03:32:51Z",
              "created_at": "2026-01-09T21:25:44Z",
              "license": null
            },
            "commands": [
              {
                "name": "/feature",
                "description": "Start or resume feature development workflow",
                "path": "plugins/harness/commands/feature.md",
                "frontmatter": {
                  "description": "Start or resume feature development workflow",
                  "allowed-tools": "Read, Write, Edit, Bash, Glob, Grep, Task, TodoWrite, mcp__plugin_engram-mcp_engram__memory_search, mcp__plugin_engram-mcp_engram__memory_remember, mcp__plugin_engram-mcp_engram__memory_sync",
                  "argument-hint": "<feature-description> [--phase <name>] [--tdd] [--skip <phase>]"
                },
                "content": "# Feature Development Workflow\n\nYou are orchestrating a structured feature development workflow. Drive the process autonomously, pausing only at decision points where user input is required.\n\n## Arguments\n\n- `$ARGUMENTS` - Feature description and optional flags\n- `--phase <name>` - Jump to specific phase (discovery, explore, requirements, design, implement, review, testing, summary)\n- `--tdd` - Use test-driven development for implementation\n- `--skip <phase>` - Skip a phase (can be repeated)\n\n---\n\n# Initialization\n\n## Step 1: Search Project Memory\n\nUse `mcp__plugin_engram-mcp_engram__memory_search` to find relevant past context:\n- Previous work on similar features\n- Past architectural decisions that might apply\n- Lessons learned from related implementations\n\nIf relevant findings exist, present them: \"I found previous context that may be relevant: [summary]\"\n\n## Step 2: Check for Existing Artifacts\n\nCheck if resuming an existing feature:\n```bash\nls -la .artifacts/*/progress.md 2>/dev/null\n```\n\n**If artifacts exist:**\n1. Read `progress.md` to determine current phase\n2. Present: \"Resuming **{feature-name}** from **{phase}**\"\n3. Jump to that phase\n\n**If no artifacts:** Proceed to Phase 1: Discovery\n\n## Step 3: Load Configuration\n\nRead configuration (in priority order, merge settings):\n1. `.claude/harness.yaml` (project overrides)\n2. `~/.claude/harness.yaml` (user defaults)\n3. `${CLAUDE_PLUGIN_ROOT}/config/workflow.yaml` (plugin defaults)\n\nNote: skipped phases, TDD mode, agent count, model preferences.\n\n---\n\n# Phase 1: Discovery\n\n**Goal:** Understand what needs to be built and set up tracking.\n\n## Actions\n\n1. Generate `feature-slug` from the feature name (lowercase, hyphenated)\n2. Create `.artifacts/{feature-slug}/` directory\n3. If the feature request is unclear, ask:\n   - What problem are you solving?\n   - What should the feature do?\n   - Any constraints or requirements?\n4. Summarize understanding and confirm with user\n\n## Artifact: progress.md\n\nCreate `.artifacts/{feature-slug}/progress.md`:\n\n```markdown\n# {Feature Name} - Progress\n\n## Status\nPhase: Discovery\nStarted: {date}\nLast Updated: {date}\n\n## Checklist\n- [x] Discovery\n- [ ] Codebase Exploration\n- [ ] Requirements\n- [ ] Architecture Design\n- [ ] Implementation\n- [ ] Code Review\n- [ ] Testing\n- [ ] Summary\n\n## Session Log\n### {date}\n- Started feature development\n- Initial request: {summary}\n```\n\n## Git Commit\n\n```\ndocs({feature-slug}): initialize feature tracking\n```\n\n**Automatic transition** to Phase 2.\n\n---\n\n# Phase 2: Explore Codebase\n\n**Goal:** Deep understanding of existing patterns and architecture.\n\n## Actions\n\n1. Launch 2-3 `code-explorer` agents in parallel using Task tool with `subagent_type: \"harness:code-explorer\"`. Each agent should focus on a different aspect:\n   - \"Find similar features and trace their implementation\"\n   - \"Map the architecture and abstractions for this area\"\n   - \"Identify integration points and extension patterns\"\n\n2. Wait for agents to complete\n\n3. Read all key files identified by the agents\n\n4. Present comprehensive summary of findings\n\n## Artifact Update\n\nAdd to `progress.md`:\n\n```markdown\n## Codebase Exploration\n\n### Key Patterns\n- {Pattern 1}: {description}\n- {Pattern 2}: {description}\n\n### Relevant Files\n| File | Purpose | Relevance |\n|------|---------|-----------|\n| `{path}` | {what it does} | {why it matters} |\n\n### Architecture Notes\n{High-level structure understanding}\n\n### Integration Points\n{Where the new feature connects to existing code}\n```\n\n## Git Commit\n\n```\ndocs({feature-slug}): document codebase exploration\n```\n\n**Automatic transition** to Phase 3.\n\n---\n\n# Phase 3: Gather Requirements\n\n**Goal:** Resolve all ambiguities before designing.\n\n**CRITICAL:** This phase is essential. Do not skip.\n\n## Actions\n\n1. Review exploration findings and original request\n2. Identify underspecified aspects:\n   - Edge cases\n   - Error handling\n   - Integration points\n   - Scope boundaries\n   - Performance needs\n3. **Ask questions ONE AT A TIME**\n4. **For each question, provide a recommendation**\n5. Wait for user answer before asking the next question\n6. Continue until all ambiguities resolved\n\n## Question Format\n\n```\n**Question {N}/{Total}**: {The specific question}\n\n**Recommendation:** {Your suggested answer with rationale}\n```\n\nIf user says \"whatever you think is best\", apply your recommendation and confirm.\n\n## PAUSE POINT\n\nWait for user answers to each question.\n\n## Artifact: requirements.md\n\nAfter all questions answered, create `.artifacts/{feature-slug}/requirements.md`:\n\n```markdown\n# {Feature Name} - Requirements\n\n## Overview\n{Brief description}\n\n## Problem Statement\n{What problem this solves}\n\n## User Stories\n- As a {user}, I want to {action} so that {benefit}\n\n## Functional Requirements\n1. {Requirement 1}\n2. {Requirement 2}\n\n## Non-Functional Requirements\n- Performance: {constraints}\n- Compatibility: {constraints}\n\n## Clarifications\n### Q: {Question 1}\nA: {Answer}\n\n## Out of Scope\n- {Excluded items}\n```\n\n## Git Commit\n\n```\ndocs({feature-slug}): finalize requirements\n```\n\n**Automatic transition** to Phase 4.\n\n---\n\n# Phase 4: Design Architecture\n\n**Goal:** Evaluate multiple approaches and select the best one.\n\n## Actions\n\n1. Search engram for past architectural patterns relevant to this feature type\n\n2. Launch 2-3 `code-architect` agents in parallel using Task tool with `subagent_type: \"harness:code-architect\"`. Each with a different focus:\n   - **Minimal changes**: Smallest change, maximum reuse\n   - **Clean architecture**: Maintainability, elegant abstractions\n   - **Pragmatic balance**: Speed + quality trade-off\n\n3. Review all approaches and form your recommendation\n\n4. Present to user:\n   - Brief summary of each approach\n   - Trade-offs comparison\n   - **Your recommendation with reasoning**\n\n## PAUSE POINT\n\nAsk user: \"Which approach would you like to use?\"\n\n## Artifact: design.md\n\nAfter user selects, create `.artifacts/{feature-slug}/design.md`:\n\n```markdown\n# {Feature Name} - Design\n\n## Chosen Approach\n{Name}\n\n## Rationale\n{Why selected}\n\n## Approaches Considered\n\n### Approach A: {Name}\n- **Summary**: {description}\n- **Pros**: {list}\n- **Cons**: {list}\n\n### Approach B: {Name}\n...\n\n## Architecture Overview\n{High-level description}\n\n## Component Design\n### {Component 1}\n- Purpose: {what it does}\n- Interface: {public API}\n- Dependencies: {what it uses}\n\n## Data Flow\n{How data moves through the system}\n\n## Risks and Mitigations\n| Risk | Mitigation |\n|------|------------|\n| {risk} | {mitigation} |\n```\n\n## Git Commit\n\n```\ndocs({feature-slug}): select {approach-name} architecture\n```\n\n**Automatic transition** to Phase 5.\n\n---\n\n# Phase 5: Implement Feature\n\n**Goal:** Build the feature following the approved design.\n\nCheck if TDD mode is enabled (via `--tdd` flag or config `tdd.mode: always`).\n\n## If TDD Mode\n\nFollow the red-green-refactor cycle:\n\n### TDD Setup\n1. Verify test framework is configured\n2. Create `test-plan.md` with ordered test cases (simplest to complex)\n\n### For Each Test Case\n1. **RED**: Write failing test, verify it fails, commit: `test({feature-slug}): add failing test for {behavior}`\n2. **GREEN**: Write minimum code to pass, commit: `feat({feature-slug}): implement {behavior}`\n3. **REFACTOR**: Clean up if needed, commit: `refactor({feature-slug}): {description}`\n\n### TDD Artifacts\n- `.artifacts/{feature-slug}/test-plan.md` - Ordered test cases\n- `.artifacts/{feature-slug}/tdd-progress.md` - Cycle tracking\n\n## If Standard Mode\n\n### PAUSE POINT\n\nPresent implementation plan and wait for approval before coding.\n\n## Artifact: plan.md\n\nCreate `.artifacts/{feature-slug}/plan.md`:\n\n```markdown\n# {Feature Name} - Implementation Plan\n\n## Files to Modify\n| File | Changes |\n|------|---------|\n| `{path}` | {what changes} |\n\n## Files to Create\n| File | Purpose |\n|------|---------|\n| `{path}` | {purpose} |\n\n## Implementation Steps\n1. [ ] {Step 1}\n2. [ ] {Step 2}\n\n## Testing Strategy\n{How to verify it works}\n```\n\n## Implementation\n\nAfter approval:\n1. Implement following the plan\n2. Follow codebase conventions strictly\n3. Update todos as you progress\n4. Commit frequently:\n   - `feat({feature-slug}): {description}`\n   - `fix({feature-slug}): {description}`\n\n## Git Commits\n\nFrequent throughout:\n```\nfeat({feature-slug}): add {component}\nfeat({feature-slug}): implement {behavior}\nfix({feature-slug}): {fix description}\n```\n\n**Automatic transition** to Phase 6.\n\n---\n\n# Phase 6: Code Review\n\n**Goal:** Ensure quality and correctness.\n\n## Actions\n\n1. Launch 3 `code-reviewer` agents in parallel using Task tool with `subagent_type: \"harness:code-reviewer\"`. Each with different focus:\n   - **Simplicity/DRY/Elegance**: Duplication, complexity, clarity\n   - **Bugs/Correctness**: Logic errors, edge cases, runtime issues\n   - **Conventions/Patterns**: Consistency with codebase\n\n2. Consolidate findings by severity\n\n3. Present findings organized as:\n   - High Priority (recommend fixing now)\n   - Medium Priority (consider fixing)\n   - Low Priority (nice to have)\n\n4. Ask user: \"What would you like to do?\"\n   - Fix now\n   - Fix later\n   - Proceed as-is\n\n5. Address issues based on user decision\n\n## Artifact Update\n\nAdd to `progress.md`:\n\n```markdown\n## Code Review\n\n### Issues Found\n| Severity | Issue | Resolution |\n|----------|-------|------------|\n| High | {issue} | Fixed / Deferred / Accepted |\n\n### Summary\n- Total: {N}, Fixed: {N}, Deferred: {N}\n```\n\n## Git Commits\n\n```\nfix({feature-slug}): {fix from review}\n```\n\n**Automatic transition** to Phase 7.\n\n---\n\n# Phase 7: Testing Verification\n\n**Goal:** User verifies the feature works correctly.\n\n**CRITICAL:** Do not skip. Feature cannot be closed until user confirms.\n\n## Actions\n\n1. Read `requirements.md` to understand what needs testing\n2. Present testing checklist with clear steps and expected results\n3. Ask user to perform tests and report back\n\n## Testing Checklist Format\n\n```markdown\n## Manual Testing\n\nPlease test and confirm each works:\n\n### Test 1: {Name}\n**Steps:**\n1. {Step 1}\n2. {Step 2}\n\n**Expected:** {What should happen}\n\n---\n\nReply with PASS or FAIL for each test.\n```\n\n## PAUSE POINT\n\nWait for user confirmation: \"Testing passed\" or issue reports.\n\n## If Issues Found\n\n1. Document the issue\n2. Fix it\n3. Commit: `fix({feature-slug}): {description}`\n4. Ask user to re-test\n\n## Artifact Update\n\nAdd to `progress.md`:\n\n```markdown\n## Testing\n- Date: {date}\n- Result: PASSED\n\n| Test | Result |\n|------|--------|\n| {name} | PASS |\n```\n\n## Git Commit\n\n```\ndocs({feature-slug}): record successful testing\n```\n\n**Automatic transition** to Phase 8.\n\n---\n\n# Phase 8: Summary\n\n**Goal:** Document completion and persist learnings.\n\n## Actions\n\n1. Mark all checklist items complete in `progress.md`\n2. Create `summary.md`\n3. Update `.artifacts/roadmap.md` if it exists:\n   - Move feature to \"Completed\" section\n   - Add deferred items to \"Planned\" section\n\n## Artifact: summary.md\n\nCreate `.artifacts/{feature-slug}/summary.md`:\n\n```markdown\n# {Feature Name} - Summary\n\n## Completed\n{Date}\n\n## What Was Built\n{Description}\n\n## Key Decisions\n| Decision | Rationale |\n|----------|-----------|\n| {decision} | {why} |\n\n## Files Changed\n| File | Changes |\n|------|---------|\n| `{path}` | {summary} |\n\n## Testing\n- Result: PASSED\n- {What was verified}\n\n## Known Limitations\n- {Any limitations}\n\n## Future Improvements\n- {Potential enhancements}\n\n## Lessons Learned\n- {What went well}\n- {What could improve}\n```\n\n## Persist to Memory\n\nUse `mcp__plugin_engram-mcp_engram__memory_remember` to save key learnings:\n\n```\nFor {feature-name}: Implemented using {pattern}. Key decision: {decision}. Lesson: {lesson}.\n```\n\n## Sync Session\n\nUse `mcp__plugin_engram-mcp_engram__memory_sync` to index this session.\n\n## Git Commit\n\n```\ndocs({feature-slug}): complete feature summary\n```\n\n## Complete\n\nCongratulate the user:\n- Phases completed\n- Artifacts created\n- Key accomplishments\n\n---\n\n# Phase Navigation\n\nJump to any phase with `--phase`:\n\n| Phase | Name |\n|-------|------|\n| 1 | `discovery` |\n| 2 | `explore` |\n| 3 | `requirements` |\n| 4 | `design` |\n| 5 | `implement` |\n| 6 | `review` |\n| 7 | `testing` |\n| 8 | `summary` |\n\nExample: `/harness:feature --phase design`\n\n---\n\n# Error Recovery\n\nIf something goes wrong:\n1. Check `progress.md` for last known state\n2. Restart phase: `/harness:feature --phase {name}`\n3. Search engram for similar past issues"
              }
            ],
            "skills": [
              {
                "name": "agent-development",
                "description": "This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins.",
                "path": "plugins/harness/skills/agent-development/SKILL.md",
                "frontmatter": {
                  "name": "agent-development",
                  "description": "This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins."
                },
                "content": "# Agent Development for Claude Code Plugins\n\n## Overview\n\nAgents are autonomous subprocesses that handle complex, multi-step tasks independently. Understanding agent structure, triggering conditions, and system prompt design enables creating powerful autonomous capabilities.\n\n**Key concepts:**\n- Agents are FOR autonomous work, commands are FOR user-initiated actions\n- Markdown file format with YAML frontmatter\n- Triggering via description field with examples\n- System prompt defines agent behavior\n- Model and color customization\n\n## Agent File Structure\n\n### Complete Format\n\n```markdown\n---\nname: agent-identifier\ndescription: Use this agent when [triggering conditions]. Examples:\n\n<example>\nContext: [Situation description]\nuser: \"[User request]\"\nassistant: \"[How assistant should respond and use this agent]\"\n<commentary>\n[Why this agent should be triggered]\n</commentary>\n</example>\n\n<example>\n[Additional example...]\n</example>\n\nmodel: inherit\ncolor: blue\ntools: [\"Read\", \"Write\", \"Grep\"]\n---\n\nYou are [agent role description]...\n\n**Your Core Responsibilities:**\n1. [Responsibility 1]\n2. [Responsibility 2]\n\n**Analysis Process:**\n[Step-by-step workflow]\n\n**Output Format:**\n[What to return]\n```\n\n## Frontmatter Fields\n\n### name (required)\n\nAgent identifier used for namespacing and invocation.\n\n**Format:** lowercase, numbers, hyphens only\n**Length:** 3-50 characters\n**Pattern:** Must start and end with alphanumeric\n\n**Good examples:**\n- `code-reviewer`\n- `test-generator`\n- `api-docs-writer`\n- `security-analyzer`\n\n**Bad examples:**\n- `helper` (too generic)\n- `-agent-` (starts/ends with hyphen)\n- `my_agent` (underscores not allowed)\n- `ag` (too short, < 3 chars)\n\n### description (required)\n\nDefines when Claude should trigger this agent. **This is the most critical field.**\n\n**Must include:**\n1. Triggering conditions (\"Use this agent when...\")\n2. Multiple `<example>` blocks showing usage\n3. Context, user request, and assistant response in each example\n4. `<commentary>` explaining why agent triggers\n\n**Format:**\n```\nUse this agent when [conditions]. Examples:\n\n<example>\nContext: [Scenario description]\nuser: \"[What user says]\"\nassistant: \"[How Claude should respond]\"\n<commentary>\n[Why this agent is appropriate]\n</commentary>\n</example>\n\n[More examples...]\n```\n\n**Best practices:**\n- Include 2-4 concrete examples\n- Show proactive and reactive triggering\n- Cover different phrasings of same intent\n- Explain reasoning in commentary\n- Be specific about when NOT to use the agent\n\n### model (optional)\n\nWhich model the agent should use.\n\n**Options:**\n- `inherit` - Use same model as parent (recommended)\n- `sonnet` - Claude Sonnet (balanced)\n- `opus` - Claude Opus (most capable, expensive)\n- `haiku` - Claude Haiku (fast, cheap)\n\n**Recommendation:** Use `inherit` unless agent needs specific model capabilities.\n\n### color (optional)\n\nVisual identifier for agent in UI.\n\n**Options:** `red`, `blue`, `green`, `yellow`, `purple`, `orange`, `pink`, `cyan`\n\n**Guidelines:**\n- Choose distinct colors for different agents in same plugin\n- Use consistent colors for similar agent types\n- Blue/cyan: Analysis, review\n- Green: Success-oriented tasks\n- Yellow: Caution, validation\n- Red: Critical, security\n- Purple/pink: Creative, generation\n- Orange: Warnings, attention\n\n### tools (optional)\n\nRestrict agent to specific tools.\n\n**Format:** Array of tool names\n\n```yaml\ntools: [\"Read\", \"Write\", \"Grep\", \"Bash\"]\n```\n\n**Default:** If omitted, agent has access to all tools\n\n**Best practice:** Limit tools to minimum needed (principle of least privilege)\n\n**Common tool sets:**\n- Read-only analysis: `[\"Read\", \"Grep\", \"Glob\"]`\n- Code generation: `[\"Read\", \"Write\", \"Grep\"]`\n- Testing: `[\"Read\", \"Bash\", \"Grep\"]`\n- Full access: Omit field or use `[\"*\"]`\n\n### permissionMode (optional)\n\nControls how the subagent handles permission requests.\n\n**Options:**\n- `default` - Standard permission handling\n- `acceptEdits` - Auto-accept file edits\n- `dontAsk` - Skip confirmation prompts\n- `bypassPermissions` - Skip all permission checks\n- `plan` - Plan mode (read-only exploration)\n- `ignore` - Ignore permission requests\n\n**Example:**\n```yaml\npermissionMode: acceptEdits\n```\n\n### skills (optional)\n\nList of skill names to auto-load when the subagent starts.\n\n**Important:** Subagents do NOT inherit skills from the parent conversation. If you want a subagent to have access to specific skills, you must list them explicitly.\n\n**Format:** Comma-separated list\n\n```yaml\nskills: security-check, code-review, testing-standards\n```\n\n**Use when:**\n- Subagent needs specialized knowledge from skills\n- Consistent behavior across subagent invocations\n- Domain-specific guidance is required\n\n### hooks (optional)\n\nDefine hooks scoped to this subagent's lifecycle.\n\n**Supported events:** `PreToolUse`, `PostToolUse`, `Stop`\n\n**Example:**\n```yaml\nhooks:\n  PostToolUse:\n    - matcher: \"Edit|Write\"\n      hooks:\n        - type: command\n          command: \"./scripts/run-linter.sh\"\n```\n\nHooks defined in a subagent are scoped to that subagent's execution and are automatically cleaned up when the subagent finishes.\n\n## System Prompt Design\n\nThe markdown body becomes the agent's system prompt. Write in second person, addressing the agent directly.\n\n### Structure\n\n**Standard template:**\n```markdown\nYou are [role] specializing in [domain].\n\n**Your Core Responsibilities:**\n1. [Primary responsibility]\n2. [Secondary responsibility]\n3. [Additional responsibilities...]\n\n**Analysis Process:**\n1. [Step one]\n2. [Step two]\n3. [Step three]\n[...]\n\n**Quality Standards:**\n- [Standard 1]\n- [Standard 2]\n\n**Output Format:**\nProvide results in this format:\n- [What to include]\n- [How to structure]\n\n**Edge Cases:**\nHandle these situations:\n- [Edge case 1]: [How to handle]\n- [Edge case 2]: [How to handle]\n```\n\n### Best Practices\n\n✅ **DO:**\n- Write in second person (\"You are...\", \"You will...\")\n- Be specific about responsibilities\n- Provide step-by-step process\n- Define output format\n- Include quality standards\n- Address edge cases\n- Keep under 10,000 characters\n\n❌ **DON'T:**\n- Write in first person (\"I am...\", \"I will...\")\n- Be vague or generic\n- Omit process steps\n- Leave output format undefined\n- Skip quality guidance\n- Ignore error cases\n\n## Creating Agents\n\n### Method 1: AI-Assisted Generation\n\nUse this prompt pattern (extracted from Claude Code):\n\n```\nCreate an agent configuration based on this request: \"[YOUR DESCRIPTION]\"\n\nRequirements:\n1. Extract core intent and responsibilities\n2. Design expert persona for the domain\n3. Create comprehensive system prompt with:\n   - Clear behavioral boundaries\n   - Specific methodologies\n   - Edge case handling\n   - Output format\n4. Create identifier (lowercase, hyphens, 3-50 chars)\n5. Write description with triggering conditions\n6. Include 2-3 <example> blocks showing when to use\n\nReturn JSON with:\n{\n  \"identifier\": \"agent-name\",\n  \"whenToUse\": \"Use this agent when... Examples: <example>...</example>\",\n  \"systemPrompt\": \"You are...\"\n}\n```\n\nThen convert to agent file format with frontmatter.\n\nSee `examples/agent-creation-prompt.md` for complete template.\n\n### Method 2: Manual Creation\n\n1. Choose agent identifier (3-50 chars, lowercase, hyphens)\n2. Write description with examples\n3. Select model (usually `inherit`)\n4. Choose color for visual identification\n5. Define tools (if restricting access)\n6. Write system prompt with structure above\n7. Save as `agents/agent-name.md`\n\n## Validation Rules\n\n### Identifier Validation\n\n```\n✅ Valid: code-reviewer, test-gen, api-analyzer-v2\n❌ Invalid: ag (too short), -start (starts with hyphen), my_agent (underscore)\n```\n\n**Rules:**\n- 3-50 characters\n- Lowercase letters, numbers, hyphens only\n- Must start and end with alphanumeric\n- No underscores, spaces, or special characters\n\n### Description Validation\n\n**Length:** 10-5,000 characters\n**Must include:** Triggering conditions and examples\n**Best:** 200-1,000 characters with 2-4 examples\n\n### System Prompt Validation\n\n**Length:** 20-10,000 characters\n**Best:** 500-3,000 characters\n**Structure:** Clear responsibilities, process, output format\n\n## Agent Organization\n\n### Plugin Agents Directory\n\n```\nplugin-name/\n└── agents/\n    ├── analyzer.md\n    ├── reviewer.md\n    └── generator.md\n```\n\nAll `.md` files in `agents/` are auto-discovered.\n\n### Namespacing\n\nAgents are namespaced automatically:\n- Single plugin: `agent-name`\n- With subdirectories: `plugin:subdir:agent-name`\n\n## Testing Agents\n\n### Test Triggering\n\nCreate test scenarios to verify agent triggers correctly:\n\n1. Write agent with specific triggering examples\n2. Use similar phrasing to examples in test\n3. Check Claude loads the agent\n4. Verify agent provides expected functionality\n\n### Test System Prompt\n\nEnsure system prompt is complete:\n\n1. Give agent typical task\n2. Check it follows process steps\n3. Verify output format is correct\n4. Test edge cases mentioned in prompt\n5. Confirm quality standards are met\n\n## Quick Reference\n\n### Minimal Agent\n\n```markdown\n---\nname: simple-agent\ndescription: Use this agent when... Examples: <example>...</example>\n---\n\nYou are an agent that [does X].\n\nProcess:\n1. [Step 1]\n2. [Step 2]\n\nOutput: [What to provide]\n```\n\n### Frontmatter Fields Summary\n\n| Field | Required | Format | Example |\n|-------|----------|--------|---------|\n| name | Yes | lowercase-hyphens | code-reviewer |\n| description | Yes | Text + examples | Use when... <example>... |\n| model | No | inherit/sonnet/opus/haiku | inherit |\n| color | No | Color name | blue |\n| tools | No | Array of tool names | [\"Read\", \"Grep\"] |\n| permissionMode | No | Permission mode | acceptEdits |\n| skills | No | Comma-separated list | security-check, code-review |\n| hooks | No | Hook configuration | See hooks section |\n\n### Best Practices\n\n**DO:**\n- ✅ Include 2-4 concrete examples in description\n- ✅ Write specific triggering conditions\n- ✅ Use `inherit` for model unless specific need\n- ✅ Choose appropriate tools (least privilege)\n- ✅ Write clear, structured system prompts\n- ✅ Test agent triggering thoroughly\n\n**DON'T:**\n- ❌ Use generic descriptions without examples\n- ❌ Omit triggering conditions\n- ❌ Give all agents same color\n- ❌ Grant unnecessary tool access\n- ❌ Write vague system prompts\n- ❌ Skip testing\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed guidance, consult:\n\n- **`references/system-prompt-design.md`** - Complete system prompt patterns\n- **`references/triggering-examples.md`** - Example formats and best practices\n- **`references/agent-creation-system-prompt.md`** - The exact prompt from Claude Code\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`agent-creation-prompt.md`** - AI-assisted agent generation template\n- **`complete-agent-examples.md`** - Full agent examples for different use cases\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-agent.sh`** - Validate agent file structure\n- **`test-agent-trigger.sh`** - Test if agent triggers correctly\n\n## Implementation Workflow\n\nTo create an agent for a plugin:\n\n1. Define agent purpose and triggering conditions\n2. Choose creation method (AI-assisted or manual)\n3. Create `agents/agent-name.md` file\n4. Write frontmatter with all required fields\n5. Write system prompt following best practices\n6. Include 2-4 triggering examples in description\n7. Validate with `scripts/validate-agent.sh`\n8. Test triggering with real scenarios\n9. Document agent in plugin README\n\nFocus on clear triggering conditions and comprehensive system prompts for autonomous operation."
              },
              {
                "name": "command-development",
                "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
                "path": "plugins/harness/skills/command-development/SKILL.md",
                "frontmatter": {
                  "name": "command-development",
                  "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code."
                },
                "content": "# Command Development for Claude Code\n\n## Overview\n\nSlash commands are frequently-used prompts defined as Markdown files that Claude executes during interactive sessions. Understanding command structure, frontmatter options, and dynamic features enables creating powerful, reusable workflows.\n\n**Key concepts:**\n- Markdown file format for commands\n- YAML frontmatter for configuration\n- Dynamic arguments and file references\n- Bash execution for context\n- Command organization and namespacing\n\n## Command Basics\n\n### What is a Slash Command?\n\nA slash command is a Markdown file containing a prompt that Claude executes when invoked. Commands provide:\n- **Reusability**: Define once, use repeatedly\n- **Consistency**: Standardize common workflows\n- **Sharing**: Distribute across team or projects\n- **Efficiency**: Quick access to complex prompts\n\n### Critical: Commands are Instructions FOR Claude\n\n**Commands are written for agent consumption, not human consumption.**\n\nWhen a user invokes `/command-name`, the command content becomes Claude's instructions. Write commands as directives TO Claude about what to do, not as messages TO the user.\n\n**Correct approach (instructions for Claude):**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication issues\n\nProvide specific line numbers and severity ratings.\n```\n\n**Incorrect approach (messages to user):**\n```markdown\nThis command will review your code for security issues.\nYou'll receive a report with vulnerability details.\n```\n\nThe first example tells Claude what to do. The second tells the user what will happen but doesn't instruct Claude. Always use the first approach.\n\n### Command Locations\n\n**Project commands** (shared with team):\n- Location: `.claude/commands/`\n- Scope: Available in specific project\n- Label: Shown as \"(project)\" in `/help`\n- Use for: Team workflows, project-specific tasks\n\n**Personal commands** (available everywhere):\n- Location: `~/.claude/commands/`\n- Scope: Available in all projects\n- Label: Shown as \"(user)\" in `/help`\n- Use for: Personal workflows, cross-project utilities\n\n**Plugin commands** (bundled with plugins):\n- Location: `plugin-name/commands/`\n- Scope: Available when plugin installed\n- Label: Shown as \"(plugin-name)\" in `/help`\n- Use for: Plugin-specific functionality\n\n## File Format\n\n### Basic Structure\n\nCommands are Markdown files with `.md` extension:\n\n```\n.claude/commands/\n├── review.md           # /review command\n├── test.md             # /test command\n└── deploy.md           # /deploy command\n```\n\n**Simple command:**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication bypass\n- Insecure data handling\n```\n\nNo frontmatter needed for basic commands.\n\n### With YAML Frontmatter\n\nAdd configuration using YAML frontmatter:\n\n```markdown\n---\ndescription: Review code for security issues\nallowed-tools: Read, Grep, Bash(git:*)\nmodel: sonnet\n---\n\nReview this code for security vulnerabilities...\n```\n\n## YAML Frontmatter Fields\n\n### description\n\n**Purpose:** Brief description shown in `/help`\n**Type:** String\n**Default:** First line of command prompt\n\n```yaml\n---\ndescription: Review pull request for code quality\n---\n```\n\n**Best practice:** Clear, actionable description (under 60 characters)\n\n### allowed-tools\n\n**Purpose:** Specify which tools command can use\n**Type:** String or Array\n**Default:** Inherits from conversation\n\n```yaml\n---\nallowed-tools: Read, Write, Edit, Bash(git:*)\n---\n```\n\n**Patterns:**\n- `Read, Write, Edit` - Specific tools\n- `Bash(git:*)` - Bash with git commands only\n- `*` - All tools (rarely needed)\n\n**Use when:** Command requires specific tool access\n\n### model\n\n**Purpose:** Specify model for command execution\n**Type:** String (sonnet, opus, haiku)\n**Default:** Inherits from conversation\n\n```yaml\n---\nmodel: haiku\n---\n```\n\n**Use cases:**\n- `haiku` - Fast, simple commands\n- `sonnet` - Standard workflows\n- `opus` - Complex analysis\n\n### argument-hint\n\n**Purpose:** Document expected arguments for autocomplete\n**Type:** String\n**Default:** None\n\n```yaml\n---\nargument-hint: [pr-number] [priority] [assignee]\n---\n```\n\n**Benefits:**\n- Helps users understand command arguments\n- Improves command discovery\n- Documents command interface\n\n### disable-model-invocation\n\n**Purpose:** Prevent Skill tool from programmatically calling command\n**Type:** Boolean\n**Default:** false\n\n```yaml\n---\ndisable-model-invocation: true\n---\n```\n\n**Use when:** Command should only be manually invoked by user, not by Claude programmatically\n\n### hooks\n\n**Purpose:** Define hooks scoped to this command's execution\n**Type:** Object with PreToolUse, PostToolUse, or Stop handlers\n**Default:** None\n\n```yaml\n---\nhooks:\n  PreToolUse:\n    - matcher: \"Bash\"\n      hooks:\n        - type: command\n          command: \"./scripts/validate-deploy.sh\"\n          once: true\n---\n```\n\n**Features:**\n- Hooks only run during command execution\n- Automatically cleaned up when command finishes\n- `once: true` runs hook only once per session\n- Supports same format as settings-based hooks\n\n**Use when:** Command needs temporary validation or automation during its execution\n\n## Dynamic Arguments\n\n### Using $ARGUMENTS\n\nCapture all arguments as single string:\n\n```markdown\n---\ndescription: Fix issue by number\nargument-hint: [issue-number]\n---\n\nFix issue #$ARGUMENTS following our coding standards and best practices.\n```\n\n**Usage:**\n```\n> /fix-issue 123\n> /fix-issue 456\n```\n\n**Expands to:**\n```\nFix issue #123 following our coding standards...\nFix issue #456 following our coding standards...\n```\n\n### Using Positional Arguments\n\nCapture individual arguments with `$1`, `$2`, `$3`, etc.:\n\n```markdown\n---\ndescription: Review PR with priority and assignee\nargument-hint: [pr-number] [priority] [assignee]\n---\n\nReview pull request #$1 with priority level $2.\nAfter review, assign to $3 for follow-up.\n```\n\n**Usage:**\n```\n> /review-pr 123 high alice\n```\n\n**Expands to:**\n```\nReview pull request #123 with priority level high.\nAfter review, assign to alice for follow-up.\n```\n\n### Combining Arguments\n\nMix positional and remaining arguments:\n\n```markdown\nDeploy $1 to $2 environment with options: $3\n```\n\n**Usage:**\n```\n> /deploy api staging --force --skip-tests\n```\n\n**Expands to:**\n```\nDeploy api to staging environment with options: --force --skip-tests\n```\n\n## File References\n\n### Using @ Syntax\n\nInclude file contents in command:\n\n```markdown\n---\ndescription: Review specific file\nargument-hint: [file-path]\n---\n\nReview @$1 for:\n- Code quality\n- Best practices\n- Potential bugs\n```\n\n**Usage:**\n```\n> /review-file src/api/users.ts\n```\n\n**Effect:** Claude reads `src/api/users.ts` before processing command\n\n### Multiple File References\n\nReference multiple files:\n\n```markdown\nCompare @src/old-version.js with @src/new-version.js\n\nIdentify:\n- Breaking changes\n- New features\n- Bug fixes\n```\n\n### Static File References\n\nReference known files without arguments:\n\n```markdown\nReview @package.json and @tsconfig.json for consistency\n\nEnsure:\n- TypeScript version matches\n- Dependencies are aligned\n- Build configuration is correct\n```\n\n## Bash Execution in Commands\n\nCommands can execute bash commands inline to dynamically gather context before Claude processes the command. This is useful for including repository state, environment information, or project-specific context.\n\n**When to use:**\n- Include dynamic context (git status, environment vars, etc.)\n- Gather project/repository state\n- Build context-aware workflows\n\n**Implementation details:**\nFor complete syntax, examples, and best practices, see `references/plugin-features-reference.md` section on bash execution. The reference includes the exact syntax and multiple working examples to avoid execution issues\n\n## Command Organization\n\n### Flat Structure\n\nSimple organization for small command sets:\n\n```\n.claude/commands/\n├── build.md\n├── test.md\n├── deploy.md\n├── review.md\n└── docs.md\n```\n\n**Use when:** 5-15 commands, no clear categories\n\n### Namespaced Structure\n\nOrganize commands in subdirectories:\n\n```\n.claude/commands/\n├── ci/\n│   ├── build.md        # /build (project:ci)\n│   ├── test.md         # /test (project:ci)\n│   └── lint.md         # /lint (project:ci)\n├── git/\n│   ├── commit.md       # /commit (project:git)\n│   └── pr.md           # /pr (project:git)\n└── docs/\n    ├── generate.md     # /generate (project:docs)\n    └── publish.md      # /publish (project:docs)\n```\n\n**Benefits:**\n- Logical grouping by category\n- Namespace shown in `/help`\n- Easier to find related commands\n\n**Use when:** 15+ commands, clear categories\n\n## Best Practices\n\n### Command Design\n\n1. **Single responsibility:** One command, one task\n2. **Clear descriptions:** Self-explanatory in `/help`\n3. **Explicit dependencies:** Use `allowed-tools` when needed\n4. **Document arguments:** Always provide `argument-hint`\n5. **Consistent naming:** Use verb-noun pattern (review-pr, fix-issue)\n\n### Argument Handling\n\n1. **Validate arguments:** Check for required arguments in prompt\n2. **Provide defaults:** Suggest defaults when arguments missing\n3. **Document format:** Explain expected argument format\n4. **Handle edge cases:** Consider missing or invalid arguments\n\n```markdown\n---\nargument-hint: [pr-number]\n---\n\n$IF($1,\n  Review PR #$1,\n  Please provide a PR number. Usage: /review-pr [number]\n)\n```\n\n### File References\n\n1. **Explicit paths:** Use clear file paths\n2. **Check existence:** Handle missing files gracefully\n3. **Relative paths:** Use project-relative paths\n4. **Glob support:** Consider using Glob tool for patterns\n\n### Bash Commands\n\n1. **Limit scope:** Use `Bash(git:*)` not `Bash(*)`\n2. **Safe commands:** Avoid destructive operations\n3. **Handle errors:** Consider command failures\n4. **Keep fast:** Long-running commands slow invocation\n\n### Documentation\n\n1. **Add comments:** Explain complex logic\n2. **Provide examples:** Show usage in comments\n3. **List requirements:** Document dependencies\n4. **Version commands:** Note breaking changes\n\n```markdown\n---\ndescription: Deploy application to environment\nargument-hint: [environment] [version]\n---\n\n<!--\nUsage: /deploy [staging|production] [version]\nRequires: AWS credentials configured\nExample: /deploy staging v1.2.3\n-->\n\nDeploy application to $1 environment using version $2...\n```\n\n## Common Patterns\n\n### Review Pattern\n\n```markdown\n---\ndescription: Review code changes\nallowed-tools: Read, Bash(git:*)\n---\n\nFiles changed: `git diff --name-only`\n\nReview each file for:\n1. Code quality and style\n2. Potential bugs or issues\n3. Test coverage\n4. Documentation needs\n\nProvide specific feedback for each file.\n```\n\n### Testing Pattern\n\n```markdown\n---\ndescription: Run tests for specific file\nargument-hint: [test-file]\nallowed-tools: Bash(npm:*)\n---\n\nRun tests: `npm test $1`\n\nAnalyze results and suggest fixes for failures.\n```\n\n### Documentation Pattern\n\n```markdown\n---\ndescription: Generate documentation for file\nargument-hint: [source-file]\n---\n\nGenerate comprehensive documentation for @$1 including:\n- Function/class descriptions\n- Parameter documentation\n- Return value descriptions\n- Usage examples\n- Edge cases and errors\n```\n\n### Workflow Pattern\n\n```markdown\n---\ndescription: Complete PR workflow\nargument-hint: [pr-number]\nallowed-tools: Bash(gh:*), Read\n---\n\nPR #$1 Workflow:\n\n1. Fetch PR: `gh pr view $1`\n2. Review changes\n3. Run checks\n4. Approve or request changes\n```\n\n## Troubleshooting\n\n**Command not appearing:**\n- Check file is in correct directory\n- Verify `.md` extension present\n- Ensure valid Markdown format\n- Restart Claude Code\n\n**Arguments not working:**\n- Verify `$1`, `$2` syntax correct\n- Check `argument-hint` matches usage\n- Ensure no extra spaces\n\n**Bash execution failing:**\n- Check `allowed-tools` includes Bash\n- Verify command syntax in backticks\n- Test command in terminal first\n- Check for required permissions\n\n**File references not working:**\n- Verify `@` syntax correct\n- Check file path is valid\n- Ensure Read tool allowed\n- Use absolute or project-relative paths\n\n## Plugin-Specific Features\n\n### CLAUDE_PLUGIN_ROOT Variable\n\nPlugin commands have access to `${CLAUDE_PLUGIN_ROOT}`, an environment variable that resolves to the plugin's absolute path.\n\n**Purpose:**\n- Reference plugin files portably\n- Execute plugin scripts\n- Load plugin configuration\n- Access plugin templates\n\n**Basic usage:**\n\n```markdown\n---\ndescription: Analyze using plugin script\nallowed-tools: Bash(node:*)\n---\n\nRun analysis: `node ${CLAUDE_PLUGIN_ROOT}/scripts/analyze.js $1`\n\nReview results and report findings.\n```\n\n**Common patterns:**\n\n```markdown\n# Execute plugin script\n`bash ${CLAUDE_PLUGIN_ROOT}/scripts/script.sh`\n\n# Load plugin configuration\n@${CLAUDE_PLUGIN_ROOT}/config/settings.json\n\n# Use plugin template\n@${CLAUDE_PLUGIN_ROOT}/templates/report.md\n\n# Access plugin resources\n@${CLAUDE_PLUGIN_ROOT}/docs/reference.md\n```\n\n**Why use it:**\n- Works across all installations\n- Portable between systems\n- No hardcoded paths needed\n- Essential for multi-file plugins\n\n### Plugin Command Organization\n\nPlugin commands discovered automatically from `commands/` directory:\n\n```\nplugin-name/\n├── commands/\n│   ├── foo.md              # /foo (plugin:plugin-name)\n│   ├── bar.md              # /bar (plugin:plugin-name)\n│   └── utils/\n│       └── helper.md       # /helper (plugin:plugin-name:utils)\n└── plugin.json\n```\n\n**Namespace benefits:**\n- Logical command grouping\n- Shown in `/help` output\n- Avoid name conflicts\n- Organize related commands\n\n**Naming conventions:**\n- Use descriptive action names\n- Avoid generic names (test, run)\n- Consider plugin-specific prefix\n- Use hyphens for multi-word names\n\n### Plugin Command Patterns\n\n**Configuration-based pattern:**\n\n```markdown\n---\ndescription: Deploy using plugin configuration\nargument-hint: [environment]\nallowed-tools: Read, Bash(*)\n---\n\nLoad configuration: @${CLAUDE_PLUGIN_ROOT}/config/$1-deploy.json\n\nDeploy to $1 using configuration settings.\nMonitor deployment and report status.\n```\n\n**Template-based pattern:**\n\n```markdown\n---\ndescription: Generate docs from template\nargument-hint: [component]\n---\n\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/docs.md\n\nGenerate documentation for $1 following template structure.\n```\n\n**Multi-script pattern:**\n\n```markdown\n---\ndescription: Complete build workflow\nallowed-tools: Bash(*)\n---\n\nBuild: `bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh`\nTest: `bash ${CLAUDE_PLUGIN_ROOT}/scripts/test.sh`\nPackage: `bash ${CLAUDE_PLUGIN_ROOT}/scripts/package.sh`\n\nReview outputs and report workflow status.\n```\n\n**See `references/plugin-features-reference.md` for detailed patterns.**\n\n## Integration with Plugin Components\n\nCommands can integrate with other plugin components for powerful workflows.\n\n### Agent Integration\n\nLaunch plugin agents for complex tasks:\n\n```markdown\n---\ndescription: Deep code review\nargument-hint: [file-path]\n---\n\nInitiate comprehensive review of @$1 using the code-reviewer agent.\n\nThe agent will analyze:\n- Code structure\n- Security issues\n- Performance\n- Best practices\n\nAgent uses plugin resources:\n- ${CLAUDE_PLUGIN_ROOT}/config/rules.json\n- ${CLAUDE_PLUGIN_ROOT}/checklists/review.md\n```\n\n**Key points:**\n- Agent must exist in `plugin/agents/` directory\n- Claude uses Task tool to launch agent\n- Document agent capabilities\n- Reference plugin resources agent uses\n\n### Skill Integration\n\nLeverage plugin skills for specialized knowledge:\n\n```markdown\n---\ndescription: Document API with standards\nargument-hint: [api-file]\n---\n\nDocument API in @$1 following plugin standards.\n\nUse the api-docs-standards skill to ensure:\n- Complete endpoint documentation\n- Consistent formatting\n- Example quality\n- Error documentation\n\nGenerate production-ready API docs.\n```\n\n**Key points:**\n- Skill must exist in `plugin/skills/` directory\n- Mention skill name to trigger invocation\n- Document skill purpose\n- Explain what skill provides\n\n### Hook Coordination\n\nDesign commands that work with plugin hooks:\n- Commands can prepare state for hooks to process\n- Hooks execute automatically on tool events\n- Commands should document expected hook behavior\n- Guide Claude on interpreting hook output\n\nSee `references/plugin-features-reference.md` for examples of commands that coordinate with hooks\n\n### Multi-Component Workflows\n\nCombine agents, skills, and scripts:\n\n```markdown\n---\ndescription: Comprehensive review workflow\nargument-hint: [file]\nallowed-tools: Bash(node:*), Read\n---\n\nTarget: @$1\n\nPhase 1 - Static Analysis:\n`node ${CLAUDE_PLUGIN_ROOT}/scripts/lint.js $1`\n\nPhase 2 - Deep Review:\nLaunch code-reviewer agent for detailed analysis.\n\nPhase 3 - Standards Check:\nUse coding-standards skill for validation.\n\nPhase 4 - Report:\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/review.md\n\nCompile findings into report following template.\n```\n\n**When to use:**\n- Complex multi-step workflows\n- Leverage multiple plugin capabilities\n- Require specialized analysis\n- Need structured outputs\n\n## Validation Patterns\n\nCommands should validate inputs and resources before processing.\n\n### Argument Validation\n\n```markdown\n---\ndescription: Deploy with validation\nargument-hint: [environment]\n---\n\nValidate environment: `echo \"$1\" | grep -E \"^(dev|staging|prod)$\" || echo \"INVALID\"`\n\nIf $1 is valid environment:\n  Deploy to $1\nOtherwise:\n  Explain valid environments: dev, staging, prod\n  Show usage: /deploy [environment]\n```\n\n### File Existence Checks\n\n```markdown\n---\ndescription: Process configuration\nargument-hint: [config-file]\n---\n\nCheck file exists: `test -f $1 && echo \"EXISTS\" || echo \"MISSING\"`\n\nIf file exists:\n  Process configuration: @$1\nOtherwise:\n  Explain where to place config file\n  Show expected format\n  Provide example configuration\n```\n\n### Plugin Resource Validation\n\n```markdown\n---\ndescription: Run plugin analyzer\nallowed-tools: Bash(test:*)\n---\n\nValidate plugin setup:\n- Script: `test -x ${CLAUDE_PLUGIN_ROOT}/bin/analyze && echo \"✓\" || echo \"✗\"`\n- Config: `test -f ${CLAUDE_PLUGIN_ROOT}/config.json && echo \"✓\" || echo \"✗\"`\n\nIf all checks pass, run analysis.\nOtherwise, report missing components.\n```\n\n### Error Handling\n\n```markdown\n---\ndescription: Build with error handling\nallowed-tools: Bash(*)\n---\n\nExecute build: `bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh 2>&1 || echo \"BUILD_FAILED\"`\n\nIf build succeeded:\n  Report success and output location\nIf build failed:\n  Analyze error output\n  Suggest likely causes\n  Provide troubleshooting steps\n```\n\n**Best practices:**\n- Validate early in command\n- Provide helpful error messages\n- Suggest corrective actions\n- Handle edge cases gracefully\n\n---\n\nFor detailed frontmatter field specifications, see `references/frontmatter-reference.md`.\nFor plugin-specific features and patterns, see `references/plugin-features-reference.md`.\nFor command pattern examples, see `examples/` directory."
              },
              {
                "name": "hook-development",
                "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, PostToolUseFailure, PermissionRequest, Stop, SubagentStart, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
                "path": "plugins/harness/skills/hook-development/SKILL.md",
                "frontmatter": {
                  "name": "hook-development",
                  "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, PostToolUseFailure, PermissionRequest, Stop, SubagentStart, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API."
                },
                "content": "# Hook Development for Claude Code Plugins\n\n## Overview\n\nHooks are event-driven automation scripts that execute in response to Claude Code events. Use hooks to validate operations, enforce policies, add context, and integrate external tools into workflows.\n\n**Key capabilities:**\n- Validate tool calls before execution (PreToolUse)\n- React to tool results (PostToolUse)\n- Enforce completion standards (Stop, SubagentStop)\n- Load project context (SessionStart)\n- Automate workflows across the development lifecycle\n\n## Hook Types\n\n### Prompt-Based Hooks (Recommended)\n\nUse LLM-driven decision making for context-aware validation:\n\n```json\n{\n  \"type\": \"prompt\",\n  \"prompt\": \"Evaluate if this tool use is appropriate: $TOOL_INPUT\",\n  \"timeout\": 30\n}\n```\n\n**Supported events:** Stop, SubagentStop, UserPromptSubmit, PreToolUse\n\n**Benefits:**\n- Context-aware decisions based on natural language reasoning\n- Flexible evaluation logic without bash scripting\n- Better edge case handling\n- Easier to maintain and extend\n\n### Command Hooks\n\nExecute bash commands for deterministic checks:\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\",\n  \"timeout\": 60\n}\n```\n\n**Use for:**\n- Fast deterministic validations\n- File system operations\n- External tool integrations\n- Performance-critical checks\n\n### Hook Options\n\n#### timeout (optional)\n\nHow long a hook should run before canceling. Specified in seconds.\n\n**Defaults:** Command hooks (60s), Prompt hooks (30s)\n\n#### once (optional)\n\nSet to `true` to run the hook only once per session. After the first successful execution, the hook is removed.\n\n**Note:** This option is only supported for hooks defined in skills and slash commands, not for agents or settings-based hooks.\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"./scripts/one-time-setup.sh\",\n  \"once\": true\n}\n```\n\n**Use cases:**\n- One-time validation at start of skill execution\n- Initial setup that shouldn't repeat\n- Resource-intensive checks that only need to run once\n\n## Hook Configuration Formats\n\n### Plugin hooks.json Format\n\n**For plugin hooks** in `hooks/hooks.json`, use wrapper format:\n\n```json\n{\n  \"description\": \"Brief explanation of hooks (optional)\",\n  \"hooks\": {\n    \"PreToolUse\": [...],\n    \"Stop\": [...],\n    \"SessionStart\": [...]\n  }\n}\n```\n\n**Key points:**\n- `description` field is optional\n- `hooks` field is required wrapper containing actual hook events\n- This is the **plugin-specific format**\n\n**Example:**\n```json\n{\n  \"description\": \"Validation hooks for code quality\",\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Write\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/validate.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n### Settings Format (Direct)\n\n**For user settings** in `.claude/settings.json`, use direct format:\n\n```json\n{\n  \"PreToolUse\": [...],\n  \"Stop\": [...],\n  \"SessionStart\": [...]\n}\n```\n\n**Key points:**\n- No wrapper - events directly at top level\n- No description field\n- This is the **settings format**\n\n**Important:** The examples below show the hook event structure that goes inside either format. For plugin hooks.json, wrap these in `{\"hooks\": {...}}`.\n\n## Hook Events\n\n### PreToolUse\n\nExecute before any tool runs. Use to approve, deny, or modify tool calls.\n\n**Example (prompt-based):**\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety. Check: system paths, credentials, path traversal, sensitive content. Return 'approve' or 'deny'.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output for PreToolUse:**\n```json\n{\n  \"hookSpecificOutput\": {\n    \"permissionDecision\": \"allow|deny|ask\",\n    \"updatedInput\": {\"field\": \"modified_value\"}\n  },\n  \"systemMessage\": \"Explanation for Claude\"\n}\n```\n\n### PostToolUse\n\nExecute after tool completes successfully. Use to react to results, provide feedback, or log.\n\n**Example:**\n```json\n{\n  \"PostToolUse\": [\n    {\n      \"matcher\": \"Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Analyze edit result for potential issues: syntax errors, security vulnerabilities, breaking changes. Provide feedback.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output behavior:**\n- Exit 0: stdout shown in transcript\n- Exit 2: stderr fed back to Claude\n- systemMessage included in context\n\n### PostToolUseFailure\n\nExecute after tool execution fails. Use to handle errors, provide recovery suggestions, or log failures.\n\n**Example:**\n```json\n{\n  \"PostToolUseFailure\": [\n    {\n      \"matcher\": \"Bash\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Analyze the command failure and suggest fixes or alternative approaches.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### PermissionRequest\n\nExecute when a permission dialog is shown to the user. Use to automatically allow or deny permissions based on rules.\n\n**Example:**\n```json\n{\n  \"PermissionRequest\": [\n    {\n      \"matcher\": \"Write\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/check-permission.sh\"\n        }\n      ]\n    }\n  ]\n}\n```\n\nRecognizes the same matcher values as PreToolUse.\n\n### Stop\n\nExecute when main agent considers stopping. Use to validate completeness.\n\n**Example:**\n```json\n{\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion: tests run, build succeeded, questions answered. Return 'approve' to stop or 'block' with reason to continue.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Decision output:**\n```json\n{\n  \"decision\": \"approve|block\",\n  \"reason\": \"Explanation\",\n  \"systemMessage\": \"Additional context\"\n}\n```\n\n### SubagentStart\n\nExecute when a subagent is started. Use to configure subagent behavior or log subagent invocations.\n\n**Example:**\n```json\n{\n  \"SubagentStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/log-subagent.sh\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### SubagentStop\n\nExecute when subagent considers stopping. Use to ensure subagent completed its task.\n\nSimilar to Stop hook, but for subagents.\n\n### UserPromptSubmit\n\nExecute when user submits a prompt. Use to add context, validate, or block prompts.\n\n**Example:**\n```json\n{\n  \"UserPromptSubmit\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Check if prompt requires security guidance. If discussing auth, permissions, or API security, return relevant warnings.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### SessionStart\n\nExecute when Claude Code session begins. Use to load context and set environment.\n\n**Matchers:**\n- `startup` - Normal startup\n- `resume` - Invoked from `--resume`, `--continue`, or `/resume`\n- `clear` - Invoked from `/clear`\n- `compact` - Invoked from auto or manual compact\n\n**Example:**\n```json\n{\n  \"SessionStart\": [\n    {\n      \"matcher\": \"startup\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Special capability:** Persist environment variables using `$CLAUDE_ENV_FILE`:\n```bash\necho \"export PROJECT_TYPE=nodejs\" >> \"$CLAUDE_ENV_FILE\"\n```\n\nSee `examples/load-context.sh` for complete example.\n\n### SessionEnd\n\nExecute when session ends. Use for cleanup, logging, and state preservation.\n\nThe `reason` field in hook input will be one of: `clear`, `logout`, `prompt_input_exit`, `other`.\n\n### PreCompact\n\nExecute before context compaction. Use to add critical information to preserve.\n\n**Matchers:**\n- `manual` - Invoked from `/compact`\n- `auto` - Invoked from auto-compact (due to full context window)\n\n### Notification\n\nExecute when Claude sends notifications. Use to react to user notifications.\n\n**Matchers:**\n- `permission_prompt` - Permission requests from Claude Code\n- `idle_prompt` - When Claude is waiting for user input (after 60+ seconds idle)\n- `auth_success` - Authentication success notifications\n- `elicitation_dialog` - When Claude Code needs input for MCP tool elicitation\n\n**Example:**\n```json\n{\n  \"Notification\": [\n    {\n      \"matcher\": \"permission_prompt\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/notify-permission.sh\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n## Hook Output Format\n\n### Standard Output (All Hooks)\n\n```json\n{\n  \"continue\": true,\n  \"suppressOutput\": false,\n  \"systemMessage\": \"Message for Claude\"\n}\n```\n\n- `continue`: If false, halt processing (default true)\n- `suppressOutput`: Hide output from transcript (default false)\n- `systemMessage`: Message shown to Claude\n\n### Exit Codes\n\n- `0` - Success (stdout shown in transcript)\n- `2` - Blocking error (stderr fed back to Claude)\n- Other - Non-blocking error\n\n## Hook Input Format\n\nAll hooks receive JSON via stdin with common fields:\n\n```json\n{\n  \"session_id\": \"abc123\",\n  \"transcript_path\": \"/path/to/transcript.txt\",\n  \"cwd\": \"/current/working/dir\",\n  \"permission_mode\": \"ask|allow\",\n  \"hook_event_name\": \"PreToolUse\"\n}\n```\n\n**Event-specific fields:**\n\n- **PreToolUse/PostToolUse:** `tool_name`, `tool_input`, `tool_result`\n- **UserPromptSubmit:** `user_prompt`\n- **Stop/SubagentStop:** `reason`\n\nAccess fields in prompts using `$TOOL_INPUT`, `$TOOL_RESULT`, `$USER_PROMPT`, etc.\n\n## Environment Variables\n\nAvailable in all command hooks:\n\n### Core Variables\n\n- **`$CLAUDE_PROJECT_DIR`** - Absolute path to the project root directory (where Claude Code was started). Use this to reference project files in a portable way.\n\n- **`$CLAUDE_PLUGIN_ROOT`** - Absolute path to the plugin directory. **Essential for plugin hooks** - always use this instead of hardcoded paths to ensure hooks work regardless of where the plugin is installed.\n\n### Special Variables\n\n- **`$CLAUDE_ENV_FILE`** - (SessionStart only) File path where you can persist environment variables for subsequent bash commands. Write `export VAR=value` lines to this file:\n  ```bash\n  echo 'export NODE_ENV=production' >> \"$CLAUDE_ENV_FILE\"\n  echo 'export API_KEY=your-key' >> \"$CLAUDE_ENV_FILE\"\n  ```\n\n- **`$CLAUDE_CODE_REMOTE`** - Set to `\"true\"` if running in remote (web) environment, not set or empty for local CLI. Use to run different logic based on execution context:\n  ```bash\n  if [ \"$CLAUDE_CODE_REMOTE\" = \"true\" ]; then\n    # Remote-specific logic\n  else\n    # Local CLI logic\n  fi\n  ```\n\n### Usage Examples\n\n**Always use ${CLAUDE_PLUGIN_ROOT} in plugin hook commands for portability:**\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\"\n}\n```\n\n**Reference project files with ${CLAUDE_PROJECT_DIR}:**\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"\\\"$CLAUDE_PROJECT_DIR\\\"/.claude/hooks/check-style.sh\"\n}\n```\n\n## Plugin Hook Configuration\n\nIn plugins, define hooks in `hooks/hooks.json`:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety\"\n        }\n      ]\n    }\n  ],\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion\"\n        }\n      ]\n    }\n  ],\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\",\n          \"timeout\": 10\n        }\n      ]\n    }\n  ]\n}\n```\n\nPlugin hooks merge with user's hooks and run in parallel.\n\n## Matchers\n\n### Tool Name Matching\n\n**Exact match:**\n```json\n\"matcher\": \"Write\"\n```\n\n**Multiple tools:**\n```json\n\"matcher\": \"Read|Write|Edit\"\n```\n\n**Wildcard (all tools):**\n```json\n\"matcher\": \"*\"\n```\n\n**Regex patterns:**\n```json\n\"matcher\": \"mcp__.*__delete.*\"  // All MCP delete tools\n```\n\n**Note:** Matchers are case-sensitive.\n\n### Common Patterns\n\n```json\n// All MCP tools\n\"matcher\": \"mcp__.*\"\n\n// Specific plugin's MCP tools\n\"matcher\": \"mcp__plugin_asana_.*\"\n\n// All file operations\n\"matcher\": \"Read|Write|Edit\"\n\n// Bash commands only\n\"matcher\": \"Bash\"\n```\n\n## Security Best Practices\n\n### Input Validation\n\nAlways validate inputs in command hooks:\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\ninput=$(cat)\ntool_name=$(echo \"$input\" | jq -r '.tool_name')\n\n# Validate tool name format\nif [[ ! \"$tool_name\" =~ ^[a-zA-Z0-9_]+$ ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Invalid tool name\"}' >&2\n  exit 2\nfi\n```\n\n### Path Safety\n\nCheck for path traversal and sensitive files:\n\n```bash\nfile_path=$(echo \"$input\" | jq -r '.tool_input.file_path')\n\n# Deny path traversal\nif [[ \"$file_path\" == *\"..\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Path traversal detected\"}' >&2\n  exit 2\nfi\n\n# Deny sensitive files\nif [[ \"$file_path\" == *\".env\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Sensitive file\"}' >&2\n  exit 2\nfi\n```\n\nSee `examples/validate-write.sh` and `examples/validate-bash.sh` for complete examples.\n\n### Quote All Variables\n\n```bash\n# GOOD: Quoted\necho \"$file_path\"\ncd \"$CLAUDE_PROJECT_DIR\"\n\n# BAD: Unquoted (injection risk)\necho $file_path\ncd $CLAUDE_PROJECT_DIR\n```\n\n### Set Appropriate Timeouts\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash script.sh\",\n  \"timeout\": 10\n}\n```\n\n**Defaults:** Command hooks (60s), Prompt hooks (30s)\n\n## Performance Considerations\n\n### Parallel Execution\n\nAll matching hooks run **in parallel**:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write\",\n      \"hooks\": [\n        {\"type\": \"command\", \"command\": \"check1.sh\"},  // Parallel\n        {\"type\": \"command\", \"command\": \"check2.sh\"},  // Parallel\n        {\"type\": \"prompt\", \"prompt\": \"Validate...\"}   // Parallel\n      ]\n    }\n  ]\n}\n```\n\n**Design implications:**\n- Hooks don't see each other's output\n- Non-deterministic ordering\n- Design for independence\n\n### Optimization\n\n1. Use command hooks for quick deterministic checks\n2. Use prompt hooks for complex reasoning\n3. Cache validation results in temp files\n4. Minimize I/O in hot paths\n\n## Temporarily Active Hooks\n\nCreate hooks that activate conditionally by checking for a flag file or configuration:\n\n**Pattern: Flag file activation**\n```bash\n#!/bin/bash\n# Only active when flag file exists\nFLAG_FILE=\"$CLAUDE_PROJECT_DIR/.enable-strict-validation\"\n\nif [ ! -f \"$FLAG_FILE\" ]; then\n  # Flag not present, skip validation\n  exit 0\nfi\n\n# Flag present, run validation\ninput=$(cat)\n# ... validation logic ...\n```\n\n**Pattern: Configuration-based activation**\n```bash\n#!/bin/bash\n# Check configuration for activation\nCONFIG_FILE=\"$CLAUDE_PROJECT_DIR/.claude/plugin-config.json\"\n\nif [ -f \"$CONFIG_FILE\" ]; then\n  enabled=$(jq -r '.strictMode // false' \"$CONFIG_FILE\")\n  if [ \"$enabled\" != \"true\" ]; then\n    exit 0  # Not enabled, skip\n  fi\nfi\n\n# Enabled, run hook logic\ninput=$(cat)\n# ... hook logic ...\n```\n\n**Use cases:**\n- Enable strict validation only when needed\n- Temporary debugging hooks\n- Project-specific hook behavior\n- Feature flags for hooks\n\n**Best practice:** Document activation mechanism in plugin README so users know how to enable/disable temporary hooks.\n\n## Hook Lifecycle and Limitations\n\n### Hooks Load at Session Start\n\n**Important:** Hooks are loaded when Claude Code session starts. Changes to hook configuration require restarting Claude Code.\n\n**Cannot hot-swap hooks:**\n- Editing `hooks/hooks.json` won't affect current session\n- Adding new hook scripts won't be recognized\n- Changing hook commands/prompts won't update\n- Must restart Claude Code: exit and run `claude` again\n\n**To test hook changes:**\n1. Edit hook configuration or scripts\n2. Exit Claude Code session\n3. Restart: `claude` or `cc`\n4. New hook configuration loads\n5. Test hooks with `claude --debug`\n\n### Hook Validation at Startup\n\nHooks are validated when Claude Code starts:\n- Invalid JSON in hooks.json causes loading failure\n- Missing scripts cause warnings\n- Syntax errors reported in debug mode\n\nUse `/hooks` command to review loaded hooks in current session.\n\n## Debugging Hooks\n\n### Enable Debug Mode\n\n```bash\nclaude --debug\n```\n\nLook for hook registration, execution logs, input/output JSON, and timing information.\n\n### Test Hook Scripts\n\nTest command hooks directly:\n\n```bash\necho '{\"tool_name\": \"Write\", \"tool_input\": {\"file_path\": \"/test\"}}' | \\\n  bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\n\necho \"Exit code: $?\"\n```\n\n### Validate JSON Output\n\nEnsure hooks output valid JSON:\n\n```bash\noutput=$(./your-hook.sh < test-input.json)\necho \"$output\" | jq .\n```\n\n## Quick Reference\n\n### Hook Events Summary\n\n| Event | When | Use For |\n|-------|------|---------|\n| PreToolUse | Before tool | Validation, modification |\n| PostToolUse | After tool succeeds | Feedback, logging |\n| PostToolUseFailure | After tool fails | Error handling, recovery |\n| PermissionRequest | Permission dialog shown | Auto-allow/deny |\n| UserPromptSubmit | User input | Context, validation |\n| Stop | Agent stopping | Completeness check |\n| SubagentStart | Subagent begins | Configuration, logging |\n| SubagentStop | Subagent done | Task validation |\n| SessionStart | Session begins | Context loading |\n| SessionEnd | Session ends | Cleanup, logging |\n| PreCompact | Before compact | Preserve context |\n| Notification | User notified | Logging, reactions |\n\n### Best Practices\n\n**DO:**\n- ✅ Use prompt-based hooks for complex logic\n- ✅ Use ${CLAUDE_PLUGIN_ROOT} for portability\n- ✅ Validate all inputs in command hooks\n- ✅ Quote all bash variables\n- ✅ Set appropriate timeouts\n- ✅ Return structured JSON output\n- ✅ Test hooks thoroughly\n\n**DON'T:**\n- ❌ Use hardcoded paths\n- ❌ Trust user input without validation\n- ❌ Create long-running hooks\n- ❌ Rely on hook execution order\n- ❌ Modify global state unpredictably\n- ❌ Log sensitive information\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and advanced techniques, consult:\n\n- **`references/patterns.md`** - Common hook patterns (8+ proven patterns)\n- **`references/migration.md`** - Migrating from basic to advanced hooks\n- **`references/advanced.md`** - Advanced use cases and techniques\n\n### Example Hook Scripts\n\nWorking examples in `examples/`:\n\n- **`validate-write.sh`** - File write validation example\n- **`validate-bash.sh`** - Bash command validation example\n- **`load-context.sh`** - SessionStart context loading example\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-hook-schema.sh`** - Validate hooks.json structure and syntax\n- **`test-hook.sh`** - Test hooks with sample input before deployment\n- **`hook-linter.sh`** - Check hook scripts for common issues and best practices\n\n### External Resources\n\n- **Official Docs**: https://docs.claude.com/en/docs/claude-code/hooks\n- **Examples**: See security-guidance plugin in marketplace\n- **Testing**: Use `claude --debug` for detailed logs\n- **Validation**: Use `jq` to validate hook JSON output\n\n## Implementation Workflow\n\nTo implement hooks in a plugin:\n\n1. Identify events to hook into (PreToolUse, Stop, SessionStart, etc.)\n2. Decide between prompt-based (flexible) or command (deterministic) hooks\n3. Write hook configuration in `hooks/hooks.json`\n4. For command hooks, create hook scripts\n5. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n6. Validate configuration with `scripts/validate-hook-schema.sh hooks/hooks.json`\n7. Test hooks with `scripts/test-hook.sh` before deployment\n8. Test in Claude Code with `claude --debug`\n9. Document hooks in plugin README\n\nFocus on prompt-based hooks for most use cases. Reserve command hooks for performance-critical or deterministic checks."
              },
              {
                "name": "lsp-integration",
                "description": "This skill should be used when the user asks to \"add LSP server\", \"configure language server\", \"add code intelligence\", \"set up .lsp.json\", \"add go to definition\", \"add find references\", \"integrate language server protocol\", or needs guidance on LSP server configuration, language server setup, or code intelligence features for Claude Code plugins.",
                "path": "plugins/harness/skills/lsp-integration/SKILL.md",
                "frontmatter": {
                  "name": "lsp-integration",
                  "description": "This skill should be used when the user asks to \"add LSP server\", \"configure language server\", \"add code intelligence\", \"set up .lsp.json\", \"add go to definition\", \"add find references\", \"integrate language server protocol\", or needs guidance on LSP server configuration, language server setup, or code intelligence features for Claude Code plugins."
                },
                "content": "# LSP Integration for Claude Code Plugins\n\n## Overview\n\nLSP (Language Server Protocol) plugins give Claude real-time code intelligence while working on codebases. LSP integration provides instant diagnostics, code navigation, and language awareness that enhances Claude's ability to understand and modify code.\n\n**Key capabilities:**\n- Instant diagnostics (errors and warnings after each edit)\n- Code navigation (go to definition, find references)\n- Hover information (type info and documentation)\n- Language awareness (understanding of code symbols)\n\n## When to Use LSP Plugins\n\n**Use LSP plugins when:**\n- Plugin works with specific programming languages\n- Users need real-time error feedback\n- Code navigation improves workflow\n- Language-specific intelligence is valuable\n\n**Note:** For common languages (TypeScript, Python, Rust), users should install pre-built LSP plugins from the official marketplace. Create custom LSP plugins only for languages not already covered.\n\n## LSP Configuration\n\n### Configuration Location\n\nLSP servers can be configured in two ways:\n\n**Standalone file (recommended for plugins):**\n```\nplugin-name/\n├── .claude-plugin/\n│   └── plugin.json\n├── .lsp.json              # LSP server definitions\n└── ...\n```\n\n**Inline in plugin.json:**\n```json\n{\n  \"name\": \"my-plugin\",\n  \"lspServers\": {\n    \"go\": {\n      \"command\": \"gopls\",\n      \"args\": [\"serve\"],\n      \"extensionToLanguage\": {\n        \".go\": \"go\"\n      }\n    }\n  }\n}\n```\n\n### Basic Configuration\n\n**.lsp.json file format:**\n\n```json\n{\n  \"language-name\": {\n    \"command\": \"language-server-binary\",\n    \"args\": [\"arg1\", \"arg2\"],\n    \"extensionToLanguage\": {\n      \".ext\": \"language-id\"\n    }\n  }\n}\n```\n\n**Example - Go language server:**\n\n```json\n{\n  \"go\": {\n    \"command\": \"gopls\",\n    \"args\": [\"serve\"],\n    \"extensionToLanguage\": {\n      \".go\": \"go\"\n    }\n  }\n}\n```\n\n**Example - TypeScript language server:**\n\n```json\n{\n  \"typescript\": {\n    \"command\": \"typescript-language-server\",\n    \"args\": [\"--stdio\"],\n    \"extensionToLanguage\": {\n      \".ts\": \"typescript\",\n      \".tsx\": \"typescriptreact\",\n      \".js\": \"javascript\",\n      \".jsx\": \"javascriptreact\"\n    }\n  }\n}\n```\n\n## Configuration Fields\n\n### Required Fields\n\n| Field | Description | Example |\n|-------|-------------|---------|\n| `command` | LSP binary to execute (must be in PATH) | `\"gopls\"`, `\"pyright\"` |\n| `extensionToLanguage` | Maps file extensions to language identifiers | `{\".go\": \"go\"}` |\n\n### Optional Fields\n\n| Field | Description | Default |\n|-------|-------------|---------|\n| `args` | Command-line arguments for server | `[]` |\n| `transport` | Communication transport | `\"stdio\"` |\n| `env` | Environment variables for server | `{}` |\n| `initializationOptions` | Options passed during initialization | `{}` |\n| `settings` | Settings via `workspace/didChangeConfiguration` | `{}` |\n| `workspaceFolder` | Workspace folder path | Project root |\n| `startupTimeout` | Max startup wait time (ms) | System default |\n| `shutdownTimeout` | Max shutdown wait time (ms) | System default |\n| `restartOnCrash` | Auto-restart if server crashes | `false` |\n| `maxRestarts` | Max restart attempts | System default |\n| `loggingConfig` | Debug logging configuration | `{}` |\n\n### Transport Options\n\n**stdio (default):** Communication via stdin/stdout\n```json\n{\n  \"transport\": \"stdio\"\n}\n```\n\n**socket:** Communication via TCP socket\n```json\n{\n  \"transport\": \"socket\"\n}\n```\n\n## Advanced Configuration\n\n### Environment Variables\n\nPass environment variables to the language server:\n\n```json\n{\n  \"rust\": {\n    \"command\": \"rust-analyzer\",\n    \"env\": {\n      \"RUST_LOG\": \"info\",\n      \"CARGO_HOME\": \"/custom/cargo/path\"\n    },\n    \"extensionToLanguage\": {\n      \".rs\": \"rust\"\n    }\n  }\n}\n```\n\n### Initialization Options\n\nPass options during server initialization:\n\n```json\n{\n  \"python\": {\n    \"command\": \"pyright-langserver\",\n    \"args\": [\"--stdio\"],\n    \"initializationOptions\": {\n      \"python\": {\n        \"analysis\": {\n          \"typeCheckingMode\": \"strict\"\n        }\n      }\n    },\n    \"extensionToLanguage\": {\n      \".py\": \"python\"\n    }\n  }\n}\n```\n\n### Workspace Settings\n\nConfigure server behavior via settings:\n\n```json\n{\n  \"typescript\": {\n    \"command\": \"typescript-language-server\",\n    \"args\": [\"--stdio\"],\n    \"settings\": {\n      \"typescript\": {\n        \"format\": {\n          \"semicolons\": \"insert\"\n        }\n      }\n    },\n    \"extensionToLanguage\": {\n      \".ts\": \"typescript\"\n    }\n  }\n}\n```\n\n### Debug Logging\n\nEnable verbose logging for troubleshooting (activated with `--enable-lsp-logging`):\n\n```json\n{\n  \"typescript\": {\n    \"command\": \"typescript-language-server\",\n    \"args\": [\"--stdio\"],\n    \"loggingConfig\": {\n      \"args\": [\"--log-level\", \"4\"],\n      \"env\": {\n        \"TSS_LOG\": \"-level verbose -file ${CLAUDE_PLUGIN_LSP_LOG_FILE}\"\n      }\n    },\n    \"extensionToLanguage\": {\n      \".ts\": \"typescript\"\n    }\n  }\n}\n```\n\n**Special variable:** `${CLAUDE_PLUGIN_LSP_LOG_FILE}` expands to the log file path. Logs are written to `~/.claude/debug/`.\n\n### Crash Recovery\n\nConfigure automatic restart on server crashes:\n\n```json\n{\n  \"go\": {\n    \"command\": \"gopls\",\n    \"args\": [\"serve\"],\n    \"restartOnCrash\": true,\n    \"maxRestarts\": 3,\n    \"extensionToLanguage\": {\n      \".go\": \"go\"\n    }\n  }\n}\n```\n\n## Common Language Servers\n\n### Available LSP Plugins (Official Marketplace)\n\n| Plugin | Language Server | Install Command |\n|--------|-----------------|-----------------|\n| `pyright-lsp` | Pyright (Python) | `pip install pyright` or `npm install -g pyright` |\n| `typescript-lsp` | TypeScript Language Server | `npm install -g typescript-language-server typescript` |\n| `rust-lsp` | rust-analyzer | See [rust-analyzer installation](https://rust-analyzer.github.io/manual.html#installation) |\n\n### Other Language Servers\n\n**Go:**\n```json\n{\n  \"go\": {\n    \"command\": \"gopls\",\n    \"args\": [\"serve\"],\n    \"extensionToLanguage\": {\n      \".go\": \"go\"\n    }\n  }\n}\n```\nInstall: `go install golang.org/x/tools/gopls@latest`\n\n**C/C++:**\n```json\n{\n  \"cpp\": {\n    \"command\": \"clangd\",\n    \"args\": [\"--background-index\"],\n    \"extensionToLanguage\": {\n      \".c\": \"c\",\n      \".cpp\": \"cpp\",\n      \".h\": \"c\",\n      \".hpp\": \"cpp\"\n    }\n  }\n}\n```\nInstall: Via system package manager or LLVM releases\n\n**Java:**\n```json\n{\n  \"java\": {\n    \"command\": \"jdtls\",\n    \"extensionToLanguage\": {\n      \".java\": \"java\"\n    }\n  }\n}\n```\nInstall: Eclipse JDT Language Server\n\n**Ruby:**\n```json\n{\n  \"ruby\": {\n    \"command\": \"solargraph\",\n    \"args\": [\"stdio\"],\n    \"extensionToLanguage\": {\n      \".rb\": \"ruby\"\n    }\n  }\n}\n```\nInstall: `gem install solargraph`\n\n## Plugin Integration\n\n### Using ${CLAUDE_PLUGIN_ROOT}\n\nReference plugin-bundled language servers:\n\n```json\n{\n  \"custom-lang\": {\n    \"command\": \"${CLAUDE_PLUGIN_ROOT}/bin/custom-lsp\",\n    \"args\": [\"--stdio\"],\n    \"extensionToLanguage\": {\n      \".custom\": \"custom-lang\"\n    }\n  }\n}\n```\n\n### Plugin Directory Structure\n\n```\nmy-lsp-plugin/\n├── .claude-plugin/\n│   └── plugin.json\n├── .lsp.json\n├── bin/\n│   └── custom-lsp          # Bundled language server (optional)\n└── README.md\n```\n\n## User Requirements\n\n**Important:** LSP plugins configure how Claude Code connects to language servers, but they don't include the server binaries themselves.\n\n**Document in plugin README:**\n1. Required language server binary\n2. Installation command\n3. Version requirements\n4. PATH configuration if needed\n\n**Example README section:**\n```markdown\n## Prerequisites\n\nThis plugin requires gopls (Go language server):\n\n```bash\ngo install golang.org/x/tools/gopls@latest\n```\n\nEnsure `gopls` is available in your PATH.\n```\n\n## Troubleshooting\n\n### Common Issues\n\n**\"Executable not found in $PATH\":**\n- Language server binary not installed\n- Binary not in PATH\n- Check `/plugin` Errors tab for details\n\n**Server not starting:**\n- Verify command and args are correct\n- Check for required dependencies\n- Test server manually: `language-server --stdio`\n- Use `claude --debug` for detailed logs\n\n**No diagnostics appearing:**\n- Check `extensionToLanguage` mapping\n- Verify file extension matches configuration\n- Confirm server supports diagnostics\n\n**Performance issues:**\n- Adjust `startupTimeout` for slow servers\n- Check server resource usage\n- Consider `workspaceFolder` scope\n\n### Debugging\n\nEnable LSP logging:\n```bash\nclaude --enable-lsp-logging\n```\n\nView logs in `~/.claude/debug/`.\n\nCheck plugin status:\n```\n/plugin\n```\nNavigate to Errors tab to see LSP-related issues.\n\n## Best Practices\n\n### Configuration\n\n1. **Use stdio transport** unless socket is specifically required\n2. **Set reasonable timeouts** for slow-starting servers\n3. **Enable restartOnCrash** for production stability\n4. **Document all prerequisites** clearly in README\n\n### File Extensions\n\n1. **Map all relevant extensions** for the language\n2. **Use standard language identifiers** (match VS Code language IDs)\n3. **Consider related file types** (.tsx for TypeScript React, etc.)\n\n### Error Handling\n\n1. **Test server installation** before plugin distribution\n2. **Provide clear error messages** in documentation\n3. **Include troubleshooting steps** in README\n4. **Suggest fallback options** if server unavailable\n\n### Performance\n\n1. **Limit background indexing** for large codebases\n2. **Configure appropriate settings** for your use case\n3. **Test with realistic project sizes**\n4. **Monitor memory usage** of language servers\n\n## Quick Reference\n\n### Minimal Configuration\n\n```json\n{\n  \"language\": {\n    \"command\": \"language-server\",\n    \"extensionToLanguage\": {\n      \".ext\": \"language-id\"\n    }\n  }\n}\n```\n\n### Full Configuration\n\n```json\n{\n  \"language\": {\n    \"command\": \"language-server\",\n    \"args\": [\"--stdio\"],\n    \"transport\": \"stdio\",\n    \"env\": {\n      \"VAR\": \"value\"\n    },\n    \"initializationOptions\": {},\n    \"settings\": {},\n    \"workspaceFolder\": \"/path/to/workspace\",\n    \"startupTimeout\": 10000,\n    \"shutdownTimeout\": 5000,\n    \"restartOnCrash\": true,\n    \"maxRestarts\": 3,\n    \"loggingConfig\": {\n      \"args\": [\"--verbose\"],\n      \"env\": {}\n    },\n    \"extensionToLanguage\": {\n      \".ext\": \"language-id\"\n    }\n  }\n}\n```\n\n## Additional Resources\n\n### Example Configurations\n\nSee `examples/` directory for working configurations:\n- `go-lsp.json` - Go language server\n- `python-lsp.json` - Python with Pyright\n- `multi-language.json` - Multiple language servers\n\n### External Resources\n\n- [Language Server Protocol Specification](https://microsoft.github.io/language-server-protocol/)\n- [LSP Implementations](https://microsoft.github.io/language-server-protocol/implementors/servers/)\n- [Claude Code Plugins Reference](/en/plugins-reference#lsp-servers)"
              },
              {
                "name": "mcp-integration",
                "description": "This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration.",
                "path": "plugins/harness/skills/mcp-integration/SKILL.md",
                "frontmatter": {
                  "name": "mcp-integration",
                  "description": "This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration."
                },
                "content": "# MCP Integration for Claude Code Plugins\n\n## Overview\n\nModel Context Protocol (MCP) enables Claude Code plugins to integrate with external services and APIs by providing structured tool access. Use MCP integration to expose external service capabilities as tools within Claude Code.\n\n**Key capabilities:**\n- Connect to external services (databases, APIs, file systems)\n- Provide 10+ related tools from a single service\n- Handle OAuth and complex authentication flows\n- Bundle MCP servers with plugins for automatic setup\n\n## MCP Server Configuration Methods\n\nPlugins can bundle MCP servers in two ways:\n\n### Method 1: Dedicated .mcp.json (Recommended)\n\nCreate `.mcp.json` at plugin root:\n\n```json\n{\n  \"database-tools\": {\n    \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/db-server\",\n    \"args\": [\"--config\", \"${CLAUDE_PLUGIN_ROOT}/config.json\"],\n    \"env\": {\n      \"DB_URL\": \"${DB_URL}\"\n    }\n  }\n}\n```\n\n**Benefits:**\n- Clear separation of concerns\n- Easier to maintain\n- Better for multiple servers\n\n### Method 2: Inline in plugin.json\n\nAdd `mcpServers` field to plugin.json:\n\n```json\n{\n  \"name\": \"my-plugin\",\n  \"version\": \"1.0.0\",\n  \"mcpServers\": {\n    \"plugin-api\": {\n      \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/api-server\",\n      \"args\": [\"--port\", \"8080\"]\n    }\n  }\n}\n```\n\n**Benefits:**\n- Single configuration file\n- Good for simple single-server plugins\n\n## MCP Server Types\n\n### stdio (Local Process)\n\nExecute local MCP servers as child processes. Best for local tools and custom servers.\n\n**Configuration:**\n```json\n{\n  \"filesystem\": {\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/allowed/path\"],\n    \"env\": {\n      \"LOG_LEVEL\": \"debug\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- File system access\n- Local database connections\n- Custom MCP servers\n- NPM-packaged MCP servers\n\n**Process management:**\n- Claude Code spawns and manages the process\n- Communicates via stdin/stdout\n- Terminates when Claude Code exits\n\n### SSE (Server-Sent Events)\n\nConnect to hosted MCP servers with OAuth support. Best for cloud services.\n\n**Configuration:**\n```json\n{\n  \"asana\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.asana.com/sse\"\n  }\n}\n```\n\n**Use cases:**\n- Official hosted MCP servers (Asana, GitHub, etc.)\n- Cloud services with MCP endpoints\n- OAuth-based authentication\n- No local installation needed\n\n**Authentication:**\n- OAuth flows handled automatically\n- User prompted on first use\n- Tokens managed by Claude Code\n\n### HTTP (REST API)\n\nConnect to RESTful MCP servers with token authentication.\n\n**Configuration:**\n```json\n{\n  \"api-service\": {\n    \"type\": \"http\",\n    \"url\": \"https://api.example.com/mcp\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${API_TOKEN}\",\n      \"X-Custom-Header\": \"value\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- REST API-based MCP servers\n- Token-based authentication\n- Custom API backends\n- Stateless interactions\n\n### WebSocket (Real-time)\n\nConnect to WebSocket MCP servers for real-time bidirectional communication.\n\n**Configuration:**\n```json\n{\n  \"realtime-service\": {\n    \"type\": \"ws\",\n    \"url\": \"wss://mcp.example.com/ws\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${TOKEN}\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- Real-time data streaming\n- Persistent connections\n- Push notifications from server\n- Low-latency requirements\n\n## Environment Variable Expansion\n\nAll MCP configurations support environment variable substitution:\n\n**${CLAUDE_PLUGIN_ROOT}** - Plugin directory (always use for portability):\n```json\n{\n  \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/my-server\"\n}\n```\n\n**User environment variables** - From user's shell:\n```json\n{\n  \"env\": {\n    \"API_KEY\": \"${MY_API_KEY}\",\n    \"DATABASE_URL\": \"${DB_URL}\"\n  }\n}\n```\n\n**Best practice:** Document all required environment variables in plugin README.\n\n## MCP Tool Naming\n\nWhen MCP servers provide tools, they're automatically prefixed:\n\n**Format:** `mcp__plugin_<plugin-name>_<server-name>__<tool-name>`\n\n**Example:**\n- Plugin: `asana`\n- Server: `asana`\n- Tool: `create_task`\n- **Full name:** `mcp__plugin_asana_asana__asana_create_task`\n\n### Using MCP Tools in Commands\n\nPre-allow specific MCP tools in command frontmatter:\n\n```markdown\n---\nallowed-tools: [\n  \"mcp__plugin_asana_asana__asana_create_task\",\n  \"mcp__plugin_asana_asana__asana_search_tasks\"\n]\n---\n```\n\n**Wildcard (use sparingly):**\n```markdown\n---\nallowed-tools: [\"mcp__plugin_asana_asana__*\"]\n---\n```\n\n**Best practice:** Pre-allow specific tools, not wildcards, for security.\n\n## Lifecycle Management\n\n**Automatic startup:**\n- MCP servers start when plugin enables\n- Connection established before first tool use\n- Restart required for configuration changes\n\n**Lifecycle:**\n1. Plugin loads\n2. MCP configuration parsed\n3. Server process started (stdio) or connection established (SSE/HTTP/WS)\n4. Tools discovered and registered\n5. Tools available as `mcp__plugin_...__...`\n\n**Viewing servers:**\nUse `/mcp` command to see all servers including plugin-provided ones.\n\n## Authentication Patterns\n\n### OAuth (SSE/HTTP)\n\nOAuth handled automatically by Claude Code:\n\n```json\n{\n  \"type\": \"sse\",\n  \"url\": \"https://mcp.example.com/sse\"\n}\n```\n\nUser authenticates in browser on first use. No additional configuration needed.\n\n### Token-Based (Headers)\n\nStatic or environment variable tokens:\n\n```json\n{\n  \"type\": \"http\",\n  \"url\": \"https://api.example.com\",\n  \"headers\": {\n    \"Authorization\": \"Bearer ${API_TOKEN}\"\n  }\n}\n```\n\nDocument required environment variables in README.\n\n### Environment Variables (stdio)\n\nPass configuration to MCP server:\n\n```json\n{\n  \"command\": \"python\",\n  \"args\": [\"-m\", \"my_mcp_server\"],\n  \"env\": {\n    \"DATABASE_URL\": \"${DB_URL}\",\n    \"API_KEY\": \"${API_KEY}\",\n    \"LOG_LEVEL\": \"info\"\n  }\n}\n```\n\n## Integration Patterns\n\n### Pattern 1: Simple Tool Wrapper\n\nCommands use MCP tools with user interaction:\n\n```markdown\n# Command: create-item.md\n---\nallowed-tools: [\"mcp__plugin_name_server__create_item\"]\n---\n\nSteps:\n1. Gather item details from user\n2. Use mcp__plugin_name_server__create_item\n3. Confirm creation\n```\n\n**Use for:** Adding validation or preprocessing before MCP calls.\n\n### Pattern 2: Autonomous Agent\n\nAgents use MCP tools autonomously:\n\n```markdown\n# Agent: data-analyzer.md\n\nAnalysis Process:\n1. Query data via mcp__plugin_db_server__query\n2. Process and analyze results\n3. Generate insights report\n```\n\n**Use for:** Multi-step MCP workflows without user interaction.\n\n### Pattern 3: Multi-Server Plugin\n\nIntegrate multiple MCP servers:\n\n```json\n{\n  \"github\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.github.com/sse\"\n  },\n  \"jira\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.jira.com/sse\"\n  }\n}\n```\n\n**Use for:** Workflows spanning multiple services.\n\n## Security Best Practices\n\n### Use HTTPS/WSS\n\nAlways use secure connections:\n\n```json\n✅ \"url\": \"https://mcp.example.com/sse\"\n❌ \"url\": \"http://mcp.example.com/sse\"\n```\n\n### Token Management\n\n**DO:**\n- ✅ Use environment variables for tokens\n- ✅ Document required env vars in README\n- ✅ Let OAuth flow handle authentication\n\n**DON'T:**\n- ❌ Hardcode tokens in configuration\n- ❌ Commit tokens to git\n- ❌ Share tokens in documentation\n\n### Permission Scoping\n\nPre-allow only necessary MCP tools:\n\n```markdown\n✅ allowed-tools: [\n  \"mcp__plugin_api_server__read_data\",\n  \"mcp__plugin_api_server__create_item\"\n]\n\n❌ allowed-tools: [\"mcp__plugin_api_server__*\"]\n```\n\n## Error Handling\n\n### Connection Failures\n\nHandle MCP server unavailability:\n- Provide fallback behavior in commands\n- Inform user of connection issues\n- Check server URL and configuration\n\n### Tool Call Errors\n\nHandle failed MCP operations:\n- Validate inputs before calling MCP tools\n- Provide clear error messages\n- Check rate limiting and quotas\n\n### Configuration Errors\n\nValidate MCP configuration:\n- Test server connectivity during development\n- Validate JSON syntax\n- Check required environment variables\n\n## Performance Considerations\n\n### Lazy Loading\n\nMCP servers connect on-demand:\n- Not all servers connect at startup\n- First tool use triggers connection\n- Connection pooling managed automatically\n\n### Batching\n\nBatch similar requests when possible:\n\n```\n# Good: Single query with filters\ntasks = search_tasks(project=\"X\", assignee=\"me\", limit=50)\n\n# Avoid: Many individual queries\nfor id in task_ids:\n    task = get_task(id)\n```\n\n## Testing MCP Integration\n\n### Local Testing\n\n1. Configure MCP server in `.mcp.json`\n2. Install plugin locally (`.claude-plugin/`)\n3. Run `/mcp` to verify server appears\n4. Test tool calls in commands\n5. Check `claude --debug` logs for connection issues\n\n### Validation Checklist\n\n- [ ] MCP configuration is valid JSON\n- [ ] Server URL is correct and accessible\n- [ ] Required environment variables documented\n- [ ] Tools appear in `/mcp` output\n- [ ] Authentication works (OAuth or tokens)\n- [ ] Tool calls succeed from commands\n- [ ] Error cases handled gracefully\n\n## Debugging\n\n### Enable Debug Logging\n\n```bash\nclaude --debug\n```\n\nLook for:\n- MCP server connection attempts\n- Tool discovery logs\n- Authentication flows\n- Tool call errors\n\n### Common Issues\n\n**Server not connecting:**\n- Check URL is correct\n- Verify server is running (stdio)\n- Check network connectivity\n- Review authentication configuration\n\n**Tools not available:**\n- Verify server connected successfully\n- Check tool names match exactly\n- Run `/mcp` to see available tools\n- Restart Claude Code after config changes\n\n**Authentication failing:**\n- Clear cached auth tokens\n- Re-authenticate\n- Check token scopes and permissions\n- Verify environment variables set\n\n## Quick Reference\n\n### MCP Server Types\n\n| Type | Transport | Best For | Auth |\n|------|-----------|----------|------|\n| stdio | Process | Local tools, custom servers | Env vars |\n| SSE | HTTP | Hosted services, cloud APIs | OAuth |\n| HTTP | REST | API backends, token auth | Tokens |\n| ws | WebSocket | Real-time, streaming | Tokens |\n\n### Configuration Checklist\n\n- [ ] Server type specified (stdio/SSE/HTTP/ws)\n- [ ] Type-specific fields complete (command or url)\n- [ ] Authentication configured\n- [ ] Environment variables documented\n- [ ] HTTPS/WSS used (not HTTP/WS)\n- [ ] ${CLAUDE_PLUGIN_ROOT} used for paths\n\n### Best Practices\n\n**DO:**\n- ✅ Use ${CLAUDE_PLUGIN_ROOT} for portable paths\n- ✅ Document required environment variables\n- ✅ Use secure connections (HTTPS/WSS)\n- ✅ Pre-allow specific MCP tools in commands\n- ✅ Test MCP integration before publishing\n- ✅ Handle connection and tool errors gracefully\n\n**DON'T:**\n- ❌ Hardcode absolute paths\n- ❌ Commit credentials to git\n- ❌ Use HTTP instead of HTTPS\n- ❌ Pre-allow all tools with wildcards\n- ❌ Skip error handling\n- ❌ Forget to document setup\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed information, consult:\n\n- **`references/server-types.md`** - Deep dive on each server type\n- **`references/authentication.md`** - Authentication patterns and OAuth\n- **`references/tool-usage.md`** - Using MCP tools in commands and agents\n\n### Example Configurations\n\nWorking examples in `examples/`:\n\n- **`stdio-server.json`** - Local stdio MCP server\n- **`sse-server.json`** - Hosted SSE server with OAuth\n- **`http-server.json`** - REST API with token auth\n\n### External Resources\n\n- **Official MCP Docs**: https://modelcontextprotocol.io/\n- **Claude Code MCP Docs**: https://docs.claude.com/en/docs/claude-code/mcp\n- **MCP SDK**: @modelcontextprotocol/sdk\n- **Testing**: Use `claude --debug` and `/mcp` command\n\n## Implementation Workflow\n\nTo add MCP integration to a plugin:\n\n1. Choose MCP server type (stdio, SSE, HTTP, ws)\n2. Create `.mcp.json` at plugin root with configuration\n3. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n4. Document required environment variables in README\n5. Test locally with `/mcp` command\n6. Pre-allow MCP tools in relevant commands\n7. Handle authentication (OAuth or tokens)\n8. Test error cases (connection failures, auth errors)\n9. Document MCP integration in plugin README\n\nFocus on stdio for custom/local servers, SSE for hosted services with OAuth."
              },
              {
                "name": "plugin-settings",
                "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.",
                "path": "plugins/harness/skills/plugin-settings/SKILL.md",
                "frontmatter": {
                  "name": "plugin-settings",
                  "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content."
                },
                "content": "# Plugin Settings Pattern for Claude Code Plugins\n\n## Overview\n\nPlugins can store user-configurable settings and state in `.claude/plugin-name.local.md` files within the project directory. This pattern uses YAML frontmatter for structured configuration and markdown content for prompts or additional context.\n\n**Key characteristics:**\n- File location: `.claude/plugin-name.local.md` in project root\n- Structure: YAML frontmatter + markdown body\n- Purpose: Per-project plugin configuration and state\n- Usage: Read from hooks, commands, and agents\n- Lifecycle: User-managed (not in git, should be in `.gitignore`)\n\n## File Structure\n\n### Basic Template\n\n```markdown\n---\nenabled: true\nsetting1: value1\nsetting2: value2\nnumeric_setting: 42\nlist_setting: [\"item1\", \"item2\"]\n---\n\n# Additional Context\n\nThis markdown body can contain:\n- Task descriptions\n- Additional instructions\n- Prompts to feed back to Claude\n- Documentation or notes\n```\n\n### Example: Plugin State File\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nenabled: true\nstrict_mode: false\nmax_retries: 3\nnotification_level: info\ncoordinator_session: team-leader\n---\n\n# Plugin Configuration\n\nThis plugin is configured for standard validation mode.\nContact @team-lead with questions.\n```\n\n## Reading Settings Files\n\n### From Hooks (Bash Scripts)\n\n**Pattern: Check existence and parse frontmatter**\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\n# Define state file path\nSTATE_FILE=\".claude/my-plugin.local.md\"\n\n# Quick exit if file doesn't exist\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0  # Plugin not configured, skip\nfi\n\n# Parse YAML frontmatter (between --- markers)\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\n\n# Extract individual fields\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\nSTRICT_MODE=$(echo \"$FRONTMATTER\" | grep '^strict_mode:' | sed 's/strict_mode: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n\n# Check if enabled\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Use configuration in hook logic\nif [[ \"$STRICT_MODE\" == \"true\" ]]; then\n  # Apply strict validation\n  # ...\nfi\n```\n\nSee `examples/read-settings-hook.sh` for complete working example.\n\n### From Commands\n\nCommands can read settings files to customize behavior:\n\n```markdown\n---\ndescription: Process data with plugin\nallowed-tools: [\"Read\", \"Bash\"]\n---\n\n# Process Command\n\nSteps:\n1. Check if settings exist at `.claude/my-plugin.local.md`\n2. Read configuration using Read tool\n3. Parse YAML frontmatter to extract settings\n4. Apply settings to processing logic\n5. Execute with configured behavior\n```\n\n### From Agents\n\nAgents can reference settings in their instructions:\n\n```markdown\n---\nname: configured-agent\ndescription: Agent that adapts to project settings\n---\n\nCheck for plugin settings at `.claude/my-plugin.local.md`.\nIf present, parse YAML frontmatter and adapt behavior according to:\n- enabled: Whether plugin is active\n- mode: Processing mode (strict, standard, lenient)\n- Additional configuration fields\n```\n\n## Parsing Techniques\n\n### Extract Frontmatter\n\n```bash\n# Extract everything between --- markers\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n```\n\n### Read Individual Fields\n\n**String fields:**\n```bash\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field_name:' | sed 's/field_name: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n**Boolean fields:**\n```bash\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n# Compare: if [[ \"$ENABLED\" == \"true\" ]]; then\n```\n\n**Numeric fields:**\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n# Use: if [[ $MAX -gt 100 ]]; then\n```\n\n### Read Markdown Body\n\nExtract content after second `---`:\n\n```bash\n# Get everything after closing ---\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n## Common Patterns\n\n### Pattern 1: Temporarily Active Hooks\n\nUse settings file to control hook activation:\n\n```bash\n#!/bin/bash\nSTATE_FILE=\".claude/security-scan.local.md\"\n\n# Quick exit if not configured\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0\nfi\n\n# Read enabled flag\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Run hook logic\n# ...\n```\n\n**Use case:** Enable/disable hooks without editing hooks.json (requires restart).\n\n### Pattern 2: Agent State Management\n\nStore agent-specific state and configuration:\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-agent\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\n---\n\n# Task Assignment\n\nImplement JWT authentication for the API.\n\n**Success Criteria:**\n- Authentication endpoints created\n- Tests passing\n- PR created and CI green\n```\n\nRead from hooks to coordinate agents:\n\n```bash\nAGENT_NAME=$(echo \"$FRONTMATTER\" | grep '^agent_name:' | sed 's/agent_name: *//')\nCOORDINATOR=$(echo \"$FRONTMATTER\" | grep '^coordinator_session:' | sed 's/coordinator_session: *//')\n\n# Send notification to coordinator\ntmux send-keys -t \"$COORDINATOR\" \"Agent $AGENT_NAME completed task\" Enter\n```\n\n### Pattern 3: Configuration-Driven Behavior\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nvalidation_level: strict\nmax_file_size: 1000000\nallowed_extensions: [\".js\", \".ts\", \".tsx\"]\nenable_logging: true\n---\n\n# Validation Configuration\n\nStrict mode enabled for this project.\nAll writes validated against security policies.\n```\n\nUse in hooks or commands:\n\n```bash\nLEVEL=$(echo \"$FRONTMATTER\" | grep '^validation_level:' | sed 's/validation_level: *//')\n\ncase \"$LEVEL\" in\n  strict)\n    # Apply strict validation\n    ;;\n  standard)\n    # Apply standard validation\n    ;;\n  lenient)\n    # Apply lenient validation\n    ;;\nesac\n```\n\n## Creating Settings Files\n\n### From Commands\n\nCommands can create settings files:\n\n```markdown\n# Setup Command\n\nSteps:\n1. Ask user for configuration preferences\n2. Create `.claude/my-plugin.local.md` with YAML frontmatter\n3. Set appropriate values based on user input\n4. Inform user that settings are saved\n5. Remind user to restart Claude Code for hooks to recognize changes\n```\n\n### Template Generation\n\nProvide template in plugin README:\n\n```markdown\n## Configuration\n\nCreate `.claude/my-plugin.local.md` in your project:\n\n\\`\\`\\`markdown\n---\nenabled: true\nmode: standard\nmax_retries: 3\n---\n\n# Plugin Configuration\n\nYour settings are active.\n\\`\\`\\`\n\nAfter creating or editing, restart Claude Code for changes to take effect.\n```\n\n## Best Practices\n\n### File Naming\n\n✅ **DO:**\n- Use `.claude/plugin-name.local.md` format\n- Match plugin name exactly\n- Use `.local.md` suffix for user-local files\n\n❌ **DON'T:**\n- Use different directory (not `.claude/`)\n- Use inconsistent naming\n- Use `.md` without `.local` (might be committed)\n\n### Gitignore\n\nAlways add to `.gitignore`:\n\n```gitignore\n.claude/*.local.md\n.claude/*.local.json\n```\n\nDocument this in plugin README.\n\n### Defaults\n\nProvide sensible defaults when settings file doesn't exist:\n\n```bash\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  # Use defaults\n  ENABLED=true\n  MODE=standard\nelse\n  # Read from file\n  # ...\nfi\n```\n\n### Validation\n\nValidate settings values:\n\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n\n# Validate numeric range\nif ! [[ \"$MAX\" =~ ^[0-9]+$ ]] || [[ $MAX -lt 1 ]] || [[ $MAX -gt 100 ]]; then\n  echo \"⚠️  Invalid max_value in settings (must be 1-100)\" >&2\n  MAX=10  # Use default\nfi\n```\n\n### Restart Requirement\n\n**Important:** Settings changes require Claude Code restart.\n\nDocument in your README:\n\n```markdown\n## Changing Settings\n\nAfter editing `.claude/my-plugin.local.md`:\n1. Save the file\n2. Exit Claude Code\n3. Restart: `claude` or `cc`\n4. New settings will be loaded\n```\n\nHooks cannot be hot-swapped within a session.\n\n## Security Considerations\n\n### Sanitize User Input\n\nWhen writing settings files from user input:\n\n```bash\n# Escape quotes in user input\nSAFE_VALUE=$(echo \"$USER_INPUT\" | sed 's/\"/\\\\\"/g')\n\n# Write to file\ncat > \"$STATE_FILE\" <<EOF\n---\nuser_setting: \"$SAFE_VALUE\"\n---\nEOF\n```\n\n### Validate File Paths\n\nIf settings contain file paths:\n\n```bash\nFILE_PATH=$(echo \"$FRONTMATTER\" | grep '^data_file:' | sed 's/data_file: *//')\n\n# Check for path traversal\nif [[ \"$FILE_PATH\" == *\"..\"* ]]; then\n  echo \"⚠️  Invalid path in settings (path traversal)\" >&2\n  exit 2\nfi\n```\n\n### Permissions\n\nSettings files should be:\n- Readable by user only (`chmod 600`)\n- Not committed to git\n- Not shared between users\n\n## Real-World Examples\n\n### multi-agent-swarm Plugin\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-implementation\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\nadditional_instructions: Use JWT tokens, not sessions\n---\n\n# Task: Implement Authentication\n\nBuild JWT-based authentication for the REST API.\nCoordinate with auth-agent on shared types.\n```\n\n**Hook usage (agent-stop-notification.sh):**\n- Checks if file exists (line 15-18: quick exit if not)\n- Parses frontmatter to get coordinator_session, agent_name, enabled\n- Sends notifications to coordinator if enabled\n- Allows quick activation/deactivation via `enabled: true/false`\n\n### ralph-loop Plugin\n\n**.claude/ralph-loop.local.md:**\n```markdown\n---\niteration: 1\nmax_iterations: 10\ncompletion_promise: \"All tests passing and build successful\"\n---\n\nFix all the linting errors in the project.\nMake sure tests pass after each fix.\n```\n\n**Hook usage (stop-hook.sh):**\n- Checks if file exists (line 15-18: quick exit if not active)\n- Reads iteration count and max_iterations\n- Extracts completion_promise for loop termination\n- Reads body as the prompt to feed back\n- Updates iteration count on each loop\n\n## Quick Reference\n\n### File Location\n\n```\nproject-root/\n└── .claude/\n    └── plugin-name.local.md\n```\n\n### Frontmatter Parsing\n\n```bash\n# Extract frontmatter\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n\n# Read field\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field:' | sed 's/field: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n### Body Parsing\n\n```bash\n# Extract body (after second ---)\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n### Quick Exit Pattern\n\n```bash\nif [[ ! -f \".claude/my-plugin.local.md\" ]]; then\n  exit 0  # Not configured\nfi\n```\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed implementation patterns:\n\n- **`references/parsing-techniques.md`** - Complete guide to parsing YAML frontmatter and markdown bodies\n- **`references/real-world-examples.md`** - Deep dive into multi-agent-swarm and ralph-loop implementations\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`read-settings-hook.sh`** - Hook that reads and uses settings\n- **`create-settings-command.md`** - Command that creates settings file\n- **`example-settings.md`** - Template settings file\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-settings.sh`** - Validate settings file structure\n- **`parse-frontmatter.sh`** - Extract frontmatter fields\n\n## Implementation Workflow\n\nTo add settings to a plugin:\n\n1. Design settings schema (which fields, types, defaults)\n2. Create template file in plugin documentation\n3. Add gitignore entry for `.claude/*.local.md`\n4. Implement settings parsing in hooks/commands\n5. Use quick-exit pattern (check file exists, check enabled field)\n6. Document settings in plugin README with template\n7. Remind users that changes require Claude Code restart\n\nFocus on keeping settings simple and providing good defaults when settings file doesn't exist."
              },
              {
                "name": "plugin-structure",
                "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.",
                "path": "plugins/harness/skills/plugin-structure/SKILL.md",
                "frontmatter": {
                  "name": "plugin-structure",
                  "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices."
                },
                "content": "# Plugin Structure for Claude Code\n\n## Overview\n\nClaude Code plugins follow a standardized directory structure with automatic component discovery. Understanding this structure enables creating well-organized, maintainable plugins that integrate seamlessly with Claude Code.\n\n**Key concepts:**\n- Conventional directory layout for automatic discovery\n- Manifest-driven configuration in `.claude-plugin/plugin.json`\n- Component-based organization (commands, agents, skills, hooks)\n- Portable path references using `${CLAUDE_PLUGIN_ROOT}`\n- Explicit vs. auto-discovered component loading\n\n## Directory Structure\n\nEvery Claude Code plugin follows this organizational pattern:\n\n```\nplugin-name/\n├── .claude-plugin/\n│   └── plugin.json          # Required: Plugin manifest\n├── commands/                 # Slash commands (.md files)\n├── agents/                   # Subagent definitions (.md files)\n├── skills/                   # Agent skills (subdirectories)\n│   └── skill-name/\n│       └── SKILL.md         # Required for each skill\n├── hooks/\n│   └── hooks.json           # Event handler configuration\n├── .mcp.json                # MCP server definitions\n├── .lsp.json                # LSP server definitions\n└── scripts/                 # Helper scripts and utilities\n```\n\n**Critical rules:**\n\n1. **Manifest location**: The `plugin.json` manifest MUST be in `.claude-plugin/` directory\n2. **Component locations**: All component directories (commands, agents, skills, hooks) MUST be at plugin root level, NOT nested inside `.claude-plugin/`\n3. **Optional components**: Only create directories for components the plugin actually uses\n4. **Naming convention**: Use kebab-case for all directory and file names\n\n## Plugin Manifest (plugin.json)\n\nThe manifest defines plugin metadata and configuration. Located at `.claude-plugin/plugin.json`:\n\n### Required Fields\n\n```json\n{\n  \"name\": \"plugin-name\"\n}\n```\n\n**Name requirements:**\n- Use kebab-case format (lowercase with hyphens)\n- Must be unique across installed plugins\n- No spaces or special characters\n- Example: `code-review-assistant`, `test-runner`, `api-docs`\n\n### Recommended Metadata\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Brief explanation of plugin purpose\",\n  \"author\": {\n    \"name\": \"Author Name\",\n    \"email\": \"author@example.com\",\n    \"url\": \"https://example.com\"\n  },\n  \"homepage\": \"https://docs.example.com\",\n  \"repository\": \"https://github.com/user/plugin-name\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"testing\", \"automation\", \"ci-cd\"]\n}\n```\n\n**Version format**: Follow semantic versioning (MAJOR.MINOR.PATCH)\n**Keywords**: Use for plugin discovery and categorization\n\n### Component Path Configuration\n\nSpecify custom paths for components (supplements default directories):\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"commands\": \"./custom-commands\",\n  \"agents\": [\"./agents\", \"./specialized-agents\"],\n  \"hooks\": \"./config/hooks.json\",\n  \"mcpServers\": \"./.mcp.json\",\n  \"lspServers\": \"./.lsp.json\",\n  \"outputStyles\": \"./styles/\"\n}\n```\n\n**Important**: Custom paths supplement defaults—they don't replace them. Components in both default directories and custom paths will load.\n\n**Path rules:**\n- Must be relative to plugin root\n- Must start with `./`\n- Cannot use absolute paths\n- Support arrays for multiple locations\n\n## Component Organization\n\n### Commands\n\n**Location**: `commands/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `commands/` load automatically\n\n**Example structure**:\n```\ncommands/\n├── review.md        # /review command\n├── test.md          # /test command\n└── deploy.md        # /deploy command\n```\n\n**File format**:\n```markdown\n---\nname: command-name\ndescription: Command description\n---\n\nCommand implementation instructions...\n```\n\n**Usage**: Commands integrate as native slash commands in Claude Code\n\n### Agents\n\n**Location**: `agents/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `agents/` load automatically\n\n**Example structure**:\n```\nagents/\n├── code-reviewer.md\n├── test-generator.md\n└── refactorer.md\n```\n\n**File format**:\n```markdown\n---\ndescription: Agent role and expertise\ncapabilities:\n  - Specific task 1\n  - Specific task 2\n---\n\nDetailed agent instructions and knowledge...\n```\n\n**Usage**: Users can invoke agents manually, or Claude Code selects them automatically based on task context\n\n### Skills\n\n**Location**: `skills/` directory with subdirectories per skill\n**Format**: Each skill in its own directory with `SKILL.md` file\n**Auto-discovery**: All `SKILL.md` files in skill subdirectories load automatically\n\n**Example structure**:\n```\nskills/\n├── api-testing/\n│   ├── SKILL.md\n│   ├── scripts/\n│   │   └── test-runner.py\n│   └── references/\n│       └── api-spec.md\n└── database-migrations/\n    ├── SKILL.md\n    └── examples/\n        └── migration-template.sql\n```\n\n**SKILL.md format**:\n```markdown\n---\nname: Skill Name\ndescription: When to use this skill\n---\n\nSkill instructions and guidance...\n```\n\n**Supporting files**: Skills can include scripts, references, examples, or assets in subdirectories\n\n**Usage**: Claude Code autonomously activates skills based on task context matching the description\n\n### Hooks\n\n**Location**: `hooks/hooks.json` or inline in `plugin.json`\n**Format**: JSON configuration defining event handlers\n**Registration**: Hooks register automatically when plugin enables\n\n**Example structure**:\n```\nhooks/\n├── hooks.json           # Hook configuration\n└── scripts/\n    ├── validate.sh      # Hook script\n    └── check-style.sh   # Hook script\n```\n\n**Configuration format**:\n```json\n{\n  \"PreToolUse\": [{\n    \"matcher\": \"Write|Edit\",\n    \"hooks\": [{\n      \"type\": \"command\",\n      \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/validate.sh\",\n      \"timeout\": 30\n    }]\n  }]\n}\n```\n\n**Available events**: PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification\n\n**Usage**: Hooks execute automatically in response to Claude Code events\n\n### MCP Servers\n\n**Location**: `.mcp.json` at plugin root or inline in `plugin.json`\n**Format**: JSON configuration for MCP server definitions\n**Auto-start**: Servers start automatically when plugin enables\n\n**Example format**:\n```json\n{\n  \"mcpServers\": {\n    \"server-name\": {\n      \"command\": \"node\",\n      \"args\": [\"${CLAUDE_PLUGIN_ROOT}/servers/server.js\"],\n      \"env\": {\n        \"API_KEY\": \"${API_KEY}\"\n      }\n    }\n  }\n}\n```\n\n**Usage**: MCP servers integrate seamlessly with Claude Code's tool system\n\n### LSP Servers\n\n**Location**: `.lsp.json` at plugin root or inline in `plugin.json`\n**Format**: JSON configuration for Language Server Protocol definitions\n**Auto-start**: Servers start automatically when plugin enables\n\n**Example format**:\n```json\n{\n  \"go\": {\n    \"command\": \"gopls\",\n    \"args\": [\"serve\"],\n    \"extensionToLanguage\": {\n      \".go\": \"go\"\n    }\n  }\n}\n```\n\n**Required fields**:\n- `command`: LSP binary to execute (must be in PATH)\n- `extensionToLanguage`: Maps file extensions to language identifiers\n\n**Usage**: LSP servers provide code intelligence (diagnostics, go to definition, find references)\n\n**Note**: For complete LSP configuration options, see the lsp-integration skill.\n\n### Output Styles\n\n**Location**: Custom directory specified in `plugin.json`\n**Format**: Markdown files defining output style configurations\n**Purpose**: Customize Claude's response formatting\n\n**Example configuration**:\n```json\n{\n  \"name\": \"plugin-name\",\n  \"outputStyles\": \"./styles/\"\n}\n```\n\n**Directory structure**:\n```\nstyles/\n├── concise.md       # Concise output style\n├── detailed.md      # Detailed output style\n└── technical.md     # Technical documentation style\n```\n\n**Usage**: Output styles customize how Claude formats responses for specific use cases\n\n## Portable Path References\n\n### ${CLAUDE_PLUGIN_ROOT}\n\nUse `${CLAUDE_PLUGIN_ROOT}` environment variable for all intra-plugin path references:\n\n```json\n{\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/run.sh\"\n}\n```\n\n**Why it matters**: Plugins install in different locations depending on:\n- User installation method (marketplace, local, npm)\n- Operating system conventions\n- User preferences\n\n**Where to use it**:\n- Hook command paths\n- MCP server command arguments\n- Script execution references\n- Resource file paths\n\n**Never use**:\n- Hardcoded absolute paths (`/Users/name/plugins/...`)\n- Relative paths from working directory (`./scripts/...` in commands)\n- Home directory shortcuts (`~/plugins/...`)\n\n### Path Resolution Rules\n\n**In manifest JSON fields** (hooks, MCP servers):\n```json\n\"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/tool.sh\"\n```\n\n**In component files** (commands, agents, skills):\n```markdown\nReference scripts at: ${CLAUDE_PLUGIN_ROOT}/scripts/helper.py\n```\n\n**In executed scripts**:\n```bash\n#!/bin/bash\n# ${CLAUDE_PLUGIN_ROOT} available as environment variable\nsource \"${CLAUDE_PLUGIN_ROOT}/lib/common.sh\"\n```\n\n## File Naming Conventions\n\n### Component Files\n\n**Commands**: Use kebab-case `.md` files\n- `code-review.md` → `/code-review`\n- `run-tests.md` → `/run-tests`\n- `api-docs.md` → `/api-docs`\n\n**Agents**: Use kebab-case `.md` files describing role\n- `test-generator.md`\n- `code-reviewer.md`\n- `performance-analyzer.md`\n\n**Skills**: Use kebab-case directory names\n- `api-testing/`\n- `database-migrations/`\n- `error-handling/`\n\n### Supporting Files\n\n**Scripts**: Use descriptive kebab-case names with appropriate extensions\n- `validate-input.sh`\n- `generate-report.py`\n- `process-data.js`\n\n**Documentation**: Use kebab-case markdown files\n- `api-reference.md`\n- `migration-guide.md`\n- `best-practices.md`\n\n**Configuration**: Use standard names\n- `hooks.json`\n- `.mcp.json`\n- `plugin.json`\n\n## Auto-Discovery Mechanism\n\nClaude Code automatically discovers and loads components:\n\n1. **Plugin manifest**: Reads `.claude-plugin/plugin.json` when plugin enables\n2. **Commands**: Scans `commands/` directory for `.md` files\n3. **Agents**: Scans `agents/` directory for `.md` files\n4. **Skills**: Scans `skills/` for subdirectories containing `SKILL.md`\n5. **Hooks**: Loads configuration from `hooks/hooks.json` or manifest\n6. **MCP servers**: Loads configuration from `.mcp.json` or manifest\n\n**Discovery timing**:\n- Plugin installation: Components register with Claude Code\n- Plugin enable: Components become available for use\n- No restart required: Changes take effect on next Claude Code session\n\n**Override behavior**: Custom paths in `plugin.json` supplement (not replace) default directories\n\n## Best Practices\n\n### Organization\n\n1. **Logical grouping**: Group related components together\n   - Put test-related commands, agents, and skills together\n   - Create subdirectories in `scripts/` for different purposes\n\n2. **Minimal manifest**: Keep `plugin.json` lean\n   - Only specify custom paths when necessary\n   - Rely on auto-discovery for standard layouts\n   - Use inline configuration only for simple cases\n\n3. **Documentation**: Include README files\n   - Plugin root: Overall purpose and usage\n   - Component directories: Specific guidance\n   - Script directories: Usage and requirements\n\n### Naming\n\n1. **Consistency**: Use consistent naming across components\n   - If command is `test-runner`, name related agent `test-runner-agent`\n   - Match skill directory names to their purpose\n\n2. **Clarity**: Use descriptive names that indicate purpose\n   - Good: `api-integration-testing/`, `code-quality-checker.md`\n   - Avoid: `utils/`, `misc.md`, `temp.sh`\n\n3. **Length**: Balance brevity with clarity\n   - Commands: 2-3 words (`review-pr`, `run-ci`)\n   - Agents: Describe role clearly (`code-reviewer`, `test-generator`)\n   - Skills: Topic-focused (`error-handling`, `api-design`)\n\n### Portability\n\n1. **Always use ${CLAUDE_PLUGIN_ROOT}**: Never hardcode paths\n2. **Test on multiple systems**: Verify on macOS, Linux, Windows\n3. **Document dependencies**: List required tools and versions\n4. **Avoid system-specific features**: Use portable bash/Python constructs\n\n### Maintenance\n\n1. **Version consistently**: Update version in plugin.json for releases\n2. **Deprecate gracefully**: Mark old components clearly before removal\n3. **Document breaking changes**: Note changes affecting existing users\n4. **Test thoroughly**: Verify all components work after changes\n\n## Common Patterns\n\n### Minimal Plugin\n\nSingle command with no dependencies:\n```\nmy-plugin/\n├── .claude-plugin/\n│   └── plugin.json    # Just name field\n└── commands/\n    └── hello.md       # Single command\n```\n\n### Full-Featured Plugin\n\nComplete plugin with all component types:\n```\nmy-plugin/\n├── .claude-plugin/\n│   └── plugin.json\n├── commands/          # User-facing commands\n├── agents/            # Specialized subagents\n├── skills/            # Auto-activating skills\n├── hooks/             # Event handlers\n│   ├── hooks.json\n│   └── scripts/\n├── .mcp.json          # External integrations\n└── scripts/           # Shared utilities\n```\n\n### Skill-Focused Plugin\n\nPlugin providing only skills:\n```\nmy-plugin/\n├── .claude-plugin/\n│   └── plugin.json\n└── skills/\n    ├── skill-one/\n    │   └── SKILL.md\n    └── skill-two/\n        └── SKILL.md\n```\n\n## Plugin Caching and File Resolution\n\nFor security and verification purposes, Claude Code copies plugins to a cache directory rather than using them in-place. Understanding this behavior is important when developing plugins that reference external files.\n\n### How Plugin Caching Works\n\nWhen a plugin is installed, Claude Code copies the plugin files to a cache directory:\n\n- **Marketplace plugins with relative paths**: The path specified in the `source` field is copied recursively\n- **Plugins with `.claude-plugin/plugin.json`**: The implicit root directory (containing `.claude-plugin/`) is copied recursively\n\n### Path Traversal Limitations\n\nPlugins cannot reference files outside their copied directory structure. Paths that traverse outside the plugin root (such as `../shared-utils`) will not work after installation because those external files are not copied to the cache.\n\n**This will NOT work:**\n```json\n{\n  \"command\": \"bash ../shared-scripts/run.sh\"\n}\n```\n\n**This WILL work:**\n```json\n{\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/run.sh\"\n}\n```\n\n### Working with External Dependencies\n\nIf a plugin needs to access files outside its directory, there are two options:\n\n**Option 1: Use symlinks**\n\nCreate symbolic links to external files within the plugin directory. Symlinks are followed during the copy process:\n\n```bash\n# Inside plugin directory\nln -s /path/to/shared-utils ./shared-utils\n```\n\nThe symlinked content will be copied into the plugin cache.\n\n**Option 2: Restructure for marketplace**\n\nSet the plugin path to a parent directory that contains all required files:\n\n```json\n{\n  \"name\": \"my-plugin\",\n  \"source\": \"./\",\n  \"description\": \"Plugin that needs root-level access\",\n  \"commands\": [\"./plugins/my-plugin/commands/\"],\n  \"agents\": [\"./plugins/my-plugin/agents/\"],\n  \"strict\": false\n}\n```\n\nThis approach copies the entire marketplace root, giving the plugin access to sibling directories.\n\n### Implications for Development\n\n1. **Self-contained plugins**: Design plugins to be fully self-contained\n2. **Test after installation**: Always test plugins after installation, not just with `--plugin-dir`\n3. **Use ${CLAUDE_PLUGIN_ROOT}**: All internal references should use this variable\n4. **Bundle dependencies**: Include all required scripts and resources within the plugin\n\n## Troubleshooting\n\n**Component not loading**:\n- Verify file is in correct directory with correct extension\n- Check YAML frontmatter syntax (commands, agents, skills)\n- Ensure skill has `SKILL.md` (not `README.md` or other name)\n- Confirm plugin is enabled in Claude Code settings\n\n**Path resolution errors**:\n- Replace all hardcoded paths with `${CLAUDE_PLUGIN_ROOT}`\n- Verify paths are relative and start with `./` in manifest\n- Check that referenced files exist at specified paths\n- Test with `echo $CLAUDE_PLUGIN_ROOT` in hook scripts\n\n**Auto-discovery not working**:\n- Confirm directories are at plugin root (not in `.claude-plugin/`)\n- Check file naming follows conventions (kebab-case, correct extensions)\n- Verify custom paths in manifest are correct\n- Restart Claude Code to reload plugin configuration\n\n**Conflicts between plugins**:\n- Use unique, descriptive component names\n- Namespace commands with plugin name if needed\n- Document potential conflicts in plugin README\n- Consider command prefixes for related functionality\n\n---\n\nFor detailed examples and advanced patterns, see files in `references/` and `examples/` directories."
              },
              {
                "name": "skill-development",
                "description": "This skill should be used when the user asks to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins.",
                "path": "plugins/harness/skills/skill-development/SKILL.md",
                "frontmatter": {
                  "name": "skill-development",
                  "description": "This skill should be used when the user asks to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins."
                },
                "content": "# Skill Development for Claude Code Plugins\n\nThis skill provides guidance for creating effective skills for Claude Code plugins.\n\n## About Skills\n\nSkills are modular, self-contained packages that extend Claude's capabilities by providing\nspecialized knowledge, workflows, and tools. Think of them as \"onboarding guides\" for specific\ndomains or tasks—they transform Claude from a general-purpose agent into a specialized agent\nequipped with procedural knowledge that no model can fully possess.\n\n### What Skills Provide\n\n1. Specialized workflows - Multi-step procedures for specific domains\n2. Tool integrations - Instructions for working with specific file formats or APIs\n3. Domain expertise - Company-specific knowledge, schemas, business logic\n4. Bundled resources - Scripts, references, and assets for complex and repetitive tasks\n\n### Anatomy of a Skill\n\nEvery skill consists of a required SKILL.md file and optional bundled resources:\n\n```\nskill-name/\n├── SKILL.md (required)\n│   ├── YAML frontmatter metadata\n│   │   ├── name: (required)\n│   │   ├── description: (required)\n│   │   ├── allowed-tools: (optional) - Tools allowed when skill is active\n│   │   ├── model: (optional) - Model to use when skill is active\n│   │   ├── context: (optional) - Set to \"fork\" for isolated subagent context\n│   │   ├── agent: (optional) - Agent type when context: fork\n│   │   ├── hooks: (optional) - Hooks scoped to skill lifecycle\n│   │   └── user-invocable: (optional) - Controls slash menu visibility\n│   └── Markdown instructions (required)\n└── Bundled Resources (optional)\n    ├── scripts/          - Executable code (Python/Bash/etc.)\n    ├── references/       - Documentation intended to be loaded into context as needed\n    └── assets/           - Files used in output (templates, icons, fonts, etc.)\n```\n\n#### SKILL.md (required)\n\n**Metadata Quality:** The `name` and `description` in YAML frontmatter determine when Claude will use the skill. Be specific about what the skill does and when to use it. Use the third-person (e.g. \"This skill should be used when...\" instead of \"Use this skill when...\").\n\n#### Bundled Resources (optional)\n\n##### Scripts (`scripts/`)\n\nExecutable code (Python/Bash/etc.) for tasks that require deterministic reliability or are repeatedly rewritten.\n\n- **When to include**: When the same code is being rewritten repeatedly or deterministic reliability is needed\n- **Example**: `scripts/rotate_pdf.py` for PDF rotation tasks\n- **Benefits**: Token efficient, deterministic, may be executed without loading into context\n- **Note**: Scripts may still need to be read by Claude for patching or environment-specific adjustments\n\n##### References (`references/`)\n\nDocumentation and reference material intended to be loaded as needed into context to inform Claude's process and thinking.\n\n- **When to include**: For documentation that Claude should reference while working\n- **Examples**: `references/finance.md` for financial schemas, `references/mnda.md` for company NDA template, `references/policies.md` for company policies, `references/api_docs.md` for API specifications\n- **Use cases**: Database schemas, API documentation, domain knowledge, company policies, detailed workflow guides\n- **Benefits**: Keeps SKILL.md lean, loaded only when Claude determines it's needed\n- **Best practice**: If files are large (>10k words), include grep search patterns in SKILL.md\n- **Avoid duplication**: Information should live in either SKILL.md or references files, not both. Prefer references files for detailed information unless it's truly core to the skill—this keeps SKILL.md lean while making information discoverable without hogging the context window. Keep only essential procedural instructions and workflow guidance in SKILL.md; move detailed reference material, schemas, and examples to references files.\n\n##### Assets (`assets/`)\n\nFiles not intended to be loaded into context, but rather used within the output Claude produces.\n\n- **When to include**: When the skill needs files that will be used in the final output\n- **Examples**: `assets/logo.png` for brand assets, `assets/slides.pptx` for PowerPoint templates, `assets/frontend-template/` for HTML/React boilerplate, `assets/font.ttf` for typography\n- **Use cases**: Templates, images, icons, boilerplate code, fonts, sample documents that get copied or modified\n- **Benefits**: Separates output resources from documentation, enables Claude to use files without loading them into context\n\n### Progressive Disclosure Design Principle\n\nSkills use a three-level loading system to manage context efficiently:\n\n1. **Metadata (name + description)** - Always in context (~100 words)\n2. **SKILL.md body** - When skill triggers (<5k words)\n3. **Bundled resources** - As needed by Claude (Unlimited*)\n\n*Unlimited because scripts can be executed without reading into context window.\n\n## Skill Creation Process\n\nTo create a skill, follow the \"Skill Creation Process\" in order, skipping steps only if there is a clear reason why they are not applicable.\n\n### Step 1: Understanding the Skill with Concrete Examples\n\nSkip this step only when the skill's usage patterns are already clearly understood. It remains valuable even when working with an existing skill.\n\nTo create an effective skill, clearly understand concrete examples of how the skill will be used. This understanding can come from either direct user examples or generated examples that are validated with user feedback.\n\nFor example, when building an image-editor skill, relevant questions include:\n\n- \"What functionality should the image-editor skill support? Editing, rotating, anything else?\"\n- \"Can you give some examples of how this skill would be used?\"\n- \"I can imagine users asking for things like 'Remove the red-eye from this image' or 'Rotate this image'. Are there other ways you imagine this skill being used?\"\n- \"What would a user say that should trigger this skill?\"\n\nTo avoid overwhelming users, avoid asking too many questions in a single message. Start with the most important questions and follow up as needed for better effectiveness.\n\nConclude this step when there is a clear sense of the functionality the skill should support.\n\n### Step 2: Planning the Reusable Skill Contents\n\nTo turn concrete examples into an effective skill, analyze each example by:\n\n1. Considering how to execute on the example from scratch\n2. Identifying what scripts, references, and assets would be helpful when executing these workflows repeatedly\n\nExample: When building a `pdf-editor` skill to handle queries like \"Help me rotate this PDF,\" the analysis shows:\n\n1. Rotating a PDF requires re-writing the same code each time\n2. A `scripts/rotate_pdf.py` script would be helpful to store in the skill\n\nExample: When designing a `frontend-webapp-builder` skill for queries like \"Build me a todo app\" or \"Build me a dashboard to track my steps,\" the analysis shows:\n\n1. Writing a frontend webapp requires the same boilerplate HTML/React each time\n2. An `assets/hello-world/` template containing the boilerplate HTML/React project files would be helpful to store in the skill\n\nExample: When building a `big-query` skill to handle queries like \"How many users have logged in today?\" the analysis shows:\n\n1. Querying BigQuery requires re-discovering the table schemas and relationships each time\n2. A `references/schema.md` file documenting the table schemas would be helpful to store in the skill\n\n**For Claude Code plugins:** When building a hooks skill, the analysis shows:\n1. Developers repeatedly need to validate hooks.json and test hook scripts\n2. `scripts/validate-hook-schema.sh` and `scripts/test-hook.sh` utilities would be helpful\n3. `references/patterns.md` for detailed hook patterns to avoid bloating SKILL.md\n\nTo establish the skill's contents, analyze each concrete example to create a list of the reusable resources to include: scripts, references, and assets.\n\n### Step 3: Create Skill Structure\n\nFor Claude Code plugins, create the skill directory structure:\n\n```bash\nmkdir -p plugin-name/skills/skill-name/{references,examples,scripts}\ntouch plugin-name/skills/skill-name/SKILL.md\n```\n\n**Note:** Unlike the generic skill-creator which uses `init_skill.py`, plugin skills are created directly in the plugin's `skills/` directory with a simpler manual structure.\n\n### Step 4: Edit the Skill\n\nWhen editing the (newly-created or existing) skill, remember that the skill is being created for another instance of Claude to use. Focus on including information that would be beneficial and non-obvious to Claude. Consider what procedural knowledge, domain-specific details, or reusable assets would help another Claude instance execute these tasks more effectively.\n\n#### Start with Reusable Skill Contents\n\nTo begin implementation, start with the reusable resources identified above: `scripts/`, `references/`, and `assets/` files. Note that this step may require user input. For example, when implementing a `brand-guidelines` skill, the user may need to provide brand assets or templates to store in `assets/`, or documentation to store in `references/`.\n\nAlso, delete any example files and directories not needed for the skill. Create only the directories you actually need (references/, examples/, scripts/).\n\n#### Update SKILL.md\n\n**Writing Style:** Write the entire skill using **imperative/infinitive form** (verb-first instructions), not second person. Use objective, instructional language (e.g., \"To accomplish X, do Y\" rather than \"You should do X\" or \"If you need to do X\"). This maintains consistency and clarity for AI consumption.\n\n**Description (Frontmatter):** Use third-person format with specific trigger phrases:\n\n```yaml\n---\nname: skill-name\ndescription: This skill should be used when the user asks to \"specific phrase 1\", \"specific phrase 2\", \"specific phrase 3\". Include exact phrases users would say that should trigger this skill. Be concrete and specific.\n---\n```\n\n**Optional frontmatter fields:**\n- `allowed-tools`: Restrict tools when skill is active (e.g., `Read, Grep, Glob`)\n- `model`: Model to use (e.g., `claude-sonnet-4-20250514`)\n- `context`: Set to `fork` to run in isolated subagent context\n- `agent`: Agent type when using `context: fork` (e.g., `Explore`, `Plan`, `general-purpose`)\n- `hooks`: Define hooks scoped to skill lifecycle (PreToolUse, PostToolUse, Stop)\n- `user-invocable`: Set to `false` to hide from slash menu while still allowing programmatic invocation\n\n**Good description examples:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", \"implement prompt-based hooks\", or mentions hook events (PreToolUse, PostToolUse, Stop).\n```\n\n**Bad description examples:**\n```yaml\ndescription: Use this skill when working with hooks.  # Wrong person, vague\ndescription: Load when user needs hook help.  # Not third person\ndescription: Provides hook guidance.  # No trigger phrases\n```\n\nTo complete SKILL.md body, answer the following questions:\n\n1. What is the purpose of the skill, in a few sentences?\n2. When should the skill be used? (Include this in frontmatter description with specific triggers)\n3. In practice, how should Claude use the skill? All reusable skill contents developed above should be referenced so that Claude knows how to use them.\n\n**Keep SKILL.md lean:** Target 1,500-2,000 words for the body. Move detailed content to references/:\n- Detailed patterns → `references/patterns.md`\n- Advanced techniques → `references/advanced.md`\n- Migration guides → `references/migration.md`\n- API references → `references/api-reference.md`\n\n**Reference resources in SKILL.md:**\n```markdown\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and techniques, consult:\n- **`references/patterns.md`** - Common patterns\n- **`references/advanced.md`** - Advanced use cases\n\n### Example Files\n\nWorking examples in `examples/`:\n- **`example-script.sh`** - Working example\n```\n\n### Step 5: Validate and Test\n\n**For plugin skills, validation is different from generic skills:**\n\n1. **Check structure**: Skill directory in `plugin-name/skills/skill-name/`\n2. **Validate SKILL.md**: Has frontmatter with name and description\n3. **Check trigger phrases**: Description includes specific user queries\n4. **Verify writing style**: Body uses imperative/infinitive form, not second person\n5. **Test progressive disclosure**: SKILL.md is lean (~1,500-2,000 words), detailed content in references/\n6. **Check references**: All referenced files exist\n7. **Validate examples**: Examples are complete and correct\n8. **Test scripts**: Scripts are executable and work correctly\n\n**Use the skill-reviewer agent:**\n```\nAsk: \"Review my skill and check if it follows best practices\"\n```\n\nThe skill-reviewer agent will check description quality, content organization, and progressive disclosure.\n\n### Step 6: Iterate\n\nAfter testing the skill, users may request improvements. Often this happens right after using the skill, with fresh context of how the skill performed.\n\n**Iteration workflow:**\n1. Use the skill on real tasks\n2. Notice struggles or inefficiencies\n3. Identify how SKILL.md or bundled resources should be updated\n4. Implement changes and test again\n\n**Common improvements:**\n- Strengthen trigger phrases in description\n- Move long sections from SKILL.md to references/\n- Add missing examples or scripts\n- Clarify ambiguous instructions\n- Add edge case handling\n\n## Plugin-Specific Considerations\n\n### Skill Location in Plugins\n\nPlugin skills live in the plugin's `skills/` directory:\n\n```\nmy-plugin/\n├── .claude-plugin/\n│   └── plugin.json\n├── commands/\n├── agents/\n└── skills/\n    └── my-skill/\n        ├── SKILL.md\n        ├── references/\n        ├── examples/\n        └── scripts/\n```\n\n### Auto-Discovery\n\nClaude Code automatically discovers skills:\n- Scans `skills/` directory\n- Finds subdirectories containing `SKILL.md`\n- Loads skill metadata (name + description) always\n- Loads SKILL.md body when skill triggers\n- Loads references/examples when needed\n\n### No Packaging Needed\n\nPlugin skills are distributed as part of the plugin, not as separate ZIP files. Users get skills when they install the plugin.\n\n### Testing in Plugins\n\nTest skills by installing plugin locally:\n\n```bash\n# Test with --plugin-dir\ncc --plugin-dir /path/to/plugin\n\n# Ask questions that should trigger the skill\n# Verify skill loads correctly\n```\n\n## Examples from Plugin-Dev\n\nStudy the skills in this plugin as examples of best practices:\n\n**hook-development skill:**\n- Excellent trigger phrases: \"create a hook\", \"add a PreToolUse hook\", etc.\n- Lean SKILL.md (1,651 words)\n- 3 references/ files for detailed content\n- 3 examples/ of working hooks\n- 3 scripts/ utilities\n\n**agent-development skill:**\n- Strong triggers: \"create an agent\", \"agent frontmatter\", etc.\n- Focused SKILL.md (1,438 words)\n- References include the AI generation prompt from Claude Code\n- Complete agent examples\n\n**plugin-settings skill:**\n- Specific triggers: \"plugin settings\", \".local.md files\", \"YAML frontmatter\"\n- References show real implementations (multi-agent-swarm, ralph-loop)\n- Working parsing scripts\n\nEach demonstrates progressive disclosure and strong triggering.\n\n## Progressive Disclosure in Practice\n\n### What Goes in SKILL.md\n\n**Include (always loaded when skill triggers):**\n- Core concepts and overview\n- Essential procedures and workflows\n- Quick reference tables\n- Pointers to references/examples/scripts\n- Most common use cases\n\n**Keep under 3,000 words, ideally 1,500-2,000 words**\n\n### What Goes in references/\n\n**Move to references/ (loaded as needed):**\n- Detailed patterns and advanced techniques\n- Comprehensive API documentation\n- Migration guides\n- Edge cases and troubleshooting\n- Extensive examples and walkthroughs\n\n**Each reference file can be large (2,000-5,000+ words)**\n\n### What Goes in examples/\n\n**Working code examples:**\n- Complete, runnable scripts\n- Configuration files\n- Template files\n- Real-world usage examples\n\n**Users can copy and adapt these directly**\n\n### What Goes in scripts/\n\n**Utility scripts:**\n- Validation tools\n- Testing helpers\n- Parsing utilities\n- Automation scripts\n\n**Should be executable and documented**\n\n## Writing Style Requirements\n\n### Imperative/Infinitive Form\n\nWrite using verb-first instructions, not second person:\n\n**Correct (imperative):**\n```\nTo create a hook, define the event type.\nConfigure the MCP server with authentication.\nValidate settings before use.\n```\n\n**Incorrect (second person):**\n```\nYou should create a hook by defining the event type.\nYou need to configure the MCP server.\nYou must validate settings before use.\n```\n\n### Third-Person in Description\n\nThe frontmatter description must use third person:\n\n**Correct:**\n```yaml\ndescription: This skill should be used when the user asks to \"create X\", \"configure Y\"...\n```\n\n**Incorrect:**\n```yaml\ndescription: Use this skill when you want to create X...\ndescription: Load this skill when user asks...\n```\n\n### Objective, Instructional Language\n\nFocus on what to do, not who should do it:\n\n**Correct:**\n```\nParse the frontmatter using sed.\nExtract fields with grep.\nValidate values before use.\n```\n\n**Incorrect:**\n```\nYou can parse the frontmatter...\nClaude should extract fields...\nThe user might validate values...\n```\n\n## Validation Checklist\n\nBefore finalizing a skill:\n\n**Structure:**\n- [ ] SKILL.md file exists with valid YAML frontmatter\n- [ ] Frontmatter has `name` and `description` fields\n- [ ] Markdown body is present and substantial\n- [ ] Referenced files actually exist\n\n**Description Quality:**\n- [ ] Uses third person (\"This skill should be used when...\")\n- [ ] Includes specific trigger phrases users would say\n- [ ] Lists concrete scenarios (\"create X\", \"configure Y\")\n- [ ] Not vague or generic\n\n**Content Quality:**\n- [ ] SKILL.md body uses imperative/infinitive form\n- [ ] Body is focused and lean (1,500-2,000 words ideal, <5k max)\n- [ ] Detailed content moved to references/\n- [ ] Examples are complete and working\n- [ ] Scripts are executable and documented\n\n**Progressive Disclosure:**\n- [ ] Core concepts in SKILL.md\n- [ ] Detailed docs in references/\n- [ ] Working code in examples/\n- [ ] Utilities in scripts/\n- [ ] SKILL.md references these resources\n\n**Testing:**\n- [ ] Skill triggers on expected user queries\n- [ ] Content is helpful for intended tasks\n- [ ] No duplicated information across files\n- [ ] References load when needed\n\n## Common Mistakes to Avoid\n\n### Mistake 1: Weak Trigger Description\n\n❌ **Bad:**\n```yaml\ndescription: Provides guidance for working with hooks.\n```\n\n**Why bad:** Vague, no specific trigger phrases, not third person\n\n✅ **Good:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", or mentions hook events. Provides comprehensive hooks API guidance.\n```\n\n**Why good:** Third person, specific phrases, concrete scenarios\n\n### Mistake 2: Too Much in SKILL.md\n\n❌ **Bad:**\n```\nskill-name/\n└── SKILL.md  (8,000 words - everything in one file)\n```\n\n**Why bad:** Bloats context when skill loads, detailed content always loaded\n\n✅ **Good:**\n```\nskill-name/\n├── SKILL.md  (1,800 words - core essentials)\n└── references/\n    ├── patterns.md (2,500 words)\n    └── advanced.md (3,700 words)\n```\n\n**Why good:** Progressive disclosure, detailed content loaded only when needed\n\n### Mistake 3: Second Person Writing\n\n❌ **Bad:**\n```markdown\nYou should start by reading the configuration file.\nYou need to validate the input.\nYou can use the grep tool to search.\n```\n\n**Why bad:** Second person, not imperative form\n\n✅ **Good:**\n```markdown\nStart by reading the configuration file.\nValidate the input before processing.\nUse the grep tool to search for patterns.\n```\n\n**Why good:** Imperative form, direct instructions\n\n### Mistake 4: Missing Resource References\n\n❌ **Bad:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n[No mention of references/ or examples/]\n```\n\n**Why bad:** Claude doesn't know references exist\n\n✅ **Good:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n## Additional Resources\n\n### Reference Files\n- **`references/patterns.md`** - Detailed patterns\n- **`references/advanced.md`** - Advanced techniques\n\n### Examples\n- **`examples/script.sh`** - Working example\n```\n\n**Why good:** Claude knows where to find additional information\n\n## Quick Reference\n\n### Minimal Skill\n\n```\nskill-name/\n└── SKILL.md\n```\n\nGood for: Simple knowledge, no complex resources needed\n\n### Standard Skill (Recommended)\n\n```\nskill-name/\n├── SKILL.md\n├── references/\n│   └── detailed-guide.md\n└── examples/\n    └── working-example.sh\n```\n\nGood for: Most plugin skills with detailed documentation\n\n### Complete Skill\n\n```\nskill-name/\n├── SKILL.md\n├── references/\n│   ├── patterns.md\n│   └── advanced.md\n├── examples/\n│   ├── example1.sh\n│   └── example2.json\n└── scripts/\n    └── validate.sh\n```\n\nGood for: Complex domains with validation utilities\n\n## Best Practices Summary\n\n✅ **DO:**\n- Use third-person in description (\"This skill should be used when...\")\n- Include specific trigger phrases (\"create X\", \"configure Y\")\n- Keep SKILL.md lean (1,500-2,000 words)\n- Use progressive disclosure (move details to references/)\n- Write in imperative/infinitive form\n- Reference supporting files clearly\n- Provide working examples\n- Create utility scripts for common operations\n- Study plugin-dev's skills as templates\n\n❌ **DON'T:**\n- Use second person anywhere\n- Have vague trigger conditions\n- Put everything in SKILL.md (>3,000 words without references/)\n- Write in second person (\"You should...\")\n- Leave resources unreferenced\n- Include broken or incomplete examples\n- Skip validation\n\n## Additional Resources\n\n### Study These Skills\n\nPlugin-dev's skills demonstrate best practices:\n- `../hook-development/` - Progressive disclosure, utilities\n- `../agent-development/` - AI-assisted creation, references\n- `../mcp-integration/` - Comprehensive references\n- `../plugin-settings/` - Real-world examples\n- `../command-development/` - Clear critical concepts\n- `../plugin-structure/` - Good organization\n\n### Reference Files\n\nFor complete skill-creator methodology:\n- **`references/skill-creator-original.md`** - Full original skill-creator content\n\n## Implementation Workflow\n\nTo create a skill for your plugin:\n\n1. **Understand use cases**: Identify concrete examples of skill usage\n2. **Plan resources**: Determine what scripts/references/examples needed\n3. **Create structure**: `mkdir -p skills/skill-name/{references,examples,scripts}`\n4. **Write SKILL.md**:\n   - Frontmatter with third-person description and trigger phrases\n   - Lean body (1,500-2,000 words) in imperative form\n   - Reference supporting files\n5. **Add resources**: Create references/, examples/, scripts/ as needed\n6. **Validate**: Check description, writing style, organization\n7. **Test**: Verify skill loads on expected triggers\n8. **Iterate**: Improve based on usage\n\nFocus on strong trigger descriptions, progressive disclosure, and imperative writing style for effective skills that load when needed and provide targeted guidance."
              }
            ]
          },
          {
            "name": "engram-mcp",
            "description": "Semantic memory for Claude Code - persistent context across sessions",
            "source": "./plugins/engram-mcp",
            "category": "productivity",
            "version": null,
            "author": {
              "name": "Steven Mosley",
              "email": "34114851+astrosteveo@users.noreply.github.com"
            },
            "install_commands": [
              "/plugin marketplace add astrosteveo/marketplace",
              "/plugin install engram-mcp@astrosteveo-marketplace"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-12T03:32:51Z",
              "created_at": "2026-01-09T21:25:44Z",
              "license": null
            },
            "commands": [
              {
                "name": "/remember",
                "description": "Save something important for future sessions",
                "path": "plugins/engram-mcp/commands/remember.md",
                "frontmatter": {
                  "description": "Save something important for future sessions",
                  "argument-hint": "<content>",
                  "allowed-tools": "mcp__plugin_engram-mcp_engram__memory_remember"
                },
                "content": "Remember this for future sessions: $ARGUMENTS\n\nUse the `mcp__plugin_engram-mcp_engram__memory_remember` MCP tool with the content provided."
              },
              {
                "name": "/resume",
                "description": "Get context to resume previous work",
                "path": "plugins/engram-mcp/commands/resume.md",
                "frontmatter": {
                  "description": "Get context to resume previous work",
                  "allowed-tools": "mcp__plugin_engram-mcp_engram__memory_resume"
                },
                "content": "Use the `mcp__plugin_engram-mcp_engram__memory_resume` MCP tool to get last session state, active todos, and recent exchanges."
              },
              {
                "name": "/search",
                "description": "Search project semantic memory for relevant past context",
                "path": "plugins/engram-mcp/commands/search.md",
                "frontmatter": {
                  "description": "Search project semantic memory for relevant past context",
                  "argument-hint": "<query>",
                  "allowed-tools": "mcp__plugin_engram-mcp_engram__memory_search"
                },
                "content": "Search indexed memory for: $ARGUMENTS\n\nUse the `mcp__plugin_engram-mcp_engram__memory_search` MCP tool with the query provided."
              },
              {
                "name": "/stats",
                "description": "Show memory statistics",
                "path": "plugins/engram-mcp/commands/stats.md",
                "frontmatter": {
                  "description": "Show memory statistics",
                  "allowed-tools": "mcp__plugin_engram-mcp_engram__memory_stats"
                },
                "content": "Use the `mcp__plugin_engram-mcp_engram__memory_stats` MCP tool to show indexed chunk count, memory location, and project info."
              },
              {
                "name": "/sync",
                "description": "Sync memory from current session transcript",
                "path": "plugins/engram-mcp/commands/sync.md",
                "frontmatter": {
                  "description": "Sync memory from current session transcript",
                  "allowed-tools": "mcp__plugin_engram-mcp_engram__memory_sync"
                },
                "content": "Use the `mcp__plugin_engram-mcp_engram__memory_sync` MCP tool to index the current session's conversation."
              }
            ],
            "skills": [
              {
                "name": "using-engram",
                "description": "Use when using the engram MCP server",
                "path": "plugins/engram-mcp/skills/using-engram/SKILL.md",
                "frontmatter": {
                  "name": "using-engram",
                  "description": "Use when using the engram MCP server"
                },
                "content": "# Engram - Semantic Memory\n\nPersistent context across Claude Code sessions.\n\n## MCP Tools\n\nWhen this skill is active, you have access to the `engram` MCP server with these tools:\n\n| Tool | Purpose |\n|------|---------|\n| `memory_search` | Semantic search across past sessions |\n| `memory_resume` | Get context to continue previous work |\n| `memory_remember` | Explicitly save important context |\n| `memory_sync` | Index current session transcript |\n| `memory_stats` | Check what's indexed |\n\n## When to Use\n\n- **Starting a session**: Use `memory_resume` to restore context from previous work\n- **Mid-session**: Use `memory_search` to find relevant past discussions\n- **Key decisions**: Use `memory_remember` to persist important context\n- **Before ending**: Use `memory_sync` to ensure current session is indexed\n\n## Commands\n\nSlash commands are available at `/engram/*`:\n- `/engram/resume` - Resume previous work\n- `/engram/search <query>` - Search memory\n- `/engram/remember <content>` - Save explicitly\n- `/engram/sync` - Index current session\n- `/engram/stats` - Show memory stats"
              }
            ]
          },
          {
            "name": "dev",
            "description": "Development",
            "source": "./plugins/dev",
            "category": "productivity",
            "version": null,
            "author": {
              "name": "Steven Mosley",
              "email": "34114851+astrosteveo@users.noreply.github.com"
            },
            "install_commands": [
              "/plugin marketplace add astrosteveo/marketplace",
              "/plugin install dev@astrosteveo-marketplace"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-12T03:32:51Z",
              "created_at": "2026-01-09T21:25:44Z",
              "license": null
            },
            "commands": [],
            "skills": []
          }
        ]
      }
    }
  ]
}