{
  "owner": {
    "id": "georgeguimaraes",
    "display_name": "George Guimarães",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/2929?v=4",
    "url": "https://github.com/georgeguimaraes",
    "bio": "Previously co-founder @sourcelevel and @plataformatec, the company behind @elixir-lang ",
    "stats": {
      "total_repos": 1,
      "total_plugins": 5,
      "total_commands": 0,
      "total_skills": 6,
      "total_stars": 70,
      "total_forks": 3
    }
  },
  "repos": [
    {
      "full_name": "georgeguimaraes/claude-code-elixir",
      "url": "https://github.com/georgeguimaraes/claude-code-elixir",
      "description": "Claude Code plugin marketplace for Elixir development",
      "homepage": "",
      "signals": {
        "stars": 70,
        "forks": 3,
        "pushed_at": "2026-01-12T12:57:19Z",
        "created_at": "2025-12-26T04:08:18Z",
        "license": "Apache-2.0"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1675
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 108
        },
        {
          "path": "LICENSE",
          "type": "blob",
          "size": 10766
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 6794
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/elixir-lsp",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/elixir-lsp/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/elixir-lsp/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 706
        },
        {
          "path": "plugins/elixir",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/elixir/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/elixir/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 434
        },
        {
          "path": "plugins/elixir/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/elixir/hooks/hooks.json",
          "type": "blob",
          "size": 287
        },
        {
          "path": "plugins/elixir/hooks/run-hook.cmd",
          "type": "blob",
          "size": 493
        },
        {
          "path": "plugins/elixir/hooks/session-start.sh",
          "type": "blob",
          "size": 1256
        },
        {
          "path": "plugins/elixir/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/elixir/skills/ecto-thinking",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/elixir/skills/ecto-thinking/SKILL.md",
          "type": "blob",
          "size": 4849
        },
        {
          "path": "plugins/elixir/skills/elixir-thinking",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/elixir/skills/elixir-thinking/SKILL.md",
          "type": "blob",
          "size": 6030
        },
        {
          "path": "plugins/elixir/skills/oban-thinking",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/elixir/skills/oban-thinking/SKILL.md",
          "type": "blob",
          "size": 8845
        },
        {
          "path": "plugins/elixir/skills/otp-thinking",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/elixir/skills/otp-thinking/SKILL.md",
          "type": "blob",
          "size": 5271
        },
        {
          "path": "plugins/elixir/skills/phoenix-thinking",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/elixir/skills/phoenix-thinking/SKILL.md",
          "type": "blob",
          "size": 4717
        },
        {
          "path": "plugins/elixir/skills/using-elixir-skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/elixir/skills/using-elixir-skills/SKILL.md",
          "type": "blob",
          "size": 2244
        },
        {
          "path": "plugins/mix-compile",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/mix-compile/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/mix-compile/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 345
        },
        {
          "path": "plugins/mix-compile/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/mix-compile/hooks/compile-elixir.sh",
          "type": "blob",
          "size": 943
        },
        {
          "path": "plugins/mix-compile/hooks/hooks.json",
          "type": "blob",
          "size": 297
        },
        {
          "path": "plugins/mix-credo",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/mix-credo/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/mix-credo/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 338
        },
        {
          "path": "plugins/mix-credo/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/mix-credo/hooks/credo-elixir.sh",
          "type": "blob",
          "size": 1082
        },
        {
          "path": "plugins/mix-credo/hooks/hooks.json",
          "type": "blob",
          "size": 295
        },
        {
          "path": "plugins/mix-format",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/mix-format/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/mix-format/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 323
        },
        {
          "path": "plugins/mix-format/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/mix-format/hooks/format-elixir.sh",
          "type": "blob",
          "size": 875
        },
        {
          "path": "plugins/mix-format/hooks/hooks.json",
          "type": "blob",
          "size": 296
        },
        {
          "path": "scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "scripts/fetch_github_wisdom.exs",
          "type": "blob",
          "size": 8154
        }
      ],
      "marketplace": {
        "name": "claude-code-elixir",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "George Guimaraes"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "elixir-lsp",
            "description": "Elixir Language Server integration for go-to-definition, references, and hover docs",
            "source": "./plugins/elixir-lsp",
            "category": "lsp",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add georgeguimaraes/claude-code-elixir",
              "/plugin install elixir-lsp@claude-code-elixir"
            ],
            "signals": {
              "stars": 70,
              "forks": 3,
              "pushed_at": "2026-01-12T12:57:19Z",
              "created_at": "2025-12-26T04:08:18Z",
              "license": "Apache-2.0"
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "elixir",
            "description": "Thinking skills for Elixir, Phoenix, Ecto, OTP, and Oban patterns",
            "source": "./plugins/elixir",
            "category": "skills",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add georgeguimaraes/claude-code-elixir",
              "/plugin install elixir@claude-code-elixir"
            ],
            "signals": {
              "stars": 70,
              "forks": 3,
              "pushed_at": "2026-01-12T12:57:19Z",
              "created_at": "2025-12-26T04:08:18Z",
              "license": "Apache-2.0"
            },
            "commands": [],
            "skills": [
              {
                "name": "ecto-thinking",
                "description": "This skill should be used when the user asks to \"add a database table\", \"create a new context\", \"query the database\", \"add a field to a schema\", \"validate form input\", \"fix N+1 queries\", \"preload this association\", \"separate these concerns\", or mentions Repo, changesets, migrations, Ecto.Multi, has_many, belongs_to, transactions, query composition, or how contexts should talk to each other.",
                "path": "plugins/elixir/skills/ecto-thinking/SKILL.md",
                "frontmatter": {
                  "name": "ecto-thinking",
                  "description": "This skill should be used when the user asks to \"add a database table\", \"create a new context\", \"query the database\", \"add a field to a schema\", \"validate form input\", \"fix N+1 queries\", \"preload this association\", \"separate these concerns\", or mentions Repo, changesets, migrations, Ecto.Multi, has_many, belongs_to, transactions, query composition, or how contexts should talk to each other."
                },
                "content": "# Ecto Thinking\n\nMental shifts for Ecto and data layer design. These insights challenge typical ORM patterns.\n\n## Context = Setting That Changes Meaning\n\nContext isn't just a namespace—it changes what words mean. \"Product\" means different things in Checkout (SKU, name), Billing (SKU, cost), and Fulfillment (SKU, warehouse). Each bounded context may have its OWN Product schema/table.\n\n**Think top-down:** Subdomain → Context → Entity. Not \"What context does Product belong to?\" but \"What is a Product in this business domain?\"\n\n## Cross-Context References: IDs, Not Associations\n\n```elixir\nschema \"cart_items\" do\n  field :product_id, :integer  # Reference by ID\n  # NOT: belongs_to :product, Catalog.Product\nend\n```\n\nQuery through the context, not across associations. Keeps contexts independent and testable.\n\n## DDD Patterns as Pipelines\n\n```elixir\ndef create_product(params) do\n  params\n  |> Products.build()       # Factory: unstructured → domain\n  |> Products.validate()    # Aggregate: enforce invariants\n  |> Products.insert()      # Repository: persist\nend\n```\n\nUse events (as data structs) to compose bounded contexts with minimal coupling.\n\n## Schema ≠ Database Table\n\n| Use Case | Approach |\n|----------|----------|\n| Database table | Standard `schema/2` |\n| Form validation only | `embedded_schema/1` |\n| API request/response | Embedded schema or schemaless |\n\n## Multiple Changesets per Schema\n\n```elixir\ndef registration_changeset(user, attrs)  # Full validation + password\ndef profile_changeset(user, attrs)       # Name, bio only\ndef admin_changeset(user, attrs)         # Role, verified_at\n```\n\nDifferent operations = different changesets.\n\n## Multi-Tenancy: Composite Foreign Keys\n\n```elixir\nadd :post_id, references(:posts, with: [org_id: :org_id], match: :full)\n```\n\nUse `prepare_query/3` for automatic scoping. Raise if `org_id` missing.\n\n## Preload vs Join Trade-offs\n\n| Approach | Best For |\n|----------|----------|\n| Separate preloads | Has-many with many records (less memory) |\n| Join preloads | Belongs-to, has-one (single query) |\n\nJoin preloads can use 10x more memory for has-many.\n\n## CRUD Contexts Are Fine\n\n> \"If you have a CRUD bounded context, go for it. No need to add complexity.\"\n\nUse generators for simple cases. Add DDD patterns only when business logic demands it.\n\n## Gotchas from Core Team\n\n### CTE Queries Don't Inherit Schema Prefix\n\nIn multi-tenant apps, CTEs don't get the parent query's prefix.\n\n**Fix:** Explicitly set prefix: `%{recursive_query | prefix: \"tenant\"}`\n\n### Parameterized Queries ≠ Prepared Statements\n\n- **Parameterized queries:** `WHERE id = $1` — always used by Ecto\n- **Prepared statements:** Query plan cached by name — can be disabled\n\n**pgbouncer:** Use `prepare: :unnamed` (disables prepared statements, keeps parameterized queries).\n\n### pool_count vs pool_size\n\nMore pools with fewer connections = better for benchmarks. **But** with mixed fast/slow queries, a single larger pool gives better latency.\n\n**Rule:** `pool_count` for uniform workloads, larger `pool_size` for real apps.\n\n### Sandbox Mode Doesn't Work With External Processes\n\nCachex, separate GenServers, or anything outside the test process won't share the sandbox transaction.\n\n**Fix:** Make the external service use the test process, or accept it's not in the same transaction.\n\n### Null Bytes Crash Postgres\n\nPostgreSQL rejects null bytes even though they're valid UTF-8.\n\n**Fix:** Sanitize at boundaries: `String.replace(string, \"\\x00\", \"\")`\n\n### preload_order for Association Sorting\n\n```elixir\nhas_many :comments, Comment, preload_order: [desc: :inserted_at]\n```\n\nNote: Doesn't work for `through` associations.\n\n### Runtime Migrations Use List API\n\n```elixir\nEcto.Migrator.run(Repo, [{0, Migration1}, {1, Migration2}], :up, opts)\n```\n\n## Idioms\n\n- Prefer `Repo.insert/1` over `Repo.insert!/1`—handle `{:ok, _}` / `{:error, _}` explicitly\n- Use `Repo.transact/1` (Ecto 3.12+) for simple transactions instead of `Ecto.Multi`\n\n## Red Flags - STOP and Reconsider\n\n- belongs_to pointing to another context's schema\n- Single changeset for all operations\n- Preloading has-many with join\n- CTEs in multi-tenant apps without explicit prefix\n- Using pgbouncer without `prepare: :unnamed`\n- Testing with Cachex/GenServers assuming sandbox shares transactions\n- Accepting user input without null byte sanitization\n\n**Any of these? Re-read the Gotchas section.**"
              },
              {
                "name": "elixir-thinking",
                "description": "This skill should be used when the user asks to \"implement a feature in Elixir\", \"refactor this module\", \"should I use a GenServer here?\", \"how should I structure this?\", \"use the pipe operator\", \"add error handling\", \"make this concurrent\", or mentions protocols, behaviours, pattern matching, with statements, comprehensions, structs, or coming from an OOP background. Contains paradigm-shifting insights.",
                "path": "plugins/elixir/skills/elixir-thinking/SKILL.md",
                "frontmatter": {
                  "name": "elixir-thinking",
                  "description": "This skill should be used when the user asks to \"implement a feature in Elixir\", \"refactor this module\", \"should I use a GenServer here?\", \"how should I structure this?\", \"use the pipe operator\", \"add error handling\", \"make this concurrent\", or mentions protocols, behaviours, pattern matching, with statements, comprehensions, structs, or coming from an OOP background. Contains paradigm-shifting insights."
                },
                "content": "# Elixir Thinking\n\nMental shifts required before writing Elixir. These contradict conventional OOP patterns.\n\n## The Iron Law\n\n```\nNO PROCESS WITHOUT A RUNTIME REASON\n```\n\nBefore creating a GenServer, Agent, or any process, answer YES to at least one:\n1. Do I need mutable state persisting across calls?\n2. Do I need concurrent execution?\n3. Do I need fault isolation?\n\n**All three are NO?** Use plain functions. Modules organize code; processes manage runtime.\n\n## The Three Decoupled Dimensions\n\nOOP couples behavior, state, and mutability together. Elixir decouples them:\n\n| OOP Dimension | Elixir Equivalent |\n|---------------|-------------------|\n| Behavior | Modules (functions) |\n| State | Data (structs, maps) |\n| Mutability | Processes (GenServer) |\n\nPick only what you need. \"I only need data and functions\" = no process needed.\n\n## \"Let It Crash\" = \"Let It Heal\"\n\nThe misconception: Write careless code.\nThe truth: Supervisors START processes.\n\n- Handle expected errors explicitly (`{:ok, _}` / `{:error, _}`)\n- Let unexpected errors crash → supervisor restarts\n\n## Control Flow\n\n**Pattern matching first:**\n- Match on function heads instead of `if/else` or `case` in bodies\n- `%{}` matches ANY map—use `map_size(map) == 0` guard for empty maps\n- Avoid nested `case`—refactor to single `case`, `with`, or separate functions\n\n**Error handling:**\n- Use `{:ok, result}` / `{:error, reason}` for operations that can fail\n- Avoid raising exceptions for control flow\n- Use `with` for chaining `{:ok, _}` / `{:error, _}` operations\n\n**Be explicit about expected cases:**\n- Avoid `_ -> nil` catch-alls—they silently swallow unexpected cases\n- Avoid `value && value.field` nil-punning—obscures actual return types\n- When a case has `{:ok, nil} -> nil` alongside `{:ok, value} -> value.field`, use `with` instead:\n\n```elixir\n# Verbose\ncase get_run(id) do\n  {:ok, nil} -> nil\n  {:ok, run} -> run.recommendations\nend\n\n# Prefer\nwith {:ok, %{recommendations: recs}} <- get_run(id), do: recs\n```\n\n## Polymorphism\n\n| For Polymorphism Over... | Use | Contract |\n|--------------------------|-----|----------|\n| Modules | Behaviors | Upfront callbacks |\n| Data | Protocols | Upfront implementations |\n| Processes | Message passing | Implicit (send/receive) |\n\n**Behaviors** = default for module polymorphism (very cheap at runtime)\n**Protocols** = only when composing data types, especially built-ins\n**Message passing** = only when stateful by design (IO, file handles)\n\nUse the simplest abstraction: pattern matching → anonymous functions → behaviors → protocols → message passing. Each step adds complexity.\n\n**When justified:** Library extensibility, multiple implementations, test swapping.\n**When to stay coupled:** Internal module, single implementation, pattern matching handles all cases.\n\n## Data Modeling Replaces Class Hierarchies\n\nOOP: Complex class hierarchy + visitor pattern.\nElixir: Model as data + pattern matching + recursion.\n\n```elixir\n{:sequence, {:literal, \"rain\"}, {:repeat, {:alternation, \"dogs\", \"cats\"}}}\n\ndef interpret({:literal, text}, input), do: ...\ndef interpret({:sequence, left, right}, input), do: ...\ndef interpret({:repeat, pattern}, input), do: ...\n```\n\n## Defaults and Options\n\nUse `/3` variants (`Keyword.get/3`, `Map.get/3`) instead of case statements branching on `nil`:\n\n```elixir\n# WRONG\ncase Keyword.get(opts, :chunker) do\n  nil -> chunker()\n  config -> parse_chunker_config(config)\nend\n\n# RIGHT\nKeyword.get(opts, :chunker, :default) |> parse_chunker_config()\n```\n\nDon't create helper functions to merge config defaults. Inline the fallback:\n\n```elixir\n# WRONG\ndefp merge_defaults(opts), do: Keyword.merge([repo: Application.get_env(:app, :repo)], opts)\n\n# RIGHT\ndef some_function(opts) do\n  repo = opts[:repo] || Application.get_env(:app, :repo)\nend\n```\n\n## Idioms\n\n- Process dictionary is typically unidiomatic—pass state explicitly\n- Reserve `is_thing` names for guards only\n- Use structs over maps when shape is known: `defstruct [:name, :age]`\n- Prepend to lists `[new | list]` not `list ++ [new]`\n- Use `dbg/1` for debugging—prints formatted value with context\n- Use built-in `JSON` module (Elixir 1.18+) instead of Jason\n\n## Testing\n\n**Test behavior, not implementation.** Test use cases / public API. Refactoring shouldn't break tests.\n\n**Test your code, not the framework.** If deleting your code doesn't fail the test, it's tautological.\n\n**Keep tests async.** `async: false` means you've coupled to global state. Fix the coupling:\n\n| Problem | Solution |\n|---------|----------|\n| `Application.put_env` | Pass config as function argument |\n| Feature flags | Inject via process dictionary or context |\n| ETS tables | Create per-test tables with unique names |\n| External APIs | Use Mox with explicit allowances |\n\n## Common Rationalizations\n\n| Excuse | Reality |\n|--------|---------|\n| \"I need a process to organize this code\" | Modules organize code. Processes are for runtime. |\n| \"GenServer is the Elixir way\" | Plain functions are also the Elixir way. |\n| \"I'll need state eventually\" | YAGNI. Add process when you need it. |\n| \"It's just a simple wrapper process\" | Simple wrappers become bottlenecks. |\n| \"This is how I'd structure it in OOP\" | Rethink from data flow. |\n\n## Red Flags - STOP and Reconsider\n\n- Creating process without answering the three questions\n- Using GenServer for stateless operations\n- Wrapping a library in a process \"for safety\"\n- One process per entity without runtime justification\n- Reaching for protocols when pattern matching works\n\n**Any of these? Re-read The Iron Law.**"
              },
              {
                "name": "oban-thinking",
                "description": "This skill should be used when the user asks to \"add a background job\", \"process async\", \"schedule a task\", \"retry failed jobs\", \"add email sending\", \"run this later\", \"add a cron job\", \"unique jobs\", \"batch process\", or mentions Oban, Oban Pro, workflows, job queues, cascades, grafting, recorded values, job args, or troubleshooting job failures.",
                "path": "plugins/elixir/skills/oban-thinking/SKILL.md",
                "frontmatter": {
                  "name": "oban-thinking",
                  "description": "This skill should be used when the user asks to \"add a background job\", \"process async\", \"schedule a task\", \"retry failed jobs\", \"add email sending\", \"run this later\", \"add a cron job\", \"unique jobs\", \"batch process\", or mentions Oban, Oban Pro, workflows, job queues, cascades, grafting, recorded values, job args, or troubleshooting job failures."
                },
                "content": "# Oban Thinking\n\nParadigm shifts for Oban job processing. These insights prevent common bugs and guide proper patterns.\n\n---\n\n# Part 1: Oban (Non-Pro)\n\n## The Iron Law: JSON Serialization\n\n```\nJOB ARGS ARE JSON. ATOMS BECOME STRINGS.\n```\n\nThis single fact causes most Oban debugging headaches.\n\n```elixir\n# Creating - atom keys are fine\nMyWorker.new(%{user_id: 123})\n\n# Processing - must use string keys (JSON converted atoms to strings)\ndef perform(%Oban.Job{args: %{\"user_id\" => user_id}}) do\n  # ...\nend\n```\n\n## Error Handling: Let It Crash\n\n**Don't catch errors in Oban jobs.** Let them bubble up to Oban for proper handling.\n\n### Why?\n\n1. **Automatic logging**: Oban logs the full error with stacktrace\n2. **Automatic retries**: Jobs retry with exponential backoff\n3. **Visibility**: Failed jobs appear in Oban Web dashboard\n4. **Consistency**: Error states are tracked in the database\n\n### Anti-Pattern\n\n```elixir\n# Bad: Swallowing errors\ndef perform(%Oban.Job{} = job) do\n  case do_work(job.args) do\n    {:ok, result} -> {:ok, result}\n    {:error, reason} ->\n      Logger.error(\"Failed: #{reason}\")\n      {:ok, :failed}  # Silently marks as complete!\n  end\nend\n```\n\n### Correct Pattern\n\n```elixir\n# Good: Let errors propagate\ndef perform(%Oban.Job{} = job) do\n  result = do_work!(job.args)  # Raises on failure\n  {:ok, result}\nend\n\n# Or return error tuple - Oban treats as failure\ndef perform(%Oban.Job{} = job) do\n  case do_work(job.args) do\n    {:ok, result} -> {:ok, result}\n    {:error, reason} -> {:error, reason}  # Oban will retry\n  end\nend\n```\n\n### When to Catch Errors\n\nOnly catch errors when you need custom retry logic or want to mark a job as permanently failed:\n\n```elixir\ndef perform(%Oban.Job{} = job) do\n  case external_api_call(job.args) do\n    {:ok, result} -> {:ok, result}\n    {:error, :not_found} -> {:cancel, :resource_not_found}  # Don't retry\n    {:error, :rate_limited} -> {:snooze, 60}  # Retry in 60 seconds\n    {:error, _} -> {:error, :will_retry}  # Normal retry\n  end\nend\n```\n\n## Snoozing for Polling\n\nUse `{:snooze, seconds}` for polling external state instead of manual retry logic:\n\n```elixir\ndef perform(%Oban.Job{} = job) do\n  if external_thing_finished?(job.args) do\n    {:ok, :done}\n  else\n    {:snooze, 5}  # Check again in 5 seconds\n  end\nend\n```\n\n## Simple Job Chaining\n\nFor simple sequential chains (JobA → JobB → JobC), have each job enqueue the next:\n\n```elixir\ndef perform(%Oban.Job{} = job) do\n  result = do_work(job.args)\n  # Enqueue next job on success\n  NextWorker.new(%{data: result}) |> Oban.insert()\n  {:ok, result}\nend\n```\n\n**Don't reach for Oban Pro Workflows for linear chains.**\n\n## Unique Jobs\n\nPrevent duplicate jobs with the `unique` option:\n\n```elixir\nuse Oban.Worker,\n  queue: :default,\n  unique: [period: 60]  # Only one job with same args per 60 seconds\n\n# Or scope uniqueness to specific fields\nunique: [period: 300, keys: [:user_id]]\n```\n\n**Gotcha:** Uniqueness is checked on insert, not execution. Two identical jobs inserted 61 seconds apart will both run.\n\n## High Throughput: Chunking\n\nFor millions of records, **chunk work into batches** rather than one job per item:\n\n```elixir\n# Bad: One job per contact (millions of jobs = database strain)\nEnum.each(contacts, &ContactWorker.new(%{id: &1.id}) |> Oban.insert())\n\n# Good: Chunk into batches\ncontacts\n|> Enum.chunk_every(100)\n|> Enum.each(&BatchWorker.new(%{contact_ids: Enum.map(&1, fn c -> c.id end)}) |> Oban.insert())\n```\n\nUse bulk inserts without uniqueness constraints for maximum throughput.\n\n---\n\n# Part 2: Oban Pro\n\n## Cascade Context: Erlang Term Serialization\n\nUnlike regular job args, **cascade context preserves atoms**:\n\n```elixir\n# Creating - atom keys\nWorkflow.put_context(%{score_run_id: id})\n\n# Processing - atom keys still work!\ndef my_cascade(%{score_run_id: id}) do\n  # ...\nend\n\n# Dot notation works too\ndef later_step(context) do\n  context.score_run_id\n  context.previous_result\nend\n```\n\n### Serialization Summary\n\n| | Creating | Processing |\n|-----------------|----------|--------------|\n| Regular jobs | atoms ok | strings only |\n| Cascade context | atoms ok | atoms ok |\n\n## When to Use Workflows\n\nReserve Workflows for:\n- Complex dependency graphs (not just linear chains)\n- Fan-out/fan-in patterns\n- When you need recorded values across steps\n- Conditional branching based on runtime state\n\n**Don't use Workflows for simple A → B → C chains.**\n\n## Workflow Composition with Graft\n\nWhen you need a parent workflow to wait for a sub-workflow to complete before continuing, use `add_graft` instead of `add_workflow`.\n\n### Key Differences\n\n| Method | Sub-workflow completes before deps run? | Output accessible? |\n|--------|----------------------------------------|-------------------|\n| `add_workflow` | No - just inserts jobs | No |\n| `add_graft` | Yes - waits for all jobs | Yes, via recorded values |\n\n### Pattern: Composing Independent Concerns\n\nDon't couple unrelated concerns (e.g., notifications) to domain-specific workflows (e.g., scoring). Instead, create a higher-level orchestrator:\n\n```elixir\n# Bad: Notification logic buried in AggregateScores\ndefmodule AggregateScores do\n  def workflow(score_run_id) do\n    Workflow.new()\n    |> Workflow.add(:aggregate, AggregateJob.new(...))\n    |> Workflow.add(:send_notification, SendEmail.new(...), deps: :aggregate)  # Wrong place!\n  end\nend\n\n# Good: Higher-level workflow composes scoring + notification\ndefmodule FullRunWithNotifications do\n  def workflow(site_url, opts) do\n    notification_opts = build_notification_opts(opts)\n\n    Workflow.new()\n    |> Workflow.put_context(%{notification_opts: notification_opts})\n    |> Workflow.add_graft(:scoring, &graft_full_run/1)\n    |> Workflow.add_cascade(:send_notification, &send_notification/1, deps: :scoring)\n  end\n\n  defp graft_full_run(context) do\n    # Sub-workflow doesn't know about notifications\n    FullRun.workflow(context.site_url, context.opts)\n    |> Workflow.apply_graft()\n    |> Oban.insert_all()\n  end\nend\n```\n\n### Recording Values for Dependent Steps\n\nFor a grafted workflow's output to be available to dependent steps, the final job must use `recorded: true`:\n\n```elixir\ndefmodule FinalJob do\n  use Oban.Pro.Worker, queue: :default, recorded: true\n\n  def perform(%Oban.Job{} = job) do\n    # Return value becomes available in context\n    {:ok, %{score_run_id: score_run_id, composite_score: score}}\n  end\nend\n```\n\n## Dynamic Workflow Appending\n\nAdd jobs to a running workflow with `Workflow.append/2`:\n\n```elixir\ndef perform(%Oban.Job{} = job) do\n  if needs_extra_step?(job.args) do\n    job\n    |> Workflow.append()\n    |> Workflow.add(:extra, ExtraWorker.new(%{}), deps: [:current_step])\n    |> Oban.insert_all()\n  end\n  {:ok, :done}\nend\n```\n\n**Caveat:** Cannot override context or add dependencies to already-running jobs. For complex dynamic scenarios, check external state in the job itself.\n\n## Fan-Out/Fan-In with Batches\n\nTo run a final job after multiple paginated workflows complete, use Batch callbacks:\n\n```elixir\n# Wrap workflows in a shared batch\nbatch_id = \"import-#{import_id}\"\n\npages\n|> Enum.each(fn page ->\n  PageWorkflow.workflow(page)\n  |> Batch.from_workflow(batch_id: batch_id)\n  |> Oban.insert_all()\nend)\n\n# Add completion callback\nBatch.new(batch_id: batch_id)\n|> Batch.add_callback(:completed, CompletionWorker)\n|> Oban.insert()\n```\n\n**Tip:** Include pagination workers in the batch to prevent premature completion.\n\n## Testing Workflows\n\n**Don't use inline testing mode** - workflows need database interaction.\n\n```elixir\n# Use run_workflow/1 for integration tests\nassert %{completed: 3} =\n  Workflow.new()\n  |> Workflow.add(:a, WorkerA.new(%{}))\n  |> Workflow.add(:b, WorkerB.new(%{}), deps: [:a])\n  |> Workflow.add(:c, WorkerC.new(%{}), deps: [:b])\n  |> run_workflow()\n```\n\nFor testing recorded values between workers, insert predecessor jobs with pre-filled metadata.\n\n---\n\n# Red Flags - STOP and Reconsider\n\n**Non-Pro:**\n- Pattern matching on atom keys in `perform/1`\n- Catching all errors and returning `{:ok, _}`\n- Wrapping job logic in try/rescue\n- Creating one job per item when processing millions of records\n\n**Pro:**\n- Using `add_workflow` when you need to wait for completion\n- Coupling notifications/emails to domain workflows\n- Not using `recorded: true` when you need output from grafted workflows\n- Using Workflows for simple linear job chains\n- Testing workflows with inline mode\n\n**Any of these? Re-read the serialization rules.**"
              },
              {
                "name": "otp-thinking",
                "description": "This skill should be used when the user asks to \"add background processing\", \"cache this data\", \"run this async\", \"handle concurrent requests\", \"manage state across requests\", \"process jobs from a queue\", \"this GenServer is slow\", or mentions GenServer, Supervisor, Agent, Task, Registry, DynamicSupervisor, handle_call, handle_cast, supervision trees, fault tolerance, \"let it crash\", or choosing between Broadway and Oban.",
                "path": "plugins/elixir/skills/otp-thinking/SKILL.md",
                "frontmatter": {
                  "name": "otp-thinking",
                  "description": "This skill should be used when the user asks to \"add background processing\", \"cache this data\", \"run this async\", \"handle concurrent requests\", \"manage state across requests\", \"process jobs from a queue\", \"this GenServer is slow\", or mentions GenServer, Supervisor, Agent, Task, Registry, DynamicSupervisor, handle_call, handle_cast, supervision trees, fault tolerance, \"let it crash\", or choosing between Broadway and Oban."
                },
                "content": "# OTP Thinking\n\nParadigm shifts for OTP design. These insights challenge typical concurrency and state management patterns.\n\n## The Iron Law\n\n```\nGENSERVER IS A BOTTLENECK BY DESIGN\n```\n\nA GenServer processes ONE message at a time. Before creating one, ask:\n1. Do I actually need serialized access?\n2. Will this become a throughput bottleneck?\n3. Can reads bypass the GenServer via ETS?\n\n**The ETS pattern:** GenServer owns ETS table, writes serialize through GenServer, reads bypass it entirely with `:read_concurrency`.\n\n**No exceptions:** Don't wrap stateless functions in GenServer. Don't create GenServer \"for organization\".\n\n## GenServer Patterns\n\n| Function | Use For |\n|----------|---------|\n| `call/3` | Synchronous requests expecting replies |\n| `cast/2` | Fire-and-forget messages |\n\n**When in doubt, use `call`** to ensure back-pressure. Set appropriate timeouts for `call/3`.\n\nUse `handle_continue/2` for post-init work—keeps `init/1` fast and non-blocking.\n\n## Task.Supervisor, Not Task.async\n\n`Task.async` spawns a **linked** process—if task crashes, caller crashes too.\n\n| Pattern | On task crash |\n|---------|---------------|\n| `Task.async/1` | Caller crashes (linked, unsupervised) |\n| `Task.Supervisor.async/2` | Caller crashes (linked, supervised) |\n| `Task.Supervisor.async_nolink/2` | Caller survives, can handle error |\n\n**Use Task.Supervisor for:** Production code, graceful shutdown, observability, `async_nolink`.\n**Use Task.async for:** Quick experiments, scripts, when crash-together is acceptable.\n\n## DynamicSupervisor + Registry = Named Dynamic Processes\n\nDynamicSupervisor only supports `:one_for_one` (dynamic children have no ordering). Use Registry for names—never create atoms dynamically:\n\n```elixir\ndefp via_tuple(id), do: {:via, Registry, {MyApp.Registry, id}}\n```\n\n**PartitionSupervisor** scales DynamicSupervisor for millions of children.\n\n## :pg for Distributed, Registry for Local\n\n| Tool | Scope | Use Case |\n|------|-------|----------|\n| Registry | Single node | Named dynamic processes |\n| :pg | Cluster-wide | Process groups, pub/sub |\n\n`:pg` replaced deprecated `:pg2`. **Horde** provides distributed supervisor/registry with CRDTs.\n\n## Broadway vs Oban: Different Problems\n\n| Tool | Use For |\n|------|---------|\n| Broadway | External queues (SQS, Kafka, RabbitMQ) — data ingestion with batching |\n| Oban | Background jobs with database persistence |\n\nBroadway is NOT a job queue.\n\n### Broadway Gotchas\n\n**Processors are for runtime, not code organization.** Dispatch to modules in `handle_message`, don't add processors for different message types.\n\n**one_for_all is for Broadway bugs, not your code.** Your `handle_message` errors are caught and result in failed messages, not supervisor restarts.\n\n**Handle expected failures in the producer** (connection loss, rate limits). Reserve max_restarts for unexpected bugs.\n\n## Supervision Strategies Encode Dependencies\n\n| Strategy | Children Relationship |\n|----------|----------------------|\n| :one_for_one | Independent |\n| :one_for_all | Interdependent (all restart) |\n| :rest_for_one | Sequential dependency |\n\nUse `:max_restarts` and `:max_seconds` to prevent restart loops.\n\nThink about failure cascades BEFORE coding.\n\n## Abstraction Decision Tree\n\n```\nNeed state?\n├── No → Plain function\n└── Yes → Complex behavior?\n    ├── No → Agent\n    └── Yes → Supervision?\n        ├── No → spawn_link\n        └── Yes → Request/response?\n            ├── No → Task.Supervisor\n            └── Yes → Explicit states?\n                ├── No → GenServer\n                └── Yes → GenStateMachine\n```\n\n## Storage Options\n\n| Need | Use |\n|------|-----|\n| Memory cache | ETS (`:read_concurrency` for reads) |\n| Static config | :persistent_term (faster than ETS) |\n| Disk persistence | DETS (2GB limit) |\n| Transactions/Distribution | Mnesia |\n\n## :sys Debugs ANY OTP Process\n\n```elixir\n:sys.get_state(pid)        # Current state\n:sys.trace(pid, true)      # Trace events (TURN OFF when done!)\n```\n\n## Telemetry Is Built Into Everything\n\nPhoenix, Ecto, and most libraries emit telemetry events. Attach handlers:\n\n```elixir\n:telemetry.attach(\"my-handler\", [:phoenix, :endpoint, :stop], &handle/4, nil)\n```\n\nUse `Telemetry.Metrics` + reporters (StatsD, Prometheus, LiveDashboard).\n\n## Red Flags - STOP and Reconsider\n\n- GenServer wrapping stateless computation\n- Task.async in production when you need error handling\n- Creating atoms dynamically for process names\n- Single GenServer becoming throughput bottleneck\n- Using Broadway for background jobs (use Oban)\n- Using Oban for external queue consumption (use Broadway)\n- No supervision strategy reasoning\n\n**Any of these? Re-read The Iron Law and use the Abstraction Decision Tree.**"
              },
              {
                "name": "phoenix-thinking",
                "description": "This skill should be used when the user asks to \"add a LiveView page\", \"create a form\", \"handle real-time updates\", \"broadcast changes to users\", \"add a new route\", \"create an API endpoint\", \"fix this LiveView bug\", \"why is mount called twice?\", or mentions handle_event, handle_info, handle_params, mount, channels, controllers, components, assigns, sockets, or PubSub. Essential for avoiding duplicate queries in mount.",
                "path": "plugins/elixir/skills/phoenix-thinking/SKILL.md",
                "frontmatter": {
                  "name": "phoenix-thinking",
                  "description": "This skill should be used when the user asks to \"add a LiveView page\", \"create a form\", \"handle real-time updates\", \"broadcast changes to users\", \"add a new route\", \"create an API endpoint\", \"fix this LiveView bug\", \"why is mount called twice?\", or mentions handle_event, handle_info, handle_params, mount, channels, controllers, components, assigns, sockets, or PubSub. Essential for avoiding duplicate queries in mount."
                },
                "content": "# Phoenix Thinking\n\nMental shifts for Phoenix applications. These insights challenge typical web framework patterns.\n\n## The Iron Law\n\n```\nNO DATABASE QUERIES IN MOUNT\n```\n\nmount/3 is called TWICE (HTTP request + WebSocket connection). Queries in mount = duplicate queries.\n\n```elixir\ndef mount(_params, _session, socket) do\n  # NO database queries here! Called twice.\n  {:ok, assign(socket, posts: [], loading: true)}\nend\n\ndef handle_params(params, _uri, socket) do\n  # Database queries here - once per navigation\n  posts = Blog.list_posts(socket.assigns.scope)\n  {:noreply, assign(socket, posts: posts, loading: false)}\nend\n```\n\n**mount/3** = setup only (empty assigns, subscriptions, defaults)\n**handle_params/3** = data loading (all database queries, URL-driven state)\n\n**No exceptions:** Don't query \"just this one small thing\" in mount. Don't \"optimize later\". LiveView lifecycle is non-negotiable.\n\n## Scopes: Security-First Pattern (Phoenix 1.8+)\n\nScopes address OWASP #1 vulnerability: Broken Access Control. Authorization context is threaded automatically—no more forgetting to scope queries.\n\n```elixir\ndef list_posts(%Scope{user: user}) do\n  Post |> where(user_id: ^user.id) |> Repo.all()\nend\n```\n\n## PubSub Topics Must Be Scoped\n\n```elixir\ndef subscribe(%Scope{organization: org}) do\n  Phoenix.PubSub.subscribe(@pubsub, \"posts:org:#{org.id}\")\nend\n```\n\nUnscoped topics = data leaks between tenants.\n\n## External Polling: GenServer, Not LiveView\n\n**Bad:** Every connected user makes API calls (multiplied by users).\n**Good:** Single GenServer polls, broadcasts to all via PubSub.\n\n## Components Receive Data, LiveViews Own Data\n\n- **Functional components:** Display-only, no internal state\n- **LiveComponents:** Own state, handle own events\n- **LiveViews:** Full page, owns URL, top-level state\n\n## Async Data Loading\n\nUse `assign_async/3` for data that can load after mount:\n\n```elixir\ndef mount(_params, _session, socket) do\n  {:ok, assign_async(socket, :user, fn -> {:ok, %{user: fetch_user()}} end)}\nend\n```\n\n## Gotchas from Core Team\n\n### LiveView terminate/2 Requires trap_exit\n\n`terminate/2` only fires if you're trapping exits—which you shouldn't do in LiveView.\n\n**Fix:** Use a separate GenServer that monitors the LiveView process via `Process.monitor/1`, then handle `:DOWN` messages to run cleanup.\n\n### start_async Duplicate Names: Later Wins\n\nCalling `start_async` with the same name while a task is in-flight: the **later one wins**, the previous task's result is ignored.\n\n**Fix:** Call `cancel_async/3` first if you want to abort the previous task.\n\n### Channel Intercept Socket State is Stale\n\nThe socket in `handle_out` intercept is a snapshot from subscription time, not current state.\n\n**Why:** Socket is copied into fastlane lookup at subscription time for performance.\n\n**Fix:** Use separate topics per role, or fetch current state explicitly.\n\n### CSS Class Precedence is Stylesheet Order\n\nWhen merging classes on components, precedence is determined by **stylesheet order**, not HTML order. If `btn-primary` appears later in the compiled CSS than `bg-red-500`, it wins regardless of HTML order.\n\n**Fix:** Use variant props instead of class merging.\n\n### Upload Content-Type Can't Be Trusted\n\nThe `:content_type` in `%Plug.Upload{}` is user-provided. Always validate actual file contents (magic bytes) and rewrite filename/extension.\n\n### Read Body Before Plug.Parsers for Webhooks\n\nTo verify webhook signatures, you need the raw body. But Plug.Parsers consumes it.\n\n```elixir\n{:ok, body, conn} = Plug.Conn.read_body(conn)\nverify_signature!(conn, body)\n%{conn | body_params: JSON.decode!(body)}\n```\n\nDon't use `preserve_req_body: true`—it keeps the entire body in memory for ALL requests.\n\n## Red Flags - STOP and Reconsider\n\n- Database query in mount/3\n- Unscoped PubSub topics in multi-tenant app\n- LiveView polling external APIs directly\n- Using terminate/2 for cleanup (won't fire without trap_exit)\n- Calling start_async with same name without cancel_async first\n- Relying on socket.assigns in Channel intercepts (stale!)\n- CSS class merging for component customization (use variants)\n- Trusting `%Plug.Upload{}.content_type` for security\n\n**Any of these? Re-read The Iron Law and the Gotchas section.**"
              },
              {
                "name": "using-elixir-skills",
                "description": "This skill should be used when the user works on any .ex or .exs file, mentions Elixir/Phoenix/Ecto/OTP, the project has a mix.exs, or asks \"which skill should I use\", \"new to Elixir\", \"help with Elixir\". Routes to the correct thinking skill BEFORE exploring code. Triggers on \"implement\", \"add\", \"fix\", \"refactor\" in Elixir projects.",
                "path": "plugins/elixir/skills/using-elixir-skills/SKILL.md",
                "frontmatter": {
                  "name": "using-elixir-skills",
                  "description": "This skill should be used when the user works on any .ex or .exs file, mentions Elixir/Phoenix/Ecto/OTP, the project has a mix.exs, or asks \"which skill should I use\", \"new to Elixir\", \"help with Elixir\". Routes to the correct thinking skill BEFORE exploring code. Triggers on \"implement\", \"add\", \"fix\", \"refactor\" in Elixir projects."
                },
                "content": "<EXTREMELY-IMPORTANT>\nIf the task involves Elixir, Phoenix, or OTP code, you MUST invoke the relevant skill BEFORE doing ANYTHING else—including exploring the codebase.\n\nTHIS IS NOT OPTIONAL. Skills tell you HOW to explore and WHAT to look for. You cannot rationalize your way out of this.\n</EXTREMELY-IMPORTANT>\n\n## The Rule\n\n```\nElixir/Phoenix/OTP task → Invoke skill FIRST → Then explore/research → Then write code\n```\n\n**Skills come before exploration.** The skills tell you what patterns to look for, what questions to ask, and what anti-patterns to avoid. Exploring without the skill means you don't know what you're looking for.\n\n## Skill Triggers\n\n| Trigger Phrases | Skill to Invoke |\n|-----------------|-----------------|\n| code, implement, write, design, architecture, structure, pattern | `elixir-thinking` |\n| LiveView, Plug, PubSub, mount, channel, socket, component | `phoenix-thinking` |\n| context, schema, Ecto, changeset, preload, Repo, migration | `ecto-thinking` |\n| GenServer, supervisor, Task, ETS, bottleneck, Broadway | `otp-thinking` |\n| Oban, workflow, job queue, cascade, graft, background job, async job | `oban-thinking` |\n\n## Red Flags\n\nThese thoughts mean STOP—invoke the skill:\n\n| Thought | Reality |\n|---------|---------|\n| \"Let me explore the codebase first\" | Skills tell you WHAT to look for. Invoke first. |\n| \"Let me understand the code first\" | Skills guide understanding. Invoke first. |\n| \"But first, let me...\" | No. Skills come first. Always. |\n| \"I'll add a process to organize this\" | Processes are for runtime, not organization. |\n| \"GenServer is the Elixir way\" | GenServer is a bottleneck by design. |\n| \"I'll query in mount\" | mount is called twice. |\n| \"Task.async is simpler\" | Use Task.Supervisor in production. |\n| \"I know Elixir well enough\" | These skills contain paradigm shifts. Invoke them. |"
              }
            ]
          },
          {
            "name": "mix-compile",
            "description": "Auto-compile Elixir files with warnings-as-errors after edits",
            "source": "./plugins/mix-compile",
            "category": "hooks",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add georgeguimaraes/claude-code-elixir",
              "/plugin install mix-compile@claude-code-elixir"
            ],
            "signals": {
              "stars": 70,
              "forks": 3,
              "pushed_at": "2026-01-12T12:57:19Z",
              "created_at": "2025-12-26T04:08:18Z",
              "license": "Apache-2.0"
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "mix-format",
            "description": "Auto-format Elixir files with mix format after edits",
            "source": "./plugins/mix-format",
            "category": "hooks",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add georgeguimaraes/claude-code-elixir",
              "/plugin install mix-format@claude-code-elixir"
            ],
            "signals": {
              "stars": 70,
              "forks": 3,
              "pushed_at": "2026-01-12T12:57:19Z",
              "created_at": "2025-12-26T04:08:18Z",
              "license": "Apache-2.0"
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "mix-credo",
            "description": "Run Credo static analysis after editing Elixir files",
            "source": "./plugins/mix-credo",
            "category": "hooks",
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add georgeguimaraes/claude-code-elixir",
              "/plugin install mix-credo@claude-code-elixir"
            ],
            "signals": {
              "stars": 70,
              "forks": 3,
              "pushed_at": "2026-01-12T12:57:19Z",
              "created_at": "2025-12-26T04:08:18Z",
              "license": "Apache-2.0"
            },
            "commands": [],
            "skills": []
          }
        ]
      }
    }
  ]
}