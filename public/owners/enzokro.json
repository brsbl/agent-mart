{
  "owner": {
    "id": "enzokro",
    "display_name": "Chris Kroenke",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/59216188?v=4",
    "url": "https://github.com/enzokro",
    "bio": "\r\n    ML Engineer in NYC\r\n",
    "stats": {
      "total_repos": 1,
      "total_plugins": 1,
      "total_commands": 8,
      "total_skills": 1,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "enzokro/crinzo-plugins",
      "url": "https://github.com/enzokro/crinzo-plugins",
      "description": "A Claude Code orchestrator for clean, focused development",
      "homepage": "",
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-12T04:41:20Z",
        "created_at": "2025-12-21T21:42:56Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 307
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 409
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 9069
        },
        {
          "path": "ftl",
          "type": "tree",
          "size": null
        },
        {
          "path": "ftl/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "ftl/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 3539
        },
        {
          "path": "ftl/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "ftl/agents/builder-verify.md",
          "type": "blob",
          "size": 3286
        },
        {
          "path": "ftl/agents/builder.md",
          "type": "blob",
          "size": 5391
        },
        {
          "path": "ftl/agents/learner.md",
          "type": "blob",
          "size": 2546
        },
        {
          "path": "ftl/agents/planner.md",
          "type": "blob",
          "size": 5649
        },
        {
          "path": "ftl/agents/router.md",
          "type": "blob",
          "size": 6039
        },
        {
          "path": "ftl/agents/synthesizer.md",
          "type": "blob",
          "size": 5375
        },
        {
          "path": "ftl/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "ftl/commands/age.md",
          "type": "blob",
          "size": 831
        },
        {
          "path": "ftl/commands/close.md",
          "type": "blob",
          "size": 1056
        },
        {
          "path": "ftl/commands/decision.md",
          "type": "blob",
          "size": 1032
        },
        {
          "path": "ftl/commands/impact.md",
          "type": "blob",
          "size": 894
        },
        {
          "path": "ftl/commands/learn.md",
          "type": "blob",
          "size": 903
        },
        {
          "path": "ftl/commands/signal.md",
          "type": "blob",
          "size": 909
        },
        {
          "path": "ftl/commands/trace.md",
          "type": "blob",
          "size": 925
        },
        {
          "path": "ftl/commands/workspace.md",
          "type": "blob",
          "size": 1464
        },
        {
          "path": "ftl/lib",
          "type": "tree",
          "size": null
        },
        {
          "path": "ftl/lib/__init__.py",
          "type": "blob",
          "size": 264
        },
        {
          "path": "ftl/lib/campaign.py",
          "type": "blob",
          "size": 25880
        },
        {
          "path": "ftl/lib/concepts.py",
          "type": "blob",
          "size": 4610
        },
        {
          "path": "ftl/lib/memory.py",
          "type": "blob",
          "size": 23378
        },
        {
          "path": "ftl/lib/workspace.py",
          "type": "blob",
          "size": 3913
        },
        {
          "path": "ftl/lib/workspace_from_plan.py",
          "type": "blob",
          "size": 10438
        },
        {
          "path": "ftl/lib/workspace_xml.py",
          "type": "blob",
          "size": 14513
        },
        {
          "path": "ftl/output-styles",
          "type": "tree",
          "size": null
        },
        {
          "path": "ftl/output-styles/bounded-execution.md",
          "type": "blob",
          "size": 971
        },
        {
          "path": "ftl/output-styles/evidence-driven.md",
          "type": "blob",
          "size": 2659
        },
        {
          "path": "ftl/output-styles/gated-orchestration.md",
          "type": "blob",
          "size": 1167
        },
        {
          "path": "ftl/output-styles/ranked-memory.md",
          "type": "blob",
          "size": 990
        },
        {
          "path": "ftl/requirements.txt",
          "type": "blob",
          "size": 206
        },
        {
          "path": "ftl/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "ftl/scripts/capture_delta.sh",
          "type": "blob",
          "size": 5838
        },
        {
          "path": "ftl/scripts/capture_exploration.sh",
          "type": "blob",
          "size": 2548
        },
        {
          "path": "ftl/scripts/log_agent_type.sh",
          "type": "blob",
          "size": 558
        },
        {
          "path": "ftl/scripts/register.sh",
          "type": "blob",
          "size": 380
        },
        {
          "path": "ftl/scripts/session_context.sh",
          "type": "blob",
          "size": 2938
        },
        {
          "path": "ftl/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "ftl/skills/ftl",
          "type": "tree",
          "size": null
        },
        {
          "path": "ftl/skills/ftl/SKILL.md",
          "type": "blob",
          "size": 16058
        },
        {
          "path": "ftl/tests",
          "type": "tree",
          "size": null
        },
        {
          "path": "ftl/tests/test_campaign_flow.py",
          "type": "blob",
          "size": 8928
        },
        {
          "path": "ftl/tests/test_cli_contracts.py",
          "type": "blob",
          "size": 11610
        },
        {
          "path": "ftl/tests/test_memory_decisions.py",
          "type": "blob",
          "size": 18095
        },
        {
          "path": "ftl/tests/test_planner_parsing.py",
          "type": "blob",
          "size": 9628
        },
        {
          "path": "ftl/tests/test_workspace_naming.py",
          "type": "blob",
          "size": 12650
        },
        {
          "path": "utils",
          "type": "tree",
          "size": null
        },
        {
          "path": "utils/version_bump.py",
          "type": "blob",
          "size": 1552
        }
      ],
      "marketplace": {
        "name": "crinzo-plugins",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "crinzo"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "ftl",
            "description": "Claude Code orchestrators that build knowledge over time.",
            "source": "./ftl",
            "category": null,
            "version": "1.0.23",
            "author": {
              "name": "crinzo"
            },
            "install_commands": [
              "/plugin marketplace add enzokro/crinzo-plugins",
              "/plugin install ftl@crinzo-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-12T04:41:20Z",
              "created_at": "2025-12-21T21:42:56Z",
              "license": null
            },
            "commands": [
              {
                "name": "/age",
                "description": "Find stale decisions that may need review.",
                "path": "ftl/commands/age.md",
                "frontmatter": {
                  "description": "Find stale decisions that may need review.",
                  "allowed-tools": "Bash, Read, Glob",
                  "user-invocable": false
                },
                "content": "# Age Check\n\nFind decisions older than threshold. Stale decisions may no longer apply.\n\n## Protocol\n\n1. Parse $ARGUMENTS for days (default: 30).\n\n2. Query stale decisions:\n```bash\nsource ~/.config/ftl/paths.sh 2>/dev/null; python3 \"$FTL_LIB/memory.py\" age $DAYS\n```\n\n3. Report findings with source files and tags.\n\n## Output Format\n\n```\nStale decisions (>30d):\n\n  [012] cache-layer (45d) - #pattern/cache-invalidation\n  [005] batch-processing (60d) - #constraint/max-batch-size\n```\n\n## Usage\n\n```\n/ftl:age        # Decisions older than 30 days\n/ftl:age 14     # Decisions older than 14 days\n/ftl:age 90     # Decisions older than 90 days\n```\n\n## Constraints\n\n- Read-only\n- Reports only, no automatic deprecation"
              },
              {
                "name": "/close",
                "description": "Complete a workspace task.",
                "path": "ftl/commands/close.md",
                "frontmatter": {
                  "description": "Complete a workspace task.",
                  "allowed-tools": "Bash, Edit, Read, Glob"
                },
                "content": "# Close\n\n## Protocol\n\nFind active XML workspace:\n```bash\nls .ftl/workspace/*$ARGUMENTS*_active*.xml 2>/dev/null\n```\n\nRead XML workspace. Update `<delivered>` element with what was implemented.\n\nUpdate delivered section and link to git:\n```bash\nWORKSPACE=$(ls .ftl/workspace/*$ARGUMENTS*_active*.xml 2>/dev/null | head -1)\npython3 -c \"\nimport xml.etree.ElementTree as ET\nimport subprocess\ntree = ET.parse('$WORKSPACE')\nroot = tree.getroot()\ndelivered = root.find('.//delivered')\ncommit = subprocess.run(['git', 'rev-parse', '--short', 'HEAD'], capture_output=True, text=True).stdout.strip() or 'none'\ndelivered.text = '''Closed manually.\nCommit: ''' + commit\ndelivered.set('status', 'complete')\nroot.set('status', 'complete')\ntree.write('$WORKSPACE', encoding='unicode', xml_declaration=True)\n\"\n```\n\nRename:\n```bash\nmv .ftl/workspace/NNN_slug_active.xml .ftl/workspace/NNN_slug_complete.xml\n# or _blocked if stuck\n```\n\nReport: summary of delivered, final file location."
              },
              {
                "name": "/decision",
                "description": "Show full decision record with context.",
                "path": "ftl/commands/decision.md",
                "frontmatter": {
                  "description": "Show full decision record with context.",
                  "allowed-tools": "Bash, Read, Glob",
                  "user-invocable": false
                },
                "content": "# Decision Record\n\nShow complete decision record including Thinking Traces and Delivered.\n\n## Protocol\n\n1. Parse $ARGUMENTS for sequence number.\n\n2. Get decision:\n```bash\nsource ~/.config/ftl/paths.sh 2>/dev/null; python3 \"$FTL_LIB/memory.py\" decision $SEQ\n```\n\n## Output Format\n\n```\n[015] auth-refactor (3d ago, complete)\n  Path: User credentials → validation → session token\n  Delta: src/auth/*.ts\n  Tags: #pattern/session-token-flow (+2)\n  Builds on: 008\n\nThinking Traces:\nChose token refresh over re-auth because...\nExamined session.ts lines 45-78...\nFound existing pattern in auth-utils.ts...\n\nDelivered:\nModified src/auth/session.ts to implement token refresh.\nAdded refresh endpoint in src/api/auth.ts.\n```\n\n## Usage\n\n```\n/ftl:decision 015    # Show decision 015\n/ftl:decision 3      # Show decision 003 (zero-padded)\n```\n\n## Constraints\n\n- Read-only\n- Returns full Thinking Traces and Delivered sections"
              },
              {
                "name": "/impact",
                "description": "Find decisions that affected a file.",
                "path": "ftl/commands/impact.md",
                "frontmatter": {
                  "description": "Find decisions that affected a file.",
                  "allowed-tools": "Bash, Read, Glob",
                  "user-invocable": false
                },
                "content": "# File Impact\n\nFind decisions that touched a file pattern.\n\n## Protocol\n\n1. Parse $ARGUMENTS for file pattern.\n\n2. Query file impact:\n```bash\nsource ~/.config/ftl/paths.sh 2>/dev/null; python3 \"$FTL_LIB/memory.py\" impact \"$FILE\"\n```\n\n## Output Format\n\n```\nDecisions affecting 'auth':\n\n  [015] auth-refactor (3d)\n    Delta: src/auth/*.ts\n\n  [008] security-audit (12d)\n    Delta: src/**/*.ts\n```\n\n## Usage\n\n```\n/ftl:impact auth           # Files containing \"auth\"\n/ftl:impact src/api        # Files in src/api/\n/ftl:impact session.ts     # Specific file\n```\n\n## Graph Query\n\nThis command traverses the `file → decisions` edge in the context graph.\n\n```\nsrc/auth/*.ts\n  └── modified_by → [015, 023]\n```\n\n## Constraints\n\n- Read-only\n- Matches file patterns from Delta fields"
              },
              {
                "name": "/learn",
                "description": "Force synthesis of cross-campaign patterns.",
                "path": "ftl/commands/learn.md",
                "frontmatter": {
                  "name": "learn",
                  "description": "Force synthesis of cross-campaign patterns.",
                  "allowed-tools": "Task, Read, Bash"
                },
                "content": "# Learn\n\nForce meta-pattern synthesis from completed campaigns.\n\n## Protocol\n\nInvoke synthesizer:\n```\nTask tool with subagent_type: ftl:synthesizer\n```\n\n## Output\n\n```\nSynthesis complete.\n\nMeta-patterns:\n  - token-lifecycle: session-token-flow + refresh-token (net +4)\n  - error-resilience: retry-with-backoff + circuit-breaker (net +2)\n\nEvolution:\n  - jwt-storage → httponly-cookies (security)\n\nBridges:\n  - retry-with-backoff: auth → api, external-services\n\nUpdated: .ftl/synthesis.json\n```\n\n## When to Use\n\n- After completing multiple campaigns\n- Before starting work in new domain\n- To surface emerging patterns\n- To identify what works (positive signals)\n\n## Auto-Synthesis\n\nSynthesis runs automatically on campaign completion.\nUse `/ftl:learn` to force manual synthesis at any time."
              },
              {
                "name": "/signal",
                "description": "Mark failure/discovery outcome for tracking.",
                "path": "ftl/commands/signal.md",
                "frontmatter": {
                  "description": "Mark failure/discovery outcome for tracking.",
                  "allowed-tools": "Bash, Read, Write",
                  "user-invocable": false
                },
                "content": "# Signal Outcome\n\nMark a failure or discovery as working (+) or problematic (-). Signals track effectiveness.\n\n## Protocol\n\n1. Parse $ARGUMENTS:\n   - First arg: `+` or `-`\n   - Second arg: entity ID (e.g., `f001` or `d003`)\n\n2. Add signal:\n```bash\nsource ~/.config/ftl/paths.sh 2>/dev/null; python3 \"$FTL_LIB/memory.py\" signal \"$SIGN\" \"$ID\"\n```\n\n3. Confirm result.\n\n## Usage\n\n```\n/ftl:signal + f001    # Failure fix worked well\n/ftl:signal - d003    # Discovery didn't help\n```\n\n## Output Format\n\n```\nSignal: f001 -> 2\n```\n\n## Storage\n\nSignals stored on entities in `.ftl/memory.json`:\n```json\n{\n  \"failures\": [\n    {\n      \"id\": \"f001\",\n      \"name\": \"failure-name\",\n      \"signal\": 2\n    }\n  ]\n}\n```\n\n## Constraints\n\n- Only writes to .ftl/memory.json\n- Does not modify workspace files"
              },
              {
                "name": "/trace",
                "description": "Find decisions that used a pattern.",
                "path": "ftl/commands/trace.md",
                "frontmatter": {
                  "description": "Find decisions that used a pattern.",
                  "allowed-tools": "Bash, Read, Glob",
                  "user-invocable": false
                },
                "content": "# Trace Pattern\n\nFind all decisions that applied a specific pattern.\n\n## Protocol\n\n1. Parse $ARGUMENTS for pattern tag.\n\n2. Trace pattern usage:\n```bash\nsource ~/.config/ftl/paths.sh 2>/dev/null; python3 \"$FTL_LIB/memory.py\" trace \"$PATTERN\"\n```\n\n## Output Format\n\n```\nDecisions using #pattern/session-token-flow:\n\n  [015] auth-refactor (3d, complete)\n  [023] session-timeout (1d, complete)\n  [028] token-refresh (0d, active)\n```\n\n## Usage\n\n```\n/ftl:trace #pattern/session-token-flow\n/ftl:trace #constraint/no-jwt-in-cookies\n/ftl:trace #decision/use-httponly\n```\n\n## Graph Query\n\nThis command traverses the `pattern → decisions` edge in the context graph.\n\n```\n#pattern/session-token-flow\n  └── applied_in → [015, 023, 028]\n```\n\n## Constraints\n\n- Read-only\n- Returns all decisions, not just recent ones"
              },
              {
                "name": "/workspace",
                "description": "Query workspace state and lineage.",
                "path": "ftl/commands/workspace.md",
                "frontmatter": {
                  "description": "Query workspace state and lineage.",
                  "allowed-tools": "Bash, Read, Glob, Grep"
                },
                "content": "# Workspace Query\n\n## Protocol\n\nParse $ARGUMENTS:\n\n**No args** — overview:\n```bash\nsource ~/.config/ftl/paths.sh 2>/dev/null; python3 \"$FTL_LIB/workspace.py\" stat\n```\n\n**\"graph\"** — tree view:\n```bash\nsource ~/.config/ftl/paths.sh 2>/dev/null; python3 \"$FTL_LIB/workspace.py\" graph\n```\n\n**Number (e.g., \"003\")** — lineage:\n```bash\nsource ~/.config/ftl/paths.sh 2>/dev/null; python3 \"$FTL_LIB/workspace.py\" lineage $SELECTOR\n```\n\n**\"active\" | \"blocked\" | \"complete\"** — filter:\n```bash\nls -la .ftl/workspace/*_${STATUS}*.xml 2>/dev/null\n```\n\n**\"roots\"** — no parent:\n```bash\nls .ftl/workspace/*.xml 2>/dev/null | while read f; do\n  [[ ! \"$f\" =~ _from-[0-9] ]] && basename \"$f\"\ndone\n```\n\n**\"tags\"** — Key Findings (extract from XML):\n```bash\npython3 -c \"\nimport xml.etree.ElementTree as ET\nfrom pathlib import Path\npatterns = set()\nfor ws in Path('.ftl/workspace').glob('*_complete.xml'):\n    tree = ET.parse(ws)\n    for p in tree.findall('.//pattern'):\n        name = p.get('name')\n        if name: patterns.add(f'#pattern/{name}')\n    for f in tree.findall('.//failure'):\n        name = f.get('name')\n        if name: patterns.add(f'#failure/{name}')\nfor p in sorted(patterns):\n    print(p)\n\"\n```\n\n**\"find PATTERN\"** — search:\n```bash\ngrep -rn \"PATTERN\" .ftl/workspace/*.xml 2>/dev/null\n```\n\n## Indicators\n\n- `[+]` complete\n- `[~]` active\n- `[!]` blocked"
              }
            ],
            "skills": [
              {
                "name": "ftl",
                "description": "Unified development orchestration. Tasks, campaigns, memory.",
                "path": "ftl/skills/ftl/SKILL.md",
                "frontmatter": {
                  "name": "ftl",
                  "description": "Unified development orchestration. Tasks, campaigns, memory.",
                  "version": "1.0.0"
                },
                "content": "# FTL Protocol\n\nUnified entry point for task execution, campaign orchestration, and memory queries.\n\n## MANDATORY CONSTRAINT\n\n**This skill is the ONLY valid entry point for FTL operations.**\n\nDO NOT:\n- Call `campaign.py` directly from Claude Code\n- Call `ftl:router`, `ftl:builder`, or other agents directly\n- Manually create workspace files\n- Skip the planner when creating campaigns\n\n**If user asks to use FTL**: Invoke THIS skill. Do not improvise the workflow.\n\n---\n\n## Two Workflows\n\n| Mode | Flow | Pattern Agent |\n|------|------|---------------|\n| TASK | Request → Router → Builder → **Learner** | Learner (single workspace) |\n| CAMPAIGN | Objective → Planner → [workspace_from_plan.py → Builder]* → **Synthesizer** | Synthesizer (all workspaces) |\n\n### Agent Matrix\n\n| Agent | Task | Campaign |\n|-------|------|----------|\n| Router | ✓ | ⊘ (use workspace_from_plan.py) |\n| Builder | ✓ | ✓ |\n| Planner | ⊘ | start only |\n| **Learner** | **✓** | **⊘ NEVER** |\n| **Synthesizer** | ⊘ | **end only** |\n\n**Router is only for TASK mode.** In Campaign mode, Planner outputs JSON task specs, and `workspace_from_plan.py` generates workspace XML directly - no Router agent needed.\n\n**Learner + Synthesizer are mutually exclusive.** Using learner in campaign mode is a category error - like asking \"what color is the number 7?\"\n\n---\n\n## Entry: Route by Intent\n\n| Input | Mode | Action |\n|-------|------|--------|\n| `/ftl <task>` | TASK | router → builder → learner |\n| `/ftl campaign <obj>` | CAMPAIGN | planner → tasks[] → synthesizer |\n| `/ftl query <topic>` | MEMORY | CLI query (no agent) |\n| `/ftl status` | STATUS | CLI query (no agent) |\n\n---\n\n## Context Injection (REQUIRED)\n\n### Memory Injection Architecture\n\nAgents fetch their own memory (not pre-injected):\n- **Planner**: Fetches ALL memory (unfiltered) for complexity formula\n- **Router**: Fetches FILTERED memory (by task tags) for mode decision + workspace\n\nThis eliminates redundant memory reads.\n\n### Before TASK mode (Router):\n\n1. Read `.ftl/cache/session_context.md` (git state, tools - NO memory)\n2. Read `.ftl/cache/cognition_state.md` (dynamic, updated after each agent)\n3. Router fetches filtered memory: `memory.py inject \"tags\"`\n\n### Before CAMPAIGN mode (Planner):\n\n1. Read `.ftl/cache/session_context.md` (git state, tools - NO memory)\n2. Planner fetches all memory: `memory.py inject` (for complexity formula)\n\n### For workspace generation (workspace_from_plan.py):\n\nMemory injection handled automatically:\n- Filters by task tags (framework, type, delta files)\n- Code context read from Delta files\n- No manual injection needed\n\n### After EVERY agent completes:\n\nHooks automatically update `.ftl/cache/cognition_state.md` via `capture_delta.sh`.\n\n### Cache Files\n\n| File | Type | Purpose |\n|------|------|---------|\n| `session_context.md` | Static | Git state, project tools (NO memory) |\n| `cognition_state.md` | Dynamic | Phase awareness, inherited knowledge |\n| `exploration_context.md` | Dynamic | Router findings for builder |\n| `delta_contents.md` | Dynamic | File contents from prior tasks |\n\n**Memory is fetched by agents, not cached** - each agent gets exactly what it needs.\n\n---\n\n## Framework Idioms Flow\n\nFramework idioms are **defined in README**, not hardcoded in agents. This makes FTL framework-agnostic.\n\n| Mode | Flow |\n|------|------|\n| TASK | README → Router (extracts) → Builder (enforces) |\n| CAMPAIGN | README → Planner (extracts to JSON) → workspace_from_plan.py → Builder (enforces) |\n\n### README Structure (project defines)\n\n```markdown\n## Framework Idioms\nRequired:\n- [pattern 1 - e.g., \"Use @rt decorator for routes\"]\n- [pattern 2 - e.g., \"Return component trees, not strings\"]\n\nForbidden:\n- [anti-pattern 1 - e.g., \"Raw HTML strings with f-strings\"]\n- [anti-pattern 2 - e.g., \"Manual string concatenation\"]\n```\n\n### Extraction (mode-dependent)\n\n**TASK mode (Router)**:\n- Looks for \"## Framework Idioms\" section in README\n- If found: copies Required/Forbidden lists verbatim to workspace\n- If not found but framework mentioned: infers generic guidance\n- If no framework: omits Framework Idioms section entirely\n\n**CAMPAIGN mode (Planner → workspace_from_plan.py)**:\n- Planner extracts idioms to JSON output\n- workspace_from_plan.py copies idioms to each workspace\n- No Router agent needed\n\n### Builder (enforces)\n\n- Framework Idioms in workspace are **Essential** constraints\n- Required items MUST be used\n- Forbidden items MUST NOT appear\n- Quality checkpoint verifies idiom compliance\n\n### Planner (signals)\n\n```markdown\n### Downstream Impact\n- Framework: [name] (Builder must use idioms)\n- Framework complexity: [low | moderate | high]\n```\n\n---\n\n## Adaptive Decomposition\n\nPlanner assesses complexity before determining task count:\n\n### Complexity Formula\n```\nC = (N × 2) + (F / 50000) + (framework × 3)\n\nN = README specification sections\nF = Prior Knowledge failure costs (tokens)\nframework = none(0), simple(1), moderate(2), high(3)\n```\n\n### Task Count by Complexity\n\n| Score | Decomposition |\n|-------|---------------|\n| C < 8 | 2 tasks: combined SPEC+BUILD → VERIFY |\n| 8 ≤ C < 15 | 3 tasks: SPEC → BUILD → VERIFY |\n| 15 ≤ C < 25 | 4-5 tasks: SPEC → BUILD_1 → BUILD_2 → VERIFY |\n| C ≥ 25 | 5-7 tasks: full decomposition with checkpoints |\n\n**If README mandates specific task count**, planner notes deviation but follows README.\n\n---\n\n## Enhanced Workspace Structure\n\nRouter creates workspaces with embedded context:\n\n### Code Context (if Delta file exists)\n```markdown\n## Code Context\n### {delta_file}\n```python\n{current file contents, first 60 lines}\n```\nExports: {function_name(), ClassName}\nImports: {from X import Y}\n\n### Task Lineage\nParent: {prior task slug} | none\nPrior delivery: {what parent completed}\n```\n\n### Framework Idioms (if framework specified)\n```markdown\n## Framework Idioms\nFramework: FastHTML\nRequired:\n- Use @rt decorator for routes\n- Return component trees (Div, Ul, Li), NOT f-strings\n- Use Form/Input/Button for forms\nForbidden:\n- Raw HTML string construction with f-strings\n- Manual string concatenation for templates\n```\n\n**Framework Idioms are Essential constraints** - Builder MUST use Required items and MUST NOT use Forbidden items.\n\n---\n\n## Mode: TASK\n\n```\n1. Task(ftl:router) with task description\n   Returns: direct | full | clarify\n\n2a. If direct:\n    Task(ftl:ftl-builder) with inline spec\n    - 3 tool budget\n    - No retry on failure\n    - Skip learner (simple change, no pattern extraction)\n    - Uses Sonnet model (simple changes don't need Opus reasoning)\n\n2b. If full:\n    Task(ftl:builder) — workspace created by router\n    - 5 tool budget\n    - Retry once on Known Failure match\n    - Code Context + Framework Idioms in workspace\n    Task(ftl:learner) — extract patterns\n\n2c. If clarify:\n    Return question to user\n```\n\n### DIRECT Mode Routing\n\nRouter assesses whether task qualifies for DIRECT mode:\n\n| Signal | Mode |\n|--------|------|\n| Single Delta file, no framework, <100 lines | DIRECT |\n| Prior Knowledge shows 0 related failures | DIRECT |\n| Multiple files OR framework involved | FULL |\n| Prior Knowledge shows related failures | FULL |\n| SPEC task type | FULL (always) |\n| VERIFY task type (standalone) | FULL |\n| VERIFY task type (final campaign task) | DIRECT (inline) |\n\n**DIRECT mode**: 3 tools, no workspace, no retry, no learner\n**FULL mode**: 5 tools, workspace with Code Context + Framework Idioms, retry once, learner\n\n**Campaign DIRECT mode (VERIFY tasks)**:\nIn campaign mode, the final VERIFY task may run inline without spawning an agent:\n- No workspace file created\n- Main orchestrator runs verify command directly\n- Status update skipped (no workspace to mark complete)\n- Campaign completion unaffected\n\nThis saves agent spawn overhead (~50k tokens) for simple verification.\n\n**Note**: In CAMPAIGN mode, BUILD tasks may still use DIRECT mode if simple. Synthesizer runs at campaign end regardless of individual task modes.\n\n### Mode Detection\n\n| Signal | Mode |\n|--------|------|\n| Prompt starts with `Campaign:` | CAMPAIGN |\n| No `Campaign:` prefix | TASK |\n\n---\n\n## Mode: CAMPAIGN\n\n### Step 1: Check Active Campaign\n\n```bash\nsource ~/.config/ftl/paths.sh 2>/dev/null\nACTIVE=$(python3 \"$FTL_LIB/campaign.py\" active 2>/dev/null)\n```\n\nIf campaign exists, skip to Step 5.\n\n### Step 2: Invoke Planner\n\n```\nTask(ftl:planner) with prompt:\n  [session_context.md contents - git state, tools]\n\n  Objective: [objective from user]\n```\n\nPlanner fetches its own memory (Step 0 in planner.md).\n\nReturns: PROCEED | CONFIRM | CLARIFY\n\n### Step 3: Create Campaign\n\n```bash\npython3 \"$FTL_LIB/campaign.py\" campaign \"$OBJECTIVE\"\n```\n\n### Step 4: Add Tasks\n\n```bash\necho \"$PLANNER_OUTPUT\" | python3 \"$FTL_LIB/campaign.py\" add-tasks-from-plan\n```\n\n### Step 4.5: Generate All Workspaces (NEW - replaces per-task Router)\n\nExtract JSON from Planner output and generate all workspaces at once:\n\n```bash\n# Extract JSON block from Planner markdown (between ```json and ```)\nPLAN_JSON=$(echo \"$PLANNER_OUTPUT\" | sed -n '/```json/,/```/p' | sed '1d;$d')\n\n# Generate all workspaces\necho \"$PLAN_JSON\" | python3 \"$FTL_LIB/workspace_from_plan.py\" -\n```\n\nThis replaces spawning Router for each task (saves ~300-400k tokens per campaign).\n\n### Step 5: Execute Each Task\n\nFor each task in sequence:\n\n**1. Builder** (workspace from Step 4.5, except DIRECT mode)\n\nAgent selection by task type (cost optimization):\n| Task Type | Agent | Model | Reason |\n|-----------|-------|-------|--------|\n| VERIFY (with workspace) | ftl:ftl-builder-verify | sonnet | No code generation, just runs tests |\n| VERIFY (final, DIRECT) | inline | - | No agent spawn, runs verify command directly |\n| DIRECT | ftl:ftl-builder-verify | sonnet | Simple changes, minimal reasoning |\n| SPEC | ftl:ftl-builder | opus | Complex test design |\n| BUILD | ftl:ftl-builder | opus | Framework idiom enforcement |\n\nFor VERIFY tasks with workspace:\n```\nTask(ftl:ftl-builder-verify) with prompt:\n  Workspace: .ftl/workspace/NNN_slug_active.xml\n```\n\nFor VERIFY tasks in DIRECT mode (final campaign task, no workspace):\n```bash\n# Run verify command inline - no agent spawn needed\nuv run pytest test_app.py -v\n# Skip status update (no workspace file to mark complete)\n# Campaign completion handles overall status\n```\n\nFor DIRECT mode (BUILD):\n```\nTask(ftl:ftl-builder-verify) with inline spec (no workspace path)\n```\n\nFor SPEC/BUILD tasks:\n```\nTask(ftl:ftl-builder) with prompt:\n  [exploration_context.md if exists]\n  [delta_contents.md if exists]\n  ---\n  Workspace: .ftl/workspace/NNN_slug_active.xml\n```\n\n**2. Update state** (skip for DIRECT mode - no workspace file)\n```bash\n# Only run if workspace file exists\nif [ -f \".ftl/workspace/${SEQ}_*_active.xml\" ]; then\n  python3 \"$FTL_LIB/campaign.py\" update-task \"$SEQ\" complete\nfi\n```\n(Hooks update cognition_state.md automatically)\n\n### Step 6: Complete Campaign (Conditional Synthesizer)\n\n```bash\npython3 \"$FTL_LIB/campaign.py\" complete\n```\n\n**Synthesizer Gate** (skip when no learning opportunity):\n\n```bash\n# Gate 1: Check for blocked workspaces (must extract failures)\nBLOCKED=$(find .ftl/workspace -name \"*_blocked.xml\" 2>/dev/null | wc -l)\n\n# Gate 2: Check for new frameworks (not yet in memory)\nCAMPAIGN_FRAMEWORK=$(python3 \"$FTL_LIB/campaign.py\" get-framework 2>/dev/null || echo \"\")\nNEW_FRAMEWORK=\"\"\nif [ -n \"$CAMPAIGN_FRAMEWORK\" ]; then\n    NEW_FRAMEWORK=$(python3 \"$FTL_LIB/memory.py\" check-new-frameworks \"$CAMPAIGN_FRAMEWORK\" 2>/dev/null || echo \"\")\nfi\n\n# Decision: Run synthesizer only if learning opportunity exists\nif [ \"$BLOCKED\" -gt 0 ] || [ -n \"$NEW_FRAMEWORK\" ]; then\n    echo \"Learning opportunity detected - running synthesizer\"\n    echo \"  Blocked workspaces: $BLOCKED\"\n    echo \"  New framework: ${NEW_FRAMEWORK:-none}\"\n    Task(ftl:synthesizer)\nelse\n    echo \"No new learnings expected - skipping synthesizer\"\n    echo \"  Reason: All workspaces complete, no new frameworks\"\n    # Minimal tracking: add campaign source reference to existing patterns\n    python3 \"$FTL_LIB/memory.py\" add-source \"$CAMPAIGN_ID\" 2>/dev/null || true\nfi\n```\n\n**Gate Logic**:\n- **RUN synthesizer if**: blocked workspaces > 0 OR new framework detected\n- **SKIP synthesizer if**: all workspaces complete AND framework already in memory\n\n**Historical ROI**:\n- Blocked tasks: 2-4x ROI (always run)\n- New framework: 2-3x ROI (run)\n- Clean + patterns matched: 0x ROI (skip - saves 26.6% tokens)\n\n**Synthesizer reads ONLY workspace files.** Does NOT read source code or run tests.\n\n---\n\n## Mode: MEMORY\n\n```bash\nsource ~/.config/ftl/paths.sh 2>/dev/null\npython3 \"$FTL_LIB/memory.py\" query \"$TOPIC\"\n```\n\n---\n\n## Workspace\n\n```\n.ftl/workspace/NNN_task-slug_status.xml\n```\n\nStatus: `active` | `complete` | `blocked`\n\n---\n\n## CLI Reference\n\n| Command | Purpose |\n|---------|---------|\n| `campaign.py active` | Check active campaign |\n| `campaign.py campaign \"$OBJ\"` | Create campaign |\n| `campaign.py add-tasks-from-plan` | Add tasks from planner output |\n| `campaign.py update-task $SEQ complete` | Mark task complete |\n| `campaign.py complete` | Complete campaign |\n| `campaign.py get-framework` | Get framework from workspace files |\n| `workspace_from_plan.py plan.json` | Generate workspaces from Planner JSON |\n| `workspace_xml.py complete <path> --delivered \"...\"` | Atomic: complete workspace |\n| `workspace_xml.py block <path> --delivered \"...\"` | Atomic: block workspace |\n| `workspace.py stat` | Workspace status |\n| `workspace.py lineage NNN` | Task lineage |\n| `memory.py query \"$TOPIC\"` | Query memory |\n| `memory.py inject .ftl/memory.json` | Format memory for injection |\n| `memory.py check-new-frameworks <fw>` | Check if framework is new to memory |\n| `memory.py add-source <campaign>` | Add campaign to pattern sources |\n\nAll commands require: `source ~/.config/ftl/paths.sh`\n\n---\n\n## Design Principles\n\n| Principle | Meaning |\n|-----------|---------|\n| Present over future | Current request only |\n| Concrete over abstract | Specific solution, not framework |\n| Explicit over clever | Clarity over sophistication |\n| Edit over create | Modify existing first |\n| Framework fidelity | Use idioms, not raw equivalents |\n| Quality beyond tests | Tests pass ≠ architecturally correct |\n\nNo new abstractions. No files outside Delta.\n\n---\n\n## Constraint Tiering\n\nAll agents use tiered constraints:\n\n| Tier | Meaning | Action |\n|------|---------|--------|\n| **Essential** | Critical invariant | Escalate if violated |\n| **Quality** | Important but recoverable | Note in output |\n\nThis replaces MUST/NEVER/CRITICAL with clear priority levels.\n\n**Example (Builder):**\n- Essential: Tool budget (5 max), Framework Idioms, block signals\n- Quality: Delivered section filled, Code Context exports preserved\n\n---\n\n## Quality Checkpoints\n\nEvery agent runs a quality checkpoint before completing:\n\n| Agent | Checks |\n|-------|--------|\n| Builder | Framework idioms used? Delivered section filled? |\n| Router | Delta specific? Verify executable? Framework context? |\n| Planner | All tasks verifiable? Dependencies ordered? |\n| Synthesizer | Soft failures detected? Generalizable patterns? |\n| Learner | Confidence threshold met? Evidence cited? |\n\nQuality checkpoint catches issues before they propagate.\n\n---\n\n## 5 Agents\n\n| Agent | Role | Key Constraint |\n|-------|------|----------------|\n| **router** | Classify tasks (TASK mode only) | Pass framework context to builder |\n| **builder** | Transform workspace spec into code | 5 tools max, framework fidelity |\n| **planner** | Decompose objectives + output JSON specs | Verification coherence |\n| **learner** | Extract patterns from single workspace (TASK) | Read-only except Key Findings |\n| **synthesizer** | Extract meta-patterns from all workspaces (CAMPAIGN) | Verify blocks before extraction |\n\n**Note**: In Campaign mode, `workspace_from_plan.py` replaces Router for workspace generation. This saves ~300-400k tokens per campaign by eliminating redundant agent spawns."
              }
            ]
          }
        ]
      }
    }
  ]
}