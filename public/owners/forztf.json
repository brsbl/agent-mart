{
  "owner": {
    "id": "forztf",
    "display_name": "forztf",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/10570841?v=4",
    "url": "https://github.com/forztf",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 1,
      "total_commands": 16,
      "total_skills": 16,
      "total_stars": 4,
      "total_forks": 1
    }
  },
  "repos": [
    {
      "full_name": "forztf/open-skilled-sdd",
      "url": "https://github.com/forztf/open-skilled-sdd",
      "description": "Enhancing AI coding assistants through open Spec-driven development (Spec-driven development for AI coding assistants), adopting the Claude Code Skills approach, compatible with various CLI and IDE AI coding assistants that support AGENTS.md.",
      "homepage": null,
      "signals": {
        "stars": 4,
        "forks": 1,
        "pushed_at": "2025-11-28T07:09:48Z",
        "created_at": "2025-11-21T06:14:22Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 396
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 1098
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 2188
        },
        {
          "path": "AGENTS.md",
          "type": "blob",
          "size": 4400
        },
        {
          "path": "CLAUDE.md",
          "type": "blob",
          "size": 5481
        },
        {
          "path": "TEST-REPORT.md",
          "type": "blob",
          "size": 2864
        },
        {
          "path": "bin",
          "type": "tree",
          "size": null
        },
        {
          "path": "bin/install.js",
          "type": "blob",
          "size": 7281
        },
        {
          "path": "bin/sync.js",
          "type": "blob",
          "size": 2002
        },
        {
          "path": "lib",
          "type": "tree",
          "size": null
        },
        {
          "path": "lib/localization.js",
          "type": "blob",
          "size": 10851
        },
        {
          "path": "lib/utils",
          "type": "tree",
          "size": null
        },
        {
          "path": "lib/utils/agents-md.js",
          "type": "blob",
          "size": 3116
        },
        {
          "path": "lib/utils/dirs.js",
          "type": "blob",
          "size": 592
        },
        {
          "path": "lib/utils/skills.js",
          "type": "blob",
          "size": 905
        },
        {
          "path": "lib/utils/yaml.js",
          "type": "blob",
          "size": 412
        },
        {
          "path": "package.json",
          "type": "blob",
          "size": 1076
        },
        {
          "path": "readme-zh.md",
          "type": "blob",
          "size": 7502
        },
        {
          "path": "readme.md",
          "type": "blob",
          "size": 7132
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-archiving-cn",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-archiving-cn/SKILL.md",
          "type": "blob",
          "size": 10164
        },
        {
          "path": "skills/openspec-archiving",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-archiving/SKILL.md",
          "type": "blob",
          "size": 10798
        },
        {
          "path": "skills/openspec-context-loading-cn",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-context-loading-cn/SKILL.md",
          "type": "blob",
          "size": 10102
        },
        {
          "path": "skills/openspec-context-loading-cn/reference",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-context-loading-cn/reference/SEARCH_PATTERNS.md",
          "type": "blob",
          "size": 2197
        },
        {
          "path": "skills/openspec-context-loading",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-context-loading/SKILL.md",
          "type": "blob",
          "size": 10399
        },
        {
          "path": "skills/openspec-implementation-cn",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-implementation-cn/SKILL.md",
          "type": "blob",
          "size": 9440
        },
        {
          "path": "skills/openspec-implementation-cn/reference",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-implementation-cn/reference/TASK_PATTERNS.md",
          "type": "blob",
          "size": 27692
        },
        {
          "path": "skills/openspec-implementation-cn/reference/TESTING_STRATEGIES.md",
          "type": "blob",
          "size": 1340
        },
        {
          "path": "skills/openspec-implementation",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-implementation/SKILL.md",
          "type": "blob",
          "size": 8447
        },
        {
          "path": "skills/openspec-proposal-creation-cn",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-proposal-creation-cn/SKILL.md",
          "type": "blob",
          "size": 7849
        },
        {
          "path": "skills/openspec-proposal-creation-cn/reference",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-proposal-creation-cn/reference/EARS_FORMAT.md",
          "type": "blob",
          "size": 7163
        },
        {
          "path": "skills/openspec-proposal-creation-cn/reference/VALIDATION_PATTERNS.md",
          "type": "blob",
          "size": 8063
        },
        {
          "path": "skills/openspec-proposal-creation-cn/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-proposal-creation-cn/templates/proposal.md",
          "type": "blob",
          "size": 774
        },
        {
          "path": "skills/openspec-proposal-creation-cn/templates/spec-delta.md",
          "type": "blob",
          "size": 1128
        },
        {
          "path": "skills/openspec-proposal-creation-cn/templates/tasks.json",
          "type": "blob",
          "size": 7935
        },
        {
          "path": "skills/openspec-proposal-creation",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-proposal-creation/SKILL.md",
          "type": "blob",
          "size": 7677
        },
        {
          "path": "skills/openspec-proposal-creation/reference",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-proposal-creation/reference/EARS_FORMAT.md",
          "type": "blob",
          "size": 8198
        },
        {
          "path": "skills/openspec-proposal-creation/reference/VALIDATION_PATTERNS.md",
          "type": "blob",
          "size": 8297
        },
        {
          "path": "skills/openspec-proposal-creation/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-proposal-creation/templates/proposal.md",
          "type": "blob",
          "size": 842
        },
        {
          "path": "skills/openspec-proposal-creation/templates/spec-delta.md",
          "type": "blob",
          "size": 1268
        },
        {
          "path": "skills/openspec-proposal-creation/templates/tasks.md",
          "type": "blob",
          "size": 774
        },
        {
          "path": "skills/speckit-analyze-zh",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-analyze-zh/SKILL.md",
          "type": "blob",
          "size": 6897
        },
        {
          "path": "skills/speckit-analyze-zh/assets",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-analyze-zh/assets/user-input-template.txt",
          "type": "blob",
          "size": 10
        },
        {
          "path": "skills/speckit-analyze-zh/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-analyze-zh/references/analysis-patterns.md",
          "type": "blob",
          "size": 1399
        },
        {
          "path": "skills/speckit-analyze-zh/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-analyze-zh/scripts/check-prerequisites.ps1",
          "type": "blob",
          "size": 800
        },
        {
          "path": "skills/speckit-checklist-zh",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-checklist-zh/SKILL.md",
          "type": "blob",
          "size": 15852
        },
        {
          "path": "skills/speckit-checklist-zh/assets",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-checklist-zh/assets/checklist-template.md",
          "type": "blob",
          "size": 1255
        },
        {
          "path": "skills/speckit-checklist-zh/assets/correct-examples.md",
          "type": "blob",
          "size": 654
        },
        {
          "path": "skills/speckit-checklist-zh/assets/example-snippets.md",
          "type": "blob",
          "size": 1653
        },
        {
          "path": "skills/speckit-checklist-zh/assets/user-input-template.md",
          "type": "blob",
          "size": 22
        },
        {
          "path": "skills/speckit-checklist-zh/assets/wrong-examples.md",
          "type": "blob",
          "size": 322
        },
        {
          "path": "skills/speckit-checklist-zh/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-checklist-zh/references/anti-examples.md",
          "type": "blob",
          "size": 2367
        },
        {
          "path": "skills/speckit-checklist-zh/references/checklist-types.md",
          "type": "blob",
          "size": 2278
        },
        {
          "path": "skills/speckit-checklist-zh/references/execution-guide.md",
          "type": "blob",
          "size": 2373
        },
        {
          "path": "skills/speckit-checklist-zh/references/quality-dimensions.md",
          "type": "blob",
          "size": 3570
        },
        {
          "path": "skills/speckit-checklist-zh/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-checklist-zh/scripts/check-prerequisites.ps1",
          "type": "blob",
          "size": 2702
        },
        {
          "path": "skills/speckit-clarify-zh",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-clarify-zh/SKILL.md",
          "type": "blob",
          "size": 10539
        },
        {
          "path": "skills/speckit-constitution-zh",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-constitution-zh/SKILL.md",
          "type": "blob",
          "size": 6010
        },
        {
          "path": "skills/speckit-constitution-zh/assets",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/memory",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/memory/constitution.md",
          "type": "blob",
          "size": 2047
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/scripts/bash",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/scripts/bash/check-prerequisites.sh",
          "type": "blob",
          "size": 4888
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/scripts/bash/common.sh",
          "type": "blob",
          "size": 4909
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/scripts/bash/create-new-feature.sh",
          "type": "blob",
          "size": 9081
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/scripts/bash/setup-plan.sh",
          "type": "blob",
          "size": 1609
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/scripts/bash/update-agent-context.sh",
          "type": "blob",
          "size": 24368
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/scripts/powershell",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/scripts/powershell/check-prerequisites.ps1",
          "type": "blob",
          "size": 4746
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/scripts/powershell/common.ps1",
          "type": "blob",
          "size": 3854
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/scripts/powershell/create-new-feature.ps1",
          "type": "blob",
          "size": 9623
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/scripts/powershell/setup-plan.ps1",
          "type": "blob",
          "size": 1889
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/scripts/powershell/update-agent-context.ps1",
          "type": "blob",
          "size": 19295
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/agent-file-template.md",
          "type": "blob",
          "size": 433
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/checklist-template.md",
          "type": "blob",
          "size": 1255
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/analyze.md",
          "type": "blob",
          "size": 6582
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/checklist.md",
          "type": "blob",
          "size": 15507
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/clarify.md",
          "type": "blob",
          "size": 10219
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/constitution.md",
          "type": "blob",
          "size": 4629
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/implement.md",
          "type": "blob",
          "size": 7211
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/plan.md",
          "type": "blob",
          "size": 2973
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/specify.md",
          "type": "blob",
          "size": 11279
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/tasks.md",
          "type": "blob",
          "size": 6005
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/constitution-template.md",
          "type": "blob",
          "size": 2047
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/plan-template.md",
          "type": "blob",
          "size": 3579
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/spec-template.md",
          "type": "blob",
          "size": 3521
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/tasks-template.md",
          "type": "blob",
          "size": 8682
        },
        {
          "path": "skills/speckit-implement-zh",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-implement-zh/SKILL.md",
          "type": "blob",
          "size": 7504
        },
        {
          "path": "skills/speckit-implement-zh/assets",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-implement-zh/assets/dockerignore.template",
          "type": "blob",
          "size": 637
        },
        {
          "path": "skills/speckit-implement-zh/assets/eslintignore.template",
          "type": "blob",
          "size": 946
        },
        {
          "path": "skills/speckit-implement-zh/assets/gitignore.template",
          "type": "blob",
          "size": 1245
        },
        {
          "path": "skills/speckit-implement-zh/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-implement-zh/references/context-loading-order.md",
          "type": "blob",
          "size": 1721
        },
        {
          "path": "skills/speckit-implement-zh/references/ignore-patterns.md",
          "type": "blob",
          "size": 1453
        },
        {
          "path": "skills/speckit-implement-zh/references/implementation-workflow.md",
          "type": "blob",
          "size": 1511
        },
        {
          "path": "skills/speckit-implement-zh/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-implement-zh/scripts/analyze-checklists.ps1",
          "type": "blob",
          "size": 2130
        },
        {
          "path": "skills/speckit-implement-zh/scripts/check-prerequisites.ps1",
          "type": "blob",
          "size": 1570
        },
        {
          "path": "skills/speckit-implement-zh/scripts/detect-project-setup.ps1",
          "type": "blob",
          "size": 2296
        },
        {
          "path": "skills/speckit-plan-zh",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-plan-zh/SKILL.md",
          "type": "blob",
          "size": 2941
        },
        {
          "path": "skills/speckit-plan-zh/assets",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-plan-zh/assets/key-rules.md",
          "type": "blob",
          "size": 206
        },
        {
          "path": "skills/speckit-plan-zh/assets/phase0-research.md",
          "type": "blob",
          "size": 712
        },
        {
          "path": "skills/speckit-plan-zh/assets/phase1-design.md",
          "type": "blob",
          "size": 816
        },
        {
          "path": "skills/speckit-plan-zh/assets/plan-template.md",
          "type": "blob",
          "size": 3579
        },
        {
          "path": "skills/speckit-plan-zh/assets/setup-workflow.md",
          "type": "blob",
          "size": 544
        },
        {
          "path": "skills/speckit-plan-zh/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-plan-zh/references/technical-context.md",
          "type": "blob",
          "size": 1613
        },
        {
          "path": "skills/speckit-plan-zh/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-plan-zh/scripts/bash",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-plan-zh/scripts/bash/check-prerequisites.sh",
          "type": "blob",
          "size": 4975
        },
        {
          "path": "skills/speckit-plan-zh/scripts/bash/common.sh",
          "type": "blob",
          "size": 4909
        },
        {
          "path": "skills/speckit-plan-zh/scripts/bash/create-new-feature.sh",
          "type": "blob",
          "size": 9420
        },
        {
          "path": "skills/speckit-plan-zh/scripts/bash/setup-plan.sh",
          "type": "blob",
          "size": 1617
        },
        {
          "path": "skills/speckit-plan-zh/scripts/bash/update-agent-context.sh",
          "type": "blob",
          "size": 24782
        },
        {
          "path": "skills/speckit-plan-zh/scripts/execute-workflow.ps1",
          "type": "blob",
          "size": 5621
        },
        {
          "path": "skills/speckit-plan-zh/scripts/powershell",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-plan-zh/scripts/powershell/check-prerequisites.ps1",
          "type": "blob",
          "size": 4805
        },
        {
          "path": "skills/speckit-plan-zh/scripts/powershell/common.ps1",
          "type": "blob",
          "size": 3849
        },
        {
          "path": "skills/speckit-plan-zh/scripts/powershell/create-new-feature.ps1",
          "type": "blob",
          "size": 9839
        },
        {
          "path": "skills/speckit-plan-zh/scripts/powershell/setup-plan.ps1",
          "type": "blob",
          "size": 1854
        },
        {
          "path": "skills/speckit-plan-zh/scripts/powershell/update-agent-context.ps1",
          "type": "blob",
          "size": 19246
        },
        {
          "path": "skills/speckit-plan-zh/scripts/setup-plan.ps1",
          "type": "blob",
          "size": 1940
        },
        {
          "path": "skills/speckit-plan-zh/scripts/update-agent-context.ps1",
          "type": "blob",
          "size": 3151
        },
        {
          "path": "skills/speckit-specify-zh",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-specify-zh/SKILL.md",
          "type": "blob",
          "size": 11026
        },
        {
          "path": "skills/speckit-specify-zh/assets",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-specify-zh/assets/clarification-template.md",
          "type": "blob",
          "size": 536
        },
        {
          "path": "skills/speckit-specify-zh/assets/quality-checklist-template.md",
          "type": "blob",
          "size": 1005
        },
        {
          "path": "skills/speckit-specify-zh/assets/spec-template.md",
          "type": "blob",
          "size": 3521
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/memory",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/memory/constitution.md",
          "type": "blob",
          "size": 2047
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/scripts/bash",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/scripts/bash/check-prerequisites.sh",
          "type": "blob",
          "size": 4888
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/scripts/bash/common.sh",
          "type": "blob",
          "size": 4909
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/scripts/bash/create-new-feature.sh",
          "type": "blob",
          "size": 9081
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/scripts/bash/setup-plan.sh",
          "type": "blob",
          "size": 1609
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/scripts/bash/update-agent-context.sh",
          "type": "blob",
          "size": 24368
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/scripts/powershell",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/scripts/powershell/check-prerequisites.ps1",
          "type": "blob",
          "size": 4746
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/scripts/powershell/common.ps1",
          "type": "blob",
          "size": 3854
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/scripts/powershell/create-new-feature.ps1",
          "type": "blob",
          "size": 9623
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/scripts/powershell/setup-plan.ps1",
          "type": "blob",
          "size": 1889
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/scripts/powershell/update-agent-context.ps1",
          "type": "blob",
          "size": 19295
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/agent-file-template.md",
          "type": "blob",
          "size": 433
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/checklist-template.md",
          "type": "blob",
          "size": 1255
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/commands/analyze.md",
          "type": "blob",
          "size": 6582
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/commands/checklist.md",
          "type": "blob",
          "size": 15507
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/commands/clarify.md",
          "type": "blob",
          "size": 10219
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/commands/constitution.md",
          "type": "blob",
          "size": 4629
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/commands/implement.md",
          "type": "blob",
          "size": 7211
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/commands/plan.md",
          "type": "blob",
          "size": 2973
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/commands/specify.md",
          "type": "blob",
          "size": 11279
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/commands/tasks.md",
          "type": "blob",
          "size": 6005
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/constitution-template.md",
          "type": "blob",
          "size": 2047
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/plan-template.md",
          "type": "blob",
          "size": 3579
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/spec-template.md",
          "type": "blob",
          "size": 3521
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/tasks-template.md",
          "type": "blob",
          "size": 8682
        },
        {
          "path": "skills/speckit-specify-zh/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-specify-zh/scripts/bash",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-specify-zh/scripts/bash/check-prerequisites.sh",
          "type": "blob",
          "size": 4975
        },
        {
          "path": "skills/speckit-specify-zh/scripts/bash/common.sh",
          "type": "blob",
          "size": 4909
        },
        {
          "path": "skills/speckit-specify-zh/scripts/bash/create-new-feature.sh",
          "type": "blob",
          "size": 9420
        },
        {
          "path": "skills/speckit-specify-zh/scripts/bash/setup-plan.sh",
          "type": "blob",
          "size": 1617
        },
        {
          "path": "skills/speckit-specify-zh/scripts/bash/update-agent-context.sh",
          "type": "blob",
          "size": 24782
        },
        {
          "path": "skills/speckit-specify-zh/scripts/create-new-feature.ps1",
          "type": "blob",
          "size": 1220
        },
        {
          "path": "skills/speckit-specify-zh/scripts/powershell",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-specify-zh/scripts/powershell/check-prerequisites.ps1",
          "type": "blob",
          "size": 4805
        },
        {
          "path": "skills/speckit-specify-zh/scripts/powershell/common.ps1",
          "type": "blob",
          "size": 3849
        },
        {
          "path": "skills/speckit-specify-zh/scripts/powershell/create-new-feature.ps1",
          "type": "blob",
          "size": 9839
        },
        {
          "path": "skills/speckit-specify-zh/scripts/powershell/setup-plan.ps1",
          "type": "blob",
          "size": 1854
        },
        {
          "path": "skills/speckit-specify-zh/scripts/powershell/update-agent-context.ps1",
          "type": "blob",
          "size": 19246
        },
        {
          "path": "skills/speckit-tasks-zh",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-tasks-zh/SKILL.md",
          "type": "blob",
          "size": 6330
        },
        {
          "path": "skills/speckit-tasks-zh/assets",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-tasks-zh/assets/TASK_EXAMPLES.md",
          "type": "blob",
          "size": 3046
        },
        {
          "path": "skills/speckit-tasks-zh/assets/WORKFLOW.md",
          "type": "blob",
          "size": 2898
        },
        {
          "path": "skills/speckit-tasks-zh/assets/tasks-template.md",
          "type": "blob",
          "size": 2164
        },
        {
          "path": "skills/speckit-tasks-zh/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-tasks-zh/scripts/check-prerequisites.ps1",
          "type": "blob",
          "size": 3516
        },
        {
          "path": "spec",
          "type": "tree",
          "size": null
        },
        {
          "path": "spec/specs",
          "type": "tree",
          "size": null
        },
        {
          "path": "spec/specs/agents-md",
          "type": "tree",
          "size": null
        },
        {
          "path": "spec/specs/agents-md/localization.md",
          "type": "blob",
          "size": 9200
        },
        {
          "path": "spec/specs/cli-commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "spec/specs/cli-commands/install.md",
          "type": "blob",
          "size": 11782
        },
        {
          "path": "spec/specs/cli-commands/sync.md",
          "type": "blob",
          "size": 9975
        },
        {
          "path": "template",
          "type": "tree",
          "size": null
        },
        {
          "path": "template/AGENTS.md",
          "type": "blob",
          "size": 1365
        },
        {
          "path": "template/AGENTS_zh.md",
          "type": "blob",
          "size": 1240
        }
      ],
      "marketplace": {
        "name": "open-skilled-sdd-marketplace",
        "version": null,
        "description": "Official marketplace for Open Spec-Driven Development Claude Code plugin",
        "owner_info": {
          "name": "forztf"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "open-skilled-sdd",
            "description": "open spec-driven development workflow: OpenSpec, PRPs, Spec Kit, spec-workflow-mcp, BMad-Method, 6A workflow",
            "source": "./",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add forztf/open-skilled-sdd",
              "/plugin install open-skilled-sdd@open-skilled-sdd-marketplace"
            ],
            "signals": {
              "stars": 4,
              "forks": 1,
              "pushed_at": "2025-11-28T07:09:48Z",
              "created_at": "2025-11-21T06:14:22Z",
              "license": null
            },
            "commands": [
              {
                "name": "/analyze",
                "description": "在任务生成后，对 spec.md、plan.md 和 tasks.md 进行非破坏性的跨工件一致性和质量分析。",
                "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/analyze.md",
                "frontmatter": {
                  "description": "在任务生成后，对 spec.md、plan.md 和 tasks.md 进行非破坏性的跨工件一致性和质量分析。",
                  "scripts": {
                    "sh": "scripts/bash/check-prerequisites.sh --json --require-tasks --include-tasks",
                    "ps": "scripts/powershell/check-prerequisites.ps1 -Json -RequireTasks -IncludeTasks"
                  }
                },
                "content": "## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 目标\n\n在实现之前，识别三个核心工件（`spec.md`、`plan.md`、`tasks.md`）之间的不一致、重复、歧义和未充分说明的项目。此命令必须仅在 `/speckit.tasks` 成功生成完整的 `tasks.md` 后运行。\n\n## 操作约束\n\n**严格只读**：**不要**修改任何文件。输出结构化分析报告。提供可选的补救计划（用户必须明确批准后才能手动调用任何后续编辑命令）。\n\n**宪章权威性**：项目宪章（`/memory/constitution.md`）在此分析范围内是**不可协商的**。宪章冲突自动为关键级别，需要调整规格、计划或任务——而不是稀释、重新解释或默默忽略原则。如果原则本身需要更改，必须在 `/speckit.analyze` 之外的单独、明确的宪章更新中进行。\n\n## 执行步骤\n\n### 1. 初始化分析上下文\n\n从仓库根目录运行一次 `{SCRIPT}` 并解析 JSON 以获取 FEATURE_DIR 和 AVAILABLE_DOCS。推导绝对路径：\n\n- SPEC = FEATURE_DIR/spec.md\n- PLAN = FEATURE_DIR/plan.md\n- TASKS = FEATURE_DIR/tasks.md\n\n如果缺少任何必需文件，则中止并显示错误消息（指示用户运行缺少的先决条件命令）。\n对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n### 2. 加载工件（渐进式披露）\n\n仅加载每个工件的最小必要上下文：\n\n**来自 spec.md：**\n\n- 概述/上下文\n- 功能要求\n- 非功能要求\n- 用户故事\n- 边缘情况（如果存在）\n\n**来自 plan.md：**\n\n- 架构/技术栈选择\n- 数据模型引用\n- 阶段\n- 技术约束\n\n**来自 tasks.md：**\n\n- 任务 ID\n- 描述\n- 阶段分组\n- 并行标记 [P]\n- 引用的文件路径\n\n**来自 constitution：**\n\n- 加载 `/memory/constitution.md` 用于原则验证\n\n### 3. 构建语义模型\n\n创建内部表示（不要在输出中包含原始工件）：\n\n- **要求清单**：每个功能+非功能要求带有一个稳定键（根据祈使句派生 slug；例如，\"用户可以上传文件\" → `user-can-upload-file`）\n- **用户故事/动作清单**：具有验收标准的离散用户动作\n- **任务覆盖映射**：将每个任务映射到一个或多个要求或故事（通过关键词/显式引用模式如 ID 或关键词进行推断）\n- **宪章规则集**：提取原则名称和 MUST/SHOULD 规范性陈述\n\n### 4. 检测过程（高效令牌分析）\n\n专注于高信号发现。限制总数为 50 个发现；在溢出摘要中聚合其余发现。\n\n#### A. 重复检测\n\n- 识别近似重复的要求\n- 标记质量较低的措辞以进行合并\n\n#### B. 歧义检测\n\n- 标记缺乏可测量标准的模糊形容词（快速、可扩展、安全、直观、健壮）\n- 标记未解决的占位符（TODO、TKTK、???、`<placeholder>` 等）\n\n#### C. 未充分说明\n\n- 有动词但缺少对象或可测量结果的要求\n- 缺少验收标准对齐的用户故事\n- 引用在规格/计划中未定义的文件或组件的任务\n\n#### D. 宪章对齐\n\n- 任何与 MUST 原则冲突的要求或计划元素\n- 缺少宪章中规定的章节或质量门\n\n#### E. 覆盖差距\n\n- 没有关联任务的要求\n- 没有映射要求/故事的任务\n- 未在任务中体现的非功能要求（例如，性能、安全性）\n\n#### F. 不一致\n\n- 术语漂移（同一概念在不同文件中有不同名称）\n- 计划中引用但在规格中缺失的数据实体（反之亦然）\n- 任务排序矛盾（例如，集成任务在基础设置任务之前但没有依赖注释）\n- 冲突的要求（例如，一个要求 Next.js 而另一个指定 Vue）\n\n### 5. 严重性分配\n\n使用此启发式方法来优先处理发现：\n\n- **关键**：违反宪章 MUST、缺少核心规格工件，或阻塞基本功能的零覆盖要求\n- **高**：重复或冲突的要求、模糊的安全/性能属性、不可测试的验收标准\n- **中**：术语漂移、缺少非功能任务覆盖、未充分说明的边缘情况\n- **低**：样式/措辞改进、不影响执行顺序的次要冗余\n\n### 6. 生成紧凑分析报告\n\n输出一个 Markdown 报告（不写入文件）具有以下结构：\n\n## 规格分析报告\n\n| ID | 类别 | 严重性 | 位置 | 摘要 | 建议 |\n|----|----------|----------|-------------|---------|----------------|\n| A1 | 重复 | 高 | spec.md:L120-134 | 两个相似的要求 ... | 合并措辞；保留更清晰的版本 |\n\n（每项发现添加一行；生成以类别首字母为前缀的稳定 ID。）\n\n**覆盖摘要表：**\n\n| 要求键 | 有任务？ | 任务 ID | 备注 |\n|-----------------|-----------|----------|-------|\n\n**宪章对齐问题：**（如果有）\n\n**未映射的任务：**（如果有）\n\n**指标：**\n\n- 总要求\n- 总任务\n- 覆盖率%（有>=1个任务的要求）\n- 歧义计数\n- 重复计数\n- 关键问题计数\n\n### 7. 提供下一步行动\n\n在报告末尾，输出一个简洁的下一步行动块：\n\n- 如果存在关键问题：建议在 `/speckit.implement` 之前解决\n- 如果只有低/中等：用户可以继续，但提供改进建议\n- 提供明确的命令建议：例如，\"使用改进运行 /speckit.specify\"，\"运行 /speckit.plan 调整架构\"，\"手动编辑 tasks.md 添加 'performance-metrics' 的覆盖\"\n\n### 8. 提供补救措施\n\n询问用户：\"您希望我为前 N 个问题建议具体的补救编辑吗？\"（不要自动应用它们。）\n\n## 操作原则\n\n### 上下文效率\n\n- **最小高信号令牌**：专注于可操作的发现，而不是详尽的文档\n- **渐进式披露**：增量加载工件；不要将所有内容倒入分析\n- **高效令牌输出**：限制发现表为 50 行；总结溢出\n- **确定性结果**：在没有更改的情况下重新运行应产生一致的 ID 和计数\n\n### 分析指南\n\n- **永不修改文件**（这是只读分析）\n- **永不虚构缺失部分**（如果缺失，准确报告）\n- **优先处理宪章违规**（这些总是关键的）\n- **使用示例而非详尽规则**（引用具体实例，而非通用模式）\n- **优雅报告零问题**（发出带有覆盖统计的成功报告）\n\n## 上下文\n\n{ARGS}"
              },
              {
                "name": "/checklist",
                "description": "根据用户要求为当前功能生成自定义检查表。",
                "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/checklist.md",
                "frontmatter": {
                  "description": "根据用户要求为当前功能生成自定义检查表。",
                  "scripts": {
                    "sh": "scripts/bash/check-prerequisites.sh --json",
                    "ps": "scripts/powershell/check-prerequisites.ps1 -Json"
                  }
                },
                "content": "## 检查表目的：\"中文的单元测试\"\n\n**关键概念**：检查表是**要求编写的单元测试** - 它们验证特定领域中要求的质量、清晰度和完整性。\n\n**不用于验证/测试**：\n\n- ❌ 不是\"验证按钮正确点击\"\n- ❌ 不是\"测试错误处理是否有效\"\n- ❌ 不是\"确认 API 返回 200\"\n- ❌ 不是检查代码/实现是否符合规格\n\n**用于要求质量验证**：\n\n- ✅ \"是否为所有卡片类型定义了视觉层次要求？\"（完整性）\n- ✅ \"是否用特定的尺寸/定位量化了'显著显示'？\"（清晰度）\n- ✅ \"所有交互元素的悬停状态要求是否一致？\"（一致性）\n- ✅ \"是否为键盘导航定义了可访问性要求？\"（覆盖范围）\n- ✅ \"规格是否定义了徽标图像加载失败时的情况？\"（边缘情况）\n\n**比喻**：如果您的规格是用英语编写的代码，那么检查表就是它的单元测试套件。您正在测试要求是否编写良好、完整、明确并准备好实施 - 而不是测试实现是否有效。\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 执行步骤\n\n1. **设置**：从仓库根目录运行 `{SCRIPT}` 并解析 JSON 以获取 FEATURE_DIR 和 AVAILABLE_DOCS 列表。\n   - 所有文件路径必须是绝对的。\n   - 对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **澄清意图（动态）**：推导出最多三个初始上下文澄清问题（无预设目录）。它们必须：\n   - 从用户的措辞 + 从规格/计划/任务中提取的信号生成\n   - 仅询问会实质性改变检查表内容的信息\n   - 如果在 `$ARGUMENTS` 中已经明确，则单独跳过\n   - 优先考虑精确性而非广度\n\n   生成算法：\n   1. 提取信号：功能领域关键词（例如，auth, latency, UX, API），风险指标（\"critical\", \"must\", \"compliance\"），利益相关者提示（\"QA\", \"review\", \"security team\"）和明确的交付物（\"a11y\", \"rollback\", \"contracts\"）。\n   2. 将信号聚类到候选关注领域（最多 4 个）按相关性排序。\n   3. 识别可能的受众和时机（作者、审阅者、QA、发布）如果不明确。\n   4. 检测缺失的维度：范围广度、深度/严谨性、风险重点、排除边界、可测量的验收标准。\n   5. 从这些原型中制定问题：\n      - 范围细化（例如，\"这应该包括与 X 和 Y 的集成接触点还是仅限于本地模块正确性？\"）\n      - 风险优先级（例如，\"这些潜在风险领域中哪些应该接受强制门控检查？\"）\n      - 深度校准（例如，\"这是一个轻量级的预提交健全性列表还是正式的发布门？\"）\n      - 受众框架（例如，\"这将仅由作者使用还是在 PR 审阅期间由同行使用？\"）\n      - 边界排除（例如，\"我们应该明确排除本轮的性能调优项目吗？\"）\n      - 场景类别差距（例如，\"未检测到恢复流程——回滚/部分故障路径是否在范围内？\"）\n\n   问题格式规则：\n   - 如果提供选项，生成一个紧凑的表格，列：选项 | 候选 | 重要性原因\n   - 限制最多 A-E 个选项；如果自由形式答案更清晰则省略表格\n   - 永远不要要求用户重述他们已经说过的话\n   - 避免推测性类别（无幻觉）。如果不确定，明确询问：\"确认 X 是否在范围内。\"\n\n   无法交互时的默认值：\n   - 深度：标准\n   - 受众：如果与代码相关则为审阅者（PR）；否则为作者\n   - 关注：前 2 个相关性聚类\n\n   输出问题（标记 Q1/Q2/Q3）。回答后：如果≥2 个场景类别（替代/异常/恢复/非功能性领域）仍不清楚，您可以要求最多两个更有针对性的后续问题（Q4/Q5），每个问题附带一行理由（例如，\"未解决的恢复路径风险\"）。不要超过五个总问题。如果用户明确拒绝更多问题则跳过升级。\n\n3. **理解用户请求**：结合 `$ARGUMENTS` + 澄清答案：\n   - 推导检查表主题（例如，安全、审阅、部署、用户体验）\n   - 整合用户提到的明确必备项目\n   - 将焦点选择映射到类别脚手架\n   - 从规格/计划/任务中推断任何缺失的上下文（不要幻觉）\n\n4. **加载功能上下文**：从 FEATURE_DIR 读取：\n   - spec.md：功能要求和范围\n   - plan.md（如果存在）：技术细节、依赖关系\n   - tasks.md（如果存在）：实施任务\n\n   **上下文加载策略**：\n   - 仅加载与活跃关注领域相关的必要部分（避免完整文件转储）\n   - 更喜欢将长段落总结为简洁的场景/要求要点\n   - 使用渐进式披露：仅在检测到差距时添加后续检索\n   - 如果源文档很大，生成中间摘要项目而不是嵌入原始文本\n\n5. **生成检查表** - 创建\"要求的单元测试\"：\n   - 如果不存在则创建 `FEATURE_DIR/checklists/` 目录\n   - 生成唯一的检查表文件名：\n     - 使用基于领域的简短描述性名称（例如，`ux.md`, `api.md`, `security.md`）\n     - 格式：`[domain].md`\n     - 如果文件存在，则追加到现有文件\n   - 从 CHK001 开始顺序编号项目\n   - 每个 `/speckit.checklist` 运行创建一个新文件（从不覆盖现有检查表）\n\n   **核心原则 - 测试要求，而不是实现**：\n   每个检查表项目必须评估要求本身：\n   - **完整性**：所有必要的要求是否存在？\n   - **清晰度**：要求是否明确且具体？\n   - **一致性**：要求是否相互对齐？\n   - **可测量性**：要求是否可以客观验证？\n   - **覆盖范围**：是否解决了所有场景/边缘情况？\n\n   **类别结构** - 按要求质量维度分组项目：\n   - **要求完整性**（是否记录了所有必要的要求？）\n   - **要求清晰度**（要求是否具体且明确？）\n   - **要求一致性**（要求是否对齐而无冲突？）\n   - **验收标准质量**（成功标准是否可测量？）\n   - **场景覆盖**（是否解决了所有流程/案例？）\n   - **边缘情况覆盖**（是否定义了边界条件？）\n   - **非功能性要求**（性能、安全性、可访问性等 - 是否指定？）\n   - **依赖关系和假设**（是否记录和验证？）\n   - **歧义和冲突**（需要澄清什么？）\n\n   **如何编写检查表项目 - \"英语的单元测试\"**：\n\n   ❌ **错误**（测试实现）：\n   - \"验证着陆页显示 3 个剧集卡片\"\n   - \"测试桌面端悬停状态是否有效\"\n   - \"确认徽标点击导航到主页\"\n\n   ✅ **正确**（测试要求质量）：\n   - \"是否明确指定了特色剧集的确切数量和布局？\" [完整性]\n   - \"是否用特定的尺寸/定位量化了'显著显示'？\" [清晰度]\n   - \"所有交互元素的悬停状态要求是否一致？\" [一致性]\n   - \"是否为所有交互式 UI 定义了键盘导航要求？\" [覆盖范围]\n   - \"当徽标图像加载失败时是否指定了回退行为？\" [边缘情况]\n   - \"是否为异步剧集数据定义了加载状态？\" [完整性]\n   - \"规格是否定义了竞争 UI 元素的视觉层次？\" [清晰度]\n\n   **项目结构**：\n   每个项目应遵循此模式：\n   - 询问要求质量的问题格式\n   - 关注规格/计划中编写（或未编写）的内容\n   - 包括质量维度在括号中 [完整性/清晰度/一致性等]\n   - 检查现有要求时引用规格部分 `[Spec §X.Y]`\n   - 使用 `[Gap]` 标记检查缺失的要求\n\n   **按质量维度的示例**：\n\n   完整性：\n   - \"是否为所有 API 故障模式定义了错误处理要求？ [Gap]\"\n   - \"是否为所有交互元素指定了可访问性要求？ [完整性]\"\n   - \"是否为响应式布局定义了移动断点要求？ [Gap]\"\n\n   清晰度：\n   - \"是否用特定的时间阈值量化了'快速加载'？ [清晰度, Spec §NFR-2]\"\n   - \"是否明确定义了'相关剧集'的选择标准？ [清晰度, Spec §FR-5]\"\n   - \"是否用可测量的视觉属性定义了'显著'？ [歧义, Spec §FR-4]\"\n\n   一致性：\n   - \"所有页面的导航要求是否对齐？ [一致性, Spec §FR-10]\"\n   - \"着陆页和详情页的卡片组件要求是否一致？ [一致性]\"\n\n   覆盖范围：\n   - \"是否为零状态场景（无剧集）定义了要求？ [覆盖范围, 边缘情况]\"\n   - \"是否解决了并发用户交互场景？ [覆盖范围, Gap]\"\n   - \"是否为部分数据加载失败指定了要求？ [覆盖范围, 异常流程]\"\n\n   可测量性：\n   - \"视觉层次要求是否可测量/可测试？ [验收标准, Spec §FR-1]\"\n   - \"是否可以客观验证'平衡的视觉权重'？ [可测量性, Spec §FR-2]\"\n\n   **场景分类和覆盖**（要求质量重点）：\n   - 检查是否存在要求：主要、替代、异常/错误、恢复、非功能性场景\n   - 对于每个场景类别，询问：\"[场景类型] 要求是否完整、清晰且一致？\"\n   - 如果场景类别缺失：\"[场景类型] 要求是故意排除还是缺失？ [Gap]\"\n   - 包括状态变更时的弹性/回滚：\"是否为迁移失败定义了回滚要求？ [Gap]\"\n\n   **可追溯性要求**：\n   - 最低要求：≥80% 的项目必须至少包含一个可追溯性引用\n   - 每个项目应引用：规格部分 `[Spec §X.Y]`，或使用标记：`[Gap]`、`[Ambiguity]`、`[Conflict]`、`[Assumption]`\n   - 如果不存在 ID 系统：\"是否建立了要求和验收标准 ID 方案？ [可追溯性]\"\n\n   **表面和解决问题**（要求质量问题）：\n   询问有关要求本身的问题：\n   - 歧义：\"'快速' 一词是否用具体指标量化？ [歧义, Spec §NFR-1]\"\n   - 冲突：\"§FR-10 和 §FR-10a 中的导航要求是否冲突？ [冲突]\"\n   - 假设：\"'始终可用的播客 API' 假设是否已验证？ [假设]\"\n   - 依赖关系：\"是否记录了外部播客 API 要求？ [依赖关系, Gap]\"\n   - 缺失定义：\"是否用可测量的标准定义了'视觉层次'？ [Gap]\"\n\n   **内容整合**：\n   - 软上限：如果原始候选项目 > 40，按风险/影响优先排序\n   - 合并检查相同要求方面的近似重复项\n   - 如果 >5 个低影响边缘情况，创建一个项目：\"边缘情况 X、Y、Z 是否在要求中解决？ [覆盖范围]\"\n\n   **🚫 绝对禁止** - 这些使其成为实现测试，而不是要求测试：\n   - ❌ 任何以\"验证\"、\"测试\"、\"确认\"、\"检查\" + 实现行为开头的项目\n   - ❌ 引用代码执行、用户操作、系统行为\n   - ❌ \"正确显示\"、\"正常工作\"、\"按预期功能\"\n   - ❌ \"点击\"、\"导航\"、\"渲染\"、\"加载\"、\"执行\"\n   - ❌ 测试用例、测试计划、QA 程序\n   - ❌ 实现细节（框架、API、算法）\n\n   **✅ 必需模式** - 这些测试要求质量：\n   - ✅ \"是否为 [场景] 定义/指定/记录了 [要求类型]？\"\n   - ✅ \"是否用具体标准量化/澄清了 [模糊术语]？\"\n   - ✅ \"[部分 A] 和 [部分 B] 的要求是否一致？\"\n   - ✅ \"是否可以客观测量/验证 [要求]？\"\n   - ✅ \"要求中是否解决了 [边缘情况/场景]？\"\n   - ✅ \"规格是否定义了 [缺失方面]？\"\n\n6. **结构参考**：按照 `templates/checklist-template.md` 中的规范模板生成检查表，包括标题、元部分、类别标题和 ID 格式。如果模板不可用，使用：H1 标题、目的/创建的元行、包含 `- [ ] CHK### <要求项目>` 行的 `##` 类别部分，全局递增 ID 从 CHK001 开始。\n\n7. **报告**：输出创建的检查表的完整路径、项目计数，并提醒用户每次运行都会创建一个新文件。总结：\n   - 选择的关注领域\n   - 深度级别\n   - 参与者/时机\n   - 任何包含的用户明确指定的必备项目\n\n**重要**：每个 `/speckit.checklist` 命令调用都使用简短的描述性名称创建检查表文件，除非文件已存在。这允许：\n\n- 不同类型的多个检查表（例如，`ux.md`, `test.md`, `security.md`）\n- 简单、易记的文件名，指示检查表目的\n- 在 `checklists/` 文件夹中轻松识别和导航\n\n为避免混乱，使用描述性类型并在完成后清理过时的检查表。\n\n## 示例检查表类型和示例项目\n\n**用户体验要求质量：** `ux.md`\n\n示例项目（测试要求，而不是实现）：\n\n- \"是否用可测量的标准定义了视觉层次要求？ [清晰度, Spec §FR-1]\"\n- \"是否明确定义了 UI 元素的数量和定位？ [完整性, Spec §FR-1]\"\n- \"交互状态要求（悬停、焦点、活动）是否一致定义？ [一致性]\"\n- \"是否为所有交互元素指定了可访问性要求？ [覆盖范围, Gap]\"\n- \"图像加载失败时是否定义了回退行为？ [边缘情况, Gap]\"\n- \"是否可以客观测量'显著显示'？ [可测量性, Spec §FR-4]\"\n\n**API 要求质量：** `api.md`\n\n示例项目：\n\n- \"是否为所有故障场景指定了错误响应格式？ [完整性]\"\n- \"是否用具体阈值量化了速率限制要求？ [清晰度]\"\n- \"所有端点的身份验证要求是否一致？ [一致性]\"\n- \"是否为外部依赖关系定义了重试/超时要求？ [覆盖范围, Gap]\"\n- \"版本控制策略是否在要求中记录？ [Gap]\"\n\n**性能要求质量：** `performance.md`\n\n示例项目：\n\n- \"是否用具体指标量化了性能要求？ [清晰度]\"\n- \"是否为所有关键用户旅程定义了性能目标？ [覆盖范围]\"\n- \"是否为不同负载条件指定了性能要求？ [完整性]\"\n- \"是否可以客观测量性能要求？ [可测量性]\"\n- \"是否为高负载场景定义了降级要求？ [边缘情况, Gap]\"\n\n**安全要求质量：** `security.md`\n\n示例项目：\n\n- \"是否为所有受保护资源指定了身份验证要求？ [覆盖范围]\"\n- \"是否为敏感信息定义了数据保护要求？ [完整性]\"\n- \"威胁模型是否记录并与要求对齐？ [可追溯性]\"\n- \"安全要求是否与合规义务一致？ [一致性]\"\n- \"是否定义了安全故障/违规响应要求？ [Gap, 异常流程]\"\n\n## 反例：不要做的事情\n\n**❌ 错误 - 这些测试实现，而不是要求：**\n\n```markdown\n- [ ] CHK001 - 验证着陆页显示 3 个剧集卡片 [Spec §FR-001]\n- [ ] CHK002 - 测试桌面端悬停状态是否正确工作 [Spec §FR-003]\n- [ ] CHK003 - 确认徽标点击导航到主页 [Spec §FR-010]\n- [ ] CHK004 - 检查相关剧集部分显示 3-5 个项目 [Spec §FR-005]\n```\n\n**✅ 正确 - 这些测试要求质量：**\n\n```markdown\n- [ ] CHK001 - 是否明确定义了特色剧集的数量和布局？ [完整性, Spec §FR-001]\n- [ ] CHK002 - 是否为所有交互元素一致定义了悬停状态要求？ [一致性, Spec §FR-003]\n- [ ] CHK003 - 是否为所有可点击品牌元素明确了导航要求？ [清晰度, Spec §FR-010]\n- [ ] CHK004 - 是否记录了相关剧集的选择标准？ [Gap, Spec §FR-005]\n- [ ] CHK005 - 是否为异步剧集数据定义了加载状态要求？ [Gap]\n- [ ] CHK006 - 是否可以客观测量\"视觉层次\"要求？ [可测量性, Spec §FR-001]\n```\n\n**主要区别：**\n\n- 错误：测试系统是否正常工作\n- 正确：测试要求是否编写正确\n- 错误：行为验证\n- 正确：要求质量验证\n- 错误：\"它是否做 X？\"\n- 正确：\"X 是否明确定义？\""
              },
              {
                "name": "/clarify",
                "description": "通过提出最多 5 个高度针对性的澄清问题并将其答案编码回规格中，识别当前功能规格中未充分说明的领域。",
                "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/clarify.md",
                "frontmatter": {
                  "description": "通过提出最多 5 个高度针对性的澄清问题并将其答案编码回规格中，识别当前功能规格中未充分说明的领域。",
                  "scripts": {
                    "sh": "scripts/bash/check-prerequisites.sh --json --paths-only",
                    "ps": "scripts/powershell/check-prerequisites.ps1 -Json -PathsOnly"
                  }
                },
                "content": "## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n目标：检测并减少活动功能规格中的歧义或缺失决策点，并将澄清直接记录在规格文件中。\n\n注意：此澄清工作流程预计在调用 `/speckit.plan` 之前运行（并完成）。如果用户明确表示他们正在跳过澄清（例如，探索性刺探），您可以继续，但必须警告下游返工风险会增加。\n\n执行步骤：\n\n1. 从仓库根目录运行一次 `{SCRIPT}`（组合 `--json --paths-only` 模式 / `-Json -PathsOnly`）。解析最小 JSON 负载字段：\n   - `FEATURE_DIR`\n   - `FEATURE_SPEC`\n   - （可选捕获 `IMPL_PLAN`, `TASKS` 用于未来的链式流程。）\n   - 如果 JSON 解析失败，则中止并指示用户重新运行 `/speckit.specify` 或验证功能分支环境。\n   - 对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. 加载当前规格文件。使用此分类法执行结构化歧义和覆盖扫描。对于每个类别，标记状态：清晰 / 部分 / 缺失。生成用于优先级排序的内部覆盖图（除非不问问题，否则不要输出原始图）。\n\n   功能范围和行为：\n   - 核心用户目标和成功标准\n   - 明确的范围外声明\n   - 用户角色 / 人物区分\n\n   领域和数据模型：\n   - 实体、属性、关系\n   - 身份和唯一性规则\n   - 生命周期/状态转换\n   - 数据量 / 规模假设\n\n   交互和用户体验流程：\n   - 关键用户旅程 / 序列\n   - 错误/空/加载状态\n   - 可访问性或本地化注释\n\n   非功能性质量属性：\n   - 性能（延迟、吞吐量目标）\n   - 可扩展性（水平/垂直、限制）\n   - 可靠性和可用性（正常运行时间、恢复期望）\n   - 可观察性（日志、指标、跟踪信号）\n   - 安全性和隐私（认证/授权、数据保护、威胁假设）\n   - 合规性 / 监管约束（如果有）\n\n   集成和外部依赖：\n   - 外部服务/API 和故障模式\n   - 数据导入/导出格式\n   - 协议/版本假设\n\n   边缘情况和故障处理：\n   - 负面场景\n   - 速率限制 / 节流\n   - 冲突解决（例如，并发编辑）\n\n   约束和权衡：\n   - 技术约束（语言、存储、托管）\n   - 明确的权衡或被拒绝的替代方案\n\n   术语和一致性：\n   - 规范术语表\n   - 避免的同义词 / 废弃术语\n\n   完成信号：\n   - 验收标准可测试性\n   - 可测量的完成定义风格指标\n\n   杂项 / 占位符：\n   - TODO 标记 / 未解决的决策\n   - 缺乏量化的模糊形容词（\"健壮的\"、\"直观的\"）\n\n   对于状态为部分或缺失的每个类别，添加一个候选问题机会，除非：\n   - 澄清不会实质性改变实施或验证策略\n   - 信息最好推迟到规划阶段（内部记录）\n\n3. 生成（内部）优先级候选澄清问题队列（最多 5 个）。不要一次性输出所有问题。应用这些约束：\n    - 整个会话最多 10 个问题。\n    - 每个问题必须可以通过以下方式回答：\n       - 短的多项选择（2-5 个不同的、互斥的选项），或\n       - 一个单词 / 短语答案（明确约束：\"答案 <=5 个单词\"）。\n    - 仅包括其答案实质性影响架构、数据建模、任务分解、测试设计、用户体验行为、运营准备或合规性验证的问题。\n    - 确保类别覆盖平衡：尝试首先覆盖最高影响的未解决类别；避免在单个高影响领域（例如，安全态势）未解决时问两个低影响问题。\n    - 排除已经回答的问题、琐碎的风格偏好或计划级执行细节（除非阻塞正确性）。\n    - 优先考虑减少下游返工风险或防止不一致验收测试的澄清。\n    - 如果超过 5 个类别仍未解决，按（影响 * 不确定性）启发式选择前 5 个。\n\n4. 顺序提问循环（交互式）：\n    - 一次只提出一个问题。\n    - 对于多项选择问题：\n       - **分析所有选项**并根据以下确定**最合适的选项**：\n          - 项目类型的最佳实践\n          - 类似实现中的常见模式\n          - 风险降低（安全性、性能、可维护性）\n          - 与规格中可见的任何明确项目目标或约束对齐\n       - 突出显示您的**推荐选项**在顶部，并提供明确的理由（1-2 句解释为什么这是最佳选择）。\n       - 格式为：`**推荐：** 选项 [X] - <理由>`\n       - 然后将所有选项呈现为 Markdown 表格：\n\n       | 选项 | 描述 |\n       |--------|-------------|\n       | A | <选项 A 描述> |\n       | B | <选项 B 描述> |\n       | C | <选项 C 描述>（根据需要添加 D/E 至多 5 个） |\n       | 简短 | 提供不同的简短答案（<=5 个单词）（仅在自由形式替代方案适当时包含） |\n\n       - 表格后添加：`您可以回复选项字母（例如，\"A\"），通过说\"yes\"或\"recommended\"接受推荐，或提供您自己的简短答案。`\n    - 对于简短答案风格（无有意义的离散选项）：\n       - 提供您的**建议答案**基于最佳实践和上下文。\n       - 格式为：`**建议：** <您的建议答案> - <简要理由>`\n       - 然后输出：`格式：简短答案（<=5 个单词）。您可以通过说\"yes\"或\"suggested\"接受建议，或提供您自己的答案。`\n    - 用户回答后：\n       - 如果用户回复\"yes\"、\"recommended\"或\"suggested\"，使用您之前声明的推荐/建议作为答案。\n       - 否则，验证答案映射到一个选项或符合 <=5 个单词的约束。\n       - 如果模糊，要求快速澄清（计数仍属于同一问题；不要前进）。\n       - 一旦满意，将其记录在工作内存中（尚不写入磁盘）并移至下一个排队问题。\n    - 停止进一步提问当：\n       - 所有关键歧义提前解决（剩余排队项目变得不必要），或\n       - 用户发出完成信号（\"done\"、\"good\"、\"no more\"），或\n       - 您达到 5 个已问问题。\n    - 永远不要提前透露未来排队的问题。\n    - 如果开始时没有有效问题，立即报告没有关键歧义。\n\n5. 每个接受答案后的集成（增量更新方法）：\n    - 维护规格的内存表示（启动时加载一次）加上原始文件内容。\n    - 对于此会话中的第一个集成答案：\n       - 确保存在 `## Clarifications` 部分（如果缺失，则在规格模板中最高级上下文/概述部分之后创建）。\n       - 在其下创建（如果不存在）一个 `### Session YYYY-MM-DD` 子标题用于今天。\n    - 接受后立即追加一个项目符号行：`- Q: <问题> → A: <最终答案>`。\n    - 然后立即将澄清应用到最合适的部分：\n       - 功能歧义 → 更新或在功能要求中添加项目符号。\n       - 用户交互 / 行为者区分 → 更新用户故事或行为者子部分（如果存在）与澄清的角色、约束或场景。\n       - 数据形状 / 实体 → 更新数据模型（添加字段、类型、关系）保持排序；简洁地记录添加的约束。\n       - 非功能性约束 → 在非功能性 / 质量属性部分添加/修改可测量标准（将模糊形容词转换为指标或明确目标）。\n       - 边缘情况 / 负面流程 → 在边缘情况 / 错误处理下添加新项目符号（或创建此类子部分如果模板提供占位符）。\n       - 术语冲突 → 规范化整个规格中的术语；仅在必要时保留原始术语，添加`(以前称为\"X\")`一次。\n    - 如果澄清使早期模糊声明无效，则替换该声明而不是重复；不留过时的矛盾文本。\n    - 每次集成后保存规格文件以最小化上下文丢失风险（原子覆盖）。\n    - 保持格式：不要重新排序无关部分；保持标题层次结构完整。\n    - 保持每个插入的澄清最小且可测试（避免叙述性漂移）。\n\n6. 验证（每次写入后执行加上最终通过）：\n   - 澄清会话包含每个接受答案的一个项目符号（无重复）。\n   - 总问（接受）问题 ≤ 5。\n   - 更新部分不包含新的答案应该解决的模糊占位符。\n   - 无矛盾的早期声明保留（扫描移除的无效替代选择）。\n   - Markdown 结构有效；仅允许新标题：`## Clarifications`, `### Session YYYY-MM-DD`。\n   - 术语一致性：所有更新部分使用相同的规范术语。\n\n7. 将更新的规格写回 `FEATURE_SPEC`。\n\n8. 报告完成（提问循环结束或提前终止后）：\n   - 问和回答的问题数量。\n   - 更新规格的路径。\n   - 触及的部分（列出名称）。\n   - 覆盖摘要表列出每个分类类别，状态：已解决（之前部分/缺失并已解决）、推迟（超出问题配额或更适合规划）、清晰（已足够）、未解决（仍部分/缺失但影响低）。\n   - 如果有任何未解决或推迟的，建议是否继续到 `/speckit.plan` 或稍后再次运行 `/speckit.clarify`。\n   - 建议的下一个命令。\n\n行为规则：\n\n- 如果未发现有意义的歧义（或所有潜在问题都是低影响的），回应：\"未检测到值得正式澄清的关键歧义。\"并建议继续。\n- 如果规格文件缺失，指示用户先运行 `/speckit.specify`（不要在此处创建新规格）。\n- 永远不要超过 5 个总问问题（澄清重试单个问题不计入新问题）。\n- 避免推测性技术栈问题，除非缺失会阻塞功能清晰度。\n- 尊重用户提前终止信号（\"stop\"、\"done\"、\"proceed\"）。\n- 如果由于完全覆盖而未问问题，输出紧凑的覆盖摘要（所有类别清晰）然后建议前进。\n- 如果配额达到但仍有未解决的高影响类别，明确标记它们为推迟并附上理由。\n\n优先级上下文：{ARGS}"
              },
              {
                "name": "/constitution",
                "description": "根据交互式或提供的原则输入创建或更新项目宪章，确保所有依赖模板保持同步",
                "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/constitution.md",
                "frontmatter": {
                  "description": "根据交互式或提供的原则输入创建或更新项目宪章，确保所有依赖模板保持同步"
                },
                "content": "## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n您正在更新位于 `/memory/constitution.md` 的项目宪章。此文件是一个模板，包含方括号中的占位符标记（例如 `[PROJECT_NAME]`, `[PRINCIPLE_1_NAME]`）。您的工作是 (a) 收集/推导具体值，(b) 精确填充模板，以及 (c) 传播任何修订到依赖工件。\n\n遵循此执行流程：\n\n1. 加载位于 `/memory/constitution.md` 的现有宪章模板。\n   - 识别形式为 `[ALL_CAPS_IDENTIFIER]` 的每个占位符标记。\n   **重要**：用户可能需要比模板中使用的更少或更多的原则。如果指定了数量，请尊重 - 遵循通用模板。您将相应地更新文档。\n\n2. 收集/推导占位符的值：\n   - 如果用户输入（对话）提供了值，则使用它。\n   - 否则从现有仓库上下文（README、文档、先前的宪章版本（如果嵌入））推断。\n   - 对于治理日期：`RATIFICATION_DATE` 是原始采用日期（如果未知则询问或标记 TODO），`LAST_AMENDED_DATE` 是今天如果进行了更改，否则保持先前日期。\n   - `CONSTITUTION_VERSION` 必须根据语义版本规则递增：\n     - MAJOR：向后不兼容的治理/原则删除或重新定义。\n     - MINOR：添加新原则/部分或实质性扩展指导。\n     - PATCH：澄清、措辞、拼写错误修复、非语义性改进。\n   - 如果版本提升类型不明确，在最终确定前提出理由。\n\n3. 起草更新的宪章内容：\n   - 用具体文本替换每个占位符（除了项目选择尚未定义的故意保留的模板槽位 - 明确说明任何保留的槽位）。\n   - 保持标题层次结构，注释可以在替换后删除，除非它们仍然提供澄清指导。\n   - 确保每个原则部分：简洁的名称行，段落（或项目符号列表）捕获不可协商的规则，如果不是显而易见则提供明确的理由。\n   - 确保治理部分列出修订程序、版本政策和合规性审查期望。\n\n4. 一致性传播检查表（将先前的检查表转换为积极验证）：\n   - 读取 `/templates/plan-template.md` 并确保任何\"宪章检查\"或规则与更新的原则对齐。\n   - 读取 `/templates/spec-template.md` 以对齐范围/要求 - 如果宪章添加/删除了强制性部分或约束则更新。\n   - 读取 `/templates/tasks-template.md` 并确保任务分类反映新增或删除的原则驱动任务类型（例如，可观察性、版本控制、测试纪律）。\n   - 读取 `/templates/commands/*.md` 中的每个命令文件（包括此文件）以验证没有过时的引用（仅当需要通用指导时保留特定代理名称如 CLAUDE）。\n   - 读取任何运行时指导文档（例如，`README.md`, `docs/quickstart.md`，或特定代理指导文件（如果存在））。更新对更改原则的引用。\n\n5. 生成同步影响报告（在更新后作为 HTML 注释预置在宪章文件顶部）：\n   - 版本变更：旧 → 新\n   - 修改的原则列表（旧标题 → 新标题如果重命名）\n   - 添加的部分\n   - 删除的部分\n   - 需要更新的模板（✅ 已更新 / ⚠ 待处理）及文件路径\n   - 如果有任何占位符故意推迟则列出。\n\n6. 最终输出前的验证：\n   - 没有剩余的未解释括号标记。\n   - 版本行与报告匹配。\n   - 日期为 ISO 格式 YYYY-MM-DD。\n   - 原则是陈述性的、可测试的，并且没有模糊语言（\"应该\" → 在适当时替换为 MUST/SHOULD 理由）。\n\n7. 将完成的宪章写回 `/memory/constitution.md`（覆盖）。\n\n8. 向用户输出最终摘要：\n   - 新版本和提升理由。\n   - 任何标记为手动跟进的文件。\n   - 建议的提交消息（例如，`docs: 修订宪章至 vX.Y.Z（原则添加 + 治理更新）`）。\n\n格式和样式要求：\n\n- 完全按照模板中的 Markdown 标题使用（不要降级/升级级别）。\n- 包装长理由行以保持可读性（理想情况下 <100 个字符），但不要用尴尬的断行强制执行。\n- 在部分之间保持单个空行。\n- 避免尾随空格。\n\n如果用户提供部分更新（例如，仅一个原则修订），仍执行验证和版本决策步骤。\n\n如果关键信息缺失（例如，批准日期真正未知），插入 `TODO(<FIELD_NAME>): explanation` 并在同步影响报告的推迟项目下列出。\n\n不要创建新模板；始终在现有的 `/memory/constitution.md` 文件上操作。"
              },
              {
                "name": "/implement",
                "description": "通过处理和执行 tasks.md 中定义的所有任务来执行实现计划",
                "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/implement.md",
                "frontmatter": {
                  "description": "通过处理和执行 tasks.md 中定义的所有任务来执行实现计划",
                  "scripts": {
                    "sh": "scripts/bash/check-prerequisites.sh --json --require-tasks --include-tasks",
                    "ps": "scripts/powershell/check-prerequisites.ps1 -Json -RequireTasks -IncludeTasks"
                  }
                },
                "content": "## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n1. 从仓库根目录运行 `{SCRIPT}` 并解析 FEATURE_DIR 和 AVAILABLE_DOCS 列表。所有路径必须是绝对的。对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **检查检查表状态**（如果 FEATURE_DIR/checklists/ 存在）：\n   - 扫描 checklists/ 目录中的所有检查表文件\n   - 对于每个检查表，计数：\n     - 总项目：所有匹配 `- [ ]` 或 `- [X]` 或 `- [x]` 的行\n     - 完成项目：匹配 `- [X]` 或 `- [x]` 的行\n     - 未完成项目：匹配 `- [ ]` 的行\n   - 创建状态表：\n\n     ```text\n     | 检查表 | 总计 | 已完成 | 未完成 | 状态 |\n     |-----------|-------|-----------|------------|--------|\n     | ux.md     | 12    | 12        | 0          | ✓ 通过 |\n     | test.md   | 8     | 5         | 3          | ✗ 失败 |\n     | security.md | 6   | 6         | 0          | ✓ 通过 |\n     ```\n\n   - 计算总体状态：\n     - **通过**：所有检查表都有 0 个未完成项目\n     - **失败**：一个或多个检查表有未完成项目\n\n   - **如果有任何检查表未完成**：\n     - 显示包含未完成项目计数的表格\n     - **停止**并询问：\"一些检查表未完成。您是否仍要继续执行实现？(yes/no)\"\n     - 等待用户响应后再继续\n     - 如果用户说\"no\"或\"wait\"或\"stop\"，则停止执行\n     - 如果用户说\"yes\"或\"proceed\"或\"continue\"，则继续到步骤 3\n\n   - **如果所有检查表都完成**：\n     - 显示表格显示所有检查表已通过\n     - 自动继续到步骤 3\n\n3. 加载和分析实现上下文：\n   - **必需**：读取 tasks.md 以获取完整的任务列表和执行计划\n   - **必需**：读取 plan.md 以获取技术栈、架构和文件结构\n   - **如果存在**：读取 data-model.md 以获取实体和关系\n   - **如果存在**：读取 contracts/ 以获取 API 规范和测试要求\n   - **如果存在**：读取 research.md 以获取技术决策和约束\n   - **如果存在**：读取 quickstart.md 以获取集成场景\n\n4. **项目设置验证**：\n   - **必需**：根据实际项目设置创建/验证忽略文件：\n\n   **检测和创建逻辑**：\n   - 检查以下命令是否成功以确定仓库是否为 git 仓库（如果是则创建/验证 .gitignore）：\n\n     ```sh\n     git rev-parse --git-dir 2>/dev/null\n     ```\n\n   - 检查是否存在 Dockerfile* 或 Docker 在 plan.md 中 → 创建/验证 .dockerignore\n   - 检查是否存在 .eslintrc* 或 eslint.config.* → 创建/验证 .eslintignore\n   - 检查是否存在 .prettierrc* → 创建/验证 .prettierignore\n   - 检查是否存在 .npmrc 或 package.json → 创建/验证 .npmignore（如果发布）\n   - 检查是否存在 terraform 文件 (*.tf) → 创建/验证 .terraformignore\n   - 检查是否需要 .helmignore（存在 helm 图表）→ 创建/验证 .helmignore\n\n   **如果忽略文件已存在**：验证它包含基本模式，仅追加缺失的关键模式\n   **如果忽略文件缺失**：创建包含检测技术的完整模式集\n\n   **按技术的常见模式**（来自 plan.md 技术栈）：\n   - **Node.js/JavaScript/TypeScript**：`node_modules/`, `dist/`, `build/`, `*.log`, `.env*`\n   - **Python**：`__pycache__/`, `*.pyc`, `.venv/`, `venv/`, `dist/`, `*.egg-info/`\n   - **Java**：`target/`, `*.class`, `*.jar`, `.gradle/`, `build/`\n   - **C#/.NET**：`bin/`, `obj/`, `*.user`, `*.suo`, `packages/`\n   - **Go**：`*.exe`, `*.test`, `vendor/`, `*.out`\n   - **Ruby**：`.bundle/`, `log/`, `tmp/`, `*.gem`, `vendor/bundle/`\n   - **PHP**：`vendor/`, `*.log`, `*.cache`, `*.env`\n   - **Rust**：`target/`, `debug/`, `release/`, `*.rs.bk`, `*.rlib`, `*.prof*`, `.idea/`, `*.log`, `.env*`\n   - **Kotlin**：`build/`, `out/`, `.gradle/`, `.idea/`, `*.class`, `*.jar`, `*.iml`, `*.log`, `.env*`\n   - **C++**：`build/`, `bin/`, `obj/`, `out/`, `*.o`, `*.so`, `*.a`, `*.exe`, `*.dll`, `.idea/`, `*.log`, `.env*`\n   - **C**：`build/`, `bin/`, `obj/`, `out/`, `*.o`, `*.a`, `*.so`, `*.exe`, `Makefile`, `config.log`, `.idea/`, `*.log`, `.env*`\n   - **Swift**：`.build/`, `DerivedData/`, `*.swiftpm/`, `Packages/`\n   - **R**：`.Rproj.user/`, `.Rhistory`, `.RData`, `.Ruserdata`, `*.Rproj`, `packrat/`, `renv/`\n   - **通用**：`.DS_Store`, `Thumbs.db`, `*.tmp`, `*.swp`, `.vscode/`, `.idea/`\n\n   **工具特定模式**：\n   - **Docker**：`node_modules/`, `.git/`, `Dockerfile*`, `.dockerignore`, `*.log*`, `.env*`, `coverage/`\n   - **ESLint**：`node_modules/`, `dist/`, `build/`, `coverage/`, `*.min.js`\n   - **Prettier**：`node_modules/`, `dist/`, `build/`, `coverage/`, `package-lock.json`, `yarn.lock`, `pnpm-lock.yaml`\n   - **Terraform**：`.terraform/`, `*.tfstate*`, `*.tfvars`, `.terraform.lock.hcl`\n   - **Kubernetes/k8s**：`*.secret.yaml`, `secrets/`, `.kube/`, `kubeconfig*`, `*.key`, `*.crt`\n\n5. 解析 tasks.md 结构并提取：\n   - **任务阶段**：设置、测试、核心、集成、完善\n   - **任务依赖**：顺序与并行执行规则\n   - **任务详情**：ID、描述、文件路径、并行标记 [P]\n   - **执行流程**：顺序和依赖要求\n\n6. 按照任务计划执行实现：\n   - **阶段执行**：完成每个阶段后再进入下一个\n   - **尊重依赖**：按顺序运行顺序任务，并行任务 [P] 可以一起运行  \n   - **遵循 TDD 方法**：在相应的实现任务之前执行测试任务\n   - **基于文件的协调**：影响相同文件的任务必须顺序运行\n   - **验证检查点**：在继续之前验证每个阶段的完成情况\n\n7. 实现执行规则：\n   - **首先设置**：初始化项目结构、依赖、配置\n   - **测试优先于代码**：如果需要为契约、实体和集成场景编写测试\n   - **核心开发**：实现模型、服务、CLI 命令、端点\n   - **集成工作**：数据库连接、中间件、日志、外部服务\n   - **完善和验证**：单元测试、性能优化、文档\n\n8. 进度跟踪和错误处理：\n   - 在每个完成的任务后报告进度\n   - 如果任何非并行任务失败则停止执行\n   - 对于并行任务 [P]，继续执行成功的任务，报告失败的任务\n   - 提供清晰的错误消息和调试上下文\n   - 如果实现无法继续则建议下一步\n   - **重要** 对于完成的任务，确保在任务文件中标记为 [X]。\n\n9. 完成验证：\n   - 验证所有必需任务已完成\n   - 检查实现的功能是否与原始规格匹配\n   - 验证测试通过且覆盖率符合要求\n   - 确认实现遵循技术计划\n   - 报告最终状态和已完成工作的摘要\n\n注意：此命令假设 tasks.md 中存在完整的任务分解。如果任务不完整或缺失，建议首先运行 `/speckit.tasks` 以重新生成任务列表。"
              },
              {
                "name": "/plan",
                "description": "使用计划模板执行实现规划工作流程以生成设计工件。",
                "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/plan.md",
                "frontmatter": {
                  "description": "使用计划模板执行实现规划工作流程以生成设计工件。",
                  "scripts": {
                    "sh": "scripts/bash/setup-plan.sh --json",
                    "ps": "scripts/powershell/setup-plan.ps1 -Json"
                  },
                  "agent_scripts": {
                    "sh": "scripts/bash/update-agent-context.sh __AGENT__",
                    "ps": "scripts/powershell/update-agent-context.ps1 -AgentType __AGENT__"
                  }
                },
                "content": "## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n1. **设置**：从仓库根目录运行 `{SCRIPT}` 并解析 JSON 以获取 FEATURE_SPEC, IMPL_PLAN, SPECS_DIR, BRANCH。对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **加载上下文**：读取 FEATURE_SPEC 和 `/memory/constitution.md`。加载 IMPL_PLAN 模板（已复制）。\n\n3. **执行计划工作流程**：按照 IMPL_PLAN 模板中的结构：\n   - 填写技术上下文（将未知标记为\"需要澄清\"）\n   - 从宪章填写宪章检查部分\n   - 评估门（如果违规未经证明则报错）\n   - 阶段 0：生成 research.md（解决所有\"需要澄清\"）\n   - 阶段 1：生成 data-model.md, contracts/, quickstart.md\n   - 阶段 1：通过运行代理脚本更新代理上下文\n   - 设计后重新评估宪章检查\n\n4. **停止并报告**：命令在阶段 2 规划后结束。报告分支、IMPL_PLAN 路径和生成的工件。\n\n## 阶段\n\n### 阶段 0：大纲和研究\n\n1. **从上面的技术上下文中提取未知项**：\n   - 对于每个\"需要澄清\" → 研究任务\n   - 对于每个依赖项 → 最佳实践任务\n   - 对于每个集成 → 模式任务\n\n2. **生成和派遣研究代理**：\n\n   ```text\n   对于技术上下文中的每个未知项：\n     任务：\"研究 {未知项} 用于 {功能上下文}\"\n   对于每个技术选择：\n     任务：\"查找 {技术} 在 {领域} 中的最佳实践\"\n   ```\n\n3. **在 `research.md` 中整合发现**，使用格式：\n   - 决策：[选择了什么]\n   - 理由：[为什么选择]\n   - 考虑的替代方案：[评估了什么其他选项]\n\n**输出**：research.md，解决所有\"需要澄清\"\n\n### 阶段 1：设计和契约\n\n**先决条件**：`research.md` 完成\n\n1. **从功能规格中提取实体** → `data-model.md`：\n   - 实体名称、字段、关系\n   - 来自要求的验证规则\n   - 如适用的状态转换\n\n2. **从功能要求生成 API 契约**：\n   - 对于每个用户操作 → 端点\n   - 使用标准 REST/GraphQL 模式\n   - 将 OpenAPI/GraphQL 模式输出到 `/contracts/`\n\n3. **代理上下文更新**：\n   - 运行 `{AGENT_SCRIPT}`\n   - 这些脚本检测使用中的 AI 代理\n   - 更新适当的代理特定上下文文件\n   - 仅添加当前计划中的新技术\n   - 保留标记之间的手动添加\n\n**输出**：data-model.md, /contracts/*, quickstart.md, 代理特定文件\n\n## 关键规则\n\n- 使用绝对路径\n- 门失败或未解决的澄清时报错"
              },
              {
                "name": "/specify",
                "description": "根据自然语言功能描述创建或更新功能规格。",
                "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/specify.md",
                "frontmatter": {
                  "description": "根据自然语言功能描述创建或更新功能规格。",
                  "scripts": {
                    "sh": "scripts/bash/create-new-feature.sh --json \"{ARGS}\"",
                    "ps": "scripts/powershell/create-new-feature.ps1 -Json \"{ARGS}\""
                  }
                },
                "content": "## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n用户在触发消息中输入 `/speckit.specify` 后的文本**就是**功能描述。假设您在此对话中始终可以使用它，即使下面出现 `{ARGS}` 字面意思。除非用户提供了空命令，否则不要要求用户重复。\n\n根据该功能描述，执行以下操作：\n\n1. **生成简洁的短名称**（2-4 个单词）用于分支：\n   - 分析功能描述并提取最有意义的关键词\n   - 创建一个 2-4 个单词的短名称，捕捉功能的本质\n   - 尽可能使用动作-名词格式（例如，\"add-user-auth\"，\"fix-payment-bug\"）\n   - 保留技术术语和缩写（OAuth2, API, JWT 等）\n   - 保持简洁但描述性足够，一眼就能理解功能\n   - 示例：\n     - \"我想添加用户认证\" → \"user-auth\"\n     - \"为 API 实现 OAuth2 集成\" → \"oauth2-api-integration\"\n     - \"创建分析仪表板\" → \"analytics-dashboard\"\n     - \"修复支付处理超时错误\" → \"fix-payment-timeout\"\n\n2. **在创建新分支前检查现有分支**：\n   \n   a. 首先，获取所有远程分支以确保我们有最新信息：\n      ```bash\n      git fetch --all --prune\n      ```\n   \n   b. 查找短名称的最高功能编号：\n      - 远程分支：`git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`\n      - 本地分支：`git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`\n      - 规格目录：检查匹配 `specs/[0-9]+-<short-name>` 的目录\n   \n   c. 确定下一个可用编号：\n      - 从所有三个来源提取所有编号\n      - 找到最高编号 N\n      - 使用 N+1 作为新分支编号\n   \n   d. 使用计算出的编号和短名称运行脚本 `{SCRIPT}`：\n      - 传递 `--number N+1` 和 `--short-name \"your-short-name\"` 以及功能描述\n      - Bash 示例：`{SCRIPT} --json --number 5 --short-name \"user-auth\" \"添加用户认证\"`\n      - PowerShell 示例：`{SCRIPT} -Json -Number 5 -ShortName \"user-auth\" \"添加用户认证\"`\n   \n   **重要**：\n   - 检查所有三个来源（远程分支、本地分支、规格目录）以找到最高编号\n   - 仅匹配具有确切短名称模式的分支/目录\n   - 如果未找到具有此短名称的现有分支/目录，则从编号 1 开始\n   - 每个功能只能运行此脚本一次\n   - JSON 在终端中作为输出提供 - 始终参考它以获取您要查找的实际内容\n   - JSON 输出将包含 BRANCH_NAME 和 SPEC_FILE 路径\n   - 对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）\n\n3. 加载 `templates/spec-template.md` 以了解必需部分。\n\n4. 遵循此执行流程：\n\n    1. 从输入解析用户描述\n       如果为空：错误 \"未提供功能描述\"\n    2. 从描述中提取关键概念\n       识别：参与者、动作、数据、约束\n    3. 对于不清楚的方面：\n       - 基于上下文和行业标准做出有根据的猜测\n       - 仅在以下情况下标记 [需要澄清：具体问题]：\n         - 选择显著影响功能范围或用户体验\n         - 存在多种合理解释且有不同的含义\n         - 没有合理的默认值\n       - **限制：最多 3 个 [需要澄清] 标记**\n       - 按影响优先级排序：范围 > 安全/隐私 > 用户体验 > 技术细节\n    4. 填写用户场景和测试部分\n       如果没有明确的用户流程：错误 \"无法确定用户场景\"\n    5. 生成功能要求\n       每个要求必须可测试\n       为未指定的细节使用合理的默认值（在假设部分记录假设）\n    6. 定义成功标准\n       创建可测量的、技术无关的结果\n       包括定量指标（时间、性能、数量）和定性措施（用户满意度、任务完成）\n       每个标准必须在没有实现细节的情况下可验证\n    7. 识别关键实体（如果涉及数据）\n    8. 返回：成功（规格已准备好规划）\n\n5. 使用模板结构将规格写入 SPEC_FILE，将占位符替换为从功能描述（参数）中得出的具体细节，同时保持部分顺序和标题。\n\n6. **规格质量验证**：在编写初始规格后，根据质量标准进行验证：\n\n   a. **创建规格质量检查表**：在 `FEATURE_DIR/checklists/requirements.md` 生成检查表文件，使用检查表模板结构和这些验证项目：\n\n      ```markdown\n      # 规格质量检查表：[功能名称]\n      \n      **目的**：在继续规划之前验证规格完整性和质量\n      **创建时间**：[日期]\n      **功能**：[链接到 spec.md]\n      \n      ## 内容质量\n      \n      - [ ] 无实现细节（语言、框架、API）\n      - [ ] 专注于用户价值和业务需求\n      - [ ] 为非技术利益相关者编写\n      - [ ] 所有必需部分已完成\n      \n      ## 要求完整性\n      \n      - [ ] 无 [需要澄清] 标记\n      - [ ] 要求可测试且明确\n      - [ ] 成功标准可测量\n      - [ ] 成功标准技术无关（无实现细节）\n      - [ ] 所有验收场景已定义\n      - [ ] 边缘情况已识别\n      - [ ] 范围明确界定\n      - [ ] 依赖关系和假设已识别\n      \n      ## 功能准备度\n      \n      - [ ] 所有功能要求都有明确的验收标准\n      - [ ] 用户场景涵盖主要流程\n      - [ ] 功能满足成功标准中定义的可测量结果\n      - [ ] 无实现细节泄露到规格中\n      \n      ## 备注\n      \n      - 标记为不完整的项目需要在 `/speckit.clarify` 或 `/speckit.plan` 之前更新规格\n      ```\n\n   b. **运行验证检查**：根据每个检查表项目审查规格：\n      - 对于每个项目，确定它是通过还是失败\n      - 记录发现的具体问题（引用相关规格部分）\n\n   c. **处理验证结果**：\n\n      - **如果所有项目都通过**：标记检查表完成并继续到步骤 6\n\n      - **如果项目失败（不包括 [需要澄清]）**：\n        1. 列出失败的项目和具体问题\n        2. 更新规格以解决每个问题\n        3. 重新运行验证直到所有项目通过（最多 3 次迭代）\n        4. 如果 3 次迭代后仍失败，将剩余问题记录在检查表备注中并警告用户\n\n      - **如果 [需要澄清] 标记仍然存在**：\n        1. 从规格中提取所有 [需要澄清：...] 标记\n        2. **限制检查**：如果标记超过 3 个，仅保留 3 个最关键（按范围/安全/用户体验影响）并为其余标记做出有根据的猜测\n        3. 对于每个需要的澄清（最多 3 个），以以下格式向用户呈现选项：\n\n           ```markdown\n           ## 问题 [N]：[主题]\n           \n           **上下文**：[引用相关规格部分]\n           \n           **我们需要知道**：[来自需要澄清标记的具体问题]\n           \n           **建议答案**：\n           \n           | 选项 | 答案 | 影响 |\n           |--------|--------|--------------|\n           | A      | [第一个建议答案] | [这对功能意味着什么] |\n           | B      | [第二个建议答案] | [这对功能意味着什么] |\n           | C      | [第三个建议答案] | [这对功能意味着什么] |\n           | 自定义 | 提供您自己的答案 | [解释如何提供自定义输入] |\n           \n           **您的选择**：_[等待用户响应]_\n           ```\n\n        4. **关键 - 表格格式**：确保 markdown 表格格式正确：\n           - 使用一致的间距，管道对齐\n           - 每个单元格应有内容周围的空格：`| 内容 |` 而不是 `|内容|`\n           - 标题分隔符必须至少有 3 个破折号：`|--------|`\n           - 测试表格在 markdown 预览中正确渲染\n        5. 顺序编号问题（Q1, Q2, Q3 - 最多 3 个总计）\n        6. 在等待响应之前一起呈现所有问题\n        7. 等待用户响应他们对所有问题的选择（例如，\"Q1: A, Q2: 自定义 - [详情], Q3: B\"）\n        8. 通过将每个 [需要澄清] 标记替换为用户选择或提供的答案来更新规格\n        9. 在所有澄清解决后重新运行验证\n\n   d. **更新检查表**：在每次验证迭代后，使用当前通过/失败状态更新检查表文件\n\n7. 报告完成情况，包括分支名称、规格文件路径、检查表结果和下一阶段的准备情况（`/speckit.clarify` 或 `/speckit.plan`）。\n\n**注意**：脚本创建并检出新分支并在写入前初始化规格文件。\n\n## 一般指南\n\n## 快速指南\n\n- 专注于用户需要**什么**和**为什么**。\n- 避免如何实现（无技术栈、API、代码结构）。\n- 为业务利益相关者编写，而不是开发人员。\n- 不要创建嵌入在规格中的任何检查表。那将是单独的命令。\n\n### 部分要求\n\n- **必需部分**：每个功能必须完成\n- **可选部分**：仅在与功能相关时包含\n- 当部分不适用时，完全删除（不要留作\"N/A\"）\n\n### 对于 AI 生成\n\n从用户提示创建此规格时：\n\n1. **做出有根据的猜测**：使用上下文、行业标准和常见模式填补空白\n2. **记录假设**：在假设部分记录合理的默认值\n3. **限制澄清**：最多 3 个 [需要澄清] 标记 - 仅用于关键决策：\n   - 显著影响功能范围或用户体验\n   - 有多种合理解释且有不同的含义\n   - 没有合理的默认值\n4. **优先级澄清**：范围 > 安全/隐私 > 用户体验 > 技术细节\n5. **像测试人员一样思考**：每个模糊要求都应无法通过\"可测试和明确\"检查表项目\n6. **需要澄清的常见领域**（如果没有合理的默认值）：\n   - 功能范围和边界（包括/排除特定用例）\n   - 用户类型和权限（如果存在多个冲突解释）\n   - 安全/合规要求（当法律/财务重要时）\n\n**合理默认值示例**（不要询问这些）：\n\n- 数据保留：该领域的行业标准实践\n- 性能目标：标准网络/移动应用期望（除非指定）\n- 错误处理：用户友好的消息和适当的回退\n- 认证方法：标准基于会话或 OAuth2 用于 Web 应用\n- 集成模式：RESTful API（除非另有说明）\n\n### 成功标准指南\n\n成功标准必须：\n\n1. **可测量**：包括具体指标（时间、百分比、数量、比率）\n2. **技术无关**：不提及框架、语言、数据库或工具\n3. **用户导向**：从用户/业务角度描述结果，而不是系统内部\n4. **可验证**：可以在不知道实现细节的情况下测试/验证\n\n**好示例**：\n\n- \"用户可以在 3 分钟内完成结账\"\n- \"系统支持 10,000 个并发用户\"\n- \"95% 的搜索在 1 秒内返回结果\"\n- \"任务完成率提高 40%\"\n\n**坏示例**（实现导向）：\n\n- \"API 响应时间低于 200ms\"（太技术性，使用\"用户立即看到结果\"）\n- \"数据库可以处理 1000 TPS\"（实现细节，使用面向用户的指标）\n- \"React 组件高效渲染\"（框架特定）\n- \"Redis 缓存命中率高于 80%\"（技术特定）"
              },
              {
                "name": "/tasks",
                "description": "基于可用设计工件为功能生成可操作的、按依赖顺序排列的 tasks.md。",
                "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/tasks.md",
                "frontmatter": {
                  "description": "基于可用设计工件为功能生成可操作的、按依赖顺序排列的 tasks.md。",
                  "scripts": {
                    "sh": "scripts/bash/check-prerequisites.sh --json",
                    "ps": "scripts/powershell/check-prerequisites.ps1 -Json"
                  }
                },
                "content": "## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n1. **设置**：从仓库根目录运行 `{SCRIPT}` 并解析 FEATURE_DIR 和 AVAILABLE_DOCS 列表。所有路径必须是绝对的。对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **加载设计文档**：从 FEATURE_DIR 读取：\n   - **必需**：plan.md（技术栈、库、结构），spec.md（带优先级的用户故事）\n   - **可选**：data-model.md（实体），contracts/（API 端点），research.md（决策），quickstart.md（测试场景）\n   - 注意：并非所有项目都有所有文档。根据可用内容生成任务。\n\n3. **执行任务生成工作流程**：\n   - 加载 plan.md 并提取技术栈、库、项目结构\n   - 加载 spec.md 并提取带优先级的用户故事（P1, P2, P3 等）\n   - 如果存在 data-model.md：提取实体并映射到用户故事\n   - 如果存在 contracts/：将端点映射到用户故事\n   - 如果存在 research.md：提取决策用于设置任务\n   - 生成按用户故事组织的任务（参见下面的任务生成规则）\n   - 生成依赖图显示用户故事完成顺序\n   - 为每个用户故事创建并行执行示例\n   - 验证任务完整性（每个用户故事都有所需任务，可独立测试）\n\n4. **生成 tasks.md**：使用 `.specify/templates/tasks-template.md` 作为结构，填充：\n   - 从 plan.md 获取正确的功能名称\n   - 阶段 1：设置任务（项目初始化）\n   - 阶段 2：基础任务（所有用户故事的阻塞先决条件）\n   - 阶段 3+：按 spec.md 中的优先级顺序排列的每个用户故事一个阶段\n   - 每个阶段包括：故事目标、独立测试标准、测试（如果要求）、实现任务\n   - 最终阶段：完善和跨领域关注点\n   - 所有任务必须遵循严格的检查表格式（参见下面的任务生成规则）\n   - 每个任务的明确文件路径\n   - 依赖关系部分显示故事完成顺序\n   - 每个故事的并行执行示例\n   - 实现策略部分（MVP 优先、增量交付）\n\n5. **报告**：输出生成的 tasks.md 路径和摘要：\n   - 总任务数\n   - 每个用户故事的任务数\n   - 识别的并行机会\n   - 每个故事的独立测试标准\n   - 建议的 MVP 范围（通常仅为用户故事 1）\n   - 格式验证：确认所有任务都遵循检查表格式（复选框、ID、标签、文件路径）\n\n为任务生成提供上下文：{ARGS}\n\ntasks.md 应该是立即可执行的 - 每个任务必须足够具体，以便 LLM 可以在没有额外上下文的情况下完成它。\n\n## 任务生成规则\n\n**关键**：任务必须按用户故事组织，以实现独立实现和测试。\n\n**测试是可选的**：仅在功能规格中明确要求或用户要求 TDD 方法时才生成测试任务。\n\n### 检查表格式（必需）\n\n每个任务必须严格遵循此格式：\n\n```text\n- [ ] [任务ID] [P?] [故事?] 带文件路径的描述\n```\n\n**格式组件**：\n\n1. **复选框**：始终以 `- [ ]` 开头（markdown 复选框）\n2. **任务 ID**：按执行顺序的序列号（T001, T002, T003...）\n3. **[P] 标记**：仅当任务可并行化时包含（不同文件，不依赖未完成任务）\n4. **[故事] 标签**：仅用户故事阶段任务必需\n   - 格式：[US1], [US2], [US3], 等（映射到 spec.md 中的用户故事）\n   - 设置阶段：无故事标签\n   - 基础阶段：无故事标签  \n   - 用户故事阶段：必须有故事标签\n   - 完善阶段：无故事标签\n5. **描述**：带确切文件路径的明确操作\n\n**示例**：\n\n- ✅ 正确：`- [ ] T001 根据实现计划创建项目结构`\n- ✅ 正确：`- [ ] T005 [P] 在 src/middleware/auth.py 中实现认证中间件`\n- ✅ 正确：`- [ ] T012 [P] [US1] 在 src/models/user.py 中创建用户模型`\n- ✅ 正确：`- [ ] T014 [US1] 在 src/services/user_service.py 中实现 UserService`\n- ❌ 错误：`- [ ] 创建用户模型`（缺少 ID 和故事标签）\n- ❌ 错误：`T001 [US1] 创建模型`（缺少复选框）\n- ❌ 错误：`- [ ] [US1] 创建用户模型`（缺少任务 ID）\n- ❌ 错误：`- [ ] T001 [US1] 创建模型`（缺少文件路径）\n\n### 任务组织\n\n1. **来自用户故事（spec.md）** - 主要组织：\n   - 每个用户故事（P1, P2, P3...）都有自己的阶段\n   - 将所有相关组件映射到它们的故事：\n     - 该故事需要的模型\n     - 该故事需要的服务\n     - 该故事需要的端点/UI\n     - 如果要求测试：该故事的特定测试\n   - 标记故事依赖关系（大多数故事应该是独立的）\n\n2. **来自契约**：\n   - 将每个契约/端点 → 映射到它服务的用户故事\n   - 如果要求测试：每个契约 → 在该故事阶段实现前的契约测试任务 [P]\n\n3. **来自数据模型**：\n   - 将每个实体映射到需要它的用户故事\n   - 如果实体服务于多个故事：放在最早的故事或设置阶段\n   - 关系 → 在适当的故事阶段中的服务层任务\n\n4. **来自设置/基础设施**：\n   - 共享基础设施 → 设置阶段（阶段 1）\n   - 基础/阻塞任务 → 基础阶段（阶段 2）\n   - 故事特定设置 → 在该故事的阶段内\n\n### 阶段结构\n\n- **阶段 1**：设置（项目初始化）\n- **阶段 2**：基础（阻塞先决条件 - 必须在用户故事前完成）\n- **阶段 3+**：按优先级顺序的用户故事（P1, P2, P3...）\n  - 在每个故事内：测试（如果要求）→ 模型 → 服务 → 端点 → 集成\n  - 每个阶段应该是一个完整的、可独立测试的增量\n- **最终阶段**：完善和跨领域关注点"
              },
              {
                "name": "/analyze",
                "description": "在任务生成后，对 spec.md、plan.md 和 tasks.md 进行非破坏性的跨工件一致性和质量分析。",
                "path": "skills/speckit-specify-zh/assets/specify/templates/commands/analyze.md",
                "frontmatter": {
                  "description": "在任务生成后，对 spec.md、plan.md 和 tasks.md 进行非破坏性的跨工件一致性和质量分析。",
                  "scripts": {
                    "sh": "scripts/bash/check-prerequisites.sh --json --require-tasks --include-tasks",
                    "ps": "scripts/powershell/check-prerequisites.ps1 -Json -RequireTasks -IncludeTasks"
                  }
                },
                "content": "## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 目标\n\n在实现之前，识别三个核心工件（`spec.md`、`plan.md`、`tasks.md`）之间的不一致、重复、歧义和未充分说明的项目。此命令必须仅在 `/speckit.tasks` 成功生成完整的 `tasks.md` 后运行。\n\n## 操作约束\n\n**严格只读**：**不要**修改任何文件。输出结构化分析报告。提供可选的补救计划（用户必须明确批准后才能手动调用任何后续编辑命令）。\n\n**宪章权威性**：项目宪章（`/memory/constitution.md`）在此分析范围内是**不可协商的**。宪章冲突自动为关键级别，需要调整规格、计划或任务——而不是稀释、重新解释或默默忽略原则。如果原则本身需要更改，必须在 `/speckit.analyze` 之外的单独、明确的宪章更新中进行。\n\n## 执行步骤\n\n### 1. 初始化分析上下文\n\n从仓库根目录运行一次 `{SCRIPT}` 并解析 JSON 以获取 FEATURE_DIR 和 AVAILABLE_DOCS。推导绝对路径：\n\n- SPEC = FEATURE_DIR/spec.md\n- PLAN = FEATURE_DIR/plan.md\n- TASKS = FEATURE_DIR/tasks.md\n\n如果缺少任何必需文件，则中止并显示错误消息（指示用户运行缺少的先决条件命令）。\n对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n### 2. 加载工件（渐进式披露）\n\n仅加载每个工件的最小必要上下文：\n\n**来自 spec.md：**\n\n- 概述/上下文\n- 功能要求\n- 非功能要求\n- 用户故事\n- 边缘情况（如果存在）\n\n**来自 plan.md：**\n\n- 架构/技术栈选择\n- 数据模型引用\n- 阶段\n- 技术约束\n\n**来自 tasks.md：**\n\n- 任务 ID\n- 描述\n- 阶段分组\n- 并行标记 [P]\n- 引用的文件路径\n\n**来自 constitution：**\n\n- 加载 `/memory/constitution.md` 用于原则验证\n\n### 3. 构建语义模型\n\n创建内部表示（不要在输出中包含原始工件）：\n\n- **要求清单**：每个功能+非功能要求带有一个稳定键（根据祈使句派生 slug；例如，\"用户可以上传文件\" → `user-can-upload-file`）\n- **用户故事/动作清单**：具有验收标准的离散用户动作\n- **任务覆盖映射**：将每个任务映射到一个或多个要求或故事（通过关键词/显式引用模式如 ID 或关键词进行推断）\n- **宪章规则集**：提取原则名称和 MUST/SHOULD 规范性陈述\n\n### 4. 检测过程（高效令牌分析）\n\n专注于高信号发现。限制总数为 50 个发现；在溢出摘要中聚合其余发现。\n\n#### A. 重复检测\n\n- 识别近似重复的要求\n- 标记质量较低的措辞以进行合并\n\n#### B. 歧义检测\n\n- 标记缺乏可测量标准的模糊形容词（快速、可扩展、安全、直观、健壮）\n- 标记未解决的占位符（TODO、TKTK、???、`<placeholder>` 等）\n\n#### C. 未充分说明\n\n- 有动词但缺少对象或可测量结果的要求\n- 缺少验收标准对齐的用户故事\n- 引用在规格/计划中未定义的文件或组件的任务\n\n#### D. 宪章对齐\n\n- 任何与 MUST 原则冲突的要求或计划元素\n- 缺少宪章中规定的章节或质量门\n\n#### E. 覆盖差距\n\n- 没有关联任务的要求\n- 没有映射要求/故事的任务\n- 未在任务中体现的非功能要求（例如，性能、安全性）\n\n#### F. 不一致\n\n- 术语漂移（同一概念在不同文件中有不同名称）\n- 计划中引用但在规格中缺失的数据实体（反之亦然）\n- 任务排序矛盾（例如，集成任务在基础设置任务之前但没有依赖注释）\n- 冲突的要求（例如，一个要求 Next.js 而另一个指定 Vue）\n\n### 5. 严重性分配\n\n使用此启发式方法来优先处理发现：\n\n- **关键**：违反宪章 MUST、缺少核心规格工件，或阻塞基本功能的零覆盖要求\n- **高**：重复或冲突的要求、模糊的安全/性能属性、不可测试的验收标准\n- **中**：术语漂移、缺少非功能任务覆盖、未充分说明的边缘情况\n- **低**：样式/措辞改进、不影响执行顺序的次要冗余\n\n### 6. 生成紧凑分析报告\n\n输出一个 Markdown 报告（不写入文件）具有以下结构：\n\n## 规格分析报告\n\n| ID | 类别 | 严重性 | 位置 | 摘要 | 建议 |\n|----|----------|----------|-------------|---------|----------------|\n| A1 | 重复 | 高 | spec.md:L120-134 | 两个相似的要求 ... | 合并措辞；保留更清晰的版本 |\n\n（每项发现添加一行；生成以类别首字母为前缀的稳定 ID。）\n\n**覆盖摘要表：**\n\n| 要求键 | 有任务？ | 任务 ID | 备注 |\n|-----------------|-----------|----------|-------|\n\n**宪章对齐问题：**（如果有）\n\n**未映射的任务：**（如果有）\n\n**指标：**\n\n- 总要求\n- 总任务\n- 覆盖率%（有>=1个任务的要求）\n- 歧义计数\n- 重复计数\n- 关键问题计数\n\n### 7. 提供下一步行动\n\n在报告末尾，输出一个简洁的下一步行动块：\n\n- 如果存在关键问题：建议在 `/speckit.implement` 之前解决\n- 如果只有低/中等：用户可以继续，但提供改进建议\n- 提供明确的命令建议：例如，\"使用改进运行 /speckit.specify\"，\"运行 /speckit.plan 调整架构\"，\"手动编辑 tasks.md 添加 'performance-metrics' 的覆盖\"\n\n### 8. 提供补救措施\n\n询问用户：\"您希望我为前 N 个问题建议具体的补救编辑吗？\"（不要自动应用它们。）\n\n## 操作原则\n\n### 上下文效率\n\n- **最小高信号令牌**：专注于可操作的发现，而不是详尽的文档\n- **渐进式披露**：增量加载工件；不要将所有内容倒入分析\n- **高效令牌输出**：限制发现表为 50 行；总结溢出\n- **确定性结果**：在没有更改的情况下重新运行应产生一致的 ID 和计数\n\n### 分析指南\n\n- **永不修改文件**（这是只读分析）\n- **永不虚构缺失部分**（如果缺失，准确报告）\n- **优先处理宪章违规**（这些总是关键的）\n- **使用示例而非详尽规则**（引用具体实例，而非通用模式）\n- **优雅报告零问题**（发出带有覆盖统计的成功报告）\n\n## 上下文\n\n{ARGS}"
              },
              {
                "name": "/checklist",
                "description": "根据用户要求为当前功能生成自定义检查表。",
                "path": "skills/speckit-specify-zh/assets/specify/templates/commands/checklist.md",
                "frontmatter": {
                  "description": "根据用户要求为当前功能生成自定义检查表。",
                  "scripts": {
                    "sh": "scripts/bash/check-prerequisites.sh --json",
                    "ps": "scripts/powershell/check-prerequisites.ps1 -Json"
                  }
                },
                "content": "## 检查表目的：\"中文的单元测试\"\n\n**关键概念**：检查表是**要求编写的单元测试** - 它们验证特定领域中要求的质量、清晰度和完整性。\n\n**不用于验证/测试**：\n\n- ❌ 不是\"验证按钮正确点击\"\n- ❌ 不是\"测试错误处理是否有效\"\n- ❌ 不是\"确认 API 返回 200\"\n- ❌ 不是检查代码/实现是否符合规格\n\n**用于要求质量验证**：\n\n- ✅ \"是否为所有卡片类型定义了视觉层次要求？\"（完整性）\n- ✅ \"是否用特定的尺寸/定位量化了'显著显示'？\"（清晰度）\n- ✅ \"所有交互元素的悬停状态要求是否一致？\"（一致性）\n- ✅ \"是否为键盘导航定义了可访问性要求？\"（覆盖范围）\n- ✅ \"规格是否定义了徽标图像加载失败时的情况？\"（边缘情况）\n\n**比喻**：如果您的规格是用英语编写的代码，那么检查表就是它的单元测试套件。您正在测试要求是否编写良好、完整、明确并准备好实施 - 而不是测试实现是否有效。\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 执行步骤\n\n1. **设置**：从仓库根目录运行 `{SCRIPT}` 并解析 JSON 以获取 FEATURE_DIR 和 AVAILABLE_DOCS 列表。\n   - 所有文件路径必须是绝对的。\n   - 对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **澄清意图（动态）**：推导出最多三个初始上下文澄清问题（无预设目录）。它们必须：\n   - 从用户的措辞 + 从规格/计划/任务中提取的信号生成\n   - 仅询问会实质性改变检查表内容的信息\n   - 如果在 `$ARGUMENTS` 中已经明确，则单独跳过\n   - 优先考虑精确性而非广度\n\n   生成算法：\n   1. 提取信号：功能领域关键词（例如，auth, latency, UX, API），风险指标（\"critical\", \"must\", \"compliance\"），利益相关者提示（\"QA\", \"review\", \"security team\"）和明确的交付物（\"a11y\", \"rollback\", \"contracts\"）。\n   2. 将信号聚类到候选关注领域（最多 4 个）按相关性排序。\n   3. 识别可能的受众和时机（作者、审阅者、QA、发布）如果不明确。\n   4. 检测缺失的维度：范围广度、深度/严谨性、风险重点、排除边界、可测量的验收标准。\n   5. 从这些原型中制定问题：\n      - 范围细化（例如，\"这应该包括与 X 和 Y 的集成接触点还是仅限于本地模块正确性？\"）\n      - 风险优先级（例如，\"这些潜在风险领域中哪些应该接受强制门控检查？\"）\n      - 深度校准（例如，\"这是一个轻量级的预提交健全性列表还是正式的发布门？\"）\n      - 受众框架（例如，\"这将仅由作者使用还是在 PR 审阅期间由同行使用？\"）\n      - 边界排除（例如，\"我们应该明确排除本轮的性能调优项目吗？\"）\n      - 场景类别差距（例如，\"未检测到恢复流程——回滚/部分故障路径是否在范围内？\"）\n\n   问题格式规则：\n   - 如果提供选项，生成一个紧凑的表格，列：选项 | 候选 | 重要性原因\n   - 限制最多 A-E 个选项；如果自由形式答案更清晰则省略表格\n   - 永远不要要求用户重述他们已经说过的话\n   - 避免推测性类别（无幻觉）。如果不确定，明确询问：\"确认 X 是否在范围内。\"\n\n   无法交互时的默认值：\n   - 深度：标准\n   - 受众：如果与代码相关则为审阅者（PR）；否则为作者\n   - 关注：前 2 个相关性聚类\n\n   输出问题（标记 Q1/Q2/Q3）。回答后：如果≥2 个场景类别（替代/异常/恢复/非功能性领域）仍不清楚，您可以要求最多两个更有针对性的后续问题（Q4/Q5），每个问题附带一行理由（例如，\"未解决的恢复路径风险\"）。不要超过五个总问题。如果用户明确拒绝更多问题则跳过升级。\n\n3. **理解用户请求**：结合 `$ARGUMENTS` + 澄清答案：\n   - 推导检查表主题（例如，安全、审阅、部署、用户体验）\n   - 整合用户提到的明确必备项目\n   - 将焦点选择映射到类别脚手架\n   - 从规格/计划/任务中推断任何缺失的上下文（不要幻觉）\n\n4. **加载功能上下文**：从 FEATURE_DIR 读取：\n   - spec.md：功能要求和范围\n   - plan.md（如果存在）：技术细节、依赖关系\n   - tasks.md（如果存在）：实施任务\n\n   **上下文加载策略**：\n   - 仅加载与活跃关注领域相关的必要部分（避免完整文件转储）\n   - 更喜欢将长段落总结为简洁的场景/要求要点\n   - 使用渐进式披露：仅在检测到差距时添加后续检索\n   - 如果源文档很大，生成中间摘要项目而不是嵌入原始文本\n\n5. **生成检查表** - 创建\"要求的单元测试\"：\n   - 如果不存在则创建 `FEATURE_DIR/checklists/` 目录\n   - 生成唯一的检查表文件名：\n     - 使用基于领域的简短描述性名称（例如，`ux.md`, `api.md`, `security.md`）\n     - 格式：`[domain].md`\n     - 如果文件存在，则追加到现有文件\n   - 从 CHK001 开始顺序编号项目\n   - 每个 `/speckit.checklist` 运行创建一个新文件（从不覆盖现有检查表）\n\n   **核心原则 - 测试要求，而不是实现**：\n   每个检查表项目必须评估要求本身：\n   - **完整性**：所有必要的要求是否存在？\n   - **清晰度**：要求是否明确且具体？\n   - **一致性**：要求是否相互对齐？\n   - **可测量性**：要求是否可以客观验证？\n   - **覆盖范围**：是否解决了所有场景/边缘情况？\n\n   **类别结构** - 按要求质量维度分组项目：\n   - **要求完整性**（是否记录了所有必要的要求？）\n   - **要求清晰度**（要求是否具体且明确？）\n   - **要求一致性**（要求是否对齐而无冲突？）\n   - **验收标准质量**（成功标准是否可测量？）\n   - **场景覆盖**（是否解决了所有流程/案例？）\n   - **边缘情况覆盖**（是否定义了边界条件？）\n   - **非功能性要求**（性能、安全性、可访问性等 - 是否指定？）\n   - **依赖关系和假设**（是否记录和验证？）\n   - **歧义和冲突**（需要澄清什么？）\n\n   **如何编写检查表项目 - \"英语的单元测试\"**：\n\n   ❌ **错误**（测试实现）：\n   - \"验证着陆页显示 3 个剧集卡片\"\n   - \"测试桌面端悬停状态是否有效\"\n   - \"确认徽标点击导航到主页\"\n\n   ✅ **正确**（测试要求质量）：\n   - \"是否明确指定了特色剧集的确切数量和布局？\" [完整性]\n   - \"是否用特定的尺寸/定位量化了'显著显示'？\" [清晰度]\n   - \"所有交互元素的悬停状态要求是否一致？\" [一致性]\n   - \"是否为所有交互式 UI 定义了键盘导航要求？\" [覆盖范围]\n   - \"当徽标图像加载失败时是否指定了回退行为？\" [边缘情况]\n   - \"是否为异步剧集数据定义了加载状态？\" [完整性]\n   - \"规格是否定义了竞争 UI 元素的视觉层次？\" [清晰度]\n\n   **项目结构**：\n   每个项目应遵循此模式：\n   - 询问要求质量的问题格式\n   - 关注规格/计划中编写（或未编写）的内容\n   - 包括质量维度在括号中 [完整性/清晰度/一致性等]\n   - 检查现有要求时引用规格部分 `[Spec §X.Y]`\n   - 使用 `[Gap]` 标记检查缺失的要求\n\n   **按质量维度的示例**：\n\n   完整性：\n   - \"是否为所有 API 故障模式定义了错误处理要求？ [Gap]\"\n   - \"是否为所有交互元素指定了可访问性要求？ [完整性]\"\n   - \"是否为响应式布局定义了移动断点要求？ [Gap]\"\n\n   清晰度：\n   - \"是否用特定的时间阈值量化了'快速加载'？ [清晰度, Spec §NFR-2]\"\n   - \"是否明确定义了'相关剧集'的选择标准？ [清晰度, Spec §FR-5]\"\n   - \"是否用可测量的视觉属性定义了'显著'？ [歧义, Spec §FR-4]\"\n\n   一致性：\n   - \"所有页面的导航要求是否对齐？ [一致性, Spec §FR-10]\"\n   - \"着陆页和详情页的卡片组件要求是否一致？ [一致性]\"\n\n   覆盖范围：\n   - \"是否为零状态场景（无剧集）定义了要求？ [覆盖范围, 边缘情况]\"\n   - \"是否解决了并发用户交互场景？ [覆盖范围, Gap]\"\n   - \"是否为部分数据加载失败指定了要求？ [覆盖范围, 异常流程]\"\n\n   可测量性：\n   - \"视觉层次要求是否可测量/可测试？ [验收标准, Spec §FR-1]\"\n   - \"是否可以客观验证'平衡的视觉权重'？ [可测量性, Spec §FR-2]\"\n\n   **场景分类和覆盖**（要求质量重点）：\n   - 检查是否存在要求：主要、替代、异常/错误、恢复、非功能性场景\n   - 对于每个场景类别，询问：\"[场景类型] 要求是否完整、清晰且一致？\"\n   - 如果场景类别缺失：\"[场景类型] 要求是故意排除还是缺失？ [Gap]\"\n   - 包括状态变更时的弹性/回滚：\"是否为迁移失败定义了回滚要求？ [Gap]\"\n\n   **可追溯性要求**：\n   - 最低要求：≥80% 的项目必须至少包含一个可追溯性引用\n   - 每个项目应引用：规格部分 `[Spec §X.Y]`，或使用标记：`[Gap]`、`[Ambiguity]`、`[Conflict]`、`[Assumption]`\n   - 如果不存在 ID 系统：\"是否建立了要求和验收标准 ID 方案？ [可追溯性]\"\n\n   **表面和解决问题**（要求质量问题）：\n   询问有关要求本身的问题：\n   - 歧义：\"'快速' 一词是否用具体指标量化？ [歧义, Spec §NFR-1]\"\n   - 冲突：\"§FR-10 和 §FR-10a 中的导航要求是否冲突？ [冲突]\"\n   - 假设：\"'始终可用的播客 API' 假设是否已验证？ [假设]\"\n   - 依赖关系：\"是否记录了外部播客 API 要求？ [依赖关系, Gap]\"\n   - 缺失定义：\"是否用可测量的标准定义了'视觉层次'？ [Gap]\"\n\n   **内容整合**：\n   - 软上限：如果原始候选项目 > 40，按风险/影响优先排序\n   - 合并检查相同要求方面的近似重复项\n   - 如果 >5 个低影响边缘情况，创建一个项目：\"边缘情况 X、Y、Z 是否在要求中解决？ [覆盖范围]\"\n\n   **🚫 绝对禁止** - 这些使其成为实现测试，而不是要求测试：\n   - ❌ 任何以\"验证\"、\"测试\"、\"确认\"、\"检查\" + 实现行为开头的项目\n   - ❌ 引用代码执行、用户操作、系统行为\n   - ❌ \"正确显示\"、\"正常工作\"、\"按预期功能\"\n   - ❌ \"点击\"、\"导航\"、\"渲染\"、\"加载\"、\"执行\"\n   - ❌ 测试用例、测试计划、QA 程序\n   - ❌ 实现细节（框架、API、算法）\n\n   **✅ 必需模式** - 这些测试要求质量：\n   - ✅ \"是否为 [场景] 定义/指定/记录了 [要求类型]？\"\n   - ✅ \"是否用具体标准量化/澄清了 [模糊术语]？\"\n   - ✅ \"[部分 A] 和 [部分 B] 的要求是否一致？\"\n   - ✅ \"是否可以客观测量/验证 [要求]？\"\n   - ✅ \"要求中是否解决了 [边缘情况/场景]？\"\n   - ✅ \"规格是否定义了 [缺失方面]？\"\n\n6. **结构参考**：按照 `templates/checklist-template.md` 中的规范模板生成检查表，包括标题、元部分、类别标题和 ID 格式。如果模板不可用，使用：H1 标题、目的/创建的元行、包含 `- [ ] CHK### <要求项目>` 行的 `##` 类别部分，全局递增 ID 从 CHK001 开始。\n\n7. **报告**：输出创建的检查表的完整路径、项目计数，并提醒用户每次运行都会创建一个新文件。总结：\n   - 选择的关注领域\n   - 深度级别\n   - 参与者/时机\n   - 任何包含的用户明确指定的必备项目\n\n**重要**：每个 `/speckit.checklist` 命令调用都使用简短的描述性名称创建检查表文件，除非文件已存在。这允许：\n\n- 不同类型的多个检查表（例如，`ux.md`, `test.md`, `security.md`）\n- 简单、易记的文件名，指示检查表目的\n- 在 `checklists/` 文件夹中轻松识别和导航\n\n为避免混乱，使用描述性类型并在完成后清理过时的检查表。\n\n## 示例检查表类型和示例项目\n\n**用户体验要求质量：** `ux.md`\n\n示例项目（测试要求，而不是实现）：\n\n- \"是否用可测量的标准定义了视觉层次要求？ [清晰度, Spec §FR-1]\"\n- \"是否明确定义了 UI 元素的数量和定位？ [完整性, Spec §FR-1]\"\n- \"交互状态要求（悬停、焦点、活动）是否一致定义？ [一致性]\"\n- \"是否为所有交互元素指定了可访问性要求？ [覆盖范围, Gap]\"\n- \"图像加载失败时是否定义了回退行为？ [边缘情况, Gap]\"\n- \"是否可以客观测量'显著显示'？ [可测量性, Spec §FR-4]\"\n\n**API 要求质量：** `api.md`\n\n示例项目：\n\n- \"是否为所有故障场景指定了错误响应格式？ [完整性]\"\n- \"是否用具体阈值量化了速率限制要求？ [清晰度]\"\n- \"所有端点的身份验证要求是否一致？ [一致性]\"\n- \"是否为外部依赖关系定义了重试/超时要求？ [覆盖范围, Gap]\"\n- \"版本控制策略是否在要求中记录？ [Gap]\"\n\n**性能要求质量：** `performance.md`\n\n示例项目：\n\n- \"是否用具体指标量化了性能要求？ [清晰度]\"\n- \"是否为所有关键用户旅程定义了性能目标？ [覆盖范围]\"\n- \"是否为不同负载条件指定了性能要求？ [完整性]\"\n- \"是否可以客观测量性能要求？ [可测量性]\"\n- \"是否为高负载场景定义了降级要求？ [边缘情况, Gap]\"\n\n**安全要求质量：** `security.md`\n\n示例项目：\n\n- \"是否为所有受保护资源指定了身份验证要求？ [覆盖范围]\"\n- \"是否为敏感信息定义了数据保护要求？ [完整性]\"\n- \"威胁模型是否记录并与要求对齐？ [可追溯性]\"\n- \"安全要求是否与合规义务一致？ [一致性]\"\n- \"是否定义了安全故障/违规响应要求？ [Gap, 异常流程]\"\n\n## 反例：不要做的事情\n\n**❌ 错误 - 这些测试实现，而不是要求：**\n\n```markdown\n- [ ] CHK001 - 验证着陆页显示 3 个剧集卡片 [Spec §FR-001]\n- [ ] CHK002 - 测试桌面端悬停状态是否正确工作 [Spec §FR-003]\n- [ ] CHK003 - 确认徽标点击导航到主页 [Spec §FR-010]\n- [ ] CHK004 - 检查相关剧集部分显示 3-5 个项目 [Spec §FR-005]\n```\n\n**✅ 正确 - 这些测试要求质量：**\n\n```markdown\n- [ ] CHK001 - 是否明确定义了特色剧集的数量和布局？ [完整性, Spec §FR-001]\n- [ ] CHK002 - 是否为所有交互元素一致定义了悬停状态要求？ [一致性, Spec §FR-003]\n- [ ] CHK003 - 是否为所有可点击品牌元素明确了导航要求？ [清晰度, Spec §FR-010]\n- [ ] CHK004 - 是否记录了相关剧集的选择标准？ [Gap, Spec §FR-005]\n- [ ] CHK005 - 是否为异步剧集数据定义了加载状态要求？ [Gap]\n- [ ] CHK006 - 是否可以客观测量\"视觉层次\"要求？ [可测量性, Spec §FR-001]\n```\n\n**主要区别：**\n\n- 错误：测试系统是否正常工作\n- 正确：测试要求是否编写正确\n- 错误：行为验证\n- 正确：要求质量验证\n- 错误：\"它是否做 X？\"\n- 正确：\"X 是否明确定义？\""
              },
              {
                "name": "/clarify",
                "description": "通过提出最多 5 个高度针对性的澄清问题并将其答案编码回规格中，识别当前功能规格中未充分说明的领域。",
                "path": "skills/speckit-specify-zh/assets/specify/templates/commands/clarify.md",
                "frontmatter": {
                  "description": "通过提出最多 5 个高度针对性的澄清问题并将其答案编码回规格中，识别当前功能规格中未充分说明的领域。",
                  "scripts": {
                    "sh": "scripts/bash/check-prerequisites.sh --json --paths-only",
                    "ps": "scripts/powershell/check-prerequisites.ps1 -Json -PathsOnly"
                  }
                },
                "content": "## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n目标：检测并减少活动功能规格中的歧义或缺失决策点，并将澄清直接记录在规格文件中。\n\n注意：此澄清工作流程预计在调用 `/speckit.plan` 之前运行（并完成）。如果用户明确表示他们正在跳过澄清（例如，探索性刺探），您可以继续，但必须警告下游返工风险会增加。\n\n执行步骤：\n\n1. 从仓库根目录运行一次 `{SCRIPT}`（组合 `--json --paths-only` 模式 / `-Json -PathsOnly`）。解析最小 JSON 负载字段：\n   - `FEATURE_DIR`\n   - `FEATURE_SPEC`\n   - （可选捕获 `IMPL_PLAN`, `TASKS` 用于未来的链式流程。）\n   - 如果 JSON 解析失败，则中止并指示用户重新运行 `/speckit.specify` 或验证功能分支环境。\n   - 对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. 加载当前规格文件。使用此分类法执行结构化歧义和覆盖扫描。对于每个类别，标记状态：清晰 / 部分 / 缺失。生成用于优先级排序的内部覆盖图（除非不问问题，否则不要输出原始图）。\n\n   功能范围和行为：\n   - 核心用户目标和成功标准\n   - 明确的范围外声明\n   - 用户角色 / 人物区分\n\n   领域和数据模型：\n   - 实体、属性、关系\n   - 身份和唯一性规则\n   - 生命周期/状态转换\n   - 数据量 / 规模假设\n\n   交互和用户体验流程：\n   - 关键用户旅程 / 序列\n   - 错误/空/加载状态\n   - 可访问性或本地化注释\n\n   非功能性质量属性：\n   - 性能（延迟、吞吐量目标）\n   - 可扩展性（水平/垂直、限制）\n   - 可靠性和可用性（正常运行时间、恢复期望）\n   - 可观察性（日志、指标、跟踪信号）\n   - 安全性和隐私（认证/授权、数据保护、威胁假设）\n   - 合规性 / 监管约束（如果有）\n\n   集成和外部依赖：\n   - 外部服务/API 和故障模式\n   - 数据导入/导出格式\n   - 协议/版本假设\n\n   边缘情况和故障处理：\n   - 负面场景\n   - 速率限制 / 节流\n   - 冲突解决（例如，并发编辑）\n\n   约束和权衡：\n   - 技术约束（语言、存储、托管）\n   - 明确的权衡或被拒绝的替代方案\n\n   术语和一致性：\n   - 规范术语表\n   - 避免的同义词 / 废弃术语\n\n   完成信号：\n   - 验收标准可测试性\n   - 可测量的完成定义风格指标\n\n   杂项 / 占位符：\n   - TODO 标记 / 未解决的决策\n   - 缺乏量化的模糊形容词（\"健壮的\"、\"直观的\"）\n\n   对于状态为部分或缺失的每个类别，添加一个候选问题机会，除非：\n   - 澄清不会实质性改变实施或验证策略\n   - 信息最好推迟到规划阶段（内部记录）\n\n3. 生成（内部）优先级候选澄清问题队列（最多 5 个）。不要一次性输出所有问题。应用这些约束：\n    - 整个会话最多 10 个问题。\n    - 每个问题必须可以通过以下方式回答：\n       - 短的多项选择（2-5 个不同的、互斥的选项），或\n       - 一个单词 / 短语答案（明确约束：\"答案 <=5 个单词\"）。\n    - 仅包括其答案实质性影响架构、数据建模、任务分解、测试设计、用户体验行为、运营准备或合规性验证的问题。\n    - 确保类别覆盖平衡：尝试首先覆盖最高影响的未解决类别；避免在单个高影响领域（例如，安全态势）未解决时问两个低影响问题。\n    - 排除已经回答的问题、琐碎的风格偏好或计划级执行细节（除非阻塞正确性）。\n    - 优先考虑减少下游返工风险或防止不一致验收测试的澄清。\n    - 如果超过 5 个类别仍未解决，按（影响 * 不确定性）启发式选择前 5 个。\n\n4. 顺序提问循环（交互式）：\n    - 一次只提出一个问题。\n    - 对于多项选择问题：\n       - **分析所有选项**并根据以下确定**最合适的选项**：\n          - 项目类型的最佳实践\n          - 类似实现中的常见模式\n          - 风险降低（安全性、性能、可维护性）\n          - 与规格中可见的任何明确项目目标或约束对齐\n       - 突出显示您的**推荐选项**在顶部，并提供明确的理由（1-2 句解释为什么这是最佳选择）。\n       - 格式为：`**推荐：** 选项 [X] - <理由>`\n       - 然后将所有选项呈现为 Markdown 表格：\n\n       | 选项 | 描述 |\n       |--------|-------------|\n       | A | <选项 A 描述> |\n       | B | <选项 B 描述> |\n       | C | <选项 C 描述>（根据需要添加 D/E 至多 5 个） |\n       | 简短 | 提供不同的简短答案（<=5 个单词）（仅在自由形式替代方案适当时包含） |\n\n       - 表格后添加：`您可以回复选项字母（例如，\"A\"），通过说\"yes\"或\"recommended\"接受推荐，或提供您自己的简短答案。`\n    - 对于简短答案风格（无有意义的离散选项）：\n       - 提供您的**建议答案**基于最佳实践和上下文。\n       - 格式为：`**建议：** <您的建议答案> - <简要理由>`\n       - 然后输出：`格式：简短答案（<=5 个单词）。您可以通过说\"yes\"或\"suggested\"接受建议，或提供您自己的答案。`\n    - 用户回答后：\n       - 如果用户回复\"yes\"、\"recommended\"或\"suggested\"，使用您之前声明的推荐/建议作为答案。\n       - 否则，验证答案映射到一个选项或符合 <=5 个单词的约束。\n       - 如果模糊，要求快速澄清（计数仍属于同一问题；不要前进）。\n       - 一旦满意，将其记录在工作内存中（尚不写入磁盘）并移至下一个排队问题。\n    - 停止进一步提问当：\n       - 所有关键歧义提前解决（剩余排队项目变得不必要），或\n       - 用户发出完成信号（\"done\"、\"good\"、\"no more\"），或\n       - 您达到 5 个已问问题。\n    - 永远不要提前透露未来排队的问题。\n    - 如果开始时没有有效问题，立即报告没有关键歧义。\n\n5. 每个接受答案后的集成（增量更新方法）：\n    - 维护规格的内存表示（启动时加载一次）加上原始文件内容。\n    - 对于此会话中的第一个集成答案：\n       - 确保存在 `## Clarifications` 部分（如果缺失，则在规格模板中最高级上下文/概述部分之后创建）。\n       - 在其下创建（如果不存在）一个 `### Session YYYY-MM-DD` 子标题用于今天。\n    - 接受后立即追加一个项目符号行：`- Q: <问题> → A: <最终答案>`。\n    - 然后立即将澄清应用到最合适的部分：\n       - 功能歧义 → 更新或在功能要求中添加项目符号。\n       - 用户交互 / 行为者区分 → 更新用户故事或行为者子部分（如果存在）与澄清的角色、约束或场景。\n       - 数据形状 / 实体 → 更新数据模型（添加字段、类型、关系）保持排序；简洁地记录添加的约束。\n       - 非功能性约束 → 在非功能性 / 质量属性部分添加/修改可测量标准（将模糊形容词转换为指标或明确目标）。\n       - 边缘情况 / 负面流程 → 在边缘情况 / 错误处理下添加新项目符号（或创建此类子部分如果模板提供占位符）。\n       - 术语冲突 → 规范化整个规格中的术语；仅在必要时保留原始术语，添加`(以前称为\"X\")`一次。\n    - 如果澄清使早期模糊声明无效，则替换该声明而不是重复；不留过时的矛盾文本。\n    - 每次集成后保存规格文件以最小化上下文丢失风险（原子覆盖）。\n    - 保持格式：不要重新排序无关部分；保持标题层次结构完整。\n    - 保持每个插入的澄清最小且可测试（避免叙述性漂移）。\n\n6. 验证（每次写入后执行加上最终通过）：\n   - 澄清会话包含每个接受答案的一个项目符号（无重复）。\n   - 总问（接受）问题 ≤ 5。\n   - 更新部分不包含新的答案应该解决的模糊占位符。\n   - 无矛盾的早期声明保留（扫描移除的无效替代选择）。\n   - Markdown 结构有效；仅允许新标题：`## Clarifications`, `### Session YYYY-MM-DD`。\n   - 术语一致性：所有更新部分使用相同的规范术语。\n\n7. 将更新的规格写回 `FEATURE_SPEC`。\n\n8. 报告完成（提问循环结束或提前终止后）：\n   - 问和回答的问题数量。\n   - 更新规格的路径。\n   - 触及的部分（列出名称）。\n   - 覆盖摘要表列出每个分类类别，状态：已解决（之前部分/缺失并已解决）、推迟（超出问题配额或更适合规划）、清晰（已足够）、未解决（仍部分/缺失但影响低）。\n   - 如果有任何未解决或推迟的，建议是否继续到 `/speckit.plan` 或稍后再次运行 `/speckit.clarify`。\n   - 建议的下一个命令。\n\n行为规则：\n\n- 如果未发现有意义的歧义（或所有潜在问题都是低影响的），回应：\"未检测到值得正式澄清的关键歧义。\"并建议继续。\n- 如果规格文件缺失，指示用户先运行 `/speckit.specify`（不要在此处创建新规格）。\n- 永远不要超过 5 个总问问题（澄清重试单个问题不计入新问题）。\n- 避免推测性技术栈问题，除非缺失会阻塞功能清晰度。\n- 尊重用户提前终止信号（\"stop\"、\"done\"、\"proceed\"）。\n- 如果由于完全覆盖而未问问题，输出紧凑的覆盖摘要（所有类别清晰）然后建议前进。\n- 如果配额达到但仍有未解决的高影响类别，明确标记它们为推迟并附上理由。\n\n优先级上下文：{ARGS}"
              },
              {
                "name": "/constitution",
                "description": "根据交互式或提供的原则输入创建或更新项目宪章，确保所有依赖模板保持同步",
                "path": "skills/speckit-specify-zh/assets/specify/templates/commands/constitution.md",
                "frontmatter": {
                  "description": "根据交互式或提供的原则输入创建或更新项目宪章，确保所有依赖模板保持同步"
                },
                "content": "## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n您正在更新位于 `/memory/constitution.md` 的项目宪章。此文件是一个模板，包含方括号中的占位符标记（例如 `[PROJECT_NAME]`, `[PRINCIPLE_1_NAME]`）。您的工作是 (a) 收集/推导具体值，(b) 精确填充模板，以及 (c) 传播任何修订到依赖工件。\n\n遵循此执行流程：\n\n1. 加载位于 `/memory/constitution.md` 的现有宪章模板。\n   - 识别形式为 `[ALL_CAPS_IDENTIFIER]` 的每个占位符标记。\n   **重要**：用户可能需要比模板中使用的更少或更多的原则。如果指定了数量，请尊重 - 遵循通用模板。您将相应地更新文档。\n\n2. 收集/推导占位符的值：\n   - 如果用户输入（对话）提供了值，则使用它。\n   - 否则从现有仓库上下文（README、文档、先前的宪章版本（如果嵌入））推断。\n   - 对于治理日期：`RATIFICATION_DATE` 是原始采用日期（如果未知则询问或标记 TODO），`LAST_AMENDED_DATE` 是今天如果进行了更改，否则保持先前日期。\n   - `CONSTITUTION_VERSION` 必须根据语义版本规则递增：\n     - MAJOR：向后不兼容的治理/原则删除或重新定义。\n     - MINOR：添加新原则/部分或实质性扩展指导。\n     - PATCH：澄清、措辞、拼写错误修复、非语义性改进。\n   - 如果版本提升类型不明确，在最终确定前提出理由。\n\n3. 起草更新的宪章内容：\n   - 用具体文本替换每个占位符（除了项目选择尚未定义的故意保留的模板槽位 - 明确说明任何保留的槽位）。\n   - 保持标题层次结构，注释可以在替换后删除，除非它们仍然提供澄清指导。\n   - 确保每个原则部分：简洁的名称行，段落（或项目符号列表）捕获不可协商的规则，如果不是显而易见则提供明确的理由。\n   - 确保治理部分列出修订程序、版本政策和合规性审查期望。\n\n4. 一致性传播检查表（将先前的检查表转换为积极验证）：\n   - 读取 `/templates/plan-template.md` 并确保任何\"宪章检查\"或规则与更新的原则对齐。\n   - 读取 `/templates/spec-template.md` 以对齐范围/要求 - 如果宪章添加/删除了强制性部分或约束则更新。\n   - 读取 `/templates/tasks-template.md` 并确保任务分类反映新增或删除的原则驱动任务类型（例如，可观察性、版本控制、测试纪律）。\n   - 读取 `/templates/commands/*.md` 中的每个命令文件（包括此文件）以验证没有过时的引用（仅当需要通用指导时保留特定代理名称如 CLAUDE）。\n   - 读取任何运行时指导文档（例如，`README.md`, `docs/quickstart.md`，或特定代理指导文件（如果存在））。更新对更改原则的引用。\n\n5. 生成同步影响报告（在更新后作为 HTML 注释预置在宪章文件顶部）：\n   - 版本变更：旧 → 新\n   - 修改的原则列表（旧标题 → 新标题如果重命名）\n   - 添加的部分\n   - 删除的部分\n   - 需要更新的模板（✅ 已更新 / ⚠ 待处理）及文件路径\n   - 如果有任何占位符故意推迟则列出。\n\n6. 最终输出前的验证：\n   - 没有剩余的未解释括号标记。\n   - 版本行与报告匹配。\n   - 日期为 ISO 格式 YYYY-MM-DD。\n   - 原则是陈述性的、可测试的，并且没有模糊语言（\"应该\" → 在适当时替换为 MUST/SHOULD 理由）。\n\n7. 将完成的宪章写回 `/memory/constitution.md`（覆盖）。\n\n8. 向用户输出最终摘要：\n   - 新版本和提升理由。\n   - 任何标记为手动跟进的文件。\n   - 建议的提交消息（例如，`docs: 修订宪章至 vX.Y.Z（原则添加 + 治理更新）`）。\n\n格式和样式要求：\n\n- 完全按照模板中的 Markdown 标题使用（不要降级/升级级别）。\n- 包装长理由行以保持可读性（理想情况下 <100 个字符），但不要用尴尬的断行强制执行。\n- 在部分之间保持单个空行。\n- 避免尾随空格。\n\n如果用户提供部分更新（例如，仅一个原则修订），仍执行验证和版本决策步骤。\n\n如果关键信息缺失（例如，批准日期真正未知），插入 `TODO(<FIELD_NAME>): explanation` 并在同步影响报告的推迟项目下列出。\n\n不要创建新模板；始终在现有的 `/memory/constitution.md` 文件上操作。"
              },
              {
                "name": "/implement",
                "description": "通过处理和执行 tasks.md 中定义的所有任务来执行实现计划",
                "path": "skills/speckit-specify-zh/assets/specify/templates/commands/implement.md",
                "frontmatter": {
                  "description": "通过处理和执行 tasks.md 中定义的所有任务来执行实现计划",
                  "scripts": {
                    "sh": "scripts/bash/check-prerequisites.sh --json --require-tasks --include-tasks",
                    "ps": "scripts/powershell/check-prerequisites.ps1 -Json -RequireTasks -IncludeTasks"
                  }
                },
                "content": "## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n1. 从仓库根目录运行 `{SCRIPT}` 并解析 FEATURE_DIR 和 AVAILABLE_DOCS 列表。所有路径必须是绝对的。对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **检查检查表状态**（如果 FEATURE_DIR/checklists/ 存在）：\n   - 扫描 checklists/ 目录中的所有检查表文件\n   - 对于每个检查表，计数：\n     - 总项目：所有匹配 `- [ ]` 或 `- [X]` 或 `- [x]` 的行\n     - 完成项目：匹配 `- [X]` 或 `- [x]` 的行\n     - 未完成项目：匹配 `- [ ]` 的行\n   - 创建状态表：\n\n     ```text\n     | 检查表 | 总计 | 已完成 | 未完成 | 状态 |\n     |-----------|-------|-----------|------------|--------|\n     | ux.md     | 12    | 12        | 0          | ✓ 通过 |\n     | test.md   | 8     | 5         | 3          | ✗ 失败 |\n     | security.md | 6   | 6         | 0          | ✓ 通过 |\n     ```\n\n   - 计算总体状态：\n     - **通过**：所有检查表都有 0 个未完成项目\n     - **失败**：一个或多个检查表有未完成项目\n\n   - **如果有任何检查表未完成**：\n     - 显示包含未完成项目计数的表格\n     - **停止**并询问：\"一些检查表未完成。您是否仍要继续执行实现？(yes/no)\"\n     - 等待用户响应后再继续\n     - 如果用户说\"no\"或\"wait\"或\"stop\"，则停止执行\n     - 如果用户说\"yes\"或\"proceed\"或\"continue\"，则继续到步骤 3\n\n   - **如果所有检查表都完成**：\n     - 显示表格显示所有检查表已通过\n     - 自动继续到步骤 3\n\n3. 加载和分析实现上下文：\n   - **必需**：读取 tasks.md 以获取完整的任务列表和执行计划\n   - **必需**：读取 plan.md 以获取技术栈、架构和文件结构\n   - **如果存在**：读取 data-model.md 以获取实体和关系\n   - **如果存在**：读取 contracts/ 以获取 API 规范和测试要求\n   - **如果存在**：读取 research.md 以获取技术决策和约束\n   - **如果存在**：读取 quickstart.md 以获取集成场景\n\n4. **项目设置验证**：\n   - **必需**：根据实际项目设置创建/验证忽略文件：\n\n   **检测和创建逻辑**：\n   - 检查以下命令是否成功以确定仓库是否为 git 仓库（如果是则创建/验证 .gitignore）：\n\n     ```sh\n     git rev-parse --git-dir 2>/dev/null\n     ```\n\n   - 检查是否存在 Dockerfile* 或 Docker 在 plan.md 中 → 创建/验证 .dockerignore\n   - 检查是否存在 .eslintrc* 或 eslint.config.* → 创建/验证 .eslintignore\n   - 检查是否存在 .prettierrc* → 创建/验证 .prettierignore\n   - 检查是否存在 .npmrc 或 package.json → 创建/验证 .npmignore（如果发布）\n   - 检查是否存在 terraform 文件 (*.tf) → 创建/验证 .terraformignore\n   - 检查是否需要 .helmignore（存在 helm 图表）→ 创建/验证 .helmignore\n\n   **如果忽略文件已存在**：验证它包含基本模式，仅追加缺失的关键模式\n   **如果忽略文件缺失**：创建包含检测技术的完整模式集\n\n   **按技术的常见模式**（来自 plan.md 技术栈）：\n   - **Node.js/JavaScript/TypeScript**：`node_modules/`, `dist/`, `build/`, `*.log`, `.env*`\n   - **Python**：`__pycache__/`, `*.pyc`, `.venv/`, `venv/`, `dist/`, `*.egg-info/`\n   - **Java**：`target/`, `*.class`, `*.jar`, `.gradle/`, `build/`\n   - **C#/.NET**：`bin/`, `obj/`, `*.user`, `*.suo`, `packages/`\n   - **Go**：`*.exe`, `*.test`, `vendor/`, `*.out`\n   - **Ruby**：`.bundle/`, `log/`, `tmp/`, `*.gem`, `vendor/bundle/`\n   - **PHP**：`vendor/`, `*.log`, `*.cache`, `*.env`\n   - **Rust**：`target/`, `debug/`, `release/`, `*.rs.bk`, `*.rlib`, `*.prof*`, `.idea/`, `*.log`, `.env*`\n   - **Kotlin**：`build/`, `out/`, `.gradle/`, `.idea/`, `*.class`, `*.jar`, `*.iml`, `*.log`, `.env*`\n   - **C++**：`build/`, `bin/`, `obj/`, `out/`, `*.o`, `*.so`, `*.a`, `*.exe`, `*.dll`, `.idea/`, `*.log`, `.env*`\n   - **C**：`build/`, `bin/`, `obj/`, `out/`, `*.o`, `*.a`, `*.so`, `*.exe`, `Makefile`, `config.log`, `.idea/`, `*.log`, `.env*`\n   - **Swift**：`.build/`, `DerivedData/`, `*.swiftpm/`, `Packages/`\n   - **R**：`.Rproj.user/`, `.Rhistory`, `.RData`, `.Ruserdata`, `*.Rproj`, `packrat/`, `renv/`\n   - **通用**：`.DS_Store`, `Thumbs.db`, `*.tmp`, `*.swp`, `.vscode/`, `.idea/`\n\n   **工具特定模式**：\n   - **Docker**：`node_modules/`, `.git/`, `Dockerfile*`, `.dockerignore`, `*.log*`, `.env*`, `coverage/`\n   - **ESLint**：`node_modules/`, `dist/`, `build/`, `coverage/`, `*.min.js`\n   - **Prettier**：`node_modules/`, `dist/`, `build/`, `coverage/`, `package-lock.json`, `yarn.lock`, `pnpm-lock.yaml`\n   - **Terraform**：`.terraform/`, `*.tfstate*`, `*.tfvars`, `.terraform.lock.hcl`\n   - **Kubernetes/k8s**：`*.secret.yaml`, `secrets/`, `.kube/`, `kubeconfig*`, `*.key`, `*.crt`\n\n5. 解析 tasks.md 结构并提取：\n   - **任务阶段**：设置、测试、核心、集成、完善\n   - **任务依赖**：顺序与并行执行规则\n   - **任务详情**：ID、描述、文件路径、并行标记 [P]\n   - **执行流程**：顺序和依赖要求\n\n6. 按照任务计划执行实现：\n   - **阶段执行**：完成每个阶段后再进入下一个\n   - **尊重依赖**：按顺序运行顺序任务，并行任务 [P] 可以一起运行  \n   - **遵循 TDD 方法**：在相应的实现任务之前执行测试任务\n   - **基于文件的协调**：影响相同文件的任务必须顺序运行\n   - **验证检查点**：在继续之前验证每个阶段的完成情况\n\n7. 实现执行规则：\n   - **首先设置**：初始化项目结构、依赖、配置\n   - **测试优先于代码**：如果需要为契约、实体和集成场景编写测试\n   - **核心开发**：实现模型、服务、CLI 命令、端点\n   - **集成工作**：数据库连接、中间件、日志、外部服务\n   - **完善和验证**：单元测试、性能优化、文档\n\n8. 进度跟踪和错误处理：\n   - 在每个完成的任务后报告进度\n   - 如果任何非并行任务失败则停止执行\n   - 对于并行任务 [P]，继续执行成功的任务，报告失败的任务\n   - 提供清晰的错误消息和调试上下文\n   - 如果实现无法继续则建议下一步\n   - **重要** 对于完成的任务，确保在任务文件中标记为 [X]。\n\n9. 完成验证：\n   - 验证所有必需任务已完成\n   - 检查实现的功能是否与原始规格匹配\n   - 验证测试通过且覆盖率符合要求\n   - 确认实现遵循技术计划\n   - 报告最终状态和已完成工作的摘要\n\n注意：此命令假设 tasks.md 中存在完整的任务分解。如果任务不完整或缺失，建议首先运行 `/speckit.tasks` 以重新生成任务列表。"
              },
              {
                "name": "/plan",
                "description": "使用计划模板执行实现规划工作流程以生成设计工件。",
                "path": "skills/speckit-specify-zh/assets/specify/templates/commands/plan.md",
                "frontmatter": {
                  "description": "使用计划模板执行实现规划工作流程以生成设计工件。",
                  "scripts": {
                    "sh": "scripts/bash/setup-plan.sh --json",
                    "ps": "scripts/powershell/setup-plan.ps1 -Json"
                  },
                  "agent_scripts": {
                    "sh": "scripts/bash/update-agent-context.sh __AGENT__",
                    "ps": "scripts/powershell/update-agent-context.ps1 -AgentType __AGENT__"
                  }
                },
                "content": "## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n1. **设置**：从仓库根目录运行 `{SCRIPT}` 并解析 JSON 以获取 FEATURE_SPEC, IMPL_PLAN, SPECS_DIR, BRANCH。对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **加载上下文**：读取 FEATURE_SPEC 和 `/memory/constitution.md`。加载 IMPL_PLAN 模板（已复制）。\n\n3. **执行计划工作流程**：按照 IMPL_PLAN 模板中的结构：\n   - 填写技术上下文（将未知标记为\"需要澄清\"）\n   - 从宪章填写宪章检查部分\n   - 评估门（如果违规未经证明则报错）\n   - 阶段 0：生成 research.md（解决所有\"需要澄清\"）\n   - 阶段 1：生成 data-model.md, contracts/, quickstart.md\n   - 阶段 1：通过运行代理脚本更新代理上下文\n   - 设计后重新评估宪章检查\n\n4. **停止并报告**：命令在阶段 2 规划后结束。报告分支、IMPL_PLAN 路径和生成的工件。\n\n## 阶段\n\n### 阶段 0：大纲和研究\n\n1. **从上面的技术上下文中提取未知项**：\n   - 对于每个\"需要澄清\" → 研究任务\n   - 对于每个依赖项 → 最佳实践任务\n   - 对于每个集成 → 模式任务\n\n2. **生成和派遣研究代理**：\n\n   ```text\n   对于技术上下文中的每个未知项：\n     任务：\"研究 {未知项} 用于 {功能上下文}\"\n   对于每个技术选择：\n     任务：\"查找 {技术} 在 {领域} 中的最佳实践\"\n   ```\n\n3. **在 `research.md` 中整合发现**，使用格式：\n   - 决策：[选择了什么]\n   - 理由：[为什么选择]\n   - 考虑的替代方案：[评估了什么其他选项]\n\n**输出**：research.md，解决所有\"需要澄清\"\n\n### 阶段 1：设计和契约\n\n**先决条件**：`research.md` 完成\n\n1. **从功能规格中提取实体** → `data-model.md`：\n   - 实体名称、字段、关系\n   - 来自要求的验证规则\n   - 如适用的状态转换\n\n2. **从功能要求生成 API 契约**：\n   - 对于每个用户操作 → 端点\n   - 使用标准 REST/GraphQL 模式\n   - 将 OpenAPI/GraphQL 模式输出到 `/contracts/`\n\n3. **代理上下文更新**：\n   - 运行 `{AGENT_SCRIPT}`\n   - 这些脚本检测使用中的 AI 代理\n   - 更新适当的代理特定上下文文件\n   - 仅添加当前计划中的新技术\n   - 保留标记之间的手动添加\n\n**输出**：data-model.md, /contracts/*, quickstart.md, 代理特定文件\n\n## 关键规则\n\n- 使用绝对路径\n- 门失败或未解决的澄清时报错"
              },
              {
                "name": "/specify",
                "description": "根据自然语言功能描述创建或更新功能规格。",
                "path": "skills/speckit-specify-zh/assets/specify/templates/commands/specify.md",
                "frontmatter": {
                  "description": "根据自然语言功能描述创建或更新功能规格。",
                  "scripts": {
                    "sh": "scripts/bash/create-new-feature.sh --json \"{ARGS}\"",
                    "ps": "scripts/powershell/create-new-feature.ps1 -Json \"{ARGS}\""
                  }
                },
                "content": "## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n用户在触发消息中输入 `/speckit.specify` 后的文本**就是**功能描述。假设您在此对话中始终可以使用它，即使下面出现 `{ARGS}` 字面意思。除非用户提供了空命令，否则不要要求用户重复。\n\n根据该功能描述，执行以下操作：\n\n1. **生成简洁的短名称**（2-4 个单词）用于分支：\n   - 分析功能描述并提取最有意义的关键词\n   - 创建一个 2-4 个单词的短名称，捕捉功能的本质\n   - 尽可能使用动作-名词格式（例如，\"add-user-auth\"，\"fix-payment-bug\"）\n   - 保留技术术语和缩写（OAuth2, API, JWT 等）\n   - 保持简洁但描述性足够，一眼就能理解功能\n   - 示例：\n     - \"我想添加用户认证\" → \"user-auth\"\n     - \"为 API 实现 OAuth2 集成\" → \"oauth2-api-integration\"\n     - \"创建分析仪表板\" → \"analytics-dashboard\"\n     - \"修复支付处理超时错误\" → \"fix-payment-timeout\"\n\n2. **在创建新分支前检查现有分支**：\n   \n   a. 首先，获取所有远程分支以确保我们有最新信息：\n      ```bash\n      git fetch --all --prune\n      ```\n   \n   b. 查找短名称的最高功能编号：\n      - 远程分支：`git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`\n      - 本地分支：`git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`\n      - 规格目录：检查匹配 `specs/[0-9]+-<short-name>` 的目录\n   \n   c. 确定下一个可用编号：\n      - 从所有三个来源提取所有编号\n      - 找到最高编号 N\n      - 使用 N+1 作为新分支编号\n   \n   d. 使用计算出的编号和短名称运行脚本 `{SCRIPT}`：\n      - 传递 `--number N+1` 和 `--short-name \"your-short-name\"` 以及功能描述\n      - Bash 示例：`{SCRIPT} --json --number 5 --short-name \"user-auth\" \"添加用户认证\"`\n      - PowerShell 示例：`{SCRIPT} -Json -Number 5 -ShortName \"user-auth\" \"添加用户认证\"`\n   \n   **重要**：\n   - 检查所有三个来源（远程分支、本地分支、规格目录）以找到最高编号\n   - 仅匹配具有确切短名称模式的分支/目录\n   - 如果未找到具有此短名称的现有分支/目录，则从编号 1 开始\n   - 每个功能只能运行此脚本一次\n   - JSON 在终端中作为输出提供 - 始终参考它以获取您要查找的实际内容\n   - JSON 输出将包含 BRANCH_NAME 和 SPEC_FILE 路径\n   - 对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）\n\n3. 加载 `templates/spec-template.md` 以了解必需部分。\n\n4. 遵循此执行流程：\n\n    1. 从输入解析用户描述\n       如果为空：错误 \"未提供功能描述\"\n    2. 从描述中提取关键概念\n       识别：参与者、动作、数据、约束\n    3. 对于不清楚的方面：\n       - 基于上下文和行业标准做出有根据的猜测\n       - 仅在以下情况下标记 [需要澄清：具体问题]：\n         - 选择显著影响功能范围或用户体验\n         - 存在多种合理解释且有不同的含义\n         - 没有合理的默认值\n       - **限制：最多 3 个 [需要澄清] 标记**\n       - 按影响优先级排序：范围 > 安全/隐私 > 用户体验 > 技术细节\n    4. 填写用户场景和测试部分\n       如果没有明确的用户流程：错误 \"无法确定用户场景\"\n    5. 生成功能要求\n       每个要求必须可测试\n       为未指定的细节使用合理的默认值（在假设部分记录假设）\n    6. 定义成功标准\n       创建可测量的、技术无关的结果\n       包括定量指标（时间、性能、数量）和定性措施（用户满意度、任务完成）\n       每个标准必须在没有实现细节的情况下可验证\n    7. 识别关键实体（如果涉及数据）\n    8. 返回：成功（规格已准备好规划）\n\n5. 使用模板结构将规格写入 SPEC_FILE，将占位符替换为从功能描述（参数）中得出的具体细节，同时保持部分顺序和标题。\n\n6. **规格质量验证**：在编写初始规格后，根据质量标准进行验证：\n\n   a. **创建规格质量检查表**：在 `FEATURE_DIR/checklists/requirements.md` 生成检查表文件，使用检查表模板结构和这些验证项目：\n\n      ```markdown\n      # 规格质量检查表：[功能名称]\n      \n      **目的**：在继续规划之前验证规格完整性和质量\n      **创建时间**：[日期]\n      **功能**：[链接到 spec.md]\n      \n      ## 内容质量\n      \n      - [ ] 无实现细节（语言、框架、API）\n      - [ ] 专注于用户价值和业务需求\n      - [ ] 为非技术利益相关者编写\n      - [ ] 所有必需部分已完成\n      \n      ## 要求完整性\n      \n      - [ ] 无 [需要澄清] 标记\n      - [ ] 要求可测试且明确\n      - [ ] 成功标准可测量\n      - [ ] 成功标准技术无关（无实现细节）\n      - [ ] 所有验收场景已定义\n      - [ ] 边缘情况已识别\n      - [ ] 范围明确界定\n      - [ ] 依赖关系和假设已识别\n      \n      ## 功能准备度\n      \n      - [ ] 所有功能要求都有明确的验收标准\n      - [ ] 用户场景涵盖主要流程\n      - [ ] 功能满足成功标准中定义的可测量结果\n      - [ ] 无实现细节泄露到规格中\n      \n      ## 备注\n      \n      - 标记为不完整的项目需要在 `/speckit.clarify` 或 `/speckit.plan` 之前更新规格\n      ```\n\n   b. **运行验证检查**：根据每个检查表项目审查规格：\n      - 对于每个项目，确定它是通过还是失败\n      - 记录发现的具体问题（引用相关规格部分）\n\n   c. **处理验证结果**：\n\n      - **如果所有项目都通过**：标记检查表完成并继续到步骤 6\n\n      - **如果项目失败（不包括 [需要澄清]）**：\n        1. 列出失败的项目和具体问题\n        2. 更新规格以解决每个问题\n        3. 重新运行验证直到所有项目通过（最多 3 次迭代）\n        4. 如果 3 次迭代后仍失败，将剩余问题记录在检查表备注中并警告用户\n\n      - **如果 [需要澄清] 标记仍然存在**：\n        1. 从规格中提取所有 [需要澄清：...] 标记\n        2. **限制检查**：如果标记超过 3 个，仅保留 3 个最关键（按范围/安全/用户体验影响）并为其余标记做出有根据的猜测\n        3. 对于每个需要的澄清（最多 3 个），以以下格式向用户呈现选项：\n\n           ```markdown\n           ## 问题 [N]：[主题]\n           \n           **上下文**：[引用相关规格部分]\n           \n           **我们需要知道**：[来自需要澄清标记的具体问题]\n           \n           **建议答案**：\n           \n           | 选项 | 答案 | 影响 |\n           |--------|--------|--------------|\n           | A      | [第一个建议答案] | [这对功能意味着什么] |\n           | B      | [第二个建议答案] | [这对功能意味着什么] |\n           | C      | [第三个建议答案] | [这对功能意味着什么] |\n           | 自定义 | 提供您自己的答案 | [解释如何提供自定义输入] |\n           \n           **您的选择**：_[等待用户响应]_\n           ```\n\n        4. **关键 - 表格格式**：确保 markdown 表格格式正确：\n           - 使用一致的间距，管道对齐\n           - 每个单元格应有内容周围的空格：`| 内容 |` 而不是 `|内容|`\n           - 标题分隔符必须至少有 3 个破折号：`|--------|`\n           - 测试表格在 markdown 预览中正确渲染\n        5. 顺序编号问题（Q1, Q2, Q3 - 最多 3 个总计）\n        6. 在等待响应之前一起呈现所有问题\n        7. 等待用户响应他们对所有问题的选择（例如，\"Q1: A, Q2: 自定义 - [详情], Q3: B\"）\n        8. 通过将每个 [需要澄清] 标记替换为用户选择或提供的答案来更新规格\n        9. 在所有澄清解决后重新运行验证\n\n   d. **更新检查表**：在每次验证迭代后，使用当前通过/失败状态更新检查表文件\n\n7. 报告完成情况，包括分支名称、规格文件路径、检查表结果和下一阶段的准备情况（`/speckit.clarify` 或 `/speckit.plan`）。\n\n**注意**：脚本创建并检出新分支并在写入前初始化规格文件。\n\n## 一般指南\n\n## 快速指南\n\n- 专注于用户需要**什么**和**为什么**。\n- 避免如何实现（无技术栈、API、代码结构）。\n- 为业务利益相关者编写，而不是开发人员。\n- 不要创建嵌入在规格中的任何检查表。那将是单独的命令。\n\n### 部分要求\n\n- **必需部分**：每个功能必须完成\n- **可选部分**：仅在与功能相关时包含\n- 当部分不适用时，完全删除（不要留作\"N/A\"）\n\n### 对于 AI 生成\n\n从用户提示创建此规格时：\n\n1. **做出有根据的猜测**：使用上下文、行业标准和常见模式填补空白\n2. **记录假设**：在假设部分记录合理的默认值\n3. **限制澄清**：最多 3 个 [需要澄清] 标记 - 仅用于关键决策：\n   - 显著影响功能范围或用户体验\n   - 有多种合理解释且有不同的含义\n   - 没有合理的默认值\n4. **优先级澄清**：范围 > 安全/隐私 > 用户体验 > 技术细节\n5. **像测试人员一样思考**：每个模糊要求都应无法通过\"可测试和明确\"检查表项目\n6. **需要澄清的常见领域**（如果没有合理的默认值）：\n   - 功能范围和边界（包括/排除特定用例）\n   - 用户类型和权限（如果存在多个冲突解释）\n   - 安全/合规要求（当法律/财务重要时）\n\n**合理默认值示例**（不要询问这些）：\n\n- 数据保留：该领域的行业标准实践\n- 性能目标：标准网络/移动应用期望（除非指定）\n- 错误处理：用户友好的消息和适当的回退\n- 认证方法：标准基于会话或 OAuth2 用于 Web 应用\n- 集成模式：RESTful API（除非另有说明）\n\n### 成功标准指南\n\n成功标准必须：\n\n1. **可测量**：包括具体指标（时间、百分比、数量、比率）\n2. **技术无关**：不提及框架、语言、数据库或工具\n3. **用户导向**：从用户/业务角度描述结果，而不是系统内部\n4. **可验证**：可以在不知道实现细节的情况下测试/验证\n\n**好示例**：\n\n- \"用户可以在 3 分钟内完成结账\"\n- \"系统支持 10,000 个并发用户\"\n- \"95% 的搜索在 1 秒内返回结果\"\n- \"任务完成率提高 40%\"\n\n**坏示例**（实现导向）：\n\n- \"API 响应时间低于 200ms\"（太技术性，使用\"用户立即看到结果\"）\n- \"数据库可以处理 1000 TPS\"（实现细节，使用面向用户的指标）\n- \"React 组件高效渲染\"（框架特定）\n- \"Redis 缓存命中率高于 80%\"（技术特定）"
              },
              {
                "name": "/tasks",
                "description": "基于可用设计工件为功能生成可操作的、按依赖顺序排列的 tasks.md。",
                "path": "skills/speckit-specify-zh/assets/specify/templates/commands/tasks.md",
                "frontmatter": {
                  "description": "基于可用设计工件为功能生成可操作的、按依赖顺序排列的 tasks.md。",
                  "scripts": {
                    "sh": "scripts/bash/check-prerequisites.sh --json",
                    "ps": "scripts/powershell/check-prerequisites.ps1 -Json"
                  }
                },
                "content": "## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n1. **设置**：从仓库根目录运行 `{SCRIPT}` 并解析 FEATURE_DIR 和 AVAILABLE_DOCS 列表。所有路径必须是绝对的。对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **加载设计文档**：从 FEATURE_DIR 读取：\n   - **必需**：plan.md（技术栈、库、结构），spec.md（带优先级的用户故事）\n   - **可选**：data-model.md（实体），contracts/（API 端点），research.md（决策），quickstart.md（测试场景）\n   - 注意：并非所有项目都有所有文档。根据可用内容生成任务。\n\n3. **执行任务生成工作流程**：\n   - 加载 plan.md 并提取技术栈、库、项目结构\n   - 加载 spec.md 并提取带优先级的用户故事（P1, P2, P3 等）\n   - 如果存在 data-model.md：提取实体并映射到用户故事\n   - 如果存在 contracts/：将端点映射到用户故事\n   - 如果存在 research.md：提取决策用于设置任务\n   - 生成按用户故事组织的任务（参见下面的任务生成规则）\n   - 生成依赖图显示用户故事完成顺序\n   - 为每个用户故事创建并行执行示例\n   - 验证任务完整性（每个用户故事都有所需任务，可独立测试）\n\n4. **生成 tasks.md**：使用 `.specify/templates/tasks-template.md` 作为结构，填充：\n   - 从 plan.md 获取正确的功能名称\n   - 阶段 1：设置任务（项目初始化）\n   - 阶段 2：基础任务（所有用户故事的阻塞先决条件）\n   - 阶段 3+：按 spec.md 中的优先级顺序排列的每个用户故事一个阶段\n   - 每个阶段包括：故事目标、独立测试标准、测试（如果要求）、实现任务\n   - 最终阶段：完善和跨领域关注点\n   - 所有任务必须遵循严格的检查表格式（参见下面的任务生成规则）\n   - 每个任务的明确文件路径\n   - 依赖关系部分显示故事完成顺序\n   - 每个故事的并行执行示例\n   - 实现策略部分（MVP 优先、增量交付）\n\n5. **报告**：输出生成的 tasks.md 路径和摘要：\n   - 总任务数\n   - 每个用户故事的任务数\n   - 识别的并行机会\n   - 每个故事的独立测试标准\n   - 建议的 MVP 范围（通常仅为用户故事 1）\n   - 格式验证：确认所有任务都遵循检查表格式（复选框、ID、标签、文件路径）\n\n为任务生成提供上下文：{ARGS}\n\ntasks.md 应该是立即可执行的 - 每个任务必须足够具体，以便 LLM 可以在没有额外上下文的情况下完成它。\n\n## 任务生成规则\n\n**关键**：任务必须按用户故事组织，以实现独立实现和测试。\n\n**测试是可选的**：仅在功能规格中明确要求或用户要求 TDD 方法时才生成测试任务。\n\n### 检查表格式（必需）\n\n每个任务必须严格遵循此格式：\n\n```text\n- [ ] [任务ID] [P?] [故事?] 带文件路径的描述\n```\n\n**格式组件**：\n\n1. **复选框**：始终以 `- [ ]` 开头（markdown 复选框）\n2. **任务 ID**：按执行顺序的序列号（T001, T002, T003...）\n3. **[P] 标记**：仅当任务可并行化时包含（不同文件，不依赖未完成任务）\n4. **[故事] 标签**：仅用户故事阶段任务必需\n   - 格式：[US1], [US2], [US3], 等（映射到 spec.md 中的用户故事）\n   - 设置阶段：无故事标签\n   - 基础阶段：无故事标签  \n   - 用户故事阶段：必须有故事标签\n   - 完善阶段：无故事标签\n5. **描述**：带确切文件路径的明确操作\n\n**示例**：\n\n- ✅ 正确：`- [ ] T001 根据实现计划创建项目结构`\n- ✅ 正确：`- [ ] T005 [P] 在 src/middleware/auth.py 中实现认证中间件`\n- ✅ 正确：`- [ ] T012 [P] [US1] 在 src/models/user.py 中创建用户模型`\n- ✅ 正确：`- [ ] T014 [US1] 在 src/services/user_service.py 中实现 UserService`\n- ❌ 错误：`- [ ] 创建用户模型`（缺少 ID 和故事标签）\n- ❌ 错误：`T001 [US1] 创建模型`（缺少复选框）\n- ❌ 错误：`- [ ] [US1] 创建用户模型`（缺少任务 ID）\n- ❌ 错误：`- [ ] T001 [US1] 创建模型`（缺少文件路径）\n\n### 任务组织\n\n1. **来自用户故事（spec.md）** - 主要组织：\n   - 每个用户故事（P1, P2, P3...）都有自己的阶段\n   - 将所有相关组件映射到它们的故事：\n     - 该故事需要的模型\n     - 该故事需要的服务\n     - 该故事需要的端点/UI\n     - 如果要求测试：该故事的特定测试\n   - 标记故事依赖关系（大多数故事应该是独立的）\n\n2. **来自契约**：\n   - 将每个契约/端点 → 映射到它服务的用户故事\n   - 如果要求测试：每个契约 → 在该故事阶段实现前的契约测试任务 [P]\n\n3. **来自数据模型**：\n   - 将每个实体映射到需要它的用户故事\n   - 如果实体服务于多个故事：放在最早的故事或设置阶段\n   - 关系 → 在适当的故事阶段中的服务层任务\n\n4. **来自设置/基础设施**：\n   - 共享基础设施 → 设置阶段（阶段 1）\n   - 基础/阻塞任务 → 基础阶段（阶段 2）\n   - 故事特定设置 → 在该故事的阶段内\n\n### 阶段结构\n\n- **阶段 1**：设置（项目初始化）\n- **阶段 2**：基础（阻塞先决条件 - 必须在用户故事前完成）\n- **阶段 3+**：按优先级顺序的用户故事（P1, P2, P3...）\n  - 在每个故事内：测试（如果要求）→ 模型 → 服务 → 端点 → 集成\n  - 每个阶段应该是一个完整的、可独立测试的增量\n- **最终阶段**：完善和跨领域关注点"
              }
            ],
            "skills": [
              {
                "name": "openspec-archiving-cn",
                "description": "归档已完成的变更并将规范差异合并到常驻文档。用于变更已部署、准备归档或实施后需要更新规范时。触发词包括 \"openspec归档\", \"归档\", \"归档提案\", \"合并规范\", \"完成提案\", \"更新文档\", \"定稿规范\", \"标记完成\"。",
                "path": "skills/openspec-archiving-cn/SKILL.md",
                "frontmatter": {
                  "name": "openspec-archiving-cn",
                  "description": "归档已完成的变更并将规范差异合并到常驻文档。用于变更已部署、准备归档或实施后需要更新规范时。触发词包括 \"openspec归档\", \"归档\", \"归档提案\", \"合并规范\", \"完成提案\", \"更新文档\", \"定稿规范\", \"标记完成\"。"
                },
                "content": "# 规范归档\n\n归档已完成的变更提案，并将其规范差异合并到常驻规范文档中。\n\n## 快速开始\n\n归档包含两项主要操作：\n1. **移动变更目录**至带时间戳的归档位置\n2. **合并规范差异**到常驻规范（ADDED/MODIFIED/REMOVED）\n\n**关键规则**：在归档前验证所有任务已完成。归档意味着已部署且完成。\n\n## 工作流\n\n复制此清单并跟踪进度：\n\n```\n归档进度:\n- [ ] 第 1 步：验证实施完成\n- [ ] 第 2 步：审阅待合并的规范差异\n- [ ] 第 3 步：创建带时间戳的归档目录\n- [ ] 第 4 步：合并 ADDED 需求到常驻规范\n- [ ] 第 5 步：合并 MODIFIED 需求到常驻规范\n- [ ] 第 6 步：合并 REMOVED 需求到常驻规范\n- [ ] 第 7 步：移动变更目录到归档\n- [ ] 第 8 步：验证常驻规范结构\n```\n\n### 第 1 步：验证实施完成\n\n在归档前确认所有工作已完成：\n\n```bash\n# 检查 IMPLEMENTED 标记\ntest -f spec/changes/{change-id}/IMPLEMENTED && echo \"✓ 已实施\" || echo \"✗ 未实施\"\n\n# 查看任务\ncat spec/changes/{change-id}/tasks.json\n\n# 使用 git 检查未提交工作\ngit status\n```\n\n**询问用户**：\n```markdown\n所有任务是否已完成并通过测试？\n该变更是否已部署到生产？\n是否继续归档？\n```\n\n### 第 2 步：审阅待合并的规范差异\n\n了解需要合并的内容：\n\n```bash\n# 列出所有规范差异文件\nfind spec/changes/{change-id}/specs -name \"*.md\" -type f\n\n# 读取每个差异文件\nfor file in spec/changes/{change-id}/specs/**/*.md; do\n    echo \"=== $file ===\"\n    cat \"$file\"\ndone\n```\n\n**识别**：\n- 哪些能力受到影响\n- ADDED/MODIFIED/REMOVED 各有多少需求\n- 这些变更在常驻规范中的归属位置\n\n### 第 3 步：创建带时间戳的归档目录\n\n```bash\n# 以当天日期创建归档目录\nTIMESTAMP=$(date +%Y-%m-%d)\nmkdir -p spec/archive/${TIMESTAMP}-{change-id}\n```\n\n**示例**：\n```bash\n# 对 2025-10-26 归档的 \"add-user-auth\" 变更\nmkdir -p spec/archive/2025-10-26-add-user-auth\n```\n\n### 第 4 步：合并 ADDED 需求到常驻规范\n\n对每个 `## ADDED Requirements` 部分：\n\n**流程**：\n1. 定位目标常驻规范文件\n2. 将新增需求追加到文件末尾\n3. 保持正确的 Markdown 格式\n\n**示例**：\n\n**来源**（`spec/changes/add-user-auth/specs/authentication/spec-delta.md`）：\n```markdown\n## ADDED Requirements\n\n### Requirement: 用户登录\nWHEN 用户提交有效凭据,\n系统 SHALL 认证用户并创建会话。\n\n#### Scenario: 登录成功\nGIVEN 有效的凭据\nWHEN 用户提交登录表单\nTHEN 系统创建会话\n```\n\n**目标**（`spec/specs/authentication/spec.md`）：\n```bash\n# 追加到常驻规范\ncat >> spec/specs/authentication/spec.md << 'EOF'\n\n### Requirement: 用户登录\nWHEN 用户提交有效凭据,\n系统 SHALL 认证用户并创建会话。\n\n#### Scenario: 登录成功\nGIVEN 有效的凭据\nWHEN 用户提交登录表单\nTHEN 系统创建会话\nEOF\n```\n\n### 第 5 步：合并 MODIFIED 需求到常驻规范\n\n对每个 `## MODIFIED Requirements` 部分：\n\n**流程**：\n1. 在常驻规范中定位现有需求\n2. 替换**整个**需求块（包括全部场景）\n3. 使用差异文件中的完整更新文本\n\n**示例（使用 sed）**：\n\n```bash\n# 查找并替换需求块\n# 这是概念示例——实际实现取决于结构\n\n# 首先，确定旧需求的起始行\nSTART_LINE=$(grep -n \"### Requirement: 用户登录\" spec/specs/authentication/spec.md | cut -d: -f1)\n\n# 查找结束位置（下一个需求或文件末尾）\nEND_LINE=$(tail -n +$((START_LINE + 1)) spec/specs/authentication/spec.md | \\\n           grep -n \"^### Requirement:\" | head -1 | cut -d: -f1)\n\n# 删除旧需求\nsed -i \"${START_LINE},${END_LINE}d\" spec/specs/authentication/spec.md\n\n# 在相同位置插入新需求\n#（从差异文件提取并插入）\n```\n\n**手动方式**（出于安全建议）：\n```markdown\n1. 在编辑器中打开常驻规范\n2. 通过名称查找目标需求\n3. 删除整个块（需求 + 所有场景）\n4. 将差异文件中的更新需求粘贴到该处\n5. 保存\n```\n\n### 第 6 步：合并 REMOVED 需求到常驻规范\n\n对每个 `## REMOVED Requirements` 部分：\n\n**流程**：\n1. 在常驻规范中定位该需求\n2. 删除整个需求块\n3. 添加一条注释记录移除\n\n**示例**：\n\n```bash\n# 方案 1：带注释删除\n# 手动编辑 spec/specs/authentication/spec.md\n\n# 添加弃用注释\necho \"<!-- Requirement 'Legacy Password Reset' removed $(date +%Y-%m-%d) -->\" >> spec/specs/authentication/spec.md\n\n# 通过手动或 sed 删除该需求块\n```\n\n**模式**：\n```markdown\n<!-- Removed 2025-10-26: 用户需使用基于邮件的密码重置 -->\n~~### Requirement: SMS Password Reset~~\n```\n\n### 第 7 步：将变更目录移动到归档\n\n在所有差异合并后：\n\n```bash\n# 将完整的变更目录移动到归档\nmv spec/changes/{change-id} spec/archive/${TIMESTAMP}-{change-id}\n```\n\n**验证移动成功**：\n```bash\n# 检查归档是否存在\nls -la spec/archive/${TIMESTAMP}-{change-id}\n\n# 检查 changes 目录是否干净\nls spec/changes/ | grep \"{change-id}\"  # 应无结果\n```\n\n### 第 8 步：验证常驻规范结构\n\n在合并后，验证常驻规范的完整性：\n\n```bash\n# 检查需求格式\ngrep -n \"### Requirement:\" spec/specs/**/*.md\n\n# 检查场景格式\ngrep -n \"#### Scenario:\" spec/specs/**/*.md\n\n# 统计每个规范中的需求数量\nfor spec in spec/specs/**/spec.md; do\n    count=$(grep -c \"### Requirement:\" \"$spec\")\n    echo \"$spec: $count 条需求\"\ndone\n```\n\n**手动审阅**：\n- 打开每个被修改的规范文件\n- 验证 Markdown 格式正确\n- 检查需求逻辑是否连贯\n- 确保不存在重复需求\n\n## 合并逻辑参考\n\n### ADDED 操作\n\n```\n动作：追加到常驻规范\n位置：文件末尾（任何页脚/附录之前）\n格式：按原文复制需求与全部场景\n```\n\n### MODIFIED 操作\n\n```\n动作：替换现有需求\n位置：通过需求名称定位，替换整个块\n格式：使用差异文件的完整更新文本（不拼接，直接替换）\n说明：旧版本保留在归档中\n```\n\n### REMOVED 操作\n\n```\n动作：删除需求，并添加弃用注释\n位置：通过需求名称定位\n格式：删除整个块，可选添加 <!-- Removed YYYY-MM-DD: reason -->\n```\n\n### RENAMED 操作（不常见）\n\n```\n动作：更新需求名称，保留内容\n位置：通过旧名称定位，更新为新名称\n格式：仅修改标题：### Requirement: 新名称\n说明：通常使用 MODIFIED 更为常见\n```\n\n## 最佳实践\n\n### 模式 1：移动前先验证\n\n**务必**在移动到归档前验证差异合并：\n\n```bash\n# 合并后查看差异\ngit diff spec/specs/\n\n# 审阅变更\ngit diff spec/specs/authentication/spec.md\n\n# 若正确则提交\ngit add spec/specs/\ngit commit -m \"Merge spec deltas from add-user-auth\"\n\n# 然后再归档\nmv spec/changes/add-user-auth spec/archive/2025-10-26-add-user-auth\n```\n\n### 模式 2：原子化归档\n\n归档整个变更，而非单个文件：\n\n**好**：\n```bash\n# 移动完整变更目录\nmv spec/changes/add-user-auth spec/archive/2025-10-26-add-user-auth\n```\n\n**坏**：\n```bash\n# 不要挑拣文件\nmv spec/changes/add-user-auth/proposal.md spec/archive/\n#（会留下孤儿文件）\n```\n\n### 模式 3：归档保全\n\n归档是历史记录。切勿修改归档文件：\n\n```markdown\n❌ 不要：编辑 spec/archive/\n✓ 要：将归档视为只读历史\n```\n\n### 模式 4：Git 提交策略\n\n推荐提交流程：\n\n```bash\n# 提交 1：合并差异\ngit add spec/specs/\ngit commit -m \"Merge spec deltas from add-user-auth\n\n- Added User Login requirement\n- Modified Password Policy requirement\n- Removed Legacy Auth requirement\"\n\n# 提交 2：归档变更\ngit add spec/archive/ spec/changes/\ngit commit -m \"Archive add-user-auth change\"\n```\n\n## 进阶主题\n\n**复杂差异**：见 [reference/MERGE_LOGIC.md](reference/MERGE_LOGIC.md)\n\n**冲突解决**：若多个变更修改同一需求，需手动合并。\n\n**回滚策略**：若需回滚归档，反向执行流程（从归档移回 changes，并从常驻规范移除已合并内容）。\n\n## 常见模式\n\n### 模式 1：简单新增\n\n```markdown\n变更新增 1 条需求 → 追加到规范 → 归档\n```\n\n### 模式 2：行为变更\n\n```markdown\n变更修改 1 条需求 → 在规范中替换 → 归档\n```\n\n### 模式 3：弃用\n\n```markdown\n变更移除 1 条需求 → 删除并添加注释 → 归档\n```\n\n### 模式 4：多需求的功能\n\n```markdown\n变更在 2 个规范中新增 5 条需求\n→ 分别追加到相应规范\n→ 验证全部已合并\n→ 归档\n```\n\n## 反模式避免\n\n**不要**：\n- 归档未完成的实施\n- 在部署前合并差异\n- 修改归档文件\n- 跳过合并后的验证\n- 忘记在合并规范后进行 git 提交\n\n**要**：\n- 在归档前验证所有任务完成\n- 小心且完整地合并差异\n- 将归档视为不可变历史\n- 验证合并后规范结构\n- 在归档移动前提交合并后的规范\n\n## 故障排查\n\n### 问题：合并冲突（常驻规范已有该需求）\n\n**解决方案**：\n```markdown\n1. 若名称相同但内容不同 → 使用 MODIFIED 模式\n2. 若确实是不同需求 → 重命名其中之一\n3. 若属重复错误 → 选择正确版本\n```\n\n### 问题：找不到需要修改/移除的需求\n\n**解决方案**：\n```markdown\n1. 按部分名称搜索：grep -i \"login\" spec/specs/**/*.md\n2. 检查是否已被移除\n3. 检查是否位于其他能力文件\n```\n\n### 问题：合并后常驻规范格式错误\n\n**解决方案**：\n```markdown\n1. 手动修复格式\n2. 重新运行验证：grep -n \"###\" spec/specs/**/*.md\n3. 确保标题层级一致\n```\n\n## 参考资料\n\n- [MERGE_LOGIC.md](reference/MERGE_LOGIC.md) - 详细的合并操作规则\n\n---\n\n**Token 预算**：此 SKILL.md 约 430 行，低于建议的 500 行上限。"
              },
              {
                "name": "openspec-archiving",
                "description": "Archives completed changes and merges specification deltas into living documentation. Use when changes are deployed, ready to archive, or specs need updating after implementation. Triggers include \"openspec archive\", \"archive change\", \"merge specs\", \"complete proposal\", \"update documentation\", \"finalize spec\", \"mark as done\".",
                "path": "skills/openspec-archiving/SKILL.md",
                "frontmatter": {
                  "name": "openspec-archiving",
                  "description": "Archives completed changes and merges specification deltas into living documentation. Use when changes are deployed, ready to archive, or specs need updating after implementation. Triggers include \"openspec archive\", \"archive change\", \"merge specs\", \"complete proposal\", \"update documentation\", \"finalize spec\", \"mark as done\"."
                },
                "content": "# Specification Archiving\n\nArchives completed change proposals and merges their spec deltas into the living specification documentation.\n\n## Quick Start\n\nArchiving involves two main operations:\n1. **Move change folder** to archive with timestamp\n2. **Merge spec deltas** into living specs (ADDED/MODIFIED/REMOVED operations)\n\n**Critical rule**: Verify all tasks are complete before archiving. Archiving signifies deployment and completion.\n\n## Workflow\n\nCopy this checklist and track progress:\n\n```\nArchive Progress:\n- [ ] Step 1: Verify implementation is complete\n- [ ] Step 2: Review spec deltas to merge\n- [ ] Step 3: Create timestamped archive directory\n- [ ] Step 4: Merge ADDED requirements into living specs\n- [ ] Step 5: Merge MODIFIED requirements into living specs\n- [ ] Step 6: Merge REMOVED requirements into living specs\n- [ ] Step 7: Move change folder to archive\n- [ ] Step 8: Validate living spec structure\n```\n\n### Step 1: Verify implementation is complete\n\nBefore archiving, confirm all work is done:\n\n```bash\n# Check for IMPLEMENTED marker\ntest -f spec/changes/{change-id}/IMPLEMENTED && echo \"✓ Implemented\" || echo \"✗ Not implemented\"\n\n# Review tasks\ncat spec/changes/{change-id}/tasks.md\n\n# Check git status for uncommitted work\ngit status\n```\n\n**Ask the user**:\n```markdown\nAre all tasks complete and tested?\nHas this change been deployed to production?\nShould I proceed with archiving?\n```\n\n### Step 2: Review spec deltas to merge\n\nUnderstand what will be merged:\n\n```bash\n# List all spec delta files\nfind spec/changes/{change-id}/specs -name \"*.md\" -type f\n\n# Read each delta\nfor file in spec/changes/{change-id}/specs/**/*.md; do\n    echo \"=== $file ===\"\n    cat \"$file\"\ndone\n```\n\n**Identify**:\n- Which capabilities are affected\n- How many requirements are ADDED/MODIFIED/REMOVED\n- Where in living specs these changes belong\n\n### Step 3: Create timestamped archive directory\n\n```bash\n# Create archive with today's date\nTIMESTAMP=$(date +%Y-%m-%d)\nmkdir -p spec/archive/${TIMESTAMP}-{change-id}\n```\n\n**Example**:\n```bash\n# For change \"add-user-auth\" archived on Oct 26, 2025\nmkdir -p spec/archive/2025-10-26-add-user-auth\n```\n\n### Step 4: Merge ADDED requirements into living specs\n\nFor each `## ADDED Requirements` section:\n\n**Process**:\n1. Locate the target living spec file\n2. Append the new requirements to the end of the file\n3. Maintain proper markdown formatting\n\n**Example**:\n\n**Source** (`spec/changes/add-user-auth/specs/authentication/spec-delta.md`):\n```markdown\n## ADDED Requirements\n\n### Requirement: User Login\nWHEN a user submits valid credentials,\nthe system SHALL authenticate the user and create a session.\n\n#### Scenario: Successful Login\nGIVEN valid credentials\nWHEN user submits login form\nTHEN system creates session\n```\n\n**Target** (`spec/specs/authentication/spec.md`):\n```bash\n# Append to living spec\ncat >> spec/specs/authentication/spec.md << 'EOF'\n\n### Requirement: User Login\nWHEN a user submits valid credentials,\nthe system SHALL authenticate the user and create a session.\n\n#### Scenario: Successful Login\nGIVEN valid credentials\nWHEN user submits login form\nTHEN system creates session\nEOF\n```\n\n### Step 5: Merge MODIFIED requirements into living specs\n\nFor each `## MODIFIED Requirements` section:\n\n**Process**:\n1. Locate the existing requirement in the living spec\n2. Replace the ENTIRE requirement block (including all scenarios)\n3. Use the complete updated text from the delta\n\n**Example using sed**:\n\n```bash\n# Find and replace requirement block\n# This is conceptual - actual implementation depends on structure\n\n# First, identify the line range of the old requirement\nSTART_LINE=$(grep -n \"### Requirement: User Login\" spec/specs/authentication/spec.md | cut -d: -f1)\n\n# Find the end (next requirement or end of file)\nEND_LINE=$(tail -n +$((START_LINE + 1)) spec/specs/authentication/spec.md | \\\n           grep -n \"^### Requirement:\" | head -1 | cut -d: -f1)\n\n# Delete old requirement\nsed -i \"${START_LINE},${END_LINE}d\" spec/specs/authentication/spec.md\n\n# Insert new requirement at same position\n# (Extract from delta and insert)\n```\n\n**Manual approach** (recommended for safety):\n```markdown\n1. Open living spec in editor\n2. Find the requirement by name\n3. Delete entire block (requirement + all scenarios)\n4. Paste updated requirement from delta\n5. Save\n```\n\n### Step 6: Merge REMOVED requirements into living specs\n\nFor each `## REMOVED Requirements` section:\n\n**Process**:\n1. Locate the requirement in the living spec\n2. Delete the entire requirement block\n3. Add a comment documenting the removal\n\n**Example**:\n\n```bash\n# Option 1: Delete with comment\n# Manually edit spec/specs/authentication/spec.md\n\n# Add deprecation comment\necho \"<!-- Requirement 'Legacy Password Reset' removed $(date +%Y-%m-%d) -->\" >> spec/specs/authentication/spec.md\n\n# Delete the requirement block manually or with sed\n```\n\n**Pattern**:\n```markdown\n<!-- Removed 2025-10-26: User must use email-based password reset -->\n~~### Requirement: SMS Password Reset~~\n```\n\n### Step 7: Move change folder to archive\n\nAfter all deltas are merged:\n\n```bash\n# Move entire change folder to archive\nmv spec/changes/{change-id} spec/archive/${TIMESTAMP}-{change-id}\n```\n\n**Verify move succeeded**:\n```bash\n# Check archive exists\nls -la spec/archive/${TIMESTAMP}-{change-id}\n\n# Check changes directory is clean\nls spec/changes/ | grep \"{change-id}\"  # Should return nothing\n```\n\n### Step 8: Validate living spec structure\n\nAfter merging, validate the living specs are well-formed:\n\n```bash\n# Check requirement format\ngrep -n \"### Requirement:\" spec/specs/**/*.md\n\n# Check scenario format\ngrep -n \"#### Scenario:\" spec/specs/**/*.md\n\n# Count requirements per spec\nfor spec in spec/specs/**/spec.md; do\n    count=$(grep -c \"### Requirement:\" \"$spec\")\n    echo \"$spec: $count requirements\"\ndone\n```\n\n**Manual review**:\n- Open each modified spec file\n- Verify markdown formatting is correct\n- Check requirements flow logically\n- Ensure no duplicate requirements exist\n\n## Merge Logic Reference\n\n### ADDED Operation\n\n```\nAction: Append to living spec\nLocation: End of file (before any footer/appendix)\nFormat: Copy requirement + all scenarios exactly as written\n```\n\n### MODIFIED Operation\n\n```\nAction: Replace existing requirement\nLocation: Find by requirement name, replace entire block\nFormat: Use complete updated text from delta (don't merge, replace)\nNote: Old version is preserved in archive\n```\n\n### REMOVED Operation\n\n```\nAction: Delete requirement, add deprecation comment\nLocation: Find by requirement name\nFormat: Delete entire block, optionally add <!-- Removed YYYY-MM-DD: reason -->\n```\n\n### RENAMED Operation (uncommon)\n\n```\nAction: Update requirement name, keep content\nLocation: Find by old name, update to new name\nFormat: Just change the header: ### Requirement: NewName\nNote: Typically use MODIFIED instead\n```\n\n## Best Practices\n\n### Pattern 1: Verify Before Moving\n\n**Always** verify delta merges before moving to archive:\n\n```bash\n# After merging, check diff\ngit diff spec/specs/\n\n# Review changes\ngit diff spec/specs/authentication/spec.md\n\n# If correct, commit\ngit add spec/specs/\ngit commit -m \"Merge spec deltas from add-user-auth\"\n\n# Then archive\nmv spec/changes/add-user-auth spec/archive/2025-10-26-add-user-auth\n```\n\n### Pattern 2: Atomic Archiving\n\nArchive entire changes, not individual files:\n\n**Good**:\n```bash\n# Move complete change folder\nmv spec/changes/add-user-auth spec/archive/2025-10-26-add-user-auth\n```\n\n**Bad**:\n```bash\n# Don't cherry-pick files\nmv spec/changes/add-user-auth/proposal.md spec/archive/\n# (leaves orphaned files)\n```\n\n### Pattern 3: Archive Preservation\n\nThe archive is a historical record. Never modify archived files:\n\n```markdown\n❌ Don't: Edit files in spec/archive/\n✓ Do: Treat archive as read-only history\n```\n\n### Pattern 4: Git Commit Strategy\n\nRecommended commit workflow:\n\n```bash\n# Commit 1: Merge deltas\ngit add spec/specs/\ngit commit -m \"Merge spec deltas from add-user-auth\n\n- Added User Login requirement\n- Modified Password Policy requirement\n- Removed Legacy Auth requirement\"\n\n# Commit 2: Archive change\ngit add spec/archive/ spec/changes/\ngit commit -m \"Archive add-user-auth change\"\n```\n\n## Advanced Topics\n\n**For complex deltas**: See [reference/MERGE_LOGIC.md](reference/MERGE_LOGIC.md)\n\n**Conflict resolution**: If multiple changes modified the same requirement, manual merge is required.\n\n**Rollback strategy**: To rollback an archive, reverse the process (move from archive back to changes, remove merged content from living specs).\n\n## Common Patterns\n\n### Pattern 1: Simple Addition\n\n```markdown\nChange adds 1 new requirement → Append to spec → Archive\n```\n\n### Pattern 2: Behavioral Change\n\n```markdown\nChange modifies 1 requirement → Replace in spec → Archive\n```\n\n### Pattern 3: Deprecation\n\n```markdown\nChange removes 1 requirement → Delete from spec with comment → Archive\n```\n\n### Pattern 4: Feature with Multiple Requirements\n\n```markdown\nChange adds 5 requirements across 2 specs\n→ Append each to respective spec\n→ Verify all are merged\n→ Archive\n```\n\n## Anti-Patterns to Avoid\n\n**Don't**:\n- Archive incomplete implementations\n- Merge deltas before deployment\n- Modify archived files\n- Skip validation after merging\n- Forget to git commit merged specs\n\n**Do**:\n- Verify all tasks complete before archiving\n- Merge deltas carefully and completely\n- Treat archive as immutable history\n- Validate merged specs structure\n- Commit merged specs before archiving move\n\n## Troubleshooting\n\n### Issue: Merge conflict (requirement exists in living spec)\n\n**Solution**:\n```markdown\n1. If names match but content differs → Use MODIFIED pattern\n2. If truly different requirements → Rename one\n3. If duplicate by mistake → Use whichever is correct\n```\n\n### Issue: Can't find requirement to modify/remove\n\n**Solution**:\n```markdown\n1. Search by partial name: grep -i \"login\" spec/specs/**/*.md\n2. Check if already removed\n3. Check if in different capability file\n```\n\n### Issue: Living spec has formatting errors after merge\n\n**Solution**:\n```markdown\n1. Fix formatting manually\n2. Re-run validation: grep -n \"###\" spec/specs/**/*.md\n3. Ensure consistent heading levels\n```\n\n## Reference Materials\n\n- [MERGE_LOGIC.md](reference/MERGE_LOGIC.md) - Detailed merge operation rules\n\n---\n\n**Token budget**: This SKILL.md is approximately 480 lines, under the 500-line recommended limit."
              },
              {
                "name": "openspec-context-loading-cn",
                "description": "加载项目上下文，列出现有规范与变更，搜索能力与需求。用于用户询问项目状态、现有规范、进行中的变更、可用能力或需要发现上下文时。触发词包括\"openspec上下文\", \"有哪些规范\", \"显示变更\", \"列出能力\", \"项目上下文\", \"查找规范\", \"规范包含什么\", \"展示规范\"。",
                "path": "skills/openspec-context-loading-cn/SKILL.md",
                "frontmatter": {
                  "name": "openspec-context-loading-cn",
                  "description": "加载项目上下文，列出现有规范与变更，搜索能力与需求。用于用户询问项目状态、现有规范、进行中的变更、可用能力或需要发现上下文时。触发词包括\"openspec上下文\", \"有哪些规范\", \"显示变更\", \"列出能力\", \"项目上下文\", \"查找规范\", \"规范包含什么\", \"展示规范\"。"
                },
                "content": "# 规范上下文加载\n\n发现并加载项目规范、进行中的变更和需求，以提供上下文。\n\n## 快速开始\n\n上下文加载可帮助回答：\n- 项目有哪些规范？\n- 目前有哪些进行中的变更？\n- 已定义了哪些需求？\n- 系统具备哪些能力？\n- 某项功能在何处有所规范？\n\n**基本模式**：搜索 → 阅读 → 总结\n\n## 发现命令\n\n注意将控制台与管道输出编码统一为 UTF-8，确保中文字符正确显示。\n\n### 列出所有规范\n\n```bash\n# 查找所有规范文件\nfind spec/specs -name \"spec.md\" -type f\n\n# 查找所有能力目录\nfind spec/specs -mindepth 1 -maxdepth 1 -type d\n\n# 显示规范树\ntree spec/specs/  # 若已安装 tree\n# 或\nls -R spec/specs/\n```\n\n**输出格式**：\n```\nspec/specs/\n├── authentication/\n│   └── spec.md\n├── billing/\n│   └── spec.md\n└── notifications/\n    └── spec.md\n```\n\n### 列出进行中的变更\n\n```bash\n# 显示所有进行中的变更\nfind spec/changes -maxdepth 1 -type d -not -path \"spec/changes\" -not -path \"*/archive\" | sort\n\n# 显示修改时间\nfind spec/changes -maxdepth 1 -type d -not -path \"spec/changes\" -not -path \"*/archive\" -exec ls -ld {} \\;\n\n# 统计进行中的变更数量\nfind spec/changes -maxdepth 1 -type d -not -path \"spec/changes\" -not -path \"*/archive\" | wc -l\n```\n\n### 列出已归档的变更\n\n```bash\n# 显示所有已归档变更\nls -1 spec/archive/\n\n# 显示日期\nls -la spec/archive/\n\n# 查找最近 7 天归档的变更\nfind spec/archive/ -maxdepth 1 -type d -mtime -7\n```\n\n### 搜索需求\n\n```bash\n# 查找所有需求\ngrep -r \"### Requirement:\" spec/specs/\n\n# 在特定能力中查找需求\ngrep \"### Requirement:\" spec/specs/authentication/spec.md\n\n# 列出唯一需求名称\ngrep -h \"### Requirement:\" spec/specs/**/*.md | sed 's/### Requirement: //' | sort\n```\n\n### 搜索场景\n\n```bash\n# 查找所有场景\ngrep -r \"#### Scenario:\" spec/specs/\n\n# 统计每个规范中的场景数量\nfor spec in spec/specs/**/spec.md; do\n    count=$(grep -c \"#### Scenario:\" \"$spec\")\n    echo \"$spec: $count scenarios\"\ndone\n```\n\n### 关键词搜索\n\n```bash\n# 查找提到 \"authentication\" 的规范\ngrep -r -i \"authentication\" spec/specs/\n\n# 查找与 \"password\" 相关的需求\ngrep -B 1 -A 5 -i \"password\" spec/specs/**/*.md | grep -A 5 \"### Requirement:\"\n\n# 查找提到 \"error\" 的场景\ngrep -B 1 -A 10 -i \"error\" spec/specs/**/*.md | grep -A 10 \"#### Scenario:\"\n```\n\n## 常见查询\n\n### 查询 1：\"项目有哪些规范？\"\n\n```bash\n# 列出所有能力\nfind spec/specs -mindepth 1 -maxdepth 1 -type d -exec basename {} \\;\n\n# 统计每个能力的需求数量\nfor cap in spec/specs/*/; do\n    name=$(basename \"$cap\")\n    count=$(grep -c \"### Requirement:\" \"$cap/spec.md\" 2>/dev/null || echo \"0\")\n    echo \"$name: $count requirements\"\ndone\n```\n\n**响应格式**：\n```markdown\n## 现有规范\n\n项目具备以下能力的规范：\n\n- **authentication**：8 条需求\n- **billing**：12 条需求\n- **notifications**：5 条需求\n\n合计：3 个能力，25 条需求\n```\n\n### 查询 2：\"当前有哪些变更在进行？\"\n\n```bash\n# 附带提案摘要的列表\nfor change in spec/changes/*/; do\n    if [ \"$change\" != \"spec/changes/archive/\" ]; then\n        id=$(basename \"$change\")\n        echo \"=== $id ===\"\n        head -n 20 \"$change/proposal.md\" | grep -A 3 \"## Why\"\n    fi\ndone\n```\n\n**响应格式**：\n```markdown\n## 进行中的变更\n\n当前进行中的变更：\n\n### add-user-auth\n**Why**：用户需要安全的认证...\n\n### update-billing-api\n**Why**：支付处理需要 v2 API...\n\n合计：2 个进行中变更\n```\n\n### 查询 3：\"查找 authentication 规范\"\n\n```bash\n# 阅读完整规范\ncat spec/specs/authentication/spec.md\n\n# 或展示摘要\necho \"需求：\"\ngrep \"### Requirement:\" spec/specs/authentication/spec.md\n\necho \"场景：\"\ngrep \"#### Scenario:\" spec/specs/authentication/spec.md\n```\n\n**响应格式**：\n```markdown\n## Authentication 规范\n\n（包含 spec.md 的完整内容）\n\n摘要：\n- 8 条需求\n- 16 个场景\n- 最近修改时间：[来自 git log 的日期]\n```\n\n### 查询 4：\"查找与 password 相关的规范\"\n\n```bash\n# 关键词搜索\ngrep -r -i \"password\" spec/specs/ -A 5\n\n# 显示提到该关键词的规范\ngrep -r -i \"password\" spec/specs/ -l\n```\n\n**响应格式**：\n```markdown\n## Specs Mentioning \"Password\"\n\n发现于：\n- spec/specs/authentication/spec.md（3 条需求）\n- spec/specs/security/spec.md（1 条需求）\n\n相关需求：\n### Requirement: Password Validation\n### Requirement: Password Reset\n### Requirement: Password Strength\n```\n\n### 查询 5：\"变更 X 的具体内容是什么？\"\n\n```bash\n# 展示完整的变更上下文\nCHANGE_ID=\"add-user-auth\"\n\necho \"=== 提案 ===\"\ncat spec/changes/$CHANGE_ID/proposal.md\n\necho \"\\n=== 任务 ===\"\ncat spec/changes/$CHANGE_ID/tasks.json\n\necho \"\\n=== 规范变更 ===\"\nfind spec/changes/$CHANGE_ID/specs -name \"*.md\" -exec echo \"File: {}\" \\; -exec cat {} \\;\n```\n\n## 仪表盘视图\n\n创建全面的项目概览：\n\n```bash\n#!/bin/bash\n# 项目规范仪表盘\n\necho \"===  规范仪表盘 ===\"\necho \"\"\n\n# 能力\necho \"## 能力\"\nCAPS=$(find spec/specs -mindepth 1 -maxdepth 1 -type d | wc -l)\necho \"能力总数: $CAPS\"\nfor cap in spec/specs/*/; do\n    name=$(basename \"$cap\")\n    reqs=$(grep -c \"### Requirement:\" \"$cap/spec.md\" 2>/dev/null || echo \"0\")\n    echo \"  - $name: $reqs 条需求\"\ndone\necho \"\"\n\n# 需求\necho \"## 需求\"\nTOTAL_REQS=$(grep -r \"### Requirement:\" spec/specs/ | wc -l)\nTOTAL_SCENARIOS=$(grep -r \"#### Scenario:\" spec/specs/ | wc -l)\necho \"需求总数: $TOTAL_REQS\"\necho \"场景总数: $TOTAL_SCENARIOS\"\necho \"每个需求平均场景数: $(echo \"scale=1; $TOTAL_SCENARIOS/$TOTAL_REQS\" | bc)\"\necho \"\"\n\n# 变更\necho \"## 变更\"\nACTIVE=$(find spec/changes -maxdepth 1 -type d -not -path \"spec/changes\" -not -path \"*/archive\" | wc -l)\nARCHIVED=$(ls -1 spec/archive/ | wc -l)\necho \"进行中的变更: $ACTIVE\"\necho \"已归档的变更: $ARCHIVED\"\necho \"\"\n\n# 最近活动\necho \"## 最近活动\"\necho \"最近修改的规范:\"\nfind spec/specs -name \"spec.md\" -type f -exec ls -lt {} \\; | head -5\n```\n\n**响应格式**：\n```markdown\n# Specification Dashboard\n\n## Capabilities\nTotal capabilities: 3\n  - authentication: 8 requirements\n  - billing: 12 requirements\n  - notifications: 5 requirements\n\n## Requirements\nTotal requirements: 25\nTotal scenarios: 52\nAvg scenarios per requirement: 2.1\n\n## Changes\nActive changes: 2\nArchived changes: 15\n\n## Recent Activity\nRecently modified specs:\n- spec/specs/billing/spec.md（2 天前）\n- spec/specs/authentication/spec.md（1 周前）\n```\n\n## 高级查询\n\n### 查找相关需求\n\n```bash\n# 查找提到其他需求的内容\ngrep -r \"User Login\" spec/specs/ -A 10 | grep \"### Requirement:\"\n\n# 查找交叉引用\ngrep -r \"See Requirement:\" spec/specs/\n```\n\n### 分析覆盖度\n\n```bash\n# 查找无场景的需求\nfor spec in spec/specs/**/spec.md; do\n    awk '/### Requirement:/ {req=$0; getline; if ($0 !~ /#### Scenario:/) print req}' \"$spec\"\ndone\n\n# 查找不包含完整 Given/When/Then 的场景\ngrep -A 5 \"#### Scenario:\" spec/specs/**/*.md | grep -v \"GIVEN\\|WHEN\\|THEN\"\n```\n\n### 对比进行中与已归档\n\n```bash\n# 展示时间演化\necho \"归档历史:\"\nls -1 spec/archive/ | head -10\n\necho \"最近归档 (30天):\"\nfind spec/archive/ -maxdepth 1 -type d -mtime -30 -exec basename {} \\;\n```\n\n## 搜索模式\n\n### 模式 1：能力发现\n\n用户提问：\"系统能做什么？\"\n\n```bash\n# 列出能力\nfind spec/specs -mindepth 1 -maxdepth 1 -type d -exec basename {} \\;\n\n# 展示高层需求\nfor cap in spec/specs/*/; do\n    echo \"=== $(basename $cap) ===\"\n    grep \"### Requirement:\" \"$cap/spec.md\" | head -3\ndone\n```\n\n### 模式 2：功能搜索\n\n用户提问：\"有密码重置的规范吗？\"\n\n```bash\n# 关键词搜索\ngrep -r -i \"password reset\" spec/specs/ -B 1 -A 10\n\n# 若找到，展示完整需求\ngrep -B 1 -A 20 \"Requirement:.*Password Reset\" spec/specs/**/*.md\n```\n\n### 模式 3：变更跟踪\n\n用户提问：\"现在做什么？\"\n\n```bash\n# 附带状态展示进行中的变更\nfor change in spec/changes/*/; do\n    if [ \"$change\" != \"spec/changes/archive/\" ]; then\n        id=$(basename \"$change\")\n        echo \"$id:\"\n        test -f \"$change/IMPLEMENTED\" && echo \"  状态: 已完成\" || echo \"  状态: 进行中\"\n        echo \"  任务: $(grep -c '\"task\":' \"$change/tasks.json\")\"\n    fi\ndone\n```\n\n## 最佳实践\n\n### 模式 1：先提供上下文再给细节\n\n**良好流程**：\n```markdown\n1. 展示仪表盘（高层概览）\n2. 用户询问具体能力\n3. 展示该能力的需求\n4. 用户询问具体需求\n5. 展示包含场景的完整需求\n```\n\n### 模式 2：高效使用 grep\n\n```bash\n# 结合过滤器提高精度\ngrep -r \"### Requirement:\" spec/specs/ | grep -i \"auth\"\n\n# 使用上下文标志提升可读性\ngrep -B 2 -A 10 \"#### Scenario:\" spec/specs/authentication/spec.md\n```\n\n### 模式 3：聚合信息\n\n不要只是倾倒文件内容。应做总结：\n\n```markdown\n**坏**：（直接输出整个规范文件）\n\n**好**：\n\"authentication 规范包含 8 条需求，覆盖：\n- 用户登录\n- 密码管理\n- 会话处理\n- 多因素认证\n\n需要我展示某条具体需求吗？\"\n```\n\n## 反模式避免\n\n**不要**：\n- 未经请求就读取整个规范文件\n- 默认列出所有需求\n- 输出未经格式化的原始 grep 结果\n- 假定用户知道能力名称\n\n**要**：\n- 先给高层概览\n- 询问用户希望深入了解的领域\n- 清晰格式化输出\n- 提供导航提示\n\n## 参考资料\n\n- [SEARCH_PATTERNS.md](reference/SEARCH_PATTERNS.md) - 高级 grep/find 模式\n\n---\n\n**Token 预算**：此 SKILL.md 约 460 行，低于建议的 500 行上限。"
              },
              {
                "name": "openspec-context-loading",
                "description": "Loads project context, lists existing specs and changes, searches capabilities and requirements. Use when user asks about project state, existing specs, active changes, available capabilities, or needs context discovery. Triggers include \"openspec context\", \"what specs exist\", \"show changes\", \"list capabilities\", \"project context\", \"find specs\", \"what's in the spec\", \"show me specs\".",
                "path": "skills/openspec-context-loading/SKILL.md",
                "frontmatter": {
                  "name": "openspec-context-loading",
                  "description": "Loads project context, lists existing specs and changes, searches capabilities and requirements. Use when user asks about project state, existing specs, active changes, available capabilities, or needs context discovery. Triggers include \"openspec context\", \"what specs exist\", \"show changes\", \"list capabilities\", \"project context\", \"find specs\", \"what's in the spec\", \"show me specs\"."
                },
                "content": "# Specification Context Loading\n\nDiscovers and loads project specifications, active changes, and requirements to provide context.\n\n## Quick Start\n\nContext loading helps answer:\n- What specs exist in this project?\n- What changes are currently active?\n- What requirements are defined?\n- What capabilities does the system have?\n- Where is a specific feature specified?\n\n**Basic pattern**: Search → Read → Summarize\n\n## Discovery Commands\n\n### List All Specifications\n\n```bash\n# Find all spec files\nfind spec/specs -name \"spec.md\" -type f\n\n# Find all capability directories\nfind spec/specs -mindepth 1 -maxdepth 1 -type d\n\n# Show spec tree\ntree spec/specs/  # if tree is installed\n# or\nls -R spec/specs/\n```\n\n**Output format**:\n```\nspec/specs/\n├── authentication/\n│   └── spec.md\n├── billing/\n│   └── spec.md\n└── notifications/\n    └── spec.md\n```\n\n### List Active Changes\n\n```bash\n# Show all active changes\nfind spec/changes -maxdepth 1 -type d -not -path \"spec/changes\" -not -path \"*/archive\" | sort\n\n# Show with modification dates\nfind spec/changes -maxdepth 1 -type d -not -path \"spec/changes\" -not -path \"*/archive\" -exec ls -ld {} \\;\n\n# Count active changes\nfind spec/changes -maxdepth 1 -type d -not -path \"spec/changes\" -not -path \"*/archive\" | wc -l\n```\n\n### List Archived Changes\n\n```bash\n# Show all archived changes\nls -1 spec/archive/\n\n# Show with dates\nls -la spec/archive/\n\n# Find recently archived (last 7 days)\nfind spec/archive/ -maxdepth 1 -type d -mtime -7\n```\n\n### Search for Requirements\n\n```bash\n# Find all requirements\ngrep -r \"### Requirement:\" spec/specs/\n\n# Find requirements in specific capability\ngrep \"### Requirement:\" spec/specs/authentication/spec.md\n\n# List unique requirement names\ngrep -h \"### Requirement:\" spec/specs/**/*.md | sed 's/### Requirement: //' | sort\n```\n\n### Search for Scenarios\n\n```bash\n# Find all scenarios\ngrep -r \"#### Scenario:\" spec/specs/\n\n# Count scenarios per spec\nfor spec in spec/specs/**/spec.md; do\n    count=$(grep -c \"#### Scenario:\" \"$spec\")\n    echo \"$spec: $count scenarios\"\ndone\n```\n\n### Search by Keyword\n\n```bash\n# Find specs mentioning \"authentication\"\ngrep -r -i \"authentication\" spec/specs/\n\n# Find requirements about \"password\"\ngrep -B 1 -A 5 -i \"password\" spec/specs/**/*.md | grep -A 5 \"### Requirement:\"\n\n# Find scenarios about \"error\"\ngrep -B 1 -A 10 -i \"error\" spec/specs/**/*.md | grep -A 10 \"#### Scenario:\"\n```\n\n## Common Queries\n\n### Query 1: \"What specs exist?\"\n\n```bash\n# List all capabilities\nfind spec/specs -mindepth 1 -maxdepth 1 -type d -exec basename {} \\;\n\n# Count requirements per capability\nfor cap in spec/specs/*/; do\n    name=$(basename \"$cap\")\n    count=$(grep -c \"### Requirement:\" \"$cap/spec.md\" 2>/dev/null || echo \"0\")\n    echo \"$name: $count requirements\"\ndone\n```\n\n**Response format**:\n```markdown\n## Existing Specifications\n\nThe project has specifications for the following capabilities:\n\n- **authentication**: 8 requirements\n- **billing**: 12 requirements\n- **notifications**: 5 requirements\n\nTotal: 3 capabilities, 25 requirements\n```\n\n### Query 2: \"What changes are active?\"\n\n```bash\n# List with proposal summaries\nfor change in spec/changes/*/; do\n    if [ \"$change\" != \"spec/changes/archive/\" ]; then\n        id=$(basename \"$change\")\n        echo \"=== $id ===\"\n        head -n 20 \"$change/proposal.md\" | grep -A 3 \"## Why\"\n    fi\ndone\n```\n\n**Response format**:\n```markdown\n## Active Changes\n\nCurrently active changes:\n\n### add-user-auth\n**Why**: Users need secure authentication...\n\n### update-billing-api\n**Why**: Payment processing requires v2 API...\n\nTotal: 2 active changes\n```\n\n### Query 3: \"Show me the authentication spec\"\n\n```bash\n# Read full spec\ncat spec/specs/authentication/spec.md\n\n# Or show summary\necho \"Requirements:\"\ngrep \"### Requirement:\" spec/specs/authentication/spec.md\n\necho \"\\nScenarios:\"\ngrep \"#### Scenario:\" spec/specs/authentication/spec.md\n```\n\n**Response format**:\n```markdown\n## Authentication Specification\n\n(Include full content of spec.md)\n\nSummary:\n- 8 requirements\n- 16 scenarios\n- Last modified: [date from git log]\n```\n\n### Query 4: \"Find specs about password\"\n\n```bash\n# Search for keyword\ngrep -r -i \"password\" spec/specs/ -A 5\n\n# Show which specs mention it\ngrep -r -i \"password\" spec/specs/ -l\n```\n\n**Response format**:\n```markdown\n## Specs Mentioning \"Password\"\n\nFound in:\n- spec/specs/authentication/spec.md (3 requirements)\n- spec/specs/security/spec.md (1 requirement)\n\nRelevant requirements:\n### Requirement: Password Validation\n### Requirement: Password Reset\n### Requirement: Password Strength\n```\n\n### Query 5: \"What's in change X?\"\n\n```bash\n# Show full change context\nCHANGE_ID=\"add-user-auth\"\n\necho \"=== Proposal ===\"\ncat spec/changes/$CHANGE_ID/proposal.md\n\necho \"\\n=== Tasks ===\"\ncat spec/changes/$CHANGE_ID/tasks.md\n\necho \"\\n=== Spec Deltas ===\"\nfind spec/changes/$CHANGE_ID/specs -name \"*.md\" -exec echo \"File: {}\" \\; -exec cat {} \\;\n```\n\n## Dashboard View\n\nCreate a comprehensive project overview:\n\n```bash\n#!/bin/bash\n# Project specification dashboard\n\necho \"===  Specification Dashboard ===\"\necho \"\"\n\n# Capabilities\necho \"## Capabilities\"\nCAPS=$(find spec/specs -mindepth 1 -maxdepth 1 -type d | wc -l)\necho \"Total capabilities: $CAPS\"\nfor cap in spec/specs/*/; do\n    name=$(basename \"$cap\")\n    reqs=$(grep -c \"### Requirement:\" \"$cap/spec.md\" 2>/dev/null || echo \"0\")\n    echo \"  - $name: $reqs requirements\"\ndone\necho \"\"\n\n# Requirements\necho \"## Requirements\"\nTOTAL_REQS=$(grep -r \"### Requirement:\" spec/specs/ | wc -l)\nTOTAL_SCENARIOS=$(grep -r \"#### Scenario:\" spec/specs/ | wc -l)\necho \"Total requirements: $TOTAL_REQS\"\necho \"Total scenarios: $TOTAL_SCENARIOS\"\necho \"Avg scenarios per requirement: $(echo \"scale=1; $TOTAL_SCENARIOS/$TOTAL_REQS\" | bc)\"\necho \"\"\n\n# Changes\necho \"## Changes\"\nACTIVE=$(find spec/changes -maxdepth 1 -type d -not -path \"spec/changes\" -not -path \"*/archive\" | wc -l)\nARCHIVED=$(ls -1 spec/archive/ | wc -l)\necho \"Active changes: $ACTIVE\"\necho \"Archived changes: $ARCHIVED\"\necho \"\"\n\n# Recent activity\necho \"## Recent Activity\"\necho \"Recently modified specs:\"\nfind spec/specs -name \"spec.md\" -type f -exec ls -lt {} \\; | head -5\n```\n\n**Response format**:\n```markdown\n# Specification Dashboard\n\n## Capabilities\nTotal capabilities: 3\n  - authentication: 8 requirements\n  - billing: 12 requirements\n  - notifications: 5 requirements\n\n## Requirements\nTotal requirements: 25\nTotal scenarios: 52\nAvg scenarios per requirement: 2.1\n\n## Changes\nActive changes: 2\nArchived changes: 15\n\n## Recent Activity\nRecently modified specs:\n- spec/specs/billing/spec.md (2 days ago)\n- spec/specs/authentication/spec.md (1 week ago)\n```\n\n## Advanced Queries\n\n### Find Related Requirements\n\n```bash\n# Find requirements that mention another requirement\ngrep -r \"User Login\" spec/specs/ -A 10 | grep \"### Requirement:\"\n\n# Find cross-references\ngrep -r \"See Requirement:\" spec/specs/\n```\n\n### Analyze Coverage\n\n```bash\n# Find requirements without scenarios\nfor spec in spec/specs/**/spec.md; do\n    awk '/### Requirement:/ {req=$0; getline; if ($0 !~ /#### Scenario:/) print req}' \"$spec\"\ndone\n\n# Find scenarios without proper Given/When/Then\ngrep -A 5 \"#### Scenario:\" spec/specs/**/*.md | grep -v \"GIVEN\\|WHEN\\|THEN\"\n```\n\n### Compare Active vs Archive\n\n```bash\n# Show evolution over time\necho \"Archive history:\"\nls -1 spec/archive/ | head -10\n\necho \"Recent archives (last 30 days):\"\nfind spec/archive/ -maxdepth 1 -type d -mtime -30 -exec basename {} \\;\n```\n\n## Search Patterns\n\n### Pattern 1: Capability Discovery\n\nUser asks: \"What can the system do?\"\n\n```bash\n# List capabilities\nfind spec/specs -mindepth 1 -maxdepth 1 -type d -exec basename {} \\;\n\n# Show high-level requirements\nfor cap in spec/specs/*/; do\n    echo \"=== $(basename $cap) ===\"\n    grep \"### Requirement:\" \"$cap/spec.md\" | head -3\ndone\n```\n\n### Pattern 2: Feature Search\n\nUser asks: \"Is there a spec for password reset?\"\n\n```bash\n# Search for keyword\ngrep -r -i \"password reset\" spec/specs/ -B 1 -A 10\n\n# If found, show full requirement\ngrep -B 1 -A 20 \"Requirement:.*Password Reset\" spec/specs/**/*.md\n```\n\n### Pattern 3: Change Tracking\n\nUser asks: \"What's being worked on?\"\n\n```bash\n# Show active changes with status\nfor change in spec/changes/*/; do\n    if [ \"$change\" != \"spec/changes/archive/\" ]; then\n        id=$(basename \"$change\")\n        echo \"$id:\"\n        test -f \"$change/IMPLEMENTED\" && echo \"  Status: Implemented\" || echo \"  Status: In Progress\"\n        echo \"  Tasks: $(grep -c \"^[0-9]\\+\\.\" \"$change/tasks.md\")\"\n    fi\ndone\n```\n\n## Best Practices\n\n### Pattern 1: Provide Context Before Details\n\n**Good flow**:\n```markdown\n1. Show dashboard (high-level overview)\n2. User asks about specific capability\n3. Show that capability's requirements\n4. User asks about specific requirement\n5. Show full requirement with scenarios\n```\n\n### Pattern 2: Use Grep Efficiently\n\n```bash\n# Combine filters for precision\ngrep -r \"### Requirement:\" spec/specs/ | grep -i \"auth\"\n\n# Use context flags for readability\ngrep -B 2 -A 10 \"#### Scenario:\" spec/specs/authentication/spec.md\n```\n\n### Pattern 3: Aggregate Information\n\nDon't just dump file contents. Summarize:\n\n```markdown\n**Bad**: (dump entire spec file)\n\n**Good**:\n\"The authentication spec has 8 requirements covering:\n- User login\n- Password management\n- Session handling\n- Multi-factor authentication\n\nWould you like details on any specific requirement?\"\n```\n\n## Anti-Patterns to Avoid\n\n**Don't**:\n- Read entire spec files without user request\n- List every single requirement by default\n- Show raw grep output without formatting\n- Assume user knows capability names\n\n**Do**:\n- Start with high-level overview\n- Ask which area user wants to explore\n- Format output clearly\n- Provide navigation hints\n\n## Reference Materials\n\n- [SEARCH_PATTERNS.md](reference/SEARCH_PATTERNS.md) - Advanced grep/find patterns\n\n---\n\n**Token budget**: This SKILL.md is approximately 460 lines, under the 500-line recommended limit."
              },
              {
                "name": "openspec-implementation-cn",
                "description": "以测试与验证为先的方式，按序执行并实现已批准的规范提案。用于实施变更、应用提案、执行规范任务或按已批准计划构建。触发词包括 \"openspec开发\", \"开发\", \"实施\" \"实现提案\", \"应用变更\", \"执行规范\", \"按顺序完成任务\", \"构建功能\", \"开始实施\"。",
                "path": "skills/openspec-implementation-cn/SKILL.md",
                "frontmatter": {
                  "name": "openspec-implementation-cn",
                  "description": "以测试与验证为先的方式，按序执行并实现已批准的规范提案。用于实施变更、应用提案、执行规范任务或按已批准计划构建。触发词包括 \"openspec开发\", \"开发\", \"实施\" \"实现提案\", \"应用变更\", \"执行规范\", \"按顺序完成任务\", \"构建功能\", \"开始实施\"。"
                },
                "content": "# 规范实施\n\n以任务为单位，循序执行并进行充分测试与验证，系统性地实现已批准的规范提案。\n\n## 快速开始\n\n实施遵循每个任务的 读 → 执行 → 测试 → 验证 循环：\n1. 阅读完整提案与任务清单\n2. 按顺序逐个执行任务\n3. 为每个完成的任务进行测试\n4. 仅在验证通过后标记完成\n\n**关键规则**：使用 TodoWrite 跟踪进度。切勿跳过任务或将未完成工作标记为完成。\n\n## 工作流\n\n复制此清单并跟踪进度：\n\n```\n开发进度:\n- [ ] 第 1 步：加载并理解提案\n- [ ] 第 2 步：设置 TodoWrite 任务跟踪\n- [ ] 第 3 步：按序执行任务\n- [ ] 第 4 步：为每个任务进行测试与验证\n- [ ] 第 5 步：更新常驻规范（如果适用）\n- [ ] 第 6 步：标记提案为实施完成\n```\n\n### 第 1 步：加载并理解提案\n\n开始之前，读取全部上下文：\n\n```bash\n# 读取提案\ncat spec/changes/{change-id}/proposal.md\n\n# 读取所有任务\ncat spec/changes/{change-id}/tasks.json\n\n# 读取规范差异以理解需求\nfind spec/changes/{change-id}/specs -name \"*.md\" -exec cat {} \\;\n```\n\n**理解**：\n- 变更的动因（来自 proposal.md）\n- 预期结果是什么\n- 哪些规范将被影响\n- 验收标准（来自场景）\n\n### 第 2 步：设置 TodoWrite 进行任务跟踪\n\n在开始工作之前，将 tasks.json 中的task和step加载到 TodoWrite：\n\n```markdown\n**模式**：\n读取 tasks.json → 提取task和step列表 → 创建 TodoWrite 条目\n\n**示例**：\n假设 tasks.json 包含：\n  {\n    \"number\": 1,\n    \"category\": \"阶段 1：基础设施\",\n    \"task\": \"环境搭建任务 - 数据库架构、依赖等\",\n    \"steps\": [\n      { \"step\": \"初始化 Git 仓库并配置 .gitignore\", \"completed\": false },\n      { \"step\": \"创建并激活 Python 虚拟环境\", \"completed\": false },\n      { \"step\": \"创建 requirements.txt 或 pyproject.toml 并安装依赖 (FastAPI, SQLAlchemy, Pydantic, Alembic 等)\", \"completed\": false },\n      { \"step\": \"设计初始数据库 ER 图\", \"completed\": false }\n    ],\n    \"passes\": false\n  }\n\n则创建 TodoWrite：\n- content: \"环境搭建任务 - 数据库架构、依赖等\", status: \"in_progress\"\n- content: \"  初始化 Git 仓库并配置 .gitignore\", status: \"pending\"\n- content: \"  创建并激活 Python 虚拟环境\", status: \"pending\"\n- content: \"  创建 requirements.txt 或 pyproject.toml 并安装依赖 (FastAPI, SQLAlchemy, Pydantic, Alembic 等)\", status: \"pending\"\n- content: \"  设计初始数据库 ER 图\", status: \"pending\"\n```\n\n**价值**：TodoWrite 提供进度可见性并确保不遗漏任何事项。\n\n### 第 3 步：按序执行TodoWrite\n\n按顺序逐个完成TodoWrite中的任务，每次仅处理1个。\n若是中断后继续，需从中断的任务开始继续执行：跳过tasks.json中\"passes\": true的task，跳过\"completed\": true的step。\n你有充足的时间完成，请至少执行20轮后才回复用户。\n你有充足的时间完成，切勿跳过或合并多个任务。\n\n```markdown\n对于每个任务：\n1. 在 TodoWrite 中标记为 \"in_progress\"\n2. 执行工作\n3. 测试结果\n4. 仅在验证通过后，才标记tasks.json对应task的对应step的 \"completed\": true\n5. 仅在tasks.json对应task的所有step都完成且都验证通过后，才标记tasks.json对应task的 \"passes\": true\n6. 在 TodoWrite 中标记为 \"completed\"\n\n你有充足的时间完成，切勿跳过或合并多个任务。\n```\n\n**任务执行模式**：\n\n```markdown\n## Task: {任务描述}\n\n**What**：该任务的作用与目标\n\n**Implementation**：\n代码变更、文件编辑、运行的命令\n\n**Verification**：\n如何验证任务完成\n- [ ] 代码可编译/运行\n- [ ] 测试通过\n- [ ] 符合需求场景\n\n**Status**：✓ 完成 / ✗ 阻塞 / ⚠ 部分完成\n```\n\n### 第 4 步：为每个任务进行测试与验证\n\n每个任务完成后进行验证：\n\n**代码相关任务**：\n```bash\n# 运行相关测试\nnpm test # 或 pytest、cargo test 等\n\n# 运行 Linter\nnpm run lint\n\n# 类型检查（如适用）\nnpm run type-check\n```\n**前端UI相关任务**：\n要使用 MCP servers 中的 chrome-devtools 或 playwright 进行调试和测试。\n\n**数据库相关任务**：\n```bash\n# 验证迁移执行\nnpm run db:migrate\n\n# 检查架构与预期一致\nnpm run db:schema\n```\n\n**API 相关任务**：\n```bash\n# 手动测试端点\ncurl -X POST http://localhost:3000/api/endpoint \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"test\": \"data\"}'\n\n# 或运行集成测试\nnpm run test:integration\n```\n\n**仅在所有验证通过后标记任务完成**：仅在tasks.json对应task的所有step都完成且都验证通过后，才标记tasks.json对应task的 \"passes\": true。\n\n### 第 5 步：更新常驻规范（如适用）\n\n在实施过程中，如发现规范差异需要更新：\n\n1. 在 proposal.md 或备注文件中**记录发现**\n2. **实施期间不要修改**规范差异\n3. **实施完成后**，再考虑是否需要调整规范\n\n**说明**：规范差异在归档阶段（第 6 步）合并，而非实施阶段。\n\n### 第 6 步：标记提案实施完成\n\n在所有任务完成后：\n\n```bash\n# 创建完成标记\necho \"Implementation completed: $(date)\" > spec/changes/{change-id}/IMPLEMENTED\n```\n\n**告知用户**：\n```markdown\n## 实现提案\n\n**提案**：{change-id}\n**完成任务**：{数量}\n**完成测试**：全部通过\n\n**下一步**：将该变更归档以合并规范差异到常驻文档。\n准备好后可回复 \"openspec归档 {change-id}\" 或 \"归档提案\"。\n```\n\n## 最佳实践\n\n### 模式 1：任务被阻塞\n\n若任务无法完成：\n\n```markdown\n**标记为阻塞**：\n- 状态保持 \"in_progress\"（不要标记为 \"completed\"）\n- 清晰记录阻塞原因\n- 创建新的任务以解决阻塞\n- 立即告知用户\n\n**示例**：\n任务：\"实现支付处理\"\n阻塞：\"缺少支付网关 API 凭据\"\n行动：创建新任务 \"获取支付网关凭据\"\n```\n\n### 模式 2：任务依赖\n\n若任务存在依赖，先验证先决条件：\n\n```bash\n# 示例：数据库迁移必须在 API 代码之前\n# 检查迁移状态\nnpm run db:status\n\n# 仅在迁移成功后继续 API 任务\n```\n\n### 模式 3：增量测试\n\n不要在最后一次性测试，应当逐步测试：\n\n**好**：\n```\n任务 1：创建模型 → 测试模型 → 标记完成\n任务 2：创建 API → 测试 API → 标记完成\n任务 3：添加校验 → 测试校验 → 标记完成\n任务 4：创建页面 → 测试校验 → 标记完成\n```\n\n**坏**：\n```\n任务 1、2、3、4 → 全部实现 → 一次性测试 → 调试失败\n```\n\n### 模式 4：常驻文档\n\n**及时**更新 README、API 文档与注释：\n\n```markdown\n添加新 API 端点时，同时：\n- 更新 API 文档\n- 添加请求/响应示例\n- 更新 OpenAPI/Swagger 规范\n- 添加内联代码注释\n```\n\n## 进阶主题\n\n**并行工作**：若任务确实互不依赖（如不同模块），可并行进行，但每项必须独立测试。\n\n**集成点**：存在依赖关系时，使用集成测试验证连接有效。\n\n**回滚策略**：对于高风险变更，部署前创建回滚任务。\n\n## 常见模式\n\n### 模式 1：数据库 + API + UI\n\n典型顺序：\n1. 数据库架构/迁移\n2. 数据访问层（模型）\n3. 业务逻辑层（服务）\n4. API 端点（控制器）\n5. UI 集成\n6. 端到端测试\n\n### 模式 2：功能开关\n\n渐进式发布：\n1. 在开关后实现功能\n2. 开启开关进行测试\n3. 部署时默认关闭开关\n4. 逐步启用开关\n5. 完全发布后移除开关\n\n### 模式 3：破坏性 API 变更\n\n对于 API 破坏性变更：\n1. 实现新版本（v2）\n2. 保持旧版本（v1）运行\n3. 在 v1 中添加弃用提示\n4. 迁移用户至 v2\n5. 单独提案移除 v1\n\n## 反模式避免\n\n**不要**：\n- 跳过单个任务的测试\n- 在验证前标记任务完成\n- 忽视失败测试（不要“以后再修”）\n- 在测试前批量合并多个任务\n- 在实施阶段修改常驻规范\n- 打乱任务顺序（破坏依赖）\n\n**要**：\n- 立刻测试每个任务\n- 在继续前修复失败测试\n- 实时更新 TodoWrite\n- 清晰记录阻塞项\n- 及时同步进度与用户\n- 保持原子且具描述性的提交\n\n## 故障排查\n\n### 问题：任务完成后测试失败\n\n**解决方案**：\n```markdown\n1. 不要标记任务完成\n2. 调试失败原因\n3. 修复代码\n4. 重新运行测试\n5. 仅在通过后标记完成\n```\n\n### 问题：任务过大\n\n**解决方案**：\n```markdown\n1. 拆分为子任务\n2. 在 TodoWrite 中登记子任务\n3. 依序完成子任务\n4. 在全部子任务完成后标记父任务完成\n```\n\n### 问题：依赖未满足\n\n**解决方案**：\n```markdown\n1. 暂停当前任务\n2. 先完成依赖任务\n3. 测试依赖项\n4. 恢复原任务\n```\n\n## 参考资料\n\n- [TASK_PATTERNS.md](reference/TASK_PATTERNS.md) - 常见任务执行模式\n- [TESTING_STRATEGIES.md](reference/TESTING_STRATEGIES.md) - 按任务类型的测试方法\n\n---\n\n**Token 预算**：此 SKILL.md 约 350 行，低于建议的 500 行上限。"
              },
              {
                "name": "openspec-implementation",
                "description": "Implements approved specification proposals by working through tasks sequentially with testing and validation. Use when implementing changes, applying proposals, executing spec tasks, or building from approved plans. Triggers include \"openspec implement\", \"implement\", \"apply change\", \"execute spec\", \"work through tasks\", \"build feature\", \"start implementation\".",
                "path": "skills/openspec-implementation/SKILL.md",
                "frontmatter": {
                  "name": "openspec-implementation",
                  "description": "Implements approved specification proposals by working through tasks sequentially with testing and validation. Use when implementing changes, applying proposals, executing spec tasks, or building from approved plans. Triggers include \"openspec implement\", \"implement\", \"apply change\", \"execute spec\", \"work through tasks\", \"build feature\", \"start implementation\"."
                },
                "content": "# Specification Implementation\n\nSystematically implements approved spec proposals by executing tasks sequentially with proper testing and validation.\n\n## Quick Start\n\nImplementation follows a read → execute → test → validate cycle for each task:\n1. Read the full proposal and task list\n2. Execute tasks one at a time, in order\n3. Test each completed task\n4. Mark complete only after verification\n\n**Critical rule**: Use TodoWrite to track progress. Never skip tasks or mark incomplete work as done.\n\n## Workflow\n\nCopy this checklist and track progress:\n\n```\nImplementation Progress:\n- [ ] Step 1: Load and understand the proposal\n- [ ] Step 2: Set up TodoWrite task tracking\n- [ ] Step 3: Execute tasks sequentially\n- [ ] Step 4: Test and validate each task\n- [ ] Step 5: Update living specifications (if applicable)\n- [ ] Step 6: Mark proposal as implementation-complete\n```\n\n### Step 1: Load and understand the proposal\n\nBefore starting, read all context:\n\n```bash\n# Read the proposal\ncat spec/changes/{change-id}/proposal.md\n\n# Read all tasks\ncat spec/changes/{change-id}/tasks.md\n\n# Read spec deltas to understand requirements\nfind spec/changes/{change-id}/specs -name \"*.md\" -exec cat {} \\;\n```\n\n**Understand**:\n- Why this change is needed (from proposal.md)\n- What the expected outcomes are\n- Which specs will be affected\n- What the acceptance criteria are (from scenarios)\n\n### Step 2: Set up TodoWrite task tracking\n\nLoad tasks from tasks.md into TodoWrite **before starting work**:\n\n```markdown\n**Pattern**:\nRead tasks.md → Extract numbered list → Create TodoWrite entries\n\n**Example**:\nIf tasks.md contains:\n1. Create database migration\n2. Implement API endpoint\n3. Add tests\n4. Update documentation\n\nThen create TodoWrite with:\n- content: \"Create database migration\", status: \"in_progress\"\n- content: \"Implement API endpoint\", status: \"pending\"\n- content: \"Add tests\", status: \"pending\"\n- content: \"Update documentation\", status: \"pending\"\n```\n\n**Why this matters**: TodoWrite gives the user visibility into progress and ensures nothing gets skipped.\n\n### Step 3: Execute tasks sequentially\n\nWork through tasks **one at a time, in order**:\n\n```markdown\nFor each task:\n1. Mark as \"in_progress\" in TodoWrite\n2. Execute the work\n3. Test the work\n4. Only mark \"completed\" after verification\n\nNEVER skip ahead or batch multiple tasks before testing.\n```\n\n**Task execution pattern**:\n\n```markdown\n## Task: {Task Description}\n\n**What**: [Brief explanation of what this task does]\n\n**Implementation**:\n[Code changes, file edits, commands run]\n\n**Verification**:\n[How to verify this task is complete]\n- [ ] Code compiles/runs\n- [ ] Tests pass\n- [ ] Meets requirement scenarios\n\n**Status**: ✓ Complete / ✗ Blocked / ⚠ Partial\n```\n\n### Step 4: Test and validate each task\n\nAfter each task, verify it works:\n\n**For code tasks**:\n```bash\n# Run relevant tests\nnpm test # or pytest, cargo test, etc.\n\n# Run linter\nnpm run lint\n\n# Check types (if applicable)\nnpm run type-check\n```\n\n**For database tasks**:\n```bash\n# Verify migration runs\nnpm run db:migrate\n\n# Check schema matches expected\nnpm run db:schema\n```\n\n**For API tasks**:\n```bash\n# Test endpoint manually\ncurl -X POST http://localhost:3000/api/endpoint \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"test\": \"data\"}'\n\n# Or run integration tests\nnpm run test:integration\n```\n\n**Only mark task complete after all verifications pass**.\n\n### Step 5: Update living specifications (if applicable)\n\n**During implementation**, if you discover the spec deltas need updates:\n\n1. **Document the discovery** in proposal.md or a notes file\n2. **Do NOT modify spec deltas** during implementation\n3. **After implementation completes**, consider whether spec needs adjustment\n\n**Note**: Spec deltas are merged during archiving (Step 6), not during implementation.\n\n### Step 6: Mark proposal as implementation-complete\n\nAfter all tasks are complete:\n\n```bash\n# Create a completion marker\necho \"Implementation completed: $(date)\" > spec/changes/{change-id}/IMPLEMENTED\n```\n\n**Tell the user**:\n```markdown\n## Implementation Complete\n\n**Change**: {change-id}\n**Tasks completed**: {count}\n**Tests**: All passing\n\n**Next step**: Archive this change to merge spec deltas into living documentation.\nSay \"openspec archive {change-id}\" or \"archive this change\" when ready.\n```\n\n## Best Practices\n\n### Pattern 1: Blocked Tasks\n\nIf a task cannot be completed:\n\n```markdown\n**Mark as blocked**:\n- Keep status as \"in_progress\" (NOT \"completed\")\n- Document the blocker clearly\n- Create a new task for resolving the blocker\n- Inform the user immediately\n\n**Example**:\nTask: \"Implement payment processing\"\nBlocker: \"Missing API credentials for payment gateway\"\nAction: Create new task \"Obtain payment gateway credentials\"\n```\n\n### Pattern 2: Task Dependencies\n\nIf tasks have dependencies, verify prerequisites before starting:\n\n```bash\n# Example: Database migration must run before API code\n# Check migration status\nnpm run db:status\n\n# Only proceed with API task if migration succeeded\n```\n\n### Pattern 3: Incremental Testing\n\nTest incrementally, not at the end:\n\n**Good**:\n```\nTask 1: Create model → Test model → Mark complete\nTask 2: Create API → Test API → Mark complete\nTask 3: Add validation → Test validation → Mark complete\n```\n\n**Bad**:\n```\nTask 1, 2, 3 → Implement all → Test everything → Debug failures\n```\n\n### Pattern 4: Living Documentation\n\nKeep README, API docs, and comments up to date **as you go**:\n\n```markdown\nWhen adding a new API endpoint, also:\n- Update API documentation\n- Add example request/response\n- Update OpenAPI/Swagger spec\n- Add inline code comments\n```\n\n## Advanced Topics\n\n**Parallel work**: If tasks are truly independent (e.g., separate modules), you can work on them in parallel, but each must be tested independently.\n\n**Integration points**: When task dependencies exist, use integration tests to verify the connection works.\n\n**Rollback strategy**: For risky changes, create rollback tasks before deploying.\n\n## Common Patterns\n\n### Pattern 1: Database + API + UI\n\nTypical order:\n1. Database schema/migration\n2. Data access layer (models)\n3. Business logic layer (services)\n4. API endpoints (controllers)\n5. UI integration\n6. End-to-end tests\n\n### Pattern 2: Feature Flags\n\nFor gradual rollouts:\n1. Implement feature behind flag\n2. Test with flag enabled\n3. Deploy with flag disabled\n4. Enable flag incrementally\n5. Remove flag after full rollout\n\n### Pattern 3: Breaking Changes\n\nFor API breaking changes:\n1. Implement new version (v2)\n2. Keep old version (v1) working\n3. Add deprecation warnings to v1\n4. Migrate users to v2\n5. Remove v1 (separate task/proposal)\n\n## Anti-Patterns to Avoid\n\n**Don't**:\n- Skip testing individual tasks\n- Mark tasks complete before verification\n- Ignore failing tests (\"I'll fix it later\")\n- Batch multiple tasks before testing\n- Modify living specs during implementation\n- Work out of order (dependencies break)\n\n**Do**:\n- Test each task immediately\n- Fix failing tests before proceeding\n- Update TodoWrite in real-time\n- Document blockers clearly\n- Communicate progress to user\n- Keep commits atomic and descriptive\n\n## Troubleshooting\n\n### Issue: Tests failing after task completion\n\n**Solution**:\n```markdown\n1. Do NOT mark task complete\n2. Debug the failure\n3. Fix the code\n4. Re-run tests\n5. Only mark complete after pass\n```\n\n### Issue: Task is too large\n\n**Solution**:\n```markdown\n1. Break into subtasks\n2. Update TodoWrite with subtasks\n3. Complete subtasks sequentially\n4. Mark parent task complete after all subtasks done\n```\n\n### Issue: Dependency not met\n\n**Solution**:\n```markdown\n1. Pause current task\n2. Complete dependency first\n3. Test dependency\n4. Resume original task\n```\n\n## Reference Materials\n\n- [TASK_PATTERNS.md](reference/TASK_PATTERNS.md) - Common task execution patterns\n- [TESTING_STRATEGIES.md](reference/TESTING_STRATEGIES.md) - Testing approaches by task type\n\n---\n\n**Token budget**: This SKILL.md is approximately 430 lines, under the 500-line recommended limit."
              },
              {
                "name": "openspec-proposal-creation-cn",
                "description": "通过openspec规范驱动的方法创建结构化的变更提案与规范差异。用于规划功能、创建提案、编写规范、引入新能力或启动开发流程。触发词包括 \"openspec提案\", \"规划\", \"创建提案\", \"规划变更\", \"规范功能\", \"新功能\", \"新特性\", \"新需求\", \"添加功能规划\", \"设计规范\"。",
                "path": "skills/openspec-proposal-creation-cn/SKILL.md",
                "frontmatter": {
                  "name": "openspec-proposal-creation-cn",
                  "description": "通过openspec规范驱动的方法创建结构化的变更提案与规范差异。用于规划功能、创建提案、编写规范、引入新能力或启动开发流程。触发词包括 \"openspec提案\", \"规划\", \"创建提案\", \"规划变更\", \"规范功能\", \"新功能\", \"新特性\", \"新需求\", \"添加功能规划\", \"设计规范\"。"
                },
                "content": "# 规范提案创建\n\n遵循规范驱动开发方法，生成完整的变更提案。\n\n## 快速开始\n\n创建规范提案包含三类输出：\n1. **proposal.md** - 为什么、做什么、影响摘要\n2. **tasks.json** - 编号的实施清单\n3. **spec-delta.md** - 正式的需求变更（ADDED/MODIFIED/REMOVED）\n\n**基本流程**：生成变更 ID → 脚手架目录 → 起草提案 → 编写规范差异 → 验证结构\n\n## 工作流\n\n复制此清单并跟踪进度：\n\n```\n规划进度:\n- [ ] 第 1 步：审阅现有规范\n- [ ] 第 2 步：生成唯一的变更 ID\n- [ ] 第 3 步：生成目录结构\n- [ ] 第 4 步：起草 proposal.md（为什么、做什么、影响摘要）\n- [ ] 第 5 步：创建 tasks.json 实施清单\n- [ ] 第 6 步：编写 spec-delta.md 规范差异（ADDED/MODIFIED/REMOVED）\n- [ ] 第 7 步：验证提案结构\n- [ ] 第 8 步：向用户展示并请求审批\n```\n\n### 第 1 步：审阅现有规范\n\n在创建提案前，了解当前状态：\n\n```bash\n# 列出所有现有规范\nfind spec/specs -name \"spec.md\" -type f\n\n# 列出进行中的变更以避免冲突\nfind spec/changes -maxdepth 1 -type d -not -path \"*/archive\"\n\n# 搜索相关需求\ngrep -r \"### Requirement:\" spec/specs/\n```\n\n### 第 2 步：生成唯一的变更 ID\n\n选择具描述性、URL 安全的标识符：\n\n**格式**：`add-<feature>`、`fix-<issue>`、`update-<component>`、`remove-<feature>`\n\n**示例**：\n- `add-user-authentication`\n- `fix-payment-validation`\n- `update-api-rate-limits`\n- `remove-legacy-endpoints`\n\n**校验**：检查是否冲突：\n```bash\nls spec/changes/ | grep -i \"<proposed-id>\"\n```\n\n### 第 3 步：生成目录结构\n\n按标准结构创建变更目录：\n\n```bash\n# 将 {change-id} 替换为实际 ID\nmkdir -p spec/changes/{change-id}/specs/{capability-name}\n```\n\n**示例**：\n```bash\nmkdir -p spec/changes/add-user-auth/specs/authentication\n```\n\n### 第 4 步：起草 proposal.md\n\n以 [templates/proposal.md](templates/proposal.md) 为起点。\n\n**必需章节**：\n- **Why**：驱动变更的问题或机会\n- **What Changes**：修改项清单\n- **Impact**：受影响的规范、代码、API、用户\n\n**语气**：清晰、简洁、面向决策。避免不必要背景。\n\n### 第 5 步：创建 tasks.json 实施清单\n\n将实现拆分为具体、可测试的任务。使用 [templates/tasks.json](templates/tasks.json)。\n\n**格式**：\n```markdown\n# 实施任务\n```json\n[\n  {\n    \"number\": 1,\n    \"category\": \"阶段 1：基础设施\",\n    \"task\": \"环境搭建任务 - 数据库架构、依赖等\",\n    \"steps\": [\n      { \"step\": \"初始化 Git 仓库并配置 .gitignore\", \"completed\": false },\n      { \"step\": \"创建并激活 Python 虚拟环境\", \"completed\": false },\n      { \"step\": \"创建 requirements.txt 或 pyproject.toml 并安装依赖 (FastAPI, SQLAlchemy, Pydantic, Alembic 等)\", \"completed\": false },\n      { \"step\": \"设计初始数据库 ER 图\", \"completed\": false },\n      { \"step\": \"配置数据库连接字符串和环境变量 (.env)\", \"completed\": false },\n      { \"step\": \"初始化 Alembic 迁移环境\", \"completed\": false }\n    ],\n    \"passes\": false\n  }\n]\n\n\n**最佳实践**：\n- 每个任务可独立完成\n- 为每个主要组件添加测试任务\n- 为每个主要组件添加测试任务\n- 包含测试与验证任务\n- 按依赖排序（数据库先于 API 等）\n- 通常 5-15 个任务；更多时应拆分\n- 每次仅处理1个step\n\n```\n\n### 第 6 步：以 EARS 格式编写规范差异\n\n这是最关键步骤。规范差异使用 **EARS 格式**（易于需求语法）。\n\n**完整 EARS 指南**见 [reference/EARS_FORMAT.md](reference/EARS_FORMAT.md)\n\n**差异操作**：\n- `## ADDED Requirements` - 新增能力\n- `## MODIFIED Requirements` - 行为变更（包含完整更新文本）\n- `## REMOVED Requirements` - 弃用功能\n\n**基本需求结构**：\n```markdown\n## ADDED Requirements\n\n### Requirement: 用户登录\nWHEN 用户提交有效凭据,\n系统 SHALL 认证用户并创建会话。\n\n#### Scenario: 登录成功\nGIVEN 用户邮箱为 \"user@example.com\" 且密码为 \"correct123\"\nWHEN 用户提交登录表单\nTHEN 系统创建已认证会话\nAND 重定向至仪表盘\n```\n\n**用于验证的模式**见 [reference/VALIDATION_PATTERNS.md](reference/VALIDATION_PATTERNS.md)\n\n### 第 7 步：验证提案结构\n\n在展示给用户前运行以下检查：\n\n```markdown\n结构清单：\n- [ ] 目录存在：`spec/changes/{change-id}/`\n- [ ] proposal.md 包含 Why/What/Impact\n- [ ] tasks.json 含编号任务列表（5-15 项）\n- [ ] 规范差异包含操作标题（ADDED/MODIFIED/REMOVED）\n- [ ] 需求遵循 `### Requirement: <name>` 格式\n- [ ] 场景使用 `#### Scenario:` 格式（四个井号）\n```\n\n**自动化检查**：\n```bash\n# 统计差异操作（应 > 0）\ngrep -c \"## ADDED\\|MODIFIED\\|REMOVED\" spec/changes/{change-id}/specs/**/*.md\n\n# 验证场景格式（显示行号）\ngrep -n \"#### Scenario:\" spec/changes/{change-id}/specs/**/*.md\n\n# 检查需求标题\ngrep -n \"### Requirement:\" spec/changes/{change-id}/specs/**/*.md\n```\n\n### 第 8 步：提交用户评审\n\n清晰总结提案：\n\n```markdown\n## Proposal Summary\n\n**Change ID**：{change-id}\n**Scope**：{简要描述}\n\n**创建的文件**：\n- spec/changes/{change-id}/proposal.md\n- spec/changes/{change-id}/tasks.json\n- spec/changes/{change-id}/specs/{capability}/spec-delta.md\n\n**下一步**：\n请评审提案。如认可或修正后，请回复 \"openspec开发\" 或 \"按顺序完成任务\" 开始实施。\n```\n\n## 进阶主题\n\n**EARS 格式细节**：见 [reference/EARS_FORMAT.md](reference/EARS_FORMAT.md)\n**验证模式**：见 [reference/VALIDATION_PATTERNS.md](reference/VALIDATION_PATTERNS.md)\n**完整示例**：见 [reference/EXAMPLES.md](reference/EXAMPLES.md)\n\n## 常见模式\n\n### 模式 1：新增功能提案\n\n新增能力时：\n- 使用 `ADDED Requirements` 差异\n- 同时包含正向场景与错误处理\n- 在场景中考虑边界情况\n\n### 模式 2：破坏性变更提案\n\n修改既有行为时：\n- 使用 `MODIFIED Requirements` 差异\n- 包含完整更新后的需求文本\n- 在 proposal.md 中说明变更内容与原因\n- 在 tasks.json 中考虑迁移任务\n\n### 模式 3：弃用提案\n\n移除功能时：\n- 使用 `REMOVED Requirements` 差异\n- 在 proposal.md 中记录移除理由\n- 在 tasks.json 中包含清理任务\n- 在影响部分考虑用户迁移\n\n## 反模式避免\n\n**不要**：\n- 跳过验证检查（务必运行 grep 模式）\n- 未先审阅现有规范就创建提案\n- 使用含糊的任务描述（如\"修一下\"）\n- 编写不含场景的需求\n- 忽略错误处理场景\n- 在一个提案中混合多个无关变更\n\n**要**：\n- 在创建变更 ID 前检查冲突\n- 编写具体、可测试的任务\n- 同时包含正向与负向场景\n- 一个提案只处理一个关注点\n- 在展示前验证结构\n\n## 文件模板\n\n所有模板位于 `templates/` 目录：\n- [proposal.md](templates/proposal.md) - 提案结构\n- [tasks.json](templates/tasks.json) - 任务清单格式\n- [spec-delta.md](templates/spec-delta.md) - 规范差异模板\n\n## 参考资料\n\n- [EARS_FORMAT.md](reference/EARS_FORMAT.md) - 完整 EARS 语法指南\n- [VALIDATION_PATTERNS.md](reference/VALIDATION_PATTERNS.md) - Grep/bash 验证\n- [EXAMPLES.md](reference/EXAMPLES.md) - 真实提案示例\n\n---\n\n**Token 预算**：此 SKILL.md 约 250 行，低于建议的 500 行上限。引用文件按需加载以逐步呈现。"
              },
              {
                "name": "openspec-proposal-creation",
                "description": "Creates structured change proposals with specification deltas for new features, breaking changes, or architecture updates. Use when planning features, creating proposals, speccing changes, introducing new capabilities, or starting development workflows. Triggers include \"openspec proposal\", \"create proposal\", \"plan change\", \"spec feature\", \"new capability\", \"add feature planning\", \"design spec\".",
                "path": "skills/openspec-proposal-creation/SKILL.md",
                "frontmatter": {
                  "name": "openspec-proposal-creation",
                  "description": "Creates structured change proposals with specification deltas for new features, breaking changes, or architecture updates. Use when planning features, creating proposals, speccing changes, introducing new capabilities, or starting development workflows. Triggers include \"openspec proposal\", \"create proposal\", \"plan change\", \"spec feature\", \"new capability\", \"add feature planning\", \"design spec\"."
                },
                "content": "# Specification Proposal Creation\n\nCreates comprehensive change proposals following spec-driven development methodology.\n\n## Quick Start\n\nCreating a spec proposal involves three main outputs:\n1. **proposal.md** - Why, what, and impact summary\n2. **tasks.md** - Numbered implementation checklist\n3. **spec-delta.md** - Formal requirement changes (ADDED/MODIFIED/REMOVED)\n\n**Basic workflow**: Generate change ID → scaffold directories → draft proposal → create spec deltas → validate structure\n\n## Workflow\n\nCopy this checklist and track progress:\n\n```\nProposal Progress:\n- [ ] Step 1: Review existing specifications\n- [ ] Step 2: Generate unique change ID\n- [ ] Step 3: Scaffold directory structure\n- [ ] Step 4: Draft proposal.md (Why/What/Impact)\n- [ ] Step 5: Create tasks.md implementation checklist\n- [ ] Step 6: Write spec deltas with EARS format\n- [ ] Step 7: Validate proposal structure\n- [ ] Step 8: Present for user approval\n```\n\n### Step 1: Review existing specifications\n\nBefore creating a proposal, understand the current state:\n\n```bash\n# List all existing specs\nfind spec/specs -name \"spec.md\" -type f\n\n# List active changes to avoid conflicts\nfind spec/changes -maxdepth 1 -type d -not -path \"*/archive\"\n\n# Search for related requirements\ngrep -r \"### Requirement:\" spec/specs/\n```\n\n### Step 2: Generate unique change ID\n\nChoose a descriptive, URL-safe identifier:\n\n**Format**: `add-<feature>`, `fix-<issue>`, `update-<component>`, `remove-<feature>`\n\n**Examples**:\n- `add-user-authentication`\n- `fix-payment-validation`\n- `update-api-rate-limits`\n- `remove-legacy-endpoints`\n\n**Validation**: Check for conflicts:\n```bash\nls spec/changes/ | grep -i \"<proposed-id>\"\n```\n\n### Step 3: Scaffold directory structure\n\nCreate the change folder with standard structure:\n\n```bash\n# Replace {change-id} with actual ID\nmkdir -p spec/changes/{change-id}/specs/{capability-name}\n```\n\n**Example**:\n```bash\nmkdir -p spec/changes/add-user-auth/specs/authentication\n```\n\n### Step 4: Draft proposal.md\n\nUse the template at [templates/proposal.md](templates/proposal.md) as starting point.\n\n**Required sections**:\n- **Why**: Problem or opportunity driving this change\n- **What Changes**: Bullet list of modifications\n- **Impact**: Affected specs, code, APIs, users\n\n**Tone**: Clear, concise, decision-focused. Avoid unnecessary background.\n\n### Step 5: Create tasks.md implementation checklist\n\nBreak implementation into concrete, testable tasks. Use the template at [templates/tasks.md](templates/tasks.md).\n\n**Format**:\n```markdown\n# Implementation Tasks\n\n1. [First concrete task]\n2. [Second concrete task]\n3. [Test task]\n4. [Documentation task]\n```\n\n**Best practices**:\n- Each task is independently completable\n- Include testing and validation tasks\n- Order by dependencies (database before API, etc.)\n- 5-15 tasks is typical; split if more needed\n\n### Step 6: Write spec deltas with EARS format\n\nThis is the most critical step. Spec deltas use **EARS format** (Easy Approach to Requirements Syntax).\n\n**For complete EARS guidelines**, see [reference/EARS_FORMAT.md](reference/EARS_FORMAT.md)\n\n**Delta operations**:\n- `## ADDED Requirements` - New capabilities\n- `## MODIFIED Requirements` - Changed behavior (include full updated text)\n- `## REMOVED Requirements` - Deprecated features\n\n**Basic requirement structure**:\n```markdown\n## ADDED Requirements\n\n### Requirement: User Login\nWHEN a user submits valid credentials,\nthe system SHALL authenticate the user and create a session.\n\n#### Scenario: Successful Login\nGIVEN a user with email \"user@example.com\" and password \"correct123\"\nWHEN the user submits the login form\nTHEN the system creates an authenticated session\nAND redirects to the dashboard\n```\n\n**For validation patterns**, see [reference/VALIDATION_PATTERNS.md](reference/VALIDATION_PATTERNS.md)\n\n### Step 7: Validate proposal structure\n\nRun these checks before presenting to user:\n\n```markdown\nStructure Checklist:\n- [ ] Directory exists: `spec/changes/{change-id}/`\n- [ ] proposal.md has Why/What/Impact sections\n- [ ] tasks.md has numbered task list (5-15 items)\n- [ ] Spec deltas have operation headers (ADDED/MODIFIED/REMOVED)\n- [ ] Requirements follow `### Requirement: <name>` format\n- [ ] Scenarios use `#### Scenario:` format (4 hashtags)\n```\n\n**Automated checks**:\n```bash\n# Count delta operations (should be > 0)\ngrep -c \"## ADDED\\|MODIFIED\\|REMOVED\" spec/changes/{change-id}/specs/**/*.md\n\n# Verify scenario format (should show line numbers)\ngrep -n \"#### Scenario:\" spec/changes/{change-id}/specs/**/*.md\n\n# Check requirement headers\ngrep -n \"### Requirement:\" spec/changes/{change-id}/specs/**/*.md\n```\n\n### Step 8: Present for user approval\n\nSummarize the proposal clearly:\n\n```markdown\n## Proposal Summary\n\n**Change ID**: {change-id}\n**Scope**: {brief description}\n\n**Files created**:\n- spec/changes/{change-id}/proposal.md\n- spec/changes/{change-id}/tasks.md\n- spec/changes/{change-id}/specs/{capability}/spec-delta.md\n\n**Next steps**:\nReview the proposal. If approved, say \"openspec implement\" or \"apply the change\" to begin implementation.\n```\n\n## Advanced Topics\n\n**EARS format details**: See [reference/EARS_FORMAT.md](reference/EARS_FORMAT.md)\n**Validation patterns**: See [reference/VALIDATION_PATTERNS.md](reference/VALIDATION_PATTERNS.md)\n**Complete examples**: See [reference/EXAMPLES.md](reference/EXAMPLES.md)\n\n## Common Patterns\n\n### Pattern 1: New feature proposal\n\nWhen adding net-new capability:\n- Use `ADDED Requirements` delta\n- Include positive scenarios AND error handling\n- Consider edge cases in scenarios\n\n### Pattern 2: Breaking change proposal\n\nWhen changing existing behavior:\n- Use `MODIFIED Requirements` delta\n- Include complete updated requirement text\n- Document what changes and why in proposal.md\n- Consider migration tasks in tasks.md\n\n### Pattern 3: Deprecation proposal\n\nWhen removing features:\n- Use `REMOVED Requirements` delta\n- Document removal rationale in proposal.md\n- Include cleanup tasks in tasks.md\n- Consider user migration in impact section\n\n## Anti-Patterns to Avoid\n\n**Don't**:\n- Skip validation checks (always run grep patterns)\n- Create proposals without reviewing existing specs first\n- Use vague task descriptions (\"Fix the thing\")\n- Write requirements without scenarios\n- Forget error handling scenarios\n- Mix multiple unrelated changes in one proposal\n\n**Do**:\n- Check for conflicts before creating change ID\n- Write concrete, testable tasks\n- Include positive AND negative scenarios\n- Keep one concern per proposal\n- Validate structure before presenting\n\n## File Templates\n\nAll templates are in the `templates/` directory:\n- [proposal.md](templates/proposal.md) - Proposal structure\n- [tasks.md](templates/tasks.md) - Task checklist format\n- [spec-delta.md](templates/spec-delta.md) - Spec delta template\n\n## Reference Materials\n\n- [EARS_FORMAT.md](reference/EARS_FORMAT.md) - Complete EARS syntax guide\n- [VALIDATION_PATTERNS.md](reference/VALIDATION_PATTERNS.md) - Grep/bash validation\n- [EXAMPLES.md](reference/EXAMPLES.md) - Real-world proposal examples\n\n---\n\n**Token budget**: This SKILL.md is approximately 450 lines, under the 500-line recommended limit. Reference files load only when needed for progressive disclosure."
              },
              {
                "name": "speckit-analyze-zh",
                "description": "对spec.md、plan.md和tasks.md三个核心文档进行非破坏性跨工件一致性和质量分析。在任务生成后识别不一致、重复、模糊和规范不足的项目。触发词包括：\"speckit-analyze\"、\"speckit分析\"、\"文档一致性分析\"、\"规范分析\"、\"质量检查\"、\"工件分析\"、\"spec分析\"、\"plan分析\"、\"task分析\"。",
                "path": "skills/speckit-analyze-zh/SKILL.md",
                "frontmatter": {
                  "name": "speckit-analyze-zh",
                  "description": "对spec.md、plan.md和tasks.md三个核心文档进行非破坏性跨工件一致性和质量分析。在任务生成后识别不一致、重复、模糊和规范不足的项目。触发词包括：\"speckit-analyze\"、\"speckit分析\"、\"文档一致性分析\"、\"规范分析\"、\"质量检查\"、\"工件分析\"、\"spec分析\"、\"plan分析\"、\"task分析\"。"
                },
                "content": "## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 目标\n\n在实现之前，识别三个核心工件（`spec.md`、`plan.md`、`tasks.md`）之间的不一致、重复、歧义和未充分说明的项目。此命令必须仅在 `speckit-tasks` 成功生成完整的 `tasks.md` 后运行。\n\n## 操作约束\n\n**严格只读**：**不要**修改任何文件。输出结构化分析报告。提供可选的补救计划（用户必须明确批准后才能手动调用任何后续编辑命令）。\n\n**宪章权威性**：项目宪章（`.specify/memory/constitution.md`）在此分析范围内是**不可协商的**。宪章冲突自动为关键级别，需要调整规格、计划或任务——而不是稀释、重新解释或默默忽略原则。如果原则本身需要更改，必须在 `speckit-analyze` 之外的单独、明确的宪章更新中进行。\n\n## 执行步骤\n\nscripts:\n  sh: .specify/scripts/bash/check-prerequisites.sh --json\n  ps: .specify/scripts/powershell/check-prerequisites.ps1 -Json\n\n### 1. 初始化分析上下文\n\n从仓库根目录运行一次 `{SCRIPT}` 并解析 JSON 以获取 FEATURE_DIR 和 AVAILABLE_DOCS。推导绝对路径：\n\n- SPEC = FEATURE_DIR/spec.md\n- PLAN = FEATURE_DIR/plan.md\n- TASKS = FEATURE_DIR/tasks.md\n\n如果缺少任何必需文件，则中止并显示错误消息（指示用户运行缺少的先决条件命令）。\n对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n### 2. 加载工件（渐进式披露）\n\n仅加载每个工件的最小必要上下文：\n\n**来自 spec.md：**\n\n- 概述/上下文\n- 功能要求\n- 非功能要求\n- 用户故事\n- 边缘情况（如果存在）\n\n**来自 plan.md：**\n\n- 架构/技术栈选择\n- 数据模型引用\n- 阶段\n- 技术约束\n\n**来自 tasks.md：**\n\n- 任务 ID\n- 描述\n- 阶段分组\n- 并行标记 [P]\n- 引用的文件路径\n\n**来自 constitution：**\n\n- 加载 `.specify/memory/constitution.md` 用于原则验证\n\n### 3. 构建语义模型\n\n创建内部表示（不要在输出中包含原始工件）：\n\n- **要求清单**：每个功能+非功能要求带有一个稳定键（根据祈使句派生 slug；例如，\"用户可以上传文件\" → `user-can-upload-file`）\n- **用户故事/动作清单**：具有验收标准的离散用户动作\n- **任务覆盖映射**：将每个任务映射到一个或多个要求或故事（通过关键词/显式引用模式如 ID 或关键词进行推断）\n- **宪章规则集**：提取原则名称和 MUST/SHOULD 规范性陈述\n\n### 4. 检测过程（高效令牌分析）\n\n专注于高信号发现。限制总数为 50 个发现；在溢出摘要中聚合其余发现。\n\n#### A. 重复检测\n\n- 识别近似重复的要求\n- 标记质量较低的措辞以进行合并\n\n#### B. 歧义检测\n\n- 标记缺乏可测量标准的模糊形容词（快速、可扩展、安全、直观、健壮）\n- 标记未解决的占位符（TODO、TKTK、???、`<placeholder>` 等）\n\n#### C. 未充分说明\n\n- 有动词但缺少对象或可测量结果的要求\n- 缺少验收标准对齐的用户故事\n- 引用在规格/计划中未定义的文件或组件的任务\n\n#### D. 宪章对齐\n\n- 任何与 MUST 原则冲突的要求或计划元素\n- 缺少宪章中规定的章节或质量门\n\n#### E. 覆盖差距\n\n- 没有关联任务的要求\n- 没有映射要求/故事的任务\n- 未在任务中体现的非功能要求（例如，性能、安全性）\n\n#### F. 不一致\n\n- 术语漂移（同一概念在不同文件中有不同名称）\n- 计划中引用但在规格中缺失的数据实体（反之亦然）\n- 任务排序矛盾（例如，集成任务在基础设置任务之前但没有依赖注释）\n- 冲突的要求（例如，一个要求 Next.js 而另一个指定 Vue）\n\n### 5. 严重性分配\n\n使用此启发式方法来优先处理发现：\n\n- **关键**：违反宪章 MUST、缺少核心规格工件，或阻塞基本功能的零覆盖要求\n- **高**：重复或冲突的要求、模糊的安全/性能属性、不可测试的验收标准\n- **中**：术语漂移、缺少非功能任务覆盖、未充分说明的边缘情况\n- **低**：样式/措辞改进、不影响执行顺序的次要冗余\n\n### 6. 生成紧凑分析报告\n\n输出一个 Markdown 报告（不写入文件）具有以下结构：\n\n## 规格分析报告\n\n| ID   | 类别 | 严重性 | 位置             | 摘要               | 建议                       |\n| ---- | ---- | ------ | ---------------- | ------------------ | -------------------------- |\n| A1   | 重复 | 高     | spec.md:L120-134 | 两个相似的要求 ... | 合并措辞；保留更清晰的版本 |\n\n（每项发现添加一行；生成以类别首字母为前缀的稳定 ID。）\n\n**覆盖摘要表：**\n\n| 要求键 | 有任务？ | 任务 ID | 备注 |\n| ------ | -------- | ------- | ---- |\n\n**宪章对齐问题：**（如果有）\n\n**未映射的任务：**（如果有）\n\n**指标：**\n\n- 总要求\n- 总任务\n- 覆盖率%（有>=1个任务的要求）\n- 歧义计数\n- 重复计数\n- 关键问题计数\n\n### 7. 提供下一步行动\n\n在报告末尾，输出一个简洁的下一步行动块：\n\n- 如果存在关键问题：建议在 `speckit-implement` 之前解决\n- 如果只有低/中等：用户可以继续，但提供改进建议\n- 提供明确的命令建议：例如，\"使用改进运行 `speckit-specify`\"，\"运行 `speckit-plan` 调整架构\"，\"手动编辑 tasks.md 添加 'performance-metrics' 的覆盖\"\n\n### 8. 提供补救措施\n\n询问用户：\"您希望我为前 N 个问题建议具体的补救编辑吗？\"（不要自动应用它们。）\n\n## 操作原则\n\n### 上下文效率\n\n- **最小高信号令牌**：专注于可操作的发现，而不是详尽的文档\n- **渐进式披露**：增量加载工件；不要将所有内容倒入分析\n- **高效令牌输出**：限制发现表为 50 行；总结溢出\n- **确定性结果**：在没有更改的情况下重新运行应产生一致的 ID 和计数\n\n### 分析指南\n\n- **永不修改文件**（这是只读分析）\n- **永不虚构缺失部分**（如果缺失，准确报告）\n- **优先处理宪章违规**（这些总是关键的）\n- **使用示例而非详尽规则**（引用具体实例，而非通用模式）\n- **优雅报告零问题**（发出带有覆盖统计的成功报告）\n\n## 上下文\n\n{ARGS}"
              },
              {
                "name": "speckit-checklist-zh",
                "description": "基于用户需求为当前功能生成定制检查清单的专业工具。专门用于需求质量验证，生成\"英语的单元测试\"，验证需求的完整性、清晰度和一致性。触发词：speckit-checklist、检查清单、需求验证、质量检查、checklist、requirements validation、质量审查、spec review",
                "path": "skills/speckit-checklist-zh/SKILL.md",
                "frontmatter": {
                  "name": "speckit-checklist-zh",
                  "description": "基于用户需求为当前功能生成定制检查清单的专业工具。专门用于需求质量验证，生成\"英语的单元测试\"，验证需求的完整性、清晰度和一致性。触发词：speckit-checklist、检查清单、需求验证、质量检查、checklist、requirements validation、质量审查、spec review"
                },
                "content": "## 检查表目的：\"中文的单元测试\"\n\n**关键概念**：检查表是**要求编写的单元测试** - 它们验证特定领域中要求的质量、清晰度和完整性。\n\n**不用于验证/测试**：\n\n- ❌ 不是\"验证按钮正确点击\"\n- ❌ 不是\"测试错误处理是否有效\"\n- ❌ 不是\"确认 API 返回 200\"\n- ❌ 不是检查代码/实现是否符合规格\n\n**用于要求质量验证**：\n\n- ✅ \"是否为所有卡片类型定义了视觉层次要求？\"（完整性）\n- ✅ \"是否用特定的尺寸/定位量化了'显著显示'？\"（清晰度）\n- ✅ \"所有交互元素的悬停状态要求是否一致？\"（一致性）\n- ✅ \"是否为键盘导航定义了可访问性要求？\"（覆盖范围）\n- ✅ \"规格是否定义了徽标图像加载失败时的情况？\"（边缘情况）\n\n**比喻**：如果您的规格是编写的代码，那么检查表就是它的单元测试套件。您正在测试要求是否编写良好、完整、明确并准备好实施 - 而不是测试实现是否有效。\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 执行步骤\n\nscripts:\n  sh: .specify/scripts/bash/check-prerequisites.sh --json\n  ps: .specify/scripts/powershell/check-prerequisites.ps1 -Json\n\n\n1. **设置**：从仓库根目录运行 `{SCRIPT}` 并解析 JSON 以获取 FEATURE_DIR 和 AVAILABLE_DOCS 列表。\n\n   - 所有文件路径必须是绝对的。\n   - 对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **澄清意图（动态）**：推导出最多三个初始上下文澄清问题（无预设目录）。它们必须：\n\n   - 从用户的措辞 + 从规格/计划/任务中提取的信号生成\n   - 仅询问会实质性改变检查表内容的信息\n   - 如果在 `$ARGUMENTS` 中已经明确，则单独跳过\n   - 优先考虑精确性而非广度\n\n   生成算法：\n\n   1. 提取信号：功能领域关键词（例如，auth, latency, UX, API），风险指标（\"critical\", \"must\", \"compliance\"），利益相关者提示（\"QA\", \"review\", \"security team\"）和明确的交付物（\"a11y\", \"rollback\", \"contracts\"）。\n   2. 将信号聚类到候选关注领域（最多 4 个）按相关性排序。\n   3. 识别可能的受众和时机（作者、审阅者、QA、发布）如果不明确。\n   4. 检测缺失的维度：范围广度、深度/严谨性、风险重点、排除边界、可测量的验收标准。\n   5. 从这些原型中制定问题：\n      - 范围细化（例如，\"这应该包括与 X 和 Y 的集成接触点还是仅限于本地模块正确性？\"）\n      - 风险优先级（例如，\"这些潜在风险领域中哪些应该接受强制门控检查？\"）\n      - 深度校准（例如，\"这是一个轻量级的预提交健全性列表还是正式的发布门？\"）\n      - 受众框架（例如，\"这将仅由作者使用还是在 PR 审阅期间由同行使用？\"）\n      - 边界排除（例如，\"我们应该明确排除本轮的性能调优项目吗？\"）\n      - 场景类别差距（例如，\"未检测到恢复流程——回滚/部分故障路径是否在范围内？\"）\n\n   问题格式规则：\n\n   - 如果提供选项，生成一个紧凑的表格，列：选项 | 候选 | 重要性原因\n   - 限制最多 A-E 个选项；如果自由形式答案更清晰则省略表格\n   - 永远不要要求用户重述他们已经说过的话\n   - 避免推测性类别（无幻觉）。如果不确定，明确询问：\"确认 X 是否在范围内。\"\n\n   无法交互时的默认值：\n\n   - 深度：标准\n   - 受众：如果与代码相关则为审阅者（PR）；否则为作者\n   - 关注：前 2 个相关性聚类\n\n   输出问题（标记 Q1/Q2/Q3）。回答后：如果≥2 个场景类别（替代/异常/恢复/非功能性领域）仍不清楚，您可以要求最多两个更有针对性的后续问题（Q4/Q5），每个问题附带一行理由（例如，\"未解决的恢复路径风险\"）。不要超过五个总问题。如果用户明确拒绝更多问题则跳过升级。\n\n3. **理解用户请求**：结合 `$ARGUMENTS` + 澄清答案：\n\n   - 推导检查表主题（例如，安全、审阅、部署、用户体验）\n   - 整合用户提到的明确必备项目\n   - 将焦点选择映射到类别脚手架\n   - 从规格/计划/任务中推断任何缺失的上下文（不要幻觉）\n\n4. **加载功能上下文**：从 FEATURE_DIR 读取：\n\n   - spec.md：功能要求和范围\n   - plan.md（如果存在）：技术细节、依赖关系\n   - tasks.md（如果存在）：实施任务\n\n   **上下文加载策略**：\n\n   - 仅加载与活跃关注领域相关的必要部分（避免完整文件转储）\n   - 更喜欢将长段落总结为简洁的场景/要求要点\n   - 使用渐进式披露：仅在检测到差距时添加后续检索\n   - 如果源文档很大，生成中间摘要项目而不是嵌入原始文本\n\n5. **生成检查表** - 创建\"要求的单元测试\"：\n\n   - 如果不存在则创建 `FEATURE_DIR/checklists/` 目录\n   - 生成唯一的检查表文件名：\n     - 使用基于领域的简短描述性名称（例如，`ux.md`, `api.md`, `security.md`）\n     - 格式：`[domain].md`\n     - 如果文件存在，则追加到现有文件\n   - 从 CHK001 开始顺序编号项目\n   - 每个 `speckit-checklist` 运行创建一个新文件（从不覆盖现有检查表）\n\n   **核心原则 - 测试要求，而不是实现**：\n   每个检查表项目必须评估要求本身：\n\n   - **完整性**：所有必要的要求是否存在？\n   - **清晰度**：要求是否明确且具体？\n   - **一致性**：要求是否相互对齐？\n   - **可测量性**：要求是否可以客观验证？\n   - **覆盖范围**：是否解决了所有场景/边缘情况？\n\n   **类别结构** - 按要求质量维度分组项目：\n\n   - **要求完整性**（是否记录了所有必要的要求？）\n   - **要求清晰度**（要求是否具体且明确？）\n   - **要求一致性**（要求是否对齐而无冲突？）\n   - **验收标准质量**（成功标准是否可测量？）\n   - **场景覆盖**（是否解决了所有流程/案例？）\n   - **边缘情况覆盖**（是否定义了边界条件？）\n   - **非功能性要求**（性能、安全性、可访问性等 - 是否指定？）\n   - **依赖关系和假设**（是否记录和验证？）\n   - **歧义和冲突**（需要澄清什么？）\n\n   **如何编写检查表项目 - \"英语的单元测试\"**：\n\n   ❌ **错误**（测试实现）：\n\n   - \"验证着陆页显示 3 个剧集卡片\"\n   - \"测试桌面端悬停状态是否有效\"\n   - \"确认徽标点击导航到主页\"\n\n   ✅ **正确**（测试要求质量）：\n\n   - \"是否明确指定了特色剧集的确切数量和布局？\" [完整性]\n   - \"是否用特定的尺寸/定位量化了'显著显示'？\" [清晰度]\n   - \"所有交互元素的悬停状态要求是否一致？\" [一致性]\n   - \"是否为所有交互式 UI 定义了键盘导航要求？\" [覆盖范围]\n   - \"当徽标图像加载失败时是否指定了回退行为？\" [边缘情况]\n   - \"是否为异步剧集数据定义了加载状态？\" [完整性]\n   - \"规格是否定义了竞争 UI 元素的视觉层次？\" [清晰度]\n\n   **项目结构**：\n   每个项目应遵循此模式：\n\n   - 询问要求质量的问题格式\n   - 关注规格/计划中编写（或未编写）的内容\n   - 包括质量维度在括号中 [完整性/清晰度/一致性等]\n   - 检查现有要求时引用规格部分 `[Spec §X.Y]`\n   - 使用 `[Gap]` 标记检查缺失的要求\n\n   **按质量维度的示例**：\n\n   完整性：\n\n   - \"是否为所有 API 故障模式定义了错误处理要求？ [Gap]\"\n   - \"是否为所有交互元素指定了可访问性要求？ [完整性]\"\n   - \"是否为响应式布局定义了移动断点要求？ [Gap]\"\n\n   清晰度：\n\n   - \"是否用特定的时间阈值量化了'快速加载'？ [清晰度, Spec §NFR-2]\"\n   - \"是否明确定义了'相关剧集'的选择标准？ [清晰度, Spec §FR-5]\"\n   - \"是否用可测量的视觉属性定义了'显著'？ [歧义, Spec §FR-4]\"\n\n   一致性：\n\n   - \"所有页面的导航要求是否对齐？ [一致性, Spec §FR-10]\"\n   - \"着陆页和详情页的卡片组件要求是否一致？ [一致性]\"\n\n   覆盖范围：\n\n   - \"是否为零状态场景（无剧集）定义了要求？ [覆盖范围, 边缘情况]\"\n   - \"是否解决了并发用户交互场景？ [覆盖范围, Gap]\"\n   - \"是否为部分数据加载失败指定了要求？ [覆盖范围, 异常流程]\"\n\n   可测量性：\n\n   - \"视觉层次要求是否可测量/可测试？ [验收标准, Spec §FR-1]\"\n   - \"是否可以客观验证'平衡的视觉权重'？ [可测量性, Spec §FR-2]\"\n\n   **场景分类和覆盖**（要求质量重点）：\n\n   - 检查是否存在要求：主要、替代、异常/错误、恢复、非功能性场景\n   - 对于每个场景类别，询问：\"[场景类型] 要求是否完整、清晰且一致？\"\n   - 如果场景类别缺失：\"[场景类型] 要求是故意排除还是缺失？ [Gap]\"\n   - 包括状态变更时的弹性/回滚：\"是否为迁移失败定义了回滚要求？ [Gap]\"\n\n   **可追溯性要求**：\n\n   - 最低要求：≥80% 的项目必须至少包含一个可追溯性引用\n   - 每个项目应引用：规格部分 `[Spec §X.Y]`，或使用标记：`[Gap]`、`[Ambiguity]`、`[Conflict]`、`[Assumption]`\n   - 如果不存在 ID 系统：\"是否建立了要求和验收标准 ID 方案？ [可追溯性]\"\n\n   **表面和解决问题**（要求质量问题）：\n   询问有关要求本身的问题：\n\n   - 歧义：\"'快速' 一词是否用具体指标量化？ [歧义, Spec §NFR-1]\"\n   - 冲突：\"§FR-10 和 §FR-10a 中的导航要求是否冲突？ [冲突]\"\n   - 假设：\"'始终可用的播客 API' 假设是否已验证？ [假设]\"\n   - 依赖关系：\"是否记录了外部播客 API 要求？ [依赖关系, Gap]\"\n   - 缺失定义：\"是否用可测量的标准定义了'视觉层次'？ [Gap]\"\n\n   **内容整合**：\n\n   - 软上限：如果原始候选项目 > 40，按风险/影响优先排序\n   - 合并检查相同要求方面的近似重复项\n   - 如果 >5 个低影响边缘情况，创建一个项目：\"边缘情况 X、Y、Z 是否在要求中解决？ [覆盖范围]\"\n\n   **🚫 绝对禁止** - 这些使其成为实现测试，而不是要求测试：\n\n   - ❌ 任何以\"验证\"、\"测试\"、\"确认\"、\"检查\" + 实现行为开头的项目\n   - ❌ 引用代码执行、用户操作、系统行为\n   - ❌ \"正确显示\"、\"正常工作\"、\"按预期功能\"\n   - ❌ \"点击\"、\"导航\"、\"渲染\"、\"加载\"、\"执行\"\n   - ❌ 测试用例、测试计划、QA 程序\n   - ❌ 实现细节（框架、API、算法）\n\n   **✅ 必需模式** - 这些测试要求质量：\n\n   - ✅ \"是否为 [场景] 定义/指定/记录了 [要求类型]？\"\n   - ✅ \"是否用具体标准量化/澄清了 [模糊术语]？\"\n   - ✅ \"[部分 A] 和 [部分 B] 的要求是否一致？\"\n   - ✅ \"是否可以客观测量/验证 [要求]？\"\n   - ✅ \"要求中是否解决了 [边缘情况/场景]？\"\n   - ✅ \"规格是否定义了 [缺失方面]？\"\n\n6. **结构参考**：按照 `.specify/templates/checklist-template.md` 中的规范模板生成检查表，包括标题、元部分、类别标题和 ID 格式。如果模板不可用，使用：H1 标题、目的/创建的元行、包含 `- [ ] CHK### <要求项目>` 行的 `##` 类别部分，全局递增 ID 从 CHK001 开始。\n\n7. **报告**：输出创建的检查表的完整路径、项目计数，并提醒用户每次运行都会创建一个新文件。总结：\n\n   - 选择的关注领域\n   - 深度级别\n   - 参与者/时机\n   - 任何包含的用户明确指定的必备项目\n\n**重要**：每个 `speckit-checklist` 命令调用都使用简短的描述性名称创建检查表文件，除非文件已存在。这允许：\n\n- 不同类型的多个检查表（例如，`ux.md`, `test.md`, `security.md`）\n- 简单、易记的文件名，指示检查表目的\n- 在 `checklists/` 文件夹中轻松识别和导航\n\n为避免混乱，使用描述性类型并在完成后清理过时的检查表。\n\n## 示例检查表类型和示例项目\n\n**用户体验要求质量：** `ux.md`\n\n示例项目（测试要求，而不是实现）：\n\n- \"是否用可测量的标准定义了视觉层次要求？ [清晰度, Spec §FR-1]\"\n- \"是否明确定义了 UI 元素的数量和定位？ [完整性, Spec §FR-1]\"\n- \"交互状态要求（悬停、焦点、活动）是否一致定义？ [一致性]\"\n- \"是否为所有交互元素指定了可访问性要求？ [覆盖范围, Gap]\"\n- \"图像加载失败时是否定义了回退行为？ [边缘情况, Gap]\"\n- \"是否可以客观测量'显著显示'？ [可测量性, Spec §FR-4]\"\n\n**API 要求质量：** `api.md`\n\n示例项目：\n\n- \"是否为所有故障场景指定了错误响应格式？ [完整性]\"\n- \"是否用具体阈值量化了速率限制要求？ [清晰度]\"\n- \"所有端点的身份验证要求是否一致？ [一致性]\"\n- \"是否为外部依赖关系定义了重试/超时要求？ [覆盖范围, Gap]\"\n- \"版本控制策略是否在要求中记录？ [Gap]\"\n\n**性能要求质量：** `performance.md`\n\n示例项目：\n\n- \"是否用具体指标量化了性能要求？ [清晰度]\"\n- \"是否为所有关键用户旅程定义了性能目标？ [覆盖范围]\"\n- \"是否为不同负载条件指定了性能要求？ [完整性]\"\n- \"是否可以客观测量性能要求？ [可测量性]\"\n- \"是否为高负载场景定义了降级要求？ [边缘情况, Gap]\"\n\n**安全要求质量：** `security.md`\n\n示例项目：\n\n- \"是否为所有受保护资源指定了身份验证要求？ [覆盖范围]\"\n- \"是否为敏感信息定义了数据保护要求？ [完整性]\"\n- \"威胁模型是否记录并与要求对齐？ [可追溯性]\"\n- \"安全要求是否与合规义务一致？ [一致性]\"\n- \"是否定义了安全故障/违规响应要求？ [Gap, 异常流程]\"\n\n## 反例：不要做的事情\n\n**❌ 错误 - 这些测试实现，而不是要求：**\n\n```markdown\n- [ ] CHK001 - 验证着陆页显示 3 个剧集卡片 [Spec §FR-001]\n- [ ] CHK002 - 测试桌面端悬停状态是否正确工作 [Spec §FR-003]\n- [ ] CHK003 - 确认徽标点击导航到主页 [Spec §FR-010]\n- [ ] CHK004 - 检查相关剧集部分显示 3-5 个项目 [Spec §FR-005]\n```\n\n**✅ 正确 - 这些测试要求质量：**\n\n```markdown\n- [ ] CHK001 - 是否明确定义了特色剧集的数量和布局？ [完整性, Spec §FR-001]\n- [ ] CHK002 - 是否为所有交互元素一致定义了悬停状态要求？ [一致性, Spec §FR-003]\n- [ ] CHK003 - 是否为所有可点击品牌元素明确了导航要求？ [清晰度, Spec §FR-010]\n- [ ] CHK004 - 是否记录了相关剧集的选择标准？ [Gap, Spec §FR-005]\n- [ ] CHK005 - 是否为异步剧集数据定义了加载状态要求？ [Gap]\n- [ ] CHK006 - 是否可以客观测量\"视觉层次\"要求？ [可测量性, Spec §FR-001]\n```\n\n**主要区别：**\n\n- 错误：测试系统是否正常工作\n- 正确：测试要求是否编写正确\n- 错误：行为验证\n- 正确：要求质量验证\n- 错误：\"它是否做 X？\"\n- 正确：\"X 是否明确定义？\""
              },
              {
                "name": "speckit-clarify-zh",
                "description": "通过提出最多5个高度针对性的澄清问题来识别当前功能规范中未明确定义的领域，并将答案编码回规范中。触发词包括：\"speckit-clarify\"、\"speckit澄清\"、\"规范澄清\"、\"功能澄清\"、\"识别模糊点\"、\"澄清需求\"。",
                "path": "skills/speckit-clarify-zh/SKILL.md",
                "frontmatter": {
                  "name": "speckit-clarify-zh",
                  "description": "通过提出最多5个高度针对性的澄清问题来识别当前功能规范中未明确定义的领域，并将答案编码回规范中。触发词包括：\"speckit-clarify\"、\"speckit澄清\"、\"规范澄清\"、\"功能澄清\"、\"识别模糊点\"、\"澄清需求\"。"
                },
                "content": "## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n目标：检测并减少活动功能规格中的歧义或缺失决策点，并将澄清直接记录在规格文件中。\n\n注意：此澄清工作流程预计在调用 `/speckit.plan` 之前运行（并完成）。如果用户明确表示他们正在跳过澄清（例如，探索性刺探），您可以继续，但必须警告下游返工风险会增加。\n\n执行步骤：\n\nscripts:\n   sh: .specify/scripts/bash/check-prerequisites.sh --json --paths-only\n   ps: .specify/scripts/powershell/check-prerequisites.ps1 -Json -PathsOnly\n\n1. 从仓库根目录运行一次 `{SCRIPT}`（组合 `--json --paths-only` 模式 / `-Json -PathsOnly`）。解析最小 JSON 负载字段：\n\n   - `FEATURE_DIR`\n   - `FEATURE_SPEC`\n   - （可选捕获 `IMPL_PLAN`, `TASKS` 用于未来的链式流程。）\n   - 如果 JSON 解析失败，则中止并指示用户重新运行 `speckit-specify` 或验证功能分支环境。\n   - 对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. 加载当前规格文件。使用此分类法执行结构化歧义和覆盖扫描。对于每个类别，标记状态：清晰 / 部分 / 缺失。生成用于优先级排序的内部覆盖图（除非不问问题，否则不要输出原始图）。\n\n   功能范围和行为：\n\n   - 核心用户目标和成功标准\n   - 明确的范围外声明\n   - 用户角色 / 人物区分\n\n   领域和数据模型：\n\n   - 实体、属性、关系\n   - 身份和唯一性规则\n   - 生命周期/状态转换\n   - 数据量 / 规模假设\n\n   交互和用户体验流程：\n\n   - 关键用户旅程 / 序列\n   - 错误/空/加载状态\n   - 可访问性或本地化注释\n\n   非功能性质量属性：\n\n   - 性能（延迟、吞吐量目标）\n   - 可扩展性（水平/垂直、限制）\n   - 可靠性和可用性（正常运行时间、恢复期望）\n   - 可观察性（日志、指标、跟踪信号）\n   - 安全性和隐私（认证/授权、数据保护、威胁假设）\n   - 合规性 / 监管约束（如果有）\n\n   集成和外部依赖：\n\n   - 外部服务/API 和故障模式\n   - 数据导入/导出格式\n   - 协议/版本假设\n\n   边缘情况和故障处理：\n\n   - 负面场景\n   - 速率限制 / 节流\n   - 冲突解决（例如，并发编辑）\n\n   约束和权衡：\n\n   - 技术约束（语言、存储、托管）\n   - 明确的权衡或被拒绝的替代方案\n\n   术语和一致性：\n\n   - 规范术语表\n   - 避免的同义词 / 废弃术语\n\n   完成信号：\n\n   - 验收标准可测试性\n   - 可测量的完成定义风格指标\n\n   杂项 / 占位符：\n\n   - TODO 标记 / 未解决的决策\n   - 缺乏量化的模糊形容词（\"健壮的\"、\"直观的\"）\n\n   对于状态为部分或缺失的每个类别，添加一个候选问题机会，除非：\n\n   - 澄清不会实质性改变实施或验证策略\n   - 信息最好推迟到规划阶段（内部记录）\n\n3. 生成（内部）优先级候选澄清问题队列（最多 5 个）。不要一次性输出所有问题。应用这些约束：\n\n   - 整个会话最多 10 个问题。\n   - 每个问题必须可以通过以下方式回答：\n     - 短的多项选择（2-5 个不同的、互斥的选项），或\n     - 一个单词 / 短语答案（明确约束：\"答案 <=5 个单词\"）。\n   - 仅包括其答案实质性影响架构、数据建模、任务分解、测试设计、用户体验行为、运营准备或合规性验证的问题。\n   - 确保类别覆盖平衡：尝试首先覆盖最高影响的未解决类别；避免在单个高影响领域（例如，安全态势）未解决时问两个低影响问题。\n   - 排除已经回答的问题、琐碎的风格偏好或计划级执行细节（除非阻塞正确性）。\n   - 优先考虑减少下游返工风险或防止不一致验收测试的澄清。\n   - 如果超过 5 个类别仍未解决，按（影响 * 不确定性）启发式选择前 5 个。\n\n4. 顺序提问循环（交互式）：\n\n   - 一次只提出一个问题。\n\n   - 对于多项选择问题：\n\n     - **分析所有选项**并根据以下确定**最合适的选项**：\n       - 项目类型的最佳实践\n       - 类似实现中的常见模式\n       - 风险降低（安全性、性能、可维护性）\n       - 与规格中可见的任何明确项目目标或约束对齐\n     - 突出显示您的**推荐选项**在顶部，并提供明确的理由（1-2 句解释为什么这是最佳选择）。\n     - 格式为：`**推荐：** 选项 [X] - <理由>`\n     - 然后将所有选项呈现为 Markdown 表格：\n\n     | 选项 | 描述                                                         |\n     | ---- | ------------------------------------------------------------ |\n     | A    | <选项 A 描述>                                                |\n     | B    | <选项 B 描述>                                                |\n     | C    | <选项 C 描述>（根据需要添加 D/E 至多 5 个）                  |\n     | 简短 | 提供不同的简短答案（<=5 个单词）（仅在自由形式替代方案适当时包含） |\n\n     - 表格后添加：`您可以回复选项字母（例如，\"A\"），通过说\"yes\"或\"recommended\"接受推荐，或提供您自己的简短答案。`\n\n   - 对于简短答案风格（无有意义的离散选项）：\n\n     - 提供您的**建议答案**基于最佳实践和上下文。\n     - 格式为：`**建议：** <您的建议答案> - <简要理由>`\n     - 然后输出：`格式：简短答案（<=5 个单词）。您可以通过说\"yes\"或\"suggested\"接受建议，或提供您自己的答案。`\n\n   - 用户回答后：\n\n     - 如果用户回复\"yes\"、\"recommended\"或\"suggested\"，使用您之前声明的推荐/建议作为答案。\n     - 否则，验证答案映射到一个选项或符合 <=5 个单词的约束。\n     - 如果模糊，要求快速澄清（计数仍属于同一问题；不要前进）。\n     - 一旦满意，将其记录在工作内存中（尚不写入磁盘）并移至下一个排队问题。\n\n   - 停止进一步提问当：\n\n     - 所有关键歧义提前解决（剩余排队项目变得不必要），或\n     - 用户发出完成信号（\"done\"、\"good\"、\"no more\"），或\n     - 您达到 5 个已问问题。\n\n   - 永远不要提前透露未来排队的问题。\n\n   - 如果开始时没有有效问题，立即报告没有关键歧义。\n\n5. 每个接受答案后的集成（增量更新方法）：\n\n   - 维护规格的内存表示（启动时加载一次）加上原始文件内容。\n   - 对于此会话中的第一个集成答案：\n     - 确保存在 `## Clarifications` 部分（如果缺失，则在规格模板中最高级上下文/概述部分之后创建）。\n     - 在其下创建（如果不存在）一个 `### Session YYYY-MM-DD` 子标题用于今天。\n   - 接受后立即追加一个项目符号行：`- Q: <问题> → A: <最终答案>`。\n   - 然后立即将澄清应用到最合适的部分：\n     - 功能歧义 → 更新或在功能要求中添加项目符号。\n     - 用户交互 / 行为者区分 → 更新用户故事或行为者子部分（如果存在）与澄清的角色、约束或场景。\n     - 数据形状 / 实体 → 更新数据模型（添加字段、类型、关系）保持排序；简洁地记录添加的约束。\n     - 非功能性约束 → 在非功能性 / 质量属性部分添加/修改可测量标准（将模糊形容词转换为指标或明确目标）。\n     - 边缘情况 / 负面流程 → 在边缘情况 / 错误处理下添加新项目符号（或创建此类子部分如果模板提供占位符）。\n     - 术语冲突 → 规范化整个规格中的术语；仅在必要时保留原始术语，添加`(以前称为\"X\")`一次。\n   - 如果澄清使早期模糊声明无效，则替换该声明而不是重复；不留过时的矛盾文本。\n   - 每次集成后保存规格文件以最小化上下文丢失风险（原子覆盖）。\n   - 保持格式：不要重新排序无关部分；保持标题层次结构完整。\n   - 保持每个插入的澄清最小且可测试（避免叙述性漂移）。\n\n6. 验证（每次写入后执行加上最终通过）：\n\n   - 澄清会话包含每个接受答案的一个项目符号（无重复）。\n   - 总问（接受）问题 ≤ 5。\n   - 更新部分不包含新的答案应该解决的模糊占位符。\n   - 无矛盾的早期声明保留（扫描移除的无效替代选择）。\n   - Markdown 结构有效；仅允许新标题：`## Clarifications`, `### Session YYYY-MM-DD`。\n   - 术语一致性：所有更新部分使用相同的规范术语。\n\n7. 将更新的规格写回 `FEATURE_SPEC`。\n\n8. 报告完成（提问循环结束或提前终止后）：\n\n   - 问和回答的问题数量。\n   - 更新规格的路径。\n   - 触及的部分（列出名称）。\n   - 覆盖摘要表列出每个分类类别，状态：已解决（之前部分/缺失并已解决）、推迟（超出问题配额或更适合规划）、清晰（已足够）、未解决（仍部分/缺失但影响低）。\n   - 如果有任何未解决或推迟的，建议是否继续到 `speckit-plan` 或稍后再次运行 `speckit-clarify`。\n   - 建议的下一个命令。\n\n行为规则：\n\n- 如果未发现有意义的歧义（或所有潜在问题都是低影响的），回应：\"未检测到值得正式澄清的关键歧义。\"并建议继续。\n- 如果规格文件缺失，指示用户先运行 `speckit-specify`（不要在此处创建新规格）。\n- 永远不要超过 5 个总问问题（澄清重试单个问题不计入新问题）。\n- 避免推测性技术栈问题，除非缺失会阻塞功能清晰度。\n- 尊重用户提前终止信号（\"stop\"、\"done\"、\"proceed\"）。\n- 如果由于完全覆盖而未问问题，输出紧凑的覆盖摘要（所有类别清晰）然后建议前进。\n- 如果配额达到但仍有未解决的高影响类别，明确标记它们为推迟并附上理由。\n\n优先级上下文：{ARGS}"
              },
              {
                "name": "speckit-constitution-zh",
                "description": "从交互式或提供的原则输入创建或更新项目章程，确保所有依赖模板保持同步。用于项目管理、规范制定、章程维护和团队协作场景。触发词包括 \"speckit章程\"、\"创建章程\"、\"更新章程\"、\"项目章程\"、\"制定规范\"、\"团队章程\"。",
                "path": "skills/speckit-constitution-zh/SKILL.md",
                "frontmatter": {
                  "name": "speckit-constitution-zh",
                  "description": "从交互式或提供的原则输入创建或更新项目章程，确保所有依赖模板保持同步。用于项目管理、规范制定、章程维护和团队协作场景。触发词包括 \"speckit章程\"、\"创建章程\"、\"更新章程\"、\"项目章程\"、\"制定规范\"、\"团队章程\"。"
                },
                "content": "## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n在继续之前，您**必须**考虑用户输入（如果不为空）。\n\n## 大纲\n\n您正在更新位于 `.specify/memory/constitution.md` 的项目章程。此文件源自一个模板[assets/constitution-template.md](assets/constitution-template.md)，包含方括号中的占位符令牌（例如 `[项目名称]`、`[原则_1_名称]`）。您的工作是：(a) 收集/推导具体值，(b) 精确填充模板，以及 (c) 在依赖工件中传播任何修订。\n\n遵循此执行流程：\n\n1. 将 `assets/specify/` 所有文件（包括子目录）按原目录结构复制到仓库根目录下的`.specify` 目录，跳过已有文件，**不能覆盖原有同名文件**。cp命令的 -n（--no-clobber）选项可以防止覆盖已存在的文件。\n在此阶段，您的项目文件夹内容应类似于以下内容：\n\n```text\n仓库根目录\n└── .specify\n    ├── memory\n    │  └── constitution.md\n    ├── scripts\n    │  ├──bash    \n    │  │  ├── check-prerequisites.sh\n    │  │  ├── common.sh\n    │  │  ├── create-new-feature.sh\n    │  │  ├── setup-plan.sh\n    │  │  └── update-claude-md.sh\n    │  ├──powershell    \n    │  │  ├── check-prerequisites.ps1\n    │  │  ├── common.ps1\n    │  │  ├── create-new-feature.ps1\n    │  │  ├── setup-plan.ps1\n    │  │  └── update-claude-md.ps1    \n    ├── specs\n    │  └── 001-create-taskify\n    │      └── spec.md\n    └── templates\n        ├── plan-template.md\n        ├── spec-template.md\n        └── tasks-template.md\n```\n\n\n2. 加载位于相对仓库根目录 `.specify/memory/constitution.md` 的现有章程模板。\n   - 识别形式为 `[ALL_CAPS_IDENTIFIER]` 的每个占位符令牌。\n     **重要**：用户可能需要比模板中使用的更少或更多的原则。如果指定了数量，请遵守该数量 - 遵循通用模板。您将相应地更新文档。\n\n3. 收集/推导占位符的值：\n   - 如果用户输入（对话）提供了值，则使用它。\n   - 否则从现有仓库上下文推断（README、文档、嵌入的先前章程版本）。\n   - 对于治理日期：`批准日期` 是原始采用日期（如果未知则询问或标记 TODO），如果有更改则 `最后修订日期` 是今天，否则保持之前的日期。\n   - `章程版本` 必须根据语义版本规则递增：\n     - 主版本：向后不兼容的治理/原则删除或重新定义。\n     - 次版本：添加新原则/章节或实质性扩展指导。\n     - 补丁：澄清、措辞、拼写错误修复、非语义性优化。\n   - 如果版本升级类型不明确，在最终确定前提出理由。\n\n4. 起草更新的章程内容：\n   - 用具体文本替换每个占位符（除了项目选择尚未定义而有意保留的模板槽位——明确说明任何剩余的占位符）。\n   - 保留标题层次结构，一旦替换可以移除注释，除非它们仍然提供澄清指导。\n   - 确保每个原则部分：简洁的名称行，段落（或项目符号列表）捕捉不可协商的规则，如果不是显而易见则提供明确的理由。\n   - 确保治理部分列出修订程序、版本策略和合规审查期望。\n\n5. 一致性传播检查清单（将先前检查清单转换为积极验证）：\n   - 读取 `.specify/templates/plan-template.md` 并确保任何\"章程检查\"或规则与更新的原则一致。\n   - 读取 `.specify/templates/spec-template.md` 以对齐范围/要求——如果章程添加/删除强制性章节或约束则更新。\n   - 读取 `.specify/templates/tasks-template.md` 并确保任务分类反映新增或删除的原则驱动任务类型（例如，可观察性、版本控制、测试纪律）。\n   - 读取任何运行时指导文档（例如 `README.md`、`docs/quickstart.md` 或存在的特定代理指导文件）。更新对已更改原则的引用。\n\n6. 生成同步影响报告（在更新后作为 HTML 注释预置在章程文件顶部）：\n   - 版本变更：旧 → 新\n   - 修改的原则列表（旧标题 → 新标题如果重命名）\n   - 新增章节\n   - 删除章节\n   - 需要更新的模板（✅ 已更新 / ⚠ 待处理）及文件路径\n   - 如果有任何占位符被故意推迟，则列出后续待办事项。\n\n7. 最终输出前的验证：\n   - 没有剩余未解释的括号令牌。\n   - 版本行与报告匹配。\n   - 日期为 ISO 格式 YYYY-MM-DD。\n   - 原则是陈述性的、可测试的，并且没有模糊语言（\"应该\" → 在适当地方替换为 MUST/SHOULD 理由）。\n\n8. 将完成的章程写回到 `.specify/memory/constitution.md`（覆盖）。\n\n9.  向用户输出最终摘要：\n   - 新版本和升级理由。\n   - 任何标记为手动跟进的文件。\n   - 建议的提交消息（例如，`docs: 修订章程至 vX.Y.Z（原则添加 + 治理更新）`）。\n\n格式化和样式要求：\n\n- 完全按照模板中的 Markdown 标题使用（不要降级/升级级别）。\n- 包装长理由行以保持可读性（理想情况下 <100 个字符），但不要用生硬的断行强制执行。\n- 在章节之间保持单个空行。\n- 避免尾随空白。\n\n如果用户提供部分更新（例如，仅修订一个原则），仍需执行验证和版本决策步骤。\n\n如果关键信息缺失（例如，批准日期确实未知），插入 `TODO(<FIELD_NAME>): explanation` 并在同步影响报告的延期项目下包含。\n\n不要创建新模板；始终在现有的 `.specify/memory/constitution.md` 文件上操作。"
              },
              {
                "name": "speckit-implement-zh",
                "description": "通过测试与验证为先的方式，按序执行并实现已批准的规范提案。用于实施变更、应用提案、执行规范任务或按已批准计划构建。触发词包括 \"speckit-implement\", \"speckit开发\", \"开发\", \"实施\" \"实现提案\", \"应用变更\", \"执行规范\", \"按顺序完成任务\", \"构建功能\", \"开始实施\"。",
                "path": "skills/speckit-implement-zh/SKILL.md",
                "frontmatter": {
                  "name": "speckit-implement-zh",
                  "description": "通过测试与验证为先的方式，按序执行并实现已批准的规范提案。用于实施变更、应用提案、执行规范任务或按已批准计划构建。触发词包括 \"speckit-implement\", \"speckit开发\", \"开发\", \"实施\" \"实现提案\", \"应用变更\", \"执行规范\", \"按顺序完成任务\", \"构建功能\", \"开始实施\"。"
                },
                "content": "## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n          \nscripts:\n  sh: .specify/scripts/bash/check-prerequisites.sh --json\n  ps: .specify/scripts/powershell/check-prerequisites.ps1 -Json\n\n1. 从仓库根目录运行 `{SCRIPT}` 并解析 FEATURE_DIR 和 AVAILABLE_DOCS 列表。所有路径必须是绝对的。对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **检查检查表状态**（如果 FEATURE_DIR/checklists/ 存在）：\n\n   - 扫描 checklists/ 目录中的所有检查表文件\n\n   - 对于每个检查表，计数：\n\n     - 总项目：所有匹配 `- [ ]` 或 `- [X]` 或 `- [x]` 的行\n     - 完成项目：匹配 `- [X]` 或 `- [x]` 的行\n     - 未完成项目：匹配 `- [ ]` 的行\n\n   - 创建状态表：\n\n     ```text\n     | 检查表 | 总计 | 已完成 | 未完成 | 状态 |\n     |-----------|-------|-----------|------------|--------|\n     | ux.md     | 12    | 12        | 0          | ✓ 通过 |\n     | test.md   | 8     | 5         | 3          | ✗ 失败 |\n     | security.md | 6   | 6         | 0          | ✓ 通过 |\n     ```\n\n   - 计算总体状态：\n\n     - **通过**：所有检查表都有 0 个未完成项目\n     - **失败**：一个或多个检查表有未完成项目\n\n   - **如果有任何检查表未完成**：\n\n     - 显示包含未完成项目计数的表格\n     - **停止**并询问：\"一些检查表未完成。您是否仍要继续执行实现？(yes/no)\"\n     - 等待用户响应后再继续\n     - 如果用户说\"no\"或\"wait\"或\"stop\"，则停止执行\n     - 如果用户说\"yes\"或\"proceed\"或\"continue\"，则继续到步骤 3\n\n   - **如果所有检查表都完成**：\n\n     - 显示表格显示所有检查表已通过\n     - 自动继续到步骤 3\n\n3. 加载和分析实现上下文：\n\n   - **必需**：读取 tasks.md 以获取完整的任务列表和执行计划\n   - **必需**：读取 plan.md 以获取技术栈、架构和文件结构\n   - **如果存在**：读取 data-model.md 以获取实体和关系\n   - **如果存在**：读取 contracts/ 以获取 API 规范和测试要求\n   - **如果存在**：读取 research.md 以获取技术决策和约束\n   - **如果存在**：读取 quickstart.md 以获取集成场景\n\n4. **项目设置验证**：\n\n   - **必需**：根据实际项目设置创建/验证忽略文件：\n\n   **检测和创建逻辑**：\n\n   - 检查以下命令是否成功以确定仓库是否为 git 仓库（如果是则创建/验证 .gitignore）：\n\n     ```sh\n     git rev-parse --git-dir 2>/dev/null\n     ```\n\n   - 检查是否存在 Dockerfile* 或 Docker 在 plan.md 中 → 创建/验证 .dockerignore\n\n   - 检查是否存在 .eslintrc* 或 eslint.config.* → 创建/验证 .eslintignore\n\n   - 检查是否存在 .prettierrc* → 创建/验证 .prettierignore\n\n   - 检查是否存在 .npmrc 或 package.json → 创建/验证 .npmignore（如果发布）\n\n   - 检查是否存在 terraform 文件 (*.tf) → 创建/验证 .terraformignore\n\n   - 检查是否需要 .helmignore（存在 helm 图表）→ 创建/验证 .helmignore\n\n   **如果忽略文件已存在**：验证它包含基本模式，仅追加缺失的关键模式\n   **如果忽略文件缺失**：创建包含检测技术的完整模式集\n\n   **按技术的常见模式**（来自 plan.md 技术栈）：\n\n   - **Node.js/JavaScript/TypeScript**：`node_modules/`, `dist/`, `build/`, `*.log`, `.env*`\n   - **Python**：`__pycache__/`, `*.pyc`, `.venv/`, `venv/`, `dist/`, `*.egg-info/`\n   - **Java**：`target/`, `*.class`, `*.jar`, `.gradle/`, `build/`\n   - **C#/.NET**：`bin/`, `obj/`, `*.user`, `*.suo`, `packages/`\n   - **Go**：`*.exe`, `*.test`, `vendor/`, `*.out`\n   - **Ruby**：`.bundle/`, `log/`, `tmp/`, `*.gem`, `vendor/bundle/`\n   - **PHP**：`vendor/`, `*.log`, `*.cache`, `*.env`\n   - **Rust**：`target/`, `debug/`, `release/`, `*.rs.bk`, `*.rlib`, `*.prof*`, `.idea/`, `*.log`, `.env*`\n   - **Kotlin**：`build/`, `out/`, `.gradle/`, `.idea/`, `*.class`, `*.jar`, `*.iml`, `*.log`, `.env*`\n   - **C++**：`build/`, `bin/`, `obj/`, `out/`, `*.o`, `*.so`, `*.a`, `*.exe`, `*.dll`, `.idea/`, `*.log`, `.env*`\n   - **C**：`build/`, `bin/`, `obj/`, `out/`, `*.o`, `*.a`, `*.so`, `*.exe`, `Makefile`, `config.log`, `.idea/`, `*.log`, `.env*`\n   - **Swift**：`.build/`, `DerivedData/`, `*.swiftpm/`, `Packages/`\n   - **R**：`.Rproj.user/`, `.Rhistory`, `.RData`, `.Ruserdata`, `*.Rproj`, `packrat/`, `renv/`\n   - **通用**：`.DS_Store`, `Thumbs.db`, `*.tmp`, `*.swp`, `.vscode/`, `.idea/`\n\n   **工具特定模式**：\n\n   - **Docker**：`node_modules/`, `.git/`, `Dockerfile*`, `.dockerignore`, `*.log*`, `.env*`, `coverage/`\n   - **ESLint**：`node_modules/`, `dist/`, `build/`, `coverage/`, `*.min.js`\n   - **Prettier**：`node_modules/`, `dist/`, `build/`, `coverage/`, `package-lock.json`, `yarn.lock`, `pnpm-lock.yaml`\n   - **Terraform**：`.terraform/`, `*.tfstate*`, `*.tfvars`, `.terraform.lock.hcl`\n   - **Kubernetes/k8s**：`*.secret.yaml`, `secrets/`, `.kube/`, `kubeconfig*`, `*.key`, `*.crt`\n\n5. 解析 tasks.md 结构并提取：\n\n   - **任务阶段**：设置、测试、核心、集成、完善\n   - **任务依赖**：顺序与并行执行规则\n   - **任务详情**：ID、描述、文件路径、并行标记 [P]\n   - **执行流程**：顺序和依赖要求\n\n6. 按照任务计划执行实现：\n\n   - **阶段执行**：完成每个阶段后再进入下一个\n   - **尊重依赖**：按顺序运行顺序任务，并行任务 [P] 可以一起运行  \n   - **遵循 TDD 方法**：在相应的实现任务之前执行测试任务\n   - **基于文件的协调**：影响相同文件的任务必须顺序运行\n   - **验证检查点**：在继续之前验证每个阶段的完成情况\n\n7. 实现执行规则：\n\n   - **首先设置**：初始化项目结构、依赖、配置\n   - **测试优先于代码**：如果需要为契约、实体和集成场景编写测试\n   - **核心开发**：实现模型、服务、CLI 命令、端点\n   - **集成工作**：数据库连接、中间件、日志、外部服务\n   - **完善和验证**：单元测试、性能优化、文档\n\n8. 进度跟踪和错误处理：\n\n   - 在每个完成的任务后报告进度\n   - 如果任何非并行任务失败则停止执行\n   - 对于并行任务 [P]，继续执行成功的任务，报告失败的任务\n   - 提供清晰的错误消息和调试上下文\n   - 如果实现无法继续则建议下一步\n   - **重要** 对于完成的任务，确保在任务文件中标记为 [X]。\n\n9. 完成验证：\n\n   - 验证所有必需任务已完成\n   - 检查实现的功能是否与原始规格匹配\n   - 验证测试通过且覆盖率符合要求\n   - 确认实现遵循技术计划\n   - 报告最终状态和已完成工作的摘要\n\n注意：此命令假设 tasks.md 中存在完整的任务分解。如果任务不完整或缺失，建议首先运行 `speckit-tasks` 以重新生成任务列表。"
              },
              {
                "name": "speckit-plan-zh",
                "description": "执行实施规划工作流程，使用计划模板生成设计工件。触发词包括：\"speckit计划\"。",
                "path": "skills/speckit-plan-zh/SKILL.md",
                "frontmatter": {
                  "name": "speckit-plan-zh",
                  "description": "执行实施规划工作流程，使用计划模板生成设计工件。触发词包括：\"speckit计划\"。"
                },
                "content": "## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n在继续之前，您**必须**考虑用户输入（如果不为空）。\n\n## 大纲\n\n1. **设置**: 从仓库根目录运行 `.specify/scripts/powershell/setup-plan.ps1 -Json` 并解析 JSON 以获取 FEATURE_SPEC、IMPL_PLAN、SPECS_DIR、BRANCH。对于参数中的单引号，如 \"I'm Groot\"，请使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **加载上下文**: 读取 FEATURE_SPEC 和 `.specify/memory/constitution.md`。加载 IMPL_PLAN 模板（已复制）。\n\n3. **执行计划工作流程**: 遵循 IMPL_PLAN 模板中的结构来：\n   - 填写技术上下文（将未知项标记为\"需要澄清\"）\n   - 从章程中填写章程检查部分\n   - 评估门禁（如果有未正当化的违规则报错）\n   - 阶段 0: 生成 research.md（解决所有\"需要澄清\"）\n   - 阶段 1: 生成 data-model.md、contracts/、quickstart.md\n   - 阶段 1: 通过运行代理脚本更新代理上下文\n   - 设计后重新评估章程检查\n\n4. **停止并报告**: 命令在阶段 2 规划后结束。报告分支、IMPL_PLAN 路径和生成的工件。\n\n## 阶段\n\n### 阶段 0: 大纲与研究\n\n1. **从上述技术上下文中提取未知项**:\n\n   - 对于每个\"需要澄清\" → 研究任务\n   - 对于每个依赖项 → 最佳实践任务\n   - 对于每个集成 → 模式任务\n\n2. **生成并分发研究代理**:\n\n   ```text\n   对于技术上下文中的每个未知项:\n     任务: \"研究 {未知项} 用于 {功能上下文}\"\n   对于每个技术选择:\n     任务: \"查找 {技术} 在 {领域} 中的最佳实践\"\n   ```\n\n3. **在 `research.md` 中整合发现结果**，使用格式:\n\n   - 决策: [选择了什么]\n   - 理由: [为什么选择]\n   - 考虑的替代方案: [还评估了什么]\n\n**输出**: 解决了所有\"需要澄清\"的 research.md\n\n### 阶段 1: 设计与契约\n\n**前提条件:** `research.md` 完成\n\n1. **从功能规格中提取实体** → `data-model.md`:\n   - 实体名称、字段、关系\n   - 来自需求的验证规则\n   - 如适用的状态转换\n\n2. **从功能需求生成 API 契约**:\n   - 对于每个用户操作 → 端点\n   - 使用标准的 REST/GraphQL 模式\n   - 将 OpenAPI/GraphQL 模式输出到 `/contracts/`\n\n3. **代理上下文更新**:\n   - 运行 `.specify/scripts/powershell/update-agent-context.ps1 -AgentType claude`\n   - 这些脚本检测正在使用的 AI 代理\n   - 更新相应的代理特定上下文文件\n   - 仅添加当前计划中的新技术\n   - 保留标记之间的手动添加内容\n\n**输出**: data-model.md、/contracts/*、quickstart.md、代理特定文件\n\n## 关键规则\n\n- 使用绝对路径\n- 如果检查点失败或存在未解决的澄清项，则报 ERROR"
              },
              {
                "name": "speckit-specify-zh",
                "description": "中文功能规范创建工具，用于将自然语言功能描述转换为结构化的功能规范文档。支持自动生成分支名称、创建Git分支、初始化规范文件和质量验证。触发词包括：\"speckit规范\"、\"功能规范\"、\"创建规范\"、\"功能描述转换\"、\"speckit-specify\"。当用户需要将功能想法转换为结构化规范时使用此技能。",
                "path": "skills/speckit-specify-zh/SKILL.md",
                "frontmatter": {
                  "name": "speckit-specify-zh",
                  "description": "中文功能规范创建工具，用于将自然语言功能描述转换为结构化的功能规范文档。支持自动生成分支名称、创建Git分支、初始化规范文件和质量验证。触发词包括：\"speckit规范\"、\"功能规范\"、\"创建规范\"、\"功能描述转换\"、\"speckit-specify\"。当用户需要将功能想法转换为结构化规范时使用此技能。"
                },
                "content": "## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n在继续之前，您**必须**考虑用户输入（如果非空）。\n\n## 大纲\n\n触发消息中用户在触发词后键入的文本**就是**功能描述。假设在此对话中始终可以使用该功能描述，即 `$ARGUMENTS`。除非用户提供了一个空命令，否则不要要求用户重复。\n\n根据该功能描述，请执行以下操作：\n\n1. 将 `assets/specify/` 所有文件（包括子目录）按原目录结构复制到仓库根目录下的`.specify` 目录，跳过已有文件，**不能覆盖原有同名文件**。cp命令的 -n（--no-clobber）选项可以防止覆盖已存在的文件。\n在此阶段，您的项目文件夹内容应类似于以下内容：\n\n```text\n仓库根目录\n└── .specify\n    ├── memory\n    │  └── constitution.md\n    ├── scripts\n    │  ├──bash    \n    │  │  ├── check-prerequisites.sh\n    │  │  ├── common.sh\n    │  │  ├── create-new-feature.sh\n    │  │  ├── setup-plan.sh\n    │  │  └── update-claude-md.sh\n    │  ├──powershell    \n    │  │  ├── check-prerequisites.ps1\n    │  │  ├── common.ps1\n    │  │  ├── create-new-feature.ps1\n    │  │  ├── setup-plan.ps1\n    │  │  └── update-claude-md.ps1    \n    ├── specs\n    │  └── 001-create-taskify\n    │      └── spec.md\n    └── templates\n        ├── plan-template.md\n        ├── spec-template.md\n        └── tasks-template.md\n```\n\n\n2. **生成一个简洁的短名称**（2-4个词）用于分支：\n\n   - 分析功能描述并提取最有意义的关键词\n   - 创建一个2-4个词的短名称，捕捉功能的本质\n   - 尽可能使用动词-名词格式（例如：\"add-user-auth\"、\"fix-payment-bug\"）\n   - 保留技术术语和缩写（OAuth2、API、JWT等）\n   - 保持简洁但足够描述性，以便一目了然地理解功能\n   - 示例：\n     - \"我想添加用户认证\" → \"user-auth\"\n     - \"为API实现OAuth2集成\" → \"oauth2-api-integration\"\n     - \"创建分析仪表板\" → \"analytics-dashboard\"\n     - \"修复支付处理超时错误\" → \"fix-payment-timeout\"\n\n3. **在创建新分支前检查现有分支**：\n\n   a. 首先获取所有远程分支以确保拥有最新信息：\n\n      ```bash\n   git fetch --all --prune\n      ```\n\n   b. 查找短名称在所有来源中的最高功能编号：\n\n      - 远程分支：`git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`\n      - 本地分支：`git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`\n      - 规范目录：检查匹配 `specs/[0-9]+-<short-name>` 的目录\n\n   c. 确定下一个可用编号：\n\n      - 提取所有三个来源的所有数字\n      - 找到最大数字N\n      - 对于新分支使用N+1\n\n   d. 使用计算出的编号和短名称运行脚本 `create-new-feature.ps1 -Json \"$ARGUMENTS\"`：\n\n      - 传递 `--number N+1` 和 `--short-name \"your-short-name\"` 以及功能描述\n      - Bash示例：`create-new-feature.sh -Json \"$ARGUMENTS\" --json --number 5 --short-name \"user-auth\" \"添加用户认证\"`\n      - PowerShell示例：`create-new-feature.ps1 -Json \"$ARGUMENTS\" -Json -Number 5 -ShortName \"user-auth\" \"添加用户认证\"`\n\n   **重要**：\n\n   - 检查所有三个来源（远程分支、本地分支、规范目录）以找到最高编号\n   - 只匹配具有确切短名称模式的分支/目录\n   - 如果未找到具有此短名称的现有分支/目录，则从编号1开始\n   - 每个功能只能运行一次此脚本\n   - JSON在终端中作为输出提供 - 始终参考它来获取您正在查找的实际内容\n   - JSON输出将包含BRANCH_NAME和SPEC_FILE路径\n   - 对于参数中的单引号如\"I'm Groot\"，使用转义语法：例如'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）\n\n4. 加载 `.specify/templates/spec-template.md` 以了解必需的部分。\n\n5. 遵循此执行流程：\n\n   1. 解析来自输入的用户描述\n      如果为空：错误\"未提供功能描述\"\n   2. 从描述中提取关键概念\n      识别：参与者、动作、数据、约束\n   3. 对于不清楚的方面：\n      - 基于上下文和行业标准做出有根据的猜测\n      - 仅在以下情况下标记[需要澄清：具体问题]：\n        - 选择显著影响功能范围或用户体验\n        - 存在多种合理解释且有不同的含义\n        - 不存在合理的默认值\n      - **限制：最多总共3个[需要澄清]标记**\n      - 按影响优先排序：范围 > 安全/隐私 > 用户体验 > 技术细节\n   4. 填写用户场景与测试部分\n      如果没有清晰的用户流程：错误\"无法确定用户场景\"\n   5. 生成功能性需求\n      每个需求都必须是可测试的\n      对未指定的详细信息使用合理的默认值（在假设部分记录假设）\n   6. 定义成功标准\n      创建可测量的、技术无关的结果\n      包括定量指标（时间、性能、数量）和定性措施（用户满意度、任务完成度）\n      每个标准必须在没有实现细节的情况下可验证\n   7. 识别关键实体（如果涉及数据）\n   8. 返回：成功（规范已准备好进行规划）\n\n6. 使用模板结构将规范写入SPEC_FILE，用从功能描述（参数）派生的具体细节替换占位符，同时保持部分顺序和标题不变。\n\n7. **规范质量验证**：编写初始规范后，根据质量标准对其进行验证：\n\n   a. **创建规范质量检查清单**：使用检查清单模板结构在 `FEATURE_DIR/checklists/requirements.md` 生成一个检查清单文件，参考：[assets/quality-checklist-template.md](assets/quality-checklist-template.md)\n\n\n   b. **运行验证检查**：针对每个检查清单项目审查规范：\n\n      - 对于每个项目，确定它是通过还是失败\n      - 记录发现的具体问题（引用相关的规范部分）\n\n   c. **处理验证结果**：\n\n      - **如果所有项目都通过**：标记检查清单完成并进入步骤6\n\n      - **如果有项目失败（不包括[需要澄清]）**：\n\n        1. 列出失败的项目和具体问题\n        2. 更新规范以解决每个问题\n        3. 重新运行验证直到所有项目通过（最多3次迭代）\n        4. 如果在3次迭代后仍然失败，在检查清单注释中记录剩余问题并向用户发出警告\n\n      - **如果存在[需要澄清]标记**：\n\n        1. 从规范中提取所有[需要澄清：...]标记\n\n        2. **限制检查**：如果存在超过3个标记，则只保留按范围/安全/用户体验影响最重要的3个，并对其余的做出有根据的猜测\n\n        3. 对于每个需要澄清的问题（最多3个），参考[assets/clarification-template.md](assets/clarification-template.md)向用户呈现选项。\n\n        4. **关键 - 表格格式化**：确保markdown表格正确格式化：\n\n           - 使用一致的间距，管道对齐\n           - 每个单元格应在内容周围留有空格：`| 内容 |` 而不是 `|内容|`\n           - 表头分隔符必须至少有3个破折号：`|--------|`\n           - 测试表格在markdown预览中是否正确渲染\n\n        5. 按顺序编号问题（Q1、Q2、Q3 - 最多总共3个）\n\n        6. 在等待响应之前一起呈现所有问题\n\n        7. 等待用户响应他们对所有问题的选择（例如：\"Q1: A, Q2: 自定义 - [详情], Q3: B\"）\n\n        8. 通过用用户的选定或提供的答案替换每个[需要澄清]标记来更新规范\n\n        9. 在所有澄清解决后重新运行验证\n\n   d. **更新检查清单**：每次验证迭代后，使用当前通过/失败状态更新检查清单文件\n\n8. 报告完成情况，包括分支名称、规范文件路径、检查清单结果以及下一阶段（`speckit-clarify` 或 `speckit-plan`）的准备情况。\n\n**注意**：脚本会创建并检出新分支并在写入前初始化规范文件。\n\n## 通用指南\n\n## 快速指南\n\n- 关注用户需要**什么**以及**为什么**\n- 避免如何实现（无技术栈、API、代码结构）\n- 为业务利益相关者而非开发人员编写\n- 不要创建嵌入规范中的任何检查清单。那将是单独的命令\n\n### 部分要求\n\n- **必填部分**：每个功能都必须完成\n- **可选部分**：仅当与功能相关时才包含\n- 当某个部分不适用时，完全删除它（不要留下\"N/A\"）\n\n### 对于AI生成\n\n从用户提示创建此规范时：\n\n1. **做出有根据的猜测**：使用上下文、行业标准和常见模式填补空白\n2. **记录假设**：在假设部分记录合理的默认值\n3. **限制澄清**：最多3个[需要澄清]标记 - 仅用于那些：\n   - 显著影响功能范围或用户体验的关键决策\n   - 具有多种合理解释且不同含义的情况\n   - 缺乏任何合理默认值的情况\n4. **优先考虑澄清**：范围 > 安全/隐私 > 用户体验 > 技术细节\n5. **像测试人员一样思考**：每个模糊的需求都应该未能通过\"可测试且明确\"的检查清单项\n6. **常见的需要澄清区域**（只有在没有合理默认值时）：\n   - 功能范围和边界（包括/排除特定用例）\n   - 用户类型和权限（如果存在多个冲突的解释可能性）\n   - 安全/合规要求（当法律/财务上重要时）\n\n**合理默认值示例**（不要询问这些）：\n\n- 数据保留：领域内的行业标准实践\n- 性能目标：标准网页/移动应用期望，除非另有规定\n- 错误处理：用户友好的消息和适当的回退\n- 认证方法：标准基于会话或OAuth2的Web应用程序\n- 集成模式：RESTful API，除非另有说明\n\n### 成功标准指南\n\n成功标准必须：\n\n1. **可衡量**：包括具体指标（时间、百分比、计数、比率）\n2. **技术无关**：不提及框架、语言、数据库或工具\n3. **以用户为中心**：从用户/业务角度描述结果，而不是系统内部机制\n4. **可验证**：无需知道实现细节即可测试/验证\n\n**良好示例**：\n\n- \"用户可在3分钟内完成结账\"\n- \"系统支持10,000个并发用户\"\n- \"95%的搜索在1秒内返回结果\"\n- \"任务完成率提高40%\"\n\n**不良示例**（实现导向）：\n\n- \"API响应时间低于200毫秒\"（过于技术性，应使用\"用户立即看到结果\"）\n\n- \"数据库可处理1000 TPS\"（实现细节，应使用面向用户的指标）\n\n- \"React组件高效渲染\"（框架特定）\n\n- \"Redis缓存命中率高于80%\"（技术特定）"
              },
              {
                "name": "speckit-tasks-zh",
                "description": "基于speckit工作流的任务生成技能，用于根据可用设计文档生成可操作的、依赖有序的tasks.md。当需要基于spec.md、plan.md、data-model.md、contracts/等设计文档为功能开发生成详细任务列表时使用此技能。触发词包括\"speckit tasks\"、\"生成任务\"、\"任务规划\"、\"功能任务分解\"、\"创建tasks.md\"等。",
                "path": "skills/speckit-tasks-zh/SKILL.md",
                "frontmatter": {
                  "name": "speckit-tasks-zh",
                  "description": "基于speckit工作流的任务生成技能，用于根据可用设计文档生成可操作的、依赖有序的tasks.md。当需要基于spec.md、plan.md、data-model.md、contracts/等设计文档为功能开发生成详细任务列表时使用此技能。触发词包括\"speckit tasks\"、\"生成任务\"、\"任务规划\"、\"功能任务分解\"、\"创建tasks.md\"等。"
                },
                "content": "## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\nscripts:\n  sh: .specify/scripts/bash/check-prerequisites.sh --json\n  ps: .specify/scripts/powershell/check-prerequisites.ps1 -Json\n\n1. **设置**：从仓库根目录运行 `{SCRIPT}` 并解析 FEATURE_DIR 和 AVAILABLE_DOCS 列表。所有路径必须是绝对的。对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **加载设计文档**：从 FEATURE_DIR 读取：\n   - **必需**：plan.md（技术栈、库、结构），spec.md（带优先级的用户故事）\n   - **可选**：data-model.md（实体），contracts/（API 端点），research.md（决策），quickstart.md（测试场景）\n   - 注意：并非所有项目都有所有文档。根据可用内容生成任务。\n\n3. **执行任务生成工作流程**：\n   - 加载 plan.md 并提取技术栈、库、项目结构\n   - 加载 spec.md 并提取带优先级的用户故事（P1, P2, P3 等）\n   - 如果存在 data-model.md：提取实体并映射到用户故事\n   - 如果存在 contracts/：将端点映射到用户故事\n   - 如果存在 research.md：提取决策用于设置任务\n   - 生成按用户故事组织的任务（参见下面的任务生成规则）\n   - 生成依赖图显示用户故事完成顺序\n   - 为每个用户故事创建并行执行示例\n   - 验证任务完整性（每个用户故事都有所需任务，可独立测试）\n\n4. **生成 tasks.md**：使用 `.specify/templates/tasks-template.md` 作为结构，填充：\n   - 从 plan.md 获取正确的功能名称\n   - 阶段 1：设置任务（项目初始化）\n   - 阶段 2：基础任务（所有用户故事的阻塞先决条件）\n   - 阶段 3+：按 spec.md 中的优先级顺序排列的每个用户故事一个阶段\n   - 每个阶段包括：故事目标、独立测试标准、测试（如果要求）、实现任务\n   - 最终阶段：完善和跨领域关注点\n   - 所有任务必须遵循严格的检查表格式（参见下面的任务生成规则）\n   - 每个任务的明确文件路径\n   - 依赖关系部分显示故事完成顺序\n   - 每个故事的并行执行示例\n   - 实现策略部分（MVP 优先、增量交付）\n\n5. **报告**：输出生成的 tasks.md 路径和摘要：\n   - 总任务数\n   - 每个用户故事的任务数\n   - 识别的并行机会\n   - 每个故事的独立测试标准\n   - 建议的 MVP 范围（通常仅为用户故事 1）\n   - 格式验证：确认所有任务都遵循检查表格式（复选框、ID、标签、文件路径）\n\n为任务生成提供上下文：{ARGS}\n\ntasks.md 应该是立即可执行的 - 每个任务必须足够具体，以便 LLM 可以在没有额外上下文的情况下完成它。\n\n## 任务生成规则\n\n**关键**：任务必须按用户故事组织，以实现独立实现和测试。\n\n**测试是可选的**：仅在功能规格中明确要求或用户要求 TDD 方法时才生成测试任务。\n\n### 检查表格式（必需）\n\n每个任务必须严格遵循此格式：\n\n```text\n- [ ] [任务ID] [P?] [故事?] 带文件路径的描述\n```\n\n**格式组件**：\n\n1. **复选框**：始终以 `- [ ]` 开头（markdown 复选框）\n2. **任务 ID**：按执行顺序的序列号（T001, T002, T003...）\n3. **[P] 标记**：仅当任务可并行化时包含（不同文件，不依赖未完成任务）\n4. **[故事] 标签**：仅用户故事阶段任务必需\n   - 格式：[US1], [US2], [US3], 等（映射到 spec.md 中的用户故事）\n   - 设置阶段：无故事标签\n   - 基础阶段：无故事标签  \n   - 用户故事阶段：必须有故事标签\n   - 完善阶段：无故事标签\n5. **描述**：带确切文件路径的明确操作\n\n**示例**：\n\n- ✅ 正确：`- [ ] T001 根据实现计划创建项目结构`\n- ✅ 正确：`- [ ] T005 [P] 在 src/middleware/auth.py 中实现认证中间件`\n- ✅ 正确：`- [ ] T012 [P] [US1] 在 src/models/user.py 中创建用户模型`\n- ✅ 正确：`- [ ] T014 [US1] 在 src/services/user_service.py 中实现 UserService`\n- ❌ 错误：`- [ ] 创建用户模型`（缺少 ID 和故事标签）\n- ❌ 错误：`T001 [US1] 创建模型`（缺少复选框）\n- ❌ 错误：`- [ ] [US1] 创建用户模型`（缺少任务 ID）\n- ❌ 错误：`- [ ] T001 [US1] 创建模型`（缺少文件路径）\n\n### 任务组织\n\n1. **来自用户故事（spec.md）** - 主要组织：\n   - 每个用户故事（P1, P2, P3...）都有自己的阶段\n   - 将所有相关组件映射到它们的故事：\n     - 该故事需要的模型\n     - 该故事需要的服务\n     - 该故事需要的端点/UI\n     - 如果要求测试：该故事的特定测试\n   - 标记故事依赖关系（大多数故事应该是独立的）\n\n2. **来自契约**：\n   - 将每个契约/端点 → 映射到它服务的用户故事\n   - 如果要求测试：每个契约 → 在该故事阶段实现前的契约测试任务 [P]\n\n3. **来自数据模型**：\n   - 将每个实体映射到需要它的用户故事\n   - 如果实体服务于多个故事：放在最早的故事或设置阶段\n   - 关系 → 在适当的故事阶段中的服务层任务\n\n4. **来自设置/基础设施**：\n   - 共享基础设施 → 设置阶段（阶段 1）\n   - 基础/阻塞任务 → 基础阶段（阶段 2）\n   - 故事特定设置 → 在该故事的阶段内\n\n### 阶段结构\n\n- **阶段 1**：设置（项目初始化）\n- **阶段 2**：基础（阻塞先决条件 - 必须在用户故事前完成）\n- **阶段 3+**：按优先级顺序的用户故事（P1, P2, P3...）\n  - 在每个故事内：测试（如果要求）→ 模型 → 服务 → 端点 → 集成\n  - 每个阶段应该是一个完整的、可独立测试的增量\n- **最终阶段**：完善和跨领域关注点"
              }
            ]
          }
        ]
      }
    }
  ]
}