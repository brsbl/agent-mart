{
  "owner": {
    "id": "runxgalee",
    "display_name": "runxgalee",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/34385911?u=e20d88099203e07f6cdcd6a04447399f1f647029&v=4",
    "url": "https://github.com/runxgalee",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 3,
      "total_commands": 18,
      "total_skills": 2,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "runxgalee/fullstack-dev",
      "url": "https://github.com/runxgalee/fullstack-dev",
      "description": "A curated collection of Claude Code plugins for full-stack development, covering backend, frontend, infrastructure, and general engineering workflows.",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-09T01:03:28Z",
        "created_at": "2025-12-28T00:39:09Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1927
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 109
        },
        {
          "path": "LICENSE",
          "type": "blob",
          "size": 1066
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 6292
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/backend",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/backend/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/backend/agents/backend-architect.md",
          "type": "blob",
          "size": 12863
        },
        {
          "path": "plugins/backend/agents/cicd-specialist.md",
          "type": "blob",
          "size": 8884
        },
        {
          "path": "plugins/backend/agents/cloud-architect.md",
          "type": "blob",
          "size": 14435
        },
        {
          "path": "plugins/backend/agents/data-engineer.md",
          "type": "blob",
          "size": 9572
        },
        {
          "path": "plugins/backend/agents/database-architect.md",
          "type": "blob",
          "size": 10013
        },
        {
          "path": "plugins/backend/agents/go-specialist.md",
          "type": "blob",
          "size": 10995
        },
        {
          "path": "plugins/backend/agents/graphql-architect.md",
          "type": "blob",
          "size": 8682
        },
        {
          "path": "plugins/backend/agents/grpc-specialist.md",
          "type": "blob",
          "size": 13131
        },
        {
          "path": "plugins/backend/agents/k8s-specialist.md",
          "type": "blob",
          "size": 12524
        },
        {
          "path": "plugins/backend/agents/postgres-specialist.md",
          "type": "blob",
          "size": 9179
        },
        {
          "path": "plugins/backend/agents/security-specialist.md",
          "type": "blob",
          "size": 11443
        },
        {
          "path": "plugins/backend/agents/sql-specialist.md",
          "type": "blob",
          "size": 7933
        },
        {
          "path": "plugins/backend/agents/sre-specialist.md",
          "type": "blob",
          "size": 11100
        },
        {
          "path": "plugins/backend/agents/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/backend/agents/templates/specialist-agent-template.md",
          "type": "blob",
          "size": 6718
        },
        {
          "path": "plugins/backend/agents/templates/task-agent-template.md",
          "type": "blob",
          "size": 2941
        },
        {
          "path": "plugins/backend/agents/terraform-specialist.md",
          "type": "blob",
          "size": 12212
        },
        {
          "path": "plugins/development",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/development/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/development/agents/claude-code-architect.md",
          "type": "blob",
          "size": 6440
        },
        {
          "path": "plugins/development/agents/code-reviewer.md",
          "type": "blob",
          "size": 10051
        },
        {
          "path": "plugins/development/agents/codebase-analyzer.md",
          "type": "blob",
          "size": 7565
        },
        {
          "path": "plugins/development/agents/context-orchestrator.md",
          "type": "blob",
          "size": 9945
        },
        {
          "path": "plugins/development/agents/debug-specialist.md",
          "type": "blob",
          "size": 9077
        },
        {
          "path": "plugins/development/agents/documentation-architect.md",
          "type": "blob",
          "size": 13601
        },
        {
          "path": "plugins/development/agents/project-analyzer.md",
          "type": "blob",
          "size": 6825
        },
        {
          "path": "plugins/development/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/development/commands/analyze-codebase.md",
          "type": "blob",
          "size": 701
        },
        {
          "path": "plugins/development/commands/analyze-directory.md",
          "type": "blob",
          "size": 1771
        },
        {
          "path": "plugins/development/commands/code-explain.md",
          "type": "blob",
          "size": 620
        },
        {
          "path": "plugins/development/commands/commit-pr.md",
          "type": "blob",
          "size": 2085
        },
        {
          "path": "plugins/development/commands/commit-push.md",
          "type": "blob",
          "size": 1526
        },
        {
          "path": "plugins/development/commands/commit.md",
          "type": "blob",
          "size": 3744
        },
        {
          "path": "plugins/development/commands/create-agent.md",
          "type": "blob",
          "size": 4380
        },
        {
          "path": "plugins/development/commands/create-command.md",
          "type": "blob",
          "size": 1211
        },
        {
          "path": "plugins/development/commands/create-issue.md",
          "type": "blob",
          "size": 2492
        },
        {
          "path": "plugins/development/commands/create-skill.md",
          "type": "blob",
          "size": 1058
        },
        {
          "path": "plugins/development/commands/dev-docs-update.md",
          "type": "blob",
          "size": 1843
        },
        {
          "path": "plugins/development/commands/dev-docs.md",
          "type": "blob",
          "size": 2251
        },
        {
          "path": "plugins/development/commands/estimate-task.md",
          "type": "blob",
          "size": 26635
        },
        {
          "path": "plugins/development/commands/git-workflow.md",
          "type": "blob",
          "size": 9191
        },
        {
          "path": "plugins/development/commands/onboarding-report.md",
          "type": "blob",
          "size": 1112
        },
        {
          "path": "plugins/development/commands/optimize-description.md",
          "type": "blob",
          "size": 2797
        },
        {
          "path": "plugins/development/commands/review-docs.md",
          "type": "blob",
          "size": 2444
        },
        {
          "path": "plugins/development/commands/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/development/commands/templates/specialist-agent-template.md",
          "type": "blob",
          "size": 6718
        },
        {
          "path": "plugins/development/commands/templates/task-agent-template.md",
          "type": "blob",
          "size": 2941
        },
        {
          "path": "plugins/development/commands/update-config.md",
          "type": "blob",
          "size": 1429
        },
        {
          "path": "plugins/development/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/development/hooks/post-tool-use-tracker.sh",
          "type": "blob",
          "size": 5104
        },
        {
          "path": "plugins/development/hooks/skill-activation-prompt.py",
          "type": "blob",
          "size": 6047
        },
        {
          "path": "plugins/development/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/development/skills/brainstorming",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/development/skills/brainstorming/SKILL.md",
          "type": "blob",
          "size": 8165
        },
        {
          "path": "plugins/development/skills/skill-developer",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/development/skills/skill-developer/ADVANCED.md",
          "type": "blob",
          "size": 3979
        },
        {
          "path": "plugins/development/skills/skill-developer/HOOK_MECHANISMS.md",
          "type": "blob",
          "size": 7920
        },
        {
          "path": "plugins/development/skills/skill-developer/PATTERNS_LIBRARY.md",
          "type": "blob",
          "size": 3347
        },
        {
          "path": "plugins/development/skills/skill-developer/SKILL.md",
          "type": "blob",
          "size": 12278
        },
        {
          "path": "plugins/development/skills/skill-developer/SKILL_RULES_REFERENCE.md",
          "type": "blob",
          "size": 8692
        },
        {
          "path": "plugins/development/skills/skill-developer/TRIGGER_TYPES.md",
          "type": "blob",
          "size": 7709
        },
        {
          "path": "plugins/development/skills/skill-developer/TROUBLESHOOTING.md",
          "type": "blob",
          "size": 10080
        },
        {
          "path": "plugins/development/skills/skill-rules.json",
          "type": "blob",
          "size": 3366
        },
        {
          "path": "plugins/frontend",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/frontend/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/frontend/agents/graphql-architect.md",
          "type": "blob",
          "size": 8682
        },
        {
          "path": "plugins/frontend/agents/react-specialist.md",
          "type": "blob",
          "size": 11187
        },
        {
          "path": "plugins/frontend/agents/tailwind-specialist.md",
          "type": "blob",
          "size": 11534
        },
        {
          "path": "plugins/frontend/agents/typescript-specialist.md",
          "type": "blob",
          "size": 9887
        }
      ],
      "marketplace": {
        "name": "fullstack-dev",
        "version": null,
        "description": "A comprehensive suite of plugins designed to enhance fullstack development workflows, covering frontend, backend, and overall development processes with specialized agents, commands, hooks, and skills.",
        "owner_info": {
          "name": "runxgalee"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "frontend",
            "description": "Frontend development plugin with specialized agents for React, TypeScript, UI components, and modern frontend development workflows",
            "source": "./plugins/frontend",
            "category": "development",
            "version": "1.0.0",
            "author": {
              "name": "runxgalee"
            },
            "install_commands": [
              "/plugin marketplace add runxgalee/fullstack-dev",
              "/plugin install frontend@fullstack-dev"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-09T01:03:28Z",
              "created_at": "2025-12-28T00:39:09Z",
              "license": "MIT"
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "backend",
            "description": "Backend development plugin with specialized agents for API development, database management, server-side logic, and backend infrastructure",
            "source": "./plugins/backend",
            "category": "development",
            "version": "1.0.0",
            "author": {
              "name": "runxgalee"
            },
            "install_commands": [
              "/plugin marketplace add runxgalee/fullstack-dev",
              "/plugin install backend@fullstack-dev"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-09T01:03:28Z",
              "created_at": "2025-12-28T00:39:09Z",
              "license": "MIT"
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "development",
            "description": "Development workflow plugin with agents, commands, hooks, and skills for automated testing, code quality, deployment, and productivity enhancement",
            "source": "./plugins/development",
            "category": "development",
            "version": "1.0.0",
            "author": {
              "name": "runxgalee"
            },
            "install_commands": [
              "/plugin marketplace add runxgalee/fullstack-dev",
              "/plugin install development@fullstack-dev"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-09T01:03:28Z",
              "created_at": "2025-12-28T00:39:09Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/analyze-codebase",
                "description": "Analyze codebase for architectural issues, code redundancy, complexity, and structural problems",
                "path": "plugins/development/commands/analyze-codebase.md",
                "frontmatter": {
                  "description": "Analyze codebase for architectural issues, code redundancy, complexity, and structural problems"
                },
                "content": "## Task\n\nUse the Task tool to invoke the `development:codebase-analyzer` agent to perform a comprehensive analysis of the current codebase.\n\nThe agent will:\n- Identify architectural issues and anti-patterns\n- Analyze directory structure and file organization\n- Detect code redundancy and duplication\n- Assess complexity levels and over-engineering\n- Find dead code and unused dependencies\n- Provide prioritized, actionable recommendations\n\nYou should pass a clear prompt to the agent asking it to analyze the codebase and provide a detailed report with findings and recommendations."
              },
              {
                "name": "/analyze-directory",
                "description": "Analyze code and documentation within a specified directory to generate a comprehensive report explaining what the code does, its purpose, and behavior. Scans files to identify functionality, architecture patterns, entry points, dependencies, and workflows.",
                "path": "plugins/development/commands/analyze-directory.md",
                "frontmatter": {
                  "description": "Analyze code and documentation within a specified directory to generate a comprehensive report explaining what the code does, its purpose, and behavior. Scans files to identify functionality, architecture patterns, entry points, dependencies, and workflows."
                },
                "content": "## Task\n\nGenerate a comprehensive analysis report for the specified directory.\n\n### Process\n\n1. **Accept directory path argument** - Use `{{ARGS}}` as the target directory path (default to current directory if not specified)\n\n2. **Launch exploration** - Use the Task tool with subagent_type='Explore' and thoroughness='very thorough' to analyze:\n   - File structure and organization\n   - Code functionality and purpose\n   - Architecture patterns and design decisions\n   - Entry points and main workflows\n   - Dependencies and integrations\n   - Configuration files and settings\n\n3. **Generate structured report** including:\n   - **Overview**: Directory purpose and high-level functionality\n   - **Architecture**: Design patterns, structure, and organization\n   - **Entry Points**: Main files, functions, or classes that serve as starting points\n   - **Key Components**: Important modules, functions, and their purposes\n   - **Dependencies**: External libraries, frameworks, and internal dependencies\n   - **Data Flow**: How data moves through the system\n   - **Configuration**: Environment variables, config files, and settings\n   - **Workflows**: Common operations and processes\n\n4. **Output format** - Present the report in clear markdown format with sections and subsections\n\n### Arguments\n\n- `{{ARGS}}` - Directory path to analyze (optional, defaults to current directory)\n\n### Example Usage\n\n```\n/analyze-directory src/services\n/analyze-directory .\n/analyze-directory ../backend/api\n```"
              },
              {
                "name": "/code-explain",
                "description": "Explain code in a target file",
                "path": "plugins/development/commands/code-explain.md",
                "frontmatter": {
                  "description": "Explain code in a target file"
                },
                "content": "## Task\nRead and explain the code in the specified file. Provide:\n\n1. **Overview**: High-level purpose and functionality\n2. **Key Components**: Main functions, classes, or modules\n3. **Logic Flow**: How the code works step-by-step\n4. **Dependencies**: Important imports and external dependencies\n5. **Notable Patterns**: Design patterns or architectural decisions\n\nKeep the explanation clear and concise, focusing on what the code does and why.\n\n### Arguments\nIf a file path is provided as an argument, explain that file. Otherwise, ask the user which file to explain."
              },
              {
                "name": "/commit-pr",
                "description": "Create commits using /commit command and draft pull request",
                "path": "plugins/development/commands/commit-pr.md",
                "frontmatter": {
                  "description": "Create commits using /commit command and draft pull request"
                },
                "content": "## Task\n\nCreate git commits and a draft pull request following these steps:\n\n### Arguments\nOptional issue number (e.g., `/commit-pr 123` or `/commit-pr #123`) to pass to `/commit` command and include in PR title.\n\n### Step 1: Create Commits\n\nUse the `/commit` command to create commits:\n- If issue number provided, call `/commit <issue-number>`\n- Otherwise, call `/commit`\n\nThe `/commit` command will:\n- Analyze and group changes into logical commits\n- Apply Conventional Commits format\n- Include issue number in commit messages if provided\n\n### Step 2: Create Draft Pull Request\n\n1. **Check branch status**:\n   - Run `git status` to verify commits were created\n   - Check if branch needs to be pushed: `git rev-parse --abbrev-ref --symbolic-full-name @{u}`\n\n2. **Analyze PR scope**:\n   - Run `git log main...HEAD` or `git log [base-branch]...HEAD` to see all commits in PR\n   - Run `git diff main...HEAD --stat` to see all changes\n   - Review ALL commits that will be included (not just the latest)\n\n3. **Create PR summary**:\n   - If issue number provided, include in title: `<type>: <description> (#<issue>)`\n   - Otherwise use conventional commit format based on commits: `<type>: <description>`\n   - Body format:\n     ```markdown\n     ## Summary\n     - [Bullet points of key changes based on commits]\n\n     ## Related Issue\n     Closes #<issue-number> (if applicable)\n\n     ## Test Plan\n     - [ ] [Testing checklist items]\n     ```\n\n4. **Push and create draft PR**:\n   - Push to remote if needed: `git push -u origin <branch>`\n   - Create draft PR using heredoc:\n     ```bash\n     gh pr create --draft --title \"<title>\" --body \"$(cat <<'EOF'\n     ## Summary\n     - [Changes]\n\n     ## Related Issue\n     Closes #123\n\n     ## Test Plan\n     - [ ] [Tests]\n     EOF\n     )\"\n     ```\n\n## Important Notes\n\n- **Use `/commit` command**: Do not manually create commits, always use `/commit` command\n- **PR as draft**: Always create as draft for review before marking ready\n- Return the PR URL when complete"
              },
              {
                "name": "/commit-push",
                "description": "Create git commit and push changes to remote repository",
                "path": "plugins/development/commands/commit-push.md",
                "frontmatter": {
                  "description": "Create git commit and push changes to remote repository",
                  "allowedTools": [
                    "Command(development:commit)",
                    "Bash(git:*)",
                    "Bash(plugin:*)"
                  ]
                },
                "content": "## Task\n\nCreate git commit(s) using the /commit command and push changes to the remote repository.\n\nFollow this workflow:\n\n1. **Create commit(s) using /commit command**\n   - Use the Skill tool to invoke the `commit` skill\n   - If arguments are provided to this command, pass them to /commit (e.g., issue number)\n   - The /commit command will handle:\n     - Analyzing staged changes\n     - Grouping changes intelligently\n     - Creating conventional commit messages\n     - Following git safety practices\n\n2. **Push to remote**\n   - After commit(s) are created successfully, push to remote\n   - Check if current branch tracks a remote branch\n   - If no upstream branch exists, push with `-u` flag: `git push -u origin <branch-name>`\n   - If upstream exists, use: `git push`\n   - Display the result to user\n\n3. **Update plugin marketplace**\n   - After successfully pushing to remote, run `/plugin marketplace update fullstack-dev`\n   - This ensures plugin metadata is kept up-to-date after changes\n   - Display the result to user\n\n### Git Safety\n- NEVER update git config\n- NEVER run destructive commands (force push, hard reset) unless explicitly requested\n- NEVER skip hooks (--no-verify) unless explicitly requested\n- All commit safety is handled by the /commit command\n\n### Arguments\nIf arguments are provided (e.g., issue number), pass them to the /commit command."
              },
              {
                "name": "/commit",
                "description": "Create git commits with smart grouping and conventional commit format",
                "path": "plugins/development/commands/commit.md",
                "frontmatter": {
                  "description": "Create git commits with smart grouping and conventional commit format"
                },
                "content": "## Task\n\nCreate git commits following Conventional Commits format with smart grouping. **This command only works with staged files** (files that have been `git add`ed).\n\n### Arguments\nIf an issue number is provided (e.g., `/commit 123` or `/commit #123`), include it in the commit message format: `<type>: <description> (#<issue-number>)`\n\n1. **Analyze staged changes**:\n   - Run `git status` to see staged and unstaged changes\n   - Run `git diff --cached --stat` to see only staged changes\n   - Run `git diff --cached` to see detailed staged changes\n   - Run `git log --oneline -5` to understand existing commit style\n   - **IMPORTANT**: If there are no staged changes, inform the user and exit\n\n2. **Group staged changes by type**:\n   - Analyze only the staged changes\n   - Group them into logical commits\n   - Each commit should be focused and atomic\n   - Group related files together (e.g., a feature with its tests, a bug fix with its affected files)\n   - Separate different types of changes (features, fixes, refactors, docs, etc.)\n   - If there are too many unrelated changes, split into multiple commits\n\n3. **Determine commit type prefix**:\n   - `feat:` - New features or functionality\n   - `fix:` - Bug fixes\n   - `refactor:` - Code refactoring without changing behavior\n   - `docs:` - Documentation changes\n   - `test:` - Adding or updating tests\n   - `style:` - Code style/formatting changes\n   - `chore:` - Maintenance tasks, dependencies, config\n   - `perf:` - Performance improvements\n   - `ci:` - CI/CD changes\n   - `build:` - Build system changes\n\n4. **Create commits from staged files**:\n   - For each logical group, use `git reset HEAD <files>` to unstage files not in the current group\n   - After unstaging unwanted files, the remaining staged files will be committed\n   - Create commit with format: `<type>: <description>`\n   - Use a heredoc for proper formatting:\n     ```bash\n     git commit -m \"$(cat <<'EOF'\n     feat: add user authentication system\n     EOF\n     )\"\n     ```\n   - Re-stage the unstaged files for the next commit: `git add <previously-unstaged-files>`\n   - Run `git status` after each commit to verify\n\n5. **Commit message guidelines**:\n   - Start with the type prefix (e.g., `feat:`, `fix:`)\n   - Keep the description concise and clear\n   - Focus on \"what\" and \"why\", not \"how\"\n   - Use present tense\n   - Don't end with a period\n   - **If issue number provided**: append it in format `(#<number>)`\n   - Example: `feat: add password reset functionality`\n   - Example: `fix: prevent race condition in user login`\n   - Example: `refactor: simplify database query logic`\n   - Example with issue: `feat: add password reset functionality (#123)`\n   - Example with issue: `fix: prevent race condition in user login (#456)`\n\n## Important Notes\n\n- **Only staged files**: This command only works with files that have already been staged with `git add`\n- **Check for staged changes first**: Always verify there are staged changes before proceeding\n- **Smart grouping**: If there are 5+ unrelated staged files, propose splitting into multiple focused commits\n- **Do not commit everything at once** unless all changes are truly related\n- Do not push to remote unless explicitly requested\n- Do not commit files with secrets (.env, credentials.json, etc.)\n- If pre-commit hook fails:\n  - If commit was REJECTED: fix the issue and create a NEW commit\n  - If commit SUCCEEDED but files were auto-modified: may amend ONLY if HEAD was created by you and not pushed\n- Never use `git commit --amend` unless explicitly requested and safe to do so\n- Never use flags like `--no-verify` or `--no-gpg-sign` unless explicitly requested"
              },
              {
                "name": "/create-agent",
                "description": "Create a new agent from template based on role and complexity",
                "path": "plugins/development/commands/create-agent.md",
                "frontmatter": {
                  "description": "Create a new agent from template based on role and complexity",
                  "argument-hint": "Brief description of the agent's role (e.g., \"code review specialist\", \"refactoring workflow coordinator\")"
                },
                "content": "You are an agent creation specialist. Create a new agent file based on the description: $ARGUMENTS\n\n## Instructions\n\n1. **Analyze the description** to determine which template to use:\n   - **Specialist Agent Template** (`specialist-agent-template.md`): Use when description indicates a domain expert role\n     - Keywords: \"expert\", \"specialist\", \"architect\", \"engineer\", \"[technology] pro\"\n     - Examples: \"Go specialist\", \"observability engineer\", \"backend architect\", \"React expert\"\n     - Characteristics: Deep expertise in specific technology, language, or domain\n\n   - **Task Agent Template** (`task-agent-template.md`): Use when description indicates a workflow or process coordinator\n     - Keywords: \"workflow\", \"coordinator\", \"multi-step\", \"complex task\", \"process\"\n     - Examples: \"code review workflow\", \"refactoring coordinator\", \"migration planner\"\n     - Characteristics: Orchestrates complex multi-step processes, requires structured workflows\n\n2. **Gather information** from user using AskUserQuestion tool (if needed):\n   - Agent name (kebab-case format)\n   - Key responsibilities or domain expertise\n   - Technologies/tools involved\n   - Model preference (sonnet/opus/haiku/inherit)\n   - Usage context: plugin use or project-specific use\n\n3. **Read the appropriate template**:\n   - For specialists: `agents/templates/specialist-agent-template.md`\n   - For task agents: `agents/templates/task-agent-template.md`\n\n4. **Determine the file location**:\n   - **For plugin use**: Create directly in `.claude/agents/[agent-name].md`\n   - **For project-specific use**: Create in `agents/[agent-name].md`\n   - Default to plugin use (`.claude/agents/`) unless user specifies project-specific\n\n5. **Create the new agent file**:\n   - Use the location determined in step 4\n   - Replace all placeholders with specific values:\n     - `[agent-name]` → actual agent name in kebab-case\n     - `[domain-name]` → technology or domain name\n     - `[pro|specialist|engineer|architect]` → chosen suffix\n     - `[Domain]` → capitalized domain name\n     - `[specific domain/task area]` → detailed domain description\n     - `[type of work]` → what the agent does\n     - `[expected outcomes]` → deliverables\n     - All other bracketed placeholders based on gathered information\n\n6. **Customize based on template type**:\n\n   **For Specialist Agents**:\n   - Fill in comprehensive capabilities organized by categories\n   - Define behavioral traits with action-oriented verbs\n   - List knowledge base areas\n   - Provide response approach steps\n   - Include example interactions (5-8 realistic requests)\n\n   **For Task Agents**:\n   - Define \"When Invoked\" triggers with specific keywords and scenarios\n   - List core responsibilities\n   - Detail workflow steps (numbered, actionable)\n   - Specify output requirements and format\n   - Define quality standards\n\n7. **Validate the created agent**:\n   - Ensure no placeholders remain (no `[...]` brackets)\n   - Verify YAML frontmatter is valid\n   - Check description is clear and specific\n   - Confirm content matches the intended agent type\n\n## Output\n\nAfter creating the agent file:\n1. Display the file path and confirmation message\n2. Show the YAML frontmatter (name, description, model)\n3. Provide a brief summary of the agent's purpose\n4. Suggest how to test/invoke the agent\n\n## Quality Standards\n- Agent names must be kebab-case (e.g., `go-pro`, `refactoring-workflow`)\n- Descriptions must be specific and actionable\n- All placeholders must be replaced with concrete values\n- Content should be complete and ready to use\n- Follow the structure and conventions of the selected template\n\n## Example Decision Logic\n\n| Description Input | Template Choice | Reasoning |\n|------------------|----------------|-----------|\n| \"Python expert\" | Specialist | Domain expertise in a language |\n| \"Code review workflow\" | Task | Process that requires multiple steps |\n| \"Database architect\" | Specialist | Role-based expertise |\n| \"Migration coordinator\" | Task | Complex multi-step process |\n| \"React specialist\" | Specialist | Technology-specific expertise |\n| \"Refactoring planner\" | Task | Planning workflow with structured steps |"
              },
              {
                "name": "/create-command",
                "description": "Create a new custom slash command with best practices",
                "path": "plugins/development/commands/create-command.md",
                "frontmatter": {
                  "allowed-tools": "Read, LS",
                  "description": "Create a new custom slash command with best practices"
                },
                "content": "## Task: Create a New Custom Slash Command\n\n### Input\n`$ARGUMENTS`\n\n### Process\n\n1. **Understand the user's intent**\n    - Infer appropriate command name and description from the input\n    - Command name should be kebab-case\n\n2. **Create the command file**\n    - Location: `.claude/commands/<command-name>.md`\n    - Start with minimal structure\n    - Only add complexity if needed\n\n### Important Guidelines\n- **Keep instructions concise** - Long instructions may be partially understood\n- **Start simple** - Basic commands only need a Task section\n- **Avoid over-specification** - Don't add allowed-tools unless necessary\n- **Focus on clarity** - Simple, direct instructions work best\n\n### Minimal Template\n```markdown\n---\ndescription: [Command description]\n---\n\n## Task\n[Brief, clear instruction]\n```\n\n### Extended Template (when needed)\n```markdown\n---\ndescription: [Command description]\nallowed-tools: [Only if specific tools needed]\n---\n\n## Context\n[Dynamic context if helpful]\n\n## Task\n[Clear instructions]\n\n### Arguments\n$ARGUMENTS\n```\n\nCreate the most appropriate command structure for the user's needs."
              },
              {
                "name": "/create-issue",
                "description": "Create a GitHub issue with structured planning documentation using a template that organizes task information into background, approach, and task breakdown sections",
                "path": "plugins/development/commands/create-issue.md",
                "frontmatter": {
                  "description": "Create a GitHub issue with structured planning documentation using a template that organizes task information into background, approach, and task breakdown sections"
                },
                "content": "## Task\n\nCreate a comprehensive GitHub issue with structured planning documentation for the given task description.\n\n### Process\n\n1. **Analyze the task description** provided by the user\n   - Extract key requirements and objectives\n   - Identify scope and complexity\n\n2. **Generate an issue template** with the following sections:\n   - **Background/Context**: Why this task is needed, problem statement, current state\n   - **Approach/Strategy**: Proposed solution, technical approach, key decisions\n   - **Task Breakdown**: Detailed step-by-step plan with sub-tasks and dependencies\n\n3. **Create the template file** (if not exists):\n   - Location: `.github/ISSUE_TEMPLATE/planning-task.md`\n   - Use GitHub issue template format\n   - Include all planning sections\n\n4. **Populate the issue** with analyzed content:\n   - Fill in background based on task context\n   - Outline strategic approach\n   - Break down into actionable tasks with checkboxes\n\n5. **Submit the GitHub issue**:\n   - Use `gh issue create` command\n   - Apply appropriate labels (e.g., `planning`, `task-breakdown`)\n   - Include the populated template content\n   - Return the issue URL\n\n### Arguments\n\n- `{{task_description}}` - Description of the task to create an issue for\n\n### Optional Flags\n\nWhen calling this command, users may include:\n- `--labels` - Additional labels to apply (comma-separated)\n- `--assignee` - GitHub username to assign\n- `--milestone` - Milestone to link to\n- `--project` - Project board to add issue to\n\n### Example Usage\n\n```\n/create-issue Implement user authentication system with JWT tokens\n/create-issue \"Add dark mode support to the application\" --labels \"enhancement,ui\" --assignee username\n```\n\n### Template Structure\n\nThe generated issue should follow this structure:\n\n```markdown\n## Background/Context\n\n[Why is this task needed? What problem does it solve? What is the current state?]\n\n## Approach/Strategy\n\n[What is the proposed solution? What technical approach will be used? What are the key decisions?]\n\n## Task Breakdown\n\n- [ ] Task 1: [Description]\n  - [ ] Subtask 1.1\n  - [ ] Subtask 1.2\n- [ ] Task 2: [Description]\n- [ ] Task 3: [Description]\n\n## Acceptance Criteria\n\n[What defines completion? How will we verify success?]\n\n## Notes\n\n[Any additional context, dependencies, or considerations]\n```"
              },
              {
                "name": "/create-skill",
                "description": "Interactive skill creation workflow with guided prompts, templates, and best practices enforcement",
                "path": "plugins/development/commands/create-skill.md",
                "frontmatter": {
                  "description": "Interactive skill creation workflow with guided prompts, templates, and best practices enforcement"
                },
                "content": "## Task\n\nUse the skill-developer skill to create a new Claude Code skill with an interactive, guided workflow.\n\nThe skill-developer provides:\n- Guided prompts for skill name, description, and functionality\n- Template selection based on skill complexity and purpose\n- Best practices enforcement for skill structure and documentation\n- Automatic plugin category determination\n- File creation in appropriate plugin directories\n- Symlink creation in .claude/skills/\n- Comprehensive documentation with examples\n- Validation of skill structure\n- README.md updates\n\n### Process\n\n1. Invoke the skill-developer skill using the Skill tool\n2. Follow the interactive prompts to define your skill\n3. Review the generated skill structure\n4. Validate and deploy the skill\n\n### Arguments\n\n- `{{args}}` - Optional: Skill name or brief description to initialize the workflow\n\nIf no arguments provided, skill-developer will start with interactive prompts."
              },
              {
                "name": "/dev-docs-update",
                "description": "Update dev documentation before context compaction",
                "path": "plugins/development/commands/dev-docs-update.md",
                "frontmatter": {
                  "description": "Update dev documentation before context compaction",
                  "argument-hint": "Optional - specific context or tasks to focus on (leave empty for comprehensive update)"
                },
                "content": "We're approaching context limits. Please update the development documentation to ensure seamless continuation after context reset.\n\n## Required Updates\n\n### 1. Update Active Task Documentation\nFor each task in `/dev/active/`:\n- Update `[task-name]-context.md` with:\n  - Current implementation state\n  - Key decisions made this session\n  - Files modified and why\n  - Any blockers or issues discovered\n  - Next immediate steps\n  - Last Updated timestamp\n\n- Update `[task-name]-tasks.md` with:\n  - Mark completed tasks as ✅ \n  - Add any new tasks discovered\n  - Update in-progress tasks with current status\n  - Reorder priorities if needed\n\n### 2. Capture Session Context\nInclude any relevant information about:\n- Complex problems solved\n- Architectural decisions made\n- Tricky bugs found and fixed\n- Integration points discovered\n- Testing approaches used\n- Performance optimizations made\n\n### 3. Update Memory (if applicable)\n- Store any new patterns or solutions in project memory/documentation\n- Update entity relationships discovered\n- Add observations about system behavior\n\n### 4. Document Unfinished Work\n- What was being worked on when context limit approached\n- Exact state of any partially completed features\n- Commands that need to be run on restart\n- Any temporary workarounds that need permanent fixes\n\n### 5. Create Handoff Notes\nIf switching to a new conversation:\n- Exact file and line being edited\n- The goal of current changes\n- Any uncommitted changes that need attention\n- Test commands to verify work\n\n## Additional Context: $ARGUMENTS\n\n**Priority**: Focus on capturing information that would be hard to rediscover or reconstruct from code alone."
              },
              {
                "name": "/dev-docs",
                "description": "Create a comprehensive strategic plan with structured task breakdown",
                "path": "plugins/development/commands/dev-docs.md",
                "frontmatter": {
                  "description": "Create a comprehensive strategic plan with structured task breakdown",
                  "argument-hint": "Describe what you need planned (e.g., \"refactor authentication system\", \"implement microservices\")"
                },
                "content": "You are an elite strategic planning specialist. Create a comprehensive, actionable plan for: $ARGUMENTS\n\n## Instructions\n\n1. **Analyze the request** and determine the scope of planning needed\n2. **Examine relevant files** in the codebase to understand current state\n3. **Create a structured plan** with:\n   - Executive Summary\n   - Current State Analysis\n   - Proposed Future State\n   - Implementation Phases (broken into sections)\n   - Detailed Tasks (actionable items with clear acceptance criteria)\n   - Risk Assessment and Mitigation Strategies\n   - Success Metrics\n   - Required Resources and Dependencies\n   - Timeline Estimates\n\n4. **Task Breakdown Structure**: \n   - Each major section represents a phase or component\n   - Number and prioritize tasks within sections\n   - Include clear acceptance criteria for each task\n   - Specify dependencies between tasks\n   - Estimate effort levels (S/M/L/XL)\n\n5. **Create task management structure**:\n   - Create directory: `dev/active/[task-name]/` (relative to project root)\n   - Generate three files:\n     - `[task-name]-plan.md` - The comprehensive plan\n     - `[task-name]-context.md` - Key files, decisions, dependencies\n     - `[task-name]-tasks.md` - Checklist format for tracking progress\n   - Include \"Last Updated: YYYY-MM-DD\" in each file\n\n## Quality Standards\n- Plans must be self-contained with all necessary context\n- Use clear, actionable language\n- Include specific technical details where relevant\n- Consider both technical and business perspectives\n- Account for potential risks and edge cases\n\n## Context References\n- Check `PROJECT_KNOWLEDGE.md` for architecture overview (if exists)\n- Consult `BEST_PRACTICES.md` for coding standards (if exists)\n- Reference `TROUBLESHOOTING.md` for common issues to avoid (if exists)\n- Use `dev/README.md` for task management guidelines (if exists)\n\n**Note**: This command is ideal to use AFTER exiting plan mode when you have a clear vision of what needs to be done. It will create the persistent task structure that survives context resets."
              },
              {
                "name": "/estimate-task",
                "description": "Estimate agent types, task breakdown, tools, agent interactions, parallelization opportunities, and execution flow with visual diagrams",
                "path": "plugins/development/commands/estimate-task.md",
                "frontmatter": {
                  "description": "Estimate agent types, task breakdown, tools, agent interactions, parallelization opportunities, and execution flow with visual diagrams"
                },
                "content": "## Task\n\nGiven a task description (provided as arguments or interactively), analyze and provide comprehensive task estimation including:\n\n1. **Agent Types Needed**: Identify which specialized agents would be best suited\n2. **Agent Execution Flow**: Visual Mermaid diagram showing agent sequence, parallel execution, and decision points\n3. **Agent Interaction Matrix**: Table showing data flow, tools, and dependencies between agents\n4. **Task Breakdown**: Detailed phases with agent assignments and dependencies\n5. **Parallelization Analysis**: Identify which agents can run in parallel vs sequential\n6. **Decision Points**: Conditional logic showing when agents trigger based on conditions\n7. **Timeline Estimation**: Compare sequential vs parallel execution times\n8. **Tool Estimation**: List tools used across all phases\n9. **Expected Output Files**: Comprehensive list of all files each agent will generate, organized by agent with file paths, types, and purposes\n\n## Agent Capability Database\n\nUse these patterns to select appropriate agents based on task requirements:\n\n### Development & Quality Agents\n\n**code-reviewer** (Always include for implementation tasks)\n- Inputs: All implementation files, changed files\n- Outputs: review-report.md, quality-metrics\n- Tools: Read, Grep, Glob\n- Domain: Quality assurance\n- Phase: Final validation (sequential, must wait for implementation)\n- Estimated Time: 4-6 minutes\n\n**debug-specialist** (Conditional: errors/test failures)\n- Inputs: Error logs, stack traces, test failures\n- Outputs: debug-report.md, fix suggestions\n- Tools: Read, Grep, Bash, Task\n- Domain: Cross-cutting\n- Conditional: Only if tests fail or errors occur\n- Estimated Time: 5-15 minutes\n\n**context-orchestrator** (Complex tasks)\n- Inputs: Project structure, task description\n- Outputs: Context analysis, execution plan\n- Tools: Read, Grep, Glob, Task\n- Domain: Orchestration\n- Phase: Initial analysis\n- Estimated Time: 3-5 minutes\n\n**claude-code-architect** (Very complex/unclear tasks)\n- Inputs: Task description, codebase structure\n- Outputs: Architecture plan, agent recommendations\n- Tools: All tools\n- Domain: Meta-planning\n- Phase: Initial planning\n- Estimated Time: 5-10 minutes\n\n**documentation-architect**\n- Inputs: Codebase, existing docs\n- Outputs: Technical documentation, architecture guides\n- Tools: Read, Grep, Glob, Write\n- Domain: Documentation\n- Estimated Time: 10-20 minutes\n\n### Frontend Agents\n\n**react-specialist**\n- Inputs: Requirements, API spec, design mockups\n- Outputs: components/*.tsx, hooks/*.ts, styles/*.css\n- Tools: Write, Edit, Read, Bash (npm)\n- Domain: Frontend\n- Can Parallelize With: Backend agents, database agents (if no shared file conflicts)\n- Estimated Time: 8-15 minutes\n\n**typescript-specialist**\n- Inputs: Requirements, existing types\n- Outputs: types/*.ts, *.d.ts, tsconfig updates\n- Tools: Write, Edit, Read\n- Domain: Type systems\n- Can Parallelize With: Other implementation agents\n- Estimated Time: 5-10 minutes\n\n**tailwind-specialist**\n- Inputs: Design requirements, component structure\n- Outputs: Tailwind configs, styled components\n- Tools: Write, Edit, Read\n- Domain: Styling\n- Can Parallelize With: Component implementation\n- Estimated Time: 4-8 minutes\n\n### Backend Agents\n\n**backend-architect**\n- Inputs: Requirements, data model, API requirements\n- Outputs: api-spec.yaml, service-design.md, *.ts, *.go\n- Tools: Write, Edit, Read, Bash, Task\n- Domain: Backend\n- Can Parallelize With: Frontend agents, database agents (different files)\n- Estimated Time: 10-20 minutes\n\n**go-specialist**\n- Inputs: Requirements, API spec\n- Outputs: *.go, go.mod updates\n- Tools: Write, Edit, Read, Bash\n- Domain: Backend (Go)\n- Can Parallelize With: Frontend, database, other backend if different services\n- Estimated Time: 10-18 minutes\n\n**grpc-specialist**\n- Inputs: Service requirements, proto schemas\n- Outputs: *.proto, gRPC services\n- Tools: Write, Edit, Read, Bash\n- Domain: RPC/microservices\n- Can Parallelize With: Other implementation agents\n- Estimated Time: 8-15 minutes\n\n### Database Agents\n\n**postgres-specialist**\n- Inputs: Data model, requirements\n- Outputs: migrations/*.sql, schema definitions\n- Tools: Write, Edit, Bash (psql)\n- Domain: Database\n- Can Parallelize With: Backend API, frontend (usually different files)\n- Estimated Time: 6-12 minutes\n\n**sql-specialist**\n- Inputs: Query requirements, schema\n- Outputs: Optimized queries, indexes\n- Tools: Write, Edit, Read, Bash\n- Domain: Database optimization\n- Can Parallelize With: Application code development\n- Estimated Time: 5-10 minutes\n\n**database-architect**\n- Inputs: Requirements, data model\n- Outputs: Schema design, migration strategy\n- Tools: Write, Read\n- Domain: Database design\n- Phase: Early design phase (sequential)\n- Estimated Time: 8-15 minutes\n\n### Infrastructure & Operations Agents\n\n**cloud-architect**\n- Inputs: Requirements, infrastructure needs\n- Outputs: IaC files (Terraform/CDK), architecture diagrams\n- Tools: Write, Edit, Read\n- Domain: Cloud infrastructure\n- Estimated Time: 15-30 minutes\n\n**k8s-specialist**\n- Inputs: Application requirements, cluster config\n- Outputs: Kubernetes manifests, Helm charts\n- Tools: Write, Edit, Bash\n- Domain: Container orchestration\n- Estimated Time: 10-20 minutes\n\n**terraform-specialist**\n- Inputs: Infrastructure requirements\n- Outputs: *.tf files, modules\n- Tools: Write, Edit, Bash\n- Domain: Infrastructure as Code\n- Estimated Time: 12-25 minutes\n\n**cicd-specialist**\n- Inputs: Deployment requirements, test strategy\n- Outputs: Pipeline configs (.github/workflows/*, .gitlab-ci.yml)\n- Tools: Write, Edit, Bash\n- Domain: CI/CD\n- Estimated Time: 8-15 minutes\n\n**sre-specialist**\n- Inputs: Service requirements, SLOs\n- Outputs: Monitoring configs, dashboards, alerts\n- Tools: Write, Edit, Read\n- Domain: Observability\n- Estimated Time: 10-18 minutes\n\n### Security Agents\n\n**security-specialist** (Conditional: security-critical features)\n- Inputs: Architecture design, implementation files\n- Outputs: security-checklist.md, vulnerability report\n- Tools: Read, Grep, Write\n- Domain: Security\n- Conditional: Always for auth/payments/sensitive data; optional otherwise\n- Phase: After design, before implementation\n- Estimated Time: 5-10 minutes\n\n## Process\n\n### 1. Parse Task Description\n\nIf arguments provided: Use them as task description\nIf no arguments: Ask user to describe the task\n\n### 2. Analyze Task Requirements\n\nExtract from task description:\n- **Keywords**: auth, database, API, frontend, UI, deploy, test, performance, etc.\n- **Technical Domain**: frontend, backend, database, fullstack, infrastructure, security\n- **Complexity**: Simple (1-2 files), Medium (3-10 files), Complex (system-wide, multiple domains)\n- **Scope**: Single component, feature addition, system refactor, new architecture\n\n### 3. Select Agents\n\nBased on keyword matching:\n\n**Authentication/Security keywords**: `auth`, `login`, `jwt`, `oauth`, `security`, `encryption`\n→ security-specialist, backend-architect, postgres-specialist (users table)\n\n**Frontend/UI keywords**: `component`, `UI`, `frontend`, `react`, `page`, `form`, `button`\n→ react-specialist, typescript-specialist, tailwind-specialist\n\n**Backend/API keywords**: `API`, `endpoint`, `service`, `backend`, `server`, `microservice`\n→ backend-architect, go-specialist, grpc-specialist\n\n**Database keywords**: `database`, `schema`, `migration`, `query`, `SQL`, `postgres`\n→ postgres-specialist, sql-specialist, database-architect\n\n**Infrastructure keywords**: `deploy`, `cloud`, `AWS`, `kubernetes`, `infrastructure`, `terraform`\n→ cloud-architect, k8s-specialist, terraform-specialist, cicd-specialist\n\n**Performance/Debugging keywords**: `bug`, `error`, `slow`, `optimize`, `debug`, `performance`\n→ debug-specialist, sre-specialist\n\n**Quality keywords**: Always include `code-reviewer` for implementation tasks\n\n**Complexity-based**:\n- Complex or unclear tasks → claude-code-architect for planning\n- Multi-domain tasks → context-orchestrator for coordination\n\n### 4. Build Dependency Graph\n\nFor each selected agent:\n1. Identify **inputs** (what artifacts/files it needs)\n2. Identify **outputs** (what artifacts/files it produces)\n3. Determine **dependencies**:\n   - Agent B depends on Agent A if B needs A's output\n   - Example: react-specialist depends on backend-architect's api-spec.yaml\n4. Detect **file conflicts**:\n   - Agents writing to same files cannot parallelize\n   - Agents writing to different files can parallelize\n5. Identify **phase**:\n   - Analysis/Planning phase (sequential)\n   - Implementation phase (can parallelize)\n   - Integration/Testing phase (sequential)\n   - Review phase (sequential)\n\n### 5. Determine Parallelization\n\n**Rules for parallel execution**:\n- ✅ Agents with no data dependencies can run in parallel\n- ✅ Agents writing to different files can run in parallel\n- ✅ Multiple Read-only agents can always parallelize\n- ⛔ Sequential if Agent B needs Agent A's output\n- ⛔ Sequential if both modify the same files\n- ⛔ Sequential for validation phases (review, testing)\n- ⛔ Sequential for git operations (commits must be ordered)\n\n**Group into phases**:\n1. **Phase 1: Analysis** (Sequential)\n   - context-orchestrator, claude-code-architect, database-architect\n2. **Phase 2: Design Validation** (Sequential)\n   - security-specialist (for security-critical features)\n3. **Phase 3: Implementation** (Can parallelize)\n   - Frontend: react-specialist, typescript-specialist, tailwind-specialist\n   - Backend: backend-architect, go-specialist, grpc-specialist\n   - Database: postgres-specialist, sql-specialist\n   - Rule: Parallel if different file scopes, sequential if dependencies exist\n4. **Phase 4: Integration** (Sequential)\n   - backend-architect for connecting components, running integration tests\n5. **Phase 5: Debugging** (Conditional, Sequential)\n   - debug-specialist if tests fail\n6. **Phase 6: Review** (Sequential)\n   - code-reviewer for final quality check\n\n### 6. Identify Decision Points\n\n**Common decision patterns**:\n\n1. **Security Review Decision** (After design)\n   - Condition: Is this a security-critical feature? (auth, payments, user data)\n   - If YES → security-specialist validates design\n   - If NO → proceed to implementation\n\n2. **Test Results Decision** (After integration)\n   - Condition: Do all tests pass?\n   - If NO → debug-specialist investigates → loop back to fixes\n   - If YES → proceed to review\n\n3. **Code Review Decision** (After review)\n   - Condition: Any critical issues found?\n   - If YES → loop back to implementation with fixes\n   - If NO → task complete\n\n4. **Complexity Decision** (Initial)\n   - Condition: Is task very complex or unclear?\n   - If YES → claude-code-architect creates detailed plan first\n   - If NO → proceed with direct implementation\n\n### 7. Generate Mermaid Diagram\n\nCreate a flowchart showing:\n- **Start node**: `([Task: {task_name}])`\n- **Agent nodes**: `[agent-name: action]`\n- **Decision nodes**: `{Condition?}`\n- **Parallel split**: `{Parallel Split}`\n- **Sync points**: `((Sync Point))`\n- **End node**: `([Complete])`\n- **Connections**: ` --> |produces: artifact|` or `-->|condition|`\n\n**Color coding (use style directives)**:\n- Analysis/Planning agents: `fill:#E8F4F8,stroke:#0066CC`\n- Implementation agents (can parallelize): `fill:#90EE90,stroke:#228B22`\n- Decision points: `fill:#FFD700,stroke:#FF8C00`\n- Parallel splits: `fill:#87CEEB,stroke:#4682B4`\n- Sync points: `fill:#DDA0DD,stroke:#9370DB`\n- Error/Debug agents: `fill:#FFB6C1,stroke:#DC143C`\n- Review/Validation agents: `fill:#F0E68C,stroke:#DAA520`\n\n**Output the Mermaid diagram to a separate file**:\n- Create file: `docs/task-flow-{sanitized-task-name}.mmd` (sanitize task name: lowercase, replace spaces with hyphens, remove special chars)\n- Example: For \"GraphQL User Registration API\" → `docs/task-flow-graphql-user-registration-api.mmd`\n- If `docs/` directory doesn't exist, create it first\n- Write the complete Mermaid flowchart to this file (without markdown code fences)\n- In the main output, include a link to this file\n\n**Template**:\n```mermaid\nflowchart TD\n    Start([Task: {TASK_NAME}])\n\n    %% Analysis Phase\n    A1[agent1: Analyze Requirements]\n    Start --> A1\n    A1 --> |produces: requirements.md| Decision1{Decision Point}\n\n    %% Decision Branch\n    Decision1 -->|condition met| A2[agent2: Conditional Action]\n    Decision1 -->|condition not met| Parallel1{Parallel Split}\n\n    %% Parallel Implementation\n    Parallel1 -->|branch 1| A3[agent3: Build Component A]\n    Parallel1 -->|branch 2| A4[agent4: Build Component B]\n    Parallel1 -->|branch 3| A5[agent5: Build Component C]\n\n    A3 --> |produces: output1| Sync1((Sync Point 1))\n    A4 --> |produces: output2| Sync1\n    A5 --> |produces: output3| Sync1\n\n    %% Integration & Testing\n    Sync1 --> A6[agent6: Integration Tests]\n    A6 --> |runs tests| Decision2{Tests Pass?}\n\n    %% Conditional Debug Loop\n    Decision2 -->|No| A7[debug-specialist: Investigate]\n    A7 --> |produces: fixes| A3\n    Decision2 -->|Yes| A8[code-reviewer: Final Review]\n\n    %% Final Decision\n    A8 --> |produces: review| Decision3{Critical Issues?}\n    Decision3 -->|Yes| A3\n    Decision3 -->|No| End([Complete])\n\n    %% Styling\n    style A1 fill:#E8F4F8,stroke:#0066CC\n    style A3 fill:#90EE90,stroke:#228B22\n    style A4 fill:#90EE90,stroke:#228B22\n    style A5 fill:#90EE90,stroke:#228B22\n    style A6 fill:#E8F4F8,stroke:#0066CC\n    style A7 fill:#FFB6C1,stroke:#DC143C\n    style A8 fill:#F0E68C,stroke:#DAA520\n    style Decision1 fill:#FFD700,stroke:#FF8C00\n    style Decision2 fill:#FFD700,stroke:#FF8C00\n    style Decision3 fill:#FFD700,stroke:#FF8C00\n    style Parallel1 fill:#87CEEB,stroke:#4682B4\n    style Sync1 fill:#DDA0DD,stroke:#9370DB\n```\n\n### 8. Create Agent Interaction Matrix\n\nBuild a table with columns:\n- **Agent**: Agent name\n- **Phase**: Phase number\n- **Input Dependencies**: What files/artifacts it needs (from which agents)\n- **Tools Used**: List of tools (Read, Write, Edit, Bash, etc.)\n- **Output Artifacts**: What files/artifacts it produces\n- **Can Parallelize With**: Which other agents can run simultaneously\n\nExample row:\n| Agent | Phase | Input Dependencies | Tools Used | Output Artifacts | Can Parallelize With |\n|-------|-------|-------------------|------------|------------------|---------------------|\n| **backend-architect** | 3 | `requirements.md` (context-orchestrator), `security-checklist.md` (security-specialist) | Write, Edit, Bash, Task | `api-spec.yaml`, `auth-service.ts`, `tests/*.test.ts` | postgres-specialist, react-specialist |\n\n### 9. Create Detailed Task Breakdown\n\nFor each phase:\n- List phase name and type (Sequential/Parallel)\n- For each step in phase:\n  - **Step number and name**\n  - **Agent**: Which agent handles this\n  - **Input**: Dependencies and required artifacts\n  - **Actions**: Bulleted list of what agent will do\n  - **Tools**: Specific tools used\n  - **Output**: Artifacts produced\n  - **Can Parallel With**: Other steps (if applicable)\n  - **Estimated Time**: Time range in minutes\n  - **Blocking**: Whether this blocks other steps\n\n### 10. List Decision Points & Conditional Flows\n\nFor each decision point:\n- **Decision ID**: After which agent/phase\n- **Condition**: What determines the path\n- **True Path**: What happens if condition is met\n- **False Path**: What happens if condition is not met\n- **Trigger Type**: Always, Conditional, Loop-back\n\nExample:\n```\n1. **After Phase 1 (Always triggers)**\n   - Decision: Security review required?\n   - Action: Always invoke security-specialist for auth/payment features\n   - Rationale: Security-critical features require expert validation\n\n2. **After Phase 4 (Conditional)**\n   - Decision: Are all tests passing?\n   - If NO: Invoke debug-specialist → Fix → Re-test (loop)\n   - If YES: Proceed to code review\n```\n\n### 11. Calculate Timeline Estimates\n\n**Per-agent estimates**: Use ranges from agent capability database\n\n**Sequential execution**: Sum of all agent times\n- Formula: `sum(all agent times)`\n\n**Parallel execution**: Max of parallel branches + sequential phases\n- Formula: `sum(sequential phases) + max(parallel branch times)`\n\n**Optimization percentage**:\n- Formula: `((sequential - parallel) / sequential) * 100`\n\n**Critical path**: Longest dependency chain from start to finish\n\n**Blocking dependencies**: Count of sync points where parallel work must converge\n\n### 12. List Tools Required\n\nGroup tools by phase and purpose:\n- **Read**: Which phases use for what purpose\n- **Write**: New file creation (list estimated file count)\n- **Edit**: Existing file modification\n- **Grep/Glob**: Code discovery and pattern matching\n- **Bash**: Commands (npm, psql, testing, git)\n- **Task**: Sub-agent orchestration\n\nInclude estimated frequency for each tool.\n\n### 13. Document Expected Output Files\n\nCreate a comprehensive list of all files that will be generated during task execution:\n\n**File Categories**:\n1. **Analysis & Planning Documents** (`.md` reports, design docs)\n2. **Implementation Code** (`.ts`, `.tsx`, `.go`, `.sql`, etc.)\n3. **Configuration Files** (`.yaml`, `.json`, config files)\n4. **Test Files** (`.test.ts`, `.spec.ts`, integration tests)\n5. **Generated Assets** (types, schemas, migrations)\n\n**For each agent**, list:\n- **Agent name**\n- **Output files** with full relative paths from project root\n- **File type** (Report, Code, Config, Test, Generated)\n- **Purpose** of each file\n\n**Format as a table**:\n| Agent | File Path | Type | Purpose |\n|-------|-----------|------|---------|\n| agent-name | `path/to/file.ext` | Report/Code/Config/Test/Generated | Brief description |\n\n**Grouping**:\n- Group files by agent\n- Within each agent, order by creation sequence\n- Mark conditional files (e.g., debug-specialist outputs only if tests fail)\n\n**Example**:\n```markdown\n### Expected Output Files\n\n| Agent | File Path | Type | Purpose |\n|-------|-----------|------|---------|\n| **graphql-architect** | `docs/schema-analysis.md` | Report | GraphQL schema design and mutation specifications |\n| **graphql-architect** | `schema/user.graphql` | Code | User registration GraphQL schema definitions |\n| **postgres-specialist** | `docs/users-schema.sql` | Report | Database schema design document |\n| **postgres-specialist** | `migrations/20260108_create_users_table.sql` | Code | Users table creation migration |\n| **security-specialist** | `docs/security-checklist.md` | Report | Security validation and requirements |\n| **backend-architect** | `resolvers/user.ts` | Code | User registration resolver implementation |\n| **backend-architect** | `tests/user.test.ts` | Test | Unit tests for user registration |\n| **code-reviewer** | `docs/review-report.md` | Report | Final code quality and security review |\n| **debug-specialist** | `docs/debug-report.md` | Report | Debugging analysis (conditional - only if tests fail) |\n```\n\nThis section provides:\n- A complete checklist of expected deliverables\n- Clear file organization structure\n- Easy verification of task completion\n- Input for subsequent automation (e.g., checking if all files were created)\n\n### 14. Output Results to Files\n\nAfter generating the complete analysis:\n\n#### Step 14.1: Create Output Directory\n- Check if `docs/` exists, create if needed using mkdir\n\n#### Step 14.2: Sanitize Task Name\nConvert task name to filename-safe format:\n- Lowercase all characters\n- Replace spaces with hyphens\n- Remove special characters (keep only alphanumeric and hyphens)\n- Truncate to 50 characters max\n- Example: \"GraphQL User Registration API\" → \"graphql-user-registration-api\"\n\n#### Step 14.3: Write Mermaid Diagram File\nSave the complete Mermaid flowchart to `docs/task-flow-{sanitized-name}.mmd`:\n- Do NOT include markdown code fences (```mermaid)\n- Write raw Mermaid syntax only\n- Include all style directives\n\n#### Step 14.4: Write Complete Estimation Report\nSave the complete estimation analysis to `docs/task-estimate-{sanitized-name}.md`:\n- Include all sections: Complexity Assessment, Recommended Agents, Agent Execution Flow, Agent Interaction Matrix, Detailed Task Breakdown, Decision Points, Tools Required, Expected Output Files, Estimated Timeline, Parallelization Summary\n- For the \"Agent Execution Flow\" section, include BOTH:\n  - Link to the separate `.mmd` file\n  - Inline mermaid diagram with code fences\n- Use full markdown formatting\n- This file serves as a permanent record of the estimation\n\n#### Step 14.5: Provide Summary to User\nAfter writing both files, provide a concise summary to the user:\n```\n✅ Task estimation complete!\n\n📊 **Full Report**: [docs/task-estimate-{sanitized-name}.md](./docs/task-estimate-{sanitized-name}.md)\n📈 **Flow Diagram**: [docs/task-flow-{sanitized-name}.mmd](./docs/task-flow-{sanitized-name}.mmd)\n\n**Quick Summary**:\n- Complexity: [Simple/Medium/Complex]\n- Agents Required: [count] agents\n- Estimated Time: [X-Y] minutes (optimized with parallelization)\n- Key Phases: [brief list]\n```\n\nDo NOT output the full estimation report inline to the user - only output the summary above. The full report is in the saved file.\n\n## Output Format\n\n**IMPORTANT**: Write the complete estimation to `docs/task-estimate-{sanitized-task-name}.md` file, then provide only a summary to the user.\n\nThe complete estimation file should follow this structured format:\n\n````markdown\n## Task Analysis: [Task Name]\n\n### Complexity Assessment\n**[Simple/Medium/Complex]** - [Brief reasoning about scope, domains involved, and technical challenges]\n\n### Recommended Agents\n- **agent-name** (Model: sonnet/opus/haiku): [Why this agent is suitable, what it will handle]\n- **agent-name** (Model: sonnet/opus/haiku): [Reasoning]\n- ...\n\n[Include 3-8 agents typically, with conditional agents marked]\n\n### Agent Execution Flow\n\n**Mermaid Diagram**: [View flow diagram](./docs/task-flow-{sanitized-task-name}.mmd)\n\n<details>\n<summary>Click to view inline diagram</summary>\n\n```mermaid\n[Generate flowchart diagram as specified in step 7]\n```\n\n</details>\n\n### Agent Interaction Matrix\n\n| Agent | Phase | Input Dependencies | Tools Used | Output Artifacts | Can Parallelize With |\n|-------|-------|-------------------|------------|------------------|---------------------|\n| **agent1** | 1 | Task description | Read, Grep | requirements.md | None (Sequential) |\n| **agent2** | 3 | requirements.md | Write, Edit | component.tsx | agent3, agent4 |\n| ... | ... | ... | ... | ... | ... |\n\n### Detailed Task Breakdown\n\n#### Phase 1: [Phase Name] (Sequential/Parallel - XX-YY minutes)\n\n**Step 1.1** - Agent: `agent-name`\n- **Input**: [Dependencies]\n- **Actions**:\n  - Action item 1\n  - Action item 2\n- **Tools**: [Tools used]\n- **Output**: [Artifacts produced]\n- **Can Parallel With**: [Other steps or None]\n- **Estimated Time**: X-Y minutes\n\n[Continue for all phases and steps]\n\n**Synchronization Point N**: [Description of what must complete before proceeding]\n\n### Decision Points & Conditional Flows\n\n1. **After [Phase/Agent] ([Always/Conditional])**\n   - **Decision**: [Condition to evaluate]\n   - **If YES**: [Action taken]\n   - **If NO**: [Alternative action]\n   - **Rationale**: [Why this decision point exists]\n\n[List all decision points]\n\n### Tools Required\n\n| Tool | Usage Phase | Purpose | Estimated Frequency |\n|------|-------------|---------|---------------------|\n| **Read** | All | Read existing code, configs | High (50+ files) |\n| **Write** | 3 | Create new components | Medium (10-15 files) |\n| ... | ... | ... | ... |\n\n### Expected Output Files\n\n| Agent | File Path | Type | Purpose |\n|-------|-----------|------|---------|\n| **agent-name** | `path/to/output.md` | Report | Description of the file's purpose |\n| **agent-name** | `src/component.tsx` | Code | Implementation file description |\n| **agent-name** | `tests/component.test.ts` | Test | Test file description |\n| ... | ... | ... | ... |\n\n[Include all files that will be generated during task execution, organized by agent]\n\n### Estimated Timeline\n\n**Without Parallelization** (Sequential execution):\n- Phase 1: X-Y minutes\n- Phase 2: X-Y minutes\n- ...\n- **Total: XX-YY minutes**\n\n**With Parallelization** (Optimized):\n- Phase 1: X-Y minutes (sequential)\n- Phase 2: X-Y minutes (max of parallel branches)\n- ...\n- **Total: XX-YY minutes**\n\n**Optimization Gain**: ~XX-YY% faster with parallel execution\n\n**Critical Path**: [Longest dependency chain]\n\n**Blocking Dependencies**: N synchronization points (after Phase X, Y, Z)\n\n### Parallelization Summary\n\n**Parallel Opportunities**:\n- ✅ Phase X: [Agent A + Agent B + Agent C can run in parallel]\n- ✅ [Other parallel opportunities]\n\n**Sequential Requirements**:\n- ⛔ Phase X must complete before Phase Y ([reason])\n- ⛔ [Other sequential requirements]\n\n**Conditional Branches**:\n- 🔀 [Conditional flow description]\n````\n\n## Important Notes\n\n1. **Simple tasks** (1-2 agents, single file): Skip complex diagram, provide simplified output\n2. **Complex tasks** (6+ agents, multi-domain): Full visualization with all sections\n3. **Edge cases**:\n   - If circular dependencies detected: Warn user and suggest refactoring\n   - If too many agents (>10): Group similar agents and simplify diagram\n   - If unclear task: Recommend using claude-code-architect first\n4. **Always include**:\n   - code-reviewer for implementation tasks\n   - debug-specialist marked as conditional\n   - Realistic time estimates with ranges\n5. **Model selection**:\n   - opus for complex architecture/design agents\n   - sonnet for most implementation and analysis\n   - haiku for simple, straightforward tasks\n\n## Example Keywords for Agent Selection\n\n- **auth, login, signup, jwt, oauth, session**: → security-specialist, backend-architect, postgres-specialist\n- **component, react, tsx, ui, page, form**: → react-specialist, typescript-specialist\n- **api, endpoint, rest, graphql, grpc**: → backend-architect, grpc-specialist\n- **database, schema, migration, sql, query**: → postgres-specialist, sql-specialist, database-architect\n- **deploy, cloud, aws, k8s, terraform**: → cloud-architect, k8s-specialist, terraform-specialist\n- **test, ci/cd, pipeline, github actions**: → cicd-specialist\n- **monitor, metrics, logs, alerts**: → sre-specialist\n- **bug, error, debug, fix, failing**: → debug-specialist\n- **performance, slow, optimize**: → sre-specialist, sql-specialist (for DB), react-specialist (for frontend)\n- **security, vulnerability, encrypt**: → security-specialist\n- **docs, documentation, readme**: → documentation-architect"
              },
              {
                "name": "/git-workflow",
                "description": null,
                "path": "plugins/development/commands/git-workflow.md",
                "frontmatter": null,
                "content": "# Complete Git Workflow with Multi-Agent Orchestration\n\nOrchestrate a comprehensive git workflow from code review through PR creation, leveraging specialized agents for quality assurance, testing, and deployment readiness. This workflow implements modern git best practices including Conventional Commits, automated testing, and structured PR creation.\n\n[Extended thinking: This workflow coordinates multiple specialized agents to ensure code quality before commits are made. The code-reviewer agent performs initial quality checks, test-automator ensures all tests pass, and deployment-engineer verifies production readiness. By orchestrating these agents sequentially with context passing, we prevent broken code from entering the repository while maintaining high velocity. The workflow supports both trunk-based and feature-branch strategies with configurable options for different team needs.]\n\n## Configuration\n\n**Target branch**: $ARGUMENTS (defaults to 'main' if not specified)\n\n**Supported flags**:\n- `--skip-tests`: Skip automated test execution (use with caution)\n- `--draft-pr`: Create PR as draft for work-in-progress\n- `--no-push`: Perform all checks but don't push to remote\n- `--squash`: Squash commits before pushing\n- `--conventional`: Enforce Conventional Commits format strictly\n- `--trunk-based`: Use trunk-based development workflow\n- `--feature-branch`: Use feature branch workflow (default)\n\n## Phase 1: Pre-Commit Review and Analysis\n\n### 1. Code Quality Assessment\n- Use Task tool with subagent_type=\"code-reviewer\"\n- Prompt: \"Review all uncommitted changes for code quality issues. Check for: 1) Code style violations, 2) Security vulnerabilities, 3) Performance concerns, 4) Missing error handling, 5) Incomplete implementations. Generate a detailed report with severity levels (critical/high/medium/low) and provide specific line-by-line feedback. Output format: JSON with {issues: [], summary: {critical: 0, high: 0, medium: 0, low: 0}, recommendations: []}\"\n- Expected output: Structured code review report for next phase\n\n### 2. Dependency and Breaking Change Analysis\n- Use Task tool with subagent_type=\"code-reviewer\"\n- Prompt: \"Analyze the changes for: 1) New dependencies or version changes, 2) Breaking API changes, 3) Database schema modifications, 4) Configuration changes, 5) Backward compatibility issues. Context from previous review: [insert issues summary]. Identify any changes that require migration scripts or documentation updates.\"\n- Context from previous: Code quality issues that might indicate breaking changes\n- Expected output: Breaking change assessment and migration requirements\n\n## Phase 2: Testing and Validation\n\n### 1. Test Execution and Coverage\n- Use Task tool with subagent_type=\"unit-testing::test-automator\"\n- Prompt: \"Execute all test suites for the modified code. Run: 1) Unit tests, 2) Integration tests, 3) End-to-end tests if applicable. Generate coverage report and identify any untested code paths. Based on review issues: [insert critical/high issues], ensure tests cover the problem areas. Provide test results in format: {passed: [], failed: [], skipped: [], coverage: {statements: %, branches: %, functions: %, lines: %}, untested_critical_paths: []}\"\n- Context from previous: Critical code review issues that need test coverage\n- Expected output: Complete test results and coverage metrics\n\n### 2. Test Recommendations and Gap Analysis\n- Use Task tool with subagent_type=\"unit-testing::test-automator\"\n- Prompt: \"Based on test results [insert summary] and code changes, identify: 1) Missing test scenarios, 2) Edge cases not covered, 3) Integration points needing verification, 4) Performance benchmarks needed. Generate test implementation recommendations prioritized by risk. Consider the breaking changes identified: [insert breaking changes].\"\n- Context from previous: Test results, breaking changes, untested paths\n- Expected output: Prioritized list of additional tests needed\n\n## Phase 3: Commit Message Generation\n\n### 1. Change Analysis and Categorization\n- Use Task tool with subagent_type=\"code-reviewer\"\n- Prompt: \"Analyze all changes and categorize them according to Conventional Commits specification. Identify the primary change type (feat/fix/docs/style/refactor/perf/test/build/ci/chore/revert) and scope. For changes: [insert file list and summary], determine if this should be a single commit or multiple atomic commits. Consider test results: [insert test summary].\"\n- Context from previous: Test results, code review summary\n- Expected output: Commit structure recommendation\n\n### 2. Conventional Commit Message Creation\n- Use Task tool with subagent_type=\"llm-application-dev::prompt-engineer\"\n- Prompt: \"Create Conventional Commits format message(s) based on categorization: [insert categorization]. Format: <type>(<scope>): <subject> with blank line then <body> explaining what and why (not how), then <footer> with BREAKING CHANGE: if applicable. Include: 1) Clear subject line (50 chars max), 2) Detailed body explaining rationale, 3) References to issues/tickets, 4) Co-authors if applicable. Consider the impact: [insert breaking changes if any].\"\n- Context from previous: Change categorization, breaking changes\n- Expected output: Properly formatted commit message(s)\n\n## Phase 4: Branch Strategy and Push Preparation\n\n### 1. Branch Management\n- Use Task tool with subagent_type=\"cicd-automation::deployment-engineer\"\n- Prompt: \"Based on workflow type [--trunk-based or --feature-branch], prepare branch strategy. For feature branch: ensure branch name follows pattern (feature|bugfix|hotfix)/<ticket>-<description>. For trunk-based: prepare for direct main push with feature flag strategy if needed. Current branch: [insert branch], target: [insert target branch]. Verify no conflicts with target branch.\"\n- Expected output: Branch preparation commands and conflict status\n\n### 2. Pre-Push Validation\n- Use Task tool with subagent_type=\"cicd-automation::deployment-engineer\"\n- Prompt: \"Perform final pre-push checks: 1) Verify all CI checks will pass, 2) Confirm no sensitive data in commits, 3) Validate commit signatures if required, 4) Check branch protection rules, 5) Ensure all review comments addressed. Test summary: [insert test results]. Review status: [insert review summary].\"\n- Context from previous: All previous validation results\n- Expected output: Push readiness confirmation or blocking issues\n\n## Phase 5: Pull Request Creation\n\n### 1. PR Description Generation\n- Use Task tool with subagent_type=\"documentation-generation::docs-architect\"\n- Prompt: \"Create comprehensive PR description including: 1) Summary of changes (what and why), 2) Type of change checklist, 3) Testing performed summary from [insert test results], 4) Screenshots/recordings if UI changes, 5) Deployment notes from [insert deployment considerations], 6) Related issues/tickets, 7) Breaking changes section if applicable: [insert breaking changes], 8) Reviewer checklist. Format as GitHub-flavored Markdown.\"\n- Context from previous: All validation results, test outcomes, breaking changes\n- Expected output: Complete PR description in Markdown\n\n### 2. PR Metadata and Automation Setup\n- Use Task tool with subagent_type=\"cicd-automation::deployment-engineer\"\n- Prompt: \"Configure PR metadata: 1) Assign appropriate reviewers based on CODEOWNERS, 2) Add labels (type, priority, component), 3) Link related issues, 4) Set milestone if applicable, 5) Configure merge strategy (squash/merge/rebase), 6) Set up auto-merge if all checks pass. Consider draft status: [--draft-pr flag]. Include test status: [insert test summary].\"\n- Context from previous: PR description, test results, review status\n- Expected output: PR configuration commands and automation rules\n\n## Success Criteria\n\n- ✅ All critical and high-severity code issues resolved\n- ✅ Test coverage maintained or improved (target: >80%)\n- ✅ All tests passing (unit, integration, e2e)\n- ✅ Commit messages follow Conventional Commits format\n- ✅ No merge conflicts with target branch\n- ✅ PR description complete with all required sections\n- ✅ Branch protection rules satisfied\n- ✅ Security scanning completed with no critical vulnerabilities\n- ✅ Performance benchmarks within acceptable thresholds\n- ✅ Documentation updated for any API changes\n\n## Rollback Procedures\n\nIn case of issues after merge:\n\n1. **Immediate Revert**: Create revert PR with `git revert <commit-hash>`\n2. **Feature Flag Disable**: If using feature flags, disable immediately\n3. **Hotfix Branch**: For critical issues, create hotfix branch from main\n4. **Communication**: Notify team via designated channels\n5. **Root Cause Analysis**: Document issue in postmortem template\n\n## Best Practices Reference\n\n- **Commit Frequency**: Commit early and often, but ensure each commit is atomic\n- **Branch Naming**: `(feature|bugfix|hotfix|docs|chore)/<ticket-id>-<brief-description>`\n- **PR Size**: Keep PRs under 400 lines for effective review\n- **Review Response**: Address review comments within 24 hours\n- **Merge Strategy**: Squash for feature branches, merge for release branches\n- **Sign-Off**: Require at least 2 approvals for main branch changes\n"
              },
              {
                "name": "/onboarding-report",
                "description": "Generate comprehensive onboarding report using project-analyzer agent",
                "path": "plugins/development/commands/onboarding-report.md",
                "frontmatter": {
                  "description": "Generate comprehensive onboarding report using project-analyzer agent"
                },
                "content": "## Task\n\nUse the Task tool to invoke the `development:project-analyzer` agent to generate a comprehensive onboarding report for this project.\n\nThe agent will:\n- Analyze project structure and directory organization\n- Identify database dependencies and schema relationships\n- Evaluate architectural patterns and design decisions\n- Assess module complexity and code organization\n- Delegate detailed analysis to specialized agents as needed\n- Produce a comprehensive onboarding report\n\nPass the following prompt to the agent:\n\n```\nAnalyze this project and generate a comprehensive onboarding report for a new developer joining the team. Include:\n1. Project structure and organization\n2. Technology stack and dependencies\n3. Architecture patterns and design decisions\n4. Database schema and data layer\n5. Module complexity assessment\n6. Developer onboarding guide with setup instructions\n7. Recommendations for areas to focus on\n```\n\nAfter the agent completes, present the findings to the user in a clear, structured format."
              },
              {
                "name": "/optimize-description",
                "description": "Transform a brief or vague prompt into a clear, specific, and actionable description suitable for Claude Code execution",
                "path": "plugins/development/commands/optimize-description.md",
                "frontmatter": {
                  "description": "Transform a brief or vague prompt into a clear, specific, and actionable description suitable for Claude Code execution"
                },
                "content": "## Task\n\nTransform the user's input prompt into a clear, specific, and actionable description optimized for Claude Code execution.\n\n### Requirements\n\n1. **Clarity**: Convert vague requests into specific, unambiguous instructions\n2. **Actionability**: Ensure the prompt clearly describes what needs to be done\n3. **Context**: Add relevant context that helps Claude Code understand the task better\n4. **Structure**: Break down complex requests into logical steps when needed\n5. **Language**: If input is in Japanese, translate to English while preserving intent\n\n### Process\n\n1. Analyze the user's input prompt\n2. Identify ambiguities, missing context, or vague language\n3. Enhance the prompt with:\n   - Specific technical details\n   - Clear success criteria\n   - Relevant constraints or preferences\n   - File paths or locations if applicable\n4. Output the optimized prompt in a clear, structured format\n\n### Arguments\n\n- `{{prompt}}` - The original prompt to optimize\n\n### Example Transformations\n\n**Before**: \"make it faster\"\n**After**: \"Analyze the performance bottlenecks in the application and implement specific optimizations. Profile the code to identify slow functions, optimize database queries, implement caching where appropriate, and measure the performance improvements.\"\n\n**Before**: \"add button\"\n**After**: \"Add a button component to [specify location]. The button should [specify functionality], use [specify styling approach], and handle [specify user interactions]. Follow the existing component patterns in the codebase.\"\n\n### Output Format\n\n**IMPORTANT**: Output must be formatted as a concise slash command description that fits within 1024 characters.\n\n**Format Requirements**:\n- Single-line or short paragraph description (max 1024 characters)\n- Clear, actionable language suitable for command descriptions\n- Focus on what the command does and key features\n- Omit unnecessary elaboration or examples in the output\n- If input is in Japanese, translate to English\n\n**Example Output** (for creating a code analysis command):\n\"Analyze code in a specified directory and generate a comprehensive report explaining functionality, architecture, and behavior. Scans files to identify entry points, design patterns, dependencies, and data flow. Accepts directory path as argument with optional flags: --depth (recursion level), --format (markdown/html/json), --include/--exclude (file patterns), --output (save location). Uses Explore agent for thorough analysis. Useful for onboarding, documentation, and understanding unfamiliar codebases.\"\n\nThe output should be ready to use directly as a `description:` field in a slash command definition."
              },
              {
                "name": "/review-docs",
                "description": "Review and validate documentation for format compliance, contextual consistency, editorial quality, and sensitive information leakage",
                "path": "plugins/development/commands/review-docs.md",
                "frontmatter": {
                  "description": "Review and validate documentation for format compliance, contextual consistency, editorial quality, and sensitive information leakage"
                },
                "content": "## Task\n\nPerform comprehensive documentation review and validation on the specified file or directory.\n\n### Review Checklist\n\n1. **Format Validation**\n   - Markdown syntax correctness\n   - Heading hierarchy and structure\n   - Code block formatting and language tags\n   - Link integrity (internal and external)\n   - List formatting consistency\n   - Table structure validity\n\n2. **Consistency Analysis**\n   - Terminology usage consistency\n   - Tone and voice alignment\n   - Cross-reference accuracy\n   - Version information alignment\n   - Naming convention adherence\n\n3. **Editorial Quality**\n   - Grammar and spelling\n   - Clarity and readability\n   - Technical accuracy\n   - Completeness of information\n   - Code example correctness\n   - Proper use of technical terms\n\n4. **Security Scan**\n   - API keys and tokens\n   - Database credentials\n   - Authentication secrets\n   - PII (Personally Identifiable Information)\n   - Internal URLs and endpoints\n   - Confidential business information\n   - Environment-specific details\n\n### Arguments\n\n- `{{target}}` - File path or directory to review (defaults to current directory)\n- `--format-only` - Only perform format validation\n- `--security-only` - Only perform security scan\n- `--consistency-only` - Only perform consistency analysis\n- `--editorial-only` - Only perform editorial review\n- `--fix-auto` - Automatically fix formatting issues where possible\n- `--report <path>` - Generate detailed report and save to specified path\n\n### Output\n\nProvide a structured report with:\n- **Summary**: Overall assessment and key findings count\n- **Critical Issues**: Security concerns and broken links\n- **Format Issues**: Syntax errors and structural problems\n- **Consistency Issues**: Terminology conflicts and cross-reference errors\n- **Editorial Suggestions**: Grammar, clarity, and completeness improvements\n- **Recommendations**: Prioritized action items with severity levels (Critical/High/Medium/Low)\n\n### Process\n\n1. Read the target documentation file(s)\n2. Run applicable validation checks based on flags\n3. Categorize findings by severity\n4. If `--fix-auto` is specified, apply automatic fixes to formatting issues\n5. Generate comprehensive report with actionable feedback\n6. If `--report` is specified, save the report to the designated path"
              },
              {
                "name": "/update-config",
                "description": "Update Claude Code configuration files (agents, skills, commands, hooks) based on their descriptions",
                "path": "plugins/development/commands/update-config.md",
                "frontmatter": {
                  "description": "Update Claude Code configuration files (agents, skills, commands, hooks) based on their descriptions"
                },
                "content": "## Task\n\nAnalyze and modify Claude Code configuration files to ensure they match their stated descriptions.\n\n### Process\n\n1. **Identify target files**\n   - Read the arguments to determine which files to update\n   - If no specific files mentioned, ask which configuration type to analyze (agents/skills/commands/hooks)\n\n2. **Analyze descriptions**\n   - Read each configuration file\n   - Extract the description from the frontmatter or header\n   - Compare the description with the actual implementation\n\n3. **Apply modifications**\n   - Update the file content to align with the description\n   - Ensure consistency in:\n     - Tool usage matches stated capabilities\n     - Instructions reflect the described behavior\n     - Examples align with the description\n     - Triggers (for skills) match the description\n\n4. **Maintain structure**\n   - Preserve existing frontmatter format\n   - Keep the overall file structure intact\n   - Follow plugin organization rules\n\n### Arguments\n- File paths or patterns to update (optional)\n- Configuration type: agents, skills, commands, or hooks (optional)\n- If no arguments provided, prompt the user to specify\n\n### Example Usage\n```\n/update-config plugins/development/agents/*.md\n/update-config --type skills\n/update-config .claude/agents/backend:postgres-specialist.md\n```"
              }
            ],
            "skills": [
              {
                "name": "brainstorming",
                "description": "Collaborative ideation and exploration before implementation. Triggers when creating features, building components, adding functionality, or starting creative work. Encourages brainstorming options, discussing trade-offs, and exploring possibilities together with the user before diving into code.",
                "path": "plugins/development/skills/brainstorming/SKILL.md",
                "frontmatter": {
                  "name": "brainstorming",
                  "description": "Collaborative ideation and exploration before implementation. Triggers when creating features, building components, adding functionality, or starting creative work. Encourages brainstorming options, discussing trade-offs, and exploring possibilities together with the user before diving into code."
                },
                "content": "# Brainstorming\n\n## Purpose\n\nThis skill promotes collaborative brainstorming and creative exploration **before** jumping into implementation. It encourages Claude to think through options, discuss possibilities, and co-create solutions with users rather than immediately writing code.\n\n## When to Use\n\nUse this skill BEFORE starting implementation work on:\n\n- **New features** - Exploring different approaches and design patterns\n- **New components** - Discussing architecture, API design, and integration\n- **Creative work** - Brainstorming solutions, evaluating alternatives, greenfield exploration\n- **Functionality additions** - Considering multiple implementation paths\n\n## Philosophy\n\nGreat software emerges from thoughtful exploration, not rushed implementation. Brainstorming means:\n\n- 🤝 **Collaboration** - Working with the user to explore ideas together\n- 💡 **Ideation** - Generating multiple options before committing to one\n- 🎯 **Trade-offs** - Discussing pros/cons of different approaches\n- 🗺️ **Context** - Understanding the bigger picture and constraints\n- ✨ **Creativity** - Thinking beyond the obvious first solution\n\n## Brainstorming Approaches\n\n### 1. EnterPlanMode (For deep exploration)\n\nUse when you need to thoroughly explore the codebase and design options:\n\n```markdown\nLet me explore the codebase and brainstorm some implementation approaches.\n```\n\n**In plan mode:**\n- Discover existing patterns and conventions\n- Identify multiple possible approaches\n- Sketch out different architectural options\n- Present trade-offs for user consideration\n- Collaborate on the best path forward\n\n### 2. AskUserQuestion (For collaborative ideation)\n\nUse to brainstorm options and gather user preferences:\n\n```markdown\nLet me brainstorm some options with you.\n```\n\n**Discuss:**\n- Different architectural approaches\n- Technology/library alternatives and trade-offs\n- UI/UX patterns and user experience considerations\n- Performance vs simplicity trade-offs\n- Integration strategies\n- Future extensibility needs\n\n### 3. Inline Exploration (For quick brainstorming)\n\nFor smaller features with a few clear options:\n- Present 2-3 possible approaches\n- Highlight key trade-offs\n- Ask for user preference\n- Confirm direction before coding\n\n## When NOT to Brainstorm\n\nSkip brainstorming for:\n\n- **Bug fixes** - Clear problems with known solutions\n- **Typo corrections** - Trivial text changes\n- **Documentation updates** - Straightforward doc improvements\n- **Simple refactoring** - Code cleanup with obvious improvements\n- **Explicit specifications** - User has already done the brainstorming\n\n## Examples\n\n### ✅ GOOD - Collaborative Brainstorming\n\n**User:** \"Add authentication to the API\"\n\n**Claude:**\n> Let me brainstorm some authentication approaches with you. I can see a few options:\n>\n> 1. **JWT-based auth** - Stateless, scalable, good for microservices\n> 2. **Session-based auth** - Simpler, works well with SSR, easier to revoke\n> 3. **OAuth2 integration** - If you need social login or third-party auth\n>\n> What's your use case? Do you need:\n> - Social login (Google, GitHub, etc.)?\n> - Just username/password?\n> - Multi-device sessions?\n> - Microservices architecture?\n\n---\n\n**User:** \"Create a user dashboard component\"\n\n**Claude:**\n> Before building the dashboard, let's brainstorm the approach together:\n>\n> **Data Architecture:**\n> - Should we fetch all dashboard data at once, or load sections progressively?\n> - Real-time updates needed, or static data on load?\n>\n> **Component Design:**\n> - Single monolithic component, or composed from smaller widgets?\n> - What level of customization should users have?\n>\n> **Integration:**\n> - Should this use existing design system components?\n> - Any specific layouts or grid systems you're using?\n>\n> Let me know your thoughts, and I'll explore the codebase to see what patterns you already have!\n\n### ❌ BAD - Skips Brainstorming\n\n**User:** \"Add a dark mode toggle\"\n\n**Claude:**\n> I'll add a dark mode toggle to your app.\n> *[Immediately writes code without discussing placement, theme management strategy, persistence approach, etc.]*\n\n**Better approach:**\n> Let's brainstorm the dark mode implementation:\n>\n> **Approach options:**\n> 1. CSS variables with data attribute toggle\n> 2. Tailwind dark: class variants\n> 3. CSS-in-JS theme provider\n>\n> **Considerations:**\n> - Where should the toggle live? (Header, settings, both?)\n> - Persist preference? (localStorage, user account, system preference?)\n> - Sync with system dark mode setting?\n>\n> What fits your existing setup best?\n\n## Brainstorming Flow\n\n```\nUser requests new feature/component\n         |\n         v\nIs this a bug fix or trivial change?\n         |\n    No   |   Yes → Proceed directly\n         v\nPresent 2-3 possible approaches\n         |\n         v\nDiscuss trade-offs and constraints\n         |\n         v\nUser provides preference/guidance\n         |\n         v\nComplex? → EnterPlanMode for deep dive\nSimple? → Quick confirmation and proceed\n```\n\n## Integration with Tools\n\nThis skill leverages:\n\n- **EnterPlanMode** - Deep exploration and multi-option design\n- **AskUserQuestion** - Collaborative option discussion\n- **TodoWrite** - Organizing implementation after alignment\n\n## Brainstorming Best Practices\n\n### DO:\n✅ Present multiple viable options\n✅ Explain trade-offs clearly\n✅ Ask about constraints and preferences\n✅ Consider future extensibility\n✅ Explore the codebase to understand patterns\n✅ Think beyond the first obvious solution\n\n### DON'T:\n❌ Present only one option as \"the way\"\n❌ Make technology choices without discussion\n❌ Ignore existing codebase patterns\n❌ Jump to code before alignment\n❌ Over-engineer with unnecessary options\n❌ Paralyze with too many choices (2-4 options is ideal)\n\n## Effective Brainstorming Questions\n\n### For Features:\n- What's the core user need we're solving?\n- What's the simplest version that would work?\n- What future extensions might we need?\n- What are the performance/security implications?\n\n### For Components:\n- How will this fit into the existing component hierarchy?\n- What props/API would make this most reusable?\n- Should this be a controlled or uncontrolled component?\n- What edge cases or states need handling?\n\n### For Architecture:\n- What patterns are we already using?\n- What scale are we designing for?\n- What's the maintenance burden of each option?\n- How does this integrate with our deployment setup?\n\n## Measuring Success\n\nBrainstorming is effective when:\n- ✅ Users feel like active collaborators, not just requesters\n- ✅ Multiple options are considered, not just the first idea\n- ✅ Decisions are made with clear understanding of trade-offs\n- ✅ Implementation matches user's actual needs and constraints\n- ✅ Solutions are well-suited to the existing codebase\n\n## Common Brainstorming Patterns\n\n### Pattern 1: The Three Options\n\nPresent three levels of implementation:\n- **Minimal** - Simplest solution, fastest to implement\n- **Standard** - Balanced approach with good extensibility\n- **Comprehensive** - Full-featured with all edge cases\n\n### Pattern 2: The Trade-Off Matrix\n\nCompare options across key dimensions:\n- Complexity vs Features\n- Performance vs Developer Experience\n- Flexibility vs Simplicity\n- Immediate needs vs Future extensibility\n\n### Pattern 3: The Discovery Session\n\nFor unclear requirements:\n1. Explore codebase to understand context\n2. Present what you found\n3. Propose 2-3 directions based on discoveries\n4. Collaborate on the best fit\n\n## Related Skills\n\n- **EnterPlanMode** - Deep planning and exploration\n- **AskUserQuestion** - Collaborative decision making\n- **TodoWrite** - Organizing work after brainstorming\n\n---\n\n**Remember:** The best code comes from collaborative thinking, not solo assumptions. Brainstorm first, implement second. 🧠✨"
              },
              {
                "name": "skill-developer",
                "description": "Create and manage Claude Code skills following Anthropic best practices. Use when creating new skills, modifying skill-rules.json, understanding trigger patterns, working with hooks, debugging skill activation, or implementing progressive disclosure. Covers skill structure, YAML frontmatter, trigger types (keywords, intent patterns, file paths, content patterns), enforcement levels (block, suggest, warn), hook mechanisms (UserPromptSubmit, PreToolUse), session tracking, and the 500-line rule.",
                "path": "plugins/development/skills/skill-developer/SKILL.md",
                "frontmatter": {
                  "name": "skill-developer",
                  "description": "Create and manage Claude Code skills following Anthropic best practices. Use when creating new skills, modifying skill-rules.json, understanding trigger patterns, working with hooks, debugging skill activation, or implementing progressive disclosure. Covers skill structure, YAML frontmatter, trigger types (keywords, intent patterns, file paths, content patterns), enforcement levels (block, suggest, warn), hook mechanisms (UserPromptSubmit, PreToolUse), session tracking, and the 500-line rule."
                },
                "content": "# Skill Developer Guide\n\n## Purpose\n\nComprehensive guide for creating and managing skills in Claude Code with auto-activation system, following Anthropic's official best practices including the 500-line rule and progressive disclosure pattern.\n\n## When to Use This Skill\n\nAutomatically activates when you mention:\n- Creating or adding skills\n- Modifying skill triggers or rules\n- Understanding how skill activation works\n- Debugging skill activation issues\n- Working with skill-rules.json\n- Hook system mechanics\n- Claude Code best practices\n- Progressive disclosure\n- YAML frontmatter\n- 500-line rule\n\n---\n\n## System Overview\n\n### Two-Hook Architecture\n\n**1. UserPromptSubmit Hook** (Proactive Suggestions)\n- **File**: `.claude/hooks/skill-activation-prompt.ts`\n- **Trigger**: BEFORE Claude sees user's prompt\n- **Purpose**: Suggest relevant skills based on keywords + intent patterns\n- **Method**: Injects formatted reminder as context (stdout → Claude's input)\n- **Use Cases**: Topic-based skills, implicit work detection\n\n**2. Stop Hook - Error Handling Reminder** (Gentle Reminders)\n- **File**: `.claude/hooks/error-handling-reminder.ts`\n- **Trigger**: AFTER Claude finishes responding\n- **Purpose**: Gentle reminder to self-assess error handling in code written\n- **Method**: Analyzes edited files for risky patterns, displays reminder if needed\n- **Use Cases**: Error handling awareness without blocking friction\n\n**Philosophy Change (2025-10-27):** We moved away from blocking PreToolUse for Sentry/error handling. Instead, use gentle post-response reminders that don't block workflow but maintain code quality awareness.\n\n### Configuration File\n\n**Location**: `.claude/skills/skill-rules.json`\n\nDefines:\n- All skills and their trigger conditions\n- Enforcement levels (block, suggest, warn)\n- File path patterns (glob)\n- Content detection patterns (regex)\n- Skip conditions (session tracking, file markers, env vars)\n\n---\n\n## Skill Types\n\n### 1. Guardrail Skills\n\n**Purpose:** Enforce critical best practices that prevent errors\n\n**Characteristics:**\n- Type: `\"guardrail\"`\n- Enforcement: `\"block\"`\n- Priority: `\"critical\"` or `\"high\"`\n- Block file edits until skill used\n- Prevent common mistakes (column names, critical errors)\n- Session-aware (don't repeat nag in same session)\n\n**Examples:**\n- `database-verification` - Verify table/column names before Prisma queries\n- `frontend-dev-guidelines` - Enforce React/TypeScript patterns\n\n**When to Use:**\n- Mistakes that cause runtime errors\n- Data integrity concerns\n- Critical compatibility issues\n\n### 2. Domain Skills\n\n**Purpose:** Provide comprehensive guidance for specific areas\n\n**Characteristics:**\n- Type: `\"domain\"`\n- Enforcement: `\"suggest\"`\n- Priority: `\"high\"` or `\"medium\"`\n- Advisory, not mandatory\n- Topic or domain-specific\n- Comprehensive documentation\n\n**Examples:**\n- `backend-dev-guidelines` - Node.js/Express/TypeScript patterns\n- `frontend-dev-guidelines` - React/TypeScript best practices\n- `error-tracking` - Sentry integration guidance\n\n**When to Use:**\n- Complex systems requiring deep knowledge\n- Best practices documentation\n- Architectural patterns\n- How-to guides\n\n---\n\n## Quick Start: Creating a New Skill\n\n### Step 1: Create Skill File\n\n**Location:** `.claude/skills/{skill-name}/SKILL.md`\n\n**Template:**\n```markdown\n---\nname: my-new-skill\ndescription: Brief description including keywords that trigger this skill. Mention topics, file types, and use cases. Be explicit about trigger terms.\n---\n\n# My New Skill\n\n## Purpose\nWhat this skill helps with\n\n## When to Use\nSpecific scenarios and conditions\n\n## Key Information\nThe actual guidance, documentation, patterns, examples\n```\n\n**Best Practices:**\n- ✅ **Name**: Lowercase, hyphens, gerund form (verb + -ing) preferred\n- ✅ **Description**: Include ALL trigger keywords/phrases (max 1024 chars)\n- ✅ **Content**: Under 500 lines - use reference files for details\n- ✅ **Examples**: Real code examples\n- ✅ **Structure**: Clear headings, lists, code blocks\n\n### Step 2: Add to skill-rules.json\n\nSee [SKILL_RULES_REFERENCE.md](SKILL_RULES_REFERENCE.md) for complete schema.\n\n**Basic Template:**\n```json\n{\n  \"my-new-skill\": {\n    \"type\": \"domain\",\n    \"enforcement\": \"suggest\",\n    \"priority\": \"medium\",\n    \"promptTriggers\": {\n      \"keywords\": [\"keyword1\", \"keyword2\"],\n      \"intentPatterns\": [\"(create|add).*?something\"]\n    }\n  }\n}\n```\n\n### Step 3: Test Triggers\n\n**Test UserPromptSubmit:**\n```bash\necho '{\"session_id\":\"test\",\"prompt\":\"your test prompt\"}' | \\\n  npx tsx .claude/hooks/skill-activation-prompt.ts\n```\n\n**Test PreToolUse:**\n```bash\ncat <<'EOF' | npx tsx .claude/hooks/skill-verification-guard.ts\n{\"session_id\":\"test\",\"tool_name\":\"Edit\",\"tool_input\":{\"file_path\":\"test.ts\"}}\nEOF\n```\n\n### Step 4: Refine Patterns\n\nBased on testing:\n- Add missing keywords\n- Refine intent patterns to reduce false positives\n- Adjust file path patterns\n- Test content patterns against actual files\n\n### Step 5: Follow Anthropic Best Practices\n\n✅ Keep SKILL.md under 500 lines\n✅ Use progressive disclosure with reference files\n✅ Add table of contents to reference files > 100 lines\n✅ Write detailed description with trigger keywords\n✅ Test with 3+ real scenarios before documenting\n✅ Iterate based on actual usage\n\n---\n\n## Enforcement Levels\n\n### BLOCK (Critical Guardrails)\n\n- Physically prevents Edit/Write tool execution\n- Exit code 2 from hook, stderr → Claude\n- Claude sees message and must use skill to proceed\n- **Use For**: Critical mistakes, data integrity, security issues\n\n**Example:** Database column name verification\n\n### SUGGEST (Recommended)\n\n- Reminder injected before Claude sees prompt\n- Claude is aware of relevant skills\n- Not enforced, just advisory\n- **Use For**: Domain guidance, best practices, how-to guides\n\n**Example:** Frontend development guidelines\n\n### WARN (Optional)\n\n- Low priority suggestions\n- Advisory only, minimal enforcement\n- **Use For**: Nice-to-have suggestions, informational reminders\n\n**Rarely used** - most skills are either BLOCK or SUGGEST.\n\n---\n\n## Skip Conditions & User Control\n\n### 1. Session Tracking\n\n**Purpose:** Don't nag repeatedly in same session\n\n**How it works:**\n- First edit → Hook blocks, updates session state\n- Second edit (same session) → Hook allows\n- Different session → Blocks again\n\n**State File:** `.claude/hooks/state/skills-used-{session_id}.json`\n\n### 2. File Markers\n\n**Purpose:** Permanent skip for verified files\n\n**Marker:** `// @skip-validation`\n\n**Usage:**\n```typescript\n// @skip-validation\nimport { PrismaService } from './prisma';\n// This file has been manually verified\n```\n\n**NOTE:** Use sparingly - defeats the purpose if overused\n\n### 3. Environment Variables\n\n**Purpose:** Emergency disable, temporary override\n\n**Global disable:**\n```bash\nexport SKIP_SKILL_GUARDRAILS=true  # Disables ALL PreToolUse blocks\n```\n\n**Skill-specific:**\n```bash\nexport SKIP_DB_VERIFICATION=true\nexport SKIP_ERROR_REMINDER=true\n```\n\n---\n\n## Testing Checklist\n\nWhen creating a new skill, verify:\n\n- [ ] Skill file created in `.claude/skills/{name}/SKILL.md`\n- [ ] Proper frontmatter with name and description\n- [ ] Entry added to `skill-rules.json`\n- [ ] Keywords tested with real prompts\n- [ ] Intent patterns tested with variations\n- [ ] File path patterns tested with actual files\n- [ ] Content patterns tested against file contents\n- [ ] Block message is clear and actionable (if guardrail)\n- [ ] Skip conditions configured appropriately\n- [ ] Priority level matches importance\n- [ ] No false positives in testing\n- [ ] No false negatives in testing\n- [ ] Performance is acceptable (<100ms or <200ms)\n- [ ] JSON syntax validated: `jq . skill-rules.json`\n- [ ] **SKILL.md under 500 lines** ⭐\n- [ ] Reference files created if needed\n- [ ] Table of contents added to files > 100 lines\n\n---\n\n## Reference Files\n\nFor detailed information on specific topics, see:\n\n### [TRIGGER_TYPES.md](TRIGGER_TYPES.md)\nComplete guide to all trigger types:\n- Keyword triggers (explicit topic matching)\n- Intent patterns (implicit action detection)\n- File path triggers (glob patterns)\n- Content patterns (regex in files)\n- Best practices and examples for each\n- Common pitfalls and testing strategies\n\n### [SKILL_RULES_REFERENCE.md](SKILL_RULES_REFERENCE.md)\nComplete skill-rules.json schema:\n- Full TypeScript interface definitions\n- Field-by-field explanations\n- Complete guardrail skill example\n- Complete domain skill example\n- Validation guide and common errors\n\n### [HOOK_MECHANISMS.md](HOOK_MECHANISMS.md)\nDeep dive into hook internals:\n- UserPromptSubmit flow (detailed)\n- PreToolUse flow (detailed)\n- Exit code behavior table (CRITICAL)\n- Session state management\n- Performance considerations\n\n### [TROUBLESHOOTING.md](TROUBLESHOOTING.md)\nComprehensive debugging guide:\n- Skill not triggering (UserPromptSubmit)\n- PreToolUse not blocking\n- False positives (too many triggers)\n- Hook not executing at all\n- Performance issues\n\n### [PATTERNS_LIBRARY.md](PATTERNS_LIBRARY.md)\nReady-to-use pattern collection:\n- Intent pattern library (regex)\n- File path pattern library (glob)\n- Content pattern library (regex)\n- Organized by use case\n- Copy-paste ready\n\n### [ADVANCED.md](ADVANCED.md)\nFuture enhancements and ideas:\n- Dynamic rule updates\n- Skill dependencies\n- Conditional enforcement\n- Skill analytics\n- Skill versioning\n\n---\n\n## Quick Reference Summary\n\n### Create New Skill (5 Steps)\n\n1. Create `.claude/skills/{name}/SKILL.md` with frontmatter\n2. Add entry to `.claude/skills/skill-rules.json`\n3. Test with `npx tsx` commands\n4. Refine patterns based on testing\n5. Keep SKILL.md under 500 lines\n\n### Trigger Types\n\n- **Keywords**: Explicit topic mentions\n- **Intent**: Implicit action detection\n- **File Paths**: Location-based activation\n- **Content**: Technology-specific detection\n\nSee [TRIGGER_TYPES.md](TRIGGER_TYPES.md) for complete details.\n\n### Enforcement\n\n- **BLOCK**: Exit code 2, critical only\n- **SUGGEST**: Inject context, most common\n- **WARN**: Advisory, rarely used\n\n### Skip Conditions\n\n- **Session tracking**: Automatic (prevents repeated nags)\n- **File markers**: `// @skip-validation` (permanent skip)\n- **Env vars**: `SKIP_SKILL_GUARDRAILS` (emergency disable)\n\n### Anthropic Best Practices\n\n✅ **500-line rule**: Keep SKILL.md under 500 lines\n✅ **Progressive disclosure**: Use reference files for details\n✅ **Table of contents**: Add to reference files > 100 lines\n✅ **One level deep**: Don't nest references deeply\n✅ **Rich descriptions**: Include all trigger keywords (max 1024 chars)\n✅ **Test first**: Build 3+ evaluations before extensive documentation\n✅ **Gerund naming**: Prefer verb + -ing (e.g., \"processing-pdfs\")\n\n### Troubleshoot\n\nTest hooks manually:\n```bash\n# UserPromptSubmit\necho '{\"prompt\":\"test\"}' | npx tsx .claude/hooks/skill-activation-prompt.ts\n\n# PreToolUse\ncat <<'EOF' | npx tsx .claude/hooks/skill-verification-guard.ts\n{\"tool_name\":\"Edit\",\"tool_input\":{\"file_path\":\"test.ts\"}}\nEOF\n```\n\nSee [TROUBLESHOOTING.md](TROUBLESHOOTING.md) for complete debugging guide.\n\n---\n\n## Related Files\n\n**Configuration:**\n- `.claude/skills/skill-rules.json` - Master configuration\n- `.claude/hooks/state/` - Session tracking\n- `.claude/settings.json` - Hook registration\n\n**Hooks:**\n- `.claude/hooks/skill-activation-prompt.ts` - UserPromptSubmit\n- `.claude/hooks/error-handling-reminder.ts` - Stop event (gentle reminders)\n\n**All Skills:**\n- `.claude/skills/*/SKILL.md` - Skill content files\n\n---\n\n**Skill Status**: COMPLETE - Restructured following Anthropic best practices ✅\n**Line Count**: < 500 (following 500-line rule) ✅\n**Progressive Disclosure**: Reference files for detailed information ✅\n\n**Next**: Create more skills, refine patterns based on usage"
              }
            ]
          }
        ]
      }
    }
  ]
}