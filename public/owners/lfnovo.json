{
  "owner": {
    "id": "lfnovo",
    "display_name": "Luis Novo",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/579178?u=6c2949fe733f6e3ac1b436861a07555d031b866a&v=4",
    "url": "https://github.com/lfnovo",
    "bio": "Someone that is addicted to learning new stuff, committed to helping as many people as possible to achieve their full potential. Open Source lover!",
    "stats": {
      "total_repos": 1,
      "total_plugins": 1,
      "total_commands": 6,
      "total_skills": 0,
      "total_stars": 1,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "lfnovo/por-marketplace",
      "url": "https://github.com/lfnovo/por-marketplace",
      "description": "Claude Code marketplace for the Product on Rails methodology",
      "homepage": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2025-12-16T20:03:41Z",
        "created_at": "2025-12-15T22:33:26Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 207
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 24
        },
        {
          "path": "LICENSE",
          "type": "blob",
          "size": 1066
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 543
        },
        {
          "path": "por-dev",
          "type": "tree",
          "size": null
        },
        {
          "path": "por-dev/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "por-dev/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 180
        },
        {
          "path": "por-dev/README.md",
          "type": "blob",
          "size": 6793
        },
        {
          "path": "por-dev/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "por-dev/commands/all-tools.md",
          "type": "blob",
          "size": 194
        },
        {
          "path": "por-dev/commands/design.md",
          "type": "blob",
          "size": 11565
        },
        {
          "path": "por-dev/commands/discover.md",
          "type": "blob",
          "size": 6397
        },
        {
          "path": "por-dev/commands/fast",
          "type": "tree",
          "size": null
        },
        {
          "path": "por-dev/commands/fast/bug.md",
          "type": "blob",
          "size": 3144
        },
        {
          "path": "por-dev/commands/fast/chore.md",
          "type": "blob",
          "size": 2459
        },
        {
          "path": "por-dev/commands/fast/feature.md",
          "type": "blob",
          "size": 4056
        },
        {
          "path": "por-dev/commands/implement.md",
          "type": "blob",
          "size": 1208
        },
        {
          "path": "por-dev/commands/plan.md",
          "type": "blob",
          "size": 14594
        },
        {
          "path": "por-dev/commands/prime.md",
          "type": "blob",
          "size": 289
        }
      ],
      "marketplace": {
        "name": "por-marketplace",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "Luis Novo"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "por-dev",
            "description": "A development plugin for the Product on Rails methodology",
            "source": "./por-dev",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add lfnovo/por-marketplace",
              "/plugin install por-dev@por-marketplace"
            ],
            "signals": {
              "stars": 1,
              "forks": 0,
              "pushed_at": "2025-12-16T20:03:41Z",
              "created_at": "2025-12-15T22:33:26Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/all-tools",
                "description": null,
                "path": "por-dev/commands/all-tools.md",
                "frontmatter": null,
                "content": "# List All Tools\n\nList all availagle tools detailed in your system prompt. Display them in bullet points. Display them in typescript function signature format and suffix the purpose of the tool."
              },
              {
                "name": "/design",
                "description": "Execute technical planning and architecture design for the feature",
                "path": "por-dev/commands/design.md",
                "frontmatter": {
                  "description": "Execute technical planning and architecture design for the feature",
                  "argument-hint": [
                    "optional-context"
                  ],
                  "model": "opus"
                },
                "content": "# Design Command\n\nThis command takes the requirements from `specs/<feature_slug>/spec.md` and transforms them into a concrete technical architecture by solving all its open questions and implementation ambiguities.\n\n## User Input\n\nArguments:\n```text\n$ARGUMENTS\n```\n\nYou **MUST** consider the user input before proceeding (if not empty).\n\n## Prerequisites\n\nBefore running this command:\n- ‚úÖ Feature specs must exist at `./specs/<feature_slug>/specs.md`\n- ‚úÖ You should be on the correct feature branch\n- ‚ùå Do NOT run this if specs are incomplete or have unresolved clarifications\n\n## Execution Flow\n\n### Step 0: Load Context\n\n1. Identify the current feature by checking:\n   - Current git branch name (if using git)\n   - Ask user to specify feature if unclear\n\n2. Load the specs file at `./specs/<feature_slug>/specs.md`\n\n3. Verify specs are complete:\n   - No `[NEEDS CLARIFICATION]` markers remaining\n   - All user stories defined with priorities\n   - Success criteria are clear\n   - If incomplete, STOP and tell user to run `/discover` first\n\n### Step 1: Technical Research\n\nBased on the requirements in specs.md, identify what you need to research:\n\n**Research Triggers:**\n- New libraries/frameworks mentioned that you're not familiar with\n- Integration with external services/APIs\n- Unfamiliar patterns or architectural approaches\n- Performance requirements that need specific solutions\n- Security/compliance requirements needing validation\n\n**Research Tools Available:**\n- **WebSearch**: For general technical information, library documentation, best practices\n- **Context7**: For library-specific documentation and examples\n- **Perplexity**: For recent technical decisions, comparisons, and up-to-date practices\n\n**Research Process:**\n1. List what needs research (be specific: \"How to implement rate limiting in xxxx framework\" not \"research rate limiting\")\n2. For each item, use the appropriate tool and synthesize findings\n3. Document key decisions as you research (don't wait until the end)\n\n**Important:** Don't research things you already know well. Focus on gaps in your knowledge that would affect implementation quality.\n\n### Step 2: Codebase Analysis\n\nUnderstand the existing codebase structure and patterns:\n\n**Discovery Questions:**\n- What is the existing tech stack? (language, frameworks, key libraries)\n- What are the established patterns? (file structure, naming conventions, architectural patterns)\n- Where do similar features live in the codebase?\n- What existing components can be reused?\n- What are the testing patterns?\n\n**Analysis Tools:**\n- Use available MCP tools to search and read code\n- Look for similar features to understand patterns\n- Identify the main directories and their purposes\n- Note any conventions (naming, structure, imports)\n\n**Tips:**\n- Search for keywords from your specs to find related code\n- Look at recent commits/PRs for active patterns\n- Check for README files explaining structure\n- Identify configuration files and their purposes\n\n### Step 3: Architecture Design\n\nNow design the architecture for this feature:\n\n**What to Define:**\n\n1. **Component Structure:**\n   - What new files/modules need to be created?\n   - What existing files need modification?\n   - How do components relate to each other?\n   - Where does each user story map to in the code?\n\n2. **Technical Decisions:**\n   - Which libraries/frameworks to use (with rationale)\n   - Which patterns to follow (with justification)\n   - How to handle edge cases\n   - Performance considerations\n   - Security considerations\n\n3. **Integration Points:**\n   - How does this feature integrate with existing code?\n   - What APIs/interfaces need to be defined?\n   - What side effects or dependencies exist?\n\n4. **Data Flow:**\n   - How does data move through the system?\n   - What transformations occur?\n   - Where is state managed?\n\n**Architecture Principles:**\n- Follow existing codebase patterns (don't reinvent)\n- Prefer simplicity over cleverness\n- Consider testability\n- Think about maintenance and debugging\n- Address non-functional requirements (performance, security, etc.)\n\n### Step 4: Generate architecture.md\n\nCreate `./specs/<feature_slug>/architecture.md` with this structure:\n\n```markdown\n# Architecture: [FEATURE NAME]\n\n**Feature**: [Feature name]\n**Date**: [Current date]\n**Branch**: [feature branch name]\n**Specs**: [Link to specs.md]\n\n## Summary\n\n[2-3 sentence overview: what we're building and the core technical approach]\n\n## Technical Context\n\n**Language/Stack**: [e.g., Python 3.11 + FastAPI, TypeScript + React, etc.]\n**Key Dependencies**: [Libraries/frameworks being used or added]\n**Storage**: [Database, files, cache - if applicable]\n**Testing**: [Testing approach and tools]\n**Platform**: [Where this runs - server, browser, mobile, etc.]\n\n## Technical Decisions\n\n### Decision 1: [Decision Title]\n\n**What**: [What was decided]\n**Why**: [Rationale for this decision]\n**Alternatives Considered**: [What else was considered and why rejected]\n**Trade-offs**: [What we gain vs what we lose]\n\n[Repeat for each major technical decision]\n\n## Architecture Overview\n\n[High-level description of how the system works before and after this change]\n\n### Component Structure\n\n**New Files/Modules:**\n```\npath/to/new/file.ext - Purpose and responsibility\npath/to/another/file.ext - Purpose and responsibility\n```\n\n**Modified Files:**\n```\npath/to/existing/file.ext - What changes and why\n```\n\n### Component Relationships\n\n[Describe how components interact - can use bullet points or simple diagrams]\n\n### Data Flow\n\n[Describe how data moves through the system for key user stories]\n\n## Implementation Approach\n\n### User Story Mapping\n\n**US1 (P1): [Story Title]**\n- Files involved: [list]\n- Key components: [list]\n- Dependencies: [if any]\n- Testing approach: [how to verify]\n\n**US2 (P2): [Story Title]**\n[Same structure]\n\n### File Structure\n\n```\n[Show the relevant part of the directory structure with new/modified files marked]\n\nproject/\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ [existing]/\n‚îÇ   ‚îú‚îÄ‚îÄ [new-module]/          # NEW\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py       # NEW\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ core.py           # NEW\n‚îÇ   ‚îî‚îÄ‚îÄ [existing-file.py]    # MODIFIED\n‚îî‚îÄ‚îÄ tests/\n    ‚îî‚îÄ‚îÄ test_new_feature.py   # NEW\n```\n\n## Integration Points\n\n[Describe how this feature integrates with existing code]\n\n- **Integration with [Component A]**: [How and why]\n- **New APIs/Interfaces**: [What's exposed]\n- **Dependencies**: [What this feature depends on]\n\n## Technical Constraints\n\n- [Constraint 1: e.g., Must maintain backward compatibility with v1 API]\n- [Constraint 2: e.g., Response time must be <200ms]\n- [Constraint 3: e.g., Must work offline]\n\n## Risks & Mitigations\n\n| Risk | Impact | Mitigation |\n|------|--------|------------|\n| [Risk description] | [High/Med/Low] | [How we'll handle it] |\n\n## Open Questions\n\n[If any technical questions remain that need resolution before implementation]\n\n- [ ] Question 1\n- [ ] Question 2\n\n## Next Steps\n\n1. Review this architecture with stakeholders\n2. Resolve any open questions\n3. Run `/tasks` to break down into implementation tasks\n```\n\n### Step 5: Generate contracts.md (Optional)\n\n**Only create this file if the feature involves:**\n- External APIs or services\n- Data models with validation rules\n- Integration contracts with other systems\n- Complex request/response formats\n\nIf needed, create `./specs/<feature_slug>/contracts.md`:\n\n```markdown\n# Contracts: [FEATURE NAME]\n\n**Feature**: [Feature name]\n**Date**: [Current date]\n\n## Data Models\n\n### [Entity Name]\n\n**Purpose**: [What this represents]\n\n**Attributes:**\n- `field_name` (type): Description, validation rules\n- `another_field` (type): Description\n\n**Example:**\n```json\n{\n  \"field_name\": \"value\",\n  \"another_field\": 123\n}\n```\n\n[Repeat for each entity]\n\n## API Contracts\n\n### [Endpoint Name]\n\n**Endpoint**: `POST /api/path`\n**Purpose**: [What this does]\n\n**Request:**\n```json\n{\n  \"param1\": \"value\",\n  \"param2\": 123\n}\n```\n\n**Response (Success - 200):**\n```json\n{\n  \"result\": \"success\",\n  \"data\": {}\n}\n```\n\n**Response (Error - 400):**\n```json\n{\n  \"error\": \"Error message\"\n}\n```\n\n**Validation Rules:**\n- param1: Required, must be non-empty string\n- param2: Required, must be positive integer\n\n[Repeat for each endpoint/contract]\n\n## Integration Contracts\n\n[If integrating with external services, document the contract/expectations]\n\n### [Service Name]\n\n**What we expect:**\n- Input format: [describe]\n- Output format: [describe]\n- Error handling: [describe]\n\n## State Transitions\n\n[If there are complex state machines or workflows, document them]\n\n[Current State] --[Action]--> [New State]\n```\n\n### Step 6 Final Review & Report\n\nPresent to the user:\n\n1. **Summary of architecture:**\n   - Core technical approach\n   - Major decisions made\n   - Key components involved\n\n2. **Files generated:**\n   - Link to `architecture.md`\n   - Link to `contracts.md` (if created)\n   - Agent file updated (CLAUDE.md or AGENTS.md)\n\n3. **Key decisions to review:**\n   - List the most important architectural decisions\n   - Ask if user wants to discuss or adjust anything\n\n4. **Next steps:**\n   - Suggest reviewing the architecture.md\n   - Ask if they want to proceed to `/tasks` or iterate on architecture\n   - Mention any open questions that need resolution\n\n## Guidelines\n\n### Research Guidelines\n\n**When to use each tool:**\n- **WebSearch**: General information, official docs, Stack Overflow patterns\n- **Context7**: Library-specific docs, API references, code examples\n- **Perplexity**: Recent best practices, \"what's the latest way to...\", comparisons\n\n**How to research efficiently:**\n- Be specific in search queries\n- Look for official documentation first\n- Cross-reference multiple sources for important decisions\n- Document your findings as you go (don't wait until end)\n\n### Architecture Guidelines\n\n**Keep it pragmatic:**\n- Don't over-engineer\n- Follow existing patterns in the codebase\n- Consider the team's skill level and familiarity\n- Choose boring, proven technologies over shiny new ones\n\n**Think about the future:**\n- How easy is this to test?\n- How easy is this to debug?\n- How easy is this to extend?\n- How easy is this to maintain?\n\n**Address non-functionals:**\n- Performance requirements from specs\n- Security considerations\n- Accessibility needs (if applicable)\n- Error handling and resilience\n\n### Documentation Guidelines\n\n**Write for humans:**\n- Use clear, simple language\n- Explain WHY, not just WHAT\n- Include examples where helpful\n- Use diagrams/ASCII art if it helps clarity\n\n**Be concise but complete:**\n- Every section should add value\n- Remove boilerplate that doesn't apply\n- Focus on decisions and trade-offs\n- Link to external docs rather than copying them\n\n**Make it actionable:**\n- Anyone should be able to implement from this\n- Include enough detail for task breakdown\n- Highlight dependencies and prerequisites\n- Call out risks and gotchas\n\n## Error Handling\n\n**If specs.md is missing:**\n```\nERROR: No specs found at ./specs/<feature_slug>/specs.md\n\nPlease run `/discover` first to create the feature specification.\n```\n\n**If specs have unresolved clarifications:**\n```\nERROR: Specs contain [NEEDS CLARIFICATION] markers:\n- [List the markers]\n\nPlease resolve these before proceeding to architecture.\nYou can:\n1. Run `/discover` again to address clarifications\n2. Manually edit specs.md to resolve them\n```\n\nOnce you are done and the architecture is complete, run the /plan command."
              },
              {
                "name": "/discover",
                "description": "Create or update the feature specification from a requirements file, card, or natural language feature description.",
                "path": "por-dev/commands/discover.md",
                "frontmatter": {
                  "description": "Create or update the feature specification from a requirements file, card, or natural language feature description.",
                  "argument-hint": [
                    "text-card-or-path"
                  ],
                  "model": "opus"
                },
                "content": "# Feature Discovery\n\nYou're writing a plan to implement a net new feature that will add value to the application.\n\nThe text in the arguments is the requirements source. Your first step here is to analyze what is the source for the feature arguments, which could be: \n\n- A string (requirements typed in natural language)\n- A file in the local filesystem\n- A card in a project management software that you can access through MCP Tools\n\nBased on the identified source, acquire the necessary context by reviewing what was types, reading the file or pulling the card from the tool. \n\nGiven that feature description, do this:\n\n<arguments>\n#$ARGUMENTS\n</arguments>\n\nYou **MUST** consider the user input before proceeding (if not empty).\nIf the input is empty, error now and ask for a proper input.\n\n## Setup\n\n1. Create a slug for this feature (<feature_slug>), should be a git branch friendly name that is not in the ./specs folder (not repeated)\n2. Create the folder at ./specs/<feature_slug>\n3. Make sure we are in a branch with the same name. If not, create it.\n4. Parse user description from Input\n    If empty: ERROR \"No feature description provided\"\n5. Extract key concepts from description\n    Identify: actors, actions, data, constraints\n\n## Analysis\n\nGo through the cards, parents and children if required, and build an initial understanding of what needs to be build. Think carefully about what is requested, ensure you understand exactly: \n    - Why this is being built (context)\n    - What is the expected outcome for this issue? (goal)\n    - How should it be built, just directionally, not in details (approach)\n    - If it requires using new APIs/tools, do you understand them?\n    - How should this be tested?\n    - What are the dependencies?\n    - What are the constraints?\nAnything that isn't clear MUST be recorded as a question / clarification needed.\n\nOnce you have a good understanding of what is being built, save it in the specs/<feature_slug>/spec.md file and ask the human to review it.\n\nYour goal at this point is to extract the feature requirements from the functionality perspective, not to define its architecure. \n\n## General Guidelines\n\n## Quick Guidelines\n\n- Focus on **WHAT** users need and **WHY**.\n- Avoid HOW to implement (no tech stack, APIs, code structure) for now.\n- DO NOT create any checklists that are embedded in the spec. That will be a separate command.\n\n## Spec Format\n\n```md\n# Feature Specification: [FEATURE NAME]\n\n**Feature Branch**: `[###-feature-name]`  \n**Input**: User description: \"$ARGUMENTS\"\n\n## Context and Understanding \n\n[ Explain what you understand from the user requirements. What is the user trying to build and what is the motivation for it? What is wrong / missing today and needs to change?]\n\n## Feature Description\n<describe the feature in detail, including its purpose and value to users>\n\n## Requirements *(mandatory)*\n\n<!--\n  ACTION REQUIRED: The content in this section represents placeholders.\n  Fill them out with the right functional requirements.\n-->\n\n### Proposed solution\n\n<!--\n  ACTION REQUIRED: How will this feature really work? Think about user journeys, APIs, reports. Do we need tests? Do we need configuration changes? Are we handling deployment? Create as many stories as its required to deliver this.\n-->\nExamples:\n\n- **US-001**: User Story for an important feature\n- **US-002**: User Story for the backend service\n- **US-003**: User Story for the frontend implementation\n- **US-004**: User Story for configuration\n- **US-005**: User Story for unit testings\n\n\n### Functional Requirements\n\n- **FR-001**: System MUST [specific capability, e.g., \"allow users to create accounts\"]\n- **FR-002**: System MUST [specific capability, e.g., \"validate email addresses\"]  \n- **FR-003**: Users MUST be able to [key interaction, e.g., \"reset their password\"]\n- **FR-004**: System MUST [data requirement, e.g., \"persist user preferences\"]\n- **FR-005**: System MUST [behavior, e.g., \"log all security events\"]\n\n*Example of marking unclear requirements:*\n\n- **FR-006**: System MUST authenticate users via [NEEDS CLARIFICATION: auth method not specified - email/password, SSO, OAuth?]\n- **FR-007**: System MUST retain user data for [NEEDS CLARIFICATION: retention period not specified]\n\n## Success Criteria *(mandatory)*\n\n<!--\n  ACTION REQUIRED: Define measurable success criteria.\n  These must be technology-agnostic and measurable.\n-->\n\n### Measurable Outcomes\n\n- **SC-001**: [Measurable metric, e.g., \"Users can complete account creation in under 2 minutes\"]\n- **SC-002**: [Measurable metric, e.g., \"System handles 1000 concurrent users without degradation\"]\n- **SC-003**: [User satisfaction metric, e.g., \"90% of users successfully complete primary task on first attempt\"]\n- **SC-004**: [Business metric, e.g., \"Reduce support tickets related to [X] by 50%\"]\n\n## Clarification Needed\n<optionally list any questions and clarifications required to properly design the feature. A developer will answer them in time. If the user answers your clarification questions, you should update the documentation.>\n\n## Notes\n<optionally list any additional notes, future considerations, or context that are relevant to the feature that will be helpful to the developer>\n```\n\nAfter creating the spec file, present your questions to the human.\n\nAsk the questions in `Clarification Needed` section in one single message. Provide alternatives and suggest your preferred appraoch. \n\nExample:\n```\nI have finished my initial review. In the analysis process, I identified some issues that would benefit from clarification. I am providing each of them below. You can reply only for the items you want to change. Any item you don't reply to, I'll consider you accepted my suggestion. You can reply to all of them in the same message. \n\n1. Insert your question here provididing details on context and why it's important\nA) Option 1 \nB) Option 2\nC) Option 3\nD) Tell me what to do. \n\n(repeat this process for each question)\n```\n\nOnce the human provides you with the answers, MUST update the spec.md file and provide the human answer to your clarification questions so you can refer to them later. \n\nOnce you are done and the discovery is complete, run the /design command."
              },
              {
                "name": "/implement",
                "description": null,
                "path": "por-dev/commands/implement.md",
                "frontmatter": null,
                "content": "# Implement the following plan\nFollow the `Instructions` to implement the `Plan` then `Report` the completed work.\n\n## Instructions\n- Read the plan, think hard about the plan and implement the plan.\n\n## Parameters\n\nIf this command is called with the --ff parameter, it means you should build the feature completely. In this case, you should reach out to the user only a) if you are done, b) if you have question or c) if you find any blocks.\n\nIf the command is not called with any parameter or you find the --phases parameter in the arguments, then you should proceed with a phased approach to the development, which means you should stop after each phase and ask the user for review before continuing to the next stage. \n\n## Plan\n$ARGUMENTS\n\n## Report\n\nIn any mode (ff or phases), at the end of each phase:\n\n- Update the plan.md file (if there is one), marking completed tasks as done `[X]`\n- Add comments to the completed phase with a summary of what was accomplished, specially if you changed the plan for some reason.\n\n\nIn any mode (ff or phases), when you are done: \n\n- Summarize the work you've just done in a concise bullet point list.\n- Report the files and total lines changed with `git diff --stat`"
              },
              {
                "name": "/plan",
                "description": "Generate detailed implementation tasks organized by user story",
                "path": "por-dev/commands/plan.md",
                "frontmatter": {
                  "description": "Generate detailed implementation tasks organized by user story",
                  "argument-hint": [
                    "optional-context"
                  ]
                },
                "content": "# Tasks Command\n\nThis command breaks down the architecture into concrete, actionable implementation tasks organized by user story and phase.\n\n## User Input\n\nArguments:\n```text\n$ARGUMENTS\n```\n\nYou **MUST** consider the user input before proceeding (if not empty).\n\n## Prerequisites\n\nBefore running this command:\n- ‚úÖ Feature specs must exist at `./specs/<feature_slug>/specs.md`\n- ‚úÖ Architecture must exist at `./specs/<feature_slug>/architecture.md`\n- ‚úÖ You should be on the correct feature branch\n- ‚ùå Do NOT run this if architecture has unresolved open questions\n\n## Execution Flow\n\n### Step 0: Load Context\n\n1. Identify the current feature by checking:\n   - Current git branch name (if using git)\n   - Ask user to specify feature if unclear\n\n2. Load required files from `./specs/<feature_slug>/`:\n   - **Required**: `specs.md` (for user stories with priorities)\n   - **Required**: `architecture.md` (for tech decisions and components)\n   - **Optional**: `contracts.md` (for API endpoints and data models)\n\n3. Verify architecture is complete:\n   - No unresolved \"Open Questions\" section items\n   - All user stories have component mappings\n   - File structure is defined\n   - If incomplete, STOP and tell user to resolve architecture first\n\n### Step 1: Extract Information\n\nFrom the loaded documents, extract:\n\n**From specs.md:**\n- All user stories with priorities (P1, P2, P3, etc.)\n- For each user story: title, goal, acceptance criteria\n- Edge cases and special requirements\n\n**From architecture.md:**\n- Tech stack and dependencies\n- Component structure (new files, modified files)\n- User story mapping (which files belong to which story)\n- Integration points and dependencies\n- File structure and naming conventions\n\n**From contracts.md (if exists):**\n- Data models/entities\n- API endpoints\n- Validation rules\n- Request/response formats\n\n### Step 2: Organize Tasks by Phase\n\nBreak down the implementation into phases following this structure:\n\n**Phase 1: Setup** (~1-2h)\n- Project initialization\n- Dependency installation\n- Configuration setup\n- Development environment prep\n\n**Phase 2: Foundational** (~2-4h)\n- Core infrastructure that BLOCKS all user stories\n- Examples: Database setup, auth framework, base classes, routing infrastructure\n- CRITICAL: Nothing user-story-specific here - only blocking prerequisites\n\n**Phase 3+: User Stories** (one phase per story, in priority order)\n- Each user story gets its own phase\n- Organized by priority (P1 first, then P2, then P3, etc.)\n- Each phase should be ~2-4 hours of work\n- Include: models, services, endpoints, UI, tests (if requested)\n\n**Final Phase: Polish**\n- Documentation\n- Code cleanup\n- Performance optimization\n- Cross-cutting concerns\n\n### Step 3: Generate Tasks\n\nFor each phase, generate specific tasks following these rules:\n\n**Task Format:**\n```\n- [ ] T001 [P] [US1] Specific task description with file path\n```\n\n**Components:**\n- `[ ]` or `[x]`: Checkbox for completion tracking\n- `T001`: Unique sequential ID\n- `[P]`: OPTIONAL marker for tasks that can run in parallel (different files, no dependencies)\n- `[US1]`: User story reference (omit for Setup/Foundational/Polish phases)\n- Description: Concrete action with specific file path when relevant\n\n**Task Granularity:**\n- Each task should be completable in 15-30 minutes\n- Include enough detail that an LLM can execute it\n- Specify file paths when creating/modifying files\n- Be specific but not excessively verbose\n\n**Parallelization Rules:**\n- Mark [P] only if tasks touch different files\n- Same file = sequential (no [P] marker)\n- Different files with no logical dependency = [P]\n- Tests can often be [P] with each other\n\n**Test Tasks (OPTIONAL):**\n- Only include if explicitly requested in specs or user asks\n- Tests should come BEFORE implementation (TDD approach)\n- Each test task should verify it FAILS before implementation\n\n### Step 4: Estimate Time\n\nFor each phase, provide a realistic time estimate:\n- Setup: Usually 1-2h\n- Foundational: 2-4h (can be longer for complex setups)\n- User Stories: 2-4h each (adjust based on complexity)\n- Polish: 1-2h\n\nTime estimates help with:\n- Session planning (knowing when to take breaks)\n- Progress tracking\n- Resource allocation\n\n### Step 5: Map Dependencies\n\nDocument explicit dependencies between phases:\n- Which phases must complete before others can start\n- Which user stories are independent vs dependent\n- Parallel opportunities (which stories can be worked simultaneously)\n\n### Step 6: Generate plan.md\n\nCreate `./specs/<feature_slug>/plan.md` with this structure (the content itself is just for your reference, keep the structure):\n\n```markdown\n# Tasks: [FEATURE NAME]\n\n**Branch**: [branch-name]\n**Specs**: [link to specs.md]\n**Architecture**: [link to architecture.md]\n**Status**: Not Started ‚è≥\n\n---\n\n## Phase 1: Setup ‚è≥ (~2h)\n\n**Purpose**: Initialize project structure and dependencies\n\n- [ ] T001 [P] Create project structure per architecture.md\n- [ ] T002 [P] Install dependencies: [list key dependencies]\n- [ ] T003 Configure [linting/formatting tools]\n- [ ] T004 Setup development environment variables\n\n**Notes:**\n- [Space for learnings and comments during implementation]\n\n---\n\n## Phase 2: Foundational ‚è≥ (~3h)\n\n**Purpose**: Core infrastructure that BLOCKS all user stories\n\n‚ö†Ô∏è **CRITICAL**: No user story work can begin until this phase completes\n\n- [ ] T005 Setup database schema and migrations in [path]\n- [ ] T006 [P] Implement authentication middleware in [path]\n- [ ] T007 [P] Create base error handling in [path]\n- [ ] T008 Setup logging infrastructure in [path]\n\n**Checkpoint**: ‚úã Foundation ready - user stories can now proceed\n\n**Notes:**\n- [Space for learnings and comments]\n\n---\n\n## Phase 3: User Story 1 - [Title] (P1) ‚è≥ üéØ MVP (~4h)\n\n**Goal**: [Brief description from specs.md]\n\n**Independent Test**: [How to verify this story works standalone]\n\n### Tasks\n\n- [ ] T009 [P] [US1] Create [Entity] model in src/models/[entity].py\n- [ ] T010 [P] [US1] Create [Entity2] model in src/models/[entity2].py\n- [ ] T011 [US1] Implement [Service] in src/services/[service].py\n- [ ] T012 [US1] Create [endpoint/feature] in src/[path]/[file].py\n- [ ] T013 [US1] Add validation for [entity] fields\n- [ ] T014 [US1] Add error handling for [scenario]\n- [ ] T015 [US1] Add logging for [operations]\n\n**Checkpoint**: ‚úã User Story 1 complete and independently testable\n\n**Notes:**\n- [Space for learnings and comments]\n\n---\n\n## Phase 4: User Story 2 - [Title] (P2) ‚è≥ (~3h)\n\n**Goal**: [Brief description from specs.md]\n\n**Independent Test**: [How to verify this story works standalone]\n\n### Tasks\n\n- [ ] T016 [P] [US2] Create [Entity] model in src/models/[entity].py\n- [ ] T017 [US2] Implement [Service] in src/services/[service].py\n- [ ] T018 [US2] Create [endpoint/feature] in src/[path]/[file].py\n- [ ] T019 [US2] Integrate with User Story 1 (if needed)\n\n**Checkpoint**: ‚úã User Stories 1 AND 2 both work independently\n\n**Notes:**\n- [Space for learnings and comments]\n\n---\n\n[Repeat for each user story: Phase 5 for US3, Phase 6 for US4, etc.]\n\n---\n\n## Phase N: Polish & Documentation ‚è≥ (~2h)\n\n**Purpose**: Final touches and cross-cutting improvements\n\n- [ ] TXXX [P] Update README.md with new feature documentation\n- [ ] TXXX [P] Add inline code comments for complex logic\n- [ ] TXXX Code cleanup and refactoring\n- [ ] TXXX Performance optimization review\n- [ ] TXXX Security review checklist\n\n**Notes:**\n- [Space for learnings and comments]\n\n---\n\n## Dependencies & Execution Order\n\n### Phase Dependencies\n\n```\nSetup (Phase 1)\n    ‚Üì\nFoundational (Phase 2) ‚Üê BLOCKS everything below\n    ‚Üì\n    ‚îú‚îÄ‚Üí User Story 1 (Phase 3) - Can start\n    ‚îú‚îÄ‚Üí User Story 2 (Phase 4) - Can start in parallel OR after US1\n    ‚îî‚îÄ‚Üí User Story 3 (Phase 5) - Can start in parallel OR after US1/US2\n    ‚Üì\nPolish (Final Phase) - After all desired stories complete\n```\n\n### User Story Independence\n\n- **US1 (P1)**: No dependencies on other stories ‚úÖ MVP\n- **US2 (P2)**: [Independent OR depends on US1 - specify]\n- **US3 (P3)**: [Independent OR depends on US1/US2 - specify]\n\n### Parallel Opportunities\n\n**Within a phase:**\n- Tasks marked [P] can run simultaneously\n- Example: Multiple model files can be created in parallel\n\n**Across phases:**\n- After Foundational completes, ALL user stories CAN run in parallel\n- Recommended: Complete US1 first (MVP), then parallelize US2+US3\n\n---\n\n## Implementation Strategy\n\n### üéØ MVP First (Recommended)\n\n1. Complete Phase 1: Setup ‚úÖ\n2. Complete Phase 2: Foundational ‚úÖ\n3. Complete Phase 3: User Story 1 ‚úÖ\n4. **STOP and VALIDATE** - Test US1 independently\n5. Deploy/demo if ready\n6. Then proceed to US2, US3, etc.\n\n### üìà Incremental Delivery\n\nEach user story adds value independently:\n- After US1: Deploy MVP ‚úÖ\n- After US2: Deploy US1+US2 ‚úÖ\n- After US3: Deploy US1+US2+US3 ‚úÖ\n\n### üë• Parallel Team Strategy\n\nWith multiple developers after Foundational:\n- Developer A: User Story 1\n- Developer B: User Story 2  \n- Developer C: User Story 3\n- Stories integrate seamlessly when complete\n\n---\n\n## Progress Tracking\n\n**Emoji Legend:**\n- ‚è≥ Not Started\n- ‚è∞ In Progress\n- ‚úÖ Completed\n\n**Update this file as you work:**\n1. Change phase status emoji (‚è≥ ‚Üí ‚è∞ ‚Üí ‚úÖ)\n2. Check off tasks as completed: `- [x]`\n3. Add notes/learnings in the Notes sections\n4. Update time estimates if needed\n\n---\n\n## Task Execution Tips\n\n**Before starting a task:**\n- Read the task description carefully\n- Check if any [P] sibling tasks can run in parallel\n- Verify prerequisites are complete\n\n**While executing:**\n- Follow file paths exactly as specified\n- Match existing code patterns and conventions\n- Test incrementally (don't wait until phase end)\n\n**After completing a task:**\n- Mark it complete: `- [x]`\n- Commit if it's a logical unit\n- Add any learnings to Notes section\n\n**At checkpoints:**\n- Validate the entire phase works as expected\n- Test user story independently\n- Get user approval before continuing\n\n---\n\n## Notes\n\n**Key Conventions:**\n- [P] = Can run in parallel (different files)\n- [US1] = Belongs to User Story 1\n- File paths should be exact and absolute when possible\n- Commit after each task or logical grouping\n- Stop at checkpoints to validate\n\n**Remember:**\n- Each user story should be independently completable\n- Foundational phase blocks everything - don't skip it\n- MVP = Just User Story 1 (P1)\n- Add learnings to Notes sections as you discover them\n```\n\n### Step 7: Final Report\n\nPresent to the user:\n\n1. **Task Summary:**\n   - Total number of tasks: [X]\n   - Number of phases: [Y]\n   - Tasks per user story breakdown\n   - Estimated total time: [Z hours]\n\n2. **Files generated:**\n   - Link to `plan.md`\n\n3. **MVP Definition:**\n   - Clearly state what constitutes the MVP (usually just P1 user story)\n   - Estimated time to MVP: [X hours]\n\n4. **Parallel Opportunities:**\n   - Highlight which phases can be parallelized\n   - Note tasks marked [P] within phases\n\n5. **Next Steps:**\n   - Suggest reviewing plan.md\n   - Recommend starting with Phase 1 (Setup)\n   - Mention checkpoints for validation\n   - Ask if they want to proceed to `/work` or adjust tasks\n\n## Guidelines\n\n### Task Generation Guidelines\n\n**Be Specific:**\n- ‚ùå \"Implement user authentication\"\n- ‚úÖ \"Implement JWT authentication middleware in src/auth/jwt.py\"\n\n**Be Actionable:**\n- Each task should have a clear deliverable\n- Include file paths when creating/modifying code\n- Specify what needs to be tested\n\n**Be Realistic:**\n- Each task: 15-30 minutes\n- Each phase: 2-4 hours\n- Don't create micro-tasks (too granular)\n- Don't create mega-tasks (too broad)\n\n**Be Independent:**\n- User stories should be independently completable\n- Mark dependencies explicitly when they exist\n- Prefer independence over tight coupling\n\n### Time Estimation Guidelines\n\n**Consider:**\n- Complexity of the task\n- Need for research/learning\n- Testing and debugging time\n- Integration complexity\n\n**Default Estimates:**\n- Simple CRUD: 2-3h per user story\n- API endpoints: 3-4h per user story\n- Complex business logic: 4-6h per user story\n- UI components: 2-4h per user story\n\n**Adjust based on:**\n- Team experience with tech stack\n- Code familiarity\n- Availability of examples/patterns\n\n### Documentation Guidelines\n\n**Notes Sections:**\n- Use for learnings during implementation\n- Document unexpected issues\n- Record decisions made on-the-fly\n- Capture \"gotchas\" for future reference\n\n**Status Tracking:**\n- Update emojis as phases progress\n- Check off tasks as completed\n- Keep the file current (living document)\n\n## Error Handling\n\n**If specs.md is missing:**\n```\nERROR: No specs found at ./specs/<feature_slug>/specs.md\n\nPlease run `/specify` first to create the feature specification.\n```\n\n**If architecture.md is missing:**\n```\nERROR: No architecture found at ./specs/<feature_slug>/architecture.md\n\nPlease run `/plan` first to create the technical architecture.\n```\n\n**If architecture has open questions:**\n```\nWARNING: Architecture has unresolved open questions:\n- [List them]\n\nResolve these before generating tasks, or tasks may be incomplete.\nProceed anyway? (yes/no)\n```\n\n**If no user stories found:**\n```\nERROR: No user stories found in specs.md\n\nUser stories are required to organize tasks by priority.\nPlease update specs.md with user stories before running /tasks.\n```\n\n## Example Flow\n\n```\nUser: /tasks\n\nClaude:\nI'll break down the architecture into actionable tasks.\n\n[Loads specs.md and architecture.md from ./specs/001-api-endpoints/]\n\nFound:\n- 3 user stories (P1, P2, P3)\n- Tech stack: Python 3.11 + FastAPI\n- 5 new files to create, 2 files to modify\n\nGenerating tasks organized by user story...\n\n‚úÖ Tasks created!\n\nüìÑ File: ./specs/001-api-endpoints/plan.md\n\nüìä Summary:\n- Total tasks: 24\n- Phases: 6 (Setup, Foundational, 3 User Stories, Polish)\n- Estimated time: ~16 hours\n- MVP (US1 only): ~7 hours\n\nüéØ MVP Definition:\nUser Story 1 (P1): \"API Authentication\" - Allows users to authenticate via JWT\n\nüîÄ Parallel Opportunities:\n- Within Phase 2: Tasks T005-T007 can run in parallel\n- After Phase 2: All user stories can proceed in parallel\n- Within each user story: Model creation tasks marked [P]\n\nüí° Recommended Approach:\n1. Start with Phase 1 (Setup) - ~2h\n2. Complete Phase 2 (Foundational) - ~3h ‚ö†Ô∏è This blocks everything\n3. Focus on Phase 3 (US1 - MVP) - ~4h\n4. Validate US1 works independently ‚úã\n5. Then proceed to US2 and US3 in any order\n\nReady to start implementation? Run `/implement` when you're ready!\n```"
              },
              {
                "name": "/prime",
                "description": null,
                "path": "por-dev/commands/prime.md",
                "frontmatter": null,
                "content": "# Prime\n> Execute the following sections to understand the codebase then summarize your understanding.\n\n## Run\ngit ls-files\n\n## Read\nREADME.md\n\n## List\nRun `tree docs` to know which docs are available. \nRead as needed during the session if you have any questions on how this project works."
              }
            ],
            "skills": []
          }
        ]
      }
    }
  ]
}