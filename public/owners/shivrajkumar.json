{
  "owner": {
    "id": "shivrajkumar",
    "display_name": "Shivraj",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/17001305?u=3f71d960cd79c7519e39e1937b6140896cf2ea12&v=4",
    "url": "https://github.com/shivrajkumar",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 3,
      "total_commands": 18,
      "total_skills": 0,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "shivrajkumar/traya-plugin",
      "url": "https://github.com/shivrajkumar/traya-plugin",
      "description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-12-04T12:42:23Z",
        "created_at": "2025-10-29T12:31:50Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 2802
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 30
        },
        {
          "path": "CLAUDE.md",
          "type": "blob",
          "size": 15024
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 7133
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/traya-backend-engineering",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/traya-backend-engineering/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/traya-backend-engineering/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 951
        },
        {
          "path": "plugins/traya-backend-engineering/.mcp.json",
          "type": "blob",
          "size": 594
        },
        {
          "path": "plugins/traya-backend-engineering/README.md",
          "type": "blob",
          "size": 12246
        },
        {
          "path": "plugins/traya-backend-engineering/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/traya-backend-engineering/agents/api-designer.md",
          "type": "blob",
          "size": 9580
        },
        {
          "path": "plugins/traya-backend-engineering/agents/api-documenter.md",
          "type": "blob",
          "size": 39865
        },
        {
          "path": "plugins/traya-backend-engineering/agents/architecture-strategist.md",
          "type": "blob",
          "size": 21121
        },
        {
          "path": "plugins/traya-backend-engineering/agents/database-modeler.md",
          "type": "blob",
          "size": 14794
        },
        {
          "path": "plugins/traya-backend-engineering/agents/express-specialist.md",
          "type": "blob",
          "size": 12211
        },
        {
          "path": "plugins/traya-backend-engineering/agents/nestjs-specialist.md",
          "type": "blob",
          "size": 11896
        },
        {
          "path": "plugins/traya-backend-engineering/agents/performance-analyzer.md",
          "type": "blob",
          "size": 20900
        },
        {
          "path": "plugins/traya-backend-engineering/agents/redis-cache-specialist.md",
          "type": "blob",
          "size": 19611
        },
        {
          "path": "plugins/traya-backend-engineering/agents/security-auditor.md",
          "type": "blob",
          "size": 21869
        },
        {
          "path": "plugins/traya-backend-engineering/agents/testing-specialist.md",
          "type": "blob",
          "size": 24497
        },
        {
          "path": "plugins/traya-backend-engineering/agents/typeorm-specialist.md",
          "type": "blob",
          "size": 20855
        },
        {
          "path": "plugins/traya-backend-engineering/agents/typescript-reviewer.md",
          "type": "blob",
          "size": 11710
        },
        {
          "path": "plugins/traya-backend-engineering/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/traya-backend-engineering/commands/generate_command.md",
          "type": "blob",
          "size": 12473
        },
        {
          "path": "plugins/traya-backend-engineering/commands/plan.md",
          "type": "blob",
          "size": 16619
        },
        {
          "path": "plugins/traya-backend-engineering/commands/resolve_todo_parallel.md",
          "type": "blob",
          "size": 10606
        },
        {
          "path": "plugins/traya-backend-engineering/commands/review.md",
          "type": "blob",
          "size": 20266
        },
        {
          "path": "plugins/traya-backend-engineering/commands/triage.md",
          "type": "blob",
          "size": 11837
        },
        {
          "path": "plugins/traya-backend-engineering/commands/work.md",
          "type": "blob",
          "size": 12504
        },
        {
          "path": "plugins/traya-backend-engineering/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/traya-backend-engineering/skills/api-developer.md",
          "type": "blob",
          "size": 31359
        },
        {
          "path": "plugins/traya-backend-engineering/skills/api-documentation-generator.md",
          "type": "blob",
          "size": 49207
        },
        {
          "path": "plugins/traya-backend-engineering/skills/api-tester.md",
          "type": "blob",
          "size": 32480
        },
        {
          "path": "plugins/traya-backend-engineering/skills/code-reviewer.md",
          "type": "blob",
          "size": 17385
        },
        {
          "path": "plugins/traya-backend-engineering/skills/database-integrator.md",
          "type": "blob",
          "size": 35949
        },
        {
          "path": "plugins/traya-frontend-engineering",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/traya-frontend-engineering/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/traya-frontend-engineering/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 881
        },
        {
          "path": "plugins/traya-frontend-engineering/.mcp.json",
          "type": "blob",
          "size": 796
        },
        {
          "path": "plugins/traya-frontend-engineering/CHANGELOG.md",
          "type": "blob",
          "size": 5725
        },
        {
          "path": "plugins/traya-frontend-engineering/LICENSE",
          "type": "blob",
          "size": 1070
        },
        {
          "path": "plugins/traya-frontend-engineering/README.md",
          "type": "blob",
          "size": 8006
        },
        {
          "path": "plugins/traya-frontend-engineering/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/traya-frontend-engineering/agents/architecture-strategist.md",
          "type": "blob",
          "size": 4621
        },
        {
          "path": "plugins/traya-frontend-engineering/agents/best-practices-researcher.md",
          "type": "blob",
          "size": 5503
        },
        {
          "path": "plugins/traya-frontend-engineering/agents/code-simplicity-reviewer.md",
          "type": "blob",
          "size": 4134
        },
        {
          "path": "plugins/traya-frontend-engineering/agents/feedback-codifier.md",
          "type": "blob",
          "size": 3692
        },
        {
          "path": "plugins/traya-frontend-engineering/agents/framework-docs-researcher.md",
          "type": "blob",
          "size": 6449
        },
        {
          "path": "plugins/traya-frontend-engineering/agents/frontend-developer.md",
          "type": "blob",
          "size": 13286
        },
        {
          "path": "plugins/traya-frontend-engineering/agents/git-history-analyzer.md",
          "type": "blob",
          "size": 3906
        },
        {
          "path": "plugins/traya-frontend-engineering/agents/pattern-recognition-specialist.md",
          "type": "blob",
          "size": 4576
        },
        {
          "path": "plugins/traya-frontend-engineering/agents/performance-oracle.md",
          "type": "blob",
          "size": 6331
        },
        {
          "path": "plugins/traya-frontend-engineering/agents/pr-comment-resolver.md",
          "type": "blob",
          "size": 3951
        },
        {
          "path": "plugins/traya-frontend-engineering/agents/repo-research-analyst.md",
          "type": "blob",
          "size": 5925
        },
        {
          "path": "plugins/traya-frontend-engineering/agents/security-sentinel.md",
          "type": "blob",
          "size": 6341
        },
        {
          "path": "plugins/traya-frontend-engineering/agents/test-automator.md",
          "type": "blob",
          "size": 9290
        },
        {
          "path": "plugins/traya-frontend-engineering/agents/traya-style-editor.md",
          "type": "blob",
          "size": 3814
        },
        {
          "path": "plugins/traya-frontend-engineering/agents/typescript-reviewer.md",
          "type": "blob",
          "size": 5560
        },
        {
          "path": "plugins/traya-frontend-engineering/agents/ui-ux-designer.md",
          "type": "blob",
          "size": 9819
        },
        {
          "path": "plugins/traya-frontend-engineering/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/traya-frontend-engineering/commands/generate_command.md",
          "type": "blob",
          "size": 3046
        },
        {
          "path": "plugins/traya-frontend-engineering/commands/plan.md",
          "type": "blob",
          "size": 8487
        },
        {
          "path": "plugins/traya-frontend-engineering/commands/resolve_todo_parallel.md",
          "type": "blob",
          "size": 1132
        },
        {
          "path": "plugins/traya-frontend-engineering/commands/review.md",
          "type": "blob",
          "size": 10436
        },
        {
          "path": "plugins/traya-frontend-engineering/commands/triage.md",
          "type": "blob",
          "size": 5668
        },
        {
          "path": "plugins/traya-frontend-engineering/commands/work.md",
          "type": "blob",
          "size": 7423
        },
        {
          "path": "plugins/traya-frontend-engineering/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/traya-frontend-engineering/skills/api-integrator.md",
          "type": "blob",
          "size": 27342
        },
        {
          "path": "plugins/traya-frontend-engineering/skills/code-reviewer.md",
          "type": "blob",
          "size": 20323
        },
        {
          "path": "plugins/traya-frontend-engineering/skills/ui-developer.md",
          "type": "blob",
          "size": 13463
        },
        {
          "path": "plugins/traya-frontend-engineering/skills/ui-tester.md",
          "type": "blob",
          "size": 17119
        },
        {
          "path": "plugins/traya-react-native",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/traya-react-native/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/traya-react-native/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 785
        },
        {
          "path": "plugins/traya-react-native/.mcp.json",
          "type": "blob",
          "size": 1051
        },
        {
          "path": "plugins/traya-react-native/README.md",
          "type": "blob",
          "size": 10756
        },
        {
          "path": "plugins/traya-react-native/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/traya-react-native/agents/android-device-specialist.md",
          "type": "blob",
          "size": 8089
        },
        {
          "path": "plugins/traya-react-native/agents/ios-simulator-specialist.md",
          "type": "blob",
          "size": 5784
        },
        {
          "path": "plugins/traya-react-native/agents/rn-accessibility-auditor.md",
          "type": "blob",
          "size": 10523
        },
        {
          "path": "plugins/traya-react-native/agents/rn-animation-specialist.md",
          "type": "blob",
          "size": 12163
        },
        {
          "path": "plugins/traya-react-native/agents/rn-architecture-strategist.md",
          "type": "blob",
          "size": 13862
        },
        {
          "path": "plugins/traya-react-native/agents/rn-best-practices-researcher.md",
          "type": "blob",
          "size": 13150
        },
        {
          "path": "plugins/traya-react-native/agents/rn-developer.md",
          "type": "blob",
          "size": 7484
        },
        {
          "path": "plugins/traya-react-native/agents/rn-native-module-specialist.md",
          "type": "blob",
          "size": 11878
        },
        {
          "path": "plugins/traya-react-native/agents/rn-navigation-specialist.md",
          "type": "blob",
          "size": 13392
        },
        {
          "path": "plugins/traya-react-native/agents/rn-pattern-recognition.md",
          "type": "blob",
          "size": 9927
        },
        {
          "path": "plugins/traya-react-native/agents/rn-performance-analyzer.md",
          "type": "blob",
          "size": 9148
        },
        {
          "path": "plugins/traya-react-native/agents/rn-security-auditor.md",
          "type": "blob",
          "size": 11715
        },
        {
          "path": "plugins/traya-react-native/agents/rn-state-management-expert.md",
          "type": "blob",
          "size": 12028
        },
        {
          "path": "plugins/traya-react-native/agents/rn-styling-expert.md",
          "type": "blob",
          "size": 11873
        },
        {
          "path": "plugins/traya-react-native/agents/rn-testing-specialist.md",
          "type": "blob",
          "size": 10495
        },
        {
          "path": "plugins/traya-react-native/agents/rn-typescript-reviewer.md",
          "type": "blob",
          "size": 10397
        },
        {
          "path": "plugins/traya-react-native/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/traya-react-native/commands/generate_command.md",
          "type": "blob",
          "size": 3046
        },
        {
          "path": "plugins/traya-react-native/commands/plan.md",
          "type": "blob",
          "size": 8487
        },
        {
          "path": "plugins/traya-react-native/commands/resolve_todo_parallel.md",
          "type": "blob",
          "size": 1132
        },
        {
          "path": "plugins/traya-react-native/commands/review.md",
          "type": "blob",
          "size": 10436
        },
        {
          "path": "plugins/traya-react-native/commands/triage.md",
          "type": "blob",
          "size": 5668
        },
        {
          "path": "plugins/traya-react-native/commands/work.md",
          "type": "blob",
          "size": 7617
        },
        {
          "path": "plugins/traya-react-native/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/traya-react-native/skills/rn-api-integrator.md",
          "type": "blob",
          "size": 10176
        },
        {
          "path": "plugins/traya-react-native/skills/rn-app-tester.md",
          "type": "blob",
          "size": 8937
        },
        {
          "path": "plugins/traya-react-native/skills/rn-code-reviewer.md",
          "type": "blob",
          "size": 8662
        },
        {
          "path": "plugins/traya-react-native/skills/rn-ui-developer.md",
          "type": "blob",
          "size": 13580
        }
      ],
      "marketplace": {
        "name": "traya-plugin",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "TrayaLabs",
          "url": "https://github.com/trayalabs1"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "traya-frontend-engineering",
            "description": "AI-powered frontend development tools for React and Next.js that get smarter with every use. Make each unit of engineering work easier than the last. Includes 16 specialized agents, 6 commands, and 4 skills.",
            "source": "./plugins/traya-frontend-engineering",
            "category": null,
            "version": "1.0.0",
            "author": {
              "name": "Shivraj Kumar",
              "url": "https://github.com/trayalabs1",
              "email": "shivrajkumar@traya.health"
            },
            "install_commands": [
              "/plugin marketplace add shivrajkumar/traya-plugin",
              "/plugin install traya-frontend-engineering@traya-plugin"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-04T12:42:23Z",
              "created_at": "2025-10-29T12:31:50Z",
              "license": null
            },
            "commands": [
              {
                "name": "/generate_command",
                "description": null,
                "path": "plugins/traya-frontend-engineering/commands/generate_command.md",
                "frontmatter": null,
                "content": "# Create a Custom Claude Code Command\n\nCreate a new slash command in `.claude/commands/` for the requested task.\n\n## Goal\n\n#$ARGUMENTS\n\n## Key Capabilities to Leverage\n\n**File Operations:**\n- Read, Edit, Write - modify files precisely\n- Glob, Grep - search codebase\n- MultiEdit - atomic multi-part changes\n\n**Development:**\n- Bash - run commands (git, tests, linters)\n- Task - launch specialized agents for complex tasks\n- TodoWrite - track progress with todo lists\n\n**Web & APIs:**\n- WebFetch, WebSearch - research documentation\n- GitHub (gh cli) - PRs, issues, reviews\n- Puppeteer - browser automation, screenshots\n\n**Integrations:**\n- AppSignal - logs and monitoring\n- Context7 - framework docs\n- Stripe, Todoist, Featurebase (if relevant)\n\n## Best Practices\n\n1. **Be specific and clear** - detailed instructions yield better results\n2. **Break down complex tasks** - use step-by-step plans\n3. **Use examples** - reference existing code patterns\n4. **Include success criteria** - tests pass, linting clean, etc.\n5. **Think first** - use \"think hard\" or \"plan\" keywords for complex problems\n6. **Iterate** - guide the process step by step\n\n## Structure Your Command\n\n```markdown\n# [Command Name]\n\n[Brief description of what this command does]\n\n## Steps\n\n1. [First step with specific details]\n   - Include file paths, patterns, or constraints\n   - Reference existing code if applicable\n\n2. [Second step]\n   - Use parallel tool calls when possible\n   - Check/verify results\n\n3. [Final steps]\n   - Run tests\n   - Lint code\n   - Commit changes (if appropriate)\n\n## Success Criteria\n\n- [ ] Tests pass\n- [ ] Code follows style guide\n- [ ] Documentation updated (if needed)\n```\n\n## Tips for Effective Commands\n\n- **Use $ARGUMENTS** placeholder for dynamic inputs\n- **Reference CLAUDE.md** patterns and conventions\n- **Include verification steps** - tests, linting, visual checks\n- **Be explicit about constraints** - don't modify X, use pattern Y\n- **Use XML tags** for structured prompts: `<task>`, `<requirements>`, `<constraints>`\n\n## Example Pattern\n\n```markdown\nImplement #$ARGUMENTS following these steps:\n\n1. Research existing patterns\n   - Search for similar code using Grep\n   - Read relevant files to understand approach\n\n2. Plan the implementation\n   - Think through edge cases and requirements\n   - Consider test cases needed\n\n3. Implement\n   - Follow existing code patterns (reference specific files)\n   - Write tests first if doing TDD\n   - Ensure code follows CLAUDE.md conventions\n\n4. Verify\n   - Run tests:\n     - Rails: `bin/rails test` or `bundle exec rspec`\n     - TypeScript: `npm test` or `yarn test` (Jest/Vitest)\n     - Python: `pytest` or `python -m pytest`\n   - Run linter:\n     - Rails: `bundle exec standardrb` or `bundle exec rubocop`\n     - TypeScript: `npm run lint` or `eslint .`\n     - Python: `ruff check .` or `flake8`\n   - Check changes with git diff\n\n5. Commit (optional)\n   - Stage changes\n   - Write clear commit message\n```\n\nNow create the command file at `.claude/commands/[name].md` with the structure above.\n"
              },
              {
                "name": "/plan",
                "description": null,
                "path": "plugins/traya-frontend-engineering/commands/plan.md",
                "frontmatter": null,
                "content": "# Create GitHub Issue\n\n## Introduction\n\nTransform feature descriptions, bug reports, or improvement ideas into well-structured markdown files issues that follow project conventions and best practices. This command provides flexible detail levels to match your needs.\n\n## Feature Description\n\n<feature_description> #$ARGUMENTS </feature_description>\n\n## Main Tasks\n\n### 1. Repository Research & Context Gathering\n\n<thinking>\nFirst, I need to understand the project's conventions and existing patterns, leveraging all available resources and use paralel subagents to do this.\n</thinking>\n\nRunn these three agents in paralel at the same time:\n\n- Task repo-research-analyst(feature_description)\n- Task best-practices-researcher (feature_description)\n- Task framework-docs-researcher (feature_description)\n\n**Reference Collection:**\n\n- [ ] Document all research findings with specific file paths (e.g., `app/services/example_service.rb:42`)\n- [ ] Include URLs to external documentation and best practices guides\n- [ ] Create a reference list of similar issues or PRs (e.g., `#123`, `#456`)\n- [ ] Note any team conventions discovered in `CLAUDE.md` or team documentation\n\n### 2. Issue Planning & Structure\n\n<thinking>\nThink like a product manager - what would make this issue clear and actionable? Consider multiple perspectives\n</thinking>\n\n**Title & Categorization:**\n\n- [ ] Draft clear, searchable issue title using conventional format (e.g., `feat:`, `fix:`, `docs:`)\n- [ ] Identify appropriate labels from repository's label set (`gh label list`)\n- [ ] Determine issue type: enhancement, bug, refactor\n\n**Stakeholder Analysis:**\n\n- [ ] Identify who will be affected by this issue (end users, developers, operations)\n- [ ] Consider implementation complexity and required expertise\n\n**Content Planning:**\n\n- [ ] Choose appropriate detail level based on issue complexity and audience\n- [ ] List all necessary sections for the chosen template\n- [ ] Gather supporting materials (error logs, screenshots, design mockups)\n- [ ] Prepare code examples or reproduction steps if applicable, name the mock filenames in the lists\n\n### 3. Choose Implementation Detail Level\n\nSelect how comprehensive you want the issue to be:\n\n#### üìÑ MINIMAL (Quick Issue)\n\n**Best for:** Simple bugs, small improvements, clear features\n\n**Includes:**\n\n- Problem statement or feature description\n- Basic acceptance criteria\n- Essential context only\n\n**Structure:**\n\n````markdown\n[Brief problem/feature description]\n\n## Acceptance Criteria\n\n- [ ] Core requirement 1\n- [ ] Core requirement 2\n\n## Context\n\n[Any critical information]\n\n## MVP\n\n### test.rb\n\n```ruby\nclass Test\n  def initialize\n    @name = \"test\"\n  end\nend\n```\n\n## References\n\n- Related issue: #[issue_number]\n- Documentation: [relevant_docs_url]\n````\n\n#### üìã MORE (Standard Issue)\n\n**Best for:** Most features, complex bugs, team collaboration\n\n**Includes everything from MINIMAL plus:**\n\n- Detailed background and motivation\n- Technical considerations\n- Success metrics\n- Dependencies and risks\n- Basic implementation suggestions\n\n**Structure:**\n\n```markdown\n## Overview\n\n[Comprehensive description]\n\n## Problem Statement / Motivation\n\n[Why this matters]\n\n## Proposed Solution\n\n[High-level approach]\n\n## Technical Considerations\n\n- Architecture impacts\n- Performance implications\n- Security considerations\n\n## Acceptance Criteria\n\n- [ ] Detailed requirement 1\n- [ ] Detailed requirement 2\n- [ ] Testing requirements\n\n## Success Metrics\n\n[How we measure success]\n\n## Dependencies & Risks\n\n[What could block or complicate this]\n\n## References & Research\n\n- Similar implementations: [file_path:line_number]\n- Best practices: [documentation_url]\n- Related PRs: #[pr_number]\n```\n\n#### üìö A LOT (Comprehensive Issue)\n\n**Best for:** Major features, architectural changes, complex integrations\n\n**Includes everything from MORE plus:**\n\n- Detailed implementation plan with phases\n- Alternative approaches considered\n- Extensive technical specifications\n- Resource requirements and timeline\n- Future considerations and extensibility\n- Risk mitigation strategies\n- Documentation requirements\n\n**Structure:**\n\n```markdown\n## Overview\n\n[Executive summary]\n\n## Problem Statement\n\n[Detailed problem analysis]\n\n## Proposed Solution\n\n[Comprehensive solution design]\n\n## Technical Approach\n\n### Architecture\n\n[Detailed technical design]\n\n### Implementation Phases\n\n#### Phase 1: [Foundation]\n\n- Tasks and deliverables\n- Success criteria\n- Estimated effort\n\n#### Phase 2: [Core Implementation]\n\n- Tasks and deliverables\n- Success criteria\n- Estimated effort\n\n#### Phase 3: [Polish & Optimization]\n\n- Tasks and deliverables\n- Success criteria\n- Estimated effort\n\n## Alternative Approaches Considered\n\n[Other solutions evaluated and why rejected]\n\n## Acceptance Criteria\n\n### Functional Requirements\n\n- [ ] Detailed functional criteria\n\n### Non-Functional Requirements\n\n- [ ] Performance targets\n- [ ] Security requirements\n- [ ] Accessibility standards\n\n### Quality Gates\n\n- [ ] Test coverage requirements\n- [ ] Documentation completeness\n- [ ] Code review approval\n\n## Success Metrics\n\n[Detailed KPIs and measurement methods]\n\n## Dependencies & Prerequisites\n\n[Detailed dependency analysis]\n\n## Risk Analysis & Mitigation\n\n[Comprehensive risk assessment]\n\n## Resource Requirements\n\n[Team, time, infrastructure needs]\n\n## Future Considerations\n\n[Extensibility and long-term vision]\n\n## Documentation Plan\n\n[What docs need updating]\n\n## References & Research\n\n### Internal References\n\n- Architecture decisions: [file_path:line_number]\n- Similar features: [file_path:line_number]\n- Configuration: [file_path:line_number]\n\n### External References\n\n- Framework documentation: [url]\n- Best practices guide: [url]\n- Industry standards: [url]\n\n### Related Work\n\n- Previous PRs: #[pr_numbers]\n- Related issues: #[issue_numbers]\n- Design documents: [links]\n```\n\n### 4. Issue Creation & Formatting\n\n<thinking>\nApply best practices for clarity and actionability, making the issue easy to scan and understand\n</thinking>\n\n**Content Formatting:**\n\n- [ ] Use clear, descriptive headings with proper hierarchy (##, ###)\n- [ ] Include code examples in triple backticks with language syntax highlighting\n- [ ] Add screenshots/mockups if UI-related (drag & drop or use image hosting)\n- [ ] Use task lists (- [ ]) for trackable items that can be checked off\n- [ ] Add collapsible sections for lengthy logs or optional details using `<details>` tags\n- [ ] Apply appropriate emoji for visual scanning (üêõ bug, ‚ú® feature, üìö docs, ‚ôªÔ∏è refactor)\n\n**Cross-Referencing:**\n\n- [ ] Link to related issues/PRs using #number format\n- [ ] Reference specific commits with SHA hashes when relevant\n- [ ] Link to code using GitHub's permalink feature (press 'y' for permanent link)\n- [ ] Mention relevant team members with @username if needed\n- [ ] Add links to external resources with descriptive text\n\n**Code & Examples:**\n\n```markdown\n# Good example with syntax highlighting and line references\n\n\\`\\`\\`ruby\n\n# app/services/user_service.rb:42\n\ndef process_user(user)\n\n# Implementation here\n\nend \\`\\`\\`\n\n# Collapsible error logs\n\n<details>\n<summary>Full error stacktrace</summary>\n\n\\`\\`\\` Error details here... \\`\\`\\`\n\n</details>\n```\n\n**AI-Era Considerations:**\n\n- [ ] Account for accelerated development with AI pair programming\n- [ ] Include prompts or instructions that worked well during research\n- [ ] Note which AI tools were used for initial exploration (Claude, Copilot, etc.)\n- [ ] Emphasize comprehensive testing given rapid implementation\n- [ ] Document any AI-generated code that needs human review\n\n### 5. Final Review & Submission\n\n**Pre-submission Checklist:**\n\n- [ ] Title is searchable and descriptive\n- [ ] Labels accurately categorize the issue\n- [ ] All template sections are complete\n- [ ] Links and references are working\n- [ ] Acceptance criteria are measurable\n- [ ] Add names of files in pseudo code examples and todo lists\n- [ ] Add an ERD mermaid diagram if applicable for new model changes\n\n## Output Format\n\nPresent the complete issue content within `<github_issue>` tags, ready for GitHub CLI:\n\n```bash\ngh issue create --title \"[TITLE]\" --body \"[CONTENT]\" --label \"[LABELS]\"\n```\n\n## Thinking Approaches\n\n- **Analytical:** Break down complex features into manageable components\n- **User-Centric:** Consider end-user impact and experience\n- **Technical:** Evaluate implementation complexity and architecture fit\n- **Strategic:** Align with project goals and roadmap\n"
              },
              {
                "name": "/resolve_todo_parallel",
                "description": null,
                "path": "plugins/traya-frontend-engineering/commands/resolve_todo_parallel.md",
                "frontmatter": null,
                "content": "Resolve all TODO comments using parallel processing.\n\n## Workflow\n\n### 1. Analyze\n\nGet all unresolved TODOs from the /todos/\\*.md directory\n\n### 2. Plan\n\nCreate a TodoWrite list of all unresolved items grouped by type.Make sure to look at dependencies that might occur and prioritize the ones needed by others. For example, if you need to change a name, you must wait to do the others. Output a mermaid flow diagram showing how we can do this. Can we do everything in parallel? Do we need to do one first that leads to others in parallel? I'll put the to-dos in the mermaid diagram flow‚Äëwise so the agent knows how to proceed in order.\n\n### 3. Implement (PARALLEL)\n\nSpawn a pr-comment-resolver agent for each unresolved item in parallel.\n\nSo if there are 3 comments, it will spawn 3 pr-comment-resolver agents in parallel. liek this\n\n1. Task pr-comment-resolver(comment1)\n2. Task pr-comment-resolver(comment2)\n3. Task pr-comment-resolver(comment3)\n\nAlways run all in parallel subagents/Tasks for each Todo item.\n\n### 4. Commit & Resolve\n\n- Commit changes\n- Remove the TODO from the file, and mark it as resolved.\n- Push to remote\n"
              },
              {
                "name": "/review",
                "description": null,
                "path": "plugins/traya-frontend-engineering/commands/review.md",
                "frontmatter": null,
                "content": "# Review Command\n\n<command_purpose> Perform exhaustive code reviews using multi-agent analysis, ultra-thinking, and Git worktrees for deep local inspection. </command_purpose>\n\n## Introduction\n\n<role>Senior Code Review Architect with expertise in security, performance, architecture, and quality assurance</role>\n\n## Prerequisites\n\n<requirements>\n- Git repository with GitHub CLI (`gh`) installed and authenticated\n- Clean main/master branch\n- Proper permissions to create worktrees and access the repository\n- For document reviews: Path to a markdown file or document\n</requirements>\n\n## Main Tasks\n\n### 1. Worktree Creation and Branch Checkout (ALWAYS FIRST)\n\n<review_target> #$ARGUMENTS </review_target>\n\n<critical_requirement> MUST create worktree FIRST to enable local code analysis. No exceptions. </critical_requirement>\n\n<thinking>\nFirst, I need to determine the review target type and set up the worktree.\nThis enables all subsequent agents to analyze actual code, not just diffs.\n</thinking>\n\n#### Immediate Actions:\n\n<task_list>\n\n- [ ] Determine review type: PR number (numeric), GitHub URL, file path (.md), or empty (latest PR)\n- [ ] Create worktree directory structure at `$git_root/.worktrees/reviews/pr-$identifier`\n- [ ] Check out PR branch in isolated worktree using `gh pr checkout`\n- [ ] Navigate to worktree - ALL subsequent analysis happens here\n\n- Fetch PR metadata using `gh pr view --json` for title, body, files, linked issues\n- Clone PR branch into worktree with full history `gh pr checkout $identifier`\n- Set up language-specific analysis tools\n- Prepare security scanning environment\n\nEnsure that the worktree is set up correctly and that the PR is checked out. ONLY then proceed to the next step.\n\n</task_list>\n\n#### Detect Project Type\n\n<thinking>\nDetermine the project type by analyzing the codebase structure and files.\nThis will inform which language-specific reviewers to use.\n</thinking>\n\n<project_type_detection>\n\nCheck for these indicators to determine project type:\n\n**TypeScript/React/Next.js Project**:\n- `tsconfig.json`\n- `package.json` with TypeScript, React, or Next.js dependencies\n- `.ts`, `.tsx`, `.jsx` files\n- `next.config.js` or `next.config.ts` (for Next.js)\n\nBased on detection, set appropriate reviewers for parallel execution.\n\n</project_type_detection>\n\n#### Parallel Agents to review the PR:\n\n<parallel_tasks>\n\nRun ALL or most of these agents at the same time, adjusting language-specific reviewers based on project type:\n\n**Language-Specific Reviewers (choose based on project type)**:\n\nFor TypeScript/React/Next.js projects:\n1. Task typescript-reviewer(PR content)\n\n**Universal Reviewers (run for all project types)**:\n2. Task git-history-analyzer(PR content)\n3. Task pattern-recognition-specialist(PR content)\n4. Task architecture-strategist(PR content)\n5. Task security-sentinel(PR content)\n6. Task performance-oracle(PR content)\n\n</parallel_tasks>\n\n### 4. Ultra-Thinking Deep Dive Phases\n\n<ultrathink_instruction> For each phase below, spend maximum cognitive effort. Think step by step. Consider all angles. Question assumptions. And bring all reviews in a synthesis to the user.</ultrathink_instruction>\n\n<deliverable>\nComplete system context map with component interactions\n</deliverable>\n\n#### Phase 3: Stakeholder Perspective Analysis\n\n<thinking_prompt> ULTRA-THINK: Put yourself in each stakeholder's shoes. What matters to them? What are their pain points? </thinking_prompt>\n\n<stakeholder_perspectives>\n\n1. **Developer Perspective** <questions>\n\n   - How easy is this to understand and modify?\n   - Are the APIs intuitive?\n   - Is debugging straightforward?\n   - Can I test this easily? </questions>\n\n2. **Operations Perspective** <questions>\n\n   - How do I deploy this safely?\n   - What metrics and logs are available?\n   - How do I troubleshoot issues?\n   - What are the resource requirements? </questions>\n\n3. **End User Perspective** <questions>\n\n   - Is the feature intuitive?\n   - Are error messages helpful?\n   - Is performance acceptable?\n   - Does it solve my problem? </questions>\n\n4. **Security Team Perspective** <questions>\n\n   - What's the attack surface?\n   - Are there compliance requirements?\n   - How is data protected?\n   - What are the audit capabilities? </questions>\n\n5. **Business Perspective** <questions>\n   - What's the ROI?\n   - Are there legal/compliance risks?\n   - How does this affect time-to-market?\n   - What's the total cost of ownership? </questions> </stakeholder_perspectives>\n\n#### Phase 4: Scenario Exploration\n\n<thinking_prompt> ULTRA-THINK: Explore edge cases and failure scenarios. What could go wrong? How does the system behave under stress? </thinking_prompt>\n\n<scenario_checklist>\n\n- [ ] **Happy Path**: Normal operation with valid inputs\n- [ ] **Invalid Inputs**: Null, empty, malformed data\n- [ ] **Boundary Conditions**: Min/max values, empty collections\n- [ ] **Concurrent Access**: Race conditions, deadlocks\n- [ ] **Scale Testing**: 10x, 100x, 1000x normal load\n- [ ] **Network Issues**: Timeouts, partial failures\n- [ ] **Resource Exhaustion**: Memory, disk, connections\n- [ ] **Security Attacks**: Injection, overflow, DoS\n- [ ] **Data Corruption**: Partial writes, inconsistency\n- [ ] **Cascading Failures**: Downstream service issues </scenario_checklist>\n\n### 6. Multi-Angle Review Perspectives\n\n#### Technical Excellence Angle\n\n- Code craftsmanship evaluation\n- Engineering best practices\n- Technical documentation quality\n- Tooling and automation assessment\n\n#### Business Value Angle\n\n- Feature completeness validation\n- Performance impact on users\n- Cost-benefit analysis\n- Time-to-market considerations\n\n#### Risk Management Angle\n\n- Security risk assessment\n- Operational risk evaluation\n- Compliance risk verification\n- Technical debt accumulation\n\n#### Team Dynamics Angle\n\n- Code review etiquette\n- Knowledge sharing effectiveness\n- Collaboration patterns\n- Mentoring opportunities\n\n### 4. Simplification and Minimalism Review\n\nRun the Task code-simplicity-reviewer() to see if we can simplify the code.\n\n### 5. Findings Synthesis and Todo Creation\n\n<critical_requirement> All findings MUST be converted to actionable todos in the CLI todo system </critical_requirement>\n\n#### Step 1: Synthesize All Findings\n\n<thinking>\nConsolidate all agent reports into a categorized list of findings.\nRemove duplicates, prioritize by severity and impact.\n</thinking>\n\n<synthesis_tasks>\n- [ ] Collect findings from all parallel agents\n- [ ] Categorize by type: security, performance, architecture, quality, etc.\n- [ ] Assign severity levels: üî¥ CRITICAL (P1), üü° IMPORTANT (P2), üîµ NICE-TO-HAVE (P3)\n- [ ] Remove duplicate or overlapping findings\n- [ ] Estimate effort for each finding (Small/Medium/Large)\n</synthesis_tasks>\n\n#### Step 2: Present Findings for Triage\n\nFor EACH finding, present in this format:\n\n```\n---\nFinding #X: [Brief Title]\n\nSeverity: üî¥ P1 / üü° P2 / üîµ P3\n\nCategory: [Security/Performance/Architecture/Quality/etc.]\n\nDescription:\n[Detailed explanation of the issue or improvement]\n\nLocation: [file_path:line_number]\n\nProblem:\n[What's wrong or could be better]\n\nImpact:\n[Why this matters, what could happen]\n\nProposed Solution:\n[How to fix it]\n\nEffort: Small/Medium/Large\n\n---\nDo you want to add this to the todo list?\n1. yes - create todo file\n2. next - skip this finding\n3. custom - modify before creating\n```\n\n#### Step 3: Create Todo Files for Approved Findings\n\n<instructions>\nWhen user says \"yes\", create a properly formatted todo file:\n</instructions>\n\n<todo_creation_process>\n\n1. **Determine next issue ID:**\n   ```bash\n   ls todos/ | grep -o '^[0-9]\\+' | sort -n | tail -1\n   ```\n\n2. **Generate filename:**\n   ```\n   {next_id}-pending-{priority}-{brief-description}.md\n   ```\n   Example: `042-pending-p1-sql-injection-risk.md`\n\n3. **Create file from template:**\n   ```bash\n   cp todos/000-pending-p1-TEMPLATE.md todos/{new_filename}\n   ```\n\n4. **Populate with finding data:**\n   ```yaml\n   ---\n   status: pending\n   priority: p1  # or p2, p3 based on severity\n   issue_id: \"042\"\n   tags: [code-review, security, rails]  # add relevant tags\n   dependencies: []\n   ---\n\n   # [Finding Title]\n\n   ## Problem Statement\n   [Detailed description from finding]\n\n   ## Findings\n   - Discovered during code review by [agent names]\n   - Location: [file_path:line_number]\n   - [Key discoveries from agents]\n\n   ## Proposed Solutions\n\n   ### Option 1: [Primary solution from finding]\n   - **Pros**: [Benefits]\n   - **Cons**: [Drawbacks]\n   - **Effort**: [Small/Medium/Large]\n   - **Risk**: [Low/Medium/High]\n\n   ## Recommended Action\n   [Leave blank - needs manager triage]\n\n   ## Technical Details\n   - **Affected Files**: [List from finding]\n   - **Related Components**: [Models, controllers, services affected]\n   - **Database Changes**: [Yes/No - describe if yes]\n\n   ## Resources\n   - Code review PR: [PR link if applicable]\n   - Related findings: [Other finding numbers]\n   - Agent reports: [Which agents flagged this]\n\n   ## Acceptance Criteria\n   - [ ] [Specific criteria based on solution]\n   - [ ] Tests pass\n   - [ ] Code reviewed\n\n   ## Work Log\n\n   ### {date} - Code Review Discovery\n   **By:** Claude Code Review System\n   **Actions:**\n   - Discovered during comprehensive code review\n   - Analyzed by multiple specialized agents\n   - Categorized and prioritized\n\n   **Learnings:**\n   - [Key insights from agent analysis]\n\n   ## Notes\n   Source: Code review performed on {date}\n   Review command: /workflows:review {arguments}\n   ```\n\n5. **Track creation:**\n   Add to TodoWrite list if tracking multiple findings\n\n</todo_creation_process>\n\n#### Step 4: Summary Report\n\nAfter processing all findings:\n\n```markdown\n## Code Review Complete\n\n**Review Target:** [PR number or branch]\n**Total Findings:** [X]\n**Todos Created:** [Y]\n\n### Created Todos:\n- `{issue_id}-pending-p1-{description}.md` - {title}\n- `{issue_id}-pending-p2-{description}.md` - {title}\n...\n\n### Skipped Findings:\n- [Finding #Z]: {reason}\n...\n\n### Next Steps:\n1. Triage pending todos: `ls todos/*-pending-*.md`\n2. Use `/triage` to review and approve\n3. Work on approved items: `/resolve_todo_parallel`\n```\n\n#### Alternative: Batch Creation\n\nIf user wants to convert all findings to todos without review:\n\n```bash\n# Ask: \"Create todos for all X findings? (yes/no/show-critical-only)\"\n# If yes: create todo files for all findings in parallel\n# If show-critical-only: only present P1 findings for triage\n```\n"
              },
              {
                "name": "/triage",
                "description": null,
                "path": "plugins/traya-frontend-engineering/commands/triage.md",
                "frontmatter": null,
                "content": "Present all findings, decisions, or issues here one by one for triage. The goal is to go through each item and decide whether to add it to the CLI todo system.\n\n**IMPORTANT: DO NOT CODE ANYTHING DURING TRIAGE!**\n\nThis command is for:\n- Triaging code review findings\n- Processing security audit results\n- Reviewing performance analysis\n- Handling any other categorized findings that need tracking\n\n## Workflow\n\n### Step 1: Present Each Finding\n\nFor each finding, present in this format:\n\n```\n---\nIssue #X: [Brief Title]\n\nSeverity: üî¥ P1 (CRITICAL) / üü° P2 (IMPORTANT) / üîµ P3 (NICE-TO-HAVE)\n\nCategory: [Security/Performance/Architecture/Bug/Feature/etc.]\n\nDescription:\n[Detailed explanation of the issue or improvement]\n\nLocation: [file_path:line_number]\n\nProblem Scenario:\n[Step by step what's wrong or could happen]\n\nProposed Solution:\n[How to fix it]\n\nEstimated Effort: [Small (< 2 hours) / Medium (2-8 hours) / Large (> 8 hours)]\n\n---\nDo you want to add this to the todo list?\n1. yes - create todo file\n2. next - skip this item\n3. custom - modify before creating\n```\n\n### Step 2: Handle User Decision\n\n**When user says \"yes\":**\n\n1. **Determine next issue ID:**\n   ```bash\n   ls todos/ | grep -o '^[0-9]\\+' | sort -n | tail -1\n   ```\n\n2. **Create filename:**\n   ```\n   {next_id}-pending-{priority}-{brief-description}.md\n   ```\n\n   Priority mapping:\n   - üî¥ P1 (CRITICAL) ‚Üí `p1`\n   - üü° P2 (IMPORTANT) ‚Üí `p2`\n   - üîµ P3 (NICE-TO-HAVE) ‚Üí `p3`\n\n   Example: `042-pending-p1-transaction-boundaries.md`\n\n3. **Create from template:**\n   ```bash\n   cp todos/000-pending-p1-TEMPLATE.md todos/{new_filename}\n   ```\n\n4. **Populate the file:**\n   ```yaml\n   ---\n   status: pending\n   priority: p1  # or p2, p3 based on severity\n   issue_id: \"042\"\n   tags: [category, relevant-tags]\n   dependencies: []\n   ---\n\n   # [Issue Title]\n\n   ## Problem Statement\n   [Description from finding]\n\n   ## Findings\n   - [Key discoveries]\n   - Location: [file_path:line_number]\n   - [Scenario details]\n\n   ## Proposed Solutions\n\n   ### Option 1: [Primary solution]\n   - **Pros**: [Benefits]\n   - **Cons**: [Drawbacks if any]\n   - **Effort**: [Small/Medium/Large]\n   - **Risk**: [Low/Medium/High]\n\n   ## Recommended Action\n   [Leave blank - will be filled during approval]\n\n   ## Technical Details\n   - **Affected Files**: [List files]\n   - **Related Components**: [Components affected]\n   - **Database Changes**: [Yes/No - describe if yes]\n\n   ## Resources\n   - Original finding: [Source of this issue]\n   - Related issues: [If any]\n\n   ## Acceptance Criteria\n   - [ ] [Specific success criteria]\n   - [ ] Tests pass\n   - [ ] Code reviewed\n\n   ## Work Log\n\n   ### {date} - Initial Discovery\n   **By:** Claude Triage System\n   **Actions:**\n   - Issue discovered during [triage session type]\n   - Categorized as {severity}\n   - Estimated effort: {effort}\n\n   **Learnings:**\n   - [Context and insights]\n\n   ## Notes\n   Source: Triage session on {date}\n   ```\n\n5. **Confirm creation:**\n   \"‚úÖ Created: `{filename}` - Issue #{issue_id}\"\n\n**When user says \"next\":**\n- Skip to the next item\n- Track skipped items for summary\n\n**When user says \"custom\":**\n- Ask what to modify (priority, description, details)\n- Update the information\n- Present revised version\n- Ask again: yes/next/custom\n\n### Step 3: Continue Until All Processed\n\n- Process all items one by one\n- Track using TodoWrite for visibility\n- Don't wait for approval between items - keep moving\n\n### Step 4: Final Summary\n\nAfter all items processed:\n\n```markdown\n## Triage Complete\n\n**Total Items:** [X]\n**Todos Created:** [Y]\n**Skipped:** [Z]\n\n### Created Todos:\n- `042-pending-p1-transaction-boundaries.md` - Transaction boundary issue\n- `043-pending-p2-cache-optimization.md` - Cache performance improvement\n...\n\n### Skipped Items:\n- Item #5: [reason]\n- Item #12: [reason]\n\n### Next Steps:\n1. Review pending todos: `ls todos/*-pending-*.md`\n2. Approve for work: Move from pending ‚Üí ready status\n3. Start work: Use `/resolve_todo_parallel` or pick individually\n```\n\n## Example Response Format\n\n```\n---\nIssue #5: Missing Transaction Boundaries for Multi-Step Operations\n\nSeverity: üî¥ P1 (CRITICAL)\n\nCategory: Data Integrity / Security\n\nDescription:\nThe google_oauth2_connected callback in GoogleOauthCallbacks concern performs multiple database\noperations without transaction protection. If any step fails midway, the database is left in an\ninconsistent state.\n\nLocation: app/controllers/concerns/google_oauth_callbacks.rb:13-50\n\nProblem Scenario:\n1. User.update succeeds (email changed)\n2. Account.save! fails (validation error)\n3. Result: User has changed email but no associated Account\n4. Next login attempt fails completely\n\nOperations Without Transaction:\n- User confirmation (line 13)\n- Waitlist removal (line 14)\n- User profile update (line 21-23)\n- Account creation (line 28-37)\n- Avatar attachment (line 39-45)\n- Journey creation (line 47)\n\nProposed Solution:\nWrap all operations in ApplicationRecord.transaction do ... end block\n\nEstimated Effort: Small (30 minutes)\n\n---\nDo you want to add this to the todo list?\n1. yes - create todo file\n2. next - skip this item\n3. custom - modify before creating\n```\n\nDo not code, and if you say yes, make sure to mark the to‚Äëdo as ready to pick up or something. If you make any changes, update the file and then continue to read the next one. If next is selecrte make sure to remove the to‚Äëdo from the list since its not relevant.\n\nEvery time you present the to‚Äëdo as a header, can you say what the progress of the triage is, how many we have done and how many are left, and an estimated time for completion, looking at how quickly we go through them as well?\n"
              },
              {
                "name": "/work",
                "description": null,
                "path": "plugins/traya-frontend-engineering/commands/work.md",
                "frontmatter": null,
                "content": "# Work Plan Execution Command\n\n## Introduction\n\nThis command helps you analyze a work document (plan, Markdown file, specification, or any structured document), create a comprehensive todo list using the TodoWrite tool, and then systematically execute each task until the entire plan is completed. It combines deep analysis with practical execution to transform plans into reality.\n\n**Skill-Based Execution**: The command automatically detects task types (UI development, API integration) and invokes appropriate skills (ui-developer, api-integrator, ui-tester, code-reviewer) for comprehensive, iterative workflows with built-in quality assurance. This leverages all bundled MCP servers (Figma, Postman, Chrome DevTools, Context7, Serena) to ensure production-ready results.\n\n## Prerequisites\n\n- A work document to analyze (plan file, specification, or any structured document)\n- Clear understanding of project context and goals\n- Access to necessary tools and permissions for implementation\n- Ability to test and validate completed work\n- Git repository with main branch\n- **Bundled MCP servers** (automatically configured with plugin):\n  - Figma MCP (for ui-developer skill - requires Figma Desktop App)\n  - Postman MCP (for api-integrator skill)\n  - Chrome DevTools MCP (for ui-developer, api-integrator, ui-tester skills)\n  - Context7 MCP (for documentation and best practices)\n  - Serena MCP (for codebase pattern analysis)\n\n## Main Tasks\n\n### 1. Setup Development Environment\n\n- Ensure main branch is up to date\n- Create feature branch with descriptive name\n- Setup worktree for isolated development\n- Configure development environment\n\n### 2. Analyze Input Document\n\n<input_document> #$ARGUMENTS </input_document>\n\n## Execution Workflow\n\n### Phase 1: Environment Setup\n\n1. **Update Main Branch**\n\n   ```bash\n   git checkout main\n   git pull origin main\n   ```\n\n2. **Create Feature Branch and Worktree**\n\n   - Determine appropriate branch name from document\n   - Get the root directory of the Git repository:\n\n   ```bash\n   git_root=$(git rev-parse --show-toplevel)\n   ```\n\n   - Create worktrees directory if it doesn't exist:\n\n   ```bash\n   mkdir -p \"$git_root/.worktrees\"\n   ```\n\n   - Add .worktrees to .gitignore if not already there:\n\n   ```bash\n   if ! grep -q \"^\\.worktrees$\" \"$git_root/.gitignore\"; then\n     echo \".worktrees\" >> \"$git_root/.gitignore\"\n   fi\n   ```\n\n   - Create the new worktree with feature branch:\n\n   ```bash\n   git worktree add -b feature-branch-name \"$git_root/.worktrees/feature-branch-name\" main\n   ```\n\n   - Change to the new worktree directory:\n\n   ```bash\n   cd \"$git_root/.worktrees/feature-branch-name\"\n   ```\n\n3. **Verify Environment**\n   - Confirm in correct worktree directory\n   - Install dependencies if needed\n   - Run initial tests to ensure clean state\n\n### Phase 2: Document Analysis and Planning\n\n1. **Read Input Document**\n\n   - Use Read tool to examine the work document\n   - Identify all deliverables and requirements\n   - Note any constraints or dependencies\n   - Extract success criteria\n\n2. **Create Task Breakdown**\n\n   - Convert requirements into specific tasks\n   - Add implementation details for each task\n   - Include testing and validation steps\n   - Consider edge cases and error handling\n\n3. **Build Todo List**\n   - Use TodoWrite to create comprehensive list\n   - Set priorities based on dependencies\n   - Include all subtasks and checkpoints\n   - Add documentation and review tasks\n\n### Phase 3: Systematic Execution\n\n1. **Detect Task Type and Invoke Skills**\n\n   Analyze the work document and todo list to determine the task type, then automatically invoke appropriate skills for comprehensive execution:\n\n   **A. For UI Development Tasks**\n\n   If the work involves building UI components from Figma designs or creating new pages/components:\n\n   ```\n   1. Invoke ui-developer skill\n      - Extract design specifications from Figma (Figma MCP)\n      - Analyze existing codebase patterns (Serena MCP)\n      - Fetch library documentation (Context7 MCP)\n      - Implement component with TypeScript + Tailwind\n      - Visual verification loop with Chrome DevTools\n      - Iterate until pixel-perfect match\n\n   2. If backend APIs needed ‚Üí Invoke api-integrator skill\n      - Test APIs with Postman (Postman MCP)\n      - Set up API client with interceptors\n      - Implement authentication integration\n      - Connect APIs to UI components\n      - Add loading and error states\n      - Integration testing with Chrome DevTools\n      - Security audit\n\n   3. Invoke ui-tester skill\n      - Functional testing (all interactive elements)\n      - Error detection and analysis\n      - Responsive and visual testing\n      - Accessibility validation (WCAG compliance)\n      - Performance testing (Core Web Vitals)\n      - Issue documentation and fixing\n      - Final validation\n\n   4. Invoke code-reviewer skill\n      - Task completion verification\n      - Technical quality review\n      - Best practices validation (Context7 MCP)\n      - Code structure and organization review\n      - Performance, security, accessibility checks\n      - Project conventions compliance\n   ```\n\n   **B. For API Integration Tasks**\n\n   If the work focuses primarily on connecting backend APIs:\n\n   ```\n   1. Invoke api-integrator skill\n      - API discovery and planning (Serena MCP for patterns)\n      - Comprehensive API testing with Postman MCP\n      - Frontend integration (authentication, data fetching)\n      - Integration testing with Chrome DevTools MCP\n      - Performance optimization\n      - Security audit\n      - Documentation\n\n   2. Invoke ui-tester skill\n      - Test complete data flow from API to UI\n      - Network monitoring and validation\n      - Error scenario testing\n      - Performance validation\n\n   3. Invoke code-reviewer skill\n      - Integration quality review\n      - Security validation\n      - Performance check\n      - Best practices compliance\n   ```\n\n   **C. For Other Tasks**\n\n   If the work doesn't fit UI development or API integration patterns, fall back to manual execution with the task loop below.\n\n2. **Task Execution Loop** (Fallback for non-UI/API tasks)\n\n   ```\n   while (tasks remain):\n     - Select next task (priority + dependencies)\n     - Mark as in_progress\n     - Execute task completely\n     - Validate completion\n     - Mark as completed\n     - Update progress\n   ```\n\n3. **Quality Assurance**\n\n   - Run tests after each task (lint, typecheck, unit tests)\n   - Execute lint and typecheck commands\n   - Verify no regressions\n   - Check against acceptance criteria\n   - Document any issues found\n   - Ensure all MCP-based validations passed (if skills were used)\n\n4. **Progress Tracking**\n   - Regularly update task status\n   - Note any blockers or delays\n   - Create new tasks for discoveries\n   - Maintain work visibility\n   - Document skill execution results\n\n### Phase 4: Completion and Submission\n\n1. **Final Validation**\n\n   - Verify all tasks completed\n   - Run comprehensive test suite\n   - Execute final lint and typecheck\n   - Check all deliverables present\n   - Ensure documentation updated\n\n2. **Prepare for Submission**\n\n   - Stage and commit all changes\n   - Write commit messages\n   - Push feature branch to remote\n   - Create detailed pull request\n\n3. **Create Pull Request**\n   ```bash\n   git push -u origin feature-branch-name\n   gh pr create --title \"Feature: [Description]\" --body \"[Detailed description]\"\n   ```\n"
              }
            ],
            "skills": []
          },
          {
            "name": "traya-react-native",
            "description": "AI-powered React Native development workflow with compounding engineering principles. Build high-quality iOS and Android apps with 16 specialized agents, 4 workflow skills, and 6 commands. Includes bundled MCP servers for Figma, iOS Simulator, Android testing, and API integration.",
            "source": "./plugins/traya-react-native",
            "category": null,
            "version": "1.0.0",
            "author": {
              "name": "Shivraj Kumar",
              "url": "https://github.com/trayalabs1",
              "email": "shivrajkumar@traya.health"
            },
            "install_commands": [
              "/plugin marketplace add shivrajkumar/traya-plugin",
              "/plugin install traya-react-native@traya-plugin"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-04T12:42:23Z",
              "created_at": "2025-10-29T12:31:50Z",
              "license": null
            },
            "commands": [
              {
                "name": "/generate_command",
                "description": null,
                "path": "plugins/traya-react-native/commands/generate_command.md",
                "frontmatter": null,
                "content": "# Create a Custom Claude Code Command\n\nCreate a new slash command in `.claude/commands/` for the requested task.\n\n## Goal\n\n#$ARGUMENTS\n\n## Key Capabilities to Leverage\n\n**File Operations:**\n- Read, Edit, Write - modify files precisely\n- Glob, Grep - search codebase\n- MultiEdit - atomic multi-part changes\n\n**Development:**\n- Bash - run commands (git, tests, linters)\n- Task - launch specialized agents for complex tasks\n- TodoWrite - track progress with todo lists\n\n**Web & APIs:**\n- WebFetch, WebSearch - research documentation\n- GitHub (gh cli) - PRs, issues, reviews\n- Puppeteer - browser automation, screenshots\n\n**Integrations:**\n- AppSignal - logs and monitoring\n- Context7 - framework docs\n- Stripe, Todoist, Featurebase (if relevant)\n\n## Best Practices\n\n1. **Be specific and clear** - detailed instructions yield better results\n2. **Break down complex tasks** - use step-by-step plans\n3. **Use examples** - reference existing code patterns\n4. **Include success criteria** - tests pass, linting clean, etc.\n5. **Think first** - use \"think hard\" or \"plan\" keywords for complex problems\n6. **Iterate** - guide the process step by step\n\n## Structure Your Command\n\n```markdown\n# [Command Name]\n\n[Brief description of what this command does]\n\n## Steps\n\n1. [First step with specific details]\n   - Include file paths, patterns, or constraints\n   - Reference existing code if applicable\n\n2. [Second step]\n   - Use parallel tool calls when possible\n   - Check/verify results\n\n3. [Final steps]\n   - Run tests\n   - Lint code\n   - Commit changes (if appropriate)\n\n## Success Criteria\n\n- [ ] Tests pass\n- [ ] Code follows style guide\n- [ ] Documentation updated (if needed)\n```\n\n## Tips for Effective Commands\n\n- **Use $ARGUMENTS** placeholder for dynamic inputs\n- **Reference CLAUDE.md** patterns and conventions\n- **Include verification steps** - tests, linting, visual checks\n- **Be explicit about constraints** - don't modify X, use pattern Y\n- **Use XML tags** for structured prompts: `<task>`, `<requirements>`, `<constraints>`\n\n## Example Pattern\n\n```markdown\nImplement #$ARGUMENTS following these steps:\n\n1. Research existing patterns\n   - Search for similar code using Grep\n   - Read relevant files to understand approach\n\n2. Plan the implementation\n   - Think through edge cases and requirements\n   - Consider test cases needed\n\n3. Implement\n   - Follow existing code patterns (reference specific files)\n   - Write tests first if doing TDD\n   - Ensure code follows CLAUDE.md conventions\n\n4. Verify\n   - Run tests:\n     - Rails: `bin/rails test` or `bundle exec rspec`\n     - TypeScript: `npm test` or `yarn test` (Jest/Vitest)\n     - Python: `pytest` or `python -m pytest`\n   - Run linter:\n     - Rails: `bundle exec standardrb` or `bundle exec rubocop`\n     - TypeScript: `npm run lint` or `eslint .`\n     - Python: `ruff check .` or `flake8`\n   - Check changes with git diff\n\n5. Commit (optional)\n   - Stage changes\n   - Write clear commit message\n```\n\nNow create the command file at `.claude/commands/[name].md` with the structure above.\n"
              },
              {
                "name": "/plan",
                "description": null,
                "path": "plugins/traya-react-native/commands/plan.md",
                "frontmatter": null,
                "content": "# Create GitHub Issue\n\n## Introduction\n\nTransform feature descriptions, bug reports, or improvement ideas into well-structured markdown files issues that follow project conventions and best practices. This command provides flexible detail levels to match your needs.\n\n## Feature Description\n\n<feature_description> #$ARGUMENTS </feature_description>\n\n## Main Tasks\n\n### 1. Repository Research & Context Gathering\n\n<thinking>\nFirst, I need to understand the project's conventions and existing patterns, leveraging all available resources and use paralel subagents to do this.\n</thinking>\n\nRunn these three agents in paralel at the same time:\n\n- Task repo-research-analyst(feature_description)\n- Task best-practices-researcher (feature_description)\n- Task framework-docs-researcher (feature_description)\n\n**Reference Collection:**\n\n- [ ] Document all research findings with specific file paths (e.g., `app/services/example_service.rb:42`)\n- [ ] Include URLs to external documentation and best practices guides\n- [ ] Create a reference list of similar issues or PRs (e.g., `#123`, `#456`)\n- [ ] Note any team conventions discovered in `CLAUDE.md` or team documentation\n\n### 2. Issue Planning & Structure\n\n<thinking>\nThink like a product manager - what would make this issue clear and actionable? Consider multiple perspectives\n</thinking>\n\n**Title & Categorization:**\n\n- [ ] Draft clear, searchable issue title using conventional format (e.g., `feat:`, `fix:`, `docs:`)\n- [ ] Identify appropriate labels from repository's label set (`gh label list`)\n- [ ] Determine issue type: enhancement, bug, refactor\n\n**Stakeholder Analysis:**\n\n- [ ] Identify who will be affected by this issue (end users, developers, operations)\n- [ ] Consider implementation complexity and required expertise\n\n**Content Planning:**\n\n- [ ] Choose appropriate detail level based on issue complexity and audience\n- [ ] List all necessary sections for the chosen template\n- [ ] Gather supporting materials (error logs, screenshots, design mockups)\n- [ ] Prepare code examples or reproduction steps if applicable, name the mock filenames in the lists\n\n### 3. Choose Implementation Detail Level\n\nSelect how comprehensive you want the issue to be:\n\n#### üìÑ MINIMAL (Quick Issue)\n\n**Best for:** Simple bugs, small improvements, clear features\n\n**Includes:**\n\n- Problem statement or feature description\n- Basic acceptance criteria\n- Essential context only\n\n**Structure:**\n\n````markdown\n[Brief problem/feature description]\n\n## Acceptance Criteria\n\n- [ ] Core requirement 1\n- [ ] Core requirement 2\n\n## Context\n\n[Any critical information]\n\n## MVP\n\n### test.rb\n\n```ruby\nclass Test\n  def initialize\n    @name = \"test\"\n  end\nend\n```\n\n## References\n\n- Related issue: #[issue_number]\n- Documentation: [relevant_docs_url]\n````\n\n#### üìã MORE (Standard Issue)\n\n**Best for:** Most features, complex bugs, team collaboration\n\n**Includes everything from MINIMAL plus:**\n\n- Detailed background and motivation\n- Technical considerations\n- Success metrics\n- Dependencies and risks\n- Basic implementation suggestions\n\n**Structure:**\n\n```markdown\n## Overview\n\n[Comprehensive description]\n\n## Problem Statement / Motivation\n\n[Why this matters]\n\n## Proposed Solution\n\n[High-level approach]\n\n## Technical Considerations\n\n- Architecture impacts\n- Performance implications\n- Security considerations\n\n## Acceptance Criteria\n\n- [ ] Detailed requirement 1\n- [ ] Detailed requirement 2\n- [ ] Testing requirements\n\n## Success Metrics\n\n[How we measure success]\n\n## Dependencies & Risks\n\n[What could block or complicate this]\n\n## References & Research\n\n- Similar implementations: [file_path:line_number]\n- Best practices: [documentation_url]\n- Related PRs: #[pr_number]\n```\n\n#### üìö A LOT (Comprehensive Issue)\n\n**Best for:** Major features, architectural changes, complex integrations\n\n**Includes everything from MORE plus:**\n\n- Detailed implementation plan with phases\n- Alternative approaches considered\n- Extensive technical specifications\n- Resource requirements and timeline\n- Future considerations and extensibility\n- Risk mitigation strategies\n- Documentation requirements\n\n**Structure:**\n\n```markdown\n## Overview\n\n[Executive summary]\n\n## Problem Statement\n\n[Detailed problem analysis]\n\n## Proposed Solution\n\n[Comprehensive solution design]\n\n## Technical Approach\n\n### Architecture\n\n[Detailed technical design]\n\n### Implementation Phases\n\n#### Phase 1: [Foundation]\n\n- Tasks and deliverables\n- Success criteria\n- Estimated effort\n\n#### Phase 2: [Core Implementation]\n\n- Tasks and deliverables\n- Success criteria\n- Estimated effort\n\n#### Phase 3: [Polish & Optimization]\n\n- Tasks and deliverables\n- Success criteria\n- Estimated effort\n\n## Alternative Approaches Considered\n\n[Other solutions evaluated and why rejected]\n\n## Acceptance Criteria\n\n### Functional Requirements\n\n- [ ] Detailed functional criteria\n\n### Non-Functional Requirements\n\n- [ ] Performance targets\n- [ ] Security requirements\n- [ ] Accessibility standards\n\n### Quality Gates\n\n- [ ] Test coverage requirements\n- [ ] Documentation completeness\n- [ ] Code review approval\n\n## Success Metrics\n\n[Detailed KPIs and measurement methods]\n\n## Dependencies & Prerequisites\n\n[Detailed dependency analysis]\n\n## Risk Analysis & Mitigation\n\n[Comprehensive risk assessment]\n\n## Resource Requirements\n\n[Team, time, infrastructure needs]\n\n## Future Considerations\n\n[Extensibility and long-term vision]\n\n## Documentation Plan\n\n[What docs need updating]\n\n## References & Research\n\n### Internal References\n\n- Architecture decisions: [file_path:line_number]\n- Similar features: [file_path:line_number]\n- Configuration: [file_path:line_number]\n\n### External References\n\n- Framework documentation: [url]\n- Best practices guide: [url]\n- Industry standards: [url]\n\n### Related Work\n\n- Previous PRs: #[pr_numbers]\n- Related issues: #[issue_numbers]\n- Design documents: [links]\n```\n\n### 4. Issue Creation & Formatting\n\n<thinking>\nApply best practices for clarity and actionability, making the issue easy to scan and understand\n</thinking>\n\n**Content Formatting:**\n\n- [ ] Use clear, descriptive headings with proper hierarchy (##, ###)\n- [ ] Include code examples in triple backticks with language syntax highlighting\n- [ ] Add screenshots/mockups if UI-related (drag & drop or use image hosting)\n- [ ] Use task lists (- [ ]) for trackable items that can be checked off\n- [ ] Add collapsible sections for lengthy logs or optional details using `<details>` tags\n- [ ] Apply appropriate emoji for visual scanning (üêõ bug, ‚ú® feature, üìö docs, ‚ôªÔ∏è refactor)\n\n**Cross-Referencing:**\n\n- [ ] Link to related issues/PRs using #number format\n- [ ] Reference specific commits with SHA hashes when relevant\n- [ ] Link to code using GitHub's permalink feature (press 'y' for permanent link)\n- [ ] Mention relevant team members with @username if needed\n- [ ] Add links to external resources with descriptive text\n\n**Code & Examples:**\n\n```markdown\n# Good example with syntax highlighting and line references\n\n\\`\\`\\`ruby\n\n# app/services/user_service.rb:42\n\ndef process_user(user)\n\n# Implementation here\n\nend \\`\\`\\`\n\n# Collapsible error logs\n\n<details>\n<summary>Full error stacktrace</summary>\n\n\\`\\`\\` Error details here... \\`\\`\\`\n\n</details>\n```\n\n**AI-Era Considerations:**\n\n- [ ] Account for accelerated development with AI pair programming\n- [ ] Include prompts or instructions that worked well during research\n- [ ] Note which AI tools were used for initial exploration (Claude, Copilot, etc.)\n- [ ] Emphasize comprehensive testing given rapid implementation\n- [ ] Document any AI-generated code that needs human review\n\n### 5. Final Review & Submission\n\n**Pre-submission Checklist:**\n\n- [ ] Title is searchable and descriptive\n- [ ] Labels accurately categorize the issue\n- [ ] All template sections are complete\n- [ ] Links and references are working\n- [ ] Acceptance criteria are measurable\n- [ ] Add names of files in pseudo code examples and todo lists\n- [ ] Add an ERD mermaid diagram if applicable for new model changes\n\n## Output Format\n\nPresent the complete issue content within `<github_issue>` tags, ready for GitHub CLI:\n\n```bash\ngh issue create --title \"[TITLE]\" --body \"[CONTENT]\" --label \"[LABELS]\"\n```\n\n## Thinking Approaches\n\n- **Analytical:** Break down complex features into manageable components\n- **User-Centric:** Consider end-user impact and experience\n- **Technical:** Evaluate implementation complexity and architecture fit\n- **Strategic:** Align with project goals and roadmap\n"
              },
              {
                "name": "/resolve_todo_parallel",
                "description": null,
                "path": "plugins/traya-react-native/commands/resolve_todo_parallel.md",
                "frontmatter": null,
                "content": "Resolve all TODO comments using parallel processing.\n\n## Workflow\n\n### 1. Analyze\n\nGet all unresolved TODOs from the /todos/\\*.md directory\n\n### 2. Plan\n\nCreate a TodoWrite list of all unresolved items grouped by type.Make sure to look at dependencies that might occur and prioritize the ones needed by others. For example, if you need to change a name, you must wait to do the others. Output a mermaid flow diagram showing how we can do this. Can we do everything in parallel? Do we need to do one first that leads to others in parallel? I'll put the to-dos in the mermaid diagram flow‚Äëwise so the agent knows how to proceed in order.\n\n### 3. Implement (PARALLEL)\n\nSpawn a pr-comment-resolver agent for each unresolved item in parallel.\n\nSo if there are 3 comments, it will spawn 3 pr-comment-resolver agents in parallel. liek this\n\n1. Task pr-comment-resolver(comment1)\n2. Task pr-comment-resolver(comment2)\n3. Task pr-comment-resolver(comment3)\n\nAlways run all in parallel subagents/Tasks for each Todo item.\n\n### 4. Commit & Resolve\n\n- Commit changes\n- Remove the TODO from the file, and mark it as resolved.\n- Push to remote\n"
              },
              {
                "name": "/review",
                "description": null,
                "path": "plugins/traya-react-native/commands/review.md",
                "frontmatter": null,
                "content": "# Review Command\n\n<command_purpose> Perform exhaustive code reviews using multi-agent analysis, ultra-thinking, and Git worktrees for deep local inspection. </command_purpose>\n\n## Introduction\n\n<role>Senior Code Review Architect with expertise in security, performance, architecture, and quality assurance</role>\n\n## Prerequisites\n\n<requirements>\n- Git repository with GitHub CLI (`gh`) installed and authenticated\n- Clean main/master branch\n- Proper permissions to create worktrees and access the repository\n- For document reviews: Path to a markdown file or document\n</requirements>\n\n## Main Tasks\n\n### 1. Worktree Creation and Branch Checkout (ALWAYS FIRST)\n\n<review_target> #$ARGUMENTS </review_target>\n\n<critical_requirement> MUST create worktree FIRST to enable local code analysis. No exceptions. </critical_requirement>\n\n<thinking>\nFirst, I need to determine the review target type and set up the worktree.\nThis enables all subsequent agents to analyze actual code, not just diffs.\n</thinking>\n\n#### Immediate Actions:\n\n<task_list>\n\n- [ ] Determine review type: PR number (numeric), GitHub URL, file path (.md), or empty (latest PR)\n- [ ] Create worktree directory structure at `$git_root/.worktrees/reviews/pr-$identifier`\n- [ ] Check out PR branch in isolated worktree using `gh pr checkout`\n- [ ] Navigate to worktree - ALL subsequent analysis happens here\n\n- Fetch PR metadata using `gh pr view --json` for title, body, files, linked issues\n- Clone PR branch into worktree with full history `gh pr checkout $identifier`\n- Set up language-specific analysis tools\n- Prepare security scanning environment\n\nEnsure that the worktree is set up correctly and that the PR is checked out. ONLY then proceed to the next step.\n\n</task_list>\n\n#### Detect Project Type\n\n<thinking>\nDetermine the project type by analyzing the codebase structure and files.\nThis will inform which language-specific reviewers to use.\n</thinking>\n\n<project_type_detection>\n\nCheck for these indicators to determine project type:\n\n**TypeScript/React/Next.js Project**:\n- `tsconfig.json`\n- `package.json` with TypeScript, React, or Next.js dependencies\n- `.ts`, `.tsx`, `.jsx` files\n- `next.config.js` or `next.config.ts` (for Next.js)\n\nBased on detection, set appropriate reviewers for parallel execution.\n\n</project_type_detection>\n\n#### Parallel Agents to review the PR:\n\n<parallel_tasks>\n\nRun ALL or most of these agents at the same time, adjusting language-specific reviewers based on project type:\n\n**Language-Specific Reviewers (choose based on project type)**:\n\nFor TypeScript/React/Next.js projects:\n1. Task typescript-reviewer(PR content)\n\n**Universal Reviewers (run for all project types)**:\n2. Task git-history-analyzer(PR content)\n3. Task pattern-recognition-specialist(PR content)\n4. Task architecture-strategist(PR content)\n5. Task security-sentinel(PR content)\n6. Task performance-oracle(PR content)\n\n</parallel_tasks>\n\n### 4. Ultra-Thinking Deep Dive Phases\n\n<ultrathink_instruction> For each phase below, spend maximum cognitive effort. Think step by step. Consider all angles. Question assumptions. And bring all reviews in a synthesis to the user.</ultrathink_instruction>\n\n<deliverable>\nComplete system context map with component interactions\n</deliverable>\n\n#### Phase 3: Stakeholder Perspective Analysis\n\n<thinking_prompt> ULTRA-THINK: Put yourself in each stakeholder's shoes. What matters to them? What are their pain points? </thinking_prompt>\n\n<stakeholder_perspectives>\n\n1. **Developer Perspective** <questions>\n\n   - How easy is this to understand and modify?\n   - Are the APIs intuitive?\n   - Is debugging straightforward?\n   - Can I test this easily? </questions>\n\n2. **Operations Perspective** <questions>\n\n   - How do I deploy this safely?\n   - What metrics and logs are available?\n   - How do I troubleshoot issues?\n   - What are the resource requirements? </questions>\n\n3. **End User Perspective** <questions>\n\n   - Is the feature intuitive?\n   - Are error messages helpful?\n   - Is performance acceptable?\n   - Does it solve my problem? </questions>\n\n4. **Security Team Perspective** <questions>\n\n   - What's the attack surface?\n   - Are there compliance requirements?\n   - How is data protected?\n   - What are the audit capabilities? </questions>\n\n5. **Business Perspective** <questions>\n   - What's the ROI?\n   - Are there legal/compliance risks?\n   - How does this affect time-to-market?\n   - What's the total cost of ownership? </questions> </stakeholder_perspectives>\n\n#### Phase 4: Scenario Exploration\n\n<thinking_prompt> ULTRA-THINK: Explore edge cases and failure scenarios. What could go wrong? How does the system behave under stress? </thinking_prompt>\n\n<scenario_checklist>\n\n- [ ] **Happy Path**: Normal operation with valid inputs\n- [ ] **Invalid Inputs**: Null, empty, malformed data\n- [ ] **Boundary Conditions**: Min/max values, empty collections\n- [ ] **Concurrent Access**: Race conditions, deadlocks\n- [ ] **Scale Testing**: 10x, 100x, 1000x normal load\n- [ ] **Network Issues**: Timeouts, partial failures\n- [ ] **Resource Exhaustion**: Memory, disk, connections\n- [ ] **Security Attacks**: Injection, overflow, DoS\n- [ ] **Data Corruption**: Partial writes, inconsistency\n- [ ] **Cascading Failures**: Downstream service issues </scenario_checklist>\n\n### 6. Multi-Angle Review Perspectives\n\n#### Technical Excellence Angle\n\n- Code craftsmanship evaluation\n- Engineering best practices\n- Technical documentation quality\n- Tooling and automation assessment\n\n#### Business Value Angle\n\n- Feature completeness validation\n- Performance impact on users\n- Cost-benefit analysis\n- Time-to-market considerations\n\n#### Risk Management Angle\n\n- Security risk assessment\n- Operational risk evaluation\n- Compliance risk verification\n- Technical debt accumulation\n\n#### Team Dynamics Angle\n\n- Code review etiquette\n- Knowledge sharing effectiveness\n- Collaboration patterns\n- Mentoring opportunities\n\n### 4. Simplification and Minimalism Review\n\nRun the Task code-simplicity-reviewer() to see if we can simplify the code.\n\n### 5. Findings Synthesis and Todo Creation\n\n<critical_requirement> All findings MUST be converted to actionable todos in the CLI todo system </critical_requirement>\n\n#### Step 1: Synthesize All Findings\n\n<thinking>\nConsolidate all agent reports into a categorized list of findings.\nRemove duplicates, prioritize by severity and impact.\n</thinking>\n\n<synthesis_tasks>\n- [ ] Collect findings from all parallel agents\n- [ ] Categorize by type: security, performance, architecture, quality, etc.\n- [ ] Assign severity levels: üî¥ CRITICAL (P1), üü° IMPORTANT (P2), üîµ NICE-TO-HAVE (P3)\n- [ ] Remove duplicate or overlapping findings\n- [ ] Estimate effort for each finding (Small/Medium/Large)\n</synthesis_tasks>\n\n#### Step 2: Present Findings for Triage\n\nFor EACH finding, present in this format:\n\n```\n---\nFinding #X: [Brief Title]\n\nSeverity: üî¥ P1 / üü° P2 / üîµ P3\n\nCategory: [Security/Performance/Architecture/Quality/etc.]\n\nDescription:\n[Detailed explanation of the issue or improvement]\n\nLocation: [file_path:line_number]\n\nProblem:\n[What's wrong or could be better]\n\nImpact:\n[Why this matters, what could happen]\n\nProposed Solution:\n[How to fix it]\n\nEffort: Small/Medium/Large\n\n---\nDo you want to add this to the todo list?\n1. yes - create todo file\n2. next - skip this finding\n3. custom - modify before creating\n```\n\n#### Step 3: Create Todo Files for Approved Findings\n\n<instructions>\nWhen user says \"yes\", create a properly formatted todo file:\n</instructions>\n\n<todo_creation_process>\n\n1. **Determine next issue ID:**\n   ```bash\n   ls todos/ | grep -o '^[0-9]\\+' | sort -n | tail -1\n   ```\n\n2. **Generate filename:**\n   ```\n   {next_id}-pending-{priority}-{brief-description}.md\n   ```\n   Example: `042-pending-p1-sql-injection-risk.md`\n\n3. **Create file from template:**\n   ```bash\n   cp todos/000-pending-p1-TEMPLATE.md todos/{new_filename}\n   ```\n\n4. **Populate with finding data:**\n   ```yaml\n   ---\n   status: pending\n   priority: p1  # or p2, p3 based on severity\n   issue_id: \"042\"\n   tags: [code-review, security, rails]  # add relevant tags\n   dependencies: []\n   ---\n\n   # [Finding Title]\n\n   ## Problem Statement\n   [Detailed description from finding]\n\n   ## Findings\n   - Discovered during code review by [agent names]\n   - Location: [file_path:line_number]\n   - [Key discoveries from agents]\n\n   ## Proposed Solutions\n\n   ### Option 1: [Primary solution from finding]\n   - **Pros**: [Benefits]\n   - **Cons**: [Drawbacks]\n   - **Effort**: [Small/Medium/Large]\n   - **Risk**: [Low/Medium/High]\n\n   ## Recommended Action\n   [Leave blank - needs manager triage]\n\n   ## Technical Details\n   - **Affected Files**: [List from finding]\n   - **Related Components**: [Models, controllers, services affected]\n   - **Database Changes**: [Yes/No - describe if yes]\n\n   ## Resources\n   - Code review PR: [PR link if applicable]\n   - Related findings: [Other finding numbers]\n   - Agent reports: [Which agents flagged this]\n\n   ## Acceptance Criteria\n   - [ ] [Specific criteria based on solution]\n   - [ ] Tests pass\n   - [ ] Code reviewed\n\n   ## Work Log\n\n   ### {date} - Code Review Discovery\n   **By:** Claude Code Review System\n   **Actions:**\n   - Discovered during comprehensive code review\n   - Analyzed by multiple specialized agents\n   - Categorized and prioritized\n\n   **Learnings:**\n   - [Key insights from agent analysis]\n\n   ## Notes\n   Source: Code review performed on {date}\n   Review command: /workflows:review {arguments}\n   ```\n\n5. **Track creation:**\n   Add to TodoWrite list if tracking multiple findings\n\n</todo_creation_process>\n\n#### Step 4: Summary Report\n\nAfter processing all findings:\n\n```markdown\n## Code Review Complete\n\n**Review Target:** [PR number or branch]\n**Total Findings:** [X]\n**Todos Created:** [Y]\n\n### Created Todos:\n- `{issue_id}-pending-p1-{description}.md` - {title}\n- `{issue_id}-pending-p2-{description}.md` - {title}\n...\n\n### Skipped Findings:\n- [Finding #Z]: {reason}\n...\n\n### Next Steps:\n1. Triage pending todos: `ls todos/*-pending-*.md`\n2. Use `/triage` to review and approve\n3. Work on approved items: `/resolve_todo_parallel`\n```\n\n#### Alternative: Batch Creation\n\nIf user wants to convert all findings to todos without review:\n\n```bash\n# Ask: \"Create todos for all X findings? (yes/no/show-critical-only)\"\n# If yes: create todo files for all findings in parallel\n# If show-critical-only: only present P1 findings for triage\n```\n"
              },
              {
                "name": "/triage",
                "description": null,
                "path": "plugins/traya-react-native/commands/triage.md",
                "frontmatter": null,
                "content": "Present all findings, decisions, or issues here one by one for triage. The goal is to go through each item and decide whether to add it to the CLI todo system.\n\n**IMPORTANT: DO NOT CODE ANYTHING DURING TRIAGE!**\n\nThis command is for:\n- Triaging code review findings\n- Processing security audit results\n- Reviewing performance analysis\n- Handling any other categorized findings that need tracking\n\n## Workflow\n\n### Step 1: Present Each Finding\n\nFor each finding, present in this format:\n\n```\n---\nIssue #X: [Brief Title]\n\nSeverity: üî¥ P1 (CRITICAL) / üü° P2 (IMPORTANT) / üîµ P3 (NICE-TO-HAVE)\n\nCategory: [Security/Performance/Architecture/Bug/Feature/etc.]\n\nDescription:\n[Detailed explanation of the issue or improvement]\n\nLocation: [file_path:line_number]\n\nProblem Scenario:\n[Step by step what's wrong or could happen]\n\nProposed Solution:\n[How to fix it]\n\nEstimated Effort: [Small (< 2 hours) / Medium (2-8 hours) / Large (> 8 hours)]\n\n---\nDo you want to add this to the todo list?\n1. yes - create todo file\n2. next - skip this item\n3. custom - modify before creating\n```\n\n### Step 2: Handle User Decision\n\n**When user says \"yes\":**\n\n1. **Determine next issue ID:**\n   ```bash\n   ls todos/ | grep -o '^[0-9]\\+' | sort -n | tail -1\n   ```\n\n2. **Create filename:**\n   ```\n   {next_id}-pending-{priority}-{brief-description}.md\n   ```\n\n   Priority mapping:\n   - üî¥ P1 (CRITICAL) ‚Üí `p1`\n   - üü° P2 (IMPORTANT) ‚Üí `p2`\n   - üîµ P3 (NICE-TO-HAVE) ‚Üí `p3`\n\n   Example: `042-pending-p1-transaction-boundaries.md`\n\n3. **Create from template:**\n   ```bash\n   cp todos/000-pending-p1-TEMPLATE.md todos/{new_filename}\n   ```\n\n4. **Populate the file:**\n   ```yaml\n   ---\n   status: pending\n   priority: p1  # or p2, p3 based on severity\n   issue_id: \"042\"\n   tags: [category, relevant-tags]\n   dependencies: []\n   ---\n\n   # [Issue Title]\n\n   ## Problem Statement\n   [Description from finding]\n\n   ## Findings\n   - [Key discoveries]\n   - Location: [file_path:line_number]\n   - [Scenario details]\n\n   ## Proposed Solutions\n\n   ### Option 1: [Primary solution]\n   - **Pros**: [Benefits]\n   - **Cons**: [Drawbacks if any]\n   - **Effort**: [Small/Medium/Large]\n   - **Risk**: [Low/Medium/High]\n\n   ## Recommended Action\n   [Leave blank - will be filled during approval]\n\n   ## Technical Details\n   - **Affected Files**: [List files]\n   - **Related Components**: [Components affected]\n   - **Database Changes**: [Yes/No - describe if yes]\n\n   ## Resources\n   - Original finding: [Source of this issue]\n   - Related issues: [If any]\n\n   ## Acceptance Criteria\n   - [ ] [Specific success criteria]\n   - [ ] Tests pass\n   - [ ] Code reviewed\n\n   ## Work Log\n\n   ### {date} - Initial Discovery\n   **By:** Claude Triage System\n   **Actions:**\n   - Issue discovered during [triage session type]\n   - Categorized as {severity}\n   - Estimated effort: {effort}\n\n   **Learnings:**\n   - [Context and insights]\n\n   ## Notes\n   Source: Triage session on {date}\n   ```\n\n5. **Confirm creation:**\n   \"‚úÖ Created: `{filename}` - Issue #{issue_id}\"\n\n**When user says \"next\":**\n- Skip to the next item\n- Track skipped items for summary\n\n**When user says \"custom\":**\n- Ask what to modify (priority, description, details)\n- Update the information\n- Present revised version\n- Ask again: yes/next/custom\n\n### Step 3: Continue Until All Processed\n\n- Process all items one by one\n- Track using TodoWrite for visibility\n- Don't wait for approval between items - keep moving\n\n### Step 4: Final Summary\n\nAfter all items processed:\n\n```markdown\n## Triage Complete\n\n**Total Items:** [X]\n**Todos Created:** [Y]\n**Skipped:** [Z]\n\n### Created Todos:\n- `042-pending-p1-transaction-boundaries.md` - Transaction boundary issue\n- `043-pending-p2-cache-optimization.md` - Cache performance improvement\n...\n\n### Skipped Items:\n- Item #5: [reason]\n- Item #12: [reason]\n\n### Next Steps:\n1. Review pending todos: `ls todos/*-pending-*.md`\n2. Approve for work: Move from pending ‚Üí ready status\n3. Start work: Use `/resolve_todo_parallel` or pick individually\n```\n\n## Example Response Format\n\n```\n---\nIssue #5: Missing Transaction Boundaries for Multi-Step Operations\n\nSeverity: üî¥ P1 (CRITICAL)\n\nCategory: Data Integrity / Security\n\nDescription:\nThe google_oauth2_connected callback in GoogleOauthCallbacks concern performs multiple database\noperations without transaction protection. If any step fails midway, the database is left in an\ninconsistent state.\n\nLocation: app/controllers/concerns/google_oauth_callbacks.rb:13-50\n\nProblem Scenario:\n1. User.update succeeds (email changed)\n2. Account.save! fails (validation error)\n3. Result: User has changed email but no associated Account\n4. Next login attempt fails completely\n\nOperations Without Transaction:\n- User confirmation (line 13)\n- Waitlist removal (line 14)\n- User profile update (line 21-23)\n- Account creation (line 28-37)\n- Avatar attachment (line 39-45)\n- Journey creation (line 47)\n\nProposed Solution:\nWrap all operations in ApplicationRecord.transaction do ... end block\n\nEstimated Effort: Small (30 minutes)\n\n---\nDo you want to add this to the todo list?\n1. yes - create todo file\n2. next - skip this item\n3. custom - modify before creating\n```\n\nDo not code, and if you say yes, make sure to mark the to‚Äëdo as ready to pick up or something. If you make any changes, update the file and then continue to read the next one. If next is selecrte make sure to remove the to‚Äëdo from the list since its not relevant.\n\nEvery time you present the to‚Äëdo as a header, can you say what the progress of the triage is, how many we have done and how many are left, and an estimated time for completion, looking at how quickly we go through them as well?\n"
              },
              {
                "name": "/work",
                "description": null,
                "path": "plugins/traya-react-native/commands/work.md",
                "frontmatter": null,
                "content": "# Work Plan Execution Command\n\n## Introduction\n\nThis command helps you analyze a work document (plan, Markdown file, specification, or any structured document), create a comprehensive todo list using the TodoWrite tool, and then systematically execute each task until the entire plan is completed. It combines deep analysis with practical execution to transform plans into reality.\n\n**Skill-Based Execution**: The command automatically detects task types (React Native UI development, API integration) and invokes appropriate skills (rn-ui-developer, rn-api-integrator, rn-app-tester, rn-code-reviewer) for comprehensive, iterative workflows with built-in quality assurance. This leverages all bundled MCP servers (Figma, Postman, iOS Simulator, Mobile Device, Context7, Serena) to ensure production-ready results on both iOS and Android.\n\n## Prerequisites\n\n- A work document to analyze (plan file, specification, or any structured document)\n- Clear understanding of project context and goals\n- Access to necessary tools and permissions for implementation\n- Ability to test and validate completed work on iOS and Android\n- Git repository with main branch\n- **Bundled MCP servers** (automatically configured with plugin):\n  - Figma MCP (for rn-ui-developer skill - requires Figma Desktop App)\n  - Postman MCP (for rn-api-integrator skill)\n  - iOS Simulator MCP (for rn-ui-developer, rn-api-integrator, rn-app-tester skills)\n  - Mobile Device MCP (for rn-ui-developer, rn-api-integrator, rn-app-tester skills)\n  - Context7 MCP (for React Native documentation and best practices)\n  - Serena MCP (for codebase pattern analysis)\n\n## Main Tasks\n\n### 1. Setup Development Environment\n\n- Ensure main branch is up to date\n- Create feature branch with descriptive name\n- Setup worktree for isolated development\n- Configure development environment\n\n### 2. Analyze Input Document\n\n<input_document> #$ARGUMENTS </input_document>\n\n## Execution Workflow\n\n### Phase 1: Environment Setup\n\n1. **Update Main Branch**\n\n   ```bash\n   git checkout main\n   git pull origin main\n   ```\n\n2. **Create Feature Branch and Worktree**\n\n   - Determine appropriate branch name from document\n   - Get the root directory of the Git repository:\n\n   ```bash\n   git_root=$(git rev-parse --show-toplevel)\n   ```\n\n   - Create worktrees directory if it doesn't exist:\n\n   ```bash\n   mkdir -p \"$git_root/.worktrees\"\n   ```\n\n   - Add .worktrees to .gitignore if not already there:\n\n   ```bash\n   if ! grep -q \"^\\.worktrees$\" \"$git_root/.gitignore\"; then\n     echo \".worktrees\" >> \"$git_root/.gitignore\"\n   fi\n   ```\n\n   - Create the new worktree with feature branch:\n\n   ```bash\n   git worktree add -b feature-branch-name \"$git_root/.worktrees/feature-branch-name\" main\n   ```\n\n   - Change to the new worktree directory:\n\n   ```bash\n   cd \"$git_root/.worktrees/feature-branch-name\"\n   ```\n\n3. **Verify Environment**\n   - Confirm in correct worktree directory\n   - Install dependencies if needed\n   - Run initial tests to ensure clean state\n\n### Phase 2: Document Analysis and Planning\n\n1. **Read Input Document**\n\n   - Use Read tool to examine the work document\n   - Identify all deliverables and requirements\n   - Note any constraints or dependencies\n   - Extract success criteria\n\n2. **Create Task Breakdown**\n\n   - Convert requirements into specific tasks\n   - Add implementation details for each task\n   - Include testing and validation steps\n   - Consider edge cases and error handling\n\n3. **Build Todo List**\n   - Use TodoWrite to create comprehensive list\n   - Set priorities based on dependencies\n   - Include all subtasks and checkpoints\n   - Add documentation and review tasks\n\n### Phase 3: Systematic Execution\n\n1. **Detect Task Type and Invoke Skills**\n\n   Analyze the work document and todo list to determine the task type, then automatically invoke appropriate skills for comprehensive execution:\n\n   **A. For UI Development Tasks**\n\n   If the work involves building UI components from Figma designs or creating new pages/components:\n\n   ```\n   1. Invoke ui-developer skill\n      - Extract design specifications from Figma (Figma MCP)\n      - Analyze existing codebase patterns (Serena MCP)\n      - Fetch library documentation (Context7 MCP)\n      - Implement component with TypeScript + Tailwind\n      - Visual verification loop with Chrome DevTools\n      - Iterate until pixel-perfect match\n\n   2. If backend APIs needed ‚Üí Invoke api-integrator skill\n      - Test APIs with Postman (Postman MCP)\n      - Set up API client with interceptors\n      - Implement authentication integration\n      - Connect APIs to UI components\n      - Add loading and error states\n      - Integration testing with Chrome DevTools\n      - Security audit\n\n   3. Invoke ui-tester skill\n      - Functional testing (all interactive elements)\n      - Error detection and analysis\n      - Responsive and visual testing\n      - Accessibility validation (WCAG compliance)\n      - Performance testing (Core Web Vitals)\n      - Issue documentation and fixing\n      - Final validation\n\n   4. Invoke code-reviewer skill\n      - Task completion verification\n      - Technical quality review\n      - Best practices validation (Context7 MCP)\n      - Code structure and organization review\n      - Performance, security, accessibility checks\n      - Project conventions compliance\n   ```\n\n   **B. For API Integration Tasks**\n\n   If the work focuses primarily on connecting backend APIs:\n\n   ```\n   1. Invoke api-integrator skill\n      - API discovery and planning (Serena MCP for patterns)\n      - Comprehensive API testing with Postman MCP\n      - Frontend integration (authentication, data fetching)\n      - Integration testing with Chrome DevTools MCP\n      - Performance optimization\n      - Security audit\n      - Documentation\n\n   2. Invoke ui-tester skill\n      - Test complete data flow from API to UI\n      - Network monitoring and validation\n      - Error scenario testing\n      - Performance validation\n\n   3. Invoke code-reviewer skill\n      - Integration quality review\n      - Security validation\n      - Performance check\n      - Best practices compliance\n   ```\n\n   **C. For Other Tasks**\n\n   If the work doesn't fit UI development or API integration patterns, fall back to manual execution with the task loop below.\n\n2. **Task Execution Loop** (Fallback for non-UI/API tasks)\n\n   ```\n   while (tasks remain):\n     - Select next task (priority + dependencies)\n     - Mark as in_progress\n     - Execute task completely\n     - Validate completion\n     - Mark as completed\n     - Update progress\n   ```\n\n3. **Quality Assurance**\n\n   - Run tests after each task (lint, typecheck, unit tests)\n   - Execute lint and typecheck commands\n   - Verify no regressions\n   - Check against acceptance criteria\n   - Document any issues found\n   - Ensure all MCP-based validations passed (if skills were used)\n\n4. **Progress Tracking**\n   - Regularly update task status\n   - Note any blockers or delays\n   - Create new tasks for discoveries\n   - Maintain work visibility\n   - Document skill execution results\n\n### Phase 4: Completion and Submission\n\n1. **Final Validation**\n\n   - Verify all tasks completed\n   - Run comprehensive test suite\n   - Execute final lint and typecheck\n   - Check all deliverables present\n   - Ensure documentation updated\n\n2. **Prepare for Submission**\n\n   - Stage and commit all changes\n   - Write commit messages\n   - Push feature branch to remote\n   - Create detailed pull request\n\n3. **Create Pull Request**\n   ```bash\n   git push -u origin feature-branch-name\n   gh pr create --title \"Feature: [Description]\" --body \"[Detailed description]\"\n   ```\n"
              }
            ],
            "skills": []
          },
          {
            "name": "traya-backend-engineering",
            "description": "AI-powered backend development workflow with compounding engineering principles. Build scalable Node.js/NestJS APIs with 12 specialized agents, 5 workflow skills, and 6 commands. Covers PostgreSQL, MongoDB, Redis, TypeORM, OpenAPI documentation, security, and comprehensive testing.",
            "source": "./plugins/traya-backend-engineering",
            "category": null,
            "version": "1.0.0",
            "author": {
              "name": "Shivraj Kumar",
              "url": "https://github.com/trayalabs1",
              "email": "shivrajkumar@traya.health"
            },
            "install_commands": [
              "/plugin marketplace add shivrajkumar/traya-plugin",
              "/plugin install traya-backend-engineering@traya-plugin"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-04T12:42:23Z",
              "created_at": "2025-10-29T12:31:50Z",
              "license": null
            },
            "commands": [
              {
                "name": "/generate_command",
                "description": null,
                "path": "plugins/traya-backend-engineering/commands/generate_command.md",
                "frontmatter": null,
                "content": "# Create a Custom Backend Command\n\nCreate a new slash command in `.claude/commands/` for backend development tasks.\n\n## Goal\n\n#$ARGUMENTS\n\n## Key Capabilities for Backend Development\n\n**File Operations:**\n- Read, Edit, Write - modify TypeScript/JavaScript files, configs, migrations\n- Glob, Grep - search codebase for controllers, services, entities\n- MultiEdit - atomic multi-part changes across backend files\n\n**Backend Development:**\n- Bash - run backend commands (npm, database migrations, tests, linters)\n- Task - launch specialized backend agents (api-designer, database-modeler, nestjs-specialist, etc.)\n- TodoWrite - track progress with todo lists\n\n**Database Operations:**\n- TypeORM migrations - create, run, revert\n- Database schema analysis\n- Query optimization\n- Seed data management\n\n**API Development:**\n- NestJS/Express scaffolding\n- Controller and service generation\n- DTO and entity creation\n- OpenAPI/Swagger documentation\n- Postman collection management\n\n**Testing & Quality:**\n- Jest unit tests\n- Supertest integration tests\n- E2E testing\n- TypeScript compilation\n- ESLint/Prettier\n\n**Web & APIs:**\n- WebFetch, WebSearch - research NestJS, TypeORM, PostgreSQL, MongoDB docs\n- GitHub (gh cli) - PRs, issues, reviews\n- Postman MCP - API testing and validation\n- Context7 MCP - framework and library documentation\n\n**Backend-Specific Integrations:**\n- Postman - API testing, collection management\n- Context7 - NestJS, Express, TypeORM documentation\n- Serena - codebase pattern analysis\n\n## Backend Development Best Practices\n\n1. **API-First Design** - design API contracts before implementation\n2. **Database Safety** - always create reversible migrations\n3. **Type Safety** - use TypeScript strict mode, comprehensive DTOs\n4. **Input Validation** - validate all inputs with class-validator\n5. **Error Handling** - consistent error responses (RFC 7807)\n6. **Testing** - unit tests (services) + integration tests (APIs)\n7. **Documentation** - OpenAPI specs, Postman collections, inline comments\n8. **Security** - OWASP Top 10 compliance, authentication/authorization\n9. **Performance** - caching (Redis), query optimization, benchmarking\n10. **Code Quality** - ESLint, Prettier, code reviews\n\n## Backend Command Structure\n\n```markdown\n# [Command Name]\n\n[Brief description of what this backend command does]\n\n## Prerequisites\n\n- Node.js and npm/yarn installed\n- Database connection configured (PostgreSQL/MongoDB)\n- TypeScript compiler available\n- [Any other backend-specific requirements]\n\n## Steps\n\n1. **[First step - usually analysis or planning]**\n   - Analyze existing API structure\n   - Review database schema\n   - Check for similar implementations\n   - Consider security and performance implications\n\n2. **[Implementation step]**\n   - Generate controllers/services/entities\n   - Create database migrations\n   - Implement business logic\n   - Add input validation\n\n3. **[Testing step]**\n   - Write unit tests for services\n   - Create integration tests for APIs\n   - Test database migrations (up/down)\n   - Validate with Postman\n\n4. **[Documentation step]**\n   - Update OpenAPI specification\n   - Create/update Postman collection\n   - Add inline code documentation\n   - Update CHANGELOG\n\n5. **[Validation step]**\n   - Run TypeScript compilation\n   - Run ESLint\n   - Execute test suite\n   - Verify API contracts\n\n## Success Criteria\n\n- [ ] TypeScript compilation successful\n- [ ] All tests pass (unit + integration)\n- [ ] ESLint passes with no warnings\n- [ ] API documentation updated (OpenAPI spec)\n- [ ] Postman collection includes new endpoints\n- [ ] Database migrations tested (up and down)\n- [ ] Performance benchmarks meet targets\n- [ ] Security review passed (OWASP compliance)\n- [ ] Code reviewed by senior backend developer\n```\n\n## Backend-Specific Command Patterns\n\n### Pattern 1: API Endpoint Creation\n\n```markdown\nCreate a new API endpoint for #$ARGUMENTS following these steps:\n\n1. **API Design**\n   - Task api-designer(\"Design REST endpoint for #$ARGUMENTS\")\n   - Define request/response DTOs\n   - Plan authentication/authorization requirements\n   - Consider rate limiting and caching\n\n2. **Database Schema** (if needed)\n   - Task database-modeler(\"Design schema for #$ARGUMENTS\")\n   - Create TypeORM entity\n   - Generate migration script\n   - Add indexes for performance\n\n3. **Implementation**\n   - Task nestjs-specialist(\"Implement #$ARGUMENTS endpoint\")\n   - Create controller with decorators\n   - Implement service layer logic\n   - Add DTO validation with class-validator\n   - Implement error handling\n\n4. **Testing**\n   - Task testing-specialist(\"Test #$ARGUMENTS endpoint\")\n   - Write service unit tests\n   - Create API integration tests with Supertest\n   - Test authentication/authorization\n   - Test error scenarios\n\n5. **Documentation**\n   - Task api-documenter(\"Document #$ARGUMENTS endpoint\")\n   - Add OpenAPI decorators\n   - Create Postman collection example\n   - Document authentication requirements\n\n6. **Validation**\n   - Run tests: `npm test`\n   - Test with Postman: validate request/response schemas\n   - Check TypeScript: `tsc --noEmit`\n   - Lint code: `npm run lint`\n   - Benchmark performance: response time < 200ms (p95)\n\n7. **Commit** (optional)\n   - Stage changes\n   - Write descriptive commit message following conventions\n   - Include breaking changes if applicable\n```\n\n### Pattern 2: Database Migration\n\n```markdown\nCreate database migration for #$ARGUMENTS following these steps:\n\n1. **Schema Design**\n   - Task database-modeler(\"Design schema changes for #$ARGUMENTS\")\n   - Create ERD if complex changes\n   - Plan for zero-downtime deployment\n   - Consider data migration strategy\n\n2. **Create Migration**\n   - Task typeorm-specialist(\"Create migration for #$ARGUMENTS\")\n   - Generate migration: `npm run migration:generate -- -n MigrationName`\n   - Implement up() method\n   - Implement down() method (rollback)\n   - Add data migration if needed\n\n3. **Update Entities**\n   - Update TypeORM entities\n   - Add/modify decorators\n   - Update relationships\n   - Regenerate DTOs if needed\n\n4. **Testing**\n   - Test on fresh database: `npm run migration:run`\n   - Test rollback: `npm run migration:revert`\n   - Test with seed data\n   - Verify data integrity\n   - Check index performance\n\n5. **Validation**\n   - Verify migration runs successfully\n   - Check database schema matches expectations\n   - Test affected API endpoints\n   - Benchmark query performance\n   - Document migration in CHANGELOG\n\n6. **Commit**\n   - Commit migration file\n   - Commit entity changes\n   - Document breaking changes\n   - Update deployment notes\n```\n\n### Pattern 3: Security Audit & Fix\n\n```markdown\nPerform security audit for #$ARGUMENTS following these steps:\n\n1. **Security Scan**\n   - Task security-auditor(\"Audit security for #$ARGUMENTS\")\n   - Check OWASP Top 10 compliance\n   - Scan dependencies: `npm audit`\n   - Review authentication/authorization\n   - Check input validation\n   - Review SQL injection risks\n\n2. **Identify Vulnerabilities**\n   - Categorize by severity (Critical/High/Medium/Low)\n   - Document attack vectors\n   - Assess impact on API consumers\n   - Prioritize fixes\n\n3. **Implement Fixes**\n   - Fix critical vulnerabilities first\n   - Add input sanitization\n   - Implement parameterized queries\n   - Add authentication guards\n   - Update dependencies: `npm audit fix`\n\n4. **Security Testing**\n   - Test injection attacks (SQL, NoSQL, XSS)\n   - Test authentication bypass attempts\n   - Test authorization edge cases\n   - Fuzz test API endpoints\n   - Validate JWT token handling\n\n5. **Documentation**\n   - Document security fixes\n   - Update security best practices\n   - Add to security checklist\n   - Create incident report if needed\n\n6. **Validation**\n   - Re-run security audit\n   - Verify all tests pass\n   - Check for similar vulnerabilities in codebase\n   - Review by security team\n```\n\n### Pattern 4: Performance Optimization\n\n```markdown\nOptimize performance for #$ARGUMENTS following these steps:\n\n1. **Baseline Measurement**\n   - Task performance-analyzer(\"Analyze performance of #$ARGUMENTS\")\n   - Measure API response times\n   - Profile database queries\n   - Check memory usage\n   - Identify bottlenecks\n\n2. **Database Optimization**\n   - Task database-modeler(\"Optimize queries for #$ARGUMENTS\")\n   - Add indexes to slow queries\n   - Optimize N+1 queries\n   - Use eager/lazy loading appropriately\n   - Implement query result caching\n\n3. **Caching Strategy**\n   - Task redis-cache-specialist(\"Implement caching for #$ARGUMENTS\")\n   - Add Redis caching layer\n   - Implement cache invalidation\n   - Set appropriate TTLs\n   - Cache expensive computations\n\n4. **Code Optimization**\n   - Optimize algorithm complexity\n   - Use batch operations\n   - Implement pagination\n   - Add response streaming for large payloads\n   - Optimize TypeScript compilation\n\n5. **Performance Testing**\n   - Benchmark before/after\n   - Load test with realistic data\n   - Test under concurrent requests\n   - Monitor memory/CPU usage\n   - Verify no regressions\n\n6. **Documentation**\n   - Document performance improvements\n   - Update performance targets\n   - Add monitoring/alerting\n   - Create optimization playbook\n```\n\n## Tips for Effective Backend Commands\n\n- **Use $ARGUMENTS** placeholder for dynamic inputs (API endpoint name, entity name, etc.)\n- **Reference CLAUDE.md** for project patterns and backend conventions\n- **Include verification steps** - tests, linting, TypeScript compilation, API validation\n- **Be explicit about database changes** - migrations, schema impacts, rollback procedures\n- **Consider security** - authentication, authorization, input validation, OWASP compliance\n- **Plan for scale** - caching, query optimization, load testing\n- **Use XML tags** for structured prompts: `<api_design>`, `<database_schema>`, `<security>`, `<performance>`\n\n## Backend-Specific Verification Commands\n\n```markdown\n## Verification Steps\n\n1. **TypeScript Compilation:**\n   ```bash\n   npm run build\n   # or\n   tsc --noEmit\n   ```\n\n2. **Linting:**\n   ```bash\n   npm run lint\n   # or\n   eslint . --ext .ts\n   # or\n   yarn lint\n   ```\n\n3. **Unit Tests:**\n   ```bash\n   npm test\n   # or\n   jest --coverage\n   # or\n   yarn test\n   ```\n\n4. **Integration Tests:**\n   ```bash\n   npm run test:integration\n   # or\n   jest --config jest.integration.config.js\n   ```\n\n5. **E2E Tests:**\n   ```bash\n   npm run test:e2e\n   ```\n\n6. **Database Migrations:**\n   ```bash\n   # Run migrations\n   npm run migration:run\n\n   # Revert last migration\n   npm run migration:revert\n   ```\n\n7. **API Testing:**\n   ```bash\n   # Using Postman (if available)\n   # Validate all endpoints\n   # Check response schemas\n   # Test authentication\n   ```\n\n8. **Performance Benchmarking:**\n   ```bash\n   # Custom benchmark script\n   npm run benchmark\n\n   # Or use tools like autocannon, ab\n   autocannon -c 100 -d 30 http://localhost:3000/api/endpoint\n   ```\n\n9. **Security Audit:**\n   ```bash\n   npm audit\n   npm audit fix\n   ```\n\n10. **Code Quality:**\n    ```bash\n    # Format code\n    npm run format\n    # or\n    prettier --write .\n    ```\n```\n\n## Example Backend Commands\n\n### Generate CRUD API\n\n```markdown\n# Generate Complete CRUD API\n\nGenerate a complete CRUD API for #$ARGUMENTS\n\n1. Use api-designer to plan RESTful endpoints\n2. Use database-modeler to design entity schema\n3. Use typeorm-specialist to create entity and repository\n4. Use nestjs-specialist to create controller, service, DTOs\n5. Use testing-specialist to create comprehensive tests\n6. Use api-documenter to generate OpenAPI spec\n7. Run all verification steps\n\nSuccess criteria:\n- All 5 REST endpoints implemented (GET, GET/:id, POST, PUT/:id, DELETE/:id)\n- Full test coverage (>80%)\n- OpenAPI spec complete\n- Postman collection created\n```\n\n### Add Authentication\n\n```markdown\n# Add JWT Authentication\n\nAdd JWT authentication to the application\n\n1. Use security-auditor to review current auth state\n2. Use nestjs-specialist to implement JWT strategy\n3. Implement authentication guards and decorators\n4. Add refresh token mechanism\n5. Create login/logout endpoints\n6. Add comprehensive security tests\n7. Update API documentation with auth requirements\n\nSuccess criteria:\n- JWT tokens properly signed and validated\n- Refresh token rotation implemented\n- All protected endpoints require authentication\n- Security tests cover common attack vectors\n```\n\nNow create the command file at `.claude/commands/[name].md` with the structure above, adapted for your specific backend development need.\n"
              },
              {
                "name": "/plan",
                "description": null,
                "path": "plugins/traya-backend-engineering/commands/plan.md",
                "frontmatter": null,
                "content": "# Create GitHub Issue for Backend Development\n\n## Introduction\n\nTransform backend feature descriptions, bug reports, API design ideas, or infrastructure improvements into well-structured markdown files that follow project conventions and best practices. This command provides flexible detail levels to match your backend development needs.\n\n## Feature Description\n\n<feature_description> #$ARGUMENTS </feature_description>\n\n## Main Tasks\n\n### 1. Repository Research & Context Gathering\n\n<thinking>\nFirst, I need to understand the project's conventions and existing patterns, leveraging all available resources and use parallel subagents to do this.\n</thinking>\n\nRun these three agents in parallel at the same time:\n\n- Task api-designer(feature_description)\n- Task database-modeler(feature_description)\n- Task architecture-strategist(feature_description)\n\n**Reference Collection:**\n\n- [ ] Document all research findings with specific file paths (e.g., `src/api/controllers/user.controller.ts:42`)\n- [ ] Include URLs to external documentation and best practices guides\n- [ ] Create a reference list of similar issues or PRs (e.g., `#123`, `#456`)\n- [ ] Note any team conventions discovered in `CLAUDE.md` or team documentation\n- [ ] Review OpenAPI/Swagger specifications if available\n- [ ] Check database schema and migration patterns\n\n### 2. Issue Planning & Structure\n\n<thinking>\nThink like a backend architect - what would make this issue clear and actionable? Consider API design, database impacts, security, performance, and scalability perspectives.\n</thinking>\n\n**Title & Categorization:**\n\n- [ ] Draft clear, searchable issue title using conventional format (e.g., `feat:`, `fix:`, `perf:`, `security:`, `db:`)\n- [ ] Identify appropriate labels from repository's label set (`gh label list`)\n- [ ] Determine issue type: api-enhancement, bug, database-migration, performance, security\n\n**Stakeholder Analysis:**\n\n- [ ] Identify who will be affected by this issue (API consumers, frontend developers, operations, DBAs)\n- [ ] Consider implementation complexity and required expertise (Node.js, NestJS, TypeORM, PostgreSQL, Redis)\n\n**Content Planning:**\n\n- [ ] Choose appropriate detail level based on issue complexity and audience\n- [ ] List all necessary sections for the chosen template\n- [ ] Gather supporting materials (API logs, database queries, performance metrics, security audit results)\n- [ ] Prepare code examples, API endpoint specifications, or database schema diagrams if applicable\n- [ ] Include OpenAPI/Swagger spec snippets if relevant\n\n### 3. Choose Implementation Detail Level\n\nSelect how comprehensive you want the issue to be:\n\n#### üìÑ MINIMAL (Quick Issue)\n\n**Best for:** Simple bug fixes, minor API improvements, small database changes\n\n**Includes:**\n\n- Problem statement or feature description\n- Basic acceptance criteria\n- Essential context only\n\n**Structure:**\n\n````markdown\n[Brief problem/feature description]\n\n## Acceptance Criteria\n\n- [ ] API endpoint returns correct status codes\n- [ ] Database changes include migration\n- [ ] OpenAPI spec updated\n\n## Context\n\n[Any critical information about API, database, or integration]\n\n## MVP\n\n### src/api/controllers/user.controller.ts\n\n```typescript\n@Controller('users')\nexport class UserController {\n  @Get(':id')\n  async findOne(@Param('id') id: string): Promise<UserDto> {\n    return this.userService.findOne(id);\n  }\n}\n```\n\n## References\n\n- Related issue: #[issue_number]\n- API documentation: [relevant_docs_url]\n- Database schema: [schema_reference]\n````\n\n#### üìã MORE (Standard Issue)\n\n**Best for:** Most API features, database integrations, performance improvements, security enhancements\n\n**Includes everything from MINIMAL plus:**\n\n- Detailed background and motivation\n- API design considerations\n- Database schema impacts\n- Security and performance implications\n- Success metrics\n- Dependencies and risks\n- Basic implementation suggestions\n\n**Structure:**\n\n```markdown\n## Overview\n\n[Comprehensive description of the API feature, database change, or system improvement]\n\n## Problem Statement / Motivation\n\n[Why this matters for the backend system, API consumers, or infrastructure]\n\n## Proposed Solution\n\n[High-level approach including API design, database changes, and integration points]\n\n## Technical Considerations\n\n### API Design\n- Endpoint structure and naming\n- Request/response schema validation\n- Authentication and authorization\n\n### Database Impact\n- Schema changes and migrations\n- Index optimization\n- Query performance\n\n### Security Considerations\n- Input validation and sanitization\n- Authentication/authorization requirements\n- Rate limiting and abuse prevention\n\n### Performance Implications\n- Caching strategy (Redis)\n- Query optimization\n- Response time targets\n\n## Acceptance Criteria\n\n- [ ] API endpoints implement OpenAPI 3.0 spec\n- [ ] TypeORM migrations include rollback\n- [ ] Unit tests cover service layer (>80% coverage)\n- [ ] Integration tests validate API contracts\n- [ ] Postman collection updated\n- [ ] Error handling follows RFC 7807 (Problem Details)\n\n## Success Metrics\n\n[How we measure success - API response times, error rates, throughput]\n\n## Dependencies & Risks\n\n### Dependencies\n- External API integrations\n- Database schema changes\n- Redis cache configuration\n\n### Risks\n- Breaking changes for API consumers\n- Migration complexity\n- Performance degradation\n\n## References & Research\n\n- Similar API implementations: [file_path:line_number]\n- NestJS best practices: [documentation_url]\n- TypeORM patterns: [file_path:line_number]\n- Related PRs: #[pr_number]\n```\n\n#### üìö A LOT (Comprehensive Issue)\n\n**Best for:** Major API versions, architectural changes, complex microservice integrations, database refactoring\n\n**Includes everything from MORE plus:**\n\n- Detailed implementation plan with phases\n- Alternative approaches considered (REST vs GraphQL, SQL vs NoSQL)\n- Extensive API specifications with examples\n- Database schema diagrams (ERD)\n- Resource requirements and timeline\n- Future considerations and extensibility\n- Risk mitigation strategies\n- Documentation requirements\n\n**Structure:**\n\n```markdown\n## Overview\n\n[Executive summary of backend system change]\n\n## Problem Statement\n\n[Detailed problem analysis with metrics, logs, and current system limitations]\n\n## Proposed Solution\n\n[Comprehensive solution design including API architecture, database design, and integration strategy]\n\n## Technical Approach\n\n### API Architecture\n\n**Endpoint Design:**\n- REST resource modeling\n- GraphQL schema design (if applicable)\n- Versioning strategy (URI vs header)\n\n**Request/Response Format:**\n```json\n{\n  \"data\": {...},\n  \"meta\": {...},\n  \"links\": {...}\n}\n```\n\n### Database Design\n\n**Entity Relationship Diagram:**\n```mermaid\nerDiagram\n    USER ||--o{ ORDER : places\n    USER {\n        uuid id PK\n        string email\n        timestamp created_at\n    }\n    ORDER {\n        uuid id PK\n        uuid user_id FK\n        decimal total\n    }\n```\n\n**Migration Strategy:**\n- Zero-downtime deployment approach\n- Data migration scripts\n- Rollback procedures\n\n### Implementation Phases\n\n#### Phase 1: Foundation (Week 1)\n\n- Database schema design\n- TypeORM entity definitions\n- Core service layer implementation\n- Success criteria: Entities created, migrations tested\n- Estimated effort: 3-5 days\n\n#### Phase 2: API Development (Week 2)\n\n- Controller implementation\n- DTO validation with class-validator\n- OpenAPI specification\n- Success criteria: API endpoints functional\n- Estimated effort: 5-7 days\n\n#### Phase 3: Testing & Documentation (Week 3)\n\n- Unit and integration tests\n- Postman collection creation\n- API documentation generation\n- Performance testing and optimization\n- Success criteria: >80% coverage, all tests green\n- Estimated effort: 3-4 days\n\n## Alternative Approaches Considered\n\n### Option 1: GraphQL instead of REST\n**Pros:** Flexible querying, single endpoint, strong typing\n**Cons:** Complexity, caching challenges, learning curve\n**Decision:** Rejected - team expertise in REST, simpler deployment\n\n### Option 2: MongoDB instead of PostgreSQL\n**Pros:** Schema flexibility, horizontal scaling\n**Cons:** No ACID guarantees, complex transactions\n**Decision:** Rejected - require relational integrity\n\n## Acceptance Criteria\n\n### Functional Requirements\n\n- [ ] All API endpoints implement OpenAPI 3.0 specification\n- [ ] Request validation using class-validator DTOs\n- [ ] Response serialization using class-transformer\n- [ ] Pagination, filtering, sorting on collection endpoints\n- [ ] JWT authentication with refresh tokens\n- [ ] Role-based authorization using guards\n\n### Non-Functional Requirements\n\n- [ ] API response time <200ms (p95)\n- [ ] Database queries optimized with proper indexes\n- [ ] Redis caching for frequently accessed data\n- [ ] Rate limiting: 100 req/min per user\n- [ ] OpenAPI documentation auto-generated\n- [ ] OWASP Top 10 security compliance\n\n### Quality Gates\n\n- [ ] Test coverage >80% (Jest + Supertest)\n- [ ] All TypeScript strict mode checks pass\n- [ ] ESLint with no warnings\n- [ ] Postman collection with all endpoints\n- [ ] API documentation published\n- [ ] Code review approved by 2+ developers\n\n## Success Metrics\n\n### Performance Metrics\n- API response time: <200ms (p95), <500ms (p99)\n- Database query time: <50ms average\n- Cache hit rate: >80%\n- Throughput: 1000 req/sec\n\n### Quality Metrics\n- Error rate: <0.1%\n- Test coverage: >80%\n- API uptime: 99.9%\n\n## Dependencies & Prerequisites\n\n### Infrastructure\n- PostgreSQL 14+ with extensions (uuid-ossp, pgcrypto)\n- Redis 6+ for caching and sessions\n- Node.js 18+ LTS\n\n### External Services\n- Authentication service (if external)\n- Third-party API integrations\n- Message queue (if applicable)\n\n### Team Dependencies\n- Database schema review with DBA\n- Security review for sensitive endpoints\n- Frontend team coordination for API contracts\n\n## Risk Analysis & Mitigation\n\n### Risk 1: Database Migration Failure\n**Probability:** Medium\n**Impact:** High\n**Mitigation:**\n- Test migrations on staging environment\n- Implement rollback scripts\n- Use transactional migrations\n- Schedule during low-traffic window\n\n### Risk 2: Breaking API Changes\n**Probability:** Low\n**Impact:** High\n**Mitigation:**\n- API versioning strategy\n- Deprecation warnings\n- Backward compatibility period\n- Consumer notification plan\n\n### Risk 3: Performance Degradation\n**Probability:** Medium\n**Impact:** Medium\n**Mitigation:**\n- Load testing before deployment\n- Database query optimization\n- Implement Redis caching\n- Monitoring and alerting\n\n## Resource Requirements\n\n### Development Team\n- 1 Backend Engineer (primary)\n- 1 Backend Engineer (reviewer)\n- 1 DBA (schema review)\n- 1 DevOps (deployment)\n\n### Timeline\n- Design & Planning: 2 days\n- Implementation: 2-3 weeks\n- Testing: 3-4 days\n- Documentation: 2 days\n- Total: 3-4 weeks\n\n### Infrastructure\n- Staging environment for testing\n- Database migrations testing environment\n- Load testing infrastructure\n\n## Future Considerations\n\n### Extensibility\n- GraphQL support for advanced queries\n- Websocket support for real-time updates\n- Microservice decomposition strategy\n- Event-driven architecture migration\n\n### Scalability\n- Horizontal scaling with load balancer\n- Database read replicas\n- Caching layer expansion\n- CDN for static API responses\n\n## Documentation Plan\n\n### API Documentation\n- [ ] OpenAPI 3.0 specification\n- [ ] Postman collection with examples\n- [ ] API changelog for versioning\n- [ ] Authentication guide\n\n### Developer Documentation\n- [ ] Database schema documentation\n- [ ] Service architecture diagram\n- [ ] Deployment runbook\n- [ ] Troubleshooting guide\n\n### User Documentation\n- [ ] API integration guide\n- [ ] Code examples (TypeScript, JavaScript)\n- [ ] Error code reference\n- [ ] Rate limiting documentation\n\n## References & Research\n\n### Internal References\n\n- Architecture decisions: [file_path:line_number]\n- Similar API implementations: [src/api/controllers/example.controller.ts:42]\n- Database patterns: [src/database/entities/user.entity.ts:15]\n- Configuration: [src/config/database.config.ts:10]\n\n### External References\n\n- NestJS documentation: https://docs.nestjs.com\n- TypeORM best practices: https://typeorm.io\n- OpenAPI specification: https://swagger.io/specification/\n- RFC 7807 Problem Details: https://tools.ietf.org/html/rfc7807\n- OWASP API Security: https://owasp.org/www-project-api-security/\n\n### Related Work\n\n- Previous API PRs: #[pr_numbers]\n- Related database issues: #[issue_numbers]\n- Architecture decision records: [links]\n```\n\n### 4. Issue Creation & Formatting\n\n<thinking>\nApply backend best practices for clarity and actionability, making the issue easy to scan and understand by both backend developers and API consumers\n</thinking>\n\n**Content Formatting:**\n\n- [ ] Use clear, descriptive headings with proper hierarchy (##, ###)\n- [ ] Include API examples in triple backticks with TypeScript syntax highlighting\n- [ ] Add database diagrams using Mermaid (ERD, sequence diagrams)\n- [ ] Include OpenAPI/Swagger spec snippets for API endpoints\n- [ ] Use task lists (- [ ]) for trackable items that can be checked off\n- [ ] Add collapsible sections for lengthy logs or API payloads using `<details>` tags\n- [ ] Apply appropriate emoji for visual scanning (üêõ bug, ‚ú® feature, üîí security, ‚ö° performance, üóÑÔ∏è database)\n\n**Cross-Referencing:**\n\n- [ ] Link to related issues/PRs using #number format\n- [ ] Reference specific commits with SHA hashes when relevant\n- [ ] Link to code using GitHub's permalink feature (press 'y' for permanent link)\n- [ ] Mention relevant team members with @username if needed\n- [ ] Add links to external API documentation, RFC specs, framework docs\n\n**Code & Examples:**\n\n```markdown\n# Good example with syntax highlighting and line references\n\n\\`\\`\\`typescript\n// src/api/controllers/user.controller.ts:42\n@Post()\n@UseGuards(JwtAuthGuard)\nasync create(@Body() createUserDto: CreateUserDto): Promise<UserDto> {\n  return this.userService.create(createUserDto);\n}\n\\`\\`\\`\n\n# Database schema with Mermaid ERD\n\\`\\`\\`mermaid\nerDiagram\n    USER ||--o{ ORDER : places\n    USER {\n        uuid id PK\n        string email\n    }\n\\`\\`\\`\n\n# Collapsible error logs\n<details>\n<summary>Full API error response</summary>\n\n\\`\\`\\`json\n{\n  \"statusCode\": 500,\n  \"message\": \"Internal server error\",\n  \"error\": \"Error details here...\"\n}\n\\`\\`\\`\n</details>\n```\n\n**Backend-Specific Considerations:**\n\n- [ ] Include database migration scripts if schema changes\n- [ ] Reference OpenAPI/Swagger specifications\n- [ ] Note API versioning implications\n- [ ] Document authentication/authorization requirements\n- [ ] Specify performance benchmarks and SLOs\n- [ ] Include security considerations (OWASP compliance)\n- [ ] Reference Postman collection updates needed\n\n**AI-Era Considerations:**\n\n- [ ] Account for accelerated development with AI pair programming\n- [ ] Include prompts or instructions that worked well during research\n- [ ] Note which AI tools were used for initial exploration (Claude, Copilot, Context7 MCP)\n- [ ] Emphasize comprehensive API testing given rapid implementation\n- [ ] Document any AI-generated code that needs security review\n- [ ] Use Postman MCP for automated API validation\n\n### 5. Final Review & Submission\n\n**Pre-submission Checklist:**\n\n- [ ] Title is searchable and descriptive\n- [ ] Labels accurately categorize the issue (api, database, security, performance)\n- [ ] All template sections are complete\n- [ ] Links and references are working\n- [ ] Acceptance criteria are measurable\n- [ ] Add names of files in pseudo code examples and todo lists\n- [ ] Add an ERD mermaid diagram if applicable for database model changes\n- [ ] Include API endpoint specifications if creating/modifying APIs\n- [ ] Reference OpenAPI/Swagger docs if applicable\n- [ ] Security and performance implications documented\n\n## Output Format\n\nPresent the complete issue content within `<github_issue>` tags, ready for GitHub CLI:\n\n```bash\ngh issue create --title \"[TITLE]\" --body \"[CONTENT]\" --label \"[LABELS]\"\n```\n\n## Thinking Approaches\n\n- **API-First:** Design API contracts before implementation, consider versioning\n- **Database-Centric:** Analyze schema impacts, migration strategies, and query performance\n- **Security-Focused:** Consider authentication, authorization, input validation, and OWASP compliance\n- **Performance-Oriented:** Evaluate caching strategies, query optimization, and response times\n- **Scalability-Aware:** Consider horizontal scaling, load balancing, and future growth\n- **Documentation-Driven:** Ensure comprehensive API docs, Postman collections, and integration guides\n"
              },
              {
                "name": "/resolve_todo_parallel",
                "description": null,
                "path": "plugins/traya-backend-engineering/commands/resolve_todo_parallel.md",
                "frontmatter": null,
                "content": "# Resolve Backend TODOs in Parallel\n\nResolve all TODO comments using parallel processing for backend development tasks.\n\n## Workflow\n\n### 1. Analyze\n\nGet all unresolved TODOs from the /todos/\\*.md directory and analyze their backend-specific requirements:\n\n- API development tasks\n- Database migration tasks\n- Security fixes\n- Performance optimizations\n- Testing improvements\n- Documentation updates\n\n### 2. Plan\n\nCreate a TodoWrite list of all unresolved items grouped by type and dependencies. Make sure to analyze dependencies that might occur and prioritize the ones needed by others.\n\n**Backend-Specific Dependencies:**\n\n- **Database migrations must run before API changes** that depend on schema\n- **Authentication changes** must complete before authorization changes\n- **Service layer changes** before controller changes\n- **Entity changes** before repository changes\n- **DTO validation** before controller implementation\n- **Test setup** before test implementation\n\n**Dependency Analysis:**\n\nFor example, if you need to:\n1. Add a new database column (migration)\n2. Update TypeORM entity\n3. Update service to use new field\n4. Update controller/DTO\n5. Add tests\n\nThese must run sequentially. However, independent tasks (different API endpoints, separate services, documentation) can run in parallel.\n\nOutput a mermaid flow diagram showing how we can execute these tasks:\n\n```mermaid\ngraph TD\n    A[Database Migration: Add user_role column] --> B[Update User Entity]\n    B --> C[Update UserService]\n    C --> D[Update UserController + DTO]\n    D --> E[Add Unit Tests]\n    D --> F[Add Integration Tests]\n\n    G[New API Endpoint: GET /health] --> H[Add HealthController]\n    H --> I[Add Health Tests]\n\n    J[Documentation: Update OpenAPI] --> K[Update Postman Collection]\n\n    E --> L[Run All Tests]\n    F --> L\n    I --> L\n    L --> M[Commit Changes]\n```\n\nThe diagram should clearly show:\n- Which tasks can run in parallel (different branches)\n- Which tasks must run sequentially (arrows showing dependencies)\n- Which tasks converge before final steps (testing, committing)\n\n### 3. Implement (PARALLEL)\n\nBased on the dependency analysis, spawn backend-specific resolver agents in parallel for independent tasks.\n\n**Agent Assignment by Task Type:**\n\n**For API Development Tasks:**\n- Task api-designer(task_details) - For API design and endpoint planning\n- Task nestjs-specialist(task_details) - For NestJS-specific implementation\n- Task express-specialist(task_details) - For Express.js implementation\n\n**For Database Tasks:**\n- Task database-modeler(task_details) - For schema design\n- Task typeorm-specialist(task_details) - For entity and migration implementation\n\n**For Security Tasks:**\n- Task security-auditor(task_details) - For security fixes and audits\n\n**For Performance Tasks:**\n- Task performance-analyzer(task_details) - For optimization implementation\n\n**For Testing Tasks:**\n- Task testing-specialist(task_details) - For comprehensive test creation\n\n**For Documentation Tasks:**\n- Task api-documenter(task_details) - For OpenAPI specs and documentation\n\n**Parallel Execution Strategy:**\n\n```\n# Example: 5 independent tasks can run in parallel\n\nParallel Group 1 (can all run simultaneously):\n1. Task nestjs-specialist(todo-042-add-health-endpoint)\n2. Task api-documenter(todo-043-update-openapi-spec)\n3. Task testing-specialist(todo-044-add-user-service-tests)\n4. Task security-auditor(todo-045-fix-jwt-validation)\n5. Task performance-analyzer(todo-046-optimize-query-performance)\n\nSequential Group 1 (must run in order):\n1. Task database-modeler(todo-047-add-user-role-field)\n   ‚Üì\n2. Task typeorm-specialist(todo-048-update-user-entity)\n   ‚Üì\n3. Task nestjs-specialist(todo-049-update-user-service)\n   ‚Üì\n4. Task testing-specialist(todo-050-test-user-role)\n```\n\n**Backend-Specific Parallel Execution Rules:**\n\n‚úÖ **CAN run in parallel:**\n- Independent API endpoints (different resources)\n- Separate database tables/entities\n- Different service classes\n- Independent test files\n- Documentation tasks\n- Security fixes in different modules\n- Performance optimizations in different areas\n\n‚ùå **CANNOT run in parallel (must be sequential):**\n- Database migration ‚Üí Entity update ‚Üí Service update ‚Üí Controller update\n- Authentication ‚Üí Authorization (dependency)\n- Parent entity ‚Üí Child entity (foreign key dependency)\n- Service layer ‚Üí Controller layer (same feature)\n- Implementation ‚Üí Tests (for same feature)\n\n### 4. Validation & Testing\n\nAfter parallel execution completes, run comprehensive validation:\n\n**Backend Testing Suite:**\n\n```bash\n# TypeScript compilation\nnpm run build || tsc --noEmit\n\n# Linting\nnpm run lint || eslint . --ext .ts\n\n# Unit tests\nnpm test || jest --coverage\n\n# Integration tests\nnpm run test:integration || jest --config jest.integration.config.js\n\n# E2E tests (if applicable)\nnpm run test:e2e\n\n# Type checking\ntsc --noEmit --pretty\n\n# Database migration validation (test rollback)\nnpm run migration:run\nnpm run migration:revert\nnpm run migration:run\n```\n\n**API Testing:**\n\n```bash\n# Test all endpoints with Postman (if Postman MCP available)\n# Validate OpenAPI spec compliance\n# Check response schemas\n# Verify authentication/authorization\n# Test error scenarios\n```\n\n**Database Validation:**\n\n```bash\n# Verify migrations applied successfully\n# Check indexes created\n# Validate constraints\n# Test query performance\n```\n\n### 5. Commit & Resolve\n\n**Pre-commit Checklist:**\n\n- [ ] All tests pass (unit + integration)\n- [ ] TypeScript compilation successful\n- [ ] ESLint passes with no warnings\n- [ ] No console.log statements in production code\n- [ ] API documentation updated (OpenAPI spec)\n- [ ] Postman collection updated (if applicable)\n- [ ] Database migrations tested (up and down)\n- [ ] Breaking changes documented\n- [ ] CHANGELOG updated\n\n**Commit Strategy:**\n\n```bash\n# If all tasks are related (same feature):\ngit add .\ngit commit -m \"feat(api): implement user role-based access control\n\n- Add user_role column to users table (migration)\n- Update User entity with role field\n- Implement role-based guards in NestJS\n- Add RBAC tests (unit + integration)\n- Update OpenAPI spec with role requirements\n- Add Postman collection examples\n\nBreaking changes:\n- All protected endpoints now require role claim in JWT\n\nRefs: #042, #043, #044, #045\n\"\n\n# If tasks are unrelated, create separate commits:\ngit add src/api/health/*\ngit commit -m \"feat(health): add health check endpoint\"\n\ngit add src/api/users/* src/database/migrations/*\ngit commit -m \"feat(users): add role-based access control\"\n\ngit add docs/* postman/*\ngit commit -m \"docs: update API documentation and Postman collection\"\n```\n\n**Resolve TODOs:**\n\n- Mark all completed TODO items as resolved\n- Update todo file status from `pending` to `completed`\n- Archive completed todos (move to `todos/completed/`)\n- Document any remaining work or follow-up items\n\n**Push Changes:**\n\n```bash\n# Push to remote branch\ngit push origin feature-branch-name\n\n# Or create PR if work is complete\ngh pr create --title \"feat: [description]\" --body \"[details]\"\n```\n\n## Backend-Specific Considerations\n\n### Breaking API Changes\n\nIf any todo involves breaking API changes:\n\n1. **Document the change:**\n   ```markdown\n   ## Breaking Changes\n   - Endpoint: `GET /api/v1/users`\n   - Change: Added required `role` query parameter\n   - Migration: Clients must include `?role=user` in requests\n   - Version: Affects v1, new behavior in v2\n   ```\n\n2. **Update API version** (if using versioning)\n3. **Add deprecation warnings** to old endpoints\n4. **Notify API consumers** before merging\n5. **Update migration guides**\n\n### Database Migrations\n\nFor todos involving database changes:\n\n1. **Test migration on fresh database:**\n   ```bash\n   npm run migration:run\n   ```\n\n2. **Test rollback:**\n   ```bash\n   npm run migration:revert\n   ```\n\n3. **Test with production-like data:**\n   - Create seed data\n   - Run migration\n   - Verify data integrity\n   - Test application functionality\n\n4. **Document migration:**\n   ```typescript\n   /**\n    * Migration: Add user_role column\n    *\n    * Changes:\n    * - Add role column to users table\n    * - Create index on role column\n    * - Set default role to 'user'\n    *\n    * Rollback: Drops role column and index\n    *\n    * Data impact: None - column is nullable with default\n    */\n   ```\n\n### Performance Optimizations\n\nFor performance-related todos:\n\n1. **Benchmark before:**\n   ```bash\n   # Record baseline metrics\n   npm run benchmark\n   ```\n\n2. **Implement optimization**\n\n3. **Benchmark after:**\n   ```bash\n   # Compare with baseline\n   npm run benchmark\n   ```\n\n4. **Document improvement:**\n   ```markdown\n   ## Performance Improvement\n   - Endpoint: GET /api/v1/users\n   - Before: 450ms (p95)\n   - After: 125ms (p95)\n   - Improvement: 72% reduction\n   - Method: Added Redis caching, optimized query with indexes\n   ```\n\n### Security Fixes\n\nFor security-related todos:\n\n1. **Verify fix with security tests:**\n   ```bash\n   # Run security-specific tests\n   npm run test:security\n   ```\n\n2. **Check for similar vulnerabilities:**\n   - Search codebase for similar patterns\n   - Apply fix consistently across codebase\n\n3. **Update security documentation:**\n   - Document the vulnerability\n   - Describe the fix\n   - Add to security checklist\n\n4. **Run dependency audit:**\n   ```bash\n   npm audit\n   npm audit fix\n   ```\n\n## Final Summary\n\nAfter all todos resolved:\n\n```markdown\n## Backend TODOs Resolution Complete\n\n**Total TODOs Resolved:** [X]\n**Execution Mode:** [Parallel/Sequential/Mixed]\n**Execution Time:** [Y minutes]\n\n### Completed Tasks by Category:\n- üåê API Development: [count]\n- üóÑÔ∏è Database: [count]\n- üîí Security: [count]\n- ‚ö° Performance: [count]\n- ‚úÖ Testing: [count]\n- üìù Documentation: [count]\n\n### Database Changes:\n- Migrations created: [count]\n- Tables modified: [list]\n- Indexes added: [count]\n\n### API Changes:\n- New endpoints: [count]\n- Modified endpoints: [count]\n- Breaking changes: [Yes/No - list if yes]\n- OpenAPI spec updated: [Yes/No]\n\n### Test Coverage:\n- Unit tests added: [count]\n- Integration tests added: [count]\n- Coverage change: [before% ‚Üí after%]\n\n### Performance Improvements:\n- Optimized endpoints: [list]\n- Response time improvements: [details]\n- Query optimizations: [count]\n\n### Commits Created:\n- [commit SHA] - [commit message]\n- [commit SHA] - [commit message]\n\n### Next Steps:\n1. Create pull request: `gh pr create`\n2. Request code review from backend team\n3. Run CI/CD pipeline\n4. Test on staging environment\n5. Plan deployment (especially for migrations)\n6. Notify API consumers if breaking changes\n```\n"
              },
              {
                "name": "/review",
                "description": null,
                "path": "plugins/traya-backend-engineering/commands/review.md",
                "frontmatter": null,
                "content": "# Review Command for Backend Development\n\n<command_purpose> Perform exhaustive backend code reviews using multi-agent analysis, ultra-thinking, and Git worktrees for deep local inspection of APIs, databases, and services. </command_purpose>\n\n## Introduction\n\n<role>Senior Backend Architect with expertise in API design, database optimization, security, performance, and distributed systems</role>\n\n## Prerequisites\n\n<requirements>\n- Git repository with GitHub CLI (`gh`) installed and authenticated\n- Clean main/master branch\n- Proper permissions to create worktrees and access the repository\n- For document reviews: Path to a markdown file or document\n- Backend-specific tools: Node.js, npm/yarn, TypeScript compiler\n</requirements>\n\n## Main Tasks\n\n### 1. Worktree Creation and Branch Checkout (ALWAYS FIRST)\n\n<review_target> #$ARGUMENTS </review_target>\n\n<critical_requirement> MUST create worktree FIRST to enable local code analysis. No exceptions. </critical_requirement>\n\n<thinking>\nFirst, I need to determine the review target type and set up the worktree.\nThis enables all subsequent agents to analyze actual backend code, database schemas, API implementations, not just diffs.\n</thinking>\n\n#### Immediate Actions:\n\n<task_list>\n\n- [ ] Determine review type: PR number (numeric), GitHub URL, file path (.md), or empty (latest PR)\n- [ ] Create worktree directory structure at `$git_root/.worktrees/reviews/pr-$identifier`\n- [ ] Check out PR branch in isolated worktree using `gh pr checkout`\n- [ ] Navigate to worktree - ALL subsequent analysis happens here\n\n- Fetch PR metadata using `gh pr view --json` for title, body, files, linked issues\n- Clone PR branch into worktree with full history `gh pr checkout $identifier`\n- Set up backend analysis tools (TypeScript compiler, ESLint, database schema tools)\n- Prepare security scanning environment (OWASP checks, dependency audit)\n\nEnsure that the worktree is set up correctly and that the PR is checked out. ONLY then proceed to the next step.\n\n</task_list>\n\n#### Detect Project Type\n\n<thinking>\nDetermine the backend project type by analyzing the codebase structure and files.\nThis will inform which framework-specific reviewers to use.\n</thinking>\n\n<project_type_detection>\n\nCheck for these indicators to determine backend project type:\n\n**NestJS Project**:\n- `nest-cli.json`\n- `package.json` with `@nestjs/core`, `@nestjs/common`\n- Decorators: `@Module()`, `@Controller()`, `@Injectable()`\n- File patterns: `*.controller.ts`, `*.service.ts`, `*.module.ts`\n\n**Express.js Project**:\n- `package.json` with `express`\n- File patterns: `app.js`, `server.js`, `routes/*.js`\n- Middleware patterns\n\n**TypeORM Database**:\n- `ormconfig.json` or `ormconfig.ts`\n- `package.json` with `typeorm`\n- Entity files: `*.entity.ts`\n- Migration files: `migrations/*.ts`\n\n**PostgreSQL/MongoDB**:\n- Database configuration files\n- Schema definitions\n- Migration scripts\n\n**API Documentation**:\n- `swagger.json`, `openapi.yaml`\n- Postman collection files\n\nBased on detection, set appropriate reviewers for parallel execution.\n\n</project_type_detection>\n\n#### Parallel Agents to Review the PR:\n\n<parallel_tasks>\n\nRun ALL or most of these backend-specific agents at the same time:\n\n**Backend Framework Reviewers (choose based on project type)**:\n\nFor NestJS projects:\n1. Task nestjs-specialist(PR content)\n\nFor Express projects:\n2. Task express-specialist(PR content)\n\n**Database & ORM Reviewers**:\n3. Task database-modeler(PR content)\n4. Task typeorm-specialist(PR content)\n5. Task redis-cache-specialist(PR content)\n\n**API & Documentation Reviewers**:\n6. Task api-designer(PR content)\n7. Task api-documenter(PR content)\n\n**Quality & Testing Reviewers**:\n8. Task testing-specialist(PR content)\n9. Task typescript-reviewer(PR content)\n\n**Performance & Security**:\n10. Task performance-analyzer(PR content)\n11. Task security-auditor(PR content)\n\n**Universal Backend Reviewers**:\n12. Task architecture-strategist(PR content)\n\n</parallel_tasks>\n\n### 2. Ultra-Thinking Deep Dive Phases\n\n<ultrathink_instruction> For each phase below, spend maximum cognitive effort. Think step by step. Consider all angles. Question assumptions. Bring all reviews in a synthesis to the user.</ultrathink_instruction>\n\n#### Phase 1: API Contract Analysis\n\n<thinking_prompt> ULTRA-THINK: Analyze API design, contracts, versioning, and backward compatibility. What could break for API consumers? </thinking_prompt>\n\n<api_analysis_checklist>\n\n- [ ] **REST Principles**: Proper HTTP methods, status codes, resource naming\n- [ ] **API Versioning**: URI versioning, header versioning, deprecation strategy\n- [ ] **Request Validation**: DTO validation, schema constraints, type safety\n- [ ] **Response Format**: Consistent structure, error handling (RFC 7807)\n- [ ] **Authentication**: JWT, OAuth, API keys - proper implementation\n- [ ] **Authorization**: Role-based access control, permissions, guards\n- [ ] **Rate Limiting**: Throttling, abuse prevention\n- [ ] **API Documentation**: OpenAPI spec, Postman collection, examples\n- [ ] **Breaking Changes**: Backward compatibility, migration path\n- [ ] **Idempotency**: POST/PUT/DELETE idempotency keys\n\n</api_analysis_checklist>\n\n<deliverable>\nComplete API contract analysis with endpoint-by-endpoint review\n</deliverable>\n\n#### Phase 2: Database Architecture Review\n\n<thinking_prompt> ULTRA-THINK: Analyze database schema design, migrations, query performance, and data integrity. What could cause data corruption or performance issues? </thinking_prompt>\n\n<database_analysis_checklist>\n\n- [ ] **Schema Design**: Normalization, relationships, constraints\n- [ ] **Migrations**: Reversible migrations, zero-downtime deployment\n- [ ] **Indexes**: Proper indexing for query performance\n- [ ] **Queries**: N+1 problems, query optimization, eager/lazy loading\n- [ ] **Transactions**: ACID compliance, transaction boundaries\n- [ ] **Data Integrity**: Foreign keys, cascades, validation\n- [ ] **Concurrency**: Race conditions, locking strategies\n- [ ] **Performance**: Query execution plans, slow query analysis\n- [ ] **Scalability**: Partitioning, sharding considerations\n- [ ] **Backup Strategy**: Data recovery, migration rollback\n\n</database_analysis_checklist>\n\n<deliverable>\nComplete database architecture map with schema diagrams and performance analysis\n</deliverable>\n\n#### Phase 3: Stakeholder Perspective Analysis\n\n<thinking_prompt> ULTRA-THINK: Put yourself in each stakeholder's shoes. What matters to them? What are their pain points? </thinking_prompt>\n\n<stakeholder_perspectives>\n\n1. **API Consumer Perspective** <questions>\n\n   - Are API contracts clear and well-documented?\n   - Is error handling informative?\n   - Are response times acceptable?\n   - Is authentication straightforward?\n   - Are there breaking changes? </questions>\n\n2. **Backend Developer Perspective** <questions>\n\n   - Is the code maintainable and testable?\n   - Are design patterns consistent?\n   - Is the service layer properly separated?\n   - Can I debug issues easily?\n   - Are TypeScript types comprehensive? </questions>\n\n3. **Database Administrator Perspective** <questions>\n\n   - Are migrations safe and reversible?\n   - Are indexes optimized?\n   - Is query performance acceptable?\n   - Are there data integrity risks?\n   - Is the schema normalized properly? </questions>\n\n4. **DevOps/Operations Perspective** <questions>\n\n   - How do I deploy this safely?\n   - What metrics and logs are available?\n   - How do I troubleshoot issues?\n   - What are the resource requirements?\n   - Is health checking implemented? </questions>\n\n5. **Security Team Perspective** <questions>\n\n   - What's the attack surface?\n   - Is input validation comprehensive?\n   - Are SQL injection risks mitigated?\n   - Is authentication/authorization secure?\n   - Are sensitive data encrypted?\n   - OWASP Top 10 compliance? </questions>\n\n6. **Performance Team Perspective** <questions>\n\n   - What are the response time targets?\n   - Is caching implemented properly?\n   - Are database queries optimized?\n   - Is there a load testing strategy?\n   - What's the throughput capacity? </questions>\n\n7. **Business Perspective** <questions>\n   - Does this API enable business requirements?\n   - Are there compliance risks?\n   - What's the operational cost?\n   - Is there an SLA commitment? </questions> </stakeholder_perspectives>\n\n#### Phase 4: Backend Scenario Exploration\n\n<thinking_prompt> ULTRA-THINK: Explore edge cases and failure scenarios specific to backend systems. What could go wrong? How does the system behave under stress? </thinking_prompt>\n\n<scenario_checklist>\n\n**API Scenarios:**\n- [ ] **Happy Path**: Valid requests with correct authentication\n- [ ] **Invalid Inputs**: Null, empty, malformed JSON/XML\n- [ ] **Authentication Failures**: Invalid tokens, expired sessions\n- [ ] **Authorization Failures**: Insufficient permissions\n- [ ] **Rate Limiting**: Throttling, DDoS protection\n- [ ] **Validation Errors**: DTO validation failures\n- [ ] **Content Negotiation**: Accept headers, unsupported formats\n\n**Database Scenarios:**\n- [ ] **Concurrent Writes**: Race conditions, deadlocks\n- [ ] **Transaction Rollbacks**: Partial failures, data consistency\n- [ ] **Connection Pool Exhaustion**: High load scenarios\n- [ ] **Migration Failures**: Rollback procedures\n- [ ] **Data Constraints**: Foreign key violations, unique constraints\n- [ ] **Query Timeouts**: Slow queries under load\n- [ ] **Cascade Deletes**: Unintended data deletion\n\n**Integration Scenarios:**\n- [ ] **External API Failures**: Timeouts, 5xx errors\n- [ ] **Network Issues**: Retries, circuit breakers\n- [ ] **Message Queue Failures**: Dead letter queues\n- [ ] **Cache Misses**: Redis unavailability, cache invalidation\n- [ ] **File Storage Failures**: Upload/download errors\n\n**Scale & Performance:**\n- [ ] **10x Load**: Response time degradation\n- [ ] **100x Load**: System breaking points\n- [ ] **Memory Leaks**: Long-running processes\n- [ ] **Connection Leaks**: Database connection handling\n- [ ] **Disk Space**: Log growth, temp files\n\n**Security Scenarios:**\n- [ ] **SQL Injection**: Parameterized queries\n- [ ] **NoSQL Injection**: MongoDB injection\n- [ ] **XSS**: Output encoding\n- [ ] **CSRF**: Token validation\n- [ ] **JWT Attacks**: Algorithm confusion, token expiry\n- [ ] **Sensitive Data Exposure**: Logging, error messages\n\n</scenario_checklist>\n\n### 3. Multi-Angle Backend Review Perspectives\n\n#### API Design Excellence\n\n- REST/GraphQL best practices\n- OpenAPI 3.0 specification quality\n- Endpoint naming and resource modeling\n- HTTP method and status code correctness\n- Request/response schema validation\n- Error handling consistency (RFC 7807)\n- API versioning strategy\n- Documentation completeness\n\n#### Database Quality\n\n- Schema design and normalization\n- Migration safety and reversibility\n- Index optimization\n- Query performance\n- Transaction management\n- Data integrity constraints\n- ORM usage patterns (TypeORM best practices)\n- Connection pooling configuration\n\n#### Security Hardening\n\n- OWASP Top 10 compliance\n- Input validation and sanitization\n- SQL/NoSQL injection prevention\n- Authentication implementation (JWT, OAuth)\n- Authorization and RBAC\n- Sensitive data handling\n- Dependency vulnerabilities (`npm audit`)\n- Security headers (helmet.js)\n\n#### Performance Optimization\n\n- API response time targets (<200ms p95)\n- Database query optimization\n- Caching strategy (Redis)\n- Connection pooling\n- Load testing results\n- Memory usage profiling\n- Async/await patterns\n- Batch operations\n\n#### Testing Coverage\n\n- Unit test coverage (>80%)\n- Integration test completeness\n- API contract testing (Supertest)\n- Database transaction testing\n- Error scenario coverage\n- Performance benchmarks\n- Load testing\n- Security testing\n\n#### Code Quality\n\n- TypeScript strict mode compliance\n- Consistent code style (ESLint, Prettier)\n- Service layer separation\n- Dependency injection patterns\n- Error handling consistency\n- Logging and monitoring\n- Documentation and comments\n- Code duplication analysis\n\n### 4. Backend Simplification Review\n\nRun the Task code-simplicity-reviewer() to identify opportunities to simplify backend code:\n\n- Reduce complexity in service methods\n- Eliminate redundant database queries\n- Simplify DTO definitions\n- Streamline middleware chains\n- Optimize import statements\n- Reduce cyclomatic complexity\n\n### 5. Findings Synthesis and Todo Creation\n\n<critical_requirement> All findings MUST be converted to actionable todos in the CLI todo system </critical_requirement>\n\n#### Step 1: Synthesize All Findings\n\n<thinking>\nConsolidate all backend agent reports into a categorized list of findings.\nRemove duplicates, prioritize by severity and impact on API consumers, database, security, and performance.\n</thinking>\n\n<synthesis_tasks>\n- [ ] Collect findings from all parallel backend agents\n- [ ] Categorize by type: api-design, database, security, performance, testing, code-quality\n- [ ] Assign severity levels: üî¥ CRITICAL (P1), üü° IMPORTANT (P2), üîµ NICE-TO-HAVE (P3)\n- [ ] Remove duplicate or overlapping findings\n- [ ] Estimate effort for each finding (Small/Medium/Large)\n- [ ] Identify breaking changes for API consumers\n</synthesis_tasks>\n\n#### Step 2: Present Findings for Triage\n\nFor EACH finding, present in this format:\n\n```\n---\nFinding #X: [Brief Title]\n\nSeverity: üî¥ P1 / üü° P2 / üîµ P3\n\nCategory: [API-Design/Database/Security/Performance/Testing/Code-Quality]\n\nDescription:\n[Detailed explanation of the issue or improvement]\n\nLocation: [file_path:line_number]\n\nProblem:\n[What's wrong or could be better]\n\nImpact:\n- API consumers: [How this affects API users]\n- Database: [Schema/performance impact]\n- Security: [Vulnerability or compliance issue]\n- Performance: [Response time/throughput impact]\n\nProposed Solution:\n[How to fix it with code examples]\n\nBackend-Specific Details:\n- Migration required: [Yes/No]\n- Breaking change: [Yes/No]\n- Database indexes: [Add/modify/remove]\n- API version: [Affected versions]\n\nEffort: Small/Medium/Large\n\n---\nDo you want to add this to the todo list?\n1. yes - create todo file\n2. next - skip this finding\n3. custom - modify before creating\n```\n\n#### Step 3: Create Todo Files for Approved Findings\n\n<instructions>\nWhen user says \"yes\", create a properly formatted todo file:\n</instructions>\n\n<todo_creation_process>\n\n1. **Determine next issue ID:**\n   ```bash\n   ls todos/ | grep -o '^[0-9]\\+' | sort -n | tail -1\n   ```\n\n2. **Generate filename:**\n   ```\n   {next_id}-pending-{priority}-{brief-description}.md\n   ```\n   Example: `042-pending-p1-sql-injection-user-search.md`\n\n3. **Create file from template:**\n   ```bash\n   cp todos/000-pending-p1-TEMPLATE.md todos/{new_filename}\n   ```\n\n4. **Populate with finding data:**\n   ```yaml\n   ---\n   status: pending\n   priority: p1  # or p2, p3 based on severity\n   issue_id: \"042\"\n   tags: [code-review, security, api, database, nestjs]  # add relevant backend tags\n   dependencies: []\n   breaking_change: false  # or true if API breaking change\n   migration_required: false  # or true if database migration needed\n   ---\n\n   # [Finding Title]\n\n   ## Problem Statement\n   [Detailed description from finding]\n\n   ## Findings\n   - Discovered during backend code review by [agent names]\n   - Location: [file_path:line_number]\n   - Category: [API/Database/Security/Performance]\n   - [Key discoveries from agents]\n\n   ## Impact Analysis\n\n   ### API Consumers\n   - [How this affects API users]\n   - Breaking change: [Yes/No]\n\n   ### Database\n   - Schema changes: [Yes/No]\n   - Migration required: [Yes/No]\n   - Performance impact: [Description]\n\n   ### Security\n   - Vulnerability: [Type and severity]\n   - OWASP category: [If applicable]\n\n   ### Performance\n   - Response time impact: [Measurement]\n   - Throughput impact: [Measurement]\n\n   ## Proposed Solutions\n\n   ### Option 1: [Primary solution from finding]\n   - **Pros**: [Benefits]\n   - **Cons**: [Drawbacks]\n   - **Effort**: [Small/Medium/Large]\n   - **Risk**: [Low/Medium/High]\n   - **Migration**: [Required/Not required]\n\n   ### Code Example:\n   ```typescript\n   // Before\n   [Current code]\n\n   // After\n   [Proposed fix]\n   ```\n\n   ## Recommended Action\n   [Leave blank - needs manager triage]\n\n   ## Technical Details\n   - **Affected Files**: [List from finding]\n   - **API Endpoints**: [List affected endpoints]\n   - **Database Tables**: [List affected tables]\n   - **Entities**: [TypeORM entities affected]\n   - **Services**: [Service layer components affected]\n   - **Controllers**: [Controllers affected]\n   - **Database Changes**: [Schema modifications needed]\n   - **Migration Script**: [Required/Not required]\n\n   ## Testing Requirements\n   - [ ] Unit tests for service layer\n   - [ ] Integration tests for API endpoints\n   - [ ] Database migration testing (up/down)\n   - [ ] Performance benchmarking\n   - [ ] Security testing\n   - [ ] Postman collection validation\n\n   ## Resources\n   - Code review PR: [PR link if applicable]\n   - Related findings: [Other finding numbers]\n   - Agent reports: [Which agents flagged this]\n   - OpenAPI spec: [Link to affected spec]\n   - Database schema: [Link to ERD or schema docs]\n\n   ## Acceptance Criteria\n   - [ ] [Specific criteria based on solution]\n   - [ ] All tests pass (unit + integration)\n   - [ ] TypeScript compilation successful\n   - [ ] ESLint passes with no warnings\n   - [ ] API documentation updated (OpenAPI spec)\n   - [ ] Postman collection updated\n   - [ ] Database migration tested (if applicable)\n   - [ ] Performance benchmarks meet targets\n   - [ ] Security audit passed\n   - [ ] Code reviewed by 2+ developers\n\n   ## Work Log\n\n   ### {date} - Code Review Discovery\n   **By:** Claude Backend Code Review System\n   **Actions:**\n   - Discovered during comprehensive backend code review\n   - Analyzed by multiple specialized backend agents\n   - Categorized and prioritized\n   - Impact analysis completed\n\n   **Learnings:**\n   - [Key insights from agent analysis]\n\n   ## Notes\n   Source: Backend code review performed on {date}\n   Review command: /traya-backend-engineering:review {arguments}\n   ```\n\n5. **Track creation:**\n   Add to TodoWrite list if tracking multiple findings\n\n</todo_creation_process>\n\n#### Step 4: Summary Report\n\nAfter processing all findings:\n\n```markdown\n## Backend Code Review Complete\n\n**Review Target:** [PR number or branch]\n**Total Findings:** [X]\n**Todos Created:** [Y]\n\n### Findings by Category:\n- üåê API Design: [count]\n- üóÑÔ∏è Database: [count]\n- üîí Security: [count]\n- ‚ö° Performance: [count]\n- ‚úÖ Testing: [count]\n- üìù Code Quality: [count]\n\n### Breaking Changes:\n- [List any API breaking changes]\n\n### Database Migrations Required:\n- [List migrations needed]\n\n### Created Todos:\n- `{issue_id}-pending-p1-{description}.md` - {title}\n- `{issue_id}-pending-p2-{description}.md` - {title}\n...\n\n### Skipped Findings:\n- [Finding #Z]: {reason}\n...\n\n### Next Steps:\n1. Triage pending todos: `ls todos/*-pending-*.md`\n2. Use `/traya-backend-engineering:triage` to review and approve\n3. Work on approved items: `/traya-backend-engineering:resolve_todo_parallel`\n4. Run migration scripts if database changes\n5. Update API documentation if API changes\n6. Notify API consumers of breaking changes\n```\n\n#### Alternative: Batch Creation\n\nIf user wants to convert all findings to todos without review:\n\n```bash\n# Ask: \"Create todos for all X findings? (yes/no/show-critical-only)\"\n# If yes: create todo files for all findings in parallel\n# If show-critical-only: only present P1 findings for triage\n```\n\n## Backend-Specific Review Outputs\n\n### API Contract Compliance Report\n- OpenAPI spec validation\n- Endpoint consistency check\n- Authentication/authorization review\n- Error handling patterns\n- API versioning assessment\n\n### Database Health Report\n- Schema design quality\n- Migration safety assessment\n- Index optimization recommendations\n- Query performance analysis\n- Transaction boundary review\n\n### Security Audit Report\n- OWASP Top 10 compliance\n- Input validation coverage\n- Authentication/authorization security\n- Dependency vulnerability scan (`npm audit`)\n- Sensitive data handling review\n\n### Performance Assessment\n- API response time analysis\n- Database query optimization\n- Caching effectiveness\n- Load testing recommendations\n- Resource usage profiling\n"
              },
              {
                "name": "/triage",
                "description": null,
                "path": "plugins/traya-backend-engineering/commands/triage.md",
                "frontmatter": null,
                "content": "# Triage Command for Backend Development\n\nPresent all findings, decisions, or issues here one by one for triage. The goal is to go through each item and decide whether to add it to the CLI todo system.\n\n**IMPORTANT: DO NOT CODE ANYTHING DURING TRIAGE!**\n\nThis command is for:\n- Triaging backend code review findings\n- Processing API security audit results\n- Reviewing database performance analysis\n- Handling API design improvements\n- Processing dependency vulnerability reports\n- Reviewing any other categorized backend findings that need tracking\n\n## Workflow\n\n### Step 1: Present Each Finding\n\nFor each finding, present in this format:\n\n```\n---\nProgress: [X/Y completed] | Estimated time remaining: [Z minutes]\n\nIssue #X: [Brief Title]\n\nSeverity: üî¥ P1 (CRITICAL) / üü° P2 (IMPORTANT) / üîµ P3 (NICE-TO-HAVE)\n\nCategory: [API-Design/Database/Security/Performance/Testing/Architecture/etc.]\n\nDescription:\n[Detailed explanation of the backend issue or improvement]\n\nLocation: [file_path:line_number]\n\nProblem Scenario:\n[Step by step what's wrong or could happen]\n\nBackend Impact:\n- API Consumers: [How this affects API users]\n- Database: [Schema/performance/integrity impact]\n- Security: [Vulnerability or compliance issue]\n- Performance: [Response time/throughput/scalability impact]\n- Breaking Change: [Yes/No - will this break existing API contracts?]\n\nProposed Solution:\n[How to fix it with specific backend implementation details]\n\nTechnical Details:\n- Affected Endpoints: [List API endpoints]\n- Database Tables: [List tables/entities]\n- Migration Required: [Yes/No]\n- TypeORM Entities: [List entities]\n- Services/Controllers: [List affected components]\n\nCode Example:\n```typescript\n// Current problematic code\n[Show current implementation]\n\n// Proposed fix\n[Show corrected implementation]\n```\n\nEstimated Effort: [Small (< 2 hours) / Medium (2-8 hours) / Large (> 8 hours)]\n\nTesting Requirements:\n- [ ] Unit tests needed\n- [ ] Integration tests needed\n- [ ] API contract testing needed\n- [ ] Database migration testing needed\n- [ ] Performance benchmarking needed\n- [ ] Security testing needed\n\n---\nDo you want to add this to the todo list?\n1. yes - create todo file\n2. next - skip this item\n3. custom - modify before creating\n```\n\n### Step 2: Handle User Decision\n\n**When user says \"yes\":**\n\n1. **Determine next issue ID:**\n   ```bash\n   ls todos/ | grep -o '^[0-9]\\+' | sort -n | tail -1\n   ```\n\n2. **Create filename:**\n   ```\n   {next_id}-pending-{priority}-{brief-description}.md\n   ```\n\n   Priority mapping:\n   - üî¥ P1 (CRITICAL) ‚Üí `p1`\n   - üü° P2 (IMPORTANT) ‚Üí `p2`\n   - üîµ P3 (NICE-TO-HAVE) ‚Üí `p3`\n\n   Example: `042-pending-p1-api-authentication-vulnerability.md`\n\n3. **Create from template:**\n   ```bash\n   cp todos/000-pending-p1-TEMPLATE.md todos/{new_filename}\n   ```\n\n4. **Populate the file:**\n   ```yaml\n   ---\n   status: pending\n   priority: p1  # or p2, p3 based on severity\n   issue_id: \"042\"\n   tags: [category, api, database, security, performance, nestjs, typeorm]\n   dependencies: []\n   breaking_change: false  # true if API breaking change\n   migration_required: false  # true if database migration needed\n   ---\n\n   # [Issue Title]\n\n   ## Problem Statement\n   [Description from finding]\n\n   ## Findings\n   - [Key discoveries]\n   - Location: [file_path:line_number]\n   - [Scenario details]\n\n   ## Backend Impact Analysis\n\n   ### API Consumers\n   - [Impact on API users]\n   - Breaking change: [Yes/No]\n   - API version affected: [v1, v2, etc.]\n\n   ### Database\n   - Schema changes: [Details]\n   - Migration required: [Yes/No]\n   - Performance impact: [Query time, throughput]\n   - Data integrity: [Concerns]\n\n   ### Security\n   - Vulnerability type: [SQL injection, XSS, authentication, etc.]\n   - OWASP category: [If applicable]\n   - Severity: [Critical/High/Medium/Low]\n\n   ### Performance\n   - Response time impact: [Current vs expected]\n   - Throughput impact: [Requests/sec]\n   - Resource usage: [Memory, CPU, connections]\n\n   ## Proposed Solutions\n\n   ### Option 1: [Primary solution]\n   - **Pros**: [Benefits]\n   - **Cons**: [Drawbacks if any]\n   - **Effort**: [Small/Medium/Large]\n   - **Risk**: [Low/Medium/High]\n   - **Migration**: [Required/Not required]\n\n   ### Code Example:\n   ```typescript\n   // Before\n   [Current code]\n\n   // After\n   [Proposed fix]\n   ```\n\n   ## Recommended Action\n   [Leave blank - will be filled during approval]\n\n   ## Technical Details\n   - **Affected Files**: [List files]\n   - **API Endpoints**: [List endpoints]\n   - **Database Tables**: [List tables]\n   - **TypeORM Entities**: [List entities]\n   - **Services**: [List services]\n   - **Controllers**: [List controllers]\n   - **Middleware**: [If applicable]\n   - **Guards/Interceptors**: [If applicable]\n   - **Database Changes**: [Yes/No - describe if yes]\n   - **Migration Script**: [Path if exists]\n\n   ## Testing Requirements\n   - [ ] Unit tests for service layer\n   - [ ] Integration tests for API endpoints\n   - [ ] API contract testing (Supertest)\n   - [ ] Database migration testing (up/down)\n   - [ ] Performance benchmarking\n   - [ ] Security testing (penetration, OWASP)\n   - [ ] Load testing\n   - [ ] Postman collection validation\n\n   ## Resources\n   - Original finding: [Source of this issue]\n   - Related issues: [If any]\n   - OpenAPI spec: [Link if applicable]\n   - Database schema: [Link to ERD]\n   - OWASP reference: [If security issue]\n   - NestJS docs: [Relevant documentation]\n\n   ## Acceptance Criteria\n   - [ ] [Specific success criteria]\n   - [ ] All tests pass (unit + integration)\n   - [ ] TypeScript compilation successful\n   - [ ] ESLint passes\n   - [ ] API documentation updated\n   - [ ] Postman collection updated\n   - [ ] Migration tested (if applicable)\n   - [ ] Performance benchmarks meet targets\n   - [ ] Security audit passed\n   - [ ] Code reviewed by 2+ developers\n\n   ## Work Log\n\n   ### {date} - Initial Discovery\n   **By:** Claude Triage System\n   **Actions:**\n   - Issue discovered during [triage session type]\n   - Categorized as {severity}\n   - Backend impact assessed\n   - Estimated effort: {effort}\n\n   **Learnings:**\n   - [Context and insights]\n\n   ## Notes\n   Source: Triage session on {date}\n   Breaking change: [Yes/No]\n   Migration required: [Yes/No]\n   ```\n\n5. **Confirm creation:**\n   \"‚úÖ Created: `{filename}` - Issue #{issue_id}\"\n\n**When user says \"next\":**\n- Skip to the next item\n- Track skipped items for summary\n\n**When user says \"custom\":**\n- Ask what to modify (priority, description, technical details, testing requirements)\n- Update the information\n- Present revised version\n- Ask again: yes/next/custom\n\n### Step 3: Continue Until All Processed\n\n- Process all items one by one\n- Track using TodoWrite for visibility\n- Show progress with each item (X/Y completed, estimated time remaining)\n- Don't wait for approval between items - keep moving\n\n### Step 4: Final Summary\n\nAfter all items processed:\n\n```markdown\n## Backend Triage Complete\n\n**Total Items:** [X]\n**Todos Created:** [Y]\n**Skipped:** [Z]\n\n### Triage Statistics:\n- üåê API Design issues: [count]\n- üóÑÔ∏è Database issues: [count]\n- üîí Security issues: [count]\n- ‚ö° Performance issues: [count]\n- ‚úÖ Testing improvements: [count]\n- üìù Code quality: [count]\n\n### Breaking Changes Identified:\n- [List any items that will break API contracts]\n\n### Database Migrations Required:\n- [List items requiring migrations]\n\n### Created Todos:\n- `042-pending-p1-api-authentication-vulnerability.md` - JWT token validation issue\n- `043-pending-p2-database-query-optimization.md` - N+1 query in user service\n- `044-pending-p1-sql-injection-search-endpoint.md` - Raw query vulnerability\n...\n\n### Skipped Items:\n- Item #5: [reason]\n- Item #12: [reason]\n\n### Next Steps:\n1. Review pending todos: `ls todos/*-pending-*.md`\n2. Approve for work: Move from pending ‚Üí ready status\n3. Start work: Use `/traya-backend-engineering:resolve_todo_parallel` or pick individually\n4. For breaking changes: Plan API versioning strategy\n5. For migrations: Test on staging environment first\n```\n\n## Example Response Format\n\n```\n---\nProgress: 5/12 completed | Estimated time remaining: 14 minutes\n\nIssue #5: Missing Input Validation in User Search Endpoint\n\nSeverity: üî¥ P1 (CRITICAL)\n\nCategory: Security / API Design\n\nDescription:\nThe user search endpoint in UserController does not validate or sanitize search input,\nallowing potential SQL injection through raw query execution in the repository layer.\n\nLocation: src/api/controllers/user.controller.ts:45-58, src/repositories/user.repository.ts:123-130\n\nProblem Scenario:\n1. Attacker sends malicious search query: `'; DROP TABLE users; --`\n2. Raw SQL query concatenates user input directly\n3. Database executes destructive SQL command\n4. Data loss and system compromise\n\nBackend Impact:\n- API Consumers: Vulnerable to exploitation, data breach risk\n- Database: Risk of data deletion, unauthorized access, schema manipulation\n- Security: CRITICAL - SQL injection (OWASP A03:2021)\n- Performance: No impact if fixed properly\n- Breaking Change: No - fix is backward compatible\n\nProposed Solution:\n1. Replace raw SQL with TypeORM QueryBuilder with parameter binding\n2. Add DTO validation using class-validator\n3. Implement input sanitization\n4. Add rate limiting to search endpoint\n\nTechnical Details:\n- Affected Endpoints: GET /api/v1/users/search\n- Database Tables: users, user_profiles\n- Migration Required: No\n- TypeORM Entities: User, UserProfile\n- Services/Controllers: UserService, UserController\n\nCode Example:\n```typescript\n// Current problematic code (user.repository.ts)\nasync searchUsers(query: string): Promise<User[]> {\n  // DANGEROUS: Direct string concatenation\n  return this.query(`SELECT * FROM users WHERE name LIKE '%${query}%'`);\n}\n\n// Proposed fix (user.repository.ts)\nasync searchUsers(query: string): Promise<User[]> {\n  return this.createQueryBuilder('user')\n    .where('user.name LIKE :query', { query: `%${query}%` })\n    .limit(50)\n    .getMany();\n}\n\n// Add DTO validation (user.controller.ts)\nexport class SearchUserDto {\n  @IsString()\n  @Length(2, 50)\n  @Matches(/^[a-zA-Z0-9\\s]+$/, {\n    message: 'Search query contains invalid characters'\n  })\n  query: string;\n}\n\n@Get('search')\nasync search(@Query() searchDto: SearchUserDto): Promise<UserDto[]> {\n  return this.userService.searchUsers(searchDto.query);\n}\n```\n\nEstimated Effort: Small (2 hours)\n\nTesting Requirements:\n- [x] Unit tests needed - test QueryBuilder implementation\n- [x] Integration tests needed - test endpoint with various inputs\n- [x] API contract testing needed - validate response schema\n- [ ] Database migration testing needed - not required\n- [x] Performance benchmarking needed - ensure query performance\n- [x] Security testing needed - test injection attempts, fuzzing\n\n---\nDo you want to add this to the todo list?\n1. yes - create todo file\n2. next - skip this item\n3. custom - modify before creating\n```\n\n## Backend-Specific Triage Guidelines\n\n### Security Issues (CRITICAL)\n- Always create todos for security vulnerabilities\n- Tag with OWASP category\n- Include proof of concept if available\n- Add security testing requirements\n- Plan for security audit after fix\n\n### Database Issues\n- Assess migration complexity\n- Consider zero-downtime deployment\n- Plan rollback strategy\n- Include performance testing\n- Review with DBA if schema changes\n\n### API Breaking Changes\n- Evaluate impact on consumers\n- Plan API versioning strategy\n- Document migration path\n- Add deprecation warnings\n- Coordinate with frontend teams\n\n### Performance Issues\n- Establish baseline metrics\n- Set target performance goals\n- Include load testing requirements\n- Consider caching strategies\n- Monitor production impact\n\nDo not code during triage. Every time you present a todo, show progress (how many completed, how many left) and estimated time for completion based on pace.\n"
              },
              {
                "name": "/work",
                "description": null,
                "path": "plugins/traya-backend-engineering/commands/work.md",
                "frontmatter": null,
                "content": "# Work Plan Execution Command for Backend Development\n\n## Introduction\n\nThis command helps you analyze a backend work document (plan, Markdown file, API specification, database design, or any structured document), create a comprehensive todo list using the TodoWrite tool, and then systematically execute each task until the entire plan is completed. It combines deep analysis with practical execution to transform backend plans into production-ready APIs and services.\n\n**Skill-Based Execution**: The command automatically detects backend task types (API development, database integration, documentation, testing) and invokes appropriate skills (api-developer, database-integrator, api-documentation-generator, api-tester, code-reviewer) for comprehensive, iterative workflows with built-in quality assurance. This leverages all bundled MCP servers (Postman, Context7, Serena) to ensure production-ready results.\n\n## Prerequisites\n\n- A work document to analyze (plan file, API specification, database design, or any structured document)\n- Clear understanding of project context and goals\n- Access to necessary tools and permissions for implementation\n- Ability to test and validate completed work\n- Git repository with main branch\n- **Bundled MCP servers** (automatically configured with plugin):\n  - Postman MCP (for API testing and validation)\n  - Context7 MCP (for framework documentation and best practices)\n  - Serena MCP (for codebase pattern analysis)\n\n## Main Tasks\n\n### 1. Setup Development Environment\n\n- Ensure main branch is up to date\n- Create feature branch with descriptive name\n- Setup worktree for isolated development\n- Configure development environment\n\n### 2. Analyze Input Document\n\n<input_document> #$ARGUMENTS </input_document>\n\n## Execution Workflow\n\n### Phase 1: Environment Setup\n\n1. **Update Main Branch**\n\n   ```bash\n   git checkout main\n   git pull origin main\n   ```\n\n2. **Create Feature Branch and Worktree**\n\n   - Determine appropriate branch name from document\n   - Get the root directory of the Git repository:\n\n   ```bash\n   git_root=$(git rev-parse --show-toplevel)\n   ```\n\n   - Create worktrees directory if it doesn't exist:\n\n   ```bash\n   mkdir -p \"$git_root/.worktrees\"\n   ```\n\n   - Add .worktrees to .gitignore if not already there:\n\n   ```bash\n   if ! grep -q \"^\\.worktrees$\" \"$git_root/.gitignore\"; then\n     echo \".worktrees\" >> \"$git_root/.gitignore\"\n   fi\n   ```\n\n   - Create the new worktree with feature branch:\n\n   ```bash\n   git worktree add -b feature-branch-name \"$git_root/.worktrees/feature-branch-name\" main\n   ```\n\n   - Change to the new worktree directory:\n\n   ```bash\n   cd \"$git_root/.worktrees/feature-branch-name\"\n   ```\n\n3. **Verify Environment**\n   - Confirm in correct worktree directory\n   - Install dependencies if needed (`npm install` or `yarn install`)\n   - Run initial tests to ensure clean state\n   - Verify database connection and migrations are up to date\n\n### Phase 2: Document Analysis and Planning\n\n1. **Read Input Document**\n\n   - Use Read tool to examine the work document\n   - Identify all deliverables and requirements (API endpoints, database schemas, integrations)\n   - Note any constraints or dependencies (external APIs, database migrations, authentication)\n   - Extract success criteria (performance targets, test coverage, API contract compliance)\n\n2. **Create Task Breakdown**\n\n   - Convert requirements into specific backend tasks\n   - Add implementation details for each task (controllers, services, entities, migrations)\n   - Include testing and validation steps (unit tests, integration tests, API testing)\n   - Consider edge cases and error handling (validation, error responses, rollback strategies)\n\n3. **Build Todo List**\n   - Use TodoWrite to create comprehensive list\n   - Set priorities based on dependencies (database schema before API implementation)\n   - Include all subtasks and checkpoints\n   - Add documentation and review tasks (OpenAPI specs, Postman collections)\n\n### Phase 3: Systematic Execution\n\n1. **Detect Task Type and Invoke Skills**\n\n   Analyze the work document and todo list to determine the backend task type, then automatically invoke appropriate skills for comprehensive execution:\n\n   **A. For API Development Tasks**\n\n   If the work involves building new API endpoints, implementing REST/GraphQL APIs, or creating controller logic:\n\n   ```\n   1. Invoke api-developer skill\n      - Analyze API requirements and design specifications\n      - Review existing API patterns with Serena MCP\n      - Fetch NestJS/Express documentation with Context7 MCP\n      - Implement controllers, services, DTOs\n      - Set up request validation with class-validator\n      - Implement authentication/authorization guards\n      - Add error handling and response serialization\n      - Visual API testing with Postman MCP\n      - Iterate until API contract validated\n\n   2. If database changes needed ‚Üí Invoke database-integrator skill\n      - Design database schema and ERD\n      - Create TypeORM entities and repositories\n      - Generate database migrations\n      - Implement data access layer\n      - Add indexes and optimize queries\n      - Test migration up/down scripts\n      - Validate data integrity\n\n   3. Invoke api-documentation-generator skill\n      - Generate OpenAPI 3.0 specification\n      - Create Postman collection with examples\n      - Document authentication requirements\n      - Add request/response examples\n      - Generate API changelog\n      - Update developer documentation\n\n   4. Invoke api-tester skill\n      - Unit testing for services and controllers\n      - Integration testing with Supertest\n      - API contract testing with Postman MCP\n      - Error scenario validation\n      - Performance testing (response times)\n      - Security testing (authentication, authorization, injection)\n      - Issue documentation and fixing\n\n   5. Invoke code-reviewer skill\n      - Task completion verification\n      - Technical quality review\n      - Best practices validation (Context7 MCP)\n      - Code structure and organization review\n      - Performance, security, OWASP compliance checks\n      - Project conventions compliance\n   ```\n\n   **B. For Database Integration Tasks**\n\n   If the work focuses primarily on database design, migrations, or ORM implementation:\n\n   ```\n   1. Invoke database-integrator skill\n      - Database schema design and ERD creation\n      - TypeORM entity definitions\n      - Migration scripts with rollback support\n      - Repository pattern implementation\n      - Query optimization and indexing\n      - Data seeding for development\n      - Migration testing and validation\n\n   2. If APIs expose database ‚Üí Invoke api-developer skill\n      - Create controllers for CRUD operations\n      - Implement DTOs and validation\n      - Add pagination, filtering, sorting\n      - Response serialization\n\n   3. Invoke api-tester skill\n      - Test database transactions and rollbacks\n      - Validate migration scripts\n      - Integration testing with test database\n      - Performance testing for queries\n      - Data integrity validation\n\n   4. Invoke code-reviewer skill\n      - Database design review\n      - Migration safety verification\n      - Query performance analysis\n      - Index optimization review\n   ```\n\n   **C. For API Documentation Tasks**\n\n   If the work involves creating or updating API documentation, OpenAPI specs, or Postman collections:\n\n   ```\n   1. Invoke api-documentation-generator skill\n      - OpenAPI 3.0 specification generation\n      - Postman collection creation\n      - GraphQL schema documentation (if applicable)\n      - Authentication guide\n      - Error code reference\n      - Integration examples\n\n   2. Invoke api-tester skill\n      - Validate documentation accuracy\n      - Test all documented endpoints\n      - Verify examples work correctly\n      - Check authentication flows\n\n   3. Invoke code-reviewer skill\n      - Documentation completeness review\n      - Accuracy verification\n      - Best practices compliance\n   ```\n\n   **D. For Testing and Quality Assurance Tasks**\n\n   If the work focuses on testing, quality improvements, or bug fixes:\n\n   ```\n   1. Invoke api-tester skill\n      - Write comprehensive unit tests\n      - Create integration test suites\n      - API contract testing\n      - Performance benchmarking\n      - Security testing\n      - Load testing\n\n   2. Invoke code-reviewer skill\n      - Test quality review\n      - Coverage analysis\n      - Edge case verification\n      - Security audit\n   ```\n\n   **E. For Other Backend Tasks**\n\n   If the work doesn't fit the above patterns (refactoring, configuration, DevOps, etc.), fall back to manual execution with the task loop below.\n\n2. **Task Execution Loop** (Fallback for non-standard backend tasks)\n\n   ```\n   while (tasks remain):\n     - Select next task (priority + dependencies)\n     - Mark as in_progress\n     - Execute task completely\n     - Validate completion\n     - Mark as completed\n     - Update progress\n   ```\n\n3. **Quality Assurance**\n\n   - Run tests after each task (lint, typecheck, unit tests, integration tests)\n   - Execute lint command: `npm run lint` or `yarn lint`\n   - Execute typecheck: `npm run type-check` or `tsc --noEmit`\n   - Run unit tests: `npm test` or `yarn test`\n   - Run integration tests if available\n   - Verify no regressions\n   - Check against acceptance criteria\n   - Document any issues found\n   - Ensure all MCP-based validations passed (if skills were used)\n\n4. **Progress Tracking**\n   - Regularly update task status\n   - Note any blockers or delays\n   - Create new tasks for discoveries\n   - Maintain work visibility\n   - Document skill execution results\n\n### Phase 4: Completion and Submission\n\n1. **Final Validation**\n\n   - Verify all tasks completed\n   - Run comprehensive test suite\n   - Execute final lint: `npm run lint`\n   - Execute final typecheck: `tsc --noEmit`\n   - Run all tests: `npm test`\n   - Check all deliverables present (APIs, migrations, tests, docs)\n   - Ensure documentation updated (OpenAPI specs, Postman collections)\n   - Verify database migrations are reversible\n   - Test API endpoints with Postman MCP\n\n2. **Prepare for Submission**\n\n   - Stage and commit all changes\n   - Write descriptive commit messages\n   - Push feature branch to remote\n   - Create detailed pull request with:\n     - API changes summary\n     - Database schema changes\n     - Breaking changes (if any)\n     - Migration instructions\n     - Testing instructions\n\n3. **Create Pull Request**\n   ```bash\n   git push -u origin feature-branch-name\n   gh pr create --title \"feat: [API/Database/Feature Description]\" --body \"[Detailed description with API changes, database impacts, testing notes]\"\n   ```\n\n## Backend-Specific Guidelines\n\n### API Development Best Practices\n\n- Follow REST principles (proper HTTP methods, status codes, resource naming)\n- Use OpenAPI 3.0 for API specifications\n- Implement proper error handling (RFC 7807 Problem Details)\n- Add request validation with class-validator\n- Implement authentication/authorization\n- Use DTOs for request/response serialization\n- Add API versioning strategy\n\n### Database Development Best Practices\n\n- Always create reversible migrations\n- Use transactions for multi-step operations\n- Add proper indexes for query performance\n- Follow naming conventions for entities and columns\n- Include data seeding for development\n- Test migrations on sample data\n- Document schema changes\n\n### Testing Best Practices\n\n- Aim for >80% test coverage\n- Write unit tests for services\n- Create integration tests for API endpoints\n- Use Supertest for HTTP testing\n- Test error scenarios and edge cases\n- Validate authentication/authorization\n- Performance test critical endpoints\n- Use Postman MCP for automated API testing\n\n### Documentation Best Practices\n\n- Generate OpenAPI specs from code decorators\n- Keep Postman collections up to date\n- Document authentication requirements\n- Include request/response examples\n- Maintain API changelog\n- Add inline code comments for complex logic\n- Update README with setup instructions\n\n## MCP Server Integration\n\nThis command leverages bundled MCP servers:\n\n- **Postman MCP**: Automated API testing, collection management, contract validation\n- **Context7 MCP**: Access to NestJS, Express, TypeORM documentation and best practices\n- **Serena MCP**: Analyze existing codebase patterns for consistency\n\nSkills automatically use these MCP servers when invoked, providing comprehensive backend development workflow automation.\n"
              }
            ],
            "skills": []
          }
        ]
      }
    }
  ]
}