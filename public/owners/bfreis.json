{
  "owner": {
    "id": "bfreis",
    "display_name": "Bruno Franca dos Reis",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/261623?v=4",
    "url": "https://github.com/bfreis",
    "bio": "Cloud expert",
    "stats": {
      "total_repos": 1,
      "total_plugins": 2,
      "total_commands": 3,
      "total_skills": 3,
      "total_stars": 1,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "bfreis/claude-mart",
      "url": "https://github.com/bfreis/claude-mart",
      "description": null,
      "homepage": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2025-12-09T06:55:01Z",
        "created_at": "2025-11-12T23:11:22Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 785
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 36
        },
        {
          "path": "CLAUDE.md",
          "type": "blob",
          "size": 536
        },
        {
          "path": "LICENSE",
          "type": "blob",
          "size": 1078
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 3930
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plan-exec",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plan-exec/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plan-exec/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 258
        },
        {
          "path": "plugins/plan-exec/README.md",
          "type": "blob",
          "size": 11279
        },
        {
          "path": "plugins/plan-exec/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plan-exec/agents/plan-worker.md",
          "type": "blob",
          "size": 5872
        },
        {
          "path": "plugins/plan-exec/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plan-exec/commands/plan-status.md",
          "type": "blob",
          "size": 4851
        },
        {
          "path": "plugins/plan-exec/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plan-exec/skills/plan-executor",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plan-exec/skills/plan-executor/SKILL.md",
          "type": "blob",
          "size": 12659
        },
        {
          "path": "plugins/plan-exec/skills/plan-executor/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plan-exec/skills/plan-executor/scripts/plan-tool",
          "type": "blob",
          "size": 24601
        },
        {
          "path": "plugins/plan-exec/skills/plan-generator",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plan-exec/skills/plan-generator/SKILL.md",
          "type": "blob",
          "size": 6670
        },
        {
          "path": "plugins/transcript-analyzer",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/transcript-analyzer/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/transcript-analyzer/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 260
        },
        {
          "path": "plugins/transcript-analyzer/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/transcript-analyzer/commands/transcript-bloat.md",
          "type": "blob",
          "size": 891
        },
        {
          "path": "plugins/transcript-analyzer/commands/transcript-summary.md",
          "type": "blob",
          "size": 671
        },
        {
          "path": "plugins/transcript-analyzer/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/transcript-analyzer/skills/transcript-analyzer",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/transcript-analyzer/skills/transcript-analyzer/SKILL.md",
          "type": "blob",
          "size": 4417
        },
        {
          "path": "plugins/transcript-analyzer/skills/transcript-analyzer/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/transcript-analyzer/skills/transcript-analyzer/scripts/transcript-tool",
          "type": "blob",
          "size": 6303
        },
        {
          "path": "scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "scripts/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "scripts/hooks/pre-commit",
          "type": "blob",
          "size": 138
        },
        {
          "path": "scripts/setup-hooks.sh",
          "type": "blob",
          "size": 332
        },
        {
          "path": "scripts/validate-plugins.sh",
          "type": "blob",
          "size": 5068
        }
      ],
      "marketplace": {
        "name": "claude-mart",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "Bruno Franca dos Reis",
          "email": "bfreis@gmail.com"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "plan-exec",
            "description": "Create and execute self-updating plan files for complex projects with phased breakdown and autonomous execution tracking. Generates feature-specific plans (e.g., PLAN-auth.md, PLAN-api.md) that enable autonomous work across sessions.",
            "source": "./plugins/plan-exec",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add bfreis/claude-mart",
              "/plugin install plan-exec@claude-mart"
            ],
            "signals": {
              "stars": 1,
              "forks": 0,
              "pushed_at": "2025-12-09T06:55:01Z",
              "created_at": "2025-11-12T23:11:22Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/plan-status",
                "description": null,
                "path": "plugins/plan-exec/commands/plan-status.md",
                "frontmatter": null,
                "content": "# /plan-status - Display Plan Progress\n\nDisplay the current status and progress of a plan file by reading its JSON state block.\n\n## Usage\n\n```\n/plan-status [plan-file]\n```\n\nIf no file is specified, look for common plan file patterns in the current directory:\n- `PLAN.md`\n- `PLAN-*.md`\n\n## Instructions\n\n1. **Locate the plan file**:\n   - If a file argument is provided, use that file\n   - Otherwise, search for `PLAN.md` or `PLAN-*.md` in the current directory\n   - If multiple plan files exist and none specified, list them and ask user to specify\n\n2. **Extract the JSON state block**:\n   The JSON block is wrapped in HTML comment markers:\n   - Start marker: `<!--PLAN-STATE`\n   - End marker: `PLAN-STATE-->`\n\n   Extract the JSON between these markers using:\n   ```bash\n   sed -n '/<!--PLAN-STATE/,/PLAN-STATE-->/p' <file> | sed '1d;$d'\n   ```\n\n3. **Parse the JSON and calculate progress**:\n   Use `jq` to extract:\n   ```bash\n   # Get execution settings\n   jq -r '.execution.mode' <json>\n   jq -r '.execution.auto_continue' <json>\n   jq -r '.execution.commit_after_phase' <json>\n   jq -r '.execution.include_plan_in_commit' <json>\n\n   # Get current phase\n   jq -r '.current_phase' <json>\n\n   # Count steps by status across all phases\n   jq '[.phases[].steps[]] | group_by(.status) | map({(.[0].status): length}) | add' <json>\n\n   # Get per-phase breakdown\n   jq '.phases[] | {id, name, total: (.steps | length), completed: ([.steps[] | select(.status == \"completed\")] | length)}' <json>\n\n   # Find in-progress steps\n   jq '[.phases[].steps[] | select(.status == \"in_progress\")] | .[0].id' <json>\n\n   # Find blocked steps with reasons\n   jq '[.phases[].steps[] | select(.status == \"blocked\") | {id, reason: .blocker}]' <json>\n   ```\n\n4. **Display formatted output**:\n\n## Output Format\n\n```\nPlan Status: PLAN-auth.md\n\nCurrent Phase: Phase 1 - JWT Token Generation (in progress)\nMode: worker | Auto-continue: yes | Commits: yes (excluding PLAN)\n\nOverall Progress: [========--------] 8/20 (40%)\n\nPhase 0: Setup [completed] (4/4)\nPhase 1: JWT Token Generation (3/5)\n  - In progress: Step 1.3\nPhase 2: Refresh Tokens (0/4)\nPhase 3: Middleware (0/3)\nPhase 4: Testing (0/4)\n\nBlocked: None\n```\n\n### Format Details\n\n**Header**: Show the plan filename\n\n**Current Phase**:\n- If `current_phase >= 0`: Show \"Phase N - Name (in progress)\"\n- If `current_phase == -1`: Show \"COMPLETE - All phases finished\"\n\n**Execution Settings**:\n- Mode: \"direct\" or \"worker\"\n- Auto-continue: \"yes\" or \"no\"\n- Commits: \"no\" if `commit_after_phase` is false, otherwise:\n  - \"yes (including PLAN)\" if `include_plan_in_commit` is true\n  - \"yes (excluding PLAN)\" if `include_plan_in_commit` is false\n\n**Progress Bar**:\n- Calculate: completed_steps / total_steps\n- Use 20-character bar with `=` for filled, `-` for empty\n- Show count and percentage: \"8/20 (40%)\"\n\n**Per-Phase Breakdown**:\n- For each phase, show: \"Phase N: Name (completed/total)\"\n- Mark completed phases with `[completed]`\n- For in-progress phases, indent and show any active step: \"- In progress: Step N.X\"\n\n**Blocked Steps**:\n- If no blocked steps: \"Blocked: None\"\n- If blocked steps exist, list each with reason:\n  ```\n  Blocked:\n  - Step 2.3: Redis connection not configured\n  - Step 3.1: Waiting for API design approval\n  ```\n\n## Edge Cases\n\n1. **No JSON state block found**:\n   - Report: \"No JSON state block found in [file]. This plan may use the legacy checkbox format or needs initialization with `plan-update init`.\"\n\n2. **Invalid JSON**:\n   - Report: \"Invalid JSON in state block. The plan file may be corrupted.\"\n\n3. **All phases complete** (`current_phase == -1`):\n   - Show progress as 100% complete\n   - Current Phase shows \"COMPLETE\"\n\n4. **No plan files found**:\n   - Report: \"No plan files found. Create one with the plan-generator skill or specify a file path.\"\n\n5. **Empty phases array**:\n   - Report: \"Plan has no phases defined.\"\n\n## Example Complete Output\n\nFor a plan with 5 phases, currently in phase 2, with one blocked step:\n\n```\nPlan Status: PLAN-auth.md\n\nCurrent Phase: Phase 2 - Refresh Tokens (in progress)\nMode: worker | Auto-continue: yes | Commits: yes (excluding PLAN)\n\nOverall Progress: [==========------] 10/20 (50%)\n\nPhase 0: Setup [completed] (4/4)\nPhase 1: JWT Token Generation [completed] (5/5)\nPhase 2: Refresh Tokens (1/4)\n  - In progress: Step 2.2\nPhase 3: Middleware (0/4)\nPhase 4: Testing (0/3)\n\nBlocked:\n- Step 2.3: Redis not configured in project\n```\n\nFor a fully complete plan:\n\n```\nPlan Status: PLAN-auth.md\n\nCurrent Phase: COMPLETE - All phases finished\nMode: direct | Auto-continue: no | Commits: no\n\nOverall Progress: [====================] 20/20 (100%)\n\nPhase 0: Setup [completed] (4/4)\nPhase 1: JWT Token Generation [completed] (5/5)\nPhase 2: Refresh Tokens [completed] (4/4)\nPhase 3: Middleware [completed] (4/4)\nPhase 4: Testing [completed] (3/3)\n\nBlocked: None\n```\n"
              }
            ],
            "skills": [
              {
                "name": "plan-executor",
                "description": "Execute and coordinate work on PLAN files with phased breakdown. Tracks progress via JSON state, coordinates worker sub-agents in worker mode, and manages commits. Use when user references a PLAN file or asks to continue/execute a plan.",
                "path": "plugins/plan-exec/skills/plan-executor/SKILL.md",
                "frontmatter": {
                  "name": "plan-executor",
                  "description": "Execute and coordinate work on PLAN files with phased breakdown. Tracks progress via JSON state, coordinates worker sub-agents in worker mode, and manages commits. Use when user references a PLAN file or asks to continue/execute a plan."
                },
                "content": "# Plan Executor Skill\n\nThis skill executes and coordinates work on existing PLAN files. It handles progress tracking, worker coordination (in worker mode), commit management, and phase advancement.\n\n## When to Use This Skill\n\nUse this skill when:\n- User references an existing PLAN file (e.g., `@PLAN-auth.md`)\n- User asks to \"continue the plan\" or \"execute the plan\"\n- User asks to \"work on\" or \"resume\" a project with a PLAN file\n- User wants to see plan status or progress\n\nDo NOT use this skill when:\n- User wants to CREATE a new plan (use `plan-generator` skill instead)\n- User wants to modify the plan structure (add/remove phases)\n\n## CRITICAL RULES\n\n**These rules MUST be followed at all times:**\n\n### 1. ALWAYS Respect Execution Mode\n\nThe execution mode is defined in the JSON state block (`execution.mode`). **You MUST follow it:**\n\n- **If `mode` is `\"worker\"`**: You are a COORDINATOR. Do NOT execute steps directly. Launch `plan-worker` sub-agents to do the work. NEVER perform implementation work yourself in worker mode.\n- **If `mode` is `\"direct\"`**: Execute steps directly in the main session.\n\n**On resume**: Re-read the JSON state and respect the mode. Do not switch modes.\n\n### 2. ALWAYS Update State Immediately\n\nState updates MUST happen in real-time, not batched:\n\n- **BEFORE starting ANY step**: Run `scripts/plan-tool start <file> <step-id>`\n- **IMMEDIATELY after completing a step**: Run `scripts/plan-tool complete <file> <step-id> --summary \"...\"`\n- **Never skip state updates** - if the session is interrupted, state should reflect reality\n\nThis ensures that if execution is interrupted, the plan can resume from the correct point.\n\n---\n\n## Understanding Plan State\n\nPLAN files contain a JSON state block at the end wrapped in HTML comment markers:\n\n```\n<!--PLAN-STATE\n{\n  \"schema_version\": \"1.0\",\n  \"execution\": {\n    \"mode\": \"direct\",           // or \"worker\"\n    \"auto_continue\": false,     // auto-advance to next phase when current completes\n    \"commit_after_phase\": false,\n    \"include_plan_in_commit\": true\n  },\n  \"current_phase\": 0,           // -1 means all complete\n  \"phases\": [\n    {\n      \"id\": 0,\n      \"name\": \"Setup\",\n      \"steps\": [\n        { \"id\": \"0.1\", \"status\": \"pending\" },\n        { \"id\": \"0.2\", \"status\": \"completed\", \"summary\": \"...\" }\n      ]\n    }\n  ]\n}\nPLAN-STATE-->\n```\n\n### Step Status Values\n\n- `pending` - Not started\n- `in_progress` - Currently being worked on (only ONE at a time)\n- `completed` - Finished successfully\n- `blocked` - Cannot proceed (includes `blocker` field with reason)\n\n### Initializing Plan State\n\nWhen a PLAN file does not have a JSON state block, initialize it before starting execution:\n\n```bash\nscripts/plan-tool init <file> [--mode direct|worker] [--auto-continue] [--commit] [--no-plan-in-commit]\n```\n\nThe `init` command parses the markdown headings to discover phases and steps, then generates the JSON state block at the end of the file.\n\n**Options:**\n- `--mode direct|worker`: Execution mode (default: direct)\n- `--auto-continue`: Enable auto-advancement between phases\n- `--commit`: Enable commits after each phase\n- `--no-plan-in-commit`: Exclude PLAN file from commits\n\nExample:\n```bash\nscripts/plan-tool init PLAN-auth.md --mode worker --auto-continue --commit --no-plan-in-commit\n```\n\n### Reading Plan State\n\nWhen starting execution:\n1. Read the entire PLAN file\n2. Check if JSON state block exists (look for `<!--PLAN-STATE` marker)\n3. **If no JSON state block exists**: Initialize it using `scripts/plan-tool init` with options based on the execution preferences in the Instructions section\n4. Parse the JSON state block to understand:\n   - Which execution mode is active (`direct` or `worker`)\n   - Which phase is current (`current_phase`)\n   - Which steps are `pending`, `in_progress`, `completed`, or `blocked`\n5. Check for any `blocked` steps that need resolution\n6. Identify the next actionable step(s)\n\n## Progress Tracking Commands\n\nUse the `scripts/plan-tool` script (relative to this skill directory) to manage JSON state updates.\n\n### Starting a Step\n\nBefore beginning work on a step:\n\n```bash\nscripts/plan-tool start <file> <step-id>\n```\n\nExample:\n```bash\nscripts/plan-tool start PLAN-auth.md 1.2\n```\n\n**Note:** Only ONE step can be `in_progress` at a time. Starting a new step automatically resets any previously in-progress step to `pending`.\n\n### Completing a Step\n\nAfter successfully finishing a step:\n\n```bash\nscripts/plan-tool complete <file> <step-id> [--summary \"...\"]\n```\n\nExample:\n```bash\nscripts/plan-tool complete PLAN-auth.md 1.2 --summary \"Added JWT validation middleware with RS256 support\"\n```\n\n**Auto-advancement:** If all steps in the current phase are completed and `auto_continue` is enabled, the phase automatically advances.\n\n### Blocking a Step\n\nWhen a step cannot proceed due to an issue:\n\n```bash\nscripts/plan-tool block <file> <step-id> --reason \"...\"\n```\n\nExample:\n```bash\nscripts/plan-tool block PLAN-auth.md 1.3 --reason \"Redis not configured - refresh tokens need persistent storage\"\n```\n\n### Unblocking a Step\n\nTo clear a blocked status after resolving the issue:\n\n```bash\nscripts/plan-tool unblock <file> <step-id>\n```\n\n### Advancing Phase\n\nTo manually advance to the next phase:\n\n```bash\nscripts/plan-tool next-phase <file> [--force]\n```\n\nUse `--force` to advance even if some steps are incomplete or blocked (not recommended).\n\n## Direct Mode Execution\n\nIn direct mode, execute steps directly in the main Claude Code session.\n\n### Execution Flow\n\n1. **Identify next step**: Find the first `pending` step in the current phase\n2. **Mark as in-progress**: Run `scripts/plan-tool start`\n3. **Execute the step**: Perform all work described in the step\n4. **Document completion**: Add notes under the step heading in markdown:\n   ```markdown\n   ### Step 1.2: Implement user validation\n   Original step description...\n   - **Completed:** Added email regex validation and password strength check\n   - **Decision:** Used zxcvbn library for password scoring\n   ```\n5. **Update state**: Run `scripts/plan-tool complete` with a brief summary\n6. **Repeat**: Continue with next pending step\n\n### Stopping Conditions\n\nOnly stop when:\n- An entire phase is complete AND `auto_continue` is disabled (ask user if they want to continue)\n- An actual error or blocker occurs\n- User explicitly requests to pause\n- All phases are complete\n\n**If `auto_continue` is enabled:** Do NOT stop between phases. Immediately proceed to the next phase.\n\n### Adding Implementation Notes\n\nAfter completing steps, add detailed notes to the **Notes & Decisions** section:\n\n```markdown\n## Notes & Decisions\n\n### Phase 1: Core Implementation (Completed)\n- Implemented JWT generation using RS256 algorithm\n- Chose 15-minute expiry for access tokens based on security best practices\n- Added refresh token rotation to prevent token reuse\n```\n\n## Worker Mode Execution\n\nIn worker mode, delegate step execution to `plan-worker` sub-agents. The main session acts as a coordinator.\n\n### Coordinator Protocol\n\n#### 1. Identify Next Work Batch\n\nParse the JSON state block to find steps with `\"status\": \"pending\"` in the current phase. Determine batch size by considering:\n\n- **Step dependencies**: If step N+1 needs output from step N, batch them together\n- **Complexity**: Steps involving multiple files, tests, or debugging -> smaller batches (1-2 steps)\n- **Independence**: Simple, independent steps -> can batch more (3-5 steps)\n- **Default**: 2-4 related steps per worker, or an entire phase if steps are simple\n\n#### 2. Prepare Worker Context\n\nGather the information the worker needs:\n\n- **Project goal**: 1-2 sentences from Project Overview\n- **Specific steps**: Full descriptions from the plan\n- **Relevant files**: List of files the worker will need to read or modify\n- **Success criteria**: Derived from step descriptions\n- **Inline examples**: Any relevant examples from the plan\n\n#### 3. Mark Steps and Launch Worker\n\n**BEFORE launching the worker**, mark all assigned steps as in-progress:\n\n```bash\nscripts/plan-tool start <file> <step-id>\n```\n\nRun this for EACH step being assigned to the worker.\n\nThen launch the `plan-worker` sub-agent with this prompt structure:\n\n```\n**Project:** [Project name from plan]\n\n**Goal:** [Brief goal from Project Overview section]\n\n**Your Assignment:**\nExecute the following steps from Phase N:\n- Step N.X: [full description]\n- Step N.Y: [full description]\n- Step N.Z: [full description]\n\n**Context Files to Read:**\n- [path/to/file1] - [why it's relevant]\n- [path/to/file2] - [why it's relevant]\n\n**Success Criteria:**\n- [Specific criterion derived from steps]\n- [Another criterion]\n\n**Constraints:**\n- [Any project-specific constraints]\n- [Technology requirements]\n\nWhen done, provide your structured summary.\n```\n\n#### 4. Process Worker Results\n\nWhen the worker returns its summary:\n\n**For COMPLETED steps:**\n```bash\nscripts/plan-tool complete <file> <step-id> --summary \"Summary from worker\"\n```\n\nAdd inline notes under the step heading:\n```markdown\n### Step N.X: [description]\nOriginal step description...\n- **Completed:** [1-2 sentence summary of what was done]\n- **Decision:** [any notable decision, if applicable]\n```\n\n**For BLOCKED steps:**\n```bash\nscripts/plan-tool block <file> <step-id> --reason \"Blocker description from worker\"\n```\n\nAdd blocker details under the step heading:\n```markdown\n### Step N.X: [description]\nOriginal step description...\n- **Blocked:** [description of the blocker]\n```\n\nThen report to user and ask how to proceed.\n\n**Update Notes & Decisions section** with worker findings for the appropriate phase.\n\n#### 5. Continue or Pause\n\n- If more pending steps remain in the phase, launch another worker\n- If phase is complete:\n  - Create git commit if `commit_after_phase` is enabled\n  - **If `auto_continue` is enabled**: Immediately proceed to the next phase\n  - **If `auto_continue` is disabled**: Ask user if they want to continue\n- If all phases are complete, report completion to user\n- If blocker hit, wait for user guidance\n\n## Phase Completion Handling\n\n### Creating Commits\n\nIf `commit_after_phase` is enabled:\n\n1. Stage all modified files from the phase\n2. Check `include_plan_in_commit` setting:\n   - If `true`: Include the PLAN file in the commit\n   - If `false`: Keep PLAN file unstaged\n3. Create commit with message describing the phase work\n\nExample commit message:\n```\nfeat(auth): Phase 1 - Implement JWT token generation\n\n- Added generateToken() function with RS256 signing\n- Created token validation middleware\n- Implemented refresh token rotation\n```\n\n### Advancing to Next Phase\n\nAfter a phase completes:\n\n1. If `auto_continue` is enabled:\n   - Log phase completion\n   - Immediately begin work on next phase\n   - Continue until all phases complete or a blocker occurs\n\n2. If `auto_continue` is disabled:\n   - Report phase completion to user\n   - Ask: \"Phase N is complete. Would you like to continue to Phase N+1?\"\n   - Wait for user confirmation before proceeding\n\n### All Phases Complete\n\nWhen `current_phase` becomes `-1`:\n1. Report completion to user\n2. Review the Completion Checklist in the PLAN file\n3. Verify all items are satisfied\n4. Suggest any final cleanup or documentation tasks\n\n## Error Handling\n\n\n### Handling Blocked Steps\n\nWhen a step is blocked:\n\n1. Run `scripts/plan-tool block` to mark it in the JSON state\n2. Stop launching workers for steps that depend on the blocked step\n3. Report to user with:\n   - The step that is blocked\n   - The reason for the blocker\n   - Options to resolve:\n     - Add a prerequisite step to fix the blocker\n     - Skip the step (unblock then complete with note)\n     - Provide guidance for another attempt\n\n### Partial Completion\n\nWhen a worker completes some but not all assigned steps:\n\n1. Run `scripts/plan-tool complete` for each finished step\n2. For incomplete steps:\n   - Leave as `pending` if work can continue\n   - Mark as `blocked` if there's an issue\n3. Decide whether to:\n   - Launch a new worker for remaining steps\n   - Report to user if there's an issue\n\n### Invalid State Recovery\n\nIf the JSON state becomes corrupted:\n\n1. Attempt to parse and identify the issue\n2. If recoverable, fix the JSON and continue\n3. If not recoverable, report to user:\n   - \"The plan state appears corrupted. Would you like me to re-initialize it from the markdown headings?\"\n   - Use `scripts/plan-tool init` to rebuild state if user confirms"
              },
              {
                "name": "plan-generator",
                "description": "Create self-updating plan files for complex projects with phased breakdown and autonomous execution tracking. Generates feature-specific plans (e.g., PLAN-auth.md, PLAN-api.md) that enable autonomous work across sessions. Use when user wants comprehensive project planning with phases and detailed steps.",
                "path": "plugins/plan-exec/skills/plan-generator/SKILL.md",
                "frontmatter": {
                  "name": "plan-generator",
                  "description": "Create self-updating plan files for complex projects with phased breakdown and autonomous execution tracking. Generates feature-specific plans (e.g., PLAN-auth.md, PLAN-api.md) that enable autonomous work across sessions. Use when user wants comprehensive project planning with phases and detailed steps."
                },
                "content": "# Plan Generator Skill\n\nThis skill creates standalone plan files for complex projects that enable autonomous, phased execution with real-time progress tracking.\n\n## When to Use This Skill\n\nUse this skill when:\n- User asks to create a project plan or PLAN file\n- User wants to break down a complex project into phases and steps\n- User needs a self-contained planning document for large initiatives\n\nDo NOT use this skill when:\n- User wants to EXECUTE an existing plan (use `plan-executor` skill instead)\n- User references an existing PLAN file to continue work\n\n## Plan File Naming\n\nPlans are feature/project-specific and can be named flexibly:\n- Single feature: `PLAN-{feature}.md` (e.g., `PLAN-auth.md`, `PLAN-api.md`)\n- Main project plan: `PLAN.md`\n- Multiple plans can coexist in one repository for different features\n\n**Always ask the user what filename they want** or suggest based on the project/feature name.\n\n## Plan File Structure\n\nWhen creating a plan file, follow this exact structure:\n\n### 1. Instructions for Claude Code (TOP OF FILE)\n\nThis section MUST be first. Keep it concise (~15 lines):\n\n```markdown\n## Instructions for Claude Code\n\nWhen working on this plan:\n1. **Use the `plan-executor` skill** to execute this plan\n2. **Work autonomously** through phases without stopping for approval (unless blocked)\n3. **Document findings** in the Notes & Decisions section\n\n**Execution Mode:** [direct|worker]\n**Auto-continue:** [yes|no]\n**Commit after phase:** [yes|no] (include PLAN file: [yes|no])\n```\n\n### 2. Current Phase Indicator\n\nSimple status at the top:\n- `**Current Phase:** Phase 1: [Phase Name]`\n- `**Current Phase:** COMPLETE`\n\n### 3. Project Overview\n\n- Clear description of the end goal\n- Context about what the project achieves\n- Key requirements (bulleted list)\n- Any constraints or dependencies\n\n### 4. Phase Breakdown\n\nEach phase should include:\n\n```markdown\n## Phase N: [Phase Name]\n\nBrief description of what this phase accomplishes.\n\n### Step N.1: [Step title]\nDetailed, actionable step description with context and requirements.\n\n### Step N.2: [Another step title]\nDescription for this step...\n```\n\n**Step Format Notes:**\n- Steps are markdown headings (`### Step N.X: Title`), NOT checkbox list items\n- Each step ID follows the format `{phase}.{step}` (e.g., `0.1`, `1.2`, `2.3`)\n- Include inline examples within phases when helpful (e.g., config structures, code snippets)\n\n### 5. Notes & Decisions Section\n\nMajor section after all phases: `## Notes & Decisions`\n\nTemplate structure for each phase:\n```markdown\n### Phase N: [Phase Name] (Status)\n- Implementation details and approach taken\n- Why decisions were made\n- Deviations from original plan with explanations\n- Technical details for future reference\n```\n\n### 6. Completion Checklist\n\nFinal section with overall project readiness criteria:\n```markdown\n## Completion Checklist\n\nBefore marking this project complete:\n- [ ] All phases marked complete\n- [ ] All tests passing\n- [ ] Build successful\n- [ ] Documentation complete\n```\n\n## Generating the Plan File\n\nWhen this skill is invoked:\n\n1. **Determine filename**: Ask user for desired filename or suggest based on project (e.g., \"I'll create PLAN-auth.md for this authentication feature\")\n\n2. **Ask about preferences**:\n\n   a) **Execution mode**:\n      - **Direct mode**: Execute steps in the main session (simpler, good for small plans)\n      - **Worker mode**: Delegate to sub-agents (recommended for large/complex plans)\n\n   b) **Auto-continue preference**:\n      - **Yes**: Automatically start the next phase without asking\n      - **No**: Ask for confirmation before each new phase (default)\n\n   c) **Commit preferences**:\n      - **Yes, include PLAN file**: Commit code changes AND updated PLAN file together\n      - **Yes, exclude PLAN file**: Commit only code changes\n      - **No**: User will handle commits manually\n\n3. **Gather project details** from the user if not already provided\n\n4. **Break down the project**:\n   - Identify logical phases (typically 3-8 phases, including Phase 0 for setup if needed)\n   - For each phase, identify concrete steps (3-10 steps per phase)\n   - Consider including inline examples (configs, schemas) in relevant phases\n\n5. **Create the plan file** with:\n   - Instructions section at the TOP (referencing `plan-executor` skill)\n   - Current Phase indicator with execution preferences\n   - Complete project overview\n   - All phases with detailed, actionable steps\n   - Empty Notes & Decisions section\n   - Completion checklist\n   - (JSON state will be initialized automatically by plan-executor on first run)\n\n6. **Make it standalone**: The file should contain enough context that referencing it in a fresh session gives Claude complete understanding of the project\n\n## Key Principles\n\n- **Instructions first**: Always put Claude instructions at the top of the file\n- **Reference plan-executor**: The instructions section should tell Claude to use the `plan-executor` skill\n- **Detailed steps**: Each step should be actionable with clear requirements\n- **Include examples**: Inline examples (configs, schemas, code snippets) make steps clearer\n- **Self-referential**: Plan should reference \"this file\" not a hardcoded filename\n\n## Example Usage\n\n### Example 1: Single Feature Plan\n\nUser: \"Create a plan for building a JWT authentication system with refresh tokens\"\n\nClaude should:\n1. Suggest: \"I'll create `PLAN-auth.md` for this authentication feature\"\n2. Ask about execution mode, auto-continue, and commit preferences\n3. Break down into phases like:\n   - Phase 0: Dependencies and project structure\n   - Phase 1: JWT token generation and validation\n   - Phase 2: Refresh token implementation\n   - Phase 3: Middleware integration\n   - Phase 4: Testing\n4. Create detailed steps for each phase with inline examples (e.g., JWT payload structure)\n5. Generate PLAN-auth.md with all structure including the JSON state block\n6. Inform user: \"I've created PLAN-auth.md. Reference it with `@PLAN-auth.md` to begin execution\"\n\n### Example 2: Main Project Plan\n\nUser: \"Create a plan for building a CLI tool with subcommands and configuration support\"\n\nClaude should:\n1. Suggest: \"I'll create `PLAN.md` for this project\"\n2. Follow same process as Example 1\n3. User can later create additional feature-specific plans alongside (e.g., PLAN-config.md)"
              }
            ]
          },
          {
            "name": "transcript-analyzer",
            "description": "Debug Claude Code plugins by analyzing session transcripts. Includes pre-built jq recipes, context bloat detection, tool usage tracing, and comprehensive documentation of transcript structure.",
            "source": "./plugins/transcript-analyzer",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add bfreis/claude-mart",
              "/plugin install transcript-analyzer@claude-mart"
            ],
            "signals": {
              "stars": 1,
              "forks": 0,
              "pushed_at": "2025-12-09T06:55:01Z",
              "created_at": "2025-11-12T23:11:22Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/transcript-bloat",
                "description": null,
                "path": "plugins/transcript-analyzer/commands/transcript-bloat.md",
                "frontmatter": null,
                "content": "# /transcript-bloat\n\nIdentifies the largest tool results in a transcript to find sources of context bloat.\n\n## Usage\n\n```\n/transcript-bloat <path-to-transcript.jsonl> [count]\n```\n\n- `count`: Number of results to show (default: 10)\n\n## Implementation\n\nWhen the user runs this command:\n\n1. Run the transcript-tool bloat command:\n```bash\n\"$(dirname \"$(dirname \"$0\")\")/skills/transcript-analyzer/scripts/transcript-tool\" bloat \"<FILE_PATH>\" <COUNT>\n```\n\n2. Present the results showing:\n   - Size in characters\n   - Tool use ID\n   - Tool name\n\n3. If specific tool results are very large, suggest investigating:\n   - Are large files being read unnecessarily?\n   - Are agent outputs too verbose?\n   - Could glob/grep be more targeted?\n\nIf no file path is provided, explain how to find transcript files:\n- Location: `~/.claude/projects/-PATH-TO-PROJECT/*.jsonl`\n- Path format: slashes become dashes\n"
              },
              {
                "name": "/transcript-summary",
                "description": null,
                "path": "plugins/transcript-analyzer/commands/transcript-summary.md",
                "frontmatter": null,
                "content": "# /transcript-summary\n\nDisplays a quick summary of a Claude Code session transcript.\n\n## Usage\n\n```\n/transcript-summary <path-to-transcript.jsonl>\n```\n\n## Implementation\n\nWhen the user runs this command with a transcript file path:\n\n1. Run the transcript-tool summary command:\n```bash\n\"$(dirname \"$(dirname \"$0\")\")/skills/transcript-analyzer/scripts/transcript-tool\" summary \"<FILE_PATH>\"\n```\n\n2. Present the output to the user in a readable format.\n\nIf no file path is provided, explain how to find transcript files:\n- Location: `~/.claude/projects/-PATH-TO-PROJECT/*.jsonl`\n- Path format: slashes become dashes (e.g., `/Users/foo/myproject` â†’ `-Users-foo-myproject`)\n"
              }
            ],
            "skills": [
              {
                "name": "transcript-analyzer",
                "description": "Analyze Claude Code session transcripts to debug plugins, understand context usage, and trace execution flow",
                "path": "plugins/transcript-analyzer/skills/transcript-analyzer/SKILL.md",
                "frontmatter": {
                  "name": "transcript-analyzer",
                  "description": "Analyze Claude Code session transcripts to debug plugins, understand context usage, and trace execution flow"
                },
                "content": "# Transcript Analyzer Skill\n\nUse this skill when you need to analyze Claude Code session transcripts for:\n- Debugging plugin behavior\n- Understanding context/token usage patterns\n- Tracing tool execution flow\n- Finding sources of context bloat\n- Investigating errors or unexpected behavior\n\n## Transcript Location\n\nClaude Code stores session transcripts at:\n```\n~/.claude/projects/-PATH-TO-PROJECT/*.jsonl\n```\n\nThe path uses dashes instead of slashes. For example:\n- Project: `/Users/bfreis/dev/myproject`\n- Transcripts: `~/.claude/projects/-Users-bfreis-dev-myproject/*.jsonl`\n\n## Transcript Structure\n\nTranscripts use **JSONL format** (one JSON object per line).\n\n### Record Types\n\n| Type | Description |\n|------|-------------|\n| `summary` | Session metadata |\n| `file-history-snapshot` | File change tracking |\n| `user` | User messages (includes tool results) |\n| `assistant` | Assistant messages (includes tool calls) |\n\n### Message Structure\n\n```json\n{\n  \"type\": \"user\" | \"assistant\",\n  \"uuid\": \"message-uuid\",\n  \"parentUuid\": \"parent-message-uuid\",\n  \"sessionId\": \"session-uuid\",\n  \"isSidechain\": false,\n  \"timestamp\": \"2025-12-06T...\",\n  \"message\": {\n    \"role\": \"user\" | \"assistant\",\n    \"content\": [...],\n    \"usage\": { \"input_tokens\": N, \"output_tokens\": N }\n  }\n}\n```\n\n### Content Block Types\n\n**In assistant messages:**\n- `text` - Regular text response\n- `tool_use` - Tool invocation with `.id`, `.name`, `.input`\n- `thinking` - Extended thinking blocks\n\n**In user messages:**\n- `text` - User input\n- `tool_result` - Tool output with `.tool_use_id`, `.content`\n\n### Critical Gotchas\n\n1. **Content is ALWAYS an array** - Even single text blocks\n2. **Tool result `.content` can be string OR array** - Handle both:\n   ```jq\n   if .content | type == \"array\" then\n     (.content | map(.text // \"\") | add)\n   else\n     .content\n   end\n   ```\n3. **Use `[]?` not `[]`** - Handles missing fields gracefully\n4. **Sub-agents have `isSidechain: true`** - Filter these for main conversation only\n5. **`parentUuid` links threads** - Not line order\n\n## Using transcript-tool\n\nThe skill provides a CLI at `scripts/transcript-tool`:\n\n```bash\n# Quick overview\ntranscript-tool summary session.jsonl\n\n# Find context bloat sources\ntranscript-tool bloat session.jsonl 15\n\n# Tool usage breakdown\ntranscript-tool tools session.jsonl\n\n# Trace specific tool\ntranscript-tool trace-tool session.jsonl Read\n\n# Find errors\ntranscript-tool errors session.jsonl\n\n# Custom jq query\ntranscript-tool extract session.jsonl '.type'\n```\n\n## Common Analysis Workflows\n\n### 1. Debug Plugin Behavior\n\n```bash\n# Find skill invocations\ntranscript-tool trace-skill session.jsonl plan-generator\n\n# See what tools were used\ntranscript-tool tools session.jsonl\n\n# Check for errors\ntranscript-tool errors session.jsonl\n```\n\n### 2. Investigate Context Bloat\n\n```bash\n# Find largest tool results\ntranscript-tool bloat session.jsonl 20\n\n# Message size analysis\ntranscript-tool messages session.jsonl\n\n# Identify specific large results\ntranscript-tool extract session.jsonl '\n  select(.type == \"user\") |\n  .message.content[]? |\n  select(.type == \"tool_result\") |\n  select((.content | tostring | length) > 10000) |\n  .tool_use_id\n'\n```\n\n### 3. Trace Execution Flow\n\n```bash\n# All tool calls in order\ntranscript-tool extract session.jsonl '\n  select(.type == \"assistant\") |\n  .message.content[]? |\n  select(.type == \"tool_use\") |\n  \"\\(.name): \\(.input | keys | join(\", \"))\"\n'\n```\n\n## Raw jq Recipes\n\nFor complex analysis, use jq directly:\n\n**Count content block types:**\n```bash\njq -r '\n  select(.type == \"user\" or .type == \"assistant\") |\n  .message.content[]? |\n  .type\n' session.jsonl | sort | uniq -c\n```\n\n**Find tool call by ID:**\n```bash\njq -r --arg id \"toolu_xxx\" '\n  select(.type == \"assistant\") |\n  .message.content[]? |\n  select(.type == \"tool_use\" and .id == $id)\n' session.jsonl\n```\n\n**Get corresponding tool result:**\n```bash\njq -r --arg id \"toolu_xxx\" '\n  select(.type == \"user\") |\n  .message.content[]? |\n  select(.type == \"tool_result\" and .tool_use_id == $id) |\n  .content\n' session.jsonl\n```\n\n**Token usage per message:**\n```bash\njq -r '\n  select(.type == \"assistant\" and .message.usage) |\n  \"\\(.message.usage.input_tokens) in, \\(.message.usage.output_tokens) out\"\n' session.jsonl\n```"
              }
            ]
          }
        ]
      }
    }
  ]
}