{
  "owner": {
    "id": "MaxBoiko21",
    "display_name": "Max Boeko",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/92517114?u=ddeaa3ea0614a24ec03bdd648ec36949b63079b6&v=4",
    "url": "https://github.com/MaxBoiko21",
    "bio": "Work...",
    "stats": {
      "total_repos": 1,
      "total_plugins": 1,
      "total_commands": 2,
      "total_skills": 2,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "MaxBoiko21/claude-plugins-marketplace",
      "url": "https://github.com/MaxBoiko21/claude-plugins-marketplace",
      "description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-12-12T11:10:56Z",
        "created_at": "2025-12-12T10:45:52Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 867
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 30
        },
        {
          "path": "PLUGIN_SCHEMA.md",
          "type": "blob",
          "size": 6685
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 3854
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-splitter",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-splitter/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-splitter/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 487
        },
        {
          "path": "plugins/code-splitter/.gitignore",
          "type": "blob",
          "size": 183
        },
        {
          "path": "plugins/code-splitter/PLUGIN_SUMMARY.md",
          "type": "blob",
          "size": 14331
        },
        {
          "path": "plugins/code-splitter/QUICKSTART.md",
          "type": "blob",
          "size": 5883
        },
        {
          "path": "plugins/code-splitter/README.md",
          "type": "blob",
          "size": 4817
        },
        {
          "path": "plugins/code-splitter/TESTING.md",
          "type": "blob",
          "size": 7892
        },
        {
          "path": "plugins/code-splitter/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-splitter/agents/code-splitter.md",
          "type": "blob",
          "size": 11257
        },
        {
          "path": "plugins/code-splitter/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-splitter/commands/scan-code.md",
          "type": "blob",
          "size": 5998
        },
        {
          "path": "plugins/code-splitter/commands/split-code.md",
          "type": "blob",
          "size": 9415
        },
        {
          "path": "plugins/code-splitter/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-splitter/skills/action-pattern-conventions",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-splitter/skills/action-pattern-conventions/SKILL.md",
          "type": "blob",
          "size": 12650
        },
        {
          "path": "plugins/code-splitter/skills/action-pattern-conventions/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-splitter/skills/action-pattern-conventions/references/framework-patterns.md",
          "type": "blob",
          "size": 17977
        },
        {
          "path": "plugins/code-splitter/skills/code-refactoring-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-splitter/skills/code-refactoring-patterns/SKILL.md",
          "type": "blob",
          "size": 10920
        },
        {
          "path": "plugins/code-splitter/skills/code-refactoring-patterns/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-splitter/skills/code-refactoring-patterns/references/extraction-patterns.md",
          "type": "blob",
          "size": 13916
        },
        {
          "path": "scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "scripts/validate-all-plugins.sh",
          "type": "blob",
          "size": 2943
        }
      ],
      "marketplace": {
        "name": "own-plugins-marketplace",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "Maksym Boiko",
          "email": "12crya34@gmail.com"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "code-splitter",
            "description": "Intelligently scan and refactor large code files into smaller, maintainable action-pattern based components following language and framework conventions",
            "source": "./plugins/code-splitter",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add MaxBoiko21/claude-plugins-marketplace",
              "/plugin install code-splitter@own-plugins-marketplace"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-12T11:10:56Z",
              "created_at": "2025-12-12T10:45:52Z",
              "license": null
            },
            "commands": [
              {
                "name": "/scan-code",
                "description": "Scan entire codebase for files that need refactoring",
                "path": "plugins/code-splitter/commands/scan-code.md",
                "frontmatter": {
                  "name": "scan-code",
                  "description": "Scan entire codebase for files that need refactoring",
                  "allowed-tools": [
                    "Glob",
                    "Grep",
                    "Read",
                    "Task"
                  ]
                },
                "content": "# Scan Codebase for Refactoring Candidates\n\nAnalyze the entire project to identify files needing refactoring based on:\n- **Size**: Files exceeding line count thresholds\n- **Complexity**: Methods/functions exceeding function count or cyclomatic complexity\n- **Patterns**: Files not following action pattern conventions\n\n## How It Works\n\n1. **Scan the project**: Use Glob to identify all relevant code files\n2. **Analyze each file**: Check size, method/function count, and patterns\n3. **Generate report**: Present findings in interactive format with metrics\n4. **Present candidates**: User can select which files to refactor with `/split-code`\n\n## Instructions for Claude\n\nRead project configuration from `.claude/code-splitter.local.md` if it exists (use Read tool).\n\nDefault thresholds (can be overridden in project config):\n- **Size threshold**: 300 lines of code\n- **Method/function threshold**: 10 methods/functions per file\n- **Frameworks to detect**: Laravel, Symfony, React, Vue, Node.js\n\n### Step 1: Detect Project Type\n\nUse package.json, composer.json, and file structure to determine:\n- Is this a Laravel/Symfony project? (check composer.json, app/ directory)\n- Is this a React/Vue project? (check package.json, src/ directory)\n- Is this a Node.js backend? (check package.json structure)\n- Is this a mixed project? (multiple frameworks)\n\n### Step 2: Identify Files to Scan\n\nBased on project type, identify relevant file patterns:\n\n**Laravel/Symfony:**\n- Controllers: `app/**/*Controller.php`, `src/**/Controller/`\n- Services: `app/**/Service.php`, `src/**/Service/`\n- Models: `app/**/*.php` excluding Controllers, Actions\n- Any file >300 lines in app/ or src/\n\n**React/Vue:**\n- Components: `src/components/**/*.{jsx,tsx,vue}`\n- Sections: `src/sections/**/*.{jsx,tsx,vue}`\n- Pages: `src/pages/**/*.{jsx,tsx,vue}`\n- Hooks/Composables: `src/hooks/**/*.ts`, `src/composables/**/*.ts`\n\n**Node.js:**\n- Services: `src/services/**/*.ts`\n- Controllers/Handlers: `src/routes/**/*.ts`, `src/handlers/**/*.ts`\n- Any file >300 lines in src/\n\n### Step 3: Analyze Each File\n\nFor each file:\n\n1. **Count lines**: Total lines of code (excluding comments/blanks for accuracy)\n2. **Count methods/functions**:\n   - PHP: Count `public function`, `private function`, `protected function`\n   - JS/TS: Count `function`, `async function`, `const x = () => {}`\n   - Vue/React: Count `function`, exports, methods\n3. **Assess pattern violations**:\n   - Controllers with business logic (>30 lines of non-routing logic)\n   - Large components without child components\n   - Services doing multiple unrelated things\n   - Files not following action pattern conventions\n\n4. **Calculate refactoring score**:\n   - Size violation: lines > 300 â†’ add 1 point\n   - Complexity violation: methods > 10 â†’ add 1 point\n   - Pattern violation: detected â†’ add 1 point\n   - Score > 0 = refactoring candidate\n\n### Step 4: Generate Interactive Report\n\nPresent results as an interactive selection menu:\n\n```\nğŸ“Š Code Splitter Scan Report\n=============================\n\nProject Type: Laravel\nFiles Analyzed: 42\nCandidates Found: 7\n\nRefactoring Candidates:\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nâ–¡ app/Http/Controllers/UserController.php\n  Lines: 425 | Methods: 15 | Score: 2/3\n  Issues: Size violation (125 lines over), complexity violation (5 extra methods)\n\nâ–¡ app/Services/OrderService.php\n  Lines: 380 | Methods: 18 | Score: 2/3\n  Issues: Too many methods, mixed concerns (creation, payment, shipping)\n\nâ–¡ app/Models/User.php\n  Lines: 220 | Methods: 12 | Score: 1/3\n  Issues: Complexity violation (2 extra methods)\n\nâœ“ All other files are within thresholds\n\nRecommended Action:\nUse `/split-code <file-path>` on any candidate above to refactor it.\n```\n\n### Step 5: Interactive Selection (Optional)\n\nIf user wants, present a checkbox interface to select multiple candidates:\n\n```\nSelect files to analyze further:\n\n[âœ“] app/Http/Controllers/UserController.php\n[ ] app/Services/OrderService.php\n[ ] app/Models/User.php\n\nPress to analyze selected files\n```\n\n## Output Format\n\nPresent as:\n1. **Summary**: Total files analyzed, candidates found\n2. **Detailed list**: Each candidate with metrics\n3. **Recommendations**: Which files to prioritize\n4. **Next steps**: Tell user to run `/split-code <file-path>` to refactor\n\n## Error Handling\n\n- If project has no code files: \"No code files found. Verify project structure.\"\n- If config file is malformed: Use default thresholds with warning\n- If file is binary: Skip (don't try to read)\n\n## Tips\n\n- Sort candidates by refactoring score (highest first)\n- Group by file type for easier processing\n- Show framework-specific violation info (e.g., \"Controller with business logic\" for Laravel)\n- Only show files that are actually refactoring candidates (have violations)\n\n## Example Output Formats\n\n**Laravel Project:**\n```\nFile: app/Http/Controllers/UserController.php\nType: Controller\nLines: 425 (threshold: 300, 125 over)\nMethods: 15 (threshold: 10, 5 over)\nViolations:\n  â€¢ Size: 425 lines exceeds 300 line threshold\n  â€¢ Complexity: 15 methods exceeds 10 method threshold\n  â€¢ Pattern: Heavy business logic should be in Action classes\nScore: 3/3 - High Priority\n```\n\n**React Project:**\n```\nFile: src/components/Dashboard.tsx\nType: Component\nLines: 380 (threshold: 300, 80 over)\nMethods: 8 hooks + embedded logic\nViolations:\n  â€¢ Size: 380 lines exceeds 300 line threshold\n  â€¢ Logic: Data fetching, form state, and rendering mixed\n  â€¢ Pattern: Should split into sub-components and custom hooks\nScore: 2/3 - Medium Priority\n```\n\n## Configuration\n\nRead `.claude/code-splitter.local.md` for overrides:\n- `line_threshold`: Override 300 line default\n- `method_threshold`: Override 10 method default\n- Language-specific paths to scan"
              },
              {
                "name": "/split-code",
                "description": "Refactor a specific file by splitting it into smaller action/component files",
                "path": "plugins/code-splitter/commands/split-code.md",
                "frontmatter": {
                  "name": "refactor",
                  "description": "Refactor a specific file by splitting it into smaller action/component files",
                  "argument-hint": "<file-path>",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "Edit",
                    "Glob",
                    "Grep",
                    "Task"
                  ]
                },
                "content": "# Refactor and Split Specific File\n\nAnalyze a specific file and execute refactoring to split it into smaller, focused components following action pattern conventions.\n\n## Parameters\n\n- `file-path` (required): Full path to the file to refactor\n\n## How It Works\n\n1. **Analyze the file**: Read and understand its structure, responsibilities, and violations\n2. **Propose refactoring plan**: Show which code will be extracted and where\n3. **User approval**: User selects which extractions to perform\n4. **Execute refactoring**: Create new files and update imports\n5. **Validate**: Check syntax and suggest improvements\n\n## Instructions for Claude\n\n### Step 1: Read and Analyze the File\n\n1. Use Read tool to load the specified file\n2. Understand its current structure:\n   - What is it doing? (business logic, data access, rendering, etc.)\n   - How many methods/functions? What do they do?\n   - How many lines?\n   - Current violations (size, complexity, multiple concerns)\n3. Determine the file type:\n   - PHP file? (Laravel controller, service, model)\n   - JavaScript/TypeScript? (Node service, React component, Vue component)\n   - Identify the framework context\n\n### Step 2: Load Project Configuration\n\n1. Try to read `.claude/code-splitter.local.md` from project root\n2. Extract project preferences:\n   - Target action paths (laravel_actions_path, react_components_path, etc.)\n   - Language-specific conventions\n   - Naming preferences\n3. If no config exists, use defaults for detected framework\n\n### Step 3: Propose Refactoring Plan\n\nCreate a detailed plan showing:\n\n**For each extraction:**\n- What code is being extracted (which methods/functions/sections)\n- Where it will be created (new file path following conventions)\n- What dependencies it needs\n- How it connects to remaining code\n\n**Example Laravel plan:**\n```\nRefactoring Plan: app/Http/Controllers/UserController.php\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nCurrent Issues:\n  â€¢ File size: 425 lines (125 lines over threshold)\n  â€¢ Methods: 15 (5 methods over threshold)\n  â€¢ Mixed concerns: routing, validation, business logic, email sending\n\nProposed Extractions:\n\n1. Create User Action\n   File: app/Actions/Users/CreateUserAction.php\n   Extracts: store() method business logic\n   Dependencies: User model, Mail service\n   Connections: Controller calls this action\n\n2. Update User Action\n   File: app/Actions/Users/UpdateUserAction.php\n   Extracts: update() method business logic\n   Dependencies: User model\n   Connections: Controller calls this action\n\n3. Delete User Action\n   File: app/Actions/Users/DeleteUserAction.php\n   Extracts: destroy() method logic\n   Dependencies: User model\n   Connections: Controller calls this action\n\n4. Send User Invitation\n   File: app/Actions/Users/SendUserInvitationAction.php\n   Extracts: sendInvitation() method\n   Dependencies: Mail service\n   Connections: Controller calls this action\n\nResult:\n  â€¢ Controller reduced to ~50 lines (routing only)\n  â€¢ Each action has single responsibility\n  â€¢ Code is testable and reusable\n  â€¢ Following Laravel action pattern\n```\n\n**For React/Vue, show component breakdown:**\n```\nRefactoring Plan: src/components/UserDashboard.tsx\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nCurrent Issues:\n  â€¢ Component size: 380 lines (80 over threshold)\n  â€¢ Mixed concerns: data fetching, form state, rendering\n  â€¢ No child components\n\nProposed Extractions:\n\n1. useUserData Hook\n   File: src/hooks/useUserData.ts\n   Extracts: User fetching logic\n   Dependencies: React Query/SWR\n   Connections: UserDashboard imports and uses it\n\n2. UserProfile Component\n   File: src/sections/UserProfile.tsx\n   Extracts: Profile rendering section\n   Dependencies: User type\n   Connections: Receives user prop from UserDashboard\n\n3. UserForm Component\n   File: src/sections/UserForm.tsx\n   Extracts: Form rendering and submission\n   Dependencies: useUserForm hook\n   Connections: Receives user prop, calls onSuccess\n\n4. UserActivity Component\n   File: src/sections/UserActivity.tsx\n   Extracts: Activity list rendering\n   Dependencies: useUserActivities hook\n   Connections: Receives userId prop\n\nResult:\n  â€¢ Dashboard component: ~50 lines of layout\n  â€¢ Each section has single responsibility\n  â€¢ Reusable hooks and components\n  â€¢ Better code organization\n```\n\n### Step 4: Present Plan to User\n\nFormat as structured proposal:\n- Show current issues clearly\n- List each extraction with file path and purpose\n- Show resulting file structure\n- Ask user: \"Should I proceed with this plan?\" or \"Would you like to adjust?\"\n\n### Step 5: User Selection\n\nAllow user to:\n- Accept the entire plan\n- Remove specific extractions (\"Don't extract #3\")\n- Add notes or adjustments\n- Proceed to execution\n\n### Step 6: Execute Refactoring\n\nFor **each extraction the user approved**:\n\n1. **Create new file**:\n   - Use Write tool to create new file at proposed location\n   - Copy extracted code into new file\n   - Add necessary imports/dependencies\n   - Add proper file structure (class, function, component, etc.)\n\n2. **Update original file**:\n   - Use Edit tool to replace extracted code with function/class call\n   - Add imports for new files\n   - Keep only the router/handler/layout logic\n\n3. **Validate syntax**:\n   - Check if file is valid (no syntax errors)\n   - Verify imports are correct\n   - Ensure function signatures match\n\n### Step 7: Generate Summary & Suggestions\n\nShow user what was created:\n\n```\nâœ… Refactoring Complete!\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nFiles Created:\n  âœ“ app/Actions/Users/CreateUserAction.php (45 lines)\n  âœ“ app/Actions/Users/UpdateUserAction.php (38 lines)\n  âœ“ app/Actions/Users/DeleteUserAction.php (25 lines)\n\nFiles Modified:\n  âœ“ app/Http/Controllers/UserController.php\n    Reduced from 425 â†’ 65 lines\n\nResult:\n  â€¢ Original controller now focused on routing only\n  â€¢ Each action has clear single responsibility\n  â€¢ Code is testable and reusable from multiple places\n  â€¢ Following Laravel action pattern\n\nNext Steps:\n  1. Run tests to verify functionality\n  2. Check imports if using IDE\n  3. Consider creating test files for new actions\n```\n\n### Step 8: Validation & Suggestions\n\nAfter refactoring, suggest improvements:\n\n```\nğŸ’¡ Suggestions for Further Improvement:\n\n1. Create Factory for CreateUserAction tests\n   Path: database/factories/UserFactory.php\n\n2. Consider extracting validation to Form Request\n   Path: app/Http/Requests/StoreUserRequest.php\n\n3. Add event dispatching for user creation\n   Would allow notifications without tight coupling\n```\n\n## Language-Specific Handling\n\n### Laravel/Symfony\n\n- Extract to Action classes in `app/Actions/` (Laravel) or `src/Service/` (Symfony)\n- Each action: `handle()` or `execute()` method\n- Dependency injection via constructor\n- Use Form Requests for validation\n- Auto-generate factories if project uses them\n\n### React\n\n- Extract to custom hooks (state/logic) in `src/hooks/`\n- Extract to components (rendering) in `src/components/` or `src/sections/`\n- Use TypeScript interfaces for props\n- Custom hooks start with `use` prefix\n- Memoize if needed\n\n### Vue\n\n- Extract to composables (logic) in `src/composables/`\n- Extract to components (rendering) in `src/components/` or `src/views/`\n- Use TypeScript interfaces\n- Composables start with `use` prefix\n- Return reactive objects\n\n### Node.js\n\n- Extract to Service classes in `src/services/`\n- Extract to Action classes for complex multi-step operations\n- Dependency injection via constructor\n- Use TypeScript for type safety\n\n## File Handling\n\n**Before Creating Files:**\n1. Check if target directory exists (using Glob)\n2. Check if file already exists\n3. If exists, ask user: \"File exists, should I overwrite?\"\n\n**Import Updates:**\n1. Auto-add necessary imports to modified files\n2. Update references from old methods to new extracted classes/functions\n3. Verify import paths are correct for the project structure\n\n## Error Handling\n\n- **Invalid file path**: \"File not found. Check the path and try again.\"\n- **Unrecognized file type**: \"Cannot refactor this file type. Supported: .php, .tsx, .ts, .vue, .jsx\"\n- **Parse error**: \"Could not parse file. Check for syntax errors first.\"\n- **Permission denied**: \"Cannot write to target directory. Check permissions.\"\n\n## Tips for Quality Results\n\n- Preserve comments and documentation\n- Keep cohesive logic together\n- Don't create too many tiny files (each should be ~30-100 lines)\n- Group related actions together (all User actions in Users/ folder)\n- Update tests if they exist\n- Suggest adding test files for new actions/components\n\n## Configuration\n\nRead `.claude/code-splitter.local.md`:\n- `laravel_actions_path`: Where to create Laravel actions\n- `react_components_path`: Where to create React components\n- `vue_composables_path`: Where to create Vue composables\n- `node_services_path`: Where to create Node services\n- Any language-specific conventions"
              }
            ],
            "skills": [
              {
                "name": "Action Pattern Conventions",
                "description": "This skill should be used when the user asks about \"Laravel action pattern\", \"action class naming\", \"how to structure actions\", \"React component patterns\", \"Node.js service structure\", \"framework-specific conventions\", or discusses creating reusable, focused classes following action pattern conventions in Laravel, Symfony, React, Vue, or Node.js projects.",
                "path": "plugins/code-splitter/skills/action-pattern-conventions/SKILL.md",
                "frontmatter": {
                  "name": "Action Pattern Conventions",
                  "description": "This skill should be used when the user asks about \"Laravel action pattern\", \"action class naming\", \"how to structure actions\", \"React component patterns\", \"Node.js service structure\", \"framework-specific conventions\", or discusses creating reusable, focused classes following action pattern conventions in Laravel, Symfony, React, Vue, or Node.js projects.",
                  "version": "0.1.0"
                },
                "content": "# Action Pattern Conventions\n\n## Purpose\n\nThis skill provides language and framework-specific guidance for implementing the action pattern across different technology stacks. It explains conventions for creating focused, reusable action classes, components, services, and modules that encapsulate specific business operations.\n\n## When to Use\n\nUse this skill when refactoring code into actions, understanding how to structure operations for a specific framework, or ensuring extracted code follows project conventions. It covers Laravel, Symfony, React, Vue, and Node.js.\n\n## Universal Action Pattern\n\nThe action pattern applies universally across frameworks:\n\n**Core concept:** One action = one operation with a clear entry point\n\n**Characteristics:**\n- **Single responsibility**: One reason to exist\n- **Clear interface**: Single entry method (`handle()`, `execute()`, call method)\n- **Dependency injection**: Dependencies injected, not global\n- **Reusability**: Can be called from multiple contexts (controllers, jobs, CLI, API, webhooks)\n- **Testability**: Testable in isolation\n- **Naming**: Describes the operation clearly\n\n**Pattern:**\n```\npublic function handle($input) {\n    // 1. Validate/prepare input\n    // 2. Execute operation (business logic)\n    // 3. Return result or side effect\n}\n```\n\n## Laravel Action Pattern\n\n### File Structure\n\n```\napp/\nâ”œâ”€â”€ Actions/\nâ”‚   â”œâ”€â”€ Users/\nâ”‚   â”‚   â”œâ”€â”€ CreateUserAction.php\nâ”‚   â”‚   â”œâ”€â”€ UpdateUserAction.php\nâ”‚   â”‚   â””â”€â”€ DeleteUserAction.php\nâ”‚   â”œâ”€â”€ Orders/\nâ”‚   â”‚   â”œâ”€â”€ CreateOrderAction.php\nâ”‚   â”‚   â””â”€â”€ ProcessPaymentAction.php\nâ”‚   â””â”€â”€ Notifications/\nâ”‚       â”œâ”€â”€ SendWelcomeEmailAction.php\nâ”‚       â””â”€â”€ SendOrderConfirmationAction.php\n```\n\n### Basic Action Class\n\n```php\n<?php\n\nnamespace App\\Actions\\Users;\n\nfinal readonly class CreateUserAction {\n    public function __construct(private UserRepository $users) {}\n\n    public function handle(array $data): User {\n        // Validate (optional, can use Form Request instead)\n        $validated = $this->validate($data);\n\n        // Create user\n        $user = $this->users->create($validated);\n\n        // Side effects (notifications, etc.)\n        // Only if tightly coupled to creation\n        // Otherwise use jobs or separate actions\n\n        return $user;\n    }\n\n    private function validate(array $data): array {\n        // Custom validation if needed\n        return $data;\n    }\n}\n```\n\n### Usage in Controllers\n\n```php\nclass UserController extends Controller {\n    public function store(CreateUserRequest $request, CreateUserAction $createUser) {\n        // Constructor injection of action\n        $user = $createUser->handle($request->validated());\n\n        return response()->json(['user' => $user], 201);\n    }\n}\n```\n\n### Naming Conventions\n\n**Action class names:**\n- Operation + \"Action\" suffix: `CreateUserAction`, `SendEmailAction`\n- Verb-noun format: Clear what it does\n- Namespace by domain: `Users/`, `Orders/`, `Payments/`\n\n**Method names:**\n- `handle()` - Primary method for the action\n- Specific methods for complex operations: `validateUser()`, `persistToDatabase()`\n\n**File structure:**\n- One action per file\n- Directory per domain/entity type\n- `app/Actions/` root directory\n\n### Advanced Patterns\n\n**Action with Transaction:**\n```php\nfinal readonly class CreateOrderAction {\n    public function __construct(private OrderRepository $orders) {}\n\n    public function handle(array $data): Order {\n        return DB::transaction(function () use ($data) {\n            $order = $this->orders->create($data);\n            $this->orders->attachItems($order->id, $data['items']);\n            return $order;\n        });\n    }\n}\n```\n\n**Action with Events:**\n```php\nfinal readonly class ProcessPaymentAction {\n    public function __construct(private PaymentGateway $gateway) {}\n\n    public function handle(Order $order): Payment {\n        $payment = $this->gateway->process($order->total);\n\n        // Dispatch event instead of tightly coupling logic\n        event(new PaymentProcessed($order, $payment));\n\n        return $payment;\n    }\n}\n```\n\n**Action Composition:**\n```php\nfinal readonly class CompleteOrderAction {\n    public function __construct(\n        private ProcessPaymentAction $processPayment,\n        private SendConfirmationAction $sendConfirmation,\n    ) {}\n\n    public function handle(Order $order): Order {\n        $payment = $this->processPayment->handle($order);\n        $this->sendConfirmation->handle($order);\n\n        return $order->markComplete();\n    }\n}\n```\n\n## React Component & Hook Pattern\n\n### Component Structure\n\n```\nsrc/\nâ”œâ”€â”€ components/          # Reusable UI components\nâ”‚   â”œâ”€â”€ button.tsx\nâ”‚   â”œâ”€â”€ card.tsx\nâ”‚   â””â”€â”€ form-field.tsx\nâ”œâ”€â”€ sections/            # Composite sections (headers, forms, features)\nâ”‚   â”œâ”€â”€ user-profile-form.tsx\nâ”‚   â””â”€â”€ order-summary.tsx\nâ”œâ”€â”€ layouts/             # Page layouts\nâ”‚   â”œâ”€â”€ dashboard-layout.tsx\nâ”‚   â””â”€â”€ auth-layout.tsx\nâ””â”€â”€ pages/               # Route pages\n    â”œâ”€â”€ users/\n    â”‚   â”œâ”€â”€ index.tsx\n    â”‚   â””â”€â”€ show.tsx\n    â””â”€â”€ orders/\n        â”œâ”€â”€ index.tsx\n        â””â”€â”€ create.tsx\n```\n\n### Component Convention\n\n**Small, focused components (<100 lines):**\n```tsx\ninterface ButtonProps {\n    label: string;\n    onClick: () => void;\n    variant?: 'primary' | 'secondary';\n}\n\nexport function Button({ label, onClick, variant = 'primary' }: ButtonProps) {\n    return (\n        <button\n            className={`btn btn-${variant}`}\n            onClick={onClick}\n        >\n            {label}\n        </button>\n    );\n}\n```\n\n**Composite sections (reusable blocks):**\n```tsx\ninterface UserFormProps {\n    user?: User;\n    onSubmit: (data: UserData) => Promise<void>;\n}\n\nexport function UserProfileForm({ user, onSubmit }: UserFormProps) {\n    const form = useUserForm(user);\n\n    const handleSubmit = async (e: React.FormEvent) => {\n        e.preventDefault();\n        await onSubmit(form.data);\n    };\n\n    return (\n        <form onSubmit={handleSubmit}>\n            <FormField label=\"Name\" value={form.data.name} />\n            <FormField label=\"Email\" value={form.data.email} />\n            <button type=\"submit\">Save</button>\n        </form>\n    );\n}\n```\n\n### Custom Hook Convention\n\n**Naming:**\n- `use` + PascalCase: `useUserForm`, `useFetchUsers`, `useAuthContext`\n- Describe what it does: `useFormValidation`, `useLocalStorage`, `usePaginatedData`\n\n**Pattern:**\n```tsx\nfunction useUserForm(initialUser?: User) {\n    const [data, setData] = useState(initialUser || {});\n    const [errors, setErrors] = useState({});\n\n    const validate = () => {\n        // Validation logic\n    };\n\n    const submit = async () => {\n        // Submit logic\n    };\n\n    return { data, setData, errors, validate, submit };\n}\n\n// Usage\nfunction MyComponent() {\n    const form = useUserForm(user);\n    return <form onSubmit={form.submit}>...</form>;\n}\n```\n\n### Composition Pattern\n\n**Extract child components:**\n```tsx\nfunction UserDashboard({ userId }) {\n    const user = useUserData(userId);\n\n    return (\n        <div className=\"dashboard\">\n            <UserHeader user={user} />\n            <UserStats user={user} />\n            <UserActivity user={user} />\n        </div>\n    );\n}\n\n// Separate components\nfunction UserHeader({ user }) {\n    return <header>{user.name}</header>;\n}\n\nfunction UserStats({ user }) {\n    return <div>Stats content</div>;\n}\n\nfunction UserActivity({ user }) {\n    return <div>Activity content</div>;\n}\n```\n\n## Vue Composition & Pattern\n\n### Component Structure\n\n```\nsrc/\nâ”œâ”€â”€ components/          # Reusable UI components\nâ”œâ”€â”€ views/              # Route views/pages\nâ”œâ”€â”€ composables/        # Reusable composition functions\nâ”‚   â”œâ”€â”€ useUserForm.ts\nâ”‚   â””â”€â”€ useFetchData.ts\nâ””â”€â”€ services/           # API client services\n    â””â”€â”€ userService.ts\n```\n\n### Composable Convention\n\n```typescript\n// composables/useUserForm.ts\nimport { ref, computed } from 'vue';\n\nexport function useUserForm(initialUser = null) {\n    const data = ref(initialUser || {});\n    const errors = ref({});\n\n    const validate = () => {\n        // Validation logic\n    };\n\n    const submit = async () => {\n        // Submit logic\n    };\n\n    return { data, errors, validate, submit };\n}\n\n// Usage in component\n<script setup lang=\"ts\">\nimport { useUserForm } from '@/composables/useUserForm';\n\nconst form = useUserForm(props.user);\n</script>\n```\n\n## Node.js / TypeScript Pattern\n\n### Service Structure\n\n```\nsrc/\nâ”œâ”€â”€ services/\nâ”‚   â”œâ”€â”€ user.service.ts\nâ”‚   â”œâ”€â”€ order.service.ts\nâ”‚   â”œâ”€â”€ email.service.ts\nâ”‚   â””â”€â”€ payment.service.ts\nâ”œâ”€â”€ repositories/       # Data access\nâ”‚   â”œâ”€â”€ user.repository.ts\nâ”‚   â””â”€â”€ order.repository.ts\nâ”œâ”€â”€ actions/           # Complex operations\nâ”‚   â”œâ”€â”€ create-order.action.ts\nâ”‚   â””â”€â”€ process-payment.action.ts\nâ””â”€â”€ utils/             # Helper functions\n    â”œâ”€â”€ validation.ts\n    â””â”€â”€ formatting.ts\n```\n\n### Service Class Convention\n\n```typescript\nexport class UserService {\n    constructor(private userRepository: UserRepository) {}\n\n    async create(data: CreateUserDTO): Promise<User> {\n        // Operation logic\n        return user;\n    }\n\n    async update(id: string, data: UpdateUserDTO): Promise<User> {\n        // Operation logic\n        return user;\n    }\n\n    async delete(id: string): Promise<void> {\n        // Operation logic\n    }\n}\n```\n\n### Action Class Convention (Node.js)\n\n```typescript\nexport class CreateOrderAction {\n    constructor(\n        private orderService: OrderService,\n        private paymentService: PaymentService,\n    ) {}\n\n    async execute(data: CreateOrderDTO): Promise<Order> {\n        // Complex multi-step operation\n        const order = await this.orderService.create(data);\n\n        if (data.paymentMethod) {\n            await this.paymentService.process(order.id, data.paymentMethod);\n        }\n\n        return order;\n    }\n}\n```\n\n### Helper Function Convention\n\n```typescript\n// utils/validation.ts\nexport function validateEmail(email: string): boolean {\n    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email);\n}\n\nexport function validatePassword(password: string): boolean {\n    return password.length >= 8;\n}\n\n// Usage\nif (!validateEmail(email)) {\n    throw new Error('Invalid email');\n}\n```\n\n## Framework Auto-Detection\n\nThe plugin auto-detects your project type based on:\n\n**Laravel:**\n- Presence of `composer.json` with laravel/framework\n- Directory structure with `app/`, `routes/`, `config/`\n\n**React:**\n- Presence of `package.json` with react dependency\n- `.tsx` or `.jsx` files in `src/`\n\n**Vue:**\n- Presence of `package.json` with vue dependency\n- `.vue` files in `src/`\n\n**Node.js / Symfony:**\n- Presence of `package.json` or `composer.json`\n- Service-based file structure\n\n## Customization per Project\n\nOverride defaults in `.claude/code-splitter.local.md`:\n\n```yaml\n---\n# Laravel\nlaravel_actions_path: app/Actions\nlaravel_action_namespace: \"App\\\\Actions\"\n\n# React\nreact_components_path: src/components\nreact_hooks_path: src/hooks\n\n# Vue\nvue_composables_path: src/composables\nvue_components_path: src/components\n\n# Node.js\nnode_services_path: src/services\nnode_actions_path: src/actions\n\n# General\naction_method_name: execute      # Instead of handle\nmax_lines_per_file: 100\n---\n```\n\n## Additional Resources\n\nFor detailed examples and advanced patterns, see:\n- **`references/framework-patterns.md`** - Comprehensive framework-specific patterns\n- **`examples/`** - Real working examples for each framework\n\n## Key Principles\n\n1. **One operation per action/service**: Clear, focused responsibility\n2. **Dependency injection**: Inject dependencies, don't rely on globals\n3. **Reusability**: Can be called from multiple contexts\n4. **Testability**: Testable in isolation with mocked dependencies\n5. **Naming clarity**: Names describe what the action does\n6. **Framework conventions**: Follow established patterns for your framework\n\nNext steps: Use `/scan-code` to identify refactoring candidates, or `/split-code <file>` to apply these patterns to your code."
              },
              {
                "name": "Code Refactoring Patterns",
                "description": "This skill should be used when the user asks to \"refactor large files\", \"split code into smaller pieces\", \"extract methods\", \"how should I refactor\", \"improve code structure\", \"break down large functions\", or discusses strategies for dividing monolithic code into smaller, maintainable components.",
                "path": "plugins/code-splitter/skills/code-refactoring-patterns/SKILL.md",
                "frontmatter": {
                  "name": "Code Refactoring Patterns",
                  "description": "This skill should be used when the user asks to \"refactor large files\", \"split code into smaller pieces\", \"extract methods\", \"how should I refactor\", \"improve code structure\", \"break down large functions\", or discusses strategies for dividing monolithic code into smaller, maintainable components.",
                  "version": "0.1.0"
                },
                "content": "# Code Refactoring Patterns\n\n## Purpose\n\nThis skill provides guidance on refactoring large, complex code files into smaller, focused, and maintainable components. It covers fundamental refactoring principles, extraction strategies, and patterns that apply across programming languages and frameworks.\n\n## When to Use\n\nUse this skill when analyzing code structure, planning refactoring strategies, or deciding how to split large files. It provides language-agnostic principles that work whether refactoring Laravel controllers, React components, Node.js services, or any codebase.\n\n## Core Refactoring Principles\n\n### 1. Single Responsibility Principle (SRP)\n\nEach function, class, or module should have one reason to change. Identify when code violates SRP:\n\n- **Controllers handling validation, business logic, and response formatting** â†’ Extract validation and business logic to separate classes\n- **Components managing state, data fetching, and rendering** â†’ Extract hooks and services\n- **Service classes with 15+ public methods** â†’ Break into focused services\n- **Functions doing multiple operations** â†’ Extract each operation to its own function\n\n**Question to ask:** \"If this code needs to change, how many different reasons could require that change?\" More than one reason signals SRP violation.\n\n### 2. Extractable Boundaries\n\nIdentify clear extraction boundaries by looking for:\n\n- **Distinct workflows**: Methods performing completely different operations (e.g., user creation separate from email sending)\n- **Reusable logic**: Code that appears in multiple places or could be used elsewhere\n- **High complexity**: Methods exceeding 15-20 lines or with nested conditionals\n- **Clear input/output**: Methods with well-defined inputs and outputs (easier to extract)\n- **Testability**: Logic that would benefit from independent testing\n\n**Extraction pattern:**\n```\n1. Identify the boundary (start/end of related operations)\n2. Extract to new method/function\n3. Verify no side effects or tight coupling\n4. Test independently\n5. Update references\n```\n\n### 3. Complexity Metrics\n\nRecognize complexity that signals refactoring need:\n\n- **Cyclomatic Complexity > 10**: Multiple branches, nested conditions â†’ Extract conditional logic to separate methods\n- **Method length > 20 lines**: Likely handling multiple concerns â†’ Break into smaller methods\n- **Nesting depth > 3 levels**: Hard to follow logic â†’ Extract inner logic to separate methods\n- **Parameter count > 4**: Hard to understand and test â†’ Group parameters into objects\n- **Method with many local variables**: Suggests multiple concerns â†’ Extract to separate methods\n\n### 4. Naming and Intent\n\nAfter extraction, ensure clear naming:\n\n- **Method names should describe intent**: `validateUserEmail()` not `check()`, `processPayment()` not `do()`\n- **Extract Guard Clauses**: Early returns for edge cases make the happy path clear\n- **Extract Error Handling**: Separate validation from business logic\n- **Extract Loops**: Extract loop bodies to named methods that describe the operation\n\n**Example**:\n```php\n// Before: Hard to understand at a glance\npublic function createUser($data) {\n    if (!$data['email']) return false;\n    if (User::where('email', $data['email'])->exists()) return false;\n    // ... 30 more lines\n}\n\n// After: Clear intent with extracted boundaries\npublic function createUser($data) {\n    if (!$this->validateUserData($data)) return false;\n    if ($this->userExists($data['email'])) return false;\n    return $this->storeUser($data);\n}\n```\n\n## Extraction Patterns by Language\n\n### PHP / Laravel\n\n**Extract CRUD operations into Action classes:**\n- `CreateUserAction` - Only handles creation logic\n- `UpdateUserAction` - Only handles updates\n- `DeleteUserAction` - Only handles deletion\n- `GetUserAction` - Only handles retrieval with related data\n\n**Extract validation into separate methods or Form Requests:**\n- `ValidateUserInput` method or Form Request class\n- Keep business logic separate from validation\n\n**Extract queries into scopes and methods:**\n- `scopeActive()` â†’ `User::query()->active()`\n- `scopeByEmail()` â†’ `User::query()->byEmail($email)`\n\n**Extract relationships into dedicated classes:**\n- Models with complex relationships â†’ Separate trait files\n- Resource formatting â†’ Dedicated Resource class\n\n### React / Vue\n\n**Extract large components into smaller pieces:**\n- Container components (data management) separate from presentational components (rendering)\n- Extract hooks for reusable logic\n- Extract smaller, focused sub-components\n\n**Extract hooks for reusable logic:**\n- `useUserPermissions()` â†’ Encapsulates permission checking\n- `useFormValidation()` â†’ Handles form state and validation\n- `useDataFetching()` â†’ Wraps React Query or SWR\n\n**Extract context providers:**\n- Theme context separate from Auth context\n- Each context for one concern\n\n### Node.js / TypeScript\n\n**Extract service methods into focused services:**\n- `UserService` â†’ User-specific operations\n- `EmailService` â†’ Email operations\n- `PaymentService` â†’ Payment operations\n\n**Extract helper/utility functions:**\n- `validateEmail()`, `hashPassword()`, `formatResponse()`\n- Keep pure functions in separate files\n\n**Extract data access patterns:**\n- Database queries â†’ Repository pattern or separate data access file\n- API calls â†’ Separate API client file\n\n## Refactoring Workflow\n\n### Step 1: Analyze Current Code\n\nRead the file and identify:\n- Current responsibilities (what does this code do?)\n- Violation areas (where are multiple concerns mixed?)\n- Extraction candidates (which parts could be separate?)\n- Dependencies (what does extracted code depend on?)\n\n### Step 2: Design Target Structure\n\nPlan the refactoring:\n- How many files/classes should be created?\n- What will each contain?\n- How will they interact?\n- What's the folder structure?\n\n### Step 3: Extract with Care\n\n- Extract one concern at a time\n- Update references to extracted code\n- Verify functionality still works\n- Run tests (if available)\n\n### Step 4: Validate\n\n- Does each extracted component have single responsibility?\n- Are dependencies clear and minimal?\n- Is the code easier to understand and test?\n- Can extracted code be reused elsewhere?\n\n## Common Extraction Scenarios\n\n### Scenario 1: Large Controller Class\n\n**Problem:** 50+ line controller method doing validation, business logic, and response formatting\n\n**Solution:**\n1. Extract validation to Form Request or validator method\n2. Extract business logic to Action class\n3. Keep controller thin (3-5 lines)\n\n### Scenario 2: Complex Component\n\n**Problem:** React component with 200+ lines doing data fetching, state management, and rendering\n\n**Solution:**\n1. Extract data fetching to custom hook\n2. Extract child components for different sections\n3. Extract form logic to separate hook\n4. Component becomes 30-40 lines focused on layout\n\n### Scenario 3: God Service Class\n\n**Problem:** Service class with 30+ public methods handling multiple unrelated operations\n\n**Solution:**\n1. Group related methods into separate service classes\n2. Service A: `UserCreation` operations\n3. Service B: `UserNotification` operations\n4. Service C: `UserPermissions` operations\n5. Update references to use appropriate service\n\n### Scenario 4: Conditional Logic\n\n**Problem:** Method with 5+ nested if/else levels\n\n**Solution:**\n1. Extract guard clauses to top (early returns)\n2. Extract condition checking to named methods\n3. Extract branch logic to separate methods\n4. Result: Clear happy path with early exits\n\n## Patterns to Follow\n\n### Action Pattern (Preferred for Business Logic)\n\n**Characteristics:**\n- Single `handle()` method with clear purpose\n- Dependencies injected via constructor\n- Reusable from commands, controllers, jobs, API requests\n- Easy to test\n\n**When to use:** Any complex business logic (user creation, payment processing, data transformation)\n\n### Hook Pattern (React/Vue)\n\n**Characteristics:**\n- Reusable logic encapsulated\n- Composed into components\n- Separate concerns (state, effects, validation)\n- Testable independently\n\n**When to use:** Reusable component logic (form handling, data fetching, permissions)\n\n### Service Pattern (Node.js/Backend)\n\n**Characteristics:**\n- Focused on specific domain\n- Clear public interface\n- Encapsulates related operations\n- Stateless or minimal state\n\n**When to use:** Domain-specific operations (UserService, EmailService, PaymentService)\n\n## Red Flags for Refactoring Need\n\nExtract code when you see:\n\n- **DRY Violation**: Same code appears 2+ times â†’ Extract to reusable function\n- **Naming Confusion**: Can't describe what a method does in a sentence â†’ Doing too much\n- **Test Difficulty**: Hard to test a method in isolation â†’ Likely mixed concerns\n- **Multiple Reasons to Change**: Modification requests affect different parts of code â†’ SRP violation\n- **Deep Nesting**: More than 3 levels of indentation â†’ Extract inner logic\n- **Long Parameter Lists**: More than 4 parameters â†’ Group into object/DTO\n- **Many Local Variables**: More than 5-6 variables â†’ Likely multiple concerns\n- **Scroll Fatigue**: Method longer than screen height â†’ Break into smaller methods\n\n## Advanced Patterns\n\n### Refactoring with Dependencies\n\nWhen extracting code with external dependencies:\n1. Identify which services/dependencies are needed\n2. Pass them as constructor parameters or method arguments\n3. Extracted code is testable with mocked dependencies\n4. Original code still works, now calling extracted code\n\n### Refactoring with State\n\nWhen extracting code that manages state:\n1. Move state and state-changing logic together\n2. Use appropriate state management (Context in React, local in Vue, closures in JS)\n3. Ensure clear ownership of state\n4. Extracted code has clear input/output\n\n### Refactoring with Side Effects\n\nWhen extracting code with side effects (DB writes, API calls, file I/O):\n1. Extract the effect operation to separate method\n2. Keep business logic pure when possible\n3. Side effects at boundaries (entry points)\n4. Easier to test pure logic separately\n\n## Additional Resources\n\nFor language and framework-specific action patterns, see:\n- **`references/extraction-patterns.md`** - Detailed extraction techniques\n- **`references/smell-indicators.md`** - Code smell checklist\n- **`examples/`** - Working refactoring examples\n\n## Next Steps\n\nAfter understanding refactoring principles, use the `/scan-code` command to identify candidates in your codebase, or `/split-code <file>` to refactor specific files following these patterns."
              }
            ]
          }
        ]
      }
    }
  ]
}