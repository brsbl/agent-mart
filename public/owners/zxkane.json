{
  "owner": {
    "id": "zxkane",
    "display_name": "Mengxin Zhu",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/843303?v=4",
    "url": "https://github.com/zxkane",
    "bio": "Open source mania.",
    "stats": {
      "total_repos": 1,
      "total_plugins": 4,
      "total_commands": 0,
      "total_skills": 4,
      "total_stars": 78,
      "total_forks": 11
    }
  },
  "repos": [
    {
      "full_name": "zxkane/aws-skills",
      "url": "https://github.com/zxkane/aws-skills",
      "description": "Claude Agent Skills for AWS",
      "homepage": "",
      "signals": {
        "stars": 78,
        "forks": 11,
        "pushed_at": "2026-01-08T07:53:13Z",
        "created_at": "2025-10-21T03:56:34Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 4329
        },
        {
          "path": ".claude",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/skills/aws-agentic-ai",
          "type": "blob",
          "size": 50
        },
        {
          "path": ".claude/skills/aws-cdk-development",
          "type": "blob",
          "size": 48
        },
        {
          "path": ".claude/skills/aws-cost-operations",
          "type": "blob",
          "size": 53
        },
        {
          "path": ".claude/skills/aws-serverless-eda",
          "type": "blob",
          "size": 54
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 1045
        },
        {
          "path": "CLAUDE.md",
          "type": "blob",
          "size": 3290
        },
        {
          "path": "LICENSE",
          "type": "blob",
          "size": 1068
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 6765
        },
        {
          "path": "docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/aws-mcp-setup.md",
          "type": "blob",
          "size": 4665
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/aws-agentic-ai",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/aws-agentic-ai/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/SKILL.md",
          "type": "blob",
          "size": 6603
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/cross-service",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/cross-service/credential-management.md",
          "type": "blob",
          "size": 13844
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/services",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/services/browser",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/services/browser/README.md",
          "type": "blob",
          "size": 10378
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/services/code-interpreter",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/services/code-interpreter/README.md",
          "type": "blob",
          "size": 7792
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/services/gateway",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/services/gateway/README.md",
          "type": "blob",
          "size": 3379
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/services/gateway/deploy-template.sh",
          "type": "blob",
          "size": 2893
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/services/gateway/deployment-strategies.md",
          "type": "blob",
          "size": 11311
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/services/gateway/troubleshooting-guide.md",
          "type": "blob",
          "size": 10342
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/services/gateway/validate-deployment.sh",
          "type": "blob",
          "size": 5708
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/services/identity",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/services/identity/README.md",
          "type": "blob",
          "size": 6868
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/services/memory",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/services/memory/README.md",
          "type": "blob",
          "size": 8309
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/services/observability",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/services/observability/README.md",
          "type": "blob",
          "size": 14145
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/services/runtime",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/services/runtime/README.md",
          "type": "blob",
          "size": 6815
        },
        {
          "path": "plugins/aws-cdk",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/aws-cdk/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/aws-cdk/skills/aws-cdk-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/aws-cdk/skills/aws-cdk-development/SKILL.md",
          "type": "blob",
          "size": 10323
        },
        {
          "path": "plugins/aws-cdk/skills/aws-cdk-development/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/aws-cdk/skills/aws-cdk-development/references/cdk-patterns.md",
          "type": "blob",
          "size": 9852
        },
        {
          "path": "plugins/aws-cdk/skills/aws-cdk-development/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/aws-cdk/skills/aws-cdk-development/scripts/validate-stack.sh",
          "type": "blob",
          "size": 7203
        },
        {
          "path": "plugins/aws-cost-ops",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/aws-cost-ops/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/aws-cost-ops/skills/aws-cost-operations",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/aws-cost-ops/skills/aws-cost-operations/SKILL.md",
          "type": "blob",
          "size": 11135
        },
        {
          "path": "plugins/aws-cost-ops/skills/aws-cost-operations/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/aws-cost-ops/skills/aws-cost-operations/references/cloudwatch-alarms.md",
          "type": "blob",
          "size": 13736
        },
        {
          "path": "plugins/aws-cost-ops/skills/aws-cost-operations/references/operations-patterns.md",
          "type": "blob",
          "size": 10477
        },
        {
          "path": "plugins/serverless-eda",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/serverless-eda/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/serverless-eda/skills/aws-serverless-eda",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/serverless-eda/skills/aws-serverless-eda/SKILL.md",
          "type": "blob",
          "size": 21784
        },
        {
          "path": "plugins/serverless-eda/skills/aws-serverless-eda/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/serverless-eda/skills/aws-serverless-eda/references/deployment-best-practices.md",
          "type": "blob",
          "size": 19664
        },
        {
          "path": "plugins/serverless-eda/skills/aws-serverless-eda/references/eda-patterns.md",
          "type": "blob",
          "size": 24678
        },
        {
          "path": "plugins/serverless-eda/skills/aws-serverless-eda/references/observability-best-practices.md",
          "type": "blob",
          "size": 19049
        },
        {
          "path": "plugins/serverless-eda/skills/aws-serverless-eda/references/performance-optimization.md",
          "type": "blob",
          "size": 16776
        },
        {
          "path": "plugins/serverless-eda/skills/aws-serverless-eda/references/security-best-practices.md",
          "type": "blob",
          "size": 15257
        },
        {
          "path": "plugins/serverless-eda/skills/aws-serverless-eda/references/serverless-patterns.md",
          "type": "blob",
          "size": 20841
        }
      ],
      "marketplace": {
        "name": "aws-skills",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "Kane Zhu",
          "email": "me@kane.mx"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "aws-cdk",
            "description": "Comprehensive AWS development skills including CDK best practices, Lambda development workflows, and AWS documentation search capabilities",
            "source": "./plugins/aws-cdk",
            "category": "development",
            "version": "1.1.0",
            "author": {
              "name": "Kane Zhu",
              "email": "me@kane.mx"
            },
            "install_commands": [
              "/plugin marketplace add zxkane/aws-skills",
              "/plugin install aws-cdk@aws-skills"
            ],
            "signals": {
              "stars": 78,
              "forks": 11,
              "pushed_at": "2026-01-08T07:53:13Z",
              "created_at": "2025-10-21T03:56:34Z",
              "license": "MIT"
            },
            "commands": [],
            "skills": [
              {
                "name": "aws-cdk-development",
                "description": "AWS Cloud Development Kit (CDK) expert for building cloud infrastructure with TypeScript/Python. Use when creating CDK stacks, defining CDK constructs, implementing infrastructure as code, or when the user mentions CDK, CloudFormation, IaC, cdk synth, cdk deploy, or wants to define AWS infrastructure programmatically. Covers CDK app structure, construct patterns, stack composition, and deployment workflows.",
                "path": "plugins/aws-cdk/skills/aws-cdk-development/SKILL.md",
                "frontmatter": {
                  "name": "aws-cdk-development",
                  "description": "AWS Cloud Development Kit (CDK) expert for building cloud infrastructure with TypeScript/Python. Use when creating CDK stacks, defining CDK constructs, implementing infrastructure as code, or when the user mentions CDK, CloudFormation, IaC, cdk synth, cdk deploy, or wants to define AWS infrastructure programmatically. Covers CDK app structure, construct patterns, stack composition, and deployment workflows.",
                  "context": "fork",
                  "allowed-tools": [
                    "mcp__cdk__*",
                    "mcp__aws-mcp__*",
                    "mcp__awsdocs__*",
                    "Bash(cdk *)",
                    "Bash(npm *)",
                    "Bash(npx *)",
                    "Bash(aws cloudformation *)",
                    "Bash(aws sts get-caller-identity)"
                  ],
                  "hooks": {
                    "PreToolUse": [
                      {
                        "matcher": "Bash(cdk deploy*)",
                        "command": "aws sts get-caller-identity --query Account --output text",
                        "once": true
                      }
                    ]
                  }
                },
                "content": "# AWS CDK Development\n\nThis skill provides comprehensive guidance for developing AWS infrastructure using the Cloud Development Kit (CDK), with integrated MCP servers for accessing latest AWS knowledge and CDK utilities.\n\n## AWS Documentation Requirement\n\n**CRITICAL**: This skill requires AWS MCP tools for accurate, up-to-date AWS information.\n\n### Before Answering AWS Questions\n\n1. **Always verify** using AWS MCP tools (if available):\n   - `mcp__aws-mcp__aws___search_documentation` or `mcp__*awsdocs*__aws___search_documentation` - Search AWS docs\n   - `mcp__aws-mcp__aws___read_documentation` or `mcp__*awsdocs*__aws___read_documentation` - Read specific pages\n   - `mcp__aws-mcp__aws___get_regional_availability` - Check service availability\n\n2. **If AWS MCP tools are unavailable**:\n   - Guide user to configure AWS MCP: See [AWS MCP Setup Guide](../../docs/aws-mcp-setup.md)\n   - Help determine which option fits their environment:\n     - Has uvx + AWS credentials → Full AWS MCP Server\n     - No Python/credentials → AWS Documentation MCP (no auth)\n   - If cannot determine → Ask user which option to use\n\n## Integrated MCP Servers\n\nThis skill includes the CDK MCP server automatically configured with the plugin:\n\n### AWS CDK MCP Server\n**When to use**: For CDK-specific guidance and utilities\n- Get CDK construct recommendations\n- Retrieve CDK best practices\n- Access CDK pattern suggestions\n- Validate CDK configurations\n- Get help with CDK-specific APIs\n\n**Important**: Leverage this server for CDK construct guidance and advanced CDK operations.\n\n## When to Use This Skill\n\nUse this skill when:\n- Creating new CDK stacks or constructs\n- Refactoring existing CDK infrastructure\n- Implementing Lambda functions within CDK\n- Following AWS CDK best practices\n- Validating CDK stack configurations before deployment\n- Verifying AWS service capabilities and regional availability\n\n## Core CDK Principles\n\n### Resource Naming\n\n**CRITICAL**: Do NOT explicitly specify resource names when they are optional in CDK constructs.\n\n**Why**: CDK-generated names enable:\n- **Reusable patterns**: Deploy the same construct/pattern multiple times without conflicts\n- **Parallel deployments**: Multiple stacks can deploy simultaneously in the same region\n- **Cleaner shared logic**: Patterns and shared code can be initialized multiple times without name collision\n- **Stack isolation**: Each stack gets uniquely identified resources automatically\n\n**Pattern**: Let CDK generate unique names automatically using CloudFormation's naming mechanism.\n\n```typescript\n// ❌ BAD - Explicit naming prevents reusability and parallel deployments\nnew lambda.Function(this, 'MyFunction', {\n  functionName: 'my-lambda',  // Avoid this\n  // ...\n});\n\n// ✅ GOOD - Let CDK generate unique names\nnew lambda.Function(this, 'MyFunction', {\n  // No functionName specified - CDK generates: StackName-MyFunctionXXXXXX\n  // ...\n});\n```\n\n**Security Note**: For different environments (dev, staging, prod), follow AWS Security Pillar best practices by using separate AWS accounts rather than relying on resource naming within a single account. Account-level isolation provides stronger security boundaries.\n\n### Lambda Function Development\n\nUse the appropriate Lambda construct based on runtime:\n\n**TypeScript/JavaScript**: Use `@aws-cdk/aws-lambda-nodejs`\n```typescript\nimport { NodejsFunction } from 'aws-cdk-lib/aws-lambda-nodejs';\n\nnew NodejsFunction(this, 'MyFunction', {\n  entry: 'lambda/handler.ts',\n  handler: 'handler',\n  // Automatically handles bundling, dependencies, and transpilation\n});\n```\n\n**Python**: Use `@aws-cdk/aws-lambda-python`\n```typescript\nimport { PythonFunction } from '@aws-cdk/aws-lambda-python-alpha';\n\nnew PythonFunction(this, 'MyFunction', {\n  entry: 'lambda',\n  index: 'handler.py',\n  handler: 'handler',\n  // Automatically handles dependencies and packaging\n});\n```\n\n**Benefits**:\n- Automatic bundling and dependency management\n- Transpilation handled automatically\n- No manual packaging required\n- Consistent deployment patterns\n\n### Pre-Deployment Validation\n\nUse a **multi-layer validation strategy** for comprehensive CDK quality checks:\n\n#### Layer 1: Real-Time IDE Feedback (Recommended)\n\n**For TypeScript/JavaScript projects**:\n\nInstall [cdk-nag](https://github.com/cdklabs/cdk-nag) for synthesis-time validation:\n```bash\nnpm install --save-dev cdk-nag\n```\n\nAdd to your CDK app:\n```typescript\nimport { Aspects } from 'aws-cdk-lib';\nimport { AwsSolutionsChecks } from 'cdk-nag';\n\nconst app = new App();\nAspects.of(app).add(new AwsSolutionsChecks());\n```\n\n**Optional - VS Code users**: Install [CDK NAG Validator extension](https://marketplace.visualstudio.com/items?itemName=alphacrack.cdk-nag-validator) for faster feedback on file save.\n\n**For Python/Java/C#/Go projects**: cdk-nag is available in all CDK languages and provides the same synthesis-time validation.\n\n#### Layer 2: Synthesis-Time Validation (Required)\n\n1. **Synthesis with cdk-nag**: Validate stack with comprehensive rules\n   ```bash\n   cdk synth  # cdk-nag runs automatically via Aspects\n   ```\n\n2. **Suppress legitimate exceptions** with documented reasons:\n   ```typescript\n   import { NagSuppressions } from 'cdk-nag';\n\n   // Document WHY the exception is needed\n   NagSuppressions.addResourceSuppressions(resource, [\n     {\n       id: 'AwsSolutions-L1',\n       reason: 'Lambda@Edge requires specific runtime for CloudFront compatibility'\n     }\n   ]);\n   ```\n\n#### Layer 3: Pre-Commit Safety Net\n\n1. **Build**: Ensure compilation succeeds\n   ```bash\n   npm run build  # or language-specific build command\n   ```\n\n2. **Tests**: Run unit and integration tests\n   ```bash\n   npm test  # or pytest, mvn test, etc.\n   ```\n\n3. **Validation Script**: Meta-level checks\n   ```bash\n   ./scripts/validate-stack.sh\n   ```\n\nThe validation script now focuses on:\n- Language detection\n- Template size and resource count analysis\n- Synthesis success verification\n- (Note: Detailed anti-pattern checks are handled by cdk-nag)\n\n## Workflow Guidelines\n\n### Development Workflow\n\n1. **Design**: Plan infrastructure resources and relationships\n2. **Verify AWS Services**: Use AWS Documentation MCP to confirm service availability and features\n   - Check regional availability for all required services\n   - Verify service limits and quotas\n   - Confirm latest API specifications\n3. **Implement**: Write CDK constructs following best practices\n   - Use CDK MCP server for construct recommendations\n   - Reference CDK best practices via MCP tools\n4. **Validate**: Run pre-deployment checks (see above)\n5. **Synthesize**: Generate CloudFormation templates\n6. **Review**: Examine synthesized templates for correctness\n7. **Deploy**: Deploy to target environment\n8. **Verify**: Confirm resources are created correctly\n\n### Stack Organization\n\n- Use nested stacks for complex applications\n- Separate concerns into logical construct boundaries\n- Export values that other stacks may need\n- Use CDK context for environment-specific configuration\n\n### Testing Strategy\n\n- Unit test individual constructs\n- Integration test stack synthesis\n- Snapshot test CloudFormation templates\n- Validate resource properties and relationships\n\n## Using MCP Servers Effectively\n\n### When to Use AWS Documentation MCP\n\n**Always verify before implementing**:\n- New AWS service features or configurations\n- Service availability in target regions\n- API parameter specifications\n- Service limits and quotas\n- Security best practices for AWS services\n\n**Example scenarios**:\n- \"Check if Lambda supports Python 3.13 runtime\"\n- \"Verify DynamoDB is available in eu-south-2\"\n- \"What are the current Lambda timeout limits?\"\n- \"Get latest S3 encryption options\"\n\n### When to Use CDK MCP Server\n\n**Leverage for CDK-specific guidance**:\n- CDK construct selection and usage\n- CDK API parameter options\n- CDK best practice patterns\n- Construct property configurations\n- CDK-specific optimizations\n\n**Example scenarios**:\n- \"What's the recommended CDK construct for API Gateway REST API?\"\n- \"How to configure NodejsFunction bundling options?\"\n- \"Best practices for CDK stack organization\"\n- \"CDK construct for DynamoDB with auto-scaling\"\n\n### MCP Usage Best Practices\n\n1. **Verify First**: Always check AWS Documentation MCP before implementing new features\n2. **Regional Validation**: Check service availability in target deployment regions\n3. **CDK Guidance**: Use CDK MCP for construct-specific recommendations\n4. **Stay Current**: MCP servers provide latest information beyond knowledge cutoff\n5. **Combine Sources**: Use both skill patterns and MCP servers for comprehensive guidance\n\n## CDK Patterns Reference\n\nFor detailed CDK patterns, anti-patterns, and architectural guidance, refer to the comprehensive reference:\n\n**File**: `references/cdk-patterns.md`\n\nThis reference includes:\n- Common CDK patterns and their use cases\n- Anti-patterns to avoid\n- Security best practices\n- Cost optimization strategies\n- Performance considerations\n\n## Additional Resources\n\n- **Validation Script**: `scripts/validate-stack.sh` - Pre-deployment validation\n- **CDK Patterns**: `references/cdk-patterns.md` - Detailed pattern library\n- **AWS Documentation MCP**: Integrated for latest AWS information\n- **CDK MCP Server**: Integrated for CDK-specific guidance\n\n## GitHub Actions Integration\n\nWhen GitHub Actions workflow files exist in the repository, ensure all checks defined in `.github/workflows/` pass before committing. This prevents CI/CD failures and maintains code quality standards."
              }
            ]
          },
          {
            "name": "aws-cost-ops",
            "description": "AWS cost optimization, monitoring, and operational excellence with integrated MCP servers for billing, cost analysis, observability, and security assessment",
            "source": "./plugins/aws-cost-ops",
            "category": "operations",
            "version": "1.1.0",
            "author": {
              "name": "Kane Zhu",
              "email": "me@kane.mx"
            },
            "install_commands": [
              "/plugin marketplace add zxkane/aws-skills",
              "/plugin install aws-cost-ops@aws-skills"
            ],
            "signals": {
              "stars": 78,
              "forks": 11,
              "pushed_at": "2026-01-08T07:53:13Z",
              "created_at": "2025-10-21T03:56:34Z",
              "license": "MIT"
            },
            "commands": [],
            "skills": [
              {
                "name": "aws-cost-operations",
                "description": "This skill provides AWS cost optimization, monitoring, and operational best practices with integrated MCP servers for billing analysis, cost estimation, observability, and security assessment.",
                "path": "plugins/aws-cost-ops/skills/aws-cost-operations/SKILL.md",
                "frontmatter": {
                  "name": "aws-cost-operations",
                  "description": "This skill provides AWS cost optimization, monitoring, and operational best practices with integrated MCP servers for billing analysis, cost estimation, observability, and security assessment.",
                  "allowed-tools": [
                    "mcp__pricing__*",
                    "mcp__costexp__*",
                    "mcp__cw__*",
                    "mcp__aws-mcp__*",
                    "mcp__awsdocs__*",
                    "Bash(aws ce *)",
                    "Bash(aws cloudwatch *)",
                    "Bash(aws logs *)",
                    "Bash(aws budgets *)",
                    "Bash(aws cloudtrail *)",
                    "Bash(aws sts get-caller-identity)"
                  ],
                  "hooks": {
                    "PreToolUse": [
                      {
                        "matcher": "Bash(aws ce *)",
                        "command": "aws sts get-caller-identity --query Account --output text",
                        "once": true
                      }
                    ]
                  }
                },
                "content": "# AWS Cost & Operations\n\nThis skill provides comprehensive guidance for AWS cost optimization, monitoring, observability, and operational excellence with integrated MCP servers.\n\n## AWS Documentation Requirement\n\n**CRITICAL**: This skill requires AWS MCP tools for accurate, up-to-date AWS information.\n\n### Before Answering AWS Questions\n\n1. **Always verify** using AWS MCP tools (if available):\n   - `mcp__aws-mcp__aws___search_documentation` or `mcp__*awsdocs*__aws___search_documentation` - Search AWS docs\n   - `mcp__aws-mcp__aws___read_documentation` or `mcp__*awsdocs*__aws___read_documentation` - Read specific pages\n   - `mcp__aws-mcp__aws___get_regional_availability` - Check service availability\n\n2. **If AWS MCP tools are unavailable**:\n   - Guide user to configure AWS MCP: See [AWS MCP Setup Guide](../../docs/aws-mcp-setup.md)\n   - Help determine which option fits their environment:\n     - Has uvx + AWS credentials → Full AWS MCP Server\n     - No Python/credentials → AWS Documentation MCP (no auth)\n   - If cannot determine → Ask user which option to use\n\n## Integrated MCP Servers\n\nThis skill includes 8 MCP servers automatically configured with the plugin:\n\n### Cost Management Servers\n\n#### 1. AWS Billing and Cost Management MCP Server\n**Purpose**: Real-time billing and cost management\n- View current AWS spending and trends\n- Analyze billing details across services\n- Track budget utilization\n- Monitor cost allocation tags\n- Review consolidated billing for organizations\n\n#### 2. AWS Pricing MCP Server\n**Purpose**: Pre-deployment cost estimation and optimization\n- Estimate costs before deploying resources\n- Compare pricing across regions\n- Calculate Total Cost of Ownership (TCO)\n- Evaluate different service options for cost efficiency\n- Get current pricing information for AWS services\n\n#### 3. AWS Cost Explorer MCP Server\n**Purpose**: Detailed cost analysis and reporting\n- Analyze historical spending patterns\n- Create custom cost reports\n- Identify cost anomalies and trends\n- Forecast future costs\n- Analyze cost by service, region, or tag\n- Generate cost optimization recommendations\n\n### Monitoring & Observability Servers\n\n#### 4. Amazon CloudWatch MCP Server\n**Purpose**: Metrics, alarms, and logs analysis\n- Query CloudWatch metrics and logs\n- Create and manage CloudWatch alarms\n- Analyze application performance metrics\n- Troubleshoot operational issues\n- Set up custom dashboards\n- Monitor resource utilization\n\n#### 5. Amazon CloudWatch Application Signals MCP Server\n**Purpose**: Application monitoring and performance insights\n- Monitor application health and performance\n- Analyze service-level objectives (SLOs)\n- Track application dependencies\n- Identify performance bottlenecks\n- Monitor service map and traces\n\n#### 6. AWS Managed Prometheus MCP Server\n**Purpose**: Prometheus-compatible monitoring\n- Query Prometheus metrics\n- Monitor containerized applications\n- Analyze Kubernetes workload metrics\n- Create PromQL queries\n- Track custom application metrics\n\n### Audit & Security Servers\n\n#### 7. AWS CloudTrail MCP Server\n**Purpose**: AWS API activity and audit analysis\n- Analyze AWS API calls and user activity\n- Track resource changes and modifications\n- Investigate security incidents\n- Audit compliance requirements\n- Identify unusual access patterns\n- Review who made what changes when\n\n#### 8. AWS Well-Architected Security Assessment Tool MCP Server\n**Purpose**: Security assessment against Well-Architected Framework\n- Assess security posture against AWS best practices\n- Identify security gaps and vulnerabilities\n- Get security improvement recommendations\n- Review security pillar compliance\n- Generate security assessment reports\n\n## When to Use This Skill\n\nUse this skill when:\n- Optimizing AWS costs and reducing spending\n- Estimating costs before deployment\n- Monitoring application and infrastructure performance\n- Setting up observability and alerting\n- Analyzing spending patterns and trends\n- Investigating operational issues\n- Auditing AWS activity and changes\n- Assessing security posture\n- Implementing operational excellence\n\n## Cost Optimization Best Practices\n\n### Pre-Deployment Cost Estimation\n\n**Always estimate costs before deploying**:\n1. Use **AWS Pricing MCP** to estimate resource costs\n2. Compare pricing across different regions\n3. Evaluate alternative service options\n4. Calculate expected monthly costs\n5. Plan for scaling and growth\n\n**Example workflow**:\n```\n\"Estimate the monthly cost of running a Lambda function with\n1 million invocations, 512MB memory, 3-second duration in us-east-1\"\n```\n\n### Cost Analysis and Optimization\n\n**Regular cost reviews**:\n1. Use **Cost Explorer MCP** to analyze spending trends\n2. Identify cost anomalies and unexpected charges\n3. Review costs by service, region, and environment\n4. Compare actual vs. budgeted costs\n5. Generate cost optimization recommendations\n\n**Cost optimization strategies**:\n- Right-size over-provisioned resources\n- Use appropriate storage classes (S3, EBS)\n- Implement auto-scaling for dynamic workloads\n- Leverage Savings Plans and Reserved Instances\n- Delete unused resources and snapshots\n- Use cost allocation tags effectively\n\n### Budget Monitoring\n\n**Track spending against budgets**:\n1. Use **Billing and Cost Management MCP** to monitor budgets\n2. Set up budget alerts for threshold breaches\n3. Review budget utilization regularly\n4. Adjust budgets based on trends\n5. Implement cost controls and governance\n\n## Monitoring and Observability Best Practices\n\n### CloudWatch Metrics and Alarms\n\n**Implement comprehensive monitoring**:\n1. Use **CloudWatch MCP** to query metrics and logs\n2. Set up alarms for critical metrics:\n   - CPU and memory utilization\n   - Error rates and latency\n   - Queue depths and processing times\n   - API gateway throttling\n   - Lambda errors and timeouts\n3. Create CloudWatch dashboards for visualization\n4. Use log insights for troubleshooting\n\n**Example alarm scenarios**:\n- Lambda error rate > 1%\n- EC2 CPU utilization > 80%\n- API Gateway 4xx/5xx error spike\n- DynamoDB throttled requests\n- ECS task failures\n\n### Application Performance Monitoring\n\n**Monitor application health**:\n1. Use **CloudWatch Application Signals MCP** for APM\n2. Track service-level objectives (SLOs)\n3. Monitor application dependencies\n4. Identify performance bottlenecks\n5. Set up distributed tracing\n\n### Container and Kubernetes Monitoring\n\n**For containerized workloads**:\n1. Use **AWS Managed Prometheus MCP** for metrics\n2. Monitor container resource utilization\n3. Track pod and node health\n4. Create PromQL queries for custom metrics\n5. Set up alerts for container anomalies\n\n## Audit and Security Best Practices\n\n### CloudTrail Activity Analysis\n\n**Audit AWS activity**:\n1. Use **CloudTrail MCP** to analyze API activity\n2. Track who made changes to resources\n3. Investigate security incidents\n4. Monitor for suspicious activity patterns\n5. Audit compliance with policies\n\n**Common audit scenarios**:\n- \"Who deleted this S3 bucket?\"\n- \"Show all IAM role changes in the last 24 hours\"\n- \"List failed login attempts\"\n- \"Find all actions by a specific user\"\n- \"Track modifications to security groups\"\n\n### Security Assessment\n\n**Regular security reviews**:\n1. Use **Well-Architected Security Assessment MCP**\n2. Assess security posture against best practices\n3. Identify security gaps and vulnerabilities\n4. Implement recommended security improvements\n5. Document security compliance\n\n**Security assessment areas**:\n- Identity and Access Management (IAM)\n- Detective controls and monitoring\n- Infrastructure protection\n- Data protection and encryption\n- Incident response preparedness\n\n## Using MCP Servers Effectively\n\n### Cost Analysis Workflow\n\n1. **Pre-deployment**: Use Pricing MCP to estimate costs\n2. **Post-deployment**: Use Billing MCP to track actual spending\n3. **Analysis**: Use Cost Explorer MCP for detailed cost analysis\n4. **Optimization**: Implement recommendations from Cost Explorer\n\n### Monitoring Workflow\n\n1. **Setup**: Configure CloudWatch metrics and alarms\n2. **Monitor**: Use CloudWatch MCP to track key metrics\n3. **Analyze**: Use Application Signals for APM insights\n4. **Troubleshoot**: Query CloudWatch Logs for issue resolution\n\n### Security Workflow\n\n1. **Audit**: Use CloudTrail MCP to review activity\n2. **Assess**: Use Well-Architected Security Assessment\n3. **Remediate**: Implement security recommendations\n4. **Monitor**: Track security events via CloudWatch\n\n### MCP Usage Best Practices\n\n1. **Cost Awareness**: Check pricing before deploying resources\n2. **Proactive Monitoring**: Set up alarms for critical metrics\n3. **Regular Reviews**: Analyze costs and performance weekly\n4. **Audit Trails**: Review CloudTrail logs for compliance\n5. **Security First**: Run security assessments regularly\n6. **Optimize Continuously**: Act on cost and performance recommendations\n\n## Operational Excellence Guidelines\n\n### Cost Optimization\n\n- **Tag Everything**: Use consistent cost allocation tags\n- **Review Monthly**: Analyze spending trends and anomalies\n- **Right-size**: Match resources to actual usage\n- **Automate**: Use auto-scaling and scheduling\n- **Monitor Budgets**: Set alerts for cost overruns\n\n### Monitoring and Alerting\n\n- **Critical Metrics**: Alert on business-critical metrics\n- **Noise Reduction**: Fine-tune thresholds to reduce false positives\n- **Actionable Alerts**: Ensure alerts have clear remediation steps\n- **Dashboard Visibility**: Create dashboards for key stakeholders\n- **Log Retention**: Balance cost and compliance needs\n\n### Security and Compliance\n\n- **Least Privilege**: Grant minimum required permissions\n- **Audit Regularly**: Review CloudTrail logs for anomalies\n- **Encrypt Data**: Use encryption at rest and in transit\n- **Assess Continuously**: Run security assessments frequently\n- **Incident Response**: Have procedures for security events\n\n## Additional Resources\n\nFor detailed operational patterns and best practices, refer to the comprehensive reference:\n\n**File**: `references/operations-patterns.md`\n\nThis reference includes:\n- Cost optimization strategies\n- Monitoring and alerting patterns\n- Observability best practices\n- Security and compliance guidelines\n- Troubleshooting workflows\n\n## CloudWatch Alarms Reference\n\n**File**: `references/cloudwatch-alarms.md`\n\nCommon alarm configurations for:\n- Lambda functions\n- EC2 instances\n- RDS databases\n- DynamoDB tables\n- API Gateway\n- ECS services\n- Application Load Balancers"
              }
            ]
          },
          {
            "name": "serverless-eda",
            "description": "AWS serverless and event-driven architecture best practices based on Well-Architected Framework with MCP servers for SAM, Lambda, Step Functions, and messaging",
            "source": "./plugins/serverless-eda",
            "category": "development",
            "version": "1.1.0",
            "author": {
              "name": "Kane Zhu",
              "email": "me@kane.mx"
            },
            "install_commands": [
              "/plugin marketplace add zxkane/aws-skills",
              "/plugin install serverless-eda@aws-skills"
            ],
            "signals": {
              "stars": 78,
              "forks": 11,
              "pushed_at": "2026-01-08T07:53:13Z",
              "created_at": "2025-10-21T03:56:34Z",
              "license": "MIT"
            },
            "commands": [],
            "skills": [
              {
                "name": "aws-serverless-eda",
                "description": "AWS serverless and event-driven architecture expert based on Well-Architected Framework. Use when building serverless APIs, Lambda functions, REST APIs, microservices, or async workflows. Covers Lambda with TypeScript/Python, API Gateway (REST/HTTP), DynamoDB, Step Functions, EventBridge, SQS, SNS, and serverless patterns. Essential when user mentions serverless, Lambda, API Gateway, event-driven, async processing, queues, pub/sub, or wants to build scalable serverless applications with AWS best practices.",
                "path": "plugins/serverless-eda/skills/aws-serverless-eda/SKILL.md",
                "frontmatter": {
                  "name": "aws-serverless-eda",
                  "description": "AWS serverless and event-driven architecture expert based on Well-Architected Framework. Use when building serverless APIs, Lambda functions, REST APIs, microservices, or async workflows. Covers Lambda with TypeScript/Python, API Gateway (REST/HTTP), DynamoDB, Step Functions, EventBridge, SQS, SNS, and serverless patterns. Essential when user mentions serverless, Lambda, API Gateway, event-driven, async processing, queues, pub/sub, or wants to build scalable serverless applications with AWS best practices.",
                  "context": "fork",
                  "skills": [
                    "aws-cdk-development"
                  ],
                  "allowed-tools": [
                    "mcp__aws-mcp__*",
                    "mcp__awsdocs__*",
                    "mcp__cdk__*",
                    "Bash(sam *)",
                    "Bash(aws lambda *)",
                    "Bash(aws apigateway *)",
                    "Bash(aws apigatewayv2 *)",
                    "Bash(aws dynamodb *)",
                    "Bash(aws stepfunctions *)",
                    "Bash(aws events *)",
                    "Bash(aws sqs *)",
                    "Bash(aws sns *)",
                    "Bash(aws sts get-caller-identity)"
                  ],
                  "hooks": {
                    "PreToolUse": [
                      {
                        "matcher": "Bash(sam deploy*)",
                        "command": "aws sts get-caller-identity --query Account --output text",
                        "once": true
                      }
                    ]
                  }
                },
                "content": "# AWS Serverless & Event-Driven Architecture\n\nThis skill provides comprehensive guidance for building serverless applications and event-driven architectures on AWS based on Well-Architected Framework principles.\n\n## AWS Documentation Requirement\n\n**CRITICAL**: This skill requires AWS MCP tools for accurate, up-to-date AWS information.\n\n### Before Answering AWS Questions\n\n1. **Always verify** using AWS MCP tools (if available):\n   - `mcp__aws-mcp__aws___search_documentation` or `mcp__*awsdocs*__aws___search_documentation` - Search AWS docs\n   - `mcp__aws-mcp__aws___read_documentation` or `mcp__*awsdocs*__aws___read_documentation` - Read specific pages\n   - `mcp__aws-mcp__aws___get_regional_availability` - Check service availability\n\n2. **If AWS MCP tools are unavailable**:\n   - Guide user to configure AWS MCP: See [AWS MCP Setup Guide](../../docs/aws-mcp-setup.md)\n   - Help determine which option fits their environment:\n     - Has uvx + AWS credentials → Full AWS MCP Server\n     - No Python/credentials → AWS Documentation MCP (no auth)\n   - If cannot determine → Ask user which option to use\n\n## Serverless MCP Servers\n\nThis skill can leverage serverless-specific MCP servers for enhanced development workflows:\n\n### AWS Serverless MCP Server\n**Purpose**: Complete serverless application lifecycle with SAM CLI\n- Initialize new serverless applications\n- Deploy serverless applications\n- Test Lambda functions locally\n- Generate SAM templates\n- Manage serverless application lifecycle\n\n### AWS Lambda Tool MCP Server\n**Purpose**: Execute Lambda functions as tools\n- Invoke Lambda functions directly\n- Test Lambda integrations\n- Execute workflows requiring private resource access\n- Run Lambda-based automation\n\n### AWS Step Functions MCP Server\n**Purpose**: Execute complex workflows and orchestration\n- Create and manage state machines\n- Execute workflow orchestrations\n- Handle distributed transactions\n- Implement saga patterns\n- Coordinate microservices\n\n### Amazon SNS/SQS MCP Server\n**Purpose**: Event-driven messaging and queue management\n- Publish messages to SNS topics\n- Send/receive messages from SQS queues\n- Manage event-driven communication\n- Implement pub/sub patterns\n- Handle asynchronous processing\n\n## When to Use This Skill\n\nUse this skill when:\n- Building serverless applications with Lambda\n- Designing event-driven architectures\n- Implementing microservices patterns\n- Creating asynchronous processing workflows\n- Orchestrating multi-service transactions\n- Building real-time data processing pipelines\n- Implementing saga patterns for distributed transactions\n- Designing for scale and resilience\n\n## AWS Well-Architected Serverless Design Principles\n\n### 1. Speedy, Simple, Singular\n\n**Functions should be concise and single-purpose**\n\n```typescript\n// ✅ GOOD - Single purpose, focused function\nexport const processOrder = async (event: OrderEvent) => {\n  // Only handles order processing\n  const order = await validateOrder(event);\n  await saveOrder(order);\n  await publishOrderCreatedEvent(order);\n  return { statusCode: 200, body: JSON.stringify({ orderId: order.id }) };\n};\n\n// ❌ BAD - Function does too much\nexport const handleEverything = async (event: any) => {\n  // Handles orders, inventory, payments, shipping...\n  // Too many responsibilities\n};\n```\n\n**Keep functions environmentally efficient and cost-aware**:\n- Minimize cold start times\n- Optimize memory allocation\n- Use provisioned concurrency only when needed\n- Leverage connection reuse\n\n### 2. Think Concurrent Requests, Not Total Requests\n\n**Design for concurrency, not volume**\n\nLambda scales horizontally - design considerations should focus on:\n- Concurrent execution limits\n- Downstream service throttling\n- Shared resource contention\n- Connection pool sizing\n\n```typescript\n// Consider concurrent Lambda executions accessing DynamoDB\nconst table = new dynamodb.Table(this, 'Table', {\n  billingMode: dynamodb.BillingMode.PAY_PER_REQUEST, // Auto-scales with load\n});\n\n// Or with provisioned capacity + auto-scaling\nconst table = new dynamodb.Table(this, 'Table', {\n  billingMode: dynamodb.BillingMode.PROVISIONED,\n  readCapacity: 5,\n  writeCapacity: 5,\n});\n\n// Enable auto-scaling for concurrent load\ntable.autoScaleReadCapacity({ minCapacity: 5, maxCapacity: 100 });\ntable.autoScaleWriteCapacity({ minCapacity: 5, maxCapacity: 100 });\n```\n\n### 3. Share Nothing\n\n**Function runtime environments are short-lived**\n\n```typescript\n// ❌ BAD - Relying on local file system\nexport const handler = async (event: any) => {\n  fs.writeFileSync('/tmp/data.json', JSON.stringify(data)); // Lost after execution\n};\n\n// ✅ GOOD - Use persistent storage\nexport const handler = async (event: any) => {\n  await s3.putObject({\n    Bucket: process.env.BUCKET_NAME,\n    Key: 'data.json',\n    Body: JSON.stringify(data),\n  });\n};\n```\n\n**State management**:\n- Use DynamoDB for persistent state\n- Use Step Functions for workflow state\n- Use ElastiCache for session state\n- Use S3 for file storage\n\n### 4. Assume No Hardware Affinity\n\n**Applications must be hardware-agnostic**\n\nInfrastructure can change without notice:\n- Lambda functions can run on different hardware\n- Container instances can be replaced\n- No assumption about underlying infrastructure\n\n**Design for portability**:\n- Use environment variables for configuration\n- Avoid hardware-specific optimizations\n- Test across different environments\n\n### 5. Orchestrate with State Machines, Not Function Chaining\n\n**Use Step Functions for orchestration**\n\n```typescript\n// ❌ BAD - Lambda function chaining\nexport const handler1 = async (event: any) => {\n  const result = await processStep1(event);\n  await lambda.invoke({\n    FunctionName: 'handler2',\n    Payload: JSON.stringify(result),\n  });\n};\n\n// ✅ GOOD - Step Functions orchestration\nconst stateMachine = new stepfunctions.StateMachine(this, 'OrderWorkflow', {\n  definition: stepfunctions.Chain\n    .start(validateOrder)\n    .next(processPayment)\n    .next(shipOrder)\n    .next(sendConfirmation),\n});\n```\n\n**Benefits of Step Functions**:\n- Visual workflow representation\n- Built-in error handling and retries\n- Execution history and debugging\n- Parallel and sequential execution\n- Service integrations without code\n\n### 6. Use Events to Trigger Transactions\n\n**Event-driven over synchronous request/response**\n\n```typescript\n// Pattern: Event-driven processing\nconst bucket = new s3.Bucket(this, 'DataBucket');\n\nbucket.addEventNotification(\n  s3.EventType.OBJECT_CREATED,\n  new s3n.LambdaDestination(processFunction),\n  { prefix: 'uploads/' }\n);\n\n// Pattern: EventBridge integration\nconst rule = new events.Rule(this, 'OrderRule', {\n  eventPattern: {\n    source: ['orders'],\n    detailType: ['OrderPlaced'],\n  },\n});\n\nrule.addTarget(new targets.LambdaFunction(processOrderFunction));\n```\n\n**Benefits**:\n- Loose coupling between services\n- Asynchronous processing\n- Better fault tolerance\n- Independent scaling\n\n### 7. Design for Failures and Duplicates\n\n**Operations must be idempotent**\n\n```typescript\n// ✅ GOOD - Idempotent operation\nexport const handler = async (event: SQSEvent) => {\n  for (const record of event.Records) {\n    const orderId = JSON.parse(record.body).orderId;\n\n    // Check if already processed (idempotency)\n    const existing = await dynamodb.getItem({\n      TableName: process.env.TABLE_NAME,\n      Key: { orderId },\n    });\n\n    if (existing.Item) {\n      console.log('Order already processed:', orderId);\n      continue; // Skip duplicate\n    }\n\n    // Process order\n    await processOrder(orderId);\n\n    // Mark as processed\n    await dynamodb.putItem({\n      TableName: process.env.TABLE_NAME,\n      Item: { orderId, processedAt: Date.now() },\n    });\n  }\n};\n```\n\n**Implement retry logic with exponential backoff**:\n```typescript\nasync function withRetry<T>(fn: () => Promise<T>, maxRetries = 3): Promise<T> {\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await fn();\n    } catch (error) {\n      if (i === maxRetries - 1) throw error;\n      await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));\n    }\n  }\n  throw new Error('Max retries exceeded');\n}\n```\n\n## Event-Driven Architecture Patterns\n\n### Pattern 1: Event Router (EventBridge)\n\nUse EventBridge for event routing and filtering:\n\n```typescript\n// Create custom event bus\nconst eventBus = new events.EventBus(this, 'AppEventBus', {\n  eventBusName: 'application-events',\n});\n\n// Define event schema\nconst schema = new events.Schema(this, 'OrderSchema', {\n  schemaName: 'OrderPlaced',\n  definition: events.SchemaDefinition.fromInline({\n    openapi: '3.0.0',\n    info: { version: '1.0.0', title: 'Order Events' },\n    paths: {},\n    components: {\n      schemas: {\n        OrderPlaced: {\n          type: 'object',\n          properties: {\n            orderId: { type: 'string' },\n            customerId: { type: 'string' },\n            amount: { type: 'number' },\n          },\n        },\n      },\n    },\n  }),\n});\n\n// Create rules for different consumers\nnew events.Rule(this, 'ProcessOrderRule', {\n  eventBus,\n  eventPattern: {\n    source: ['orders'],\n    detailType: ['OrderPlaced'],\n  },\n  targets: [new targets.LambdaFunction(processOrderFunction)],\n});\n\nnew events.Rule(this, 'NotifyCustomerRule', {\n  eventBus,\n  eventPattern: {\n    source: ['orders'],\n    detailType: ['OrderPlaced'],\n  },\n  targets: [new targets.LambdaFunction(notifyCustomerFunction)],\n});\n```\n\n### Pattern 2: Queue-Based Processing (SQS)\n\nUse SQS for reliable asynchronous processing:\n\n```typescript\n// Standard queue for at-least-once delivery\nconst queue = new sqs.Queue(this, 'ProcessingQueue', {\n  visibilityTimeout: Duration.seconds(300),\n  retentionPeriod: Duration.days(14),\n  deadLetterQueue: {\n    queue: dlq,\n    maxReceiveCount: 3,\n  },\n});\n\n// FIFO queue for ordered processing\nconst fifoQueue = new sqs.Queue(this, 'OrderedQueue', {\n  fifo: true,\n  contentBasedDeduplication: true,\n  deduplicationScope: sqs.DeduplicationScope.MESSAGE_GROUP,\n});\n\n// Lambda consumer\nnew lambda.EventSourceMapping(this, 'QueueConsumer', {\n  target: processingFunction,\n  eventSourceArn: queue.queueArn,\n  batchSize: 10,\n  maxBatchingWindow: Duration.seconds(5),\n});\n```\n\n### Pattern 3: Pub/Sub (SNS + SQS Fan-Out)\n\nImplement fan-out pattern for multiple consumers:\n\n```typescript\n// Create SNS topic\nconst topic = new sns.Topic(this, 'OrderTopic', {\n  displayName: 'Order Events',\n});\n\n// Multiple SQS queues subscribe to topic\nconst inventoryQueue = new sqs.Queue(this, 'InventoryQueue');\nconst shippingQueue = new sqs.Queue(this, 'ShippingQueue');\nconst analyticsQueue = new sqs.Queue(this, 'AnalyticsQueue');\n\ntopic.addSubscription(new subscriptions.SqsSubscription(inventoryQueue));\ntopic.addSubscription(new subscriptions.SqsSubscription(shippingQueue));\ntopic.addSubscription(new subscriptions.SqsSubscription(analyticsQueue));\n\n// Each queue has its own Lambda consumer\nnew lambda.EventSourceMapping(this, 'InventoryConsumer', {\n  target: inventoryFunction,\n  eventSourceArn: inventoryQueue.queueArn,\n});\n```\n\n### Pattern 4: Saga Pattern with Step Functions\n\nImplement distributed transactions:\n\n```typescript\nconst reserveFlight = new tasks.LambdaInvoke(this, 'ReserveFlight', {\n  lambdaFunction: reserveFlightFunction,\n  outputPath: '$.Payload',\n});\n\nconst reserveHotel = new tasks.LambdaInvoke(this, 'ReserveHotel', {\n  lambdaFunction: reserveHotelFunction,\n  outputPath: '$.Payload',\n});\n\nconst processPayment = new tasks.LambdaInvoke(this, 'ProcessPayment', {\n  lambdaFunction: processPaymentFunction,\n  outputPath: '$.Payload',\n});\n\n// Compensating transactions\nconst cancelFlight = new tasks.LambdaInvoke(this, 'CancelFlight', {\n  lambdaFunction: cancelFlightFunction,\n});\n\nconst cancelHotel = new tasks.LambdaInvoke(this, 'CancelHotel', {\n  lambdaFunction: cancelHotelFunction,\n});\n\n// Define saga with compensation\nconst definition = reserveFlight\n  .next(reserveHotel)\n  .next(processPayment)\n  .addCatch(cancelHotel.next(cancelFlight), {\n    resultPath: '$.error',\n  });\n\nnew stepfunctions.StateMachine(this, 'BookingStateMachine', {\n  definition,\n  timeout: Duration.minutes(5),\n});\n```\n\n### Pattern 5: Event Sourcing\n\nStore events as source of truth:\n\n```typescript\n// Event store with DynamoDB\nconst eventStore = new dynamodb.Table(this, 'EventStore', {\n  partitionKey: { name: 'aggregateId', type: dynamodb.AttributeType.STRING },\n  sortKey: { name: 'version', type: dynamodb.AttributeType.NUMBER },\n  stream: dynamodb.StreamViewType.NEW_IMAGE,\n});\n\n// Lambda function stores events\nexport const handleCommand = async (event: any) => {\n  const { aggregateId, eventType, eventData } = event;\n\n  // Get current version\n  const items = await dynamodb.query({\n    TableName: process.env.EVENT_STORE,\n    KeyConditionExpression: 'aggregateId = :id',\n    ExpressionAttributeValues: { ':id': aggregateId },\n    ScanIndexForward: false,\n    Limit: 1,\n  });\n\n  const nextVersion = items.Items?.[0]?.version + 1 || 1;\n\n  // Append new event\n  await dynamodb.putItem({\n    TableName: process.env.EVENT_STORE,\n    Item: {\n      aggregateId,\n      version: nextVersion,\n      eventType,\n      eventData,\n      timestamp: Date.now(),\n    },\n  });\n};\n\n// Projections read from event stream\neventStore.grantStreamRead(projectionFunction);\n```\n\n## Serverless Architecture Patterns\n\n### Pattern 1: API-Driven Microservices\n\nREST APIs with Lambda backend:\n\n```typescript\nconst api = new apigateway.RestApi(this, 'Api', {\n  restApiName: 'microservices-api',\n  deployOptions: {\n    throttlingRateLimit: 1000,\n    throttlingBurstLimit: 2000,\n    tracingEnabled: true,\n  },\n});\n\n// User service\nconst users = api.root.addResource('users');\nusers.addMethod('GET', new apigateway.LambdaIntegration(getUsersFunction));\nusers.addMethod('POST', new apigateway.LambdaIntegration(createUserFunction));\n\n// Order service\nconst orders = api.root.addResource('orders');\norders.addMethod('GET', new apigateway.LambdaIntegration(getOrdersFunction));\norders.addMethod('POST', new apigateway.LambdaIntegration(createOrderFunction));\n```\n\n### Pattern 2: Stream Processing\n\nReal-time data processing with Kinesis:\n\n```typescript\nconst stream = new kinesis.Stream(this, 'DataStream', {\n  shardCount: 2,\n  retentionPeriod: Duration.days(7),\n});\n\n// Lambda processes stream records\nnew lambda.EventSourceMapping(this, 'StreamProcessor', {\n  target: processFunction,\n  eventSourceArn: stream.streamArn,\n  batchSize: 100,\n  maxBatchingWindow: Duration.seconds(5),\n  parallelizationFactor: 10,\n  startingPosition: lambda.StartingPosition.LATEST,\n  retryAttempts: 3,\n  bisectBatchOnError: true,\n  onFailure: new lambdaDestinations.SqsDestination(dlq),\n});\n```\n\n### Pattern 3: Async Task Processing\n\nBackground job processing:\n\n```typescript\n// SQS queue for tasks\nconst taskQueue = new sqs.Queue(this, 'TaskQueue', {\n  visibilityTimeout: Duration.minutes(5),\n  receiveMessageWaitTime: Duration.seconds(20), // Long polling\n  deadLetterQueue: {\n    queue: dlq,\n    maxReceiveCount: 3,\n  },\n});\n\n// Lambda worker processes tasks\nconst worker = new lambda.Function(this, 'TaskWorker', {\n  // ... configuration\n  reservedConcurrentExecutions: 10, // Control concurrency\n});\n\nnew lambda.EventSourceMapping(this, 'TaskConsumer', {\n  target: worker,\n  eventSourceArn: taskQueue.queueArn,\n  batchSize: 10,\n  reportBatchItemFailures: true, // Partial batch failure handling\n});\n```\n\n### Pattern 4: Scheduled Jobs\n\nPeriodic processing with EventBridge:\n\n```typescript\n// Daily cleanup job\nnew events.Rule(this, 'DailyCleanup', {\n  schedule: events.Schedule.cron({ hour: '2', minute: '0' }),\n  targets: [new targets.LambdaFunction(cleanupFunction)],\n});\n\n// Process every 5 minutes\nnew events.Rule(this, 'FrequentProcessing', {\n  schedule: events.Schedule.rate(Duration.minutes(5)),\n  targets: [new targets.LambdaFunction(processFunction)],\n});\n```\n\n### Pattern 5: Webhook Processing\n\nHandle external webhooks:\n\n```typescript\n// API Gateway endpoint for webhooks\nconst webhookApi = new apigateway.RestApi(this, 'WebhookApi', {\n  restApiName: 'webhooks',\n});\n\nconst webhook = webhookApi.root.addResource('webhook');\nwebhook.addMethod('POST', new apigateway.LambdaIntegration(webhookFunction, {\n  proxy: true,\n  timeout: Duration.seconds(29), // API Gateway max\n}));\n\n// Lambda handler validates and queues webhook\nexport const handler = async (event: APIGatewayProxyEvent) => {\n  // Validate webhook signature\n  const isValid = validateSignature(event.headers, event.body);\n  if (!isValid) {\n    return { statusCode: 401, body: 'Invalid signature' };\n  }\n\n  // Queue for async processing\n  await sqs.sendMessage({\n    QueueUrl: process.env.QUEUE_URL,\n    MessageBody: event.body,\n  });\n\n  // Return immediately\n  return { statusCode: 202, body: 'Accepted' };\n};\n```\n\n## Best Practices\n\n### Error Handling\n\n**Implement comprehensive error handling**:\n\n```typescript\nexport const handler = async (event: SQSEvent) => {\n  const failures: SQSBatchItemFailure[] = [];\n\n  for (const record of event.Records) {\n    try {\n      await processRecord(record);\n    } catch (error) {\n      console.error('Failed to process record:', record.messageId, error);\n      failures.push({ itemIdentifier: record.messageId });\n    }\n  }\n\n  // Return partial batch failures for retry\n  return { batchItemFailures: failures };\n};\n```\n\n### Dead Letter Queues\n\n**Always configure DLQs for error handling**:\n\n```typescript\nconst dlq = new sqs.Queue(this, 'DLQ', {\n  retentionPeriod: Duration.days(14),\n});\n\nconst queue = new sqs.Queue(this, 'Queue', {\n  deadLetterQueue: {\n    queue: dlq,\n    maxReceiveCount: 3,\n  },\n});\n\n// Monitor DLQ depth\nnew cloudwatch.Alarm(this, 'DLQAlarm', {\n  metric: dlq.metricApproximateNumberOfMessagesVisible(),\n  threshold: 1,\n  evaluationPeriods: 1,\n  alarmDescription: 'Messages in DLQ require attention',\n});\n```\n\n### Observability\n\n**Enable tracing and monitoring**:\n\n```typescript\nnew NodejsFunction(this, 'Function', {\n  entry: 'src/handler.ts',\n  tracing: lambda.Tracing.ACTIVE, // X-Ray tracing\n  environment: {\n    POWERTOOLS_SERVICE_NAME: 'order-service',\n    POWERTOOLS_METRICS_NAMESPACE: 'MyApp',\n    LOG_LEVEL: 'INFO',\n  },\n});\n```\n\n## Using MCP Servers Effectively\n\n### AWS Serverless MCP Usage\n\n**Lifecycle management**:\n- Initialize new serverless projects\n- Generate SAM templates\n- Deploy applications\n- Test locally before deployment\n\n### Lambda Tool MCP Usage\n\n**Function execution**:\n- Test Lambda functions directly\n- Execute automation workflows\n- Access private resources\n- Validate integrations\n\n### Step Functions MCP Usage\n\n**Workflow orchestration**:\n- Create state machines for complex workflows\n- Execute distributed transactions\n- Implement saga patterns\n- Coordinate microservices\n\n### SNS/SQS MCP Usage\n\n**Messaging operations**:\n- Test pub/sub patterns\n- Send test messages to queues\n- Validate event routing\n- Debug message processing\n\n## Additional Resources\n\nThis skill includes comprehensive reference documentation based on AWS best practices:\n\n- **Serverless Patterns**: `references/serverless-patterns.md`\n  - Core serverless architectures and API patterns\n  - Data processing and integration patterns\n  - Orchestration with Step Functions\n  - Anti-patterns to avoid\n\n- **Event-Driven Architecture Patterns**: `references/eda-patterns.md`\n  - Event routing and processing patterns\n  - Event sourcing and saga patterns\n  - Idempotency and error handling\n  - Message ordering and deduplication\n\n- **Security Best Practices**: `references/security-best-practices.md`\n  - Shared responsibility model\n  - IAM least privilege patterns\n  - Data protection and encryption\n  - Network security with VPC\n\n- **Observability Best Practices**: `references/observability-best-practices.md`\n  - Three pillars: metrics, logs, traces\n  - Structured logging with Lambda Powertools\n  - X-Ray distributed tracing\n  - CloudWatch alarms and dashboards\n\n- **Performance Optimization**: `references/performance-optimization.md`\n  - Cold start optimization techniques\n  - Memory and CPU optimization\n  - Package size reduction\n  - Provisioned concurrency patterns\n\n- **Deployment Best Practices**: `references/deployment-best-practices.md`\n  - CI/CD pipeline design\n  - Testing strategies (unit, integration, load)\n  - Deployment strategies (canary, blue/green)\n  - Rollback and safety mechanisms\n\n**External Resources**:\n- **AWS Well-Architected Serverless Lens**: https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/\n- **ServerlessLand.com**: Pre-built serverless patterns\n- **AWS Serverless Workshops**: https://serverlessland.com/learn?type=Workshops\n\nFor detailed implementation patterns, anti-patterns, and code examples, refer to the comprehensive references in the skill directory."
              }
            ]
          },
          {
            "name": "aws-agentic-ai",
            "description": "AWS Bedrock AgentCore comprehensive expert for deploying and managing all AgentCore services including Gateway, Runtime, Memory, Identity, Code Interpreter, Browser, and Observability",
            "source": "./plugins/aws-agentic-ai",
            "category": "development",
            "version": "1.1.0",
            "author": {
              "name": "Kane Zhu",
              "email": "me@kane.mx"
            },
            "install_commands": [
              "/plugin marketplace add zxkane/aws-skills",
              "/plugin install aws-agentic-ai@aws-skills"
            ],
            "signals": {
              "stars": 78,
              "forks": 11,
              "pushed_at": "2026-01-08T07:53:13Z",
              "created_at": "2025-10-21T03:56:34Z",
              "license": "MIT"
            },
            "commands": [],
            "skills": [
              {
                "name": "aws-agentic-ai",
                "description": "AWS Bedrock AgentCore comprehensive expert for deploying and managing all AgentCore services. Use when working with Gateway, Runtime, Memory, Identity, or any AgentCore component. Covers MCP target deployment, credential management, schema optimization, runtime configuration, memory management, and identity services.",
                "path": "plugins/aws-agentic-ai/skills/aws-agentic-ai/SKILL.md",
                "frontmatter": {
                  "name": "aws-agentic-ai",
                  "aliases": [
                    "bedrock-agentcore",
                    "aws-agentic-ai"
                  ],
                  "description": "AWS Bedrock AgentCore comprehensive expert for deploying and managing all AgentCore services. Use when working with Gateway, Runtime, Memory, Identity, or any AgentCore component. Covers MCP target deployment, credential management, schema optimization, runtime configuration, memory management, and identity services.",
                  "context": "fork",
                  "model": "sonnet",
                  "allowed-tools": [
                    "mcp__aws-mcp__*",
                    "mcp__awsdocs__*",
                    "Bash(aws bedrock-agentcore-control *)",
                    "Bash(aws bedrock-agentcore-runtime *)",
                    "Bash(aws bedrock *)",
                    "Bash(aws s3 cp *)",
                    "Bash(aws s3 ls *)",
                    "Bash(aws secretsmanager *)",
                    "Bash(aws sts get-caller-identity)"
                  ],
                  "hooks": {
                    "PreToolUse": [
                      {
                        "matcher": "Bash(aws bedrock-agentcore-control create-*)",
                        "command": "aws sts get-caller-identity --query Account --output text",
                        "once": true
                      }
                    ]
                  }
                },
                "content": "# AWS Bedrock AgentCore\n\nAWS Bedrock AgentCore provides a complete platform for deploying and scaling AI agents with seven core services. This skill guides you through service selection, deployment patterns, and integration workflows using AWS CLI.\n\n## AWS Documentation Requirement\n\n**CRITICAL**: This skill requires AWS MCP tools for accurate, up-to-date AWS information.\n\n### Before Answering AWS Questions\n\n1. **Always verify** using AWS MCP tools (if available):\n   - `mcp__aws-mcp__aws___search_documentation` or `mcp__*awsdocs*__aws___search_documentation` - Search AWS docs\n   - `mcp__aws-mcp__aws___read_documentation` or `mcp__*awsdocs*__aws___read_documentation` - Read specific pages\n   - `mcp__aws-mcp__aws___get_regional_availability` - Check service availability\n\n2. **If AWS MCP tools are unavailable**:\n   - Guide user to configure AWS MCP: See [AWS MCP Setup Guide](../../docs/aws-mcp-setup.md)\n   - Help determine which option fits their environment:\n     - Has uvx + AWS credentials → Full AWS MCP Server\n     - No Python/credentials → AWS Documentation MCP (no auth)\n   - If cannot determine → Ask user which option to use\n\n## When to Use This Skill\n\nUse this skill when you need to:\n- Deploy REST APIs as MCP tools for AI agents (Gateway)\n- Execute agents in serverless runtime (Runtime)\n- Add conversation memory to agents (Memory)\n- Manage API credentials and authentication (Identity)\n- Enable agents to execute code securely (Code Interpreter)\n- Allow agents to interact with websites (Browser)\n- Monitor and trace agent performance (Observability)\n\n## Available Services\n\n| Service | Use For | Documentation |\n|---------|---------|---------------|\n| **Gateway** | Converting REST APIs to MCP tools | [`services/gateway/README.md`](services/gateway/README.md) |\n| **Runtime** | Deploying and scaling agents | [`services/runtime/README.md`](services/runtime/README.md) |\n| **Memory** | Managing conversation state | [`services/memory/README.md`](services/memory/README.md) |\n| **Identity** | Credential and access management | [`services/identity/README.md`](services/identity/README.md) |\n| **Code Interpreter** | Secure code execution in sandboxes | [`services/code-interpreter/README.md`](services/code-interpreter/README.md) |\n| **Browser** | Web automation and scraping | [`services/browser/README.md`](services/browser/README.md) |\n| **Observability** | Tracing and monitoring | [`services/observability/README.md`](services/observability/README.md) |\n\n## Common Workflows\n\n### Deploying a Gateway Target\n\n**MANDATORY - READ DETAILED DOCUMENTATION**: See [`services/gateway/README.md`](services/gateway/README.md) for complete Gateway setup guide including deployment strategies, troubleshooting, and IAM configuration.\n\n**Quick Workflow**:\n1. Upload OpenAPI schema to S3\n2. *(API Key auth only)* Create credential provider and store API key\n3. Create gateway target linking schema (and credentials if using API key)\n4. Verify target status and test connectivity\n\n> **Note**: Credential provider is only needed for API key authentication. Lambda targets use IAM roles, and MCP servers use OAuth.\n\n### Managing Credentials\n\n**MANDATORY - READ DETAILED DOCUMENTATION**: See [`cross-service/credential-management.md`](cross-service/credential-management.md) for unified credential management patterns across all services.\n\n**Quick Workflow**:\n1. Use Identity service credential providers for all API keys\n2. Link providers to gateway targets via ARN references\n3. Rotate credentials quarterly through credential provider updates\n4. Monitor usage with CloudWatch metrics\n\n### Monitoring Agents\n\n**MANDATORY - READ DETAILED DOCUMENTATION**: See [`services/observability/README.md`](services/observability/README.md) for comprehensive monitoring setup.\n\n**Quick Workflow**:\n1. Enable observability for agents\n2. Configure CloudWatch dashboards for metrics\n3. Set up alarms for error rates and latency\n4. Use X-Ray for distributed tracing\n\n## Service-Specific Documentation\n\nFor detailed documentation on each AgentCore service, see the following resources:\n\n### Gateway Service\n- **Overview**: [`services/gateway/README.md`](services/gateway/README.md)\n- **Deployment Strategies**: [`services/gateway/deployment-strategies.md`](services/gateway/deployment-strategies.md)\n- **Troubleshooting**: [`services/gateway/troubleshooting-guide.md`](services/gateway/troubleshooting-guide.md)\n\n### Runtime, Memory, Identity, Code Interpreter, Browser, Observability\nEach service has comprehensive documentation in its respective directory:\n- [`services/runtime/README.md`](services/runtime/README.md)\n- [`services/memory/README.md`](services/memory/README.md)\n- [`services/identity/README.md`](services/identity/README.md)\n- [`services/code-interpreter/README.md`](services/code-interpreter/README.md)\n- [`services/browser/README.md`](services/browser/README.md)\n- [`services/observability/README.md`](services/observability/README.md)\n\n## Cross-Service Resources\n\nFor patterns and best practices that span multiple AgentCore services:\n\n- **Credential Management**: [`cross-service/credential-management.md`](cross-service/credential-management.md) - Unified credential patterns, security practices, rotation procedures\n\n## Additional Resources\n\n- **AWS Documentation**: [Amazon Bedrock AgentCore](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/what-is-bedrock-agentcore.html)\n- **API Reference**: [Bedrock AgentCore Control Plane API](https://docs.aws.amazon.com/bedrock-agentcore-control/latest/APIReference/)\n- **AWS CLI Reference**: [bedrock-agentcore-control commands](https://awscli.amazonaws.com/v2/documentation/api/latest/reference/bedrock-agentcore-control/index.html)"
              }
            ]
          }
        ]
      }
    }
  ]
}