{
  "owner": {
    "id": "sjungling",
    "display_name": "Scott Jungling",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/8387?v=4",
    "url": "https://github.com/sjungling",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 6,
      "total_commands": 9,
      "total_skills": 8,
      "total_stars": 6,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "sjungling/claude-plugins",
      "url": "https://github.com/sjungling/claude-plugins",
      "description": "personal collection of Claude Code plugins",
      "homepage": null,
      "signals": {
        "stars": 6,
        "forks": 0,
        "pushed_at": "2025-12-20T22:50:31Z",
        "created_at": "2025-10-10T04:14:44Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 765
        },
        {
          "path": "CLAUDE.md",
          "type": "blob",
          "size": 8545
        },
        {
          "path": "LICENSE",
          "type": "blob",
          "size": 1071
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 60
        },
        {
          "path": "docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/plans",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/plans/2025-11-13-git-bisect-skill-design.md",
          "type": "blob",
          "size": 9084
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 441
        },
        {
          "path": "plugins/claude/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/agents/builder.md",
          "type": "blob",
          "size": 402
        },
        {
          "path": "plugins/claude/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/commands/list-skills.md",
          "type": "blob",
          "size": 1141
        },
        {
          "path": "plugins/claude/commands/review-command.md",
          "type": "blob",
          "size": 2648
        },
        {
          "path": "plugins/claude/commands/review-skill.md",
          "type": "blob",
          "size": 2099
        },
        {
          "path": "plugins/claude/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/skills/builder",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/skills/builder/SKILL.md",
          "type": "blob",
          "size": 14956
        },
        {
          "path": "plugins/claude/skills/builder/assets",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/skills/builder/assets/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/skills/builder/assets/templates/agent-template.md",
          "type": "blob",
          "size": 931
        },
        {
          "path": "plugins/claude/skills/builder/assets/templates/command-template.md",
          "type": "blob",
          "size": 395
        },
        {
          "path": "plugins/claude/skills/builder/assets/templates/plugin.json",
          "type": "blob",
          "size": 340
        },
        {
          "path": "plugins/claude/skills/builder/assets/templates/skill-template.md",
          "type": "blob",
          "size": 1983
        },
        {
          "path": "plugins/claude/skills/builder/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/skills/builder/references/hooks-guide.md",
          "type": "blob",
          "size": 14959
        },
        {
          "path": "plugins/claude/skills/builder/references/plugins-guide.md",
          "type": "blob",
          "size": 15958
        },
        {
          "path": "plugins/claude/skills/builder/references/skills-guide.md",
          "type": "blob",
          "size": 23146
        },
        {
          "path": "plugins/claude/skills/builder/references/slash-commands-guide.md",
          "type": "blob",
          "size": 13414
        },
        {
          "path": "plugins/claude/skills/builder/references/subagents-guide.md",
          "type": "blob",
          "size": 9194
        },
        {
          "path": "plugins/claude/skills/builder/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/skills/builder/scripts/init_plugin.py",
          "type": "blob",
          "size": 5706
        },
        {
          "path": "plugins/claude/skills/builder/scripts/validate_marketplace.py",
          "type": "blob",
          "size": 12609
        },
        {
          "path": "plugins/cli-developer",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cli-developer/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cli-developer/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 365
        },
        {
          "path": "plugins/cli-developer/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cli-developer/agents/cli-ux-designer.md",
          "type": "blob",
          "size": 971
        },
        {
          "path": "plugins/cli-developer/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cli-developer/skills/cli-ux-designer",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cli-developer/skills/cli-ux-designer/SKILL.md",
          "type": "blob",
          "size": 6397
        },
        {
          "path": "plugins/cli-developer/skills/cli-ux-designer/assets",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cli-developer/skills/cli-ux-designer/assets/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cli-developer/skills/cli-ux-designer/assets/examples/help-text-example.txt",
          "type": "blob",
          "size": 1208
        },
        {
          "path": "plugins/cli-developer/skills/cli-ux-designer/assets/examples/interactive-prompt-example.txt",
          "type": "blob",
          "size": 1412
        },
        {
          "path": "plugins/cli-developer/skills/cli-ux-designer/assets/examples/list-view-example.txt",
          "type": "blob",
          "size": 1482
        },
        {
          "path": "plugins/cli-developer/skills/cli-ux-designer/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cli-developer/skills/cli-ux-designer/references/ansi-color-reference.md",
          "type": "blob",
          "size": 7928
        },
        {
          "path": "plugins/cli-developer/skills/cli-ux-designer/references/unicode-symbols.md",
          "type": "blob",
          "size": 13823
        },
        {
          "path": "plugins/openrewrite-author",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/openrewrite-author/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/openrewrite-author/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 453
        },
        {
          "path": "plugins/openrewrite-author/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/openrewrite-author/skills/rewrite-yaml",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/openrewrite-author/skills/rewrite-yaml/SKILL.md",
          "type": "blob",
          "size": 11752
        },
        {
          "path": "plugins/openrewrite-author/skills/rewrite-yaml/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/openrewrite-author/skills/rewrite-yaml/references/jsonpath-patterns.md",
          "type": "blob",
          "size": 16569
        },
        {
          "path": "plugins/openrewrite-author/skills/rewrite-yaml/references/openrewrite-traits-guide.md",
          "type": "blob",
          "size": 11619
        },
        {
          "path": "plugins/openrewrite-author/skills/rewrite-yaml/references/recipe-patterns.md",
          "type": "blob",
          "size": 20758
        },
        {
          "path": "plugins/openrewrite-author/skills/rewrite-yaml/references/recipe-template.java",
          "type": "blob",
          "size": 7987
        },
        {
          "path": "plugins/openrewrite-author/skills/rewrite-yaml/references/testing-patterns.md",
          "type": "blob",
          "size": 20973
        },
        {
          "path": "plugins/openrewrite-author/skills/rewrite-yaml/references/yaml-lst-reference.md",
          "type": "blob",
          "size": 19036
        },
        {
          "path": "plugins/openrewrite-author/skills/rewrite-yaml/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/openrewrite-author/skills/rewrite-yaml/scripts/add_license_header.sh",
          "type": "blob",
          "size": 4170
        },
        {
          "path": "plugins/openrewrite-author/skills/rewrite-yaml/scripts/init_recipe.py",
          "type": "blob",
          "size": 8272
        },
        {
          "path": "plugins/openrewrite-author/skills/rewrite-yaml/scripts/validate_java8.py",
          "type": "blob",
          "size": 4400
        },
        {
          "path": "plugins/openrewrite",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/openrewrite/README.md",
          "type": "blob",
          "size": 11691
        },
        {
          "path": "plugins/openrewrite/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/SKILL.md",
          "type": "blob",
          "size": 37445
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/examples/example-declarative-migration.yml",
          "type": "blob",
          "size": 8474
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/examples/example-say-hello-recipe.java",
          "type": "blob",
          "size": 5623
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/examples/example-scanning-recipe.java",
          "type": "blob",
          "size": 10007
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/examples/example-yaml-github-actions.java",
          "type": "blob",
          "size": 7627
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/references/checklist-recipe-development.md",
          "type": "blob",
          "size": 7912
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/references/common-patterns.md",
          "type": "blob",
          "size": 7546
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/references/java-lst-reference.md",
          "type": "blob",
          "size": 11145
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/references/jsonpath-patterns.md",
          "type": "blob",
          "size": 16569
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/references/trait-implementation-guide.md",
          "type": "blob",
          "size": 11619
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/references/yaml-lst-reference.md",
          "type": "blob",
          "size": 19036
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/scripts/add_license_header.sh",
          "type": "blob",
          "size": 4170
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/scripts/init_recipe.py",
          "type": "blob",
          "size": 8272
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/scripts/validate_recipe.py",
          "type": "blob",
          "size": 11360
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/templates/license-header.txt",
          "type": "blob",
          "size": 581
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/templates/template-declarative-recipe.yml",
          "type": "blob",
          "size": 4008
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/templates/template-imperative-recipe.java",
          "type": "blob",
          "size": 6594
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/templates/template-recipe-test.java",
          "type": "blob",
          "size": 7706
        },
        {
          "path": "plugins/openrewrite/skills/recipe-writer/templates/template-refaster-template.java",
          "type": "blob",
          "size": 4006
        },
        {
          "path": "plugins/swift-engineer",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/swift-engineer/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/swift-engineer/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 453
        },
        {
          "path": "plugins/swift-engineer/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/swift-engineer/agents/ios-swift-expert.md",
          "type": "blob",
          "size": 1584
        },
        {
          "path": "plugins/swift-engineer/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/swift-engineer/commands/swift-lint.md",
          "type": "blob",
          "size": 1950
        },
        {
          "path": "plugins/swift-engineer/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/swift-engineer/skills/ios-swift-expert",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/swift-engineer/skills/ios-swift-expert/SKILL.md",
          "type": "blob",
          "size": 11806
        },
        {
          "path": "plugins/swift-engineer/skills/ios-swift-expert/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/swift-engineer/skills/ios-swift-expert/references/apple-guidelines.md",
          "type": "blob",
          "size": 1671
        },
        {
          "path": "plugins/swift-engineer/skills/ios-swift-expert/references/code-examples.md",
          "type": "blob",
          "size": 4165
        },
        {
          "path": "plugins/swift-engineer/skills/ios-swift-expert/references/debugging-strategies.md",
          "type": "blob",
          "size": 1148
        },
        {
          "path": "plugins/swift-engineer/skills/ios-swift-expert/references/patterns.md",
          "type": "blob",
          "size": 1733
        },
        {
          "path": "plugins/technical-writer",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/technical-writer/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/technical-writer/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 416
        },
        {
          "path": "plugins/technical-writer/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/technical-writer/agents/obsidian-vault-manager.md",
          "type": "blob",
          "size": 298
        },
        {
          "path": "plugins/technical-writer/agents/technical-writer.md",
          "type": "blob",
          "size": 928
        },
        {
          "path": "plugins/technical-writer/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/technical-writer/skills/obsidian-vault-manager",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/technical-writer/skills/obsidian-vault-manager/SKILL.md",
          "type": "blob",
          "size": 6057
        },
        {
          "path": "plugins/technical-writer/skills/obsidian-vault-manager/assets",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/technical-writer/skills/obsidian-vault-manager/assets/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/technical-writer/skills/obsidian-vault-manager/assets/templates/daily-note-template.md",
          "type": "blob",
          "size": 319
        },
        {
          "path": "plugins/technical-writer/skills/obsidian-vault-manager/assets/templates/daily-note.md",
          "type": "blob",
          "size": 235
        },
        {
          "path": "plugins/technical-writer/skills/obsidian-vault-manager/assets/templates/meeting-note-template.md",
          "type": "blob",
          "size": 624
        },
        {
          "path": "plugins/technical-writer/skills/obsidian-vault-manager/assets/templates/meeting.md",
          "type": "blob",
          "size": 453
        },
        {
          "path": "plugins/technical-writer/skills/obsidian-vault-manager/assets/templates/project-note-template.md",
          "type": "blob",
          "size": 758
        },
        {
          "path": "plugins/technical-writer/skills/obsidian-vault-manager/assets/templates/project.md",
          "type": "blob",
          "size": 460
        },
        {
          "path": "plugins/technical-writer/skills/obsidian-vault-manager/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/technical-writer/skills/obsidian-vault-manager/references/obsidian-cli-reference.md",
          "type": "blob",
          "size": 8620
        },
        {
          "path": "plugins/technical-writer/skills/obsidian-vault-manager/references/obsidian-syntax.md",
          "type": "blob",
          "size": 9568
        },
        {
          "path": "plugins/technical-writer/skills/technical-writer",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/technical-writer/skills/technical-writer/SKILL.md",
          "type": "blob",
          "size": 10117
        },
        {
          "path": "plugins/technical-writer/skills/technical-writer/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/technical-writer/skills/technical-writer/references/style-guide.md",
          "type": "blob",
          "size": 16135
        },
        {
          "path": "plugins/technical-writer/skills/technical-writer/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/technical-writer/skills/technical-writer/scripts/validate_markdown.py",
          "type": "blob",
          "size": 8963
        },
        {
          "path": "plugins/workflow",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/workflow/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/workflow/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 359
        },
        {
          "path": "plugins/workflow/SKILL.md",
          "type": "blob",
          "size": 1769
        },
        {
          "path": "plugins/workflow/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/workflow/commands/check-and-resolve.md",
          "type": "blob",
          "size": 6331
        },
        {
          "path": "plugins/workflow/commands/clarify-issue.md",
          "type": "blob",
          "size": 7465
        },
        {
          "path": "plugins/workflow/commands/commit-and-push.md",
          "type": "blob",
          "size": 4526
        },
        {
          "path": "plugins/workflow/commands/fix-issue.md",
          "type": "blob",
          "size": 4902
        },
        {
          "path": "plugins/workflow/commands/pr.md",
          "type": "blob",
          "size": 5231
        },
        {
          "path": "plugins/workflow/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/workflow/skills/git-bisect-debugging",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/workflow/skills/git-bisect-debugging/SKILL.md",
          "type": "blob",
          "size": 22854
        }
      ],
      "marketplace": {
        "name": "claude-plugins",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "Scott",
          "email": "scott.jungling@gmail.com"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "swift-engineer",
            "description": null,
            "source": "./plugins/swift-engineer",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add sjungling/claude-plugins",
              "/plugin install swift-engineer@claude-plugins"
            ],
            "signals": {
              "stars": 6,
              "forks": 0,
              "pushed_at": "2025-12-20T22:50:31Z",
              "created_at": "2025-10-10T04:14:44Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/swift-lint",
                "description": "Format and lint Swift code using swift-format",
                "path": "plugins/swift-engineer/commands/swift-lint.md",
                "frontmatter": {
                  "description": "Format and lint Swift code using swift-format",
                  "allowed-tools": [
                    "Task",
                    "Bash",
                    "Glob",
                    "AskUserQuestion"
                  ]
                },
                "content": "To keep the codebase clean, execute the following workflow:\n\n## Step 1: Check for Periphery\n\nBefore formatting and linting, check if Periphery (unused code detector) is available:\n\n1. Run `which periphery` to check if periphery is installed\n2. If installed, check if the project is configured by looking for:\n   - `.periphery.yml` configuration file in the project root, OR\n   - An Xcode project/workspace file (`.xcodeproj` or `.xcworkspace`)\n\n3. If periphery is installed AND the project has either a `.periphery.yml` config or Xcode project files, use AskUserQuestion to prompt:\n   - Question: \"Periphery is available for detecting unused code. Would you like to run it before formatting and linting?\"\n   - Header: \"Run Periphery\"\n   - Options:\n     - \"Yes\" - \"Run periphery scan first to identify unused code\"\n     - \"No\" - \"Skip periphery and proceed with formatting/linting\"\n\n4. If user selects \"Yes\", launch a general-purpose subagent to run `periphery scan` and report findings. Wait for it to complete before proceeding.\n\n## Step 2: Format and Lint with swift-format\n\nExecute the following workflow using subagents for context isolation:\n\n**IMPORTANT**: Launch TWO separate subagents sequentially. Do NOT run them in parallel. Formatting often fixes issues that would be flagged by the linter, so linting must happen AFTER formatting is complete.\n\n1. First, launch a general-purpose subagent to run `swift-format format --in-place --recursive` to format all Swift code. Wait for it to complete.\n\n2. Then, launch a second general-purpose subagent to run `swift-format lint --recursive` on the project and resolve all remaining lint issues until clean.\n\nUse the Task tool for all subagent steps to keep output isolated from the main agent context.\n\nReport a brief summary of results after all steps are complete."
              }
            ],
            "skills": [
              {
                "name": "ios-swift-expert",
                "description": "Elite iOS and macOS development expertise for Swift, SwiftUI, UIKit, Xcode, and the entire Apple development ecosystem. Automatically activates when working with .swift files, Xcode projects (.xcodeproj, .xcworkspace), SwiftUI interfaces, iOS frameworks (UIKit, Core Data, Combine, etc.), app architecture, or Apple platform development.",
                "path": "plugins/swift-engineer/skills/ios-swift-expert/SKILL.md",
                "frontmatter": {
                  "name": "ios-swift-expert",
                  "description": "Elite iOS and macOS development expertise for Swift, SwiftUI, UIKit, Xcode, and the entire Apple development ecosystem. Automatically activates when working with .swift files, Xcode projects (.xcodeproj, .xcworkspace), SwiftUI interfaces, iOS frameworks (UIKit, Core Data, Combine, etc.), app architecture, or Apple platform development."
                },
                "content": "# iOS and macOS Development Expert\n\n## Overview\n\nElite-level guidance for iOS and macOS development with deep expertise in Swift, SwiftUI, UIKit, and the entire Apple development ecosystem.\n\n**Core principle:** Follow Apple's Human Interface Guidelines, Swift API Design Guidelines, and modern iOS development best practices while writing clean, performant, memory-safe code.\n\n## When to Use\n\nAutomatically activates when:\n- Working with `.swift` source files\n- Opening or modifying Xcode projects (`.xcodeproj`, `.xcworkspace`)\n- Editing SwiftUI views or UIKit view controllers\n- Implementing iOS/macOS frameworks (Core Data, Combine, UIKit, SwiftUI, etc.)\n- Debugging Xcode build errors or runtime issues\n- Designing app architectures (MVVM, MVI, Clean Architecture)\n- Optimizing performance or fixing memory leaks\n- Implementing accessibility, localization, or privacy features\n- Configuring app targets, build settings, or project structure\n\nManual invocation when:\n- User explicitly asks about Swift language features\n- User needs guidance on Apple platform APIs\n- User requests iOS/macOS development best practices\n- User encounters Apple platform-specific problems\n\n## When NOT to Use This Skill\n\nDo not use this skill for:\n- General programming questions unrelated to Apple platforms\n- Backend server development (unless using Vapor/Swift on server)\n- Cross-platform mobile development (React Native, Flutter, Kotlin Multiplatform)\n- Web development (unless WebKit/Safari specific or Swift for WebAssembly)\n- Android development\n- Desktop development on non-Apple platforms\n\n## Core Expertise Areas\n\n### Swift Language Mastery\n\n- **Modern Swift Features**: Value types, protocol-oriented programming, generics, result builders, property wrappers, async/await, actors\n- **Memory Management**: ARC, weak/unowned references, retain cycles, memory graph debugging\n- **Concurrency**: Structured concurrency with async/await, actors, task groups, continuation, legacy GCD patterns\n- **Error Handling**: Proper use of throws, Result type, error propagation, custom error types\n- **Type Safety**: Leveraging Swift's type system for safer code, phantom types, type erasure\n\n### SwiftUI Development\n\n- **Declarative UI**: Views, modifiers, composition, custom view builders\n- **State Management**: @State, @Binding, @ObservedObject, @StateObject, @EnvironmentObject, @Observable (iOS 17+)\n- **Layout System**: VStack, HStack, ZStack, GeometryReader, Layout protocol (iOS 16+), safe areas\n- **Animations**: Implicit animations, explicit animations, transitions, matched geometry effect\n- **Navigation**: NavigationStack (iOS 16+), NavigationPath, programmatic navigation, deep linking\n- **Advanced Patterns**: ViewModifiers, PreferenceKeys, custom environments, coordinators\n\n### UIKit (Legacy & Hybrid Apps)\n\n- **View Controllers**: Lifecycle, containment, custom transitions, adaptive layouts\n- **Auto Layout**: Constraints, stack views, size classes, intrinsic content size\n- **Table/Collection Views**: Data sources, delegates, diffable data sources, compositional layout\n- **Gestures**: Tap, swipe, pan, long press, custom gesture recognizers\n- **Core Animation**: Layer animations, keyframe animations, CADisplayLink\n- **Integration**: Bridging UIKit and SwiftUI with UIViewRepresentable/UIViewControllerRepresentable\n\n### iOS Frameworks & APIs\n\n- **Core Data**: Managed object context, fetch requests, predicates, migrations, relationships\n- **Combine**: Publishers, subscribers, operators, cancellables, error handling, backpressure\n- **Core Location**: Location services, geofencing, heading, privacy best practices\n- **CloudKit**: Public/private databases, records, subscriptions, sharing\n- **StoreKit**: In-app purchases, subscriptions, transaction handling, receipt validation\n- **HealthKit, HomeKit, ARKit, RealityKit**: Domain-specific framework expertise\n\n### Xcode & Build System\n\n- **Project Structure**: Targets, schemes, configurations, build phases, script phases\n- **Build Settings**: Optimization levels, code signing, provisioning profiles, entitlements\n- **Debugging Tools**: LLDB, breakpoints, view debugging, Instruments, memory graph debugger\n- **Testing**: XCTest, UI testing, performance testing, test plans, code coverage\n- **Swift Package Manager**: Package manifests, dependencies, versioning, local packages\n\n### App Architecture\n\n- **MVVM**: Model-View-ViewModel with SwiftUI or UIKit\n- **MVI**: Model-View-Intent unidirectional data flow\n- **Clean Architecture**: Layered separation, dependency injection, testability\n- **Coordinator Pattern**: Navigation flow management\n- **Repository Pattern**: Data layer abstraction\n- **Design Patterns**: Factory, observer, strategy, dependency injection containers\n\n## Development Workflow\n\n### 1. Build Verification\n\n**Always verify builds** after making changes using `xcodebuild`:\n\n```bash\nxcodebuild -project YourProject.xcodeproj -scheme YourScheme -quiet build\n```\n\n- Use `-quiet` flag to minimize output as specified in project documentation\n- Replace placeholders with actual project and scheme names\n- For workspaces, use `-workspace YourWorkspace.xcworkspace`\n- Check exit code to confirm success\n\n### 2. Code Standards\n\nFollow these standards for all Swift code:\n\n**Naming Conventions:**\n- Types: UpperCamelCase (e.g., `UserProfileViewController`)\n- Functions/variables: lowerCamelCase (e.g., `fetchUserData()`)\n- Constants: lowerCamelCase (e.g., `let maxRetryCount = 3`)\n- Protocols: UpperCamelCase, often ending in -able, -ible, or -ing (e.g., `Codable`, `Drawable`)\n\n**Access Control:**\n- Default to `private` or `fileprivate` for implementation details\n- Use `internal` (default) for module-internal APIs\n- Mark `public` or `open` only for exported APIs\n- Consider `@testable import` for testing instead of making everything public\n\n**Code Organization:**\n- Group related code with `// MARK: - Section Name`\n- Order: properties, initializers, lifecycle methods, public methods, private methods\n- One type per file (exceptions for small helper types)\n- Use extensions for protocol conformance\n\n**Memory Safety:**\n- Use `[weak self]` in closures that may outlive the caller\n- Use `[unowned self]` only when certain closure won't outlive the reference\n- Break retain cycles between parent/child view controllers\n- Monitor retain cycles in Instruments\n\n### 3. Testing Requirements\n\nWrite testable code with appropriate coverage:\n\n**Unit Tests:**\n- Test business logic, view models, data transformations\n- Mock network/database dependencies\n- Use dependency injection for testability\n- Aim for >80% coverage on critical paths\n\n**UI Tests:**\n- Test critical user flows (login, purchase, main features)\n- Use accessibility identifiers for reliable element selection\n- Keep UI tests fast and focused\n\n### 4. Performance Considerations\n\nOptimize for user experience:\n\n**Rendering Performance:**\n- Keep view hierarchies shallow\n- Avoid expensive operations in `body` (SwiftUI) or `layoutSubviews` (UIKit)\n- Profile with Instruments (Time Profiler, SwiftUI view body)\n- Lazy-load content, virtualize lists\n\n**Memory Management:**\n- Release large objects when no longer needed\n- Monitor memory warnings and respond appropriately\n- Profile with Instruments (Allocations, Leaks)\n- Avoid strong reference cycles\n\n**Battery Life:**\n- Minimize location services usage\n- Batch network requests\n- Use background modes judiciously\n- Profile with Instruments (Energy Log)\n\n### 5. Apple Platform Best Practices\n\nFollow Apple's official guidelines for:\n- Human Interface Guidelines (navigation, controls, interactions, accessibility)\n- Privacy & Security (permissions, data handling, authentication)\n- Accessibility (VoiceOver, Dynamic Type, color contrast)\n- Localization (NSLocalizedString, RTL languages, formatting)\n\nSee `./references/apple-guidelines.md` for detailed requirements and best practices.\n\n## Problem-Solving Approach\n\n### 1. Analysis Phase\n\n- Read error messages carefully (Xcode, runtime logs, crash reports)\n- Check project-specific requirements in CLAUDE.md\n- Review existing code patterns and architecture\n- Consider iOS version compatibility and API availability\n\n### 2. Solution Design\n\n- Provide multiple approaches when appropriate, explaining trade-offs\n- Reference official Apple documentation and WWDC sessions\n- Consider performance, memory, and battery impact\n- Suggest appropriate design patterns for the problem\n\n### 3. Implementation\n\n- Write clean, readable Swift code following API Design Guidelines\n- Include inline comments for complex logic\n- Add proper error handling with meaningful error messages\n- Ensure code is testable with dependency injection where appropriate\n\n### 4. Validation\n\n- Verify code builds successfully with `xcodebuild`\n- Test on simulator and, when possible, physical devices\n- Check for retain cycles and memory leaks\n- Validate accessibility and localization\n\n## Communication Style\n\n**Clear and Actionable:**\n- Provide specific code examples, not just descriptions\n- Explain the \"why\" behind architectural and implementation decisions\n- Offer step-by-step instructions for complex implementations\n- Highlight potential pitfalls and how to avoid them\n\n**Authoritative Sources:**\n- Link to Apple's official documentation\n- Cite WWDC sessions for best practices\n- Reference Swift Evolution proposals for language features\n- Point to Human Interface Guidelines for design decisions\n- See `./references/apple-guidelines.md` for documentation links\n\n**Trade-offs:**\n- Performance vs. code simplicity\n- SwiftUI vs. UIKit for specific use cases\n- Async/await vs. completion handlers\n- Protocol-oriented vs. class-based design\n\n**Complete implementation examples:** See `./references/code-examples.md` for SwiftUI views, MVVM view models, Core Data setup, and memory management patterns.\n\n**Design patterns and solutions:** See `./references/patterns.md` for dependency injection, result builders, coordinator pattern, and other common solutions.\n\n**Debugging guidance:** See `./references/debugging-strategies.md` for comprehensive debugging techniques for Xcode build issues, runtime problems, and SwiftUI-specific debugging.\n\n## Success Criteria\n\nGuidance is successful when:\n\n- Code builds successfully using `xcodebuild` with `-quiet` flag\n- Solutions follow Apple's Human Interface Guidelines\n- Implementations are memory-safe and performant\n- Code adheres to Swift API Design Guidelines\n- Solutions are testable and maintainable\n- Proper error handling is implemented\n- Accessibility and localization are considered\n- User privacy and security best practices are followed\n- Target iOS/macOS versions are compatible\n\n## Additional Resources\n\nFor complete reference materials, see:\n- `./references/code-examples.md` - SwiftUI, MVVM, Core Data, and memory management examples\n- `./references/patterns.md` - Dependency injection, result builders, coordinator pattern\n- `./references/debugging-strategies.md` - Xcode, runtime, and SwiftUI debugging techniques\n- `./references/apple-guidelines.md` - Official Apple documentation and guidelines\n\n## Remember\n\n- Always verify builds with `xcodebuild -quiet`\n- Follow project-specific standards from CLAUDE.md\n- Write memory-safe code with proper ARC usage\n- Consider accessibility, localization, and privacy\n- Reference Apple documentation and WWDC best practices\n- Explain trade-offs in architectural decisions\n- Provide clear, actionable code examples"
              }
            ]
          },
          {
            "name": "cli-developer",
            "description": null,
            "source": "./plugins/cli-developer",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add sjungling/claude-plugins",
              "/plugin install cli-developer@claude-plugins"
            ],
            "signals": {
              "stars": 6,
              "forks": 0,
              "pushed_at": "2025-12-20T22:50:31Z",
              "created_at": "2025-10-10T04:14:44Z",
              "license": "MIT"
            },
            "commands": [],
            "skills": [
              {
                "name": "cli-ux-designer",
                "description": "Expert in CLI/TUI design, command structure, visual design (colors, typography, icons), accessibility, and UX patterns. Automatically activates when designing new CLI tools, improving command interfaces, or reviewing CLI usability.",
                "path": "plugins/cli-developer/skills/cli-ux-designer/SKILL.md",
                "frontmatter": {
                  "name": "cli-ux-designer",
                  "description": "Expert in CLI/TUI design, command structure, visual design (colors, typography, icons), accessibility, and UX patterns. Automatically activates when designing new CLI tools, improving command interfaces, or reviewing CLI usability."
                },
                "content": "# CLI Design Guide\n\nExpert CLI design consultant specializing in creating exceptional command-line interfaces. Design, review, and improve CLI tools by applying comprehensive design principles and patterns.\n\n## When NOT to Use This Skill\n\nDo not use this skill for:\n- GUI/web interface design\n- Backend API design (unless CLI tool interacts with it)\n- General UX design outside command-line contexts\n- Programming language design\n\n## Core Expertise\n\nCore design principles to apply:\n\n### 1. Reasonable Defaults, Easy Overrides\n\n- Optimize for common use cases while providing customization options\n- Use flags to modify default behaviors\n- Consider what most users need most often\n\n### 2. Maintain Brand Consistency\n\n- Use platform-specific language and terminology\n- Mirror web interface patterns where appropriate\n- Apply consistent visual styling (colors, states, syntax)\n- Use sentence case, not title case\n\n### 3. Reduce Cognitive Load\n\n- Include confirmation steps for risky operations\n- Provide clear headers for context\n- Maintain consistent command patterns\n- Anticipate user mistakes and next actions\n- Design for accessibility\n\n### 4. Terminal-First with Web Integration\n\n- Keep users in terminal when possible\n- Provide easy paths to web interface when needed\n- Include `--web` flags for browser actions\n- Output relevant URLs after operations\n\n## Command Structure Expertise\n\nEnsure commands follow this consistent pattern:\n\n| tool | `<command>` | `<subcommand>` | [value]  | [flags] | [value] |\n| ---- | ----------- | -------------- | -------- | ------- | ------- |\n| cli  | issue       | view           | 234      | --web   | -       |\n| cli  | pr          | create         | -        | --title | \"Title\" |\n| cli  | repo        | fork           | org/repo | --clone | false   |\n\n**Components:**\n\n- **Command**: The object to interact with\n- **Subcommand**: The action to take on that object\n- **Flag**: Modifiers with long version (`--state`) and often shorthand (`-s`)\n- **Values**: IDs, owner/repo pairs, URLs, branch names, file names\n\n**Language Guidelines:**\n\n- Use unambiguous language that can't be confused\n- Use shorter phrases when possible and appropriate\n- Use flags for modifiers of actions, avoid making modifiers their own commands\n- Use understood shorthands to save characters\n\n## Visual Design System Knowledge\n\n### Typography\n\n- Assume monospace fonts\n- Use **bold** for emphasis and repository names\n- Create hierarchy with spacing and weight\n- No italics (unreliable support)\n\n### Color Usage\n\nApply the 8 basic ANSI colors:\n\n- **Green**: Success, open states\n- **Red**: Failure, closed states\n- **Yellow**: Warnings, draft states\n- **Blue**: Information, links\n- **Cyan**: Branch names, special identifiers\n- **Magenta**: Special highlights\n- **Gray**: Secondary information, labels\n- **White/Default**: Primary text\n\n**Guidelines:**\n\n- Only enhance meaning, never communicate meaning solely through color\n- Consider users can customize terminal colors\n- Some terminals don't support 256-color sequences reliably\n\nFor complete ANSI color codes and escape sequences, see `./references/ansi-color-reference.md`.\n\n### Iconography\n\nUse Unicode symbols consistently:\n\n- `✓` Success\n- `✗` Failure\n- `!` Alert\n- `-` Neutral\n- `+` Changes requested\n\nConsider varying Unicode font support across systems.\n\nFor a comprehensive list of CLI-friendly Unicode symbols, see `./references/unicode-symbols.md`.\n\n## Component Pattern Expertise\n\n### Lists\n\n- Use tabular format with headers\n- Show state through color\n- Include relevant contextual information\n\nFor a complete list view example, see `./assets/examples/list-view-example.txt`.\n\n### Detail Views\n\n- Show comprehensive information\n- Indent body content\n- Include URLs at bottom\n\n### Prompts\n\n- **Yes/No**: Default in caps, for confirmations\n- **Short text**: Single-line input with autocomplete\n- **Long text**: Multi-line with editor option\n- **Radio select**: Choose one option\n- **Multi-select**: Choose multiple options\n- Always provide flag alternatives to prompts\n\nFor an interactive prompt example, see `./assets/examples/interactive-prompt-example.txt`.\n\n### Help Pages\n\nRequired sections: Usage, Core commands, Flags, Learn more, Inherited flags\nOptional sections: Additional commands, Examples, Arguments, Feedback\n\nFor a complete help text example, see `./assets/examples/help-text-example.txt`.\n\n### Syntax Conventions\n\n- `<required-args>` in angle brackets\n- `[optional-args]` in square brackets\n- `{mutually-exclusive}` in braces\n- `repeatable...` with ellipsis\n- Use dash-case for multi-word variables\n\n## Technical Considerations\n\n### Script Automation Support\n\n- Provide flags for all interactive elements\n- Output machine-readable formats when piped\n- Use tabs as delimiters for structured data\n- Remove colors/formatting in non-terminal output\n- Include exact timestamps and full data\n\n### Accessibility\n\n- Use punctuation for screen reader pauses\n- Don't rely solely on color for meaning\n- Support high contrast and custom themes\n- Design for cognitive accessibility\n\n## Recommended Approach\n\nWhen helping with CLI design:\n\n1. **Analyze existing patterns** - Look at current command structure and identify inconsistencies\n2. **Apply design principles** - Ensure commands follow the four core principles\n3. **Review visual design** - Check color usage, typography, spacing, and iconography\n4. **Evaluate user experience** - Consider cognitive load, error handling, and empty states\n5. **Ensure accessibility** - Verify commands work for diverse users and environments\n6. **Check scriptability** - Ensure commands work well in automated contexts\n\nProvide specific, actionable recommendations with clear rationale based on CLI design best practices. Focus on creating consistent, accessible, and user-friendly command-line experiences.\n\n## Success Criteria\n\nRecommendations are successful when:\n- Commands follow consistent patterns across the tool\n- Help text is clear with useful examples\n- Visual hierarchy guides users naturally\n- Both interactive and scriptable use cases work\n- Accessibility requirements are met"
              }
            ]
          },
          {
            "name": "technical-writer",
            "description": null,
            "source": "./plugins/technical-writer",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add sjungling/claude-plugins",
              "/plugin install technical-writer@claude-plugins"
            ],
            "signals": {
              "stars": 6,
              "forks": 0,
              "pushed_at": "2025-12-20T22:50:31Z",
              "created_at": "2025-10-10T04:14:44Z",
              "license": "MIT"
            },
            "commands": [],
            "skills": [
              {
                "name": "obsidian-vault-manager",
                "description": "Expert in managing Obsidian vaults using obsidian-cli workflows for reading, writing, searching, moving, and organizing notes while preserving wiki-link integrity and vault structure. Automatically activates when working with Obsidian vaults, markdown notes with wiki-links, or when internal link integrity needs to be preserved during file operations.",
                "path": "plugins/technical-writer/skills/obsidian-vault-manager/SKILL.md",
                "frontmatter": {
                  "name": "obsidian-vault-manager",
                  "description": "Expert in managing Obsidian vaults using obsidian-cli workflows for reading, writing, searching, moving, and organizing notes while preserving wiki-link integrity and vault structure. Automatically activates when working with Obsidian vaults, markdown notes with wiki-links, or when internal link integrity needs to be preserved during file operations."
                },
                "content": "# Obsidian Vault Manager\n\n## Prerequisites\n\nBefore performing vault operations:\n\n1. **Verify obsidian-cli is installed:**\n   ```bash\n   obsidian-cli --version\n   ```\n\n2. **If obsidian-cli is unavailable:**\n   - Install via: `npm install -g @johnlindquist/obsidian-cli`\n   - Fallback: Standard file operations can be used but will NOT preserve wiki-links\n   - Warning: Without obsidian-cli, moving notes will break all internal `[[wiki-links]]`\n\n3. **Verify vault is accessible:**\n   ```bash\n   obsidian-cli print-default\n   ```\n\n## Overview\n\n**Use `obsidian-cli` for all Obsidian vault operations.** Standard file tools (mv, Write, Edit) break internal links and ignore vault structure. The `obsidian-cli` tool automatically preserves `[[wiki-links]]` and maintains vault integrity.\n\n## When to Use\n\nThis skill activates when:\n- Working with Obsidian vaults (`.md` files with `[[wiki-links]]`)\n- Moving/renaming notes (links must stay valid)\n- Creating notes with Obsidian-specific syntax (wiki-links, checkboxes, tags)\n- Searching vault content or note names\n- Organizing multiple notes across folders\n\n**Don't use for:**\n- General markdown editing outside Obsidian vaults\n- Static documentation (no internal links)\n- Single-file markdown operations\n\n## Quick Reference\n\n| Task | Command | Notes |\n|------|---------|-------|\n| Check vault | `obsidian-cli print-default` | Always run first |\n| Read note | `obsidian-cli print \"Note Name\"` | Reads by name or path |\n| Create note | `obsidian-cli create \"Name\" --content \"text\"` | Add `--open` to launch Obsidian |\n| Update note | `obsidian-cli create \"Name\" --content \"text\" --append` | Use `--overwrite` to replace |\n| Move note | `obsidian-cli move \"old/path\" \"new/path\"` | **Auto-updates all links** |\n| Search content | `obsidian-cli search-content \"term\"` | Searches note contents |\n| Search names | `obsidian-cli search` | Fuzzy search (interactive) |\n| Daily note | `obsidian-cli daily` | Create/open today's note |\n\n**See also:**\n- [Complete obsidian-cli Command Reference](./references/obsidian-cli-reference.md) - All commands with flags and advanced usage\n- [Obsidian Syntax Reference](./references/obsidian-syntax.md) - Wiki-links, tags, frontmatter, and markdown syntax\n- [Note Templates](./assets/templates/) - Daily note, project, and meeting templates\n\n## Core Workflows\n\n### Always Check Vault First\n\n```bash\n# REQUIRED before any operation\nobsidian-cli print-default\n\n# Get path for direct file operations if needed\nVAULT_PATH=$(obsidian-cli print-default --path-only)\n```\n\n**Why:** Paths are vault-relative, not repository-relative. Creating files in wrong location breaks vault structure.\n\n### Moving/Reorganizing Notes\n\n```bash\n# ✅ CORRECT: Auto-updates all links\nobsidian-cli move \"Random Notes/Design\" \"Projects/Design\"\n\n# ❌ WRONG: Breaks all links to this note\nmv \"vault/Random Notes/Design.md\" \"vault/Projects/Design.md\"\n```\n\n**Critical:** `obsidian-cli move` updates every link in the vault automatically. Using `mv` or file operations breaks internal references.\n\n### Creating/Updating Notes\n\n```bash\n# Create new note\nobsidian-cli create \"Projects/Mobile App\" --content \"# Mobile App\\n\\n## Tasks\\n- [ ] Task 1\"\n\n# Append to existing (safe if file exists)\nobsidian-cli create \"Daily Log\" --content \"\\n## Update\\n- New entry\" --append\n\n# Replace existing (use cautiously)\nobsidian-cli create \"Draft\" --content \"# Fresh content\" --overwrite\n```\n\n**Obsidian syntax in `--content`:**\n- Wiki-links: `[[Note Name]]`\n- Tags: `#project`\n- Checkboxes: `- [ ] Task`\n- Newlines: `\\n`\n\n**Templates:** Use provided [note templates](./assets/templates/) as starting points for common note types (daily notes, projects, meetings).\n\n### Searching and Organizing\n\n```bash\n# Find notes mentioning topic\nobsidian-cli search-content \"API design\"\n\n# Read found note\nobsidian-cli print \"Backend/API Design\"\n\n# Reorganize (preserves all links)\nobsidian-cli move \"Backend/API Design\" \"Projects/Backend/API Design\"\n```\n\n## Common Mistakes\n\n| Mistake | Why Wrong | Fix |\n|---------|-----------|-----|\n| Using `mv` to move notes | Breaks all `[[wiki-links]]` to that note | Use `obsidian-cli move` |\n| Using `Write` tool for notes | Creates files outside vault or wrong location | Use `obsidian-cli create --content` |\n| Using `Read` for vault notes | Misses vault context, no search integration | Use `obsidian-cli print` |\n| Not checking vault first | Operations fail or create files in wrong place | Always run `print-default` first |\n| Manual link updating with sed | Error-prone, misses bidirectional links | `obsidian-cli move` handles automatically |\n| Using absolute paths | Breaks when vault moves | Use vault-relative paths |\n\n## When to Use Standard Tools\n\n**Use `obsidian-cli` first.** Only use standard tools when:\n- Bulk editing note contents (use `Edit` after `obsidian-cli print`)\n- Complex search patterns (use `Grep` with vault path)\n- File pattern matching (use `Glob` on `$VAULT_PATH/**/*.md`)\n\n**Always preserve:**\n- Frontmatter (YAML between `---`)\n- Obsidian link syntax `[[Note]]`\n- Tag syntax `#tag-name`\n- Markdown structure\n\n## Integration Pattern\n\n```bash\n# 1. Check vault\nobsidian-cli print-default\n\n# 2. Use obsidian-cli for vault operations\nobsidian-cli search-content \"search term\"\nobsidian-cli print \"Found Note\"\n\n# 3. Use standard tools ONLY when needed\n# (e.g., complex editing after reading with obsidian-cli)\n```\n\n## Success Criteria\n\nVault operations succeed when:\n- All `[[wiki-links]]` remain valid after moves\n- Notes created in correct vault location\n- Markdown and frontmatter preserved\n- Search returns accurate results\n- No broken links or orphaned notes"
              },
              {
                "name": "technical-writer",
                "description": "Expert in technical documentation (README, API docs, guides, tutorials, quickstarts, specs, release notes) that automatically activates when creating, editing, or reviewing .md files in docs/ directories, README files, or when discussing documentation structure, style guides, or content organization. Follows industry best practices for clear, accessible technical communication across all documentation types.",
                "path": "plugins/technical-writer/skills/technical-writer/SKILL.md",
                "frontmatter": {
                  "name": "technical-writer",
                  "description": "Expert in technical documentation (README, API docs, guides, tutorials, quickstarts, specs, release notes) that automatically activates when creating, editing, or reviewing .md files in docs/ directories, README files, or when discussing documentation structure, style guides, or content organization. Follows industry best practices for clear, accessible technical communication across all documentation types."
                },
                "content": "# Technical Documentation Expert\n\n## Overview\n\nProvides expert guidance for creating clear, comprehensive, and user-friendly technical documentation following industry best practices and structured content models.\n\n**Core principle:** Write for the audience with clarity, accessibility, and actionable content using standardized documentation patterns.\n\n## When to Use\n\nAutomatically activates when:\n\n- Working with `.md` files in `docs/` directories\n- Creating or editing README files\n- Editing documentation files or markup\n- Discussing documentation structure, information architecture, or style guides\n- Creating API documentation with examples and parameter tables\n- Writing user guides, tutorials, or quickstarts\n- Drafting release notes or change logs\n- Structuring specifications or technical proposals\n\nManual invocation when:\n\n- User explicitly asks about documentation best practices\n- User needs guidance on content organization or structure\n- User requests help with technical writing style\n- User encounters documentation quality issues\n\n## When NOT to Use This Skill\n\nDo not use this skill for:\n\n- Creative writing or marketing copy\n- Code implementation (documentation only)\n- Project management documentation\n- Internal team chat or informal notes\n- Academic papers or research documentation\n\n## Core Expertise Areas\n\n### Content Types\n\n1. **Conceptual** - Explains what something is and why it's useful (\"About...\" articles)\n2. **Referential** - Detailed reference information (API docs, syntax guides, parameter tables)\n3. **Procedural** - Step-by-step task completion with numbered lists and gerund titles\n4. **Troubleshooting** - Error resolution, known issues, and debugging guidance\n5. **Quickstart** - Essential setup in 5 minutes/600 words maximum\n6. **Tutorial** - End-to-end workflow with real-world examples and conversational tone\n7. **Release Notes** - Version changes categorized by type (Features, Fixes, Breaking Changes)\n\n### Documentation Structure\n\n**Standard Article Elements:**\n\n- Titles: Sentence case, gerund for procedures, character limits by level\n- Intros: 1-2 sentences explaining content\n- Prerequisites and permissions when applicable\n- Clear next steps\n\n**Information Architecture:**\n\n- Hierarchical structure with maximum 4 navigation levels\n- Content ordering: Conceptual → Referential → Procedural → Troubleshooting\n\n**For detailed structure requirements:** See `./references/style-guide.md` section on Article Structure and Standard Elements.\n\n### Style Guide Principles\n\nApply formatting and style rules from the comprehensive style guide:\n\n- Language: Clear, simple, active voice, sentence case\n- Technical formatting: Code in backticks, UI in bold, placeholders in ALL-CAPS\n- Structure: Numbered lists for procedures, bullets for non-sequential info\n- Links: Descriptive text, no \"click here\"\n- Alerts: Use Note, Tip, Important, Warning, Caution sparingly\n\n**For detailed formatting rules:** See `./references/style-guide.md` sections on Language and Tone, Technical Writing Conventions, and Structure and Format.\n\n### Procedural Content Ordering\n\nFollow standard procedural sequence: Enabling → Using → Managing → Disabling → Destructive\n\nWithin individual steps: Optional info → Reason → Location → Action\n\n**For complete ordering guidelines:** See `./references/style-guide.md` section on Content Ordering Guidelines.\n\n## Development Workflow\n\n### 1. Understand the Audience\n\n- Identify user expertise level (beginner, intermediate, advanced)\n- Determine user goals and tasks\n- Consider context where documentation will be used\n- Plan appropriate content depth and technical level\n\n### 2. Choose Content Type\n\nSelect the appropriate content type:\n\n- **Need to explain a concept?** → Conceptual\n- **Documenting API or syntax?** → Referential\n- **How-to for specific task?** → Procedural\n- **Debugging help?** → Troubleshooting\n- **Quick setup needed?** → Quickstart (≤5 minutes)\n- **End-to-end learning?** → Tutorial\n- **Version changes?** → Release Notes\n\n### 3. Structure Content\n\n**Standard content sequence:**\n\n1. Title (sentence case, descriptive, within character limits)\n2. Brief intro (1-2 sentences)\n3. Prerequisites (if applicable)\n4. Permissions statement (if required)\n5. Main content (ordered appropriately by type)\n6. Troubleshooting (embedded when helpful)\n7. Next steps / Further reading\n\n### 4. Apply Style Guide\n\nFollow the comprehensive style guide for:\n\n- Formatting code, UI elements, and placeholders\n- Writing clear procedures with proper structure\n- Adding accessibility features (alt text, sufficient contrast)\n- Ensuring proper link formatting and context\n- Using alerts appropriately\n\nFor complete style guide details, see: `./references/style-guide.md`\n\n### 5. Content Accuracy\n\n**Critical rule:** Do not invent or assume information not present in source material.\n\n- If gaps exist, ask user for missing information\n- Do not create placeholder or speculative content\n- Verify technical accuracy with authoritative sources\n- Include working examples when possible\n\n## Problem-Solving Approach\n\n### 1. Analysis Phase\n\n- Review existing documentation structure and patterns\n- Identify target audience and their needs\n- Assess information architecture and navigation\n- Check for consistency with project documentation standards\n\n### 2. Solution Design\n\n- Select appropriate content type for the task\n- Plan information hierarchy and flow\n- Consider accessibility and localization needs\n- Design for different user expertise levels\n\n### 3. Implementation\n\n- Write clear, concise content following style guide\n- Structure with appropriate headings and sections\n- Include concrete examples where helpful\n- Add tables for complex reference information\n- Ensure proper formatting of code, UI, and placeholders\n\n### 4. Validation\n\n- Verify content accuracy and completeness\n- Check that examples work as documented\n- Ensure style guide compliance\n- Validate accessibility (alt text, structure, contrast)\n- Confirm navigation and links work correctly\n\n**Automated validation:** Use `./scripts/validate_markdown.py <file>` to check:\n- Proper heading hierarchy (no skipped levels)\n- Code block formatting (language tags, closing backticks)\n- Link syntax and descriptive link text\n- Basic document structure\n\n## Communication Style\n\n**Be Clear and Actionable:**\n\n- Use simple, direct language\n- Provide specific examples and code snippets\n- Break complex topics into digestible sections\n- Include visual aids when they clarify concepts\n\n**Serve Multiple Expertise Levels:**\n\n- Layer content from simple to complex\n- Provide quick reference sections\n- Link to deeper explanations\n- Use prerequisites to set expectations\n\n**Focus on User Goals:**\n\n- Organize by tasks users want to accomplish\n- Use gerund titles for procedures (\"Creating...\", \"Configuring...\")\n- Include \"what you'll learn\" or \"what you'll build\" statements\n- Provide clear next steps after each article\n\n## Reference Materials\n\nThis skill references the comprehensive style guide for detailed guidance on all formatting rules.\n\n**See:** `./references/style-guide.md` for the complete technical writing style guide.\n\n### Quick Discovery: Search Patterns\n\nFor specific formatting rules in the large style guide, use grep to search:\n\n- **Alert formatting rules:** Search for `\"alert\"` in `./references/style-guide.md`\n- **Code block formatting:** Search for `\"code\"` or `\"backticks\"` in `./references/style-guide.md`\n- **Link formatting:** Search for `\"link text\"` in `./references/style-guide.md`\n- **Table formatting:** Search for `\"table\"` in `./references/style-guide.md`\n- **Heading hierarchy:** Search for `\"heading\"` in `./references/style-guide.md`\n- **Procedural step structure:** Search for `\"step structure\"` or `\"Within Procedural\"` in `./references/style-guide.md`\n- **Alt text requirements:** Search for `\"alt text\"` in `./references/style-guide.md`\n- **Placeholder conventions:** Search for `\"placeholder\"` or `\"ALL-CAPS\"` in `./references/style-guide.md`\n\n## Success Criteria\n\nDocumentation is successful when:\n\n- Content is accessible to the target audience\n- Structure follows the appropriate content type\n- Examples clarify complex concepts\n- Style guide rules are consistently applied\n- Users can complete tasks using the documentation\n- Information architecture supports easy navigation\n- Content is accurate and up-to-date\n\n## Quick Reference: Common Patterns\n\n### README Structure\n\n```markdown\n# Project Title (sentence case)\n\nBrief description in 1-2 sentences.\n\n## Prerequisites\n\n- Item 1\n- Item 2\n\n## Installation\n\n1. Step one\n2. Step two\n\n## Usage\n\nBasic usage examples with code blocks.\n\n## Documentation\n\nLinks to further reading.\n```\n\n### API Documentation Pattern\n\n```markdown\n## `functionName(param1, param2)`\n\nBrief description of what the function does.\n\n**Parameters:**\n\n| Parameter | Type   | Description |\n| --------- | ------ | ----------- |\n| param1    | string | Description |\n| param2    | number | Description |\n\n**Returns:** Description of return value\n\n**Example:**\n\\`\\`\\`language\n// Working code example\n\\`\\`\\`\n```\n\n### Release Notes Pattern\n\n```markdown\n# Version X.Y.Z\n\n## Features\n\n- New feature description\n\n## Fixes\n\n- Bug fix description\n\n## Breaking Changes\n\n- Breaking change with migration path\n\n## Improvements\n\n- Enhancement description\n```\n\n## Remember\n\n- Always consider the audience first\n- Choose the right content type for the task\n- Follow style guide consistently\n- Do not invent information - ask when unclear\n- Include working examples\n- Make content accessible\n- Structure for easy navigation\n- Validate before completion"
              }
            ]
          },
          {
            "name": "openrewrite",
            "description": null,
            "source": "./plugins/openrewrite",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add sjungling/claude-plugins",
              "/plugin install openrewrite@claude-plugins"
            ],
            "signals": {
              "stars": 6,
              "forks": 0,
              "pushed_at": "2025-12-20T22:50:31Z",
              "created_at": "2025-10-10T04:14:44Z",
              "license": "MIT"
            },
            "commands": [],
            "skills": [
              {
                "name": "rewrite-yaml",
                "description": "Expert in test-first development of production-quality OpenRewrite recipes for YAML manipulation using LST structure, visitor patterns, and JsonPath matching. Automatically activates when working with OpenRewrite recipe files or Java files in `src/main/java/**/rewrite/**` directories.",
                "path": "plugins/openrewrite-author/skills/rewrite-yaml/SKILL.md",
                "frontmatter": {
                  "name": "rewrite-yaml",
                  "description": "Expert in test-first development of production-quality OpenRewrite recipes for YAML manipulation using LST structure, visitor patterns, and JsonPath matching. Automatically activates when working with OpenRewrite recipe files or Java files in `src/main/java/**/rewrite/**` directories."
                },
                "content": "# Writing OpenRewrite YAML Recipes\n\n## Overview\n\nCreate production-quality OpenRewrite recipes for YAML manipulation using test-first development.\n\n**Core principle:** Write tests first (RED), implement minimally (GREEN), apply OpenRewrite idioms (REFACTOR).\n\n## When to Use\n\n- User asks to create/modify OpenRewrite recipes for YAML\n- Need to manipulate YAML files (GitHub Actions, K8s manifests, CI configs, generic YAML)\n- Building search or transformation recipes for YAML structures\n\n## When NOT to Use This Skill\n\nDo not use this skill for:\n\n- General YAML editing (use standard Edit tools)\n- Non-OpenRewrite transformation tools\n- Java versions above 8 (skill specializes in Java 8 compatibility)\n- Generic code refactoring outside OpenRewrite ecosystem\n\n## Critical Constraints\n\n**JAVA 8 COMPATIBILITY ONLY**: Use traditional if-else, switch statements, explicit casting. NO switch expressions, pattern matching, `var`, text blocks, or Java 9+ features.\n\n**LICENSE HEADERS**: Always check for `{repository_root}/gradle/licenseHeader.txt` when creating new recipe files. If this file exists, include its contents as the license header at the top of the generated Java recipe file. Remember to substitute `${year}` with the current year (2025 or later as appropriate).\n\n## The Workflow\n\n### Phase 1: RED - Write Failing Tests\n\nWrite test cases with before/after YAML examples using OpenRewrite's testing framework.\n\n### Phase 2: Architecture Decision\n\nChoose declarative (YAML composition) vs imperative (Java Visitor) approach.\n\n### Phase 3: GREEN - Minimal Implementation\n\nImplement just enough to make tests pass.\n\n### Phase 4: REFACTOR - Apply OpenRewrite Idioms\n\nImprove recipe using traits, composition, and conventions.\n\n### Phase 5: Documentation\n\nAdd displayName, description (with markdown), and usage examples.\n\n## Phase 1: RED - Write Failing Tests\n\n### Test Structure\n\nUse OpenRewrite's testing framework with before/after YAML. For detailed test patterns and examples, see `./references/testing-patterns.md`.\n\n### Checklist\n\n- [ ] Write happy path test (simplest transformation)\n- [ ] Include edge cases (empty files, missing keys, null values)\n- [ ] Test no-op scenarios (recipe shouldn't change unrelated YAML)\n- [ ] Consider multi-document YAML if relevant\n- [ ] Include real-world examples if domain is known\n\n### Verification\n\nRun tests to confirm RED state - tests must fail initially.\n\n**Key principle:** Start with simplest possible before/after. Add complexity incrementally.\n\n## Phase 2: Architecture Decision - Declarative vs Imperative\n\n### Decision Framework\n\n**Start with:** Can this be done by composing existing recipes?\n\n- **YES** → Use declarative YAML recipe\n- **NO** → Need imperative Java recipe with Visitor\n\n### Declarative Recipe (YAML Composition)\n\nCreate YAML file in `src/main/resources/META-INF/rewrite/`:\n\n```yaml\n---\ntype: specs.openrewrite.org/v1beta/recipe\nname: com.example.MyComposedRecipe\ndisplayName: My composed recipe\ndescription: Composes existing recipes\nrecipeList:\n  - org.openrewrite.yaml.search.FindKey:\n      keyPath: $.some.path\n  - org.openrewrite.yaml.ChangeValue:\n      keyPath: $.some.path\n      value: newValue\n```\n\n**When to use declarative:**\n\n- Simple transformations using existing recipes\n- Searching for patterns\n- Standard modifications (change values, delete keys)\n- Composing multiple existing recipes\n\n**Common declarative recipes:**\n\n- `org.openrewrite.yaml.search.FindKey`, `FindValue` - searching\n- `org.openrewrite.yaml.ChangeKey`, `ChangeValue`, `DeleteKey` - modifications\n- `org.openrewrite.yaml.MergeYaml`, `CopyValue` - additions\n\n### Imperative Recipe (Java Visitor)\n\n**When to use imperative:**\n\n- Complex logic or conditional transformations\n- Need to traverse YAML LST structure\n- Creating new YAML structures dynamically\n- Custom matching beyond JsonPath capabilities\n\n**Key principle:** Always try declarative first. Only go imperative when you hit limitations.\n\n## Phase 3: GREEN - Minimal Implementation\n\n### For Declarative Recipes\n\n1. Create YAML file in `src/main/resources/META-INF/rewrite/`\n2. Compose existing `org.openrewrite.yaml.*` recipes\n3. Run tests to verify GREEN state\n\nFor common recipe patterns, see `./references/recipe-patterns.md`.\n\n### For Imperative Recipes (Java Visitor)\n\nExtend `YamlIsoVisitor<ExecutionContext>` (when not changing tree structure) or `YamlVisitor<ExecutionContext>` (when structure may change).\n\nFor complete recipe templates and examples, see `./references/recipe-template.java`.\n\n**Automation:** Use `./scripts/init_recipe.py <RecipeName>` to generate recipe boilerplate (class, test file, YAML declarative option).\n\n### Verification\n\nRun tests to achieve GREEN state - all tests must pass with formatting preserved.\n\n## Phase 4: REFACTOR - Apply OpenRewrite Idioms\n\n### Checklist for Idiomatic Recipes\n\n**1. Trait Usage**\n\n- [ ] Can this recipe implement an existing trait?\n- [ ] Should a new trait be created for reusable matching logic?\n- [ ] Separate \"what to find\" (trait) from \"what to do\" (recipe)\n\n**2. Recipe Composition**\n\n- [ ] Can parts be extracted into smaller, composable recipes?\n- [ ] Are there opportunities for configurability (parameters)?\n- [ ] Could this be split into search recipe + modification recipe?\n\n**3. OpenRewrite Conventions**\n\n- [ ] Recipe has clear `displayName` and `description` (both support **markdown**)\n- [ ] Parameters use `@Option` annotations with descriptions\n- [ ] Recipe class is Java 8 compatible (run `./scripts/validate_java8.py src/` to check)\n- [ ] Properly handles `null` values and missing elements\n- [ ] Preserves formatting and comments where possible\n\n**4. Performance Considerations**\n\n- [ ] Minimize LST traversals (don't visit more than necessary)\n- [ ] Use preconditions to skip files that won't match\n- [ ] Return original object if no changes made (identity check)\n\n### Verification\n\n- [ ] All tests still pass after refactoring\n- [ ] Recipe follows OpenRewrite naming conventions\n- [ ] Code is cleaner and more maintainable\n\n## Phase 5: Documentation\n\n### Documentation Requirements\n\n**Recipe metadata (supports markdown):**\n\n- `displayName`: User-friendly name with markdown formatting\n- `description`: Detailed explanation with code examples, lists, links\n- `@Option` descriptions: Clear explanations with inline code examples\n\n**Example with markdown:**\n\n````java\n@Override\npublic String getDisplayName() {\n    return \"Update GitHub Actions to `actions/checkout@v4`\";\n}\n\n@Override\npublic String getDescription() {\n    return \"Updates all uses of `actions/checkout@v2` and `actions/checkout@v3` to `actions/checkout@v4`.\\n\\n\" +\n           \"**Before:**\\n```yaml\\n- uses: actions/checkout@v2\\n```\\n\\n\" +\n           \"**After:**\\n```yaml\\n- uses: actions/checkout@v4\\n```\";\n}\n````\n\n**Usage examples:**\n\n- Add Javadoc with common use cases\n- Show before/after transformations\n- Document parameter effects\n\n## Technical Reference\n\n### YAML LST Structure\n\nUnderstanding the YAML LST hierarchy is essential. For detailed structure documentation, see `./references/yaml-lst-reference.md`.\n\nKey concepts:\n- **Yaml.Documents** → **Yaml.Document** → **Yaml.Mapping** → **Yaml.Mapping.Entry**\n- **Yaml.Sequence** → **Yaml.Sequence.Entry**\n- **Yaml.Scalar** (primitive values)\n\n### Essential Patterns\n\nFor complete recipe templates and patterns, see:\n- `./references/recipe-template.java` - Complete recipe structure with annotations\n- `./references/recipe-patterns.md` - Search, replacement, and modification patterns\n- `./references/jsonpath-patterns.md` - Common JsonPath patterns for GitHub Actions, K8s, and generic YAML\n\n### Quick Reference\n\n**Key matching:**\n```java\nif (\"targetKey\".equals(entry.getKey().getValue())) { /* match */ }\n```\n\n**Safe value access:**\n```java\nString value = entry.getValue() instanceof Yaml.Scalar ?\n    ((Yaml.Scalar) entry.getValue()).getValue() : null;\n```\n\n**JsonPath matching:**\n```java\nJsonPathMatcher matcher = new JsonPathMatcher(\"$.jobs.*.steps[*].uses\");\nif (matcher.matches(getCursor())) { /* process */ }\n```\n\nFor more JsonPath patterns, search `./references/jsonpath-patterns.md` for your use case.\n\n### Recipe Development Rules\n\n1. Always call super methods: `return super.visitMappingEntry(entry, ctx);`\n2. Return modified copies - never mutate LST elements directly\n3. Use `withX()` methods for all modifications\n4. Handle null cases with conditional expressions\n5. Preserve formatting - LST methods maintain it automatically\n6. Java 8 only - no modern Java features\n\n### OpenRewrite Traits (Advanced)\n\nFor complex recipes that benefit from higher-level semantic abstractions, OpenRewrite Traits provide domain-specific logic by wrapping LST elements.\n\n**For detailed information about Traits**, refer to the companion guide: `./references/openrewrite-traits-guide.md`.\n\n**Quick Traits Overview:**\n\n- Traits implement `Trait<T extends Tree>` interface\n- Include a nested `Matcher` class extending `SimpleTraitMatcher<T>`\n- Use `matcher.asVisitor()` to convert to TreeVisitor in recipes\n- Provide semantic methods like `getActionRef()` instead of raw LST navigation\n\n**Example using Traits:**\n\n```java\n@Override\npublic TreeVisitor<?, ExecutionContext> getVisitor() {\n    return new ActionStep.Matcher().asVisitor((step, ctx) -> {\n        String ref = step.getActionRef();\n        if (ref != null && ref.contains(\"@v2\")) {\n            return step.withActionRef(ref.replace(\"@v2\", \"@v3\")).getTree();\n        }\n        return step.getTree();\n    });\n}\n```\n\nFor complete trait implementation patterns, matcher API details, and advanced examples, consult `./references/openrewrite-traits-guide.md`.\n\n## Final Validation\n\n### Production-Ready Checklist\n\n- [ ] All tests pass (GREEN state maintained)\n- [ ] Recipe follows OpenRewrite naming conventions (`com.yourorg.RecipeName`)\n- [ ] No hardcoded values that should be parameters\n- [ ] Recipe handles edge cases gracefully (no NPEs)\n- [ ] Code is Java 8 compatible (verify with `./scripts/validate_java8.py`)\n- [ ] Formatting/comments preserved in YAML output\n- [ ] Documentation is clear and includes examples\n- [ ] Recipe could be contributed to OpenRewrite or org recipe library\n- [ ] License header included if `gradle/licenseHeader.txt` exists (use `./scripts/add_license_header.sh`)\n\n### Success Criteria\n\nRecipe is production-ready when:\n\n- Tests comprehensively cover happy path and edge cases\n- Implementation follows OpenRewrite idioms (traits, composition)\n- Documentation enables users to understand and use the recipe\n- Code quality meets standards for upstream contribution\n\n## Recommended Approach\n\nFollow this workflow when creating OpenRewrite recipes:\n\n1. **Phase 1 (RED)** - Write failing tests with before/after YAML\n2. **Phase 2 (DECIDE)** - Choose declarative vs imperative approach\n3. **Phase 3 (GREEN)** - Implement minimal working solution\n4. **Phase 4 (REFACTOR)** - Apply OpenRewrite idioms (traits, composition)\n5. **Phase 5 (DOCUMENT)** - Add markdown documentation and examples\n6. **Validate** - Confirm production readiness with checklist\n\nAlways provide complete, working recipes with proper annotations, error handling, and clear comments explaining the logic.\n\n## Remember\n\n- **Always start with tests (RED)**\n- **Try declarative before imperative**\n- **Apply idioms during REFACTOR, not GREEN**\n- **Document with markdown for clarity**\n- **Validate production-readiness before completion**"
              },
              {
                "name": "recipe-writer",
                "description": "Expert in test-first development of production-quality OpenRewrite recipes for automated code refactoring. Automatically activates when working with OpenRewrite recipe files, Java/YAML files in `src/main/java/**/rewrite/**` directories, writing tests implementing `RewriteTest`, or when users ask about recipe development, writing recipes, creating migrations, LST manipulation, JavaTemplate usage, visitor patterns, preconditions, scanning recipes, YAML recipes, GitHub Actions transformations, Kubernetes manifest updates, or code migration strategies. Guides recipe type selection (declarative/Refaster/imperative), visitor implementation, and test-driven development workflows.",
                "path": "plugins/openrewrite/skills/recipe-writer/SKILL.md",
                "frontmatter": {
                  "name": "recipe-writer",
                  "description": "Expert in test-first development of production-quality OpenRewrite recipes for automated code refactoring. Automatically activates when working with OpenRewrite recipe files, Java/YAML files in `src/main/java/**/rewrite/**` directories, writing tests implementing `RewriteTest`, or when users ask about recipe development, writing recipes, creating migrations, LST manipulation, JavaTemplate usage, visitor patterns, preconditions, scanning recipes, YAML recipes, GitHub Actions transformations, Kubernetes manifest updates, or code migration strategies. Guides recipe type selection (declarative/Refaster/imperative), visitor implementation, and test-driven development workflows."
                },
                "content": "# OpenRewrite Recipe Writing Expert\n\n## Overview\n\nCreate production-quality OpenRewrite recipes using test-first development. This skill combines comprehensive coverage of all recipe types (declarative, Refaster, imperative) with deep domain expertise in Java and YAML transformations.\n\n**Core Principle:** Write tests first (RED), implement minimally (GREEN), apply OpenRewrite idioms (REFACTOR).\n\n## When to Use This Skill\n\nExplicitly invoke this skill for:\n\n- **Planning recipes** - Determining the best recipe type for a use case\n- **Implementing recipes** - Writing recipe classes, visitors, and JavaTemplate code\n- **Writing tests** - Creating comprehensive test coverage with RewriteTest\n- **YAML transformations** - GitHub Actions, Kubernetes manifests, CI/CD configs\n- **Java refactoring** - Code migrations, API updates, framework modernization\n- **Debugging recipes** - Troubleshooting visitor behavior, type checking, or preconditions\n- **Converting recipe types** - Analyzing if an imperative recipe can be declarative\n- **Understanding OpenRewrite concepts** - Learning about LSTs, cursors, traits, or scanning patterns\n\n## When NOT to Use This Skill\n\nDo NOT invoke this skill for:\n\n- **General Java programming questions** - Use standard Java knowledge unless specifically about OpenRewrite LST manipulation\n  - ❌ \"How do I parse JSON in Java?\"\n  - ✅ \"How do I parse Java code into LSTs?\"\n- **General YAML editing** - Use standard Edit tools for direct file modifications\n  - ❌ \"Edit this YAML file to change the value\"\n  - ✅ \"Create a recipe to update GitHub Actions across all repositories\"\n- **Running OpenRewrite recipes** - This skill is for authoring recipes, not executing them\n  - ❌ \"How do I run the Maven plugin?\"\n  - ✅ \"How do I test my recipe runs correctly?\"\n- **Build tool configuration** - Unless directly related to recipe publishing/distribution\n  - ❌ \"How do I configure Gradle for my project?\"\n  - ✅ \"How do I publish my recipe to Maven Central?\"\n- **General refactoring questions** - Only use for OpenRewrite recipe implementation\n  - ❌ \"What's the best way to refactor this code?\"\n  - ✅ \"What recipe type should I use for this refactoring?\"\n- **Reading/understanding existing code** - Unless analyzing recipe implementation\n  - ❌ \"Explain what this Spring controller does\"\n  - ✅ \"Explain what this JavaIsoVisitor is doing\"\n\n## Quick Examples\n\nHere are example requests that activate this skill:\n\n**Planning:**\n- \"I need to migrate from JUnit 4 to JUnit 5 - help me plan the recipe\"\n- \"What's the best recipe type to replace all ArrayList with List?\"\n- \"Should I use a declarative or imperative recipe for adding annotations?\"\n- \"Help me create a recipe to update GitHub Actions to use Node 20\"\n\n**Java Implementation:**\n- \"Write a recipe that adds @Deprecated to classes in com.example.old package\"\n- \"Show me how to use JavaTemplate to add a method to a class\"\n- \"Create a recipe that changes method return types from Optional to nullable\"\n\n**YAML Implementation:**\n- \"Create a recipe to update all GitHub Actions checkout actions to v4\"\n- \"Write a recipe to change Kubernetes image tags across all manifests\"\n- \"Build a recipe to migrate Travis CI configs to GitHub Actions\"\n\n**Debugging:**\n- \"My recipe isn't matching the expected classes - help debug\"\n- \"Why is my JavaTemplate throwing a parse error?\"\n- \"The recipe runs but doesn't make any changes - what's wrong?\"\n- \"My YAML recipe isn't preserving comments - how do I fix it?\"\n\n**Testing:**\n- \"Write tests for a ScanningRecipe that analyzes multiple files\"\n- \"How do I test a recipe that requires external classpath dependencies?\"\n- \"Show me how to test edge cases in my YAML recipe\"\n\n## Recipe Type Selection\n\nChoose the appropriate recipe type based on your needs.\n\n### Decision Tree\n\n```\nStart here\n    ├─ Can I compose existing recipes? ───────────────────┐\n    │   YES → Use Declarative YAML                         │\n    │   NO ↓                                                │\n    ├─ Is it a simple expression/statement replacement? ───┤\n    │   YES → Use Refaster Template                        │\n    │   NO ↓                                                │\n    └─ Do I need custom logic or conditional changes? ─────┤\n        YES → Use Imperative Java Recipe                   │\n                                                            │\nStill unsure? → Start with declarative, fall back to ─────┘\n               imperative only when necessary\n```\n\n### Recipe Type Comparison\n\n| Type | Speed | Complexity | Use Cases | Examples |\n|------|-------|------------|-----------|----------|\n| **Declarative YAML** | Fastest | Lowest | Composing existing recipes | Framework migrations, standard refactorings |\n| **Refaster Template** | Fast | Low-Medium | Expression/statement replacements | API updates, method call changes |\n| **Imperative Java** | Slower | High | Complex transformations, conditional logic | Custom analysis, YAML LST manipulation |\n\n### Declarative YAML Recipes (Preferred)\n\n**Use when:** Composing existing recipes with configuration\n\n**Advantages:**\n- No code required\n- Simple and maintainable\n- Fast execution\n- Easy to understand\n\n**Example use case:** Combining framework migration steps\n\n```yaml\ntype: specs.openrewrite.org/v1beta/recipe\nname: com.yourorg.MyMigration\ndisplayName: Migrate to Framework X\nrecipeList:\n  - org.openrewrite.java.ChangeType:\n      oldFullyQualifiedTypeName: old.Type\n      newFullyQualifiedTypeName: new.Type\n  - com.yourorg.OtherRecipe\n```\n\n**Common declarative recipes:**\n- Java: `ChangeType`, `ChangeMethodName`, `AddDependency`, `UpgradeDependencyVersion`\n- YAML: `FindKey`, `FindValue`, `ChangeKey`, `ChangeValue`, `DeleteKey`, `MergeYaml`, `CopyValue`\n\n### Refaster Template Recipes\n\n**Use when:** Simple expression/statement replacements with type awareness\n\n**Advantages:**\n- Faster than imperative recipes\n- Type-aware matching\n- Concise syntax\n- Good for API migrations\n\n**Example use case:** Replace `StringUtils.equals()` with `Objects.equals()`\n\n```java\npublic class StringUtilsToObjects {\n    @BeforeTemplate\n    boolean before(String s1, String s2) {\n        return StringUtils.equals(s1, s2);\n    }\n\n    @AfterTemplate\n    boolean after(String s1, String s2) {\n        return Objects.equals(s1, s2);\n    }\n}\n```\n\n### Imperative Java Recipes\n\n**Use when:** Complex logic, conditional transformations, custom analysis, or YAML/LST manipulation\n\n**Advantages:**\n- Full control over transformation logic\n- Complex transformations possible\n- Access to full LST structure\n- Can implement custom matching\n\n**Example use case:**\n- Add modifiers only to variables that aren't reassigned\n- Transform YAML based on complex conditions\n- Generate new files based on analysis\n- Multi-file coordination with ScanningRecipe\n\n**Decision Rule:** If it can be declarative, make it declarative. Use Refaster for simple replacements. Use imperative only when necessary.\n\n## Test-First Development Workflow\n\nFollow the RED-GREEN-REFACTOR cycle for recipe development:\n\n```\nPhase 1: RED (Write Failing Tests)\n    ↓\nPhase 2: DECIDE (Select Recipe Type)\n    ↓\nPhase 3: GREEN (Minimal Implementation)\n    ↓\nPhase 4: REFACTOR (Apply OpenRewrite Idioms)\n    ↓\nPhase 5: DOCUMENT (Add Metadata & Examples)\n    ↓\nPhase 6: VALIDATE (Production Readiness)\n```\n\n### Phase 1: RED - Write Failing Tests\n\nStart with tests before writing any recipe code. This ensures you understand the transformation and can verify correctness.\n\n**For Java recipes:**\n\n```java\nclass YourRecipeTest implements RewriteTest {\n\n    @Override\n    public void defaults(RecipeSpec spec) {\n        spec.recipe(new YourRecipe(\"parameter-value\"));\n    }\n\n    @Test\n    void makesExpectedChange() {\n        rewriteRun(\n            //language=java\n            java(\n                // Before\n                \"\"\"\n                  package com.example;\n                  class Before { }\n                  \"\"\",\n                // After\n                \"\"\"\n                  package com.example;\n                  class After { }\n                  \"\"\"\n            )\n        );\n    }\n\n    @Test\n    void doesNotChangeWhenNotNeeded() {\n        rewriteRun(\n            //language=java\n            java(\n                \"\"\"\n                  package com.example;\n                  class AlreadyCorrect { }\n                  \"\"\"\n                // No second argument = no change expected\n            )\n        );\n    }\n}\n```\n\n**For YAML recipes:**\n\n```java\nclass YourYamlRecipeTest implements RewriteTest {\n\n    @Override\n    public void defaults(RecipeSpec spec) {\n        spec.recipe(new YourYamlRecipe());\n    }\n\n    @Test\n    void updatesGitHubActionsCheckout() {\n        rewriteRun(\n            //language=yaml\n            yaml(\n                \"\"\"\n                  jobs:\n                    build:\n                      steps:\n                        - uses: actions/checkout@v2\n                  \"\"\",\n                \"\"\"\n                  jobs:\n                    build:\n                      steps:\n                        - uses: actions/checkout@v4\n                  \"\"\"\n            )\n        );\n    }\n}\n```\n\n**Test Checklist:**\n- [ ] Write happy path test (simplest transformation)\n- [ ] Include edge cases (nulls, empty files, missing elements)\n- [ ] Test no-op scenarios (recipe shouldn't change unrelated code)\n- [ ] Test multi-document YAML if relevant\n- [ ] Include real-world examples if domain is known\n- [ ] Run tests to confirm RED state - tests must fail initially\n\n**Key Principle:** Start with simplest possible before/after. Add complexity incrementally.\n\n### Phase 2: DECIDE - Select Recipe Type\n\nUse the decision tree above to choose between declarative, Refaster, or imperative.\n\n**Ask yourself:**\n1. Can this be done by composing existing recipes? → Declarative\n2. Is it a simple expression/statement replacement? → Refaster\n3. Does it need custom logic or LST manipulation? → Imperative\n\n**For YAML-specific decisions:**\n- Simple value changes, key renames → Declarative (use `ChangeValue`, `ChangeKey`)\n- Complex JsonPath matching with conditions → Imperative\n- Multi-step YAML transformations → Declarative (compose multiple recipes)\n- Dynamic YAML generation → Imperative\n\n### Phase 3: GREEN - Minimal Implementation\n\nImplement just enough to make tests pass. Don't optimize or refactor yet.\n\n**For declarative recipes:**\n\n1. Create YAML file in `src/main/resources/META-INF/rewrite/`\n2. Compose existing recipes\n3. Run tests to verify GREEN state\n\n**For imperative Java recipes:**\n\nUse templates from `./templates/` directory:\n- `template-imperative-recipe.java` - Complete recipe structure\n- `template-recipe-test.java` - Test structure\n\n**Automation:** Use `./scripts/init_recipe.py <RecipeName>` to generate boilerplate.\n\n**For YAML recipes, extend YamlIsoVisitor:**\n\n```java\npublic class YourYamlRecipe extends Recipe {\n\n    @Override\n    public String getDisplayName() {\n        return \"Your recipe display name\";\n    }\n\n    @Override\n    public String getDescription() {\n        return \"Description of transformation.\";\n    }\n\n    @Override\n    public TreeVisitor<?, ExecutionContext> getVisitor() {\n        return new YamlIsoVisitor<ExecutionContext>() {\n            @Override\n            public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry entry, ExecutionContext ctx) {\n                entry = super.visitMappingEntry(entry, ctx);\n\n                // Match specific key\n                if (\"targetKey\".equals(entry.getKey().getValue())) {\n                    // Safe value access\n                    if (entry.getValue() instanceof Yaml.Scalar) {\n                        Yaml.Scalar scalar = (Yaml.Scalar) entry.getValue();\n                        if (\"oldValue\".equals(scalar.getValue())) {\n                            return entry.withValue(\n                                scalar.withValue(\"newValue\")\n                            );\n                        }\n                    }\n                }\n\n                return entry;\n            }\n        };\n    }\n}\n```\n\n**Verification:** Run tests to achieve GREEN state - all tests must pass.\n\n### Phase 4: REFACTOR - Apply OpenRewrite Idioms\n\nNow improve the recipe using OpenRewrite best practices. Don't skip GREEN to do this - refactoring comes AFTER tests pass.\n\n**Refactoring Checklist:**\n\n**1. Trait Usage** (Advanced)\n- [ ] Can this recipe implement an existing trait?\n- [ ] Should a new trait be created for reusable matching logic?\n- [ ] Separate \"what to find\" (trait) from \"what to do\" (recipe)\n\nSee `./references/trait-implementation-guide.md` for details.\n\n**2. Recipe Composition**\n- [ ] Can parts be extracted into smaller, composable recipes?\n- [ ] Are there opportunities for configurability (parameters)?\n- [ ] Could this be split into search recipe + modification recipe?\n\n**3. OpenRewrite Conventions**\n- [ ] Recipe has clear `displayName` and `description` (both support markdown)\n- [ ] Parameters use `@Option` annotations with descriptions and examples\n- [ ] Properly handles `null` values and missing elements\n- [ ] Preserves formatting and comments where possible\n- [ ] Uses `@Value` and `@EqualsAndHashCode(callSuper = false)` for immutability\n- [ ] `getVisitor()` returns NEW instance (never cached)\n\n**4. Performance Considerations**\n- [ ] Minimize LST traversals (don't visit more than necessary)\n- [ ] Use preconditions to skip files that won't match\n- [ ] Return original object if no changes made (identity check)\n\n**5. YAML-Specific Refactoring**\n- [ ] Use JsonPath matching for complex patterns\n- [ ] Handle multi-document YAML if relevant\n- [ ] Preserve YAML anchors and aliases\n- [ ] Test with real-world files (GitHub Actions, K8s, etc.)\n\n**Verification:**\n- [ ] All tests still pass after refactoring\n- [ ] Recipe follows OpenRewrite naming conventions\n- [ ] Code is cleaner and more maintainable\n\n### Phase 5: DOCUMENT - Add Metadata & Examples\n\nAdd comprehensive documentation to make the recipe discoverable and understandable.\n\n**Recipe Metadata (supports markdown):**\n\n```java\n@Override\npublic String getDisplayName() {\n    return \"Update GitHub Actions to `actions/checkout@v4`.\";\n}\n\n@Override\npublic String getDescription() {\n    return \"Updates all uses of `actions/checkout@v2` and `actions/checkout@v3` to `actions/checkout@v4`.\\n\\n\" +\n           \"**Before:**\\n```yaml\\n- uses: actions/checkout@v2\\n```\\n\\n\" +\n           \"**After:**\\n```yaml\\n- uses: actions/checkout@v4\\n```\";\n}\n```\n\n**Option Documentation:**\n\n```java\n@Option(\n    displayName = \"Old action reference\",\n    description = \"The old action reference to replace (e.g., `actions/checkout@v2`).\",\n    example = \"actions/checkout@v2\"\n)\nString oldActionRef;\n```\n\n**Javadoc:**\n- Add class-level Javadoc with use cases\n- Show before/after transformations\n- Document parameter effects\n- Link to related recipes\n\n**Naming Conventions:**\n- Display names: Sentence case, code in backticks, end with period\n- Recipe names: `com.yourorg.VerbNoun` (e.g., `com.yourorg.UpdateGitHubActions`)\n\n### Phase 6: VALIDATE - Production Readiness\n\nUse the comprehensive checklist to ensure production quality.\n\n**Quick Validation:**\n- [ ] All tests pass (GREEN state maintained)\n- [ ] Recipe handles edge cases gracefully (no NPEs)\n- [ ] Formatting/comments preserved in output\n- [ ] Documentation is clear and includes examples\n- [ ] Recipe is idempotent (same result on repeated runs)\n\n**Full Validation:**\nSee `./references/checklist-recipe-development.md` for 200+ validation items.\n\n**License Headers:**\nCheck for `{repository_root}/gradle/licenseHeader.txt`. If exists, use `./scripts/add_license_header.sh` to add headers.\n\n## Implementation Patterns\n\nQuick reference for common implementation patterns.\n\n### Java Recipes\n\n**Set Up Recipe Class:**\n\n```java\n@Value\n@EqualsAndHashCode(callSuper = false)\npublic class YourRecipe extends Recipe {\n\n    @Option(displayName = \"Parameter Name\",\n            description = \"Clear description.\",\n            example = \"com.example.Type\")\n    String parameterName;\n\n    @Override\n    public String getDisplayName() {\n        return \"Your recipe display name.\";\n    }\n\n    @Override\n    public String getDescription() {\n        return \"What this recipe does.\";\n    }\n\n    @Override\n    public TreeVisitor<?, ExecutionContext> getVisitor() {\n        return new YourVisitor();\n    }\n}\n```\n\n**Implement Visitor:**\n\n```java\npublic class YourVisitor extends JavaIsoVisitor<ExecutionContext> {\n\n    @Override\n    public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {\n        // ALWAYS call super to traverse the tree\n        J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);\n\n        // Check if change is needed (do no harm)\n        if (!shouldChange(cd)) {\n            return cd;\n        }\n\n        // Make changes using JavaTemplate or LST methods\n        cd = makeChanges(cd);\n\n        return cd;\n    }\n}\n```\n\n**Use JavaTemplate:**\n\n```java\nprivate final JavaTemplate template = JavaTemplate\n    .builder(\"public String hello() { return \\\"Hello from #{}!\\\"; }\")\n    .build();\n\n// In visitor method:\nclassDecl = template.apply(\n    new Cursor(getCursor(), classDecl.getBody()),\n    classDecl.getBody().getCoordinates().lastStatement(),\n    fullyQualifiedClassName\n);\n```\n\n**Add Preconditions:**\n\n```java\n@Override\npublic TreeVisitor<?, ExecutionContext> getVisitor() {\n    return Preconditions.check(\n        Preconditions.and(\n            new UsesType<>(\"com.example.Type\", true),\n            new UsesJavaVersion<>(17)\n        ),\n        new YourVisitor()\n    );\n}\n```\n\n### YAML Recipes\n\n**Basic YAML Visitor:**\n\n```java\npublic class YourYamlRecipe extends Recipe {\n\n    @Override\n    public TreeVisitor<?, ExecutionContext> getVisitor() {\n        return new YamlIsoVisitor<ExecutionContext>() {\n            @Override\n            public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry entry, ExecutionContext ctx) {\n                entry = super.visitMappingEntry(entry, ctx);\n\n                // Match key\n                if (\"targetKey\".equals(entry.getKey().getValue())) {\n                    // Safe value access\n                    String value = entry.getValue() instanceof Yaml.Scalar ?\n                        ((Yaml.Scalar) entry.getValue()).getValue() : null;\n\n                    if (\"oldValue\".equals(value)) {\n                        return entry.withValue(\n                            ((Yaml.Scalar) entry.getValue()).withValue(\"newValue\")\n                        );\n                    }\n                }\n\n                return entry;\n            }\n        };\n    }\n}\n```\n\n**JsonPath Matching:**\n\n```java\npublic class GitHubActionsRecipe extends Recipe {\n\n    @Override\n    public TreeVisitor<?, ExecutionContext> getVisitor() {\n        return new YamlIsoVisitor<ExecutionContext>() {\n\n            private final JsonPathMatcher matcher =\n                new JsonPathMatcher(\"$.jobs.*.steps[*].uses\");\n\n            @Override\n            public Yaml.Scalar visitScalar(Yaml.Scalar scalar, ExecutionContext ctx) {\n                scalar = super.visitScalar(scalar, ctx);\n\n                if (matcher.matches(getCursor())) {\n                    String value = scalar.getValue();\n                    if (value != null && value.startsWith(\"actions/checkout@v2\")) {\n                        return scalar.withValue(value.replace(\"@v2\", \"@v4\"));\n                    }\n                }\n\n                return scalar;\n            }\n        };\n    }\n}\n```\n\n**Common JsonPath Patterns:**\n\nSee `./references/jsonpath-patterns.md` for comprehensive patterns including:\n- GitHub Actions: `$.jobs.*.steps[*].uses`, `$.on.push.branches`\n- Kubernetes: `$.spec.template.spec.containers[*].image`, `$.metadata.labels`\n- Generic YAML: `$.databases.*.connection.host`, `$[?(@.enabled == true)]`\n\n### ScanningRecipe Pattern\n\nUse when you need to see all files before making changes, generate new files, or share data across files.\n\n```java\n@Value\n@EqualsAndHashCode(callSuper = false)\npublic class YourScanningRecipe extends ScanningRecipe<YourAccumulator> {\n\n    public static class YourAccumulator {\n        Map<SourceFile, Boolean> fileData = new HashMap<>();\n    }\n\n    @Override\n    public YourAccumulator getInitialValue(ExecutionContext ctx) {\n        return new YourAccumulator();\n    }\n\n    @Override\n    public TreeVisitor<?, ExecutionContext> getScanner(YourAccumulator acc) {\n        return new TreeVisitor<Tree, ExecutionContext>() {\n            @Override\n            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {\n                // Collect data into accumulator\n                return tree;\n            }\n        };\n    }\n\n    @Override\n    public TreeVisitor<?, ExecutionContext> getVisitor(YourAccumulator acc) {\n        return new TreeVisitor<Tree, ExecutionContext>() {\n            @Override\n            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {\n                // Use data from accumulator to make changes\n                return tree;\n            }\n        };\n    }\n}\n```\n\nFor complete example, see `./examples/example-scanning-recipe.java`.\n\n## Testing Recipes\n\n### Test Structure\n\nUse the RewriteTest interface for all recipe tests.\n\n```java\nclass YourRecipeTest implements RewriteTest {\n\n    @Override\n    public void defaults(RecipeSpec spec) {\n        spec.recipe(new YourRecipe(\"parameter-value\"));\n    }\n\n    @Test\n    void makesExpectedChange() {\n        rewriteRun(\n            //language=java\n            java(\n                // Before\n                \"\"\"\n                  package com.example;\n                  class Before { }\n                  \"\"\",\n                // After\n                \"\"\"\n                  package com.example;\n                  class After { }\n                  \"\"\"\n            )\n        );\n    }\n\n    @Test\n    void doesNotChangeWhenNotNeeded() {\n        rewriteRun(\n            //language=java\n            java(\n                \"\"\"\n                  package com.example;\n                  class AlreadyCorrect { }\n                  \"\"\"\n                // No second argument = no change expected\n            )\n        );\n    }\n}\n```\n\n### Testing Best Practices\n\n- **Test both changes AND no-changes cases** - Ensure recipe doesn't modify unrelated code\n- **Test edge cases** - Nulls, empty files, missing elements, multi-document YAML\n- **Test harness runs multiple cycles** - Ensures idempotence automatically\n- **Add `//language=XXX` comments** - Helps IDE syntax highlight test code\n- **Use text blocks properly** - End `\"\"\"` delimiter one indent to right of open delimiter\n\n### YAML-Specific Testing\n\n**Multi-document YAML:**\n\n```java\n@Test\nvoid handlesMultiDocumentYaml() {\n    rewriteRun(\n        //language=yaml\n        yaml(\n            \"\"\"\n              ---\n              first: document\n              ---\n              second: document\n              \"\"\",\n            \"\"\"\n              ---\n              first: updated\n              ---\n              second: updated\n              \"\"\"\n        )\n    );\n}\n```\n\n**Null value handling:**\n\n```java\n@Test\nvoid handlesNullValues() {\n    rewriteRun(\n        //language=yaml\n        yaml(\n            \"\"\"\n              key: null\n              another:\n              \"\"\"\n            // Should not crash or change\n        )\n    );\n}\n```\n\n**Comment preservation:**\n\n```java\n@Test\nvoid preservesComments() {\n    rewriteRun(\n        //language=yaml\n        yaml(\n            \"\"\"\n              # Important comment\n              key: oldValue\n              \"\"\",\n            \"\"\"\n              # Important comment\n              key: newValue\n              \"\"\"\n        )\n    );\n}\n```\n\nFor more testing patterns, see `./references/testing-patterns.md`.\n\n## Advanced Features\n\n### OpenRewrite Traits\n\nTraits provide semantic abstractions over LST elements, wrapping them with domain-specific logic.\n\n**When to use traits:**\n- You need reusable matching logic across multiple recipes\n- You want to separate \"what to find\" from \"what to do\"\n- You're working with complex LST patterns repeatedly\n\n**Basic trait structure:**\n\n```java\n@Value\npublic class YourTrait implements Trait<J.ClassDeclaration> {\n    Cursor cursor;\n\n    // Domain-specific accessor\n    public String getClassName() {\n        return getTree().getSimpleName();\n    }\n\n    // Nested Matcher class\n    public static class Matcher extends SimpleTraitMatcher<J.ClassDeclaration> {\n        @Override\n        protected @Nullable YourTrait test(Cursor cursor) {\n            J.ClassDeclaration cd = cursor.getValue();\n            // Custom matching logic\n            if (matchesCondition(cd)) {\n                return new YourTrait(cursor);\n            }\n            return null;\n        }\n    }\n}\n```\n\n**Using traits in recipes:**\n\n```java\n@Override\npublic TreeVisitor<?, ExecutionContext> getVisitor() {\n    return new YourTrait.Matcher().asVisitor((trait, ctx) -> {\n        String className = trait.getClassName();\n        // Use semantic API instead of raw LST navigation\n        return trait.getTree();\n    });\n}\n```\n\n**IMPORTANT:** Never use deprecated `Traits` utility classes. Always instantiate matchers directly:\n\n```java\n// ❌ Old (deprecated):\nTraits.literal()\n\n// ✅ New (preferred):\nnew Literal.Matcher()\n```\n\nFor complete trait implementation guide, see `./references/trait-implementation-guide.md`.\n\n### Preconditions (Performance Optimization)\n\nPreconditions filter files before running the recipe, improving performance.\n\n**Common preconditions:**\n\n```java\n// Only run on files using specific type\nnew UsesType<>(\"com.example.Type\", true)\n\n// Only run on files with specific method\nnew UsesMethod<>(\"com.example.Type methodName(..)\")\n\n// Only run on specific Java version\nnew UsesJavaVersion<>(17)\n\n// Only run on YAML files\nnew FindSourceFiles(\"**/*.yml\", \"**/*.yaml\")\n```\n\n**Combining preconditions:**\n\n```java\n@Override\npublic TreeVisitor<?, ExecutionContext> getVisitor() {\n    return Preconditions.check(\n        Preconditions.and(\n            new UsesType<>(\"com.example.Type\", true),\n            new UsesJavaVersion<>(11)\n        ),\n        new YourVisitor()\n    );\n}\n```\n\n### JavaTemplate Deep Dive\n\nJavaTemplate compiles code snippets once and applies them to LST elements.\n\n**When to use:**\n- Adding new code structures (methods, statements, expressions)\n- Complex code generation that's tedious with LST methods\n\n**When NOT to use:**\n- Modifying existing elements (use `.withX()` methods)\n- Simple changes (reordering, renaming, removing)\n\n**Template syntax:**\n\n```java\n// Untyped substitution (strings)\nJavaTemplate.builder(\"System.out.println(#{})\")\n    .build();\n\n// Typed substitution (LST elements)\nJavaTemplate.builder(\"return #{any(java.lang.String)}\")\n    .build();\n\n// With imports\nJavaTemplate.builder(\"List<String> list = new ArrayList<>()\")\n    .imports(\"java.util.List\", \"java.util.ArrayList\")\n    .build();\n\n// With classpath\nJavaTemplate.builder(\"@Deprecated(since = \\\"2.0\\\")\")\n    .javaParser(JavaParser.fromJavaVersion().classpath(\"library-name\"))\n    .build();\n\n// Context-sensitive (references local scope)\nJavaTemplate.builder(\"localVariable.method()\")\n    .contextSensitive()\n    .build();\n```\n\n**Applying templates:**\n\n```java\n// Apply to statement position\nmethod.withBody(\n    template.apply(\n        new Cursor(getCursor(), method.getBody()),\n        method.getBody().getCoordinates().lastStatement(),\n        args\n    )\n);\n```\n\n**Tips:**\n- Context-free templates (default) are faster\n- Use `.contextSensitive()` only when referencing local variables/methods\n- Declare all imports explicitly\n- Escape special characters in template strings\n\n### State Management\n\n**Within visitor (intra-visitor state):**\n\n```java\n// Store state\ngetCursor().putMessage(\"key\", value);\n\n// Retrieve state from cursor hierarchy\nObject value = getCursor().getNearestMessage(\"key\");\n```\n\n**Between visitors (ScanningRecipe):**\n\nUse accumulator pattern - see ScanningRecipe section above.\n\n**Never:**\n- Use ExecutionContext for visitor state\n- Mutate recipe instance fields\n- Use static variables\n\n### Multi-Module Projects\n\nTrack data per-project, not globally:\n\n```java\npublic static class Accumulator {\n    // ✅ Per-project tracking\n    Map<SourceFile, Boolean> fileData = new HashMap<>();\n\n    // ❌ Don't assume single project\n    // boolean globalFlag;\n}\n```\n\n## Troubleshooting\n\nCommon issues and solutions when developing recipes.\n\n### Recipe Not Running on Expected Files\n\n**Symptoms:** Recipe doesn't execute on files you expect to change\n\n**Solutions:**\n1. Check preconditions - might be too restrictive\n2. Verify file matches visitor type (JavaIsoVisitor for Java, YamlIsoVisitor for YAML)\n3. Add debug logging to visitor methods\n4. Ensure the file contains the patterns you're looking for\n5. For YAML: Check file extension (`.yml` vs `.yaml`)\n\n### JavaTemplate Parse Errors\n\n**Symptoms:** Template fails to compile or apply\n\n**Solutions:**\n1. Check imports are declared with `.imports()`\n2. Verify classpath includes all referenced types with `.javaParser()`\n3. Use `.contextSensitive()` if referencing local scope\n4. Escape special characters in template strings\n5. Ensure placeholder syntax is correct:\n   - `#{}` for strings\n   - `#{any(Type)}` for LST elements\n\n### Tests Passing But Recipe Doesn't Work in Real Code\n\n**Symptoms:** RewriteTest passes but recipe fails on actual projects\n\n**Solutions:**\n1. Add more realistic test cases with complex code\n2. Test with external dependencies via parser configuration\n3. Verify preconditions match real-world usage\n4. Check for edge cases not covered in tests\n5. Test with different Java versions if version-specific\n\n### Recipe Makes Changes But Not Idempotent\n\n**Symptoms:** Running recipe multiple times produces different results each time\n\n**Solutions:**\n1. Ensure all checks use referential equality (return unchanged LST if no change needed)\n2. Verify visitor doesn't accumulate state between invocations\n3. Check that `getVisitor()` returns a NEW instance each time\n4. Ensure recipe class is immutable (uses `@Value`)\n5. Test with `rewriteRun()` which automatically runs multiple cycles\n\n### Type Information Not Available\n\n**Symptoms:** `TypeUtils.isOfClassType()` returns false when it should be true\n\n**Solutions:**\n1. Ensure test configures classpath with required dependencies\n2. Check that imports are present in the source file\n3. Verify the type binding resolved correctly (check for `null` types)\n4. Add explicit type attribution if working with dynamic code\n\n### YAML Recipe Not Matching Expected Elements\n\n**Symptoms:** YAML recipe doesn't find or transform expected YAML elements\n\n**Solutions:**\n1. Check JsonPath pattern is correct - test with online JsonPath evaluator\n2. Verify you're using correct LST visitor method (visitScalar vs visitMappingEntry)\n3. Handle null values safely - YAML allows `key: null` and `key:`\n4. Check for multi-document YAML (starts with `---`)\n5. Verify you're calling `super.visitX()` to traverse tree\n\n### YAML Comments or Formatting Not Preserved\n\n**Symptoms:** Recipe changes YAML but loses comments or formatting\n\n**Solutions:**\n1. Never create new LST elements - always use `.withX()` methods\n2. Use `ListUtils` for list operations, never mutate directly\n3. Return original element if no change needed (identity check)\n4. Check you're not replacing entire nodes unnecessarily\n\nFor more troubleshooting guidance, see `./references/troubleshooting-guide.md`.\n\n## Critical Best Practices\n\n### Do No Harm\n- If unsure whether a change is safe, DON'T make it\n- Make minimal, least invasive changes\n- Respect existing formatting and comments\n- Return unchanged LST if no change needed\n\n### Immutability & Idempotence\n- Recipes must be immutable (no mutable state)\n- Same input → same output, always\n- Use `@Value` and `@EqualsAndHashCode(callSuper = false)`\n- `getVisitor()` must return NEW instance each time\n\n### Never Mutate LSTs\n```java\n// WRONG\nmethod.getArguments().remove(0);\n\n// CORRECT\nmethod.withArguments(ListUtils.map(method.getArguments(), (i, arg) ->\n    i == 0 ? null : arg\n));\n```\n\n### Naming Conventions\n- Display names: Sentence case, code in backticks, end with period\n- Example: \"Change type from `OldType` to `NewType`.\"\n- Recipe names: `com.yourorg.VerbNoun` (e.g., `com.yourorg.ChangePackage`)\n\n## Accessing Bundled Resources\n\nThis skill uses progressive disclosure to minimize token usage. Load resources on demand:\n\n### Templates (for boilerplate code)\n- `templates/template-imperative-recipe.java` - Complete recipe class structure\n- `templates/template-declarative-recipe.yml` - YAML recipe format\n- `templates/template-refaster-template.java` - Refaster template structure\n- `templates/template-recipe-test.java` - Test class using RewriteTest\n- `templates/license-header.txt` - Standard license header\n\n### Examples (for working patterns)\n- `examples/example-say-hello-recipe.java` - Simple recipe with JavaTemplate\n- `examples/example-scanning-recipe.java` - Multi-file analysis pattern\n- `examples/example-yaml-github-actions.java` - YAML domain example\n- `examples/example-declarative-migration.yml` - Framework migration\n\n### References (for detailed guidance)\n- `references/java-lst-reference.md` - Java LST structure and hierarchy\n- `references/yaml-lst-reference.md` - YAML LST structure and hierarchy\n- `references/jsonpath-patterns.md` - Domain-specific JsonPath patterns\n- `references/trait-implementation-guide.md` - Advanced trait patterns\n- `references/checklist-recipe-development.md` - 200+ validation items\n- `references/common-patterns.md` - Copy-paste code snippets\n- `references/testing-patterns.md` - Test patterns and edge cases\n- `references/troubleshooting-guide.md` - Issue diagnosis and solutions\n\n### When to Load Resources\n\n| Resource Type | Typical Size | When to Load |\n|--------------|-------------|--------------|\n| SKILL.md | ~3,500 tokens | Always (auto) |\n| Templates | ~500 tokens each | On demand (Read tool) |\n| Examples | ~1,000 tokens each | On demand (Read tool) |\n| References | ~1,500-3,000 tokens each | On demand (Read tool) |\n\n**Best practice:** Only read templates/examples when actively working on implementation. The SKILL.md content provides sufficient guidance for planning and decision-making.\n\n## Quick Reference\n\n### Key Classes\n\n| Class | Purpose |\n|-------|---------|\n| `Recipe` | Base class for all recipes |\n| `JavaIsoVisitor<ExecutionContext>` | Most common Java visitor type |\n| `YamlIsoVisitor<ExecutionContext>` | Most common YAML visitor type |\n| `JavaTemplate` | Generate Java code snippets |\n| `RewriteTest` | Testing interface |\n| `ScanningRecipe<T>` | Multi-file analysis pattern |\n| `JsonPathMatcher` | Match YAML/JSON paths |\n\n### Key Methods\n\n| Method | Purpose |\n|--------|---------|\n| `getVisitor()` | Returns visitor instance (must be NEW) |\n| `super.visitX()` | Traverse subtree |\n| `.withX()` | Create modified LST copy (immutable) |\n| `ListUtils.map()` | Transform lists without mutation |\n| `doAfterVisit()` | Chain additional visitors |\n| `maybeAddImport()` | Add import if not present |\n| `maybeRemoveImport()` | Remove import if unused |\n| `getCursor().putMessage()` | Store intra-visitor state |\n\n### Common Patterns\n\nFor quick reference on frequently used patterns, see:\n- `references/common-patterns.md` - Import management, visitor chaining, type checking\n- `references/jsonpath-patterns.md` - GitHub Actions, Kubernetes, CI/CD patterns\n\n## Automation Scripts\n\nUse helper scripts for common tasks:\n\n- **`./scripts/init_recipe.py <RecipeName>`** - Generate recipe boilerplate (class, test file, optional YAML)\n- **`./scripts/validate_recipe.py [path]`** - Validate recipe structure, naming, Java compatibility\n- **`./scripts/add_license_header.sh [file]`** - Add license headers from `gradle/licenseHeader.txt`\n\n## Token Budget Awareness\n\nThis skill is optimized for token efficiency:\n\n- **SKILL.md**: ~3,500 tokens (loaded when skill activates)\n- **Templates**: Load only when creating new recipes\n- **Examples**: Load only when learning specific patterns\n- **References**: Load only when you need deep dives or validation\n\n**Strategy:** Start with SKILL.md guidance. Load templates for boilerplate. Load references for troubleshooting or advanced features.\n\n## Remember\n\n- **Always start with tests (RED)**\n- **Try declarative before Refaster before imperative**\n- **Apply idioms during REFACTOR, not GREEN**\n- **Document with markdown for clarity**\n- **Validate production-readiness before completion**\n- **Preserve formatting and comments**\n- **Do no harm - when in doubt, don't change**"
              }
            ]
          },
          {
            "name": "claude",
            "description": null,
            "source": "./plugins/claude",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add sjungling/claude-plugins",
              "/plugin install claude@claude-plugins"
            ],
            "signals": {
              "stars": 6,
              "forks": 0,
              "pushed_at": "2025-12-20T22:50:31Z",
              "created_at": "2025-10-10T04:14:44Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/list-skills",
                "description": "List all available Claude Code skills in a formatted table",
                "path": "plugins/claude/commands/list-skills.md",
                "frontmatter": {
                  "description": "List all available Claude Code skills in a formatted table",
                  "allowed-tools": [
                    "Bash",
                    "Read",
                    "Glob"
                  ]
                },
                "content": "List all available Claude Code skills and display them in a readable format optimized for terminal viewing.\n\n**Group skills by plugin source** to keep related skills together. Use this format:\n\n```\nAvailable Skills:\n\nPlugin: {plugin-source}\n\n{skill-name}\n  Description: {description}\n\n{skill-name-2}\n  Description: {description}\n\nPlugin: {another-plugin-source}\n\n{skill-name-3}\n  Description: {description}\n```\n\n**Important formatting rules:**\n- Group all skills from the same plugin/marketplace together\n- Show \"Plugin: {source}\" header once per group\n- Under each skill, show ONLY the skill name and description (don't repeat the plugin source)\n- If a skill appears multiple times (e.g., \"2 instances\"), note that in the skill name line\n- Keep full descriptions (no truncation) - natural line wrapping is fine\n- Add blank lines between plugin groups for visual separation\n\nAt the end, include usage instructions:\n```\nUsage:\n  Invoke with: Skill tool using skill name\n  Example: ui-engineering:senior-ui-engineer\n```"
              },
              {
                "name": "/review-command",
                "description": "Review a Claude Code slash command and recommend improvements based on best practices",
                "path": "plugins/claude/commands/review-command.md",
                "frontmatter": {
                  "description": "Review a Claude Code slash command and recommend improvements based on best practices",
                  "argument-hint": [
                    "path-to-command.md"
                  ],
                  "allowed-tools": [
                    "Read",
                    "WebFetch",
                    "Glob"
                  ]
                },
                "content": "Review the Claude Code slash command located at: **$1**\n\nFirst, fetch the official documentation from https://docs.claude.com/en/docs/claude-code/slash-commands.md to understand current best practices.\n\nThen read the command file and analyze it for conformance to best practices. Provide actionable recommendations for improvements.\n\nFocus on:\n\n- **Frontmatter Quality**:\n  - Presence of `description` field (clear, concise explanation)\n  - Proper use of `argument-hint` for auto-completion guidance\n  - `allowed-tools` specification (explicit permissions vs. inherited)\n  - `model` specification if needed for specific Claude models\n  - `disable-model-invocation` if command shouldn't be auto-invoked\n\n- **Argument Handling**:\n  - Appropriate use of `$1`, `$2` positional parameters vs `$ARGUMENTS`\n  - Clear documentation of expected arguments in the prompt\n  - Sensible defaults for optional arguments\n  - Validation logic for required arguments\n\n- **Command Focus**:\n  - Single, well-defined purpose (not trying to do too much)\n  - Clear use case that's distinct from skills/agents\n  - Appropriate for \"simple prompt snippets used often\"\n\n- **Writing Style**:\n  - Clear, actionable instructions\n  - Proper use of file references with '@' prefix if needed (e.g., @path/to/file.md)\n  - Proper use of bash execution with '!' prefix if needed\n  - Examples provided where helpful\n\n- **Tool Permissions**:\n  - 'allowed-tools' explicitly declared in frontmatter\n  - Only necessary tools included\n  - Bash commands specific rather than broad if using '!' prefix\n\n- **Documentation Quality**:\n  - Description field matches actual command behavior\n  - Argument expectations clearly documented\n  - Usage examples provided where helpful\n\nProvide prioritized, specific recommendations organized by:\n1. **Critical** - Must fix for proper functionality or security\n2. **Important** - Should fix for best practices alignment\n3. **Nice-to-have** - Optional improvements for enhanced quality\n\nFor each recommendation:\n- Explain the issue clearly with reference to official documentation\n- Provide concrete examples of how to fix it\n- Reference specific lines in the command file when applicable\n- Show before/after examples for clarity\n\nHighlight what the command does well and offer to implement improvements if requested.\n\nIf the command file path is not provided, search for `.md` files in `.claude/commands/` in the current working directory and offer to review them."
              },
              {
                "name": "/review-skill",
                "description": "Review a Claude Code skill and recommend improvements to conform to best practices",
                "path": "plugins/claude/commands/review-skill.md",
                "frontmatter": {
                  "description": "Review a Claude Code skill and recommend improvements to conform to best practices",
                  "argument-hint": [
                    "path/to/skill/directory or skill-name"
                  ],
                  "allowed-tools": [
                    "Task",
                    "Skill",
                    "Read",
                    "Glob"
                  ]
                },
                "content": "Review the Claude Code skill located at: **$1**\n\nUse the Skill tool to invoke `example-skills:skill-creator` to access comprehensive skill creation guidance, validation scripts, and packaging tools.\n\nRead all files in the skill directory including SKILL.md, reference materials, templates, and scripts. Review the skill for conformance to best practices and provide actionable recommendations for improvements.\n\nFocus on:\n\n- **Metadata Quality**: Frontmatter completeness (name, description fields) with clear activation triggers and technology keywords\n- **Progressive Disclosure**: Proper use of bundled resources (scripts/, references/, assets/) and when to load them\n- **Writing Style**: Imperative/infinitive form (verb-first instructions), not second person\n- **Prompt Quality**: Clarity, structure, effectiveness, and adherence to skill creation process\n- **Examples and Usage**: Clear guidance on when to use and when NOT to use\n- **Tool Specifications**: Proper tool usage patterns and integrations\n- **Validation**: Run validation checks if available (mention `scripts/package_skill.py` for validation)\n\nProvide prioritized, specific recommendations organized by:\n1. **Critical** - Must fix for proper functionality\n2. **Important** - Should fix for best practices alignment\n3. **Nice-to-have** - Optional improvements for enhanced quality\n\nFor each recommendation:\n- Explain the issue clearly\n- Provide concrete examples of how to fix it\n- Reference specific files and line numbers when applicable\n\nHighlight what the skill does well and offer to implement improvements if requested. If the skill appears ready for distribution, mention that `scripts/package_skill.py` can validate and package it.\n\nIf the skill directory path is not provided, search for skill directories in `.claude/skills/` or `plugins/*/skills/` in the current working directory and offer to review them."
              }
            ],
            "skills": [
              {
                "name": "builder",
                "description": "Expert in creating Claude Code subagents, skills, slash commands, plugins, and plugin marketplaces. Automatically activates when working with .md files in .claude/ directories, agent/command/skill frontmatter, marketplace.json, or when discussing Claude Code extensibility and component creation.",
                "path": "plugins/claude/skills/builder/SKILL.md",
                "frontmatter": {
                  "name": "builder",
                  "description": "Expert in creating Claude Code subagents, skills, slash commands, plugins, and plugin marketplaces. Automatically activates when working with .md files in .claude/ directories, agent/command/skill frontmatter, marketplace.json, or when discussing Claude Code extensibility and component creation."
                },
                "content": "# Claude Code Builder\n\nExpert guidance for creating Claude Code subagents, skills, slash commands, plugins, and plugin marketplaces.\n\n## Automatic Activation\n\nThis skill automatically activates when:\n- Creating or editing `.claude/agents/*.md` files\n- Working with `.claude/commands/*.md` files\n- Developing `skills/*/SKILL.md` files\n- Configuring `.claude-plugin/plugin.json` or `marketplace.json`\n- Working with files in `.claude/` directories\n- Users ask \"How do I create a Claude Code skill?\"\n- Users ask \"How do I make a slash command?\"\n- Users mention \"building a plugin\" or \"creating an agent\"\n- Discussing Claude Code extensibility and customization\n\n## When NOT to Use This Skill\n\nDo not use this skill for:\n- General Claude Code usage questions (non-extensibility topics)\n- Debugging existing user code (unless related to plugin development)\n- Standard development tasks unrelated to Claude Code components\n- Basic Claude Code CLI operations (use `/help` instead)\n- Questions about using existing plugins (rather than creating them)\n\n## Quick Start\n\n### Progressive Disclosure Design Principle\n\nClaude Code components use a three-level loading system to manage context efficiently:\n\n1. **Metadata (name + description)** - Always in context (~100 words)\n2. **Component body** - Loaded when component triggers (<5k words recommended)\n3. **Bundled resources** - Loaded as needed (unlimited)\n\nDesign components to be lean in the body, delegating detailed information to bundled references. This approach keeps the context window efficient while making specialized knowledge available when needed.\n\n### Creating a New Component\n\nBefore starting, determine which component type fits the requirements:\n\n- **Skill**: Automatic activation based on context (preferred for most use cases)\n- **Slash Command**: Quick keyboard shortcuts for common tasks\n- **Subagent**: Delegatable workflows needing context isolation\n- **Plugin**: Package multiple components for distribution\n\n### Component Selection Guide\n\n| Need | Use | Example |\n|------|-----|---------|\n| Always-available guidance | Skill | Code style patterns, debugging workflows |\n| Keyboard shortcut | Command | `/format-code`, `/run-tests` |\n| Delegatable workflow | Subagent | Code reviews, complex migrations |\n| Package for distribution | Plugin | Collection of related components |\n| Validate prerequisites | Hook | Check dependencies, verify API keys |\n\n## Core Workflows\n\n### 1. Creating a Skill\n\nSkills provide automatic, context-aware guidance.\n\n**Steps**:\n1. Create directory: `skills/skill-name/`\n2. Create `SKILL.md` with frontmatter\n3. Write comprehensive description with trigger keywords\n4. Add skill content with examples and patterns\n5. Bundle reference materials in subdirectories\n6. Test activation contexts\n\n**See**: `./references/skills-guide.md` for complete best practices\n\n### 2. Creating a Slash Command\n\nCommands provide quick shortcuts for common tasks.\n\n**Steps**:\n1. Create file: `commands/command-name.md`\n2. Add optional YAML frontmatter (description, allowed-tools, args)\n3. Write command prompt with argument placeholders\n4. Preapprove necessary tools\n5. Test command execution\n\n**See**: `./references/slash-commands-guide.md` for complete best practices\n\n### 3. Creating a Subagent\n\nSubagents provide specialized expertise and delegatable workflows.\n\n**Steps**:\n1. Create file: `agents/agent-name.md`\n2. Add required YAML frontmatter (name, description, model, color, tools)\n3. Write focused system prompt\n4. Define workflows and success criteria\n5. Test with Task tool\n\n**See**: `./references/subagents-guide.md` for complete best practices\n\n### 4. Creating a Plugin\n\nPlugins package components for distribution.\n\n**Quick Start**: Plugin scaffold generator usage:\n```bash\npython ./scripts/init_plugin.py --name my-plugin --description \"Description\" --author \"Your Name\"\n```\n\n**Steps**:\n1. Create plugin directory structure (or use `./scripts/init_plugin.py`)\n2. Create `.claude-plugin/plugin.json` with metadata\n3. Add components (agents, commands, skills)\n4. Create README.md and SKILLS.md\n5. Register in marketplace.json\n6. Validate marketplace configuration (use `./scripts/validate_marketplace.py`)\n7. Test installation\n\n**See**: `./references/plugins-guide.md` for complete best practices\n\n### 5. Creating Hooks\n\nHooks validate prerequisites and control tool execution.\n\n**Steps**:\n1. Create `hooks/hooks.json` configuration\n2. Create hook script in `scripts/` directory\n3. Make script executable (`chmod +x`)\n4. Implement proper input/output contract\n5. Test with mock inputs\n6. Verify error messages are helpful\n\n**See**: `./references/hooks-guide.md` for complete best practices\n\n## YAML Frontmatter Quick Reference\n\n**Note**: This is a quick reference. See individual reference guides for complete schema details.\n\n### Skills (SKILL.md)\n\n```yaml\n---\nname: skill-name\ndescription: Expert in [domain]. Automatically activates when [triggers]...\n---\n```\n\n**Note**: Skills support ONLY `name` and `description` in frontmatter. Unlike subagents, skills do not support `version`, `model`, `color`, `tools`, or any other fields. Additional fields will be ignored.\n\nSee `./references/skills-guide.md` for complete frontmatter specification.\n\n### Subagents (agents/*.md)\n\n```yaml\n---\nname: agent-name\ndescription: Agent purpose...\nmodel: inherit\ncolor: blue\ntools: Read, Write, Edit\n---\n```\n\nSee `./references/subagents-guide.md` for complete frontmatter specification.\n\n### Slash Commands (commands/*.md)\n\n```yaml\n---\ndescription: Command description\nallowed-tools:\n  - Bash(npm:*)\nargs:\n  - name: arg-name\n    description: What it does\n---\n```\n\nSee `./references/slash-commands-guide.md` for complete frontmatter specification.\n\n## Best Practices\n\n### Skill Development\n\n**Do**:\n- Write descriptions with specific activation triggers\n- Include technology names and file patterns\n- Bundle reference materials in skill directory\n- Test in multiple contexts to verify activation\n- Start description with third-person voice\n\n**Don't**:\n- Write descriptions too generic\n- Omit specific technologies from description\n- Include network-dependent resources\n- Use skills for simple linear workflows (use commands instead)\n\n### Command Development\n\n**Do**:\n- Use clear, descriptive command names\n- Preapprove necessary tools\n- Document arguments\n- Include error handling guidance\n- Support argument substitution\n\n**Don't**:\n- Preapprove dangerous commands unnecessarily\n- Create commands for complex decision-making (use agents/skills)\n- Skip testing with different argument combinations\n\n### Subagent Development\n\n**Do**:\n- Focus on specific domain expertise\n- Provide step-by-step workflows\n- Reference authoritative documentation\n- Define clear success criteria\n- Restrict tools appropriately\n\n**Don't**:\n- Create agents too general-purpose\n- Duplicate main Claude capabilities\n- Create overly complex nested workflows\n- Skip examples in description\n\n### Plugin Development\n\n**Do**:\n- Focus on specific use case or domain\n- Provide comprehensive documentation\n- Test all components before publishing\n- Use semantic versioning\n- Include usage examples\n\n**Don't**:\n- Create unfocused plugins\n- Use absolute paths in configuration\n- Skip testing installation process\n- Omit documentation for any components\n\n## Common Patterns\n\n**Component Templates**: Use provided templates as starting points:\n- `./assets/templates/plugin.json` - Plugin metadata template\n- `./assets/templates/agent-template.md` - Subagent structure template\n- `./assets/templates/skill-template.md` - Skill structure template\n- `./assets/templates/command-template.md` - Slash command template\n\n### Skill with References\n\n```\nskill-name/\n├── SKILL.md\n├── references/\n│   ├── guide.md\n│   └── patterns.md\n└── templates/\n    └── template.txt\n```\n\n### Multi-Component Plugin\n\n```\nplugin-name/\n├── .claude-plugin/\n│   └── plugin.json\n├── agents/\n│   └── expert.md\n├── commands/\n│   └── quick-action.md\n├── skills/\n│   └── auto-guidance/\n│       └── SKILL.md\n├── SKILLS.md\n└── README.md\n```\n\n### Command with Subagent\n\n```markdown\n---\ndescription: Complex workflow delegated to expert\nallowed-tools:\n  - Task\n---\n\nUse the domain-expert agent to [accomplish task].\n\nProvide the agent with:\n- [Context 1]\n- [Context 2]\n\nExpected deliverables:\n- [Output 1]\n- [Output 2]\n```\n\n## Troubleshooting\n\n### Skill Not Activating\n\n**Problem**: Skill doesn't trigger in expected contexts\n\n**Solutions**:\n- Add more specific keywords to description\n- Include technology/framework names\n- Mention file patterns (.swift, .tsx, etc.)\n- Start description with third-person voice\n- Test different `description` variations\n\n### Invalid YAML Frontmatter\n\n**Problem**: Component fails to load\n\n**Solutions**:\n- Validate YAML syntax (indentation, colons, dashes)\n- Check field names match requirements\n- Verify string values are quoted if they contain special chars\n- Ensure name fields use kebab-case\n\n### Command Tools Not Preapproved\n\n**Problem**: Command prompts for approval repeatedly\n\n**Solutions**:\n- Add tools to `allowed-tools` array\n- Use glob patterns for flexibility: `Bash(npm:*)`\n- Include all commands the workflow requires\n- Test command to identify missing approvals\n\n### Plugin Not Installing\n\n**Problem**: Plugin installation fails\n\n**Solutions**:\n- Verify `source` path uses `./` prefix\n- Check all component paths are relative\n- Validate marketplace.json is valid JSON\n- Ensure files exist at specified paths\n- Test with: `cat marketplace.json | python -m json.tool`\n\n## Bundled Resources\n\nThis skill includes bundled resources to support component creation:\n\n**References** (loaded into context as needed):\n- `./references/subagents-guide.md` - Complete frontmatter reference, system prompt best practices, testing and integration patterns, common agent patterns\n- `./references/skills-guide.md` - Description writing for activation, content structure recommendations, bundling reference materials, discovery and testing\n- `./references/slash-commands-guide.md` - Tool preapproval syntax, argument handling, workflow patterns, security considerations\n- `./references/plugins-guide.md` - Plugin structure and metadata, marketplace configuration, installation and distribution, testing and versioning\n- `./references/hooks-guide.md` - Hook types and when to use them, PreToolUse hook implementation, input/output contracts, validation patterns and best practices\n\n**Scripts** (executable utilities):\n- `./scripts/init_plugin.py` - Generate plugin scaffold with complete directory structure (agents/, commands/, skills/, .claude-plugin/)\n- `./scripts/validate_marketplace.py` - Validate marketplace.json configuration for correctness and best practices\n\n**Assets** (templates used in output):\n- `./assets/templates/plugin.json` - Plugin metadata template with standard fields\n- `./assets/templates/agent-template.md` - Subagent structure template with frontmatter and system prompt sections\n- `./assets/templates/skill-template.md` - Skill structure template with activation triggers and bundled resources\n- `./assets/templates/command-template.md` - Slash command template with argument handling and tool preapprovals\n\n## Examples\n\n### Example: Creating a Testing Skill\n\n```yaml\n---\nname: api-testing-patterns\ndescription: Expert in API testing patterns. Automatically activates when writing tests for REST APIs, GraphQL endpoints, or API integration tests - provides patterns for request mocking, response validation, authentication testing, and error scenario coverage\n---\n\n# API Testing Patterns\n\n## Quick Start\n\nWhen testing API endpoints:\n1. Arrange: Set up test data and mocks\n2. Act: Make the API request\n3. Assert: Validate response\n4. Cleanup: Reset state\n\n[Additional content with patterns and examples]\n```\n\n### Example: Creating a Deployment Command\n\n```markdown\n---\ndescription: Deploy application to specified environment\nallowed-tools:\n  - Bash(git:*)\n  - Bash(npm run deploy:*)\n  - Bash(gh:*)\nargs:\n  - name: environment\n    description: Target environment (dev, staging, prod)\n---\n\nDeploy to $1 environment:\n\n1. Verify git status is clean\n2. Run deployment script for $1\n3. Monitor deployment status\n4. Create deployment record\n\nUse: /deploy staging\n```\n\n### Example: Creating a Code Review Agent\n\n```yaml\n---\nname: code-reviewer\ndescription: Expert code reviewer analyzing code quality, best practices, security, and maintainability. Use for comprehensive code reviews before merging.\nmodel: inherit\ncolor: purple\ntools: Read, Grep, Glob\n---\n\nYou are an expert code reviewer specializing in code quality, security, and maintainability.\n\n## Review Process\n\n1. Analyze changed files for:\n   - Code quality and readability\n   - Security vulnerabilities\n   - Performance implications\n   - Test coverage\n\n2. Provide feedback on:\n   - Best practices adherence\n   - Design patterns\n   - Error handling\n   - Documentation\n\n3. Suggest improvements with examples\n\n[Additional review guidelines]\n```\n\n## Success Criteria\n\nClaude Code components are successful when:\n\n**Skills**:\n- Activate automatically in appropriate contexts\n- Provide clear, actionable guidance\n- Include comprehensive examples\n- Bundle useful reference materials efficiently\n- Use third-person voice in description\n- Use imperative/infinitive form consistently in content\n\n**Commands**:\n- Execute workflows efficiently without unnecessary approval prompts\n- Handle arguments correctly with proper substitution\n- Have necessary tools preapproved in frontmatter\n- Provide clear feedback on execution status\n- Follow security best practices for destructive operations\n\n**Subagents**:\n- Stay focused on their domain expertise\n- Follow defined workflows consistently\n- Have appropriate tool access restrictions\n- Deliver expected results autonomously\n- Include usage examples in description\n\n**Plugins**:\n- Install without errors via marketplace\n- All components work as documented\n- Clear, comprehensive documentation provided\n- Properly versioned using semantic versioning\n- Use relative paths with `./` prefix in configurations\n\n## Documentation Links\n\n**Official Claude Code Documentation**:\n- Subagents: https://docs.claude.com/en/docs/claude-code/sub-agents.md\n- Skills: https://docs.claude.com/en/docs/agents-and-tools/agent-skills/overview.md\n- Slash Commands: https://docs.claude.com/en/docs/claude-code/slash-commands.md\n- Plugins: https://docs.claude.com/en/docs/claude-code/plugins.md\n- Plugin Marketplaces: https://docs.claude.com/en/docs/claude-code/plugin-marketplaces.md"
              }
            ]
          },
          {
            "name": "workflow",
            "description": null,
            "source": "./plugins/workflow",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add sjungling/claude-plugins",
              "/plugin install workflow@claude-plugins"
            ],
            "signals": {
              "stars": 6,
              "forks": 0,
              "pushed_at": "2025-12-20T22:50:31Z",
              "created_at": "2025-10-10T04:14:44Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/check-and-resolve",
                "description": "Run npm run check:all if available and resolve all issues found",
                "path": "plugins/workflow/commands/check-and-resolve.md",
                "frontmatter": {
                  "description": "Run npm run check:all if available and resolve all issues found",
                  "preapprovedTools": [
                    "Bash(npm:*)",
                    "Bash(git:*)",
                    "Read(**/*.*)",
                    "Edit(**/*.*)",
                    "Write(**/*.*)",
                    "Grep",
                    "Glob",
                    "TodoWrite"
                  ]
                },
                "content": "You are tasked with running quality checks and resolving all issues found. Follow these steps:\n\n# Workflow Overview\n\n```mermaid\nflowchart TD\n    Start([Start]) --> DetectEnv[Run npm run to list scripts]\n    DetectEnv --> HasScript{check:all available?}\n\n    HasScript -->|No| AskUser[Ask about alternative scripts]\n    HasScript -->|Yes| RunChecks[Run npm run check:all]\n\n    RunChecks --> ParseOutput[Parse errors, warnings, failures]\n    ParseOutput --> CreateTodos[Create TodoWrite list for all issues]\n\n    CreateTodos --> HasIssues{Issues found?}\n    HasIssues -->|No| Success[All checks pass]\n    HasIssues -->|Yes| NextIssue[Get next issue from todo]\n\n    NextIssue --> MarkInProgress[Mark todo as in_progress]\n    MarkInProgress --> ReadCode[Read affected files]\n    ReadCode --> UnderstandIssue[Analyze root cause]\n\n    UnderstandIssue --> FixIssue[Apply targeted fix with Edit]\n    FixIssue --> Verify[Re-run npm run check:all]\n\n    Verify --> FixWorked{Issue resolved?}\n    FixWorked -->|Yes| MarkComplete[Mark todo as completed]\n    FixWorked -->|No| Attempts{Attempts < 3?}\n\n    Attempts -->|Yes| TryAgain[Try alternative approach]\n    TryAgain --> ReadCode\n    Attempts -->|No| MarkBlocked[Mark as blocked, ask user]\n\n    MarkComplete --> MoreIssues{More issues?}\n    MarkBlocked --> MoreIssues\n\n    MoreIssues -->|Yes| NextIssue\n    MoreIssues -->|No| FinalCheck[Run full npm run check:all]\n\n    FinalCheck --> AllPassed{All checks pass?}\n    AllPassed -->|No| NewIssues[Add new issues to todo]\n    NewIssues --> NextIssue\n    AllPassed -->|Yes| Summary[Provide completion summary]\n\n    Summary --> End([End])\n    Success --> End\n    AskUser --> End\n\n    style Start fill:#90EE90\n    style End fill:#90EE90\n    style Success fill:#90EE90\n    style MarkBlocked fill:#FFB6C1\n    style AllPassed fill:#87CEEB\n```\n\n# 1. Environment Detection\n\nFirst, check if this is a Node.js project and if the check:all script is available:\n\n1. Run `npm run` to list all available scripts\n2. Check if `check:all` is in the output\n3. If the script is not available, inform the user and ask if they want to:\n   - Run alternative scripts (list the available ones from npm run output)\n   - Skip the check phase and just review existing issues\n\n# 2. Run Quality Checks\n\nIf `npm run check:all` is available:\n\n1. **Run the check command**:\n   ```bash\n   npm run check:all\n   ```\n\n2. **Capture and analyze output**:\n   - Parse the output to identify all errors, warnings, and failures\n   - Categorize issues by type:\n     - Type errors (TypeScript)\n     - Linting errors (ESLint, etc.)\n     - Test failures\n     - Formatting issues\n     - Other build/check errors\n\n3. **Create a task plan** using TodoWrite:\n   - Create one todo item for each distinct issue or group of related issues\n   - Use descriptive names like \"Fix type error in auth.ts:42\" or \"Resolve 5 ESLint errors in utils/\"\n   - Set the first task to in_progress\n\n# 3. Resolve Issues Systematically\n\nFor each issue found:\n\n1. **Read affected files**:\n   - Use Read tool to examine the problematic code\n   - Understand the context and root cause\n\n2. **Fix the issue**:\n   - Use Edit tool to make targeted fixes\n   - Ensure fixes are minimal and focused\n   - Prefer fixing root causes over suppressing warnings\n\n3. **Verify the fix**:\n   - Re-run `npm run check:all` to confirm the issue is resolved\n   - If new issues appear, add them to the todo list\n   - Mark the current todo as completed when verified\n\n4. **Move to next issue**:\n   - Update TodoWrite to mark current task completed\n   - Set next task to in_progress\n   - Continue until all issues are resolved\n\n# 4. Final Verification\n\nAfter resolving all issues:\n\n1. **Run full check suite**:\n   ```bash\n   npm run check:all\n   ```\n\n2. **Verify clean output**:\n   - Ensure all checks pass with no errors or warnings\n   - If any issues remain, add them to the todo list and continue resolving\n\n3. **Summary**:\n   - Provide a summary of all issues resolved\n   - Note any issues that couldn't be automatically fixed (if any)\n\n# Resolution Strategies\n\n## Type Errors\n- Add missing type annotations\n- Fix type mismatches\n- Add proper null/undefined checks\n- Update interface definitions if needed\n- Consider using type assertions only as last resort\n\n## Linting Errors\n- Fix formatting issues\n- Remove unused variables/imports\n- Add missing dependencies to useEffect/useCallback\n- Fix accessibility issues (a11y)\n- Resolve complexity warnings with refactoring\n\n## Test Failures\n- Update test expectations if code behavior changed correctly\n- Fix broken test setup/teardown\n- Add missing mocks or test data\n- Fix async timing issues\n- Update snapshots if UI changed intentionally\n\n## Formatting Issues\n- Let the formatter handle these automatically\n- Run `npm run format` or similar if available\n- Ensure .prettierrc or similar config is respected\n\n# Important Rules\n\n- **Never suppress errors** without understanding them - always fix the root cause\n- **Keep changes focused** - one issue at a time\n- **Verify after each fix** - don't accumulate untested changes\n- **Use TodoWrite** to track progress and give user visibility\n- **Ask for clarification** if an issue's resolution is ambiguous\n- **Document breaking changes** if any fixes require API changes\n- **Preserve functionality** - fixes should not change working behavior\n- **Stay idempotent** - re-running should be safe if interrupted\n\n# Error Handling\n\nIf a fix creates new issues:\n- Undo the problematic change\n- Add the new issue to the todo list\n- Try an alternative approach\n- Ask user for guidance if stuck\n\nIf stuck on an issue for more than 2-3 attempts:\n- Mark it in the todo list as blocked\n- Ask the user for guidance\n- Move to next issue and return later\n\n# Workflow Summary\n\n1. Detect environment and check if npm run check:all is available\n2. Run checks and capture all issues\n3. Create comprehensive todo list with all issues\n4. Resolve issues one by one, verifying each fix\n5. Re-run full check suite to confirm all issues resolved\n6. Provide summary of work completed\n\nProceed with running the checks and resolving all issues found."
              },
              {
                "name": "/clarify-issue",
                "description": "Clarify ambiguities in a GitHub issue through structured questioning",
                "path": "plugins/workflow/commands/clarify-issue.md",
                "frontmatter": {
                  "allowed-tools": "Bash(gh issue view:*), Bash(gh issue edit:*), Bash(git status:*), AskUserQuestion, Read(**/*.md), Write(**/*.md), Edit(**/*.md), mcp__use_browser, mcp__plugin_ui-engineering_figma-mcp__*",
                  "argument-hint": [
                    "issue-url"
                  ],
                  "description": "Clarify ambiguities in a GitHub issue through structured questioning"
                },
                "content": "Clarify ambiguities in GitHub issue: $ARGUMENTS\n\n## Argument Validation\n\n- Ensure an issue URL or number was provided and prompt the user if not.\n- Extract the issue number from the URL if a full URL was provided.\n\n## Context Gathering\n\nFetch the issue details using `gh`:\n\n```bash\ngh issue view \"$ISSUE_NUMBER\" --json number,title,body,url,labels,state\n```\n\nParse the issue title and body to understand the current specification.\n\n## Ambiguity Detection\n\nAnalyze the issue against these nine categories to identify gaps:\n\n1. **Functional Scope & Behavior**\n   - What specific capabilities must be delivered?\n   - What's explicitly out of scope?\n   - How should the feature behave in normal conditions?\n\n2. **Domain & Data Model**\n   - What entities, attributes, and relationships are involved?\n   - What validation rules apply?\n   - Are there existing data structures to extend or new ones to create?\n\n3. **Interaction & UX Flow**\n   - What's the user journey or workflow?\n   - What inputs are required and what outputs are produced?\n   - How should errors or feedback be communicated to users?\n\n4. **Non-Functional Quality Attributes**\n   - What are the performance, security, or accessibility requirements?\n   - What scale or load must be supported?\n   - Are there compliance or regulatory constraints?\n\n5. **Integration & External Dependencies**\n   - What APIs, services, or systems must integrate?\n   - What data formats or protocols are required?\n   - Are there authentication or authorization requirements?\n\n6. **Edge Cases & Failure Handling**\n   - What happens with invalid, missing, or malformed input?\n   - How should timeouts, network failures, or unavailable services be handled?\n   - What error states need graceful degradation?\n\n7. **Constraints & Tradeoffs**\n   - What technical or business constraints exist?\n   - What tradeoffs between speed, quality, scope are acceptable?\n   - What's the priority if resources are limited?\n\n8. **Terminology & Consistency**\n   - Are terms used consistently throughout the spec?\n   - Do any terms need clear definitions?\n   - Are there naming conventions to follow?\n\n9. **Completion Signals**\n   - What defines \"done\" for this feature?\n   - What testing is required?\n   - What documentation must be updated?\n\nFor each category, assign a status:\n- **Clear**: Well-defined and actionable\n- **Partial**: Some information present but gaps remain\n- **Missing**: No information or critically incomplete\n\n## Question Generation\n\nGenerate up to 5 targeted clarification questions that:\n- Address the highest-impact ambiguities (Partial or Missing categories)\n- Materially affect architecture, data modeling, testing, UX, operations, or compliance\n- Exclude trivial stylistic preferences\n- Can be answered with either:\n  - Multiple-choice (2-4 options with clear descriptions)\n  - Short-phrase responses\n\nFor each question:\n- Clearly state what's ambiguous and why it matters\n- If multiple-choice, identify and explain the recommended option\n- Ensure answers will directly inform implementation decisions\n\n## Interactive Clarification\n\nUse the `AskUserQuestion` tool to present clarifications:\n\n1. Present questions one at a time (or in small batches if related)\n2. For multiple-choice questions:\n   - Set the recommended option based on best practices or issue context\n   - Provide clear descriptions for each option explaining tradeoffs\n   - Use `multiSelect: false` for mutually exclusive choices\n3. For open-ended questions:\n   - Provide example options with an \"Other\" choice\n   - Keep option descriptions concise but informative\n\nExample AskUserQuestion usage:\n```\n{\n  \"questions\": [\n    {\n      \"question\": \"What should happen when a user tries to perform this action without authentication?\",\n      \"header\": \"Auth handling\",\n      \"multiSelect\": false,\n      \"options\": [\n        {\n          \"label\": \"Redirect to login\",\n          \"description\": \"Send user to login page with return URL. Standard web app pattern.\"\n        },\n        {\n          \"label\": \"Show 401 error\",\n          \"description\": \"Return 401 status. Better for API endpoints.\"\n        },\n        {\n          \"label\": \"Graceful degradation\",\n          \"description\": \"Show limited functionality without auth. Good for public features.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n## Answer Integration\n\nAfter receiving answers from the user:\n\n1. **Create clarifications file** (if it doesn't exist):\n   - Write to `/tmp/claude/issue-$ISSUE_NUMBER-clarifications.md`\n   - Format with:\n     ```markdown\n     # Clarifications for Issue #$ISSUE_NUMBER\n\n     ## Date: YYYY-MM-DD\n\n     ### [Category Name]\n\n     **Q:** [Question text]\n     **A:** [User's answer with reasoning if applicable]\n\n     ---\n     ```\n\n2. **Update existing clarifications** (if file exists):\n   - Use Read tool to load existing content\n   - Use Edit tool to append new Q&A under today's date\n   - Ensure no duplicate questions\n\n3. **Update the GitHub issue**:\n   - Write updated issue body to `/tmp/claude/issue-$ISSUE_NUMBER-body.md`\n   - Add or update a `## Clarifications` section at the end\n   - Include date-stamped Q&A entries\n   - Use Read tool to verify content\n   - Update issue: `gh issue edit $ISSUE_NUMBER --body-file /tmp/claude/issue-$ISSUE_NUMBER-body.md`\n\n4. **Validate**:\n   - Check for contradictions with previous answers\n   - Ensure terminology consistency\n   - Verify formatting is preserved\n\n## Session Management\n\n- Maximum 10 questions per session (stop earlier if all critical gaps addressed)\n- Allow user to signal completion with \"done\", \"stop\", or \"skip\"\n- If quota exhausted, report any remaining high-impact items\n\n## Completion Report\n\nAfter clarification session ends, provide:\n\n```markdown\n## Clarification Summary\n\n**Questions asked:** X\n**Questions answered:** Y\n**Issue updated:** #$ISSUE_NUMBER\n\n**Coverage by Category:**\n| Category | Status | Notes |\n|----------|--------|-------|\n| Functional Scope | Clear/Partial/Missing | ... |\n| Domain Model | Clear/Partial/Missing | ... |\n| ... | ... | ... |\n\n**Next Steps:**\n- [Suggested action based on coverage]\n- [Any remaining ambiguities to address]\n- [Ready to proceed with implementation? Yes/No]\n```\n\n## Important Rules\n\n- NEVER ask trivial or stylistic questions that don't affect implementation\n- NEVER speculate about tech stack unless blocking functional clarity\n- ALWAYS respect \"done\"/\"stop\" signals\n- ALWAYS update the issue incrementally after each answer to prevent data loss\n- ALWAYS provide reasoning for recommended options in multiple-choice questions\n- Keep questions focused and actionable\n- Prioritize questions by implementation impact\n\n## Workflow Summary\n\n1. Fetch issue with `gh issue view` → extract title and body\n2. Analyze against 9-category taxonomy → identify ambiguities\n3. Generate up to 5 high-impact clarification questions\n4. Use `AskUserQuestion` tool → collect structured responses\n5. Write clarifications to temp file → update issue with `gh issue edit --body-file`\n6. Validate for consistency and contradictions\n7. Provide coverage summary and next steps\n\nProceed with clarifying the issue following these guidelines."
              },
              {
                "name": "/commit-and-push",
                "description": "Create a conventional commit and push to current branch",
                "path": "plugins/workflow/commands/commit-and-push.md",
                "frontmatter": {
                  "description": "Create a conventional commit and push to current branch",
                  "args": [
                    {
                      "name": "pre-commit-action",
                      "description": "Optional action to perform before committing (e.g., \"run tests\", \"update version\", \"lint code\")"
                    }
                  ],
                  "preapprovedTools": [
                    "Bash(git:*)",
                    "Read(**/*.*)",
                    "Grep",
                    "Glob",
                    "TodoWrite"
                  ]
                },
                "content": "You are tasked with creating a conventional commit and pushing to the current branch following these strict requirements:\n\n# Pre-Commit Action\n\nIf the user provided a pre-commit action argument ($1), perform that action FIRST before proceeding with the commit workflow:\n- Read and understand what action is requested\n- Execute the requested action (e.g., run tests, update version numbers, run linters)\n- Verify the action completed successfully\n- If the action fails, STOP and report the error - do not proceed with commit\n- If the action succeeds, continue with the commit workflow below\n\nIf no pre-commit action was specified, proceed directly to the commit workflow.\n\n# Conventional Commit Types\nUse these standard types for commits:\n- `feat`: New feature\n- `fix`: Bug fix\n- `docs`: Documentation only\n- `style`: Code style changes (formatting, no logic change)\n- `refactor`: Code refactoring (no functional changes)\n- `perf`: Performance improvements\n- `test`: Adding or updating tests\n- `chore`: Build process, dependencies, tooling\n- `ci`: CI/CD configuration changes\n- `revert`: Reverting previous commits\n\n# Commit Creation Workflow\n\n1. **Review changes**:\n   - Run `git status` to see all changed files\n   - Run `git diff` to see unstaged changes\n   - Run `git diff --staged` to see already-staged changes\n\n2. **Review commit style**:\n   - Run `git log -5 --oneline` to understand the project's commit message style\n\n3. **Selectively stage files** (NEVER use `git add .` or `git add -A`):\n   - Review the output of `git status` carefully\n   - Stage files individually using `git add <file1> <file2> ...`\n   - **EXCLUDE these file patterns** (never stage):\n     - Secret/credential files: `.env`, `.env.*`, `credentials.json`, `secrets.*`, `*.key`, `*.pem`\n     - IDE configs: `.vscode/`, `.idea/`, `*.swp`, `*.swo`, `.DS_Store`\n     - Build artifacts: `node_modules/`, `dist/`, `build/`, `target/`, `*.log`\n     - Temporary files: `tmp/`, `temp/`, `*.tmp`, `*.cache`\n     - Personal configs: `.env.local`, `config.local.*`\n   - If you detect any of these patterns in changed files, **STOP and ask the user** before proceeding\n   - Only stage files that are directly related to the changes being committed\n\n4. **Create conventional commit**:\n   - **Title format**: `{type}({scope}): {short description}` or `{type}: {short description}`\n   - Title should be max 72 characters\n   - Use imperative mood (\"add feature\" not \"added feature\")\n   - **Extended description**: Multi-line explanation of:\n     - What changed and why\n     - Any breaking changes or important notes\n     - Related issues or tickets\n   - NEVER include co-authorship credit to Claude or any AI agent\n   - Format: Use git commit with heredoc for proper multi-line formatting\n\nExample commit:\n```bash\ngit commit -m \"$(cat <<'EOF'\nfeat(auth): add user authentication system\n\nImplements JWT-based authentication with refresh tokens.\nIncludes middleware for protected routes and token validation.\nAdds login, logout, and token refresh endpoints.\n\nBreaking change: API now requires Authorization header for protected routes.\nEOF\n)\"\n```\n\n5. **Push changes**:\n   - Get current branch name: `git branch --show-current`\n   - Push only the current branch: `git push origin {current-branch}`\n   - If the branch doesn't exist on remote, use: `git push -u origin {current-branch}`\n\n# Important Rules\n- NEVER add \"Co-Authored-By: Claude\" or any AI attribution to commits\n- NEVER use `git add .` or `git add -A` - always stage files selectively\n- Always use conventional commit format\n- Keep commit titles concise and descriptive (max 72 chars)\n- Include meaningful extended descriptions for context\n- Ensure commits are atomic and focused\n- STOP and ask user if potentially sensitive files are detected in changes\n- Only push the current branch (no tags, no other branches)\n\n# Workflow Summary\n1. Review changes → `git status`, `git diff`\n2. Review recent commits → `git log -5 --oneline`\n3. **Selectively stage files** (review each file, exclude sensitive/generated files)\n4. Create conventional commit with extended description using heredoc\n5. Push current branch to remote\n\nProceed with creating the commit and pushing following these guidelines."
              },
              {
                "name": "/fix-issue",
                "description": "Analyze and fix a GitHub issue end-to-end with plan, branch, tests, and draft PR",
                "path": "plugins/workflow/commands/fix-issue.md",
                "frontmatter": {
                  "allowed-tools": "Bash(gh issue view:*), Bash(gh issue comment:*), Bash(gh pr create:*), Bash(gh pr list:*), Bash(git status:*), Bash(git branch:*), Bash(git switch:*), Bash(git checkout:*), Bash(git add:*), Bash(git commit:*), Bash(git push:*), Bash(lsof:*)",
                  "argument-hint": [
                    "issue-number"
                  ],
                  "description": "Analyze and fix a GitHub issue end-to-end with plan, branch, tests, and draft PR"
                },
                "content": "Analyze and fix GitHub issue #$ARGUMENTS.\n\n## Argument validation\n\n- Ensure an issue number was provided and prompt the user if not.\n\n## Context\n\n- Issue (JSON): `gh issue view \"$ARGUMENTS\" --json number,title,body,url,labels,assignees,state,author,createdAt,updatedAt`\n- Issue (human): `gh issue view \"$ARGUMENTS\"`\n- Current branch: `git branch --show-current`\n- Git status: `git status -sb`\n- Open PRs referencing #$ARGUMENTS: `gh pr list --state open --search \"$ARGUMENTS in:title,body\" --json number,title,url,headRefName,author`\n\n## Inputs\n\n- $ARGUMENTS = issue number (required)\n- Type and branch slug are auto-inferred from the issue (no additional args).\n\n## Your task\n\n1. Analysis and Clarification (use subagent)\n\n   - Launch a general-purpose subagent to analyze the issue and gather requirements\n   - The subagent should:\n     - Read and summarize the issue: problem, acceptance criteria, scope, and risks\n     - Identify any ambiguities or missing information\n     - **Use the AskUserQuestion tool** to ask structured clarifying questions about:\n       - Edge cases and error handling requirements\n       - Scope boundaries (what's in/out of scope)\n       - Implementation approach preferences\n       - Testing expectations and coverage requirements\n       - Any missing acceptance criteria\n       - Breaking changes or migration concerns\n     - Return a comprehensive summary including user responses\n   - Wait for the subagent to complete and review the analysis before proceeding\n\n2. Plan (propose and wait for confirmation)\n\n   - Based on the analysis and clarification responses, propose a minimal, testable plan (files to change, tests to add, migration notes if any).\n   - Post the proposed plan to the issue:\n     - Create temp file: `gh issue comment $ARGUMENTS --edit-last --body-file /dev/null 2>/dev/null || true` (to get template if available)\n     - Write plan to temp file: Use Write tool to create `/tmp/claude/issue-comment-$ARGUMENTS.md` with the concise plan summary\n     - Use Read tool to verify the content if needed\n     - Post comment: `gh issue comment $ARGUMENTS --body-file /tmp/claude/issue-comment-$ARGUMENTS.md`\n   - **Wait for user confirmation before making repo changes.**\n\n3. Branch management\n\n   - If on main or default branch, create a branch:\n     - Type: infer from labels/title (fix|feat|chore|docs|refactor). Default: fix.\n     - Slug: derive from issue title (kebab-case, <=50 chars). Fallback: \"issue-$ARGUMENTS\".\n     - Branch name: {type}/issue-$ARGUMENTS-{slug}\n   - Commands to use (after approval):\n     - git switch -c {branch} OR git checkout -b {branch}\n\n4. Code search and implementation\n\n   - Identify impacted modules and cross-cutting concerns.\n   - Implement the fix/feature with small, logical commits.\n\n5. Tests and local verification\n\n   - Prefer unit tests. If integration tests needed, call that out.\n   - Heuristics:\n     - If `package.json` exists: run `npm run check:all` and `npm test` if available.\n     - If a Python project: run `uvx pytest` and `ruff` if configured.\n     - If Go: run `go test ./...`.\n   - Ensure dev server on port 3000 is not already running before starting any local server.\n\n6. Quality gates\n\n   - Ensure code passes linting, formatting, and type checks available in the repo.\n   - Keep changes minimal and well-scoped.\n\n7. Commit\n\n   - Use a conventional commit message; include issue reference.\n   - Example: \"<type>: <scope>: <subject> (#$ARGUMENTS)\" (type inferred)\n   - Do NOT attribute to Claude in the commit message.\n\n8. PR (draft) with Problem/Solution format\n\n   - Push branch and create a draft PR that links the issue:\n     - Write PR body to temp file using Write tool at `/tmp/claude/pr-body-issue-$ARGUMENTS.md`:\n       ```markdown\n       ## Problem\n\n       [Describe what's broken or missing]\n\n       ## Solution\n\n       [Explain what changed and why]\n\n       ## Testing\n\n       [How to test these changes]\n\n       Fixes #$ARGUMENTS\n       ```\n     - Use Edit tool to update the temp file with actual problem/solution descriptions\n     - Use Read tool to verify the content before creating PR\n     - Create PR: `gh pr create --draft --title \"<type>(<scope>): <subject> (#$ARGUMENTS)\" --body-file /tmp/claude/pr-body-issue-$ARGUMENTS.md`\n\n## Notes\n\n- Use GitHub CLI (gh) for all GitHub operations.\n- Keep interactions idempotent and ask for confirmation before pushing or creating PRs.\n- If repo tooling is unclear, ask whether to enable/add tests or linters for this fix."
              },
              {
                "name": "/pr",
                "description": "Create a pull request with conventional commits formatting",
                "path": "plugins/workflow/commands/pr.md",
                "frontmatter": {
                  "description": "Create a pull request with conventional commits formatting",
                  "preapprovedTools": [
                    "Bash(git:*)",
                    "Bash(gh:*)",
                    "Read(**/*.*)",
                    "Grep",
                    "Glob",
                    "TodoWrite"
                  ]
                },
                "content": "You are tasked with creating a pull request following these strict requirements:\n\n# Branch Management\n1. Check the current branch using `git branch --show-current`\n2. Get the default branch using `git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'`\n3. If we're on the main/default branch:\n   - Analyze the changes to determine the appropriate conventional commit type\n   - Create a new branch using the format: `{type}/{short-description}` (e.g., `fix/auth-token-validation`, `feat/add-dark-mode`)\n   - The short-description should be kebab-case and descriptive\n   - Check out the new branch\n\n# Conventional Commit Types\nUse these standard types for commits and branch names:\n- `feat`: New feature\n- `fix`: Bug fix\n- `docs`: Documentation only\n- `style`: Code style changes (formatting, no logic change)\n- `refactor`: Code refactoring (no functional changes)\n- `perf`: Performance improvements\n- `test`: Adding or updating tests\n- `chore`: Build process, dependencies, tooling\n- `ci`: CI/CD configuration changes\n- `revert`: Reverting previous commits\n\n# Commit Creation\n1. Review all staged and unstaged changes using `git status` and `git diff`\n2. Review recent commit messages for style consistency using `git log -5 --oneline`\n3. **Selectively stage files** (NEVER use `git add .` or `git add -A`):\n   - Review the output of `git status` carefully\n   - Stage files individually using `git add <file1> <file2> ...`\n   - **EXCLUDE these file patterns** (never stage):\n     - Secret/credential files: `.env`, `.env.*`, `credentials.json`, `secrets.*`, `*.key`, `*.pem`\n     - IDE configs: `.vscode/`, `.idea/`, `*.swp`, `*.swo`, `.DS_Store`\n     - Build artifacts: `node_modules/`, `dist/`, `build/`, `target/`, `*.log`\n     - Temporary files: `tmp/`, `temp/`, `*.tmp`, `*.cache`\n     - Personal configs: `.env.local`, `config.local.*`\n   - If you detect any of these patterns in changed files, **STOP and ask the user** before proceeding\n   - Only stage files that are directly related to the changes being committed\n4. Create commits with:\n   - **Title format**: `{type}({scope}): {short description}` or `{type}: {short description}`\n   - Title should be max 72 characters\n   - Use imperative mood (\"add feature\" not \"added feature\")\n   - **Extended description**: Multi-line explanation of:\n     - What changed and why\n     - Any breaking changes or important notes\n     - Related issues or tickets\n   - NEVER include co-authorship credit to Claude or any AI agent\n   - Format: Use git commit with heredoc for proper multi-line formatting\n\nExample commit:\n```bash\ngit commit -m \"$(cat <<'EOF'\nfeat(auth): add user authentication system\n\nImplements JWT-based authentication with refresh tokens.\nIncludes middleware for protected routes and token validation.\nAdds login, logout, and token refresh endpoints.\n\nBreaking change: API now requires Authorization header for protected routes.\nEOF\n)\"\n```\n\n# Pull Request Creation\n1. Push the branch to remote with tracking: `git push -u origin {branch-name}`\n2. Create PR using `gh pr create` with:\n   - **PR Title**: Same format as commit title - `{type}({scope}): {short description}`\n   - **PR Description**: Use Problem & Solution format with temp file:\n     - Write initial template to temp file using Write tool at `/tmp/claude/pr-body.md`:\n       ```markdown\n       ## Problem\n       [Describe the problem being solved, why this change is needed, or what gap this fills]\n\n       ## Solution\n       [Explain the approach taken to solve the problem]\n       [Include specific implementation details]\n       [Note any important technical decisions]\n\n       ## Testing\n       [How to test these changes]\n\n       ## Related Issues\n       [Link any related issues if applicable]\n       ```\n     - Use Edit tool to replace placeholders with actual content based on git diff and commit analysis\n     - Use Read tool to verify the final content before creating PR\n     - Create PR: `gh pr create --title \"type(scope): description\" --body-file /tmp/claude/pr-body.md`\n\n3. Return the PR URL to the user\n\n# Important Rules\n- NEVER add \"Co-Authored-By: Claude\" or any AI attribution to commits or PRs\n- NEVER push directly to main/default branch\n- NEVER use `git add .` or `git add -A` - always stage files selectively\n- Always use conventional commit format\n- Keep commit titles concise and descriptive (max 72 chars)\n- Include meaningful extended descriptions for context\n- Ensure commits are atomic and focused\n- Use Problem & Solution format for all PR descriptions\n- STOP and ask user if potentially sensitive files are detected in changes\n\n# Workflow Summary\n1. Check current branch → create feature branch if on main\n2. Review changes with `git status` and `git diff` → determine commit type\n3. **Selectively stage files** (review each file, exclude sensitive/generated files)\n4. Create conventional commit with extended description\n5. Push branch → create PR with Problem & Solution format\n6. Return PR URL\n\nProceed with creating the pull request following these guidelines."
              }
            ],
            "skills": [
              {
                "name": "git-bisect-debugging",
                "description": "Use when debugging regressions or identifying which commit introduced a bug - provides systematic workflow for git bisect with automated test scripts, manual verification, or hybrid approaches. Can be invoked from systematic-debugging as a debugging technique, or used standalone when you know the issue is historical.",
                "path": "plugins/workflow/skills/git-bisect-debugging/SKILL.md",
                "frontmatter": {
                  "name": "git-bisect-debugging",
                  "description": "Use when debugging regressions or identifying which commit introduced a bug - provides systematic workflow for git bisect with automated test scripts, manual verification, or hybrid approaches. Can be invoked from systematic-debugging as a debugging technique, or used standalone when you know the issue is historical."
                },
                "content": "# Git Bisect Debugging\n\n## Overview\n\nSystematically identify which commit introduced a bug or regression using git bisect. This skill provides a structured workflow for automated, manual, and hybrid bisect approaches.\n\n**Core principle:** Binary search through commit history to find the exact commit that introduced the issue. Main agent orchestrates, subagents execute verification at each step.\n\n**Announce at start:** \"I'm using git-bisect-debugging to find which commit introduced this issue.\"\n\n## Quick Reference\n\n| Phase | Key Activities | Output |\n|-------|---------------|--------|\n| **1. Setup & Verification** | Identify good/bad commits, verify clean state | Confirmed commit range |\n| **2. Strategy Selection** | Choose automated/manual/hybrid approach | Test script or verification steps |\n| **3. Execution** | Run bisect with subagents | First bad commit hash |\n| **4. Analysis & Handoff** | Show commit details, analyze root cause | Root cause understanding |\n\n## MANDATORY Requirements\n\nThese are **non-negotiable**. No exceptions for time pressure, production incidents, or \"simple\" cases:\n\n1. **✅ ANNOUNCE skill usage** at start:\n   ```\n   \"I'm using git-bisect-debugging to find which commit introduced this issue.\"\n   ```\n\n2. **✅ CREATE TodoWrite checklist** immediately (before Phase 1):\n   - Copy the exact checklist from \"The Process\" section below\n   - Update status as you progress through phases\n   - Mark phases complete ONLY when finished\n\n3. **✅ VERIFY safety checks** (Phase 1 - no skipping):\n   - Working directory MUST be clean (`git status`)\n   - Good commit MUST be verified (actually good)\n   - Bad commit MUST be verified (actually bad)\n   - If ANY check fails → abort and fix before proceeding\n\n4. **✅ USE AskUserQuestion** for strategy selection (Phase 2):\n   - Present all 3 approaches (automated, manual, hybrid)\n   - Don't default to automated without asking\n   - User must explicitly choose\n\n5. **✅ LAUNCH subagents** for verification (Phase 3):\n   - Main agent: orchestrates git bisect state\n   - Subagents: execute verification at each commit (via Task tool)\n   - NEVER run verification in main context\n   - Each commit tested in isolated subagent\n\n6. **✅ HANDOFF to systematic-debugging** (Phase 4):\n   - After finding bad commit, announce handoff\n   - Use superpowers:systematic-debugging skill\n   - Investigate root cause, not just WHAT changed\n\n## Red Flags - STOP and Follow the Skill\n\nIf you catch yourself thinking ANY of these, you're about to violate the skill:\n\n- \"User is in a hurry, I'll skip safety checks\" → NO. Run all safety checks.\n- \"This is simple, no need for TodoWrite\" → NO. Create the checklist.\n- \"I'll just use automated approach\" → NO. Use AskUserQuestion.\n- \"I'll run the test in my context\" → NO. Launch subagent.\n- \"Found the commit, that's enough\" → NO. Handoff to systematic-debugging.\n- \"Working directory looks clean\" → NO. Run `git status` to verify.\n- \"I'll verify good/bad commits later\" → NO. Verify BEFORE starting bisect.\n\n**All of these mean: STOP. Follow the 4-phase workflow exactly.**\n\n## The Process\n\nCopy this checklist to track progress:\n\n```\nGit Bisect Progress:\n- [ ] Phase 1: Setup & Verification (good/bad commits identified)\n- [ ] Phase 2: Strategy Selection (approach chosen, script ready)\n- [ ] Phase 3: Execution (first bad commit found)\n- [ ] Phase 4: Analysis & Handoff (root cause investigation complete)\n```\n\n### Phase 1: Setup & Verification\n\n**Purpose:** Ensure git bisect is appropriate and safe to run.\n\n**Steps:**\n\n1. **Verify prerequisites:**\n   - Check we're in a git repository\n   - Verify working directory is clean (`git status`)\n   - If uncommitted changes exist, abort and ask user to commit or stash\n\n2. **Identify commit range:**\n   - Ask user for **good commit** (where it worked)\n     - Suggestions: last release tag, last passing CI, commit from when it worked\n     - Commands to help: `git log --oneline`, `git tag`, `git log --since=\"last week\"`\n   - Ask user for **bad commit** (where it's broken)\n     - Usually: `HEAD` or a specific commit where issue confirmed\n   - Calculate estimated steps: ~log2(commits between good and bad)\n\n3. **Verify the range:**\n   - Checkout bad commit and verify issue exists\n   - Checkout good commit and verify issue doesn't exist\n   - If reversed, offer to swap them\n   - Return to original branch/commit\n\n4. **Safety checks:**\n   - Warn if range is >1000 commits (ask for confirmation)\n   - Verify good commit is ancestor of bad commit\n   - Note current branch/commit for cleanup later\n\n**Output:** Confirmed good commit hash, bad commit hash, estimated steps\n\n### Phase 2: Strategy Selection\n\n**Purpose:** Choose the most efficient bisect approach.\n\n**Assessment:** Can we write an automated test script that deterministically identifies good vs bad?\n\n**MANDATORY: Use AskUserQuestion tool** to present these three approaches (do NOT default to automated):\n\n```javascript\nAskUserQuestion({\n  questions: [{\n    question: \"Which git bisect approach should we use?\",\n    header: \"Strategy\",\n    multiSelect: false,\n    options: [\n      {\n        label: \"Automated - test script runs automatically\",\n        description: \"Fast, no manual intervention. Best for: test failures, crashes, deterministic behavior. Requires: working test script.\"\n      },\n      {\n        label: \"Manual - you verify each commit\",\n        description: \"Handles subjective issues. Best for: UI/UX changes, complex scenarios. Requires: you can manually check each commit.\"\n      },\n      {\n        label: \"Hybrid - script + manual confirmation\",\n        description: \"Efficient with reliability. Best for: mostly automated but needs judgment. Requires: script for most cases, manual for edge cases.\"\n      }\n    ]\n  }]\n})\n```\n\n**Three approaches to present:**\n\n**Approach 1: Automated Bisect**\n- **When to use:** Test failure, crash, deterministic behavior\n- **How it works:** Script returns exit 0 (good) or 1 (bad), fully automatic\n- **Benefits:** Fast, no manual intervention, reproducible\n- **Requirements:** Can write a script that runs the test/check\n\n**Approach 2: Manual Bisect**\n- **When to use:** UI/UX changes, subjective behavior, complex scenarios\n- **How it works:** User verifies at each commit, Claude guides\n- **Benefits:** Handles non-deterministic or subjective issues\n- **Requirements:** User can manually verify each commit\n\n**Approach 3: Hybrid Bisect**\n- **When to use:** Mostly automatable but needs human judgment\n- **How it works:** Script narrows range, manual verification for final confirmation\n- **Benefits:** Efficiency of automation with reliability of manual check\n- **Requirements:** Can automate most checks, manual for edge cases\n\n**If automated or hybrid selected:**\n\nWrite test script following this template:\n\n```bash\n#!/bin/bash\n# Exit codes: 0 = good, 1 = bad, 125 = skip (can't test)\n\n# Setup/build (required for each commit)\nnpm install --silent 2>/dev/null || exit 125\n\n# Run the actual test\nnpm test -- path/to/specific-test.js\nexit $?\n```\n\n**Script guidelines:**\n- Make it **deterministic** (no random data, use fixed seeds)\n- Make it **fast** (runs ~log2(N) times)\n- **Exit codes:** 0 = good, 1 = bad, 125 = skip\n- Include build/setup (each commit might need different deps)\n- Test ONE specific thing, not entire suite\n- Make it **read-only** (no data modification)\n\n**If manual selected:**\n\nWrite specific verification steps for subagent:\n\n**Good example:**\n```\n1. Run `npm start`\n2. Open browser to http://localhost:3000\n3. Click the \"Login\" button\n4. Check if it redirects to /dashboard\n5. Respond 'good' if redirect happens, 'bad' if it doesn't\n```\n\n**Bad example:**\n```\nSee if the login works\n```\n\n**Output:** Selected approach, test script (if automated/hybrid), or verification steps (if manual)\n\n### Phase 3: Execution\n\n**Architecture:** Main agent orchestrates bisect, subagents verify each commit in isolated context.\n\n**Main agent responsibilities:**\n- Manage git bisect state (`start`, `good`, `bad`, `reset`)\n- Track progress and communicate remaining steps\n- Launch subagents for verification\n- Handle errors and cleanup\n\n**Subagent responsibilities:**\n- Execute verification in clean context (no bleeding between commits)\n- Report result: \"good\", \"bad\", or \"skip\"\n- Provide brief reasoning for result\n\n**Execution flow:**\n\n1. **Main agent:** Run `git bisect start <bad> <good>`\n\n2. **Loop until bisect completes:**\n\n   a. Git checks out a commit to test\n\n   b. **Main agent launches subagent** using Task tool:\n\n   **For automated:**\n   ```\n   Prompt: \"Run this test script and report the result:\n\n   <script content>\n\n   Report 'good' if exit code is 0, 'bad' if exit code is 1, 'skip' if exit code is 125.\n   Include the output of the script in your response.\"\n   ```\n\n   **For manual:**\n   ```\n   Prompt: \"We're testing commit <hash> (<message>).\n\n   Follow these verification steps:\n   <verification steps>\n\n   Report 'good' if the issue doesn't exist, 'bad' if it does exist.\n   Explain what you observed.\"\n   ```\n\n   **For hybrid:**\n   ```\n   Prompt: \"Run this test script:\n\n   <script content>\n\n   If exit code is 0 or 1, report that result.\n   If exit code is 125 or script is ambiguous, perform manual verification:\n   <verification steps>\n\n   Report 'good', 'bad', or 'skip' with explanation.\"\n   ```\n\n   c. **Subagent returns:** Result (\"good\", \"bad\", or \"skip\") with explanation\n\n   d. **Main agent:** Run `git bisect good|bad|skip` based on result\n\n   e. **Main agent:** Update progress\n      - Show commit that was tested and result\n      - Calculate remaining steps: `git bisect log | grep \"# .*step\" | tail -1`\n      - Example: \"Tested commit abc123 (bad). ~4 steps remaining.\"\n\n   f. Repeat until git bisect identifies first bad commit\n\n3. **Main agent:** Run `git bisect reset` to cleanup\n\n4. **Main agent:** Return to original branch/commit\n\n**Error handling during execution:**\n\n- **Subagent timeout/error:** Allow user to manually mark as \"skip\"\n- **Build failures:** Use `git bisect skip`\n- **Too many skips (>5):** Suggest manual investigation, show untestable commits\n- **Bisect interrupted:** Ensure `git bisect reset` runs in cleanup\n\n**Output:** First bad commit hash, bisect log showing the path taken\n\n### Phase 4: Analysis & Handoff\n\n**Purpose:** Present findings and analyze root cause.\n\n**Steps:**\n\n1. **Present the identified commit:**\n   ```\n   Found first bad commit: <hash>\n\n   Author: <author>\n   Date: <date>\n\n   <commit message>\n\n   Files changed:\n   <list of files from git show --stat>\n   ```\n\n2. **Show how to view details:**\n   ```\n   View full diff: git show <hash>\n   View file at that commit: git show <hash>:<file>\n   ```\n\n3. **Handoff to root cause analysis:**\n   - Announce: \"Now that we've found the breaking commit at `<hash>`, I'm using systematic-debugging to analyze why this change caused the issue.\"\n   - Use superpowers:systematic-debugging skill to investigate\n   - Focus analysis on the changes in the bad commit\n   - Identify the specific line/change that caused the issue\n   - Explain WHY it broke (not just WHAT changed)\n\n**Output:** Root cause understanding of why the commit broke functionality\n\n## Safety & Error Handling\n\n### Pre-flight Checks (Phase 1)\n- ✅ Working directory is clean\n- ✅ In a git repository\n- ✅ Good/bad commits exist and are valid\n- ✅ Good commit is actually good (issue doesn't exist)\n- ✅ Bad commit is actually bad (issue exists)\n- ✅ Good is ancestor of bad\n- ⚠️ Warn if >1000 commits in range\n\n### During Execution (Phase 3)\n- **Subagent fails:** Log error, allow skip or abort\n- **Build fails:** Use `git bisect skip`, continue\n- **Ambiguous result:** Use `git bisect skip`, max 5 skips\n- **Can't determine good/bad:** Ask user for guidance\n\n### Cleanup & Recovery\n- **Always** run `git bisect reset` when done (success or failure)\n- If interrupted, prompt user to run `git bisect reset`\n- Return to original branch/commit\n- If bisect is running and skill exits, warn user to cleanup\n\n### Failure Modes\n- **Too many skips:** Report untestable commits, suggest narrower range or manual review\n- **Good/bad reversed:** Detect pattern (all results opposite), offer to restart with swapped inputs\n- **No bad commit found:** Verify bad commit is actually bad, check if issue is environmental\n\n## Best Practices\n\n### Optimizing Commit Range\n- **Narrow the range first** if possible:\n  - Issue appeared last week? Start from last week, not 6 months ago\n  - Use `git log --since=\"2 weeks ago\"` to find starting point\n  - Use tags/releases as good commits when possible\n\n### Writing Good Test Scripts\n**Do:**\n- ✅ Test ONE specific thing\n- ✅ Make it deterministic (fixed seeds, no random data)\n- ✅ Make it fast (runs log2(N) times)\n- ✅ Include setup/build in script\n- ✅ Use proper exit codes (0=good, 1=bad, 125=skip)\n\n**Don't:**\n- ❌ Run entire test suite (too slow)\n- ❌ Depend on external state (databases, APIs)\n- ❌ Use random data or timestamps\n- ❌ Modify production data\n\n### Manual Verification\n**Be specific:**\n- ✅ \"API returns 200 for GET /health\"\n- ✅ \"Login button redirects to /dashboard\"\n- ❌ \"See if it works\"\n- ❌ \"Check if login is broken\"\n\n**Give exact steps:**\n1. Run server with `npm start`\n2. Open browser to http://localhost:3000\n3. Click element with id=\"login-btn\"\n4. Verify URL changes to /dashboard\n\n### Common Patterns\n\n| Issue Type | Recommended Approach | Script/Steps Example |\n|------------|---------------------|---------------------|\n| Test failure | Automated | `npm test -- failing-test.spec.js` |\n| Crash/error | Automated | `node app.js 2>&1 | grep -q ERROR && exit 1 || exit 0` |\n| Performance | Automated | `time npm run benchmark \\| awk '{if ($1 > 5.0) exit 1}'` |\n| UI/UX change | Manual | \"Click X, verify Y appears\" |\n| Behavior change | Manual or Hybrid | Script to check, manual to confirm subjective aspects |\n\n### Progress Communication\n- After each step: \"Tested commit abc123 (<result>). ~X steps remaining.\"\n- Show bisect log periodically: `git bisect log`\n- Estimate remaining steps: log2(commits in range)\n- Example: 100 commits → ~7 steps, 1000 commits → ~10 steps\n\n## Common Rationalizations (Resist These!)\n\n| Rationalization | Reality | What to Do Instead |\n|----------------|---------|-------------------|\n| \"User is in a hurry, skip safety checks\" | Broken bisect from dirty state wastes MORE time | Run all Phase 1 checks. Always. |\n| \"This is simple, no need for TodoWrite\" | You'll skip phases without tracking | Create checklist immediately |\n| \"I'll just use automated approach\" | User might prefer manual for vague issues | Use AskUserQuestion tool |\n| \"I'll run the test in my context\" | Context bleeding between commits breaks bisect | Launch subagent for each verification |\n| \"Working directory looks clean\" | Assumptions cause failures | Run `git status` to verify |\n| \"I'll verify good/bad commits later\" | Starting with wrong good/bad wastes all steps | Verify BEFORE `git bisect start` |\n| \"Found the commit, user knows why\" | User asked to FIND it, not debug it | Hand off to systematic-debugging |\n| \"Production incident, no time for process\" | Skipping process in incidents causes MORE incidents | Follow workflow. It's faster. |\n| \"I remember from baseline, no need to test\" | Skills evolve, baseline was different session | Test at each commit with subagent |\n\n**If you catch yourself rationalizing, STOP. Go back to MANDATORY Requirements section.**\n\n## Integration with Other Skills\n\n### Called BY systematic-debugging\nWhen systematic-debugging determines an issue is historical:\n\n```\nsystematic-debugging detects:\n- Issue doesn't exist in commit from 2 weeks ago\n- Issue exists now\n→ Suggests: \"This appears to be a regression. I'm using git-bisect-debugging to find when it was introduced.\"\n→ Invokes: git-bisect-debugging skill\n→ Returns: First bad commit for analysis\n→ Resumes: systematic-debugging analyzes the breaking change\n```\n\n### Calls systematic-debugging\nIn Phase 4, after finding the bad commit:\n\n```\ngit-bisect-debugging completes:\n→ Announces: \"Found commit abc123. Using systematic-debugging to analyze root cause.\"\n→ Invokes: superpowers:systematic-debugging\n→ Context: \"Focus on changes in commit abc123\"\n→ Goal: Understand WHY the change broke functionality\n```\n\n## Limitations (By Design)\n\nThis skill focuses on straightforward scenarios. It does NOT handle:\n\n- ❌ Complex merge commit issues (would need `--first-parent`)\n- ❌ Flaky/intermittent test failures (would need statistical approaches)\n- ❌ Build system failures across many commits (would need advanced skip strategies)\n\nFor these scenarios, manual git bisect with user guidance is recommended.\n\n## Example Workflows\n\n### Example 1: Automated Test Failure\n\n```\nUser: \"The login test started failing sometime in the last 50 commits.\"\n\nClaude: \"I'm using git-bisect-debugging to find which commit introduced this issue.\"\n\n[Phase 1: Setup]\n- git status → clean\n- Good commit: v1.2.0 tag (last release)\n- Bad commit: HEAD\n- Verify: checkout v1.2.0, run test → passes\n- Verify: checkout HEAD, run test → fails\n- Range: 47 commits, ~6 steps estimated\n\n[Phase 2: Strategy Selection]\nAskUserQuestion: Which approach?\nUser selects: Automated\n\nScript created:\n#!/bin/bash\nnpm install --silent 2>/dev/null || exit 125\nnpm test -- tests/login.spec.js\nexit $?\n\n[Phase 3: Execution]\nStep 1: Launch subagent for commit abc123\n  Subagent: \"Test failed. Exit code 1. bad\"\n  Main: git bisect bad → ~3 steps remaining\n\nStep 2: Launch subagent for commit def456\n  Subagent: \"Test passed. Exit code 0. good\"\n  Main: git bisect good → ~2 steps remaining\n\nStep 3: Launch subagent for commit ghi789\n  Subagent: \"Test failed. Exit code 1. bad\"\n  Main: git bisect bad → ~1 step remaining\n\nStep 4: Launch subagent for commit jkl012\n  Subagent: \"Test passed. Exit code 0. good\"\n  Main: git bisect good\n\nGit bisect identifies: ghi789 is first bad commit\n\n[Phase 4: Analysis]\nFound first bad commit: ghi789\n\nAuthor: John Doe\nDate: 2025-11-10\n\nfeat: update authentication middleware\n\nFiles changed:\n  src/auth/middleware.js | 12 ++++---\n  tests/login.spec.js    |  3 +-\n\nUsing systematic-debugging to analyze why this change broke the test...\n[Hands off to systematic-debugging skill]\n```\n\n### Example 2: Manual UI Regression\n\n```\nUser: \"The dashboard layout looks wrong, but I'm not sure when it broke.\"\n\nClaude: \"I'm using git-bisect-debugging to find which commit introduced this issue.\"\n\n[Phase 1: Setup]\n- git status → clean\n- Good commit: 2 weeks ago (user remembers it working)\n- Bad commit: HEAD\n- Range: 89 commits, ~7 steps estimated\n\n[Phase 2: Strategy Selection]\nAskUserQuestion: Which approach?\nUser selects: Manual\n\nVerification steps created:\n1. Run `npm run dev`\n2. Open browser to http://localhost:3000/dashboard\n3. Check if the sidebar and main content are side-by-side\n4. Respond 'good' if layout is correct, 'bad' if sidebar overlaps content\n\n[Phase 3: Execution]\nStep 1: Checkout commit abc123\n  Launch subagent with verification steps\n  User verifies: \"Layout is correct. good\"\n  Main: git bisect good → ~3 steps remaining\n\nStep 2: Checkout commit def456\n  Launch subagent with verification steps\n  User verifies: \"Sidebar overlaps content. bad\"\n  Main: git bisect bad → ~2 steps remaining\n\n... continues until first bad commit found\n\n[Phase 4: Analysis]\nFound first bad commit: mno345\n\nAuthor: Jane Smith\nDate: 2025-11-08\n\nrefactor: migrate to CSS Grid layout\n\nFiles changed:\n  src/components/Dashboard.css | 25 +++++++++++----------\n\nUsing systematic-debugging to analyze the CSS changes...\n[Hands off to systematic-debugging skill]\n```\n\n### Example 3: Hybrid Performance Regression\n\n```\nUser: \"API response times got slower recently.\"\n\nClaude: \"I'm using git-bisect-debugging to find which commit introduced this issue.\"\n\n[Phase 1: Setup]\n- git status → clean\n- Good commit: last release tag v2.1.0\n- Bad commit: HEAD\n- Range: 120 commits, ~7 steps estimated\n\n[Phase 2: Strategy Selection]\nAskUserQuestion: Which approach?\nUser selects: Hybrid\n\nScript created:\n#!/bin/bash\nnpm install --silent 2>/dev/null || exit 125\n\n# Run benchmark 3 times, take average\ntotal=0\nfor i in 1 2 3; do\n  time=$(npm run benchmark:api 2>/dev/null | grep \"response_time\" | awk '{print $2}')\n  [ -z \"$time\" ] && exit 125  # Can't test\n  total=$(echo \"$total + $time\" | bc)\ndone\navg=$(echo \"scale=2; $total / 3\" | bc)\n\n# Threshold: 500ms is acceptable\nif (( $(echo \"$avg > 500\" | bc -l) )); then\n  exit 1  # bad (too slow)\nelse\n  exit 0  # good (fast enough)\nfi\n\nManual fallback steps:\n\"If script is ambiguous, manually test API and verify response time is <500ms\"\n\n[Phase 3: Execution]\nSteps proceed with script automation...\nIf script returns 125 (can't test), subagent asks user to manually verify\n\n[Phase 4: Analysis]\nFound first bad commit: pqr678\n\nAuthor: Bob Johnson\nDate: 2025-11-11\n\nfeat: add caching layer for user preferences\n\nFiles changed:\n  src/api/middleware/cache.js | 45 ++++++++++++++++++++++++++++++++\n\nUsing systematic-debugging to analyze the caching implementation...\n[Reveals: Cache lookup is synchronous and blocking, causing slowdown]\n```\n\n## Troubleshooting\n\n### \"Good and bad are reversed\"\nIf early results suggest good/bad are swapped:\n- Stop bisect\n- Verify issue description is correct\n- Swap good/bad commits and restart\n\n### \"Too many skips, can't narrow down\"\nIf >5 commits skipped:\n- Review skipped commits manually\n- Check if builds are broken in that range\n- Consider narrowing the range or manual investigation\n\n### \"Bisect is stuck/interrupted\"\nIf bisect state is corrupted or interrupted:\n```bash\ngit bisect reset  # Clean up bisect state\ngit checkout main  # Return to main branch\n# Restart bisect with better range/script\n```\n\n### \"Subagent is taking too long\"\n- Set reasonable timeout for verification\n- If automated: optimize test script\n- If manual: simplify verification steps\n- Consider marking commit as 'skip'\n\n## Summary\n\n**When to use:** Historical bugs, regressions, \"when did this break\" questions\n\n**Key strengths:**\n- ✅ Systematic binary search (efficient)\n- ✅ Subagent isolation (clean context)\n- ✅ Automated + manual + hybrid approaches\n- ✅ Integrates with systematic-debugging\n\n**Remember:**\n1. Always verify good is good, bad is bad\n2. Keep test scripts deterministic and fast\n3. Use subagents for each verification step\n4. Clean up with `git bisect reset`\n5. Hand off to systematic-debugging for root cause"
              }
            ]
          }
        ]
      }
    }
  ]
}