{
  "owner": {
    "id": "ChamHerry",
    "display_name": "ChamHerry",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/51915924?v=4",
    "url": "https://github.com/ChamHerry",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 2,
      "total_commands": 3,
      "total_skills": 0,
      "total_stars": 49,
      "total_forks": 5
    }
  },
  "repos": [
    {
      "full_name": "ChamHerry/claude-code-third-party-plugins",
      "url": "https://github.com/ChamHerry/claude-code-third-party-plugins",
      "description": null,
      "homepage": null,
      "signals": {
        "stars": 49,
        "forks": 5,
        "pushed_at": "2025-11-28T10:53:08Z",
        "created_at": "2025-11-03T06:28:24Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1179
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 440
        },
        {
          "path": "CHANGELOG.md",
          "type": "blob",
          "size": 1594
        },
        {
          "path": "CONTRIBUTING.md",
          "type": "blob",
          "size": 6576
        },
        {
          "path": "LICENSE",
          "type": "blob",
          "size": 1086
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 7753
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/README.md",
          "type": "blob",
          "size": 3189
        },
        {
          "path": "plugins/project-init",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/project-init/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/project-init/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 250
        },
        {
          "path": "plugins/project-init/README.md",
          "type": "blob",
          "size": 10185
        },
        {
          "path": "plugins/project-init/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/project-init/commands/project-init.md",
          "type": "blob",
          "size": 84838
        },
        {
          "path": "plugins/session-manager",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/session-manager/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/session-manager/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 264
        },
        {
          "path": "plugins/session-manager/.gitignore.example",
          "type": "blob",
          "size": 448
        },
        {
          "path": "plugins/session-manager/README.md",
          "type": "blob",
          "size": 13444
        },
        {
          "path": "plugins/session-manager/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/session-manager/commands/continue-session.md",
          "type": "blob",
          "size": 21141
        },
        {
          "path": "plugins/session-manager/commands/save-session.md",
          "type": "blob",
          "size": 10877
        }
      ],
      "marketplace": {
        "name": "claude-code-third-party-plugins",
        "version": "1.0.0",
        "description": "Claude Code 插件市场，包含项目初始化、开发辅助等实用工具",
        "owner_info": {
          "name": "Wang Xuecheng",
          "email": "ahut17353766123@gmail.com"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "project-init",
            "description": "基于 CLAUDE_TEMPLATE.md 模板快速初始化项目 CLAUDE.md 规范文件，通过交互式问答生成定制化开发规范",
            "source": "./plugins/project-init",
            "category": "productivity",
            "version": "1.0.0",
            "author": {
              "name": "Wang Xuecheng",
              "email": "ahut17353766123@gmail.com"
            },
            "install_commands": [
              "/plugin marketplace add ChamHerry/claude-code-third-party-plugins",
              "/plugin install project-init@claude-code-third-party-plugins"
            ],
            "signals": {
              "stars": 49,
              "forks": 5,
              "pushed_at": "2025-11-28T10:53:08Z",
              "created_at": "2025-11-03T06:28:24Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/project-init",
                "description": "智能分析项目并生成 CLAUDE.md 规范文件（完全跨平台）",
                "path": "plugins/project-init/commands/project-init.md",
                "frontmatter": {
                  "allowed-tools": "Read, Write, AskUserQuestion, Bash(date:*), Glob, Grep",
                  "description": "智能分析项目并生成 CLAUDE.md 规范文件（完全跨平台）"
                },
                "content": "智能分析现有项目结构和配置文件,自动推断技术栈、架构模式等信息,**只对无法确定的信息进行询问**,最终生成项目的 CLAUDE.md 开发规范文件。\n\n**核心特性**:\n- 🔍 **智能分析**: 自动检测项目类型、语言、框架\n- 💡 **按需询问**: 只对无法推断的信息询问用户\n- 🎯 **数据优先**: 优先使用项目实际数据,避免猜测\n- 🌐 **跨平台**: 完全兼容 Windows / macOS / Linux\n\n---\n\n## 内置模板\n\n以下是用于生成 CLAUDE.md 的内置模板：\n\n```template\n# CLAUDE.md 模板\n\n> 用于在新项目中快速建立开发规范和最佳实践。使用时请填充 `[占位符]` 部分。\n\n---\n\n## 项目概述\n\n**[项目名称]** - [项目一句话描述]\n\n### 核心技术栈\n- **框架**: [框架名称和版本]\n- **数据存储**: [数据库/缓存技术]\n- **开发语言**: [语言和版本]\n- **代码风格**: [命名规范]\n\n### 项目架构\n```\n[绘制项目架构图]\n例如：\nAPI层 → Service层 → Logic层 → Data层 → Storage\n```\n\n**关键模块**：\n- **[模块1]**: [路径] - [说明]\n- **[模块2]**: [路径] - [说明]\n\n---\n\n## 测试规范\n- 测试覆盖率 > 80%\n- 使用 Mock 模拟外部依赖\n- Mock 数据存放在 `test/data/` 目录\n- 测试文件存放在 `test/` 目录\n\n---\n\n## 架构规则（强制）\n\n### 层职责定义\n- **[Layer 1]**: ✅ [应该做的] / ❌ [不应该做的]\n- **[Layer 2]**: ✅ [应该做的] / ❌ [不应该做的]\n\n### 开发规则\n1. **命名规范** - [统一命名规范]\n2. **依赖管理** - [依赖引入规则]\n3. **错误处理** - [统一错误处理机制]\n4. **版本控制** -\n   - Git 提交必须使用 AskUserQuestion 工具询问用户同意\n   - 提交消息必须包含：\n     - 问题描述（What）\n     - 根本原因（Why）\n     - 修复内容（How）\n     - 技术细节（Details）\n     - 影响范围（Impact）\n   - **严格禁止**包含以下内容：\n     - `🤖 Generated with [Claude Code](https://claude.com/claude-code)`\n     - `Co-Authored-By: Claude <noreply@anthropic.com>`\n     - 其他任何 AI 工具的标识或署名\n5. **禁止行为** - [明确禁止的操作]\n\n### Claude Code 工具使用规范\n\n**AI 必须使用的工具**：\n- **AskUserQuestion**: 数据不足或需要决策时，必须主动询问用户\n- **TodoWrite**: 跟踪多步骤任务的进度，及时更新任务状态\n- **Read/Grep/Glob**: 修改前必须先分析现有代码，避免重复定义\n- **Plan**: 设计实施方案时，必须使用 Plan 工具进行规划和架构设计\n\n### Skills 技能使用规范（强制）\n\nSkills 是可扩展的专业能力模块，**必须**根据场景强制使用对应技能。\n\n#### 强制使用场景映射表\n\n> **使用说明**: 根据项目实际可用的 Skills 填充下表。通过 `<available_skills>` 列表获取当前环境可用技能。\n\n| 触发场景 | 关键词识别 | 必须使用的技能 |\n|---------|-----------|--------------|\n| [场景1] | [关键词1、关键词2、...] | `[skill-name-1]` |\n| [场景2] | [关键词1、关键词2、...] | `[skill-name-2]` |\n| [场景3] | [关键词1、关键词2、...] | `[skill-name-3]` |\n\n**常见场景类型参考**：\n- 架构设计类：系统架构、技术选型、组件设计\n- 可视化类：架构图、流程图、时序图、关系图\n- 文档处理类：Word、PPT、PDF、Excel\n- 前端设计类：UI设计、界面原型、组件设计\n\n#### 强制触发规则\n\n**以下场景必须调用对应技能，禁止跳过**：\n\n1. **[场景类型1]**（触发 `[skill-name]`）\n   - [具体触发条件1]\n   - [具体触发条件2]\n   - 用户提及\"[关键词]\"\n\n2. **[场景类型2]**（触发 `[skill-name]`）\n   - [具体触发条件1]\n   - [具体触发条件2]\n\n#### 技能调用检查清单\n\n在完成任务前，必须检查：\n- [ ] 是否识别到上述强制触发场景？\n- [ ] 是否已调用对应的必需技能？\n- [ ] 如未调用，是否有合理理由？（需向用户说明）\n\n#### 禁止行为\n\n- ❌ **禁止**在强制场景下不调用对应技能\n- ❌ **禁止**用文字描述替代可视化输出（有可视化技能时）\n- ❌ **禁止**跳过专业技能直接输出低质量结果\n\n#### 技能调用语法\n\n```\n使用 Skill 工具，参数 skill 设置为技能名称：\n- [根据 <available_skills> 列表填充]\n```\n\n#### 动态技能发现流程\n\n1. **识别任务类型**：分析用户需求，判断是否需要专业技能支持\n2. **查看可用技能**：通过系统提供的 `<available_skills>` 列表确认当前可用的技能\n3. **匹配场景映射**：根据上表的场景映射，确定必须调用的技能\n4. **调用技能**：使用 `Skill` 工具调用对应技能\n\n**Token 管理规范（强制）**：\n\n在开始每个 todo 任务前，必须评估剩余 token 是否足够完成该任务：\n\n1. **评估标准**：\n   - 当前剩余 token < 30000：存在风险\n   - 当前剩余 token < 20000：高风险\n   - 当前剩余 token < 10000：极高风险\n\n2. **风险处理流程**：\n\n   **如果存在风险**，必须使用 AskUserQuestion 工具询问用户：\n\n   ```yaml\n   question: \"⚠️ Token 预警：当前剩余 [X] tokens，即将开始「[Todo任务名称]」可能存在 token 不足风险。您希望如何处理？\"\n   header: \"Token 管理\"\n   multiSelect: false\n   options:\n     - label: \"继续执行当前任务\"\n       description: \"继续完成当前任务，可能需要在新会话中继续未完成的工作\"\n     - label: \"生成进度总结文档\"\n       description: \"生成包含当前进度总结和剩余待办事项实施方案的文档，便于在新会话中继续\"\n   ```\n\n3. **生成进度总结文档**（用户选择选项 2 时）：\n\n   创建文档：`docs/progress/YYYY-MM-DD-HH-MM-[任务名称]-进度总结.md`\n\n   文档必须包含：\n   ```markdown\n   # [任务名称] - 进度总结与实施方案\n\n   **创建时间**: YYYY-MM-DD HH:MM\n   **当前状态**: 进行中\n   **完成度**: X/Y 个任务\n\n   ---\n\n   ## 一、已完成任务\n\n   ### 1.1 任务清单\n   - [x] 任务 1 - 完成情况描述\n   - [x] 任务 2 - 完成情况描述\n   - [x] 任务 3 - 完成情况描述\n\n   ### 1.2 关键成果\n   - **成果 1**: 具体内容和路径\n   - **成果 2**: 具体内容和路径\n   - **成果 3**: 具体内容和路径\n\n   ### 1.3 已修改文件\n   ```\n   path/to/file1.ext - 修改内容描述\n   path/to/file2.ext - 修改内容描述\n   ```\n\n   ---\n\n   ## 二、剩余待办任务\n\n   ### 2.1 待办清单\n   - [ ] 任务 4 - 详细描述\n   - [ ] 任务 5 - 详细描述\n   - [ ] 任务 6 - 详细描述\n\n   ### 2.2 实施方案\n\n   #### 任务 4: [任务名称]\n   **目标**: [具体目标]\n   **步骤**:\n   1. [详细步骤 1]\n   2. [详细步骤 2]\n   3. [详细步骤 3]\n\n   **需要修改的文件**:\n   - `path/to/file1.ext` - [修改说明]\n   - `path/to/file2.ext` - [修改说明]\n\n   **注意事项**:\n   - [注意点 1]\n   - [注意点 2]\n\n   #### 任务 5: [任务名称]\n   ... (同上格式)\n\n   ---\n\n   ## 三、技术背景和上下文\n\n   ### 3.1 项目架构\n   [关键架构信息]\n\n   ### 3.2 技术栈\n   [使用的技术栈]\n\n   ### 3.3 重要约束\n   - [约束 1]\n   - [约束 2]\n\n   ### 3.4 已知问题\n   - [问题 1 及解决方案]\n   - [问题 2 及解决方案]\n\n   ---\n\n   ## 四、继续工作指南\n\n   ### 4.1 快速启动\n   在新会话中执行以下步骤：\n   1. 阅读本文档了解当前进度\n   2. 使用 TodoWrite 工具恢复任务列表\n   3. 从「任务 4」开始继续执行\n\n   ### 4.2 验证检查清单\n   开始前请确认：\n   - [ ] 已理解所有已完成任务的内容\n   - [ ] 已查看所有修改过的文件\n   - [ ] 已理解剩余任务的实施方案\n   - [ ] 已了解技术背景和约束\n\n   ---\n\n   **🤖 Generated with Claude Code**\n   ```\n\n4. **文档生成后**：\n   - 输出文档路径\n   - 提示用户在新会话中使用 `@文档路径` 继续工作\n   - 优雅结束当前会话\n\n**最佳实践**：\n- 定期评估 token 使用情况\n- 在大型任务开始前进行评估\n- 预留至少 15000 tokens 的安全边际\n- 及时保存进度，避免工作丢失\n\n---\n\n## AI 工作流程与质量门（强制）\n\n### 工作流程总览\n\n```\n需求输入\n   ↓\nA. 立项/澄清（Gate 0）\n   ↓  KISS + YAGNI + AskUserQuestion\n   ↓\nB. 方案设计（Gate 1）\n   ↓  SoC/LoD/组合优于继承 + DIP/ISP\n   ↓\nC. 编码前置（Gate 2）\n   ↓  DRY + 分层职责 + 前置条件信任\n   ↓\nD. 编码实现\n   ↓  SOLID + 幂等/限流/熔断 + 可观测性\n   ↓\nE. 测试与验收（Gate 3）\n   ↓  单测+契约 + Mock + 覆盖率\n   ↓\n开发完成 ✅\n（发布与运维不在此范围）\n```\n\n---\n\n### A. 立项/澄清阶段（Gate 0）\n\n**目标**: 明确需求边界，拒绝过度设计\n\n**使用原则**:\n- **KISS + YAGNI** → 先砍需求，确认功能必要性\n- **AskUserQuestion** → 明确边界与约束\n\n**输出**:\n- 需求边界清晰\n- 最小方案草图\n- 走审批流程\n\n**质量门 Gate 0：问题澄清**\n- [ ] 已使用 AskUserQuestion 收敛需求与约束\n- [ ] KISS 四问已回答（特别是\"真的需要这个功能吗？\"）\n- [ ] 需求边界明确，无歧义\n\n---\n\n### B. 方案设计阶段（Gate 1）\n\n**目标**: 设计可扩展、可维护的方案\n\n**使用原则**:\n- **SoC/LoD/组合优于继承** → 明确分层边界，减少耦合\n- **DIP/ISP** → 稳住扩展点，依赖抽象\n\n**输出**:\n- 方案文档（`docs/todo/YYYY-MM-DD-HH-MM-功能名称-方案.md`）\n- 必须包含：\n  - 完整调用链路分析\n  - KISS 四问的回答\n  - 性能影响评估\n  - 风险分析和缓解措施\n\n**质量门 Gate 1：方案评审**\n- [ ] 方案文档已提交\n- [ ] 调用链路分析完整\n- [ ] KISS 四问已回答\n- [ ] 性能影响已评估\n- [ ] 风险与缓解措施明确\n- [ ] 已获得用户审批\n\n---\n\n### C. 编码前置阶段（Gate 2）\n\n**目标**: 确保代码质量，避免重复实现\n\n**使用原则**:\n- **DRY** → 全局检索避免重复（使用 grep）\n- **SRP/SoC** → 划清分层职责\n- **前置条件信任原则** → 避免重复验证\n\n**输出**:\n- 代码重复检查报告\n- 分层职责明确\n- 前置条件明确\n\n**质量门 Gate 2：实现前检查**\n- [ ] 已使用 grep 全局检索，无重复定义\n- [ ] 分层边界清晰，职责明确\n- [ ] 前置条件信任原则已应用\n- [ ] 接口契约明确\n\n---\n\n### D. 编码实现阶段\n\n**目标**: 高质量代码实现\n\n**使用原则**:\n- **SOLID** → 作为底座（SRP/OCP/LSP/ISP/DIP）\n- **幂等/限流/熔断** → 进到关键路径\n- **日志/指标/Trace** → 埋点就位\n\n**输出**:\n- 高质量代码\n- 可观测性埋点\n- 健壮性保障（幂等/限流/熔断）\n\n**关键检查**:\n- [ ] SOLID 原则已遵循\n- [ ] 关键路径已添加幂等/限流/熔断\n- [ ] 日志/指标/Trace 埋点完整\n\n---\n\n### E. 测试与验收阶段（Gate 3）\n\n**目标**: 确保代码质量和功能正确性\n\n**使用原则**:\n- **测试金字塔** → 单测+契约优先\n- **Mock** → 隔离外部依赖\n\n**输出**:\n- 测试报告（`docs/test/YYYY-MM-DD-HH-MM-功能名称-测试报告.md`）\n- 测试覆盖率报告\n\n**质量门 Gate 3：测试门**\n- [ ] 单元测试覆盖率 ≥ 80%（或项目自定义值）\n- [ ] 集成测试已通过\n- [ ] 必要的契约测试已完成\n- [ ] Mock 数据已准备（test/data/）\n- [ ] 测试报告已生成\n\n---\n\n## 核心开发实践（强制）\n\n### 1. 代码修改前的分析（强制）\n\n**所有代码修改前，必须先完成深度分析，理解项目架构后再设计方案。**\n\n#### 调用链路分析要点\n```\nHTTP请求 → 路由 → Controller → Service → Logic → Data → Storage\n```\n\n必须分析：\n- **入口点**: 请求从哪个API端点或界面进入\n- **数据流转**: 数据在各层之间如何传递和转换\n- **依赖关系**: 各组件之间的依赖\n- **错误传播**: 错误如何在调用链中传播\n- **缓存策略**: 缓存的读写时机\n- **事务边界**: 数据一致性保证点\n\n#### 方案设计原则：KISS\n\n设计前必须回答4个问题：\n1. **\"这是真问题还是臆想的？\"** - 拒绝过度设计\n2. **\"有更简单的方法吗？\"** - 永远寻找最简方案\n3. **\"会破坏什么吗？\"** - 向后兼容是铁律\n4. **\"真的需要这个功能吗？\"** - 确认功能必要性\n\n**性能要求**：\n- 最小化数据库/缓存操作次数\n- 优先使用批量操作\n- 合理使用并发和异步\n- 避免不必要的数据复制\n\n**代码简洁性**：\n- 能用30行解决，绝不写300行\n- 复用现有代码\n- 函数职责单一\n\n#### 数据驱动的方案设计（强制）\n\n**所有方案必须有充足的数据支撑**：\n\n数据充足性判断：\n- ✅ 是否完整理解现有代码实现逻辑？\n- ✅ 是否掌握性能瓶颈数据？\n- ✅ 是否了解用户实际使用场景？\n- ✅ 是否分析业界最佳实践？\n- ✅ 是否评估不同方案优劣？\n\n**数据不足时的处理**：\n```\n⚠️ 我没有足够的信心设计最佳方案\n\n需要以下数据：\n1. [具体需要的数据1]\n2. [具体需要的数据2]\n...\n\n请提供这些数据或告诉我如何获取。\n```\n\n**禁止**：\n- ❌ 基于猜测或假设进行方案设计\n- ❌ 数据不足时强行给出方案\n- ❌ 使用\"可能\"、\"也许\"等不确定词汇描述关键决策\n\n#### 方案审批流程（强制）\n\n**在实施任何代码修改前，必须先获得用户审批**：\n\n**工作流程**：\n1. **分析阶段**：AI 使用只读工具（Read/Grep/Glob）深度分析代码\n2. **方案设计**：制定详细的实施方案（见下方\"方案文档要求\"）\n3. **展示方案**：向用户清晰展示方案，等待批准\n4. **执行修改**：获得批准后才开始实际修改代码\n\n**方案文档要求**：\n1. **提交方案设计文档**，包含：\n   - 完整调用链路分析\n   - 问题诊断和根因分析\n   - **支撑数据和分析**（必须包含）\n   - 方案设计（架构图、时序图、代码片段）\n   - KISS原则4问题的回答\n   - 性能影响评估\n   - 风险分析和缓解措施\n   - **文档保存**: 保存到 `docs/todo/YYYY-MM-DD-HH-MM-功能名称-方案.md`\n\n2. **等待用户确认** - 批准后方可开始实施\n\n3. **实施** - 严格按照批准方案执行\n\n#### 分析检查清单\n\n开始编码前必须完成：\n- [ ] 已完整追踪调用链路\n- [ ] 已理解所有涉及层的职责\n- [ ] 已识别所有数据转换点\n- [ ] 已回答KISS原则4个问题\n- [ ] 已收集充足数据支撑方案\n- [ ] 已制定详细实施方案\n- [ ] 已获得用户审批确认\n\n---\n\n### 2. 设计与代码层原则\n\n#### 2.1 SOLID原则（强制）\n\n##### 单一职责原则（SRP）\n- 一个类/模块只负责一个功能领域的变化\n- 每个包/模块职责单一且清晰，一个修改原因只能有一个\n- 避免\"上帝类\"或\"万能函数\"\n\n##### 开闭原则（OCP）\n- 对扩展开放，对修改封闭\n- 添加新功能通过扩展实现，不修改现有代码\n- 使用接口和抽象类定义扩展点\n\n##### 里氏替换原则（LSP）\n- 子类必须能够替换父类而不影响程序正确性\n- 所有实现同一接口的类必须可互换\n- 接口契约必须保持一致\n\n##### 接口隔离原则（ISP）\n- 客户端不应该依赖它不需要的接口\n- 接口应该小而专注，只包含必要方法\n- 大接口应拆分为多个小接口\n\n##### 依赖倒置原则（DIP）\n- 高层模块不应该依赖低层模块，两者都应该依赖抽象\n- 依赖接口而不是具体实现，通过依赖注入传递依赖\n- 具体实现可以随时替换\n\n#### 2.2 DRY（Don't Repeat Yourself）\n- **原则**: 避免重复实现，优先复用现有代码\n- **实践**: 添加任何新定义前，必须先用 `grep -r \"functionName\\|className\"` 检查是否已存在\n- **目标**: 每个知识点在系统中只有唯一、明确的表达\n\n#### 2.3 SoC（Separation of Concerns）\n- **原则**: 关注点分离，不同关注点分离到不同模块\n- **实践**: 与层职责定义和调用链分析一致，明确各层边界\n- **目标**: 业务逻辑、数据访问、UI展示、基础设施各司其职\n\n#### 2.4 LoD（Law of Demeter / 最少知道原则）\n- **原则**: 一个对象应当对其他对象有尽可能少的了解\n- **实践**: 减少跨层/跨域耦合，只与直接朋友通信\n- **规则**: 只调用以下方法：\n  - 对象自身的方法\n  - 方法参数的方法\n  - 方法内创建对象的方法\n  - 对象直接持有的组件的方法\n\n#### 2.5 组合优于继承\n- **原则**: 优先使用对象组合而不是类继承来实现代码复用\n- **实践**: 配合 OCP/LSP，把变更点外提为组合件\n- **优点**: 更灵活、更易测试、避免继承层次过深\n\n#### 2.6 YAGNI（You Aren't Gonna Need It）\n- **原则**: 只实现当前需要的功能，不为未来可能的需求预先设计\n- **实践**: 与 KISS 搭配，拒绝\"也许将来会用到\"的功能\n- **目标**: 减少不必要的复杂性和维护成本\n\n---\n\n### 3. 架构与健壮性原则\n\n#### 3.1 Clean/Hexagonal/Ports & Adapters 架构\n- **原则**: 接口抽象 + 适配器模式，把外部依赖隔离进边界层\n- **实践**:\n  - 核心业务逻辑不依赖外部框架、数据库、UI\n  - 通过端口（接口）定义核心与外部的交互契约\n  - 通过适配器实现具体的外部集成（数据库、API、消息队列）\n- **目标**: 与 DIP/ISP 强一致，实现核心业务的可测试性和可替换性\n\n#### 3.2 12-Factor App（服务化应用实践）\n- **配置外置**: 配置通过环境变量注入，不硬编码在代码中\n- **无状态进程**: 进程无状态，会话状态存储在外部（Redis等）\n- **日志标准输出**: 日志输出到 stdout/stderr，由日志收集系统统一处理\n- **一次性进程**: 进程可以快速启动和优雅关闭\n- **依赖隔离**: 显式声明依赖，不依赖系统全局包\n- **端口绑定**: 服务通过端口暴露，自包含运行\n\n#### 3.3 幂等性 & 去重\n- **原则**: 写接口、任务重试、事件消费的第一性原则\n- **实践**:\n  - API设计: POST/PUT 使用幂等键（idempotency-key）\n  - 消息消费: 使用消息ID去重，确保至少一次处理\n  - 数据库操作: 使用唯一索引防止重复插入\n- **目标**: 保证系统在重试、网络抖动情况下的数据一致性\n\n#### 3.4 限流/熔断/重试/退避（服务健壮性四件套）\n- **限流**:\n  - 保护系统不被突发流量压垮\n  - 实现: 令牌桶、漏桶、滑动窗口\n  - 默认: 100 RPS/实例（可根据项目调整）\n\n- **熔断**:\n  - 快速失败，防止级联故障\n  - 触发条件: 20%错误率或连续N次失败（可根据项目调整）\n  - 状态: 关闭 → 打开 → 半开 → 关闭\n\n- **重试**:\n  - 应对临时性故障\n  - 策略: 指数退避（1s, 2s, 4s），最多3次\n  - 注意: 必须配合幂等性设计\n\n- **退避**:\n  - 避免雪崩效应\n  - 策略: 固定退避、指数退避、带抖动的指数退避\n\n---\n\n### 4. 功能版本迭代限制\n\n**禁止版本迭代**: 对于存量功能，严格禁止版本迭代（v1、v2、v3）\n\n**核心原则**：\n- **就地更新**: 所有改进必须直接修改现有代码\n- **用户主导**: 只有用户明确要求才能创建新版本\n- **单一实现**: 每个功能只能有一个实现版本\n- **向后兼容**: 必须保持向后兼容\n- **清理废弃**: 必须版本迭代时同时清理旧代码\n\n---\n\n### 5. 任务解析与影响分析\n\n**任务前置分析原则**: 执行任何任务前，必须先进行全面分析\n\n#### 文件影响评估\n- **主要修改文件**: 直接需要编辑的核心文件\n- **关联影响文件**: 可能受影响需同步更新的文件\n- **测试相关文件**: 需要更新或新增的测试文件\n- **配置文件**: 可能需要调整的配置\n\n#### 依赖关系分析\n- **文件依赖**: 识别导入/引用关系\n- **功能依赖**: 识别模块间调用关系\n\n#### 重复定义检查\n\n添加任何新定义前，必须先检查：\n```bash\n# 检查函数/类/接口定义\ngrep -r \"functionName\\|className\" --include=\"*.[ext]\"\n```\n\n**原则**: 避免重复实现，优先复用现有代码\n\n---\n\n### 6. 前置条件信任原则\n\n**避免重复验证**: 信任调用链的前置条件\n\n```[语言]\n// ❌ 过度防御：重复验证已验证数据\nfunction process(data) {\n    if (!data) return  // 前层已验证\n    if (!data.field) return  // 前层已验证\n    // ...\n}\n\n// ✅ 信任前置条件\nfunction process(data) {\n    // 前置条件: 调用方已验证\n    const value = data.field\n    // 业务逻辑...\n}\n```\n\n**分层职责**：\n- **入口层**: 负责验证和防护\n- **业务层**: 信任前置条件，专注业务\n- **数据层**: 处理持久化，不做业务验证\n\n---\n\n## 交互规范（强制）\n\n### 沟通原则\n- **中文响应**: 所有响应使用中文\n- **详细说明**: 提供清晰的操作步骤和说明\n- **操作确认**: 重要操作前进行确认\n- **透明度**: 如实汇报进度、问题和风险\n\n### 主动提问机制（强制）\n- **数据不足时提问**: 缺乏必要信息时，必须使用 `AskUserQuestion` 工具询问用户\n- **明确性优先**: 遇到模糊需求时，通过提问明确用户意图\n- **必须提问的场景**:\n  - 技术方案有多种实现路径需权衡时\n  - 需要删除或修改重要功能/数据时\n  - 配置参数会显著影响系统行为时\n  - 不确定用户具体需求时\n  - 设计决策可能影响架构或性能时\n  - 存在向后兼容性风险时\n- **提问质量要求**:\n  - 问题应具体、聚焦\n  - 提供2-4个清晰选项\n  - 每个选项附带详细说明\n  - 说明各选项的影响和优缺点\n- **等待确认**: 提问后必须等待用户回答\n\n### 文件创建限制（强制）\n- **禁止主动创建文档**: 不主动创建文档文件(*.md)或README，除非用户明确要求\n- **优先编辑**: 优先编辑现有文件而非创建新文件\n- **必要性原则**: 只创建绝对必要的文件\n- **用户确认**: 创建新文件前必须征得用户同意\n\n---\n\n**最后更新**: [日期]\n```\n\n```monorepo-template\n# CLAUDE.md 模板 (Monorepo)\n\n> Monorepo 项目的统一开发规范和最佳实践。包含多个子项目的协作规范。\n\n---\n\n## 项目概述\n\n**[项目名称]** - [项目一句话描述]\n\n### 项目类型\n\n**Monorepo** ([Monorepo类型]: 前后端分离 / 多服务架构 / Workspace 管理等)\n\n### 项目架构（Monorepo）\n\n**整体架构**:\n```\nMonorepo 根目录\n├── [子项目1路径] - [子项目1名称] ([技术栈])\n├── [子项目2路径] - [子项目2名称] ([技术栈])\n└── [子项目N路径] - [子项目N名称] ([技术栈])\n```\n\n**子项目详情**:\n\n#### [子项目1名称] (`[子项目1路径]`)\n- **技术栈**: [框架] + [语言]\n- **职责**: [项目职责描述]\n- **主要目录**:\n  - `src/` - 源代码\n  - `test/` - 测试文件\n  - [其他关键目录]\n- **数据存储**: [数据库/缓存技术]\n- **架构模式**: [架构模式]\n\n#### [子项目2名称] (`[子项目2路径]`)\n- **技术栈**: [框架] + [语言]\n- **职责**: [项目职责描述]\n- **主要目录**:\n  - `src/` - 源代码\n  - `test/` - 测试文件\n  - [其他关键目录]\n- **数据存储**: [数据库/缓存技术]\n- **架构模式**: [架构模式]\n\n**项目间关系**:\n- [子项目1] → [子项目2]: [关系描述，如 API 调用]\n- [子项目2] → [数据存储]: [关系描述]\n\n### 核心技术栈\n\n**整体技术栈**:\n- **语言**: [所有使用的语言，去重]\n- **框架**: [所有使用的框架，去重]\n- **数据存储**: [所有数据存储技术，去重]\n- **代码风格**: [统一的命名规范，或注明差异]\n\n---\n\n## 测试规范\n- 各子项目测试覆盖率 > 80%\n- 使用 Mock 模拟外部依赖和跨项目依赖\n- Mock 数据存放在各子项目的 `test/data/` 目录\n- 测试文件存放在各子项目的 `test/` 目录\n- 集成测试放在根目录 `integration-tests/` 目录\n\n---\n\n## 架构规则（强制）\n\n### Monorepo 管理规则\n\n1. **子项目独立性**\n   - ✅ 每个子项目应该能独立构建和测试\n   - ✅ 子项目间的依赖应该明确声明\n   - ❌ 禁止直接引用其他子项目的内部实现\n   - ❌ 禁止循环依赖\n\n2. **共享代码管理**\n   - ✅ 共享工具库放在 `packages/` 或 `libs/` 目录\n   - ✅ 共享类型定义统一管理\n   - ❌ 禁止复制粘贴代码到多个子项目\n\n3. **版本控制策略**\n   - ✅ 使用统一的版本管理工具（如 Lerna、pnpm workspaces）\n   - ✅ 子项目版本同步或独立管理（根据实际情况）\n\n### 层职责定义\n\n**[子项目1名称]**:\n- **[Layer 1]**: ✅ [应该做的] / ❌ [不应该做的]\n- **[Layer 2]**: ✅ [应该做的] / ❌ [不应该做的]\n\n**[子项目2名称]**:\n- **[Layer 1]**: ✅ [应该做的] / ❌ [不应该做的]\n- **[Layer 2]**: ✅ [应该做的] / ❌ [不应该做的]\n\n### 开发规则\n1. **命名规范** - [统一命名规范，或注明各子项目差异]\n2. **依赖管理** - 使用 workspace 特性管理子项目间依赖\n3. **错误处理** - [统一错误处理机制]\n4. **版本控制** -\n   - Git 提交必须使用 AskUserQuestion 工具询问用户同意\n   - 提交消息必须包含：\n     - 问题描述（What）\n     - 根本原因（Why）\n     - 修复内容（How）\n     - 技术细节（Details）\n     - 影响范围（Impact）\n   - **严格禁止**包含以下内容：\n     - `🤖 Generated with [Claude Code](https://claude.com/claude-code)`\n     - `Co-Authored-By: Claude <noreply@anthropic.com>`\n     - 其他任何 AI 工具的标识或署名\n5. **禁止行为** - [明确禁止的操作]\n   - 禁止子项目间的紧耦合\n   - 禁止绕过 API 直接访问其他子项目的数据库\n\n### Claude Code 工具使用规范\n\n**AI 必须使用的工具**：\n- **AskUserQuestion**: 数据不足或需要决策时，必须主动询问用户\n- **TodoWrite**: 跟踪多步骤任务的进度，及时更新任务状态\n- **Read/Grep/Glob**: 修改前必须先分析现有代码，避免重复定义\n- **Plan**: 设计实施方案时，必须使用 Plan 工具进行规划和架构设计\n- **跨项目影响分析**: 修改子项目代码时，必须分析对其他子项目的影响\n\n### Skills 技能使用规范（强制）\n\nSkills 是可扩展的专业能力模块，**必须**根据场景强制使用对应技能。\n\n#### 强制使用场景映射表\n\n> **使用说明**: 根据项目实际可用的 Skills 填充下表。通过 `<available_skills>` 列表获取当前环境可用技能。\n\n| 触发场景 | 关键词识别 | 必须使用的技能 |\n|---------|-----------|--------------|\n| [场景1] | [关键词1、关键词2、...] | `[skill-name-1]` |\n| [场景2] | [关键词1、关键词2、...] | `[skill-name-2]` |\n| [场景3] | [关键词1、关键词2、...] | `[skill-name-3]` |\n\n**常见场景类型参考**：\n- 架构设计类：系统架构、技术选型、组件设计\n- 可视化类：架构图、流程图、时序图、关系图\n- 文档处理类：Word、PPT、PDF、Excel\n- 前端设计类：UI设计、界面原型、组件设计\n\n#### 强制触发规则\n\n**以下场景必须调用对应技能，禁止跳过**：\n\n1. **[场景类型1]**（触发 `[skill-name]`）\n   - [具体触发条件1]\n   - [具体触发条件2]\n   - 用户提及\"[关键词]\"\n\n2. **[场景类型2]**（触发 `[skill-name]`）\n   - [具体触发条件1]\n   - [具体触发条件2]\n\n#### 技能调用检查清单\n\n在完成任务前，必须检查：\n- [ ] 是否识别到上述强制触发场景？\n- [ ] 是否已调用对应的必需技能？\n- [ ] 如未调用，是否有合理理由？（需向用户说明）\n\n#### 禁止行为\n\n- ❌ **禁止**在强制场景下不调用对应技能\n- ❌ **禁止**用文字描述替代可视化输出（有可视化技能时）\n- ❌ **禁止**跳过专业技能直接输出低质量结果\n\n#### 技能调用语法\n\n```\n使用 Skill 工具，参数 skill 设置为技能名称：\n- [根据 <available_skills> 列表填充]\n```\n\n#### 动态技能发现流程\n\n1. **识别任务类型**：分析用户需求，判断是否需要专业技能支持\n2. **查看可用技能**：通过系统提供的 `<available_skills>` 列表确认当前可用的技能\n3. **匹配场景映射**：根据上表的场景映射，确定必须调用的技能\n4. **调用技能**：使用 `Skill` 工具调用对应技能\n\n**Token 管理规范（强制）**：\n\n在开始每个 todo 任务前，必须评估剩余 token 是否足够完成该任务：\n\n1. **评估标准**：\n   - 当前剩余 token < 30000：存在风险\n   - 当前剩余 token < 20000：高风险\n   - 当前剩余 token < 10000：极高风险\n\n2. **风险处理流程**：\n\n   **如果存在风险**，必须使用 AskUserQuestion 工具询问用户：\n\n   ```yaml\n   question: \"⚠️ Token 预警：当前剩余 [X] tokens，即将开始「[Todo任务名称]」可能存在 token 不足风险。您希望如何处理？\"\n   header: \"Token 管理\"\n   multiSelect: false\n   options:\n     - label: \"继续执行当前任务\"\n       description: \"继续完成当前任务，可能需要在新会话中继续未完成的工作\"\n     - label: \"生成进度总结文档\"\n       description: \"生成包含当前进度总结和剩余待办事项实施方案的文档，便于在新会话中继续\"\n   ```\n\n3. **生成进度总结文档**（用户选择选项 2 时）：\n\n   创建文档：`docs/progress/YYYY-MM-DD-HH-MM-[任务名称]-进度总结.md`\n\n   文档必须包含：\n   ```markdown\n   # [任务名称] - 进度总结与实施方案\n\n   **创建时间**: YYYY-MM-DD HH:MM\n   **当前状态**: 进行中\n   **完成度**: X/Y 个任务\n   **项目类型**: Monorepo\n\n   ---\n\n   ## 一、已完成任务\n\n   ### 1.1 任务清单\n   - [x] 任务 1 - 完成情况描述\n   - [x] 任务 2 - 完成情况描述\n   - [x] 任务 3 - 完成情况描述\n\n   ### 1.2 关键成果\n   - **成果 1**: 具体内容和路径\n   - **成果 2**: 具体内容和路径\n   - **成果 3**: 具体内容和路径\n\n   ### 1.3 已修改文件（Monorepo）\n   ```\n   [子项目1]/path/to/file1.ext - 修改内容描述\n   [子项目2]/path/to/file2.ext - 修改内容描述\n   共享库/path/to/shared.ext - 修改内容描述\n   ```\n\n   ### 1.4 跨项目影响\n   - **[子项目1]**: 影响描述\n   - **[子项目2]**: 影响描述\n   - **共享代码**: 影响范围\n\n   ---\n\n   ## 二、剩余待办任务\n\n   ### 2.1 待办清单\n   - [ ] 任务 4 - 详细描述（涉及子项目：[列表]）\n   - [ ] 任务 5 - 详细描述（涉及子项目：[列表]）\n   - [ ] 任务 6 - 详细描述（涉及子项目：[列表]）\n\n   ### 2.2 实施方案\n\n   #### 任务 4: [任务名称]\n   **目标**: [具体目标]\n   **涉及子项目**: [子项目列表]\n\n   **步骤**:\n   1. [详细步骤 1]\n   2. [详细步骤 2]\n   3. [详细步骤 3]\n\n   **需要修改的文件**:\n   - `[子项目1]/path/to/file1.ext` - [修改说明]\n   - `[子项目2]/path/to/file2.ext` - [修改说明]\n   - `共享库/path/to/shared.ext` - [修改说明]\n\n   **跨项目影响**:\n   - [子项目1]: [影响说明]\n   - [子项目2]: [影响说明]\n\n   **注意事项**:\n   - [注意点 1]\n   - [注意点 2]\n\n   #### 任务 5: [任务名称]\n   ... (同上格式)\n\n   ---\n\n   ## 三、技术背景和上下文\n\n   ### 3.1 Monorepo 架构\n   ```\n   [展示 monorepo 结构和子项目关系]\n   ```\n\n   ### 3.2 子项目信息\n   - **[子项目1]**: [技术栈] - [职责]\n   - **[子项目2]**: [技术栈] - [职责]\n\n   ### 3.3 重要约束\n   - [约束 1]\n   - [约束 2]\n   - [Monorepo 特定约束]\n\n   ### 3.4 已知问题\n   - [问题 1 及解决方案]\n   - [问题 2 及解决方案]\n\n   ---\n\n   ## 四、继续工作指南\n\n   ### 4.1 快速启动\n   在新会话中执行以下步骤：\n   1. 阅读本文档了解当前进度\n   2. 使用 TodoWrite 工具恢复任务列表\n   3. 从「任务 4」开始继续执行\n   4. 注意跨项目影响分析\n\n   ### 4.2 验证检查清单\n   开始前请确认：\n   - [ ] 已理解所有已完成任务的内容\n   - [ ] 已查看所有修改过的文件（包括所有子项目）\n   - [ ] 已理解剩余任务的实施方案\n   - [ ] 已了解 Monorepo 架构和子项目关系\n   - [ ] 已了解跨项目影响范围\n\n   ---\n\n   **🤖 Generated with Claude Code**\n   ```\n\n4. **文档生成后**：\n   - 输出文档路径\n   - 提示用户在新会话中使用 `@文档路径` 继续工作\n   - 优雅结束当前会话\n\n**最佳实践**：\n- 定期评估 token 使用情况\n- 在大型任务开始前进行评估\n- Monorepo 项目由于涉及多个子项目，通常需要更多 tokens\n- 预留至少 20000 tokens 的安全边际\n- 及时保存进度，避免工作丢失\n\n---\n\n## AI 工作流程与质量门（强制）\n\n### 工作流程总览\n\n```\n需求输入\n   ↓\nA. 立项/澄清（Gate 0）\n   ↓  KISS + YAGNI + AskUserQuestion\n   ↓\nB. 方案设计（Gate 1）\n   ↓  SoC/LoD/组合优于继承 + DIP/ISP\n   ↓\nC. 编码前置（Gate 2）\n   ↓  DRY + 分层职责 + 前置条件信任\n   ↓\nD. 编码实现\n   ↓  SOLID + 幂等/限流/熔断 + 可观测性\n   ↓\nE. 测试与验收（Gate 3）\n   ↓  单测+契约 + Mock + 覆盖率\n   ↓\n开发完成 ✅\n（发布与运维不在此范围）\n```\n\n---\n\n### A. 立项/澄清阶段（Gate 0）\n\n**目标**: 明确需求边界，拒绝过度设计\n\n**使用原则**:\n- **KISS + YAGNI** → 先砍需求，确认功能必要性\n- **AskUserQuestion** → 明确边界与约束\n\n**输出**:\n- 需求边界清晰\n- 最小方案草图\n- 走审批流程\n\n**质量门 Gate 0：问题澄清**\n- [ ] 已使用 AskUserQuestion 收敛需求与约束\n- [ ] KISS 四问已回答（特别是\"真的需要这个功能吗？\"）\n- [ ] 需求边界明确，无歧义\n\n---\n\n### B. 方案设计阶段（Gate 1）\n\n**目标**: 设计可扩展、可维护的方案\n\n**使用原则**:\n- **SoC/LoD/组合优于继承** → 明确分层边界，减少耦合\n- **DIP/ISP** → 稳住扩展点，依赖抽象\n\n**输出**:\n- 方案文档（`docs/todo/YYYY-MM-DD-HH-MM-功能名称-方案.md`）\n- 必须包含：\n  - 完整调用链路分析（包括跨项目调用）\n  - KISS 四问的回答\n  - 性能影响评估\n  - 跨项目影响分析\n  - 风险分析和缓解措施\n\n**质量门 Gate 1：方案评审**\n- [ ] 方案文档已提交\n- [ ] 调用链路分析完整\n- [ ] KISS 四问已回答\n- [ ] 性能影响已评估\n- [ ] 跨项目影响已分析\n- [ ] 风险与缓解措施明确\n- [ ] 已获得用户审批\n\n---\n\n### C. 编码前置阶段（Gate 2）\n\n**目标**: 确保代码质量，避免重复实现\n\n**使用原则**:\n- **DRY** → 全局检索避免重复（使用 grep，覆盖所有子项目）\n- **SRP/SoC** → 划清分层职责\n- **前置条件信任原则** → 避免重复验证\n\n**输出**:\n- 代码重复检查报告（覆盖所有子项目）\n- 分层职责明确\n- 前置条件明确\n\n**质量门 Gate 2：实现前检查**\n- [ ] 已使用 grep 全局检索所有子项目，无重复定义\n- [ ] 分层边界清晰，职责明确\n- [ ] 前置条件信任原则已应用\n- [ ] 接口契约明确\n\n---\n\n### D. 编码实现阶段\n\n**目标**: 高质量代码实现\n\n**使用原则**:\n- **SOLID** → 作为底座（SRP/OCP/LSP/ISP/DIP）\n- **幂等/限流/熔断** → 进到关键路径\n- **日志/指标/Trace** → 埋点就位\n\n**输出**:\n- 高质量代码\n- 可观测性埋点\n- 健壮性保障（幂等/限流/熔断）\n\n**关键检查**:\n- [ ] SOLID 原则已遵循\n- [ ] 关键路径已添加幂等/限流/熔断\n- [ ] 日志/指标/Trace 埋点完整\n\n---\n\n### E. 测试与验收阶段（Gate 3）\n\n**目标**: 确保代码质量和功能正确性\n\n**使用原则**:\n- **测试金字塔** → 单测+契约优先\n- **Mock** → 隔离外部依赖\n\n**输出**:\n- 测试报告（`docs/test/YYYY-MM-DD-HH-MM-功能名称-测试报告.md`）\n- 测试覆盖率报告（各子项目）\n\n**质量门 Gate 3：测试门**\n- [ ] 单元测试覆盖率 ≥ 80%（或项目自定义值）\n- [ ] 集成测试已通过（包括跨项目集成测试）\n- [ ] 必要的契约测试已完成\n- [ ] Mock 数据已准备（test/data/）\n- [ ] 测试报告已生成\n\n---\n\n## 核心开发实践（强制）\n\n### 1. 代码修改前的分析（强制）\n\n**所有代码修改前，必须先完成深度分析，理解 Monorepo 架构后再设计方案。**\n\n#### 调用链路分析要点（Monorepo）\n```\n用户请求 → [子项目1入口] → [子项目1业务逻辑] → [跨项目API调用] → [子项目2] → [数据存储]\n```\n\n必须分析：\n- **入口点**: 请求从哪个子项目的哪个端点进入\n- **跨项目调用**: 数据如何在子项目间流转\n- **依赖关系**: 各子项目之间的依赖\n- **错误传播**: 错误如何跨项目传播\n- **数据一致性**: 跨项目的事务和一致性保证\n\n#### 方案设计原则: KISS\n\n设计前必须回答4个问题:\n1. **\"这是真问题还是臆想的?\"** - 拒绝过度设计\n2. **\"有更简单的方法吗?\"** - 永远寻找最简方案\n3. **\"会破坏什么吗?\"** - 向后兼容是铁律，考虑对所有子项目的影响\n4. **\"真的需要这个功能吗?\"** - 确认功能必要性\n\n**性能要求**:\n- 最小化跨项目通信次数\n- 优先使用批量操作\n- 合理使用缓存减少跨项目调用\n- 避免不必要的数据复制\n\n**代码简洁性**:\n- 能用30行解决，绝不写300行\n- 复用现有代码和共享库\n- 函数职责单一\n\n#### 数据驱动的方案设计（强制）\n\n**所有方案必须有充足的数据支撑**：\n\n数据充足性判断：\n- ✅ 是否完整理解现有代码实现逻辑？\n- ✅ 是否掌握各子项目之间的调用关系？\n- ✅ 是否了解跨项目的性能瓶颈？\n- ✅ 是否分析业界 Monorepo 最佳实践？\n- ✅ 是否评估不同方案优劣？\n\n**数据不足时的处理**:\n```\n⚠️ 我没有足够的信心设计最佳方案\n\n需要以下数据:\n1. [具体需要的数据1]\n2. [具体需要的数据2]\n...\n\n请提供这些数据或告诉我如何获取。\n```\n\n**禁止**:\n- ❌ 基于猜测或假设进行方案设计\n- ❌ 数据不足时强行给出方案\n- ❌ 使用\"可能\"、\"也许\"等不确定词汇描述关键决策\n- ❌ 忽视跨项目影响\n\n#### 方案审批流程（强制）\n\n**在实施任何代码修改前，必须先获得用户审批**:\n\n**工作流程**:\n1. **分析阶段**: AI 使用只读工具(Read/Grep/Glob)深度分析所有相关子项目的代码\n2. **方案设计**: 制定详细的实施方案，包括跨项目影响分析\n3. **展示方案**: 向用户清晰展示方案，等待批准\n4. **执行修改**: 获得批准后才开始实际修改代码\n\n**方案文档要求**:\n1. **提交方案设计文档**，包含:\n   - 完整调用链路分析（包括跨项目调用）\n   - 问题诊断和根因分析\n   - **支撑数据和分析**（必须包含）\n   - 方案设计（架构图、时序图、代码片段）\n   - KISS原则4问题的回答\n   - 性能影响评估（特别是跨项目通信）\n   - **跨项目影响分析**（列出所有受影响的子项目）\n   - 风险分析和缓解措施\n   - **文档保存**: 保存到 `docs/todo/YYYY-MM-DD-HH-MM-功能名称-方案.md`\n\n2. **等待用户确认** - 批准后方可开始实施\n\n3. **实施** - 严格按照批准方案执行\n\n#### 分析检查清单\n\n开始编码前必须完成:\n- [ ] 已完整追踪调用链路（包括跨项目调用）\n- [ ] 已理解所有涉及子项目的职责\n- [ ] 已识别所有跨项目数据传递点\n- [ ] 已回答KISS原则4个问题\n- [ ] 已收集充足数据支撑方案\n- [ ] 已分析对所有子项目的影响\n- [ ] 已制定详细实施方案\n- [ ] 已获得用户审批确认\n\n### 2. SOLID原则（强制执行）\n\n**所有架构设计和代码实现必须遵循SOLID原则**：\n\n**Monorepo 特别注意**：\n- 在 Monorepo 中，SOLID 原则不仅适用于单个子项目内部，也适用于子项目之间的关系\n- 子项目间的接口设计同样需要遵循 SOLID 原则\n\n#### 1. 单一职责原则（SRP - Single Responsibility Principle）\n- **定义**：一个类/模块只负责一个功能领域的变化\n- **实践要点**：\n  - 每个包/模块职责单一且清晰\n  - 工厂负责创建，适配器负责转换，具体实现负责执行\n  - 避免\"上帝类\"或\"万能函数\"\n  - 一个模块的修改原因只能有一个\n- **Monorepo 应用**：\n  - 每个子项目应该有明确且单一的职责\n  - 避免子项目职责过于复杂或模糊\n\n#### 2. 开闭原则（OCP - Open-Closed Principle）\n- **定义**：对扩展开放，对修改封闭\n- **实践要点**：\n  - 添加新功能通过扩展实现，不修改现有代码\n  - 使用接口和抽象类定义扩展点\n  - 新增实现只需创建新文件，无需修改旧代码\n  - 避免使用大量 switch/if-else 判断类型\n- **Monorepo 应用**：\n  - 添加新子项目不应该需要修改现有子项目\n  - 子项目间的 API 应该稳定，通过版本控制实现兼容\n\n#### 3. 里氏替换原则（LSP - Liskov Substitution Principle）\n- **定义**：子类必须能够替换父类而不影响程序正确性\n- **实践要点**：\n  - 所有实现同一接口的类必须可互换\n  - 接口契约必须保持一致\n  - 不违反接口定义的前置条件和后置条件\n  - 调用方不应关心具体实现类型\n- **Monorepo 应用**：\n  - 如果多个子项目实现相同的接口，它们应该可以互相替换\n  - 共享接口的契约必须严格遵守\n\n#### 4. 接口隔离原则（ISP - Interface Segregation Principle）\n- **定义**：客户端不应该依赖它不需要的接口\n- **实践要点**：\n  - 接口应该小而专注，只包含必要方法\n  - 避免臃肿的接口定义\n  - 根据客户端需求定义最小接口\n  - 大接口应拆分为多个小接口\n- **Monorepo 应用**：\n  - 子项目之间的 API 应该精简，只暴露必要的接口\n  - 避免一个子项目暴露过多不相关的功能\n\n#### 5. 依赖倒置原则（DIP - Dependency Inversion Principle）\n- **定义**：高层模块不应该依赖低层模块，两者都应该依赖抽象\n- **实践要点**：\n  - 依赖接口而不是具体实现\n  - 通过依赖注入传递依赖\n  - 抽象层不依赖具体层\n  - 具体实现可以随时替换\n- **Monorepo 应用**：\n  - 子项目之间应该通过定义良好的接口通信\n  - 避免直接依赖其他子项目的具体实现\n  - 使用共享接口定义实现解耦\n\n#### SOLID原则检查清单\n\n**设计新功能前必须回答**：\n- [ ] **SRP**：每个模块的职责是否单一明确？（包括子项目级别）\n- [ ] **OCP**：添加新功能是否需要修改现有代码？（包括其他子项目）\n- [ ] **LSP**：所有实现是否可以互换使用？（包括跨子项目）\n- [ ] **ISP**：接口是否臃肿，是否包含不必要的方法？（包括跨项目 API）\n- [ ] **DIP**：是否依赖抽象而不是具体实现？（包括子项目间依赖）\n\n**违反SOLID原则的后果**：\n- 代码耦合度高，难以维护\n- 功能扩展需要大量修改现有代码\n- 子项目间紧耦合，难以独立开发和部署\n- 测试困难，无法进行单元测试\n- 技术债务快速累积\n\n#### 2.2 DRY（Don't Repeat Yourself）\n- **原则**: 避免重复实现，优先复用现有代码和共享库\n- **实践**: 添加任何新定义前，必须先用 `grep -r \"functionName\\|className\"` 检查所有子项目\n- **目标**: 每个知识点在系统中只有唯一、明确的表达\n\n#### 2.3 SoC（Separation of Concerns）\n- **原则**: 关注点分离，不同关注点分离到不同模块\n- **实践**: 与层职责定义和调用链分析一致，明确各层边界\n- **目标**: 业务逻辑、数据访问、UI展示、基础设施各司其职\n- **Monorepo 应用**: 每个子项目应有明确的关注点\n\n#### 2.4 LoD（Law of Demeter / 最少知道原则）\n- **原则**: 一个对象应当对其他对象有尽可能少的了解\n- **实践**: 减少跨层/跨域/跨项目耦合，只与直接朋友通信\n- **规则**: 只调用以下方法：\n  - 对象自身的方法\n  - 方法参数的方法\n  - 方法内创建对象的方法\n  - 对象直接持有的组件的方法\n\n#### 2.5 组合优于继承\n- **原则**: 优先使用对象组合而不是类继承来实现代码复用\n- **实践**: 配合 OCP/LSP，把变更点外提为组合件\n- **优点**: 更灵活、更易测试、避免继承层次过深\n\n#### 2.6 YAGNI（You Aren't Gonna Need It）\n- **原则**: 只实现当前需要的功能，不为未来可能的需求预先设计\n- **实践**: 与 KISS 搭配，拒绝\"也许将来会用到\"的功能\n- **目标**: 减少不必要的复杂性和维护成本\n\n---\n\n### 3. 架构与健壮性原则\n\n#### 3.1 Clean/Hexagonal/Ports & Adapters 架构\n- **原则**: 接口抽象 + 适配器模式，把外部依赖隔离进边界层\n- **实践**:\n  - 核心业务逻辑不依赖外部框架、数据库、UI\n  - 通过端口（接口）定义核心与外部的交互契约\n  - 通过适配器实现具体的外部集成（数据库、API、消息队列）\n- **目标**: 与 DIP/ISP 强一致，实现核心业务的可测试性和可替换性\n\n#### 3.2 12-Factor App（服务化应用实践）\n- **配置外置**: 配置通过环境变量注入，不硬编码在代码中\n- **无状态进程**: 进程无状态，会话状态存储在外部（Redis等）\n- **日志标准输出**: 日志输出到 stdout/stderr，由日志收集系统统一处理\n- **一次性进程**: 进程可以快速启动和优雅关闭\n- **依赖隔离**: 显式声明依赖，不依赖系统全局包\n- **端口绑定**: 服务通过端口暴露，自包含运行\n\n#### 3.3 幂等性 & 去重\n- **原则**: 写接口、任务重试、事件消费的第一性原则\n- **实践**:\n  - API设计: POST/PUT 使用幂等键（idempotency-key）\n  - 消息消费: 使用消息ID去重，确保至少一次处理\n  - 数据库操作: 使用唯一索引防止重复插入\n- **目标**: 保证系统在重试、网络抖动情况下的数据一致性\n\n#### 3.4 限流/熔断/重试/退避（服务健壮性四件套）\n- **限流**:\n  - 保护系统不被突发流量压垮\n  - 实现: 令牌桶、漏桶、滑动窗口\n  - 默认: 100 RPS/实例（可根据项目调整）\n\n- **熔断**:\n  - 快速失败，防止级联故障\n  - 触发条件: 20%错误率或连续N次失败（可根据项目调整）\n  - 状态: 关闭 → 打开 → 半开 → 关闭\n\n- **重试**:\n  - 应对临时性故障\n  - 策略: 指数退避（1s, 2s, 4s），最多3次\n  - 注意: 必须配合幂等性设计\n\n- **退避**:\n  - 避免雪崩效应\n  - 策略: 固定退避、指数退避、带抖动的指数退避\n\n---\n\n### 4. 功能版本迭代限制\n\n**禁止版本迭代**: 对于存量功能，严格禁止版本迭代(v1、v2、v3)\n\n**核心原则**:\n- **就地更新**: 所有改进必须直接修改现有代码\n- **用户主导**: 只有用户明确要求才能创建新版本\n- **单一实现**: 每个功能只能有一个实现版本\n- **向后兼容**: 必须保持向后兼容，考虑所有依赖该功能的子项目\n- **清理废弃**: 必须版本迭代时同时清理旧代码\n\n### 4. 任务解析与影响分析\n\n**任务前置分析原则**: 执行任何任务前，必须先进行全面分析\n\n#### 文件影响评估（Monorepo）\n- **主要修改文件**: 直接需要编辑的核心文件\n- **关联影响文件**: 同一子项目中可能受影响的文件\n- **跨项目影响文件**: 其他子项目中可能受影响的文件\n- **共享代码影响**: 共享库和工具的影响范围\n- **测试相关文件**: 需要更新或新增的测试文件（包括集成测试）\n- **配置文件**: 可能需要调整的配置\n\n#### 依赖关系分析（Monorepo）\n- **子项目内依赖**: 识别导入/引用关系\n- **跨项目依赖**: 识别子项目间的调用关系\n- **共享代码依赖**: 识别对共享库的依赖\n\n#### 重复定义检查\n\n添加任何新定义前，必须先检查所有子项目：\n```bash\n# 检查所有子项目中的函数/类/接口定义\ngrep -r \"functionName\\|className\" --include=\"*.[ext]\" [所有子项目路径]\n```\n\n**原则**: 避免重复实现，优先复用现有代码和共享库\n\n### 5. 前置条件信任原则\n\n**避免重复验证**: 信任调用链的前置条件\n\n**分层职责**:\n- **入口层**: 负责验证和防护（通常在面向用户的子项目）\n- **业务层**: 信任前置条件，专注业务\n- **数据层**: 处理持久化，不做业务验证\n- **跨项目调用**: 调用其他子项目的 API 时，信任其已完成验证\n\n---\n\n## 交互规范（强制）\n\n### 沟通原则\n- **中文响应**: 所有响应使用中文\n- **详细说明**: 提供清晰的操作步骤和说明\n- **操作确认**: 重要操作前进行确认\n- **透明度**: 如实汇报进度、问题和风险\n- **跨项目影响说明**: 修改代码时明确说明对其他子项目的影响\n\n### 主动提问机制（强制）\n- **数据不足时提问**: 缺乏必要信息时，必须使用 `AskUserQuestion` 工具询问用户\n- **明确性优先**: 遇到模糊需求时，通过提问明确用户意图\n- **必须提问的场景**:\n  - 技术方案有多种实现路径需权衡时\n  - 需要删除或修改重要功能/数据时\n  - 修改可能影响多个子项目时\n  - 配置参数会显著影响系统行为时\n  - 不确定用户具体需求时\n  - 设计决策可能影响架构或性能时\n  - 存在跨项目向后兼容性风险时\n- **提问质量要求**:\n  - 问题应具体、聚焦\n  - 提供2-4个清晰选项\n  - 每个选项附带详细说明\n  - 说明各选项的影响和优缺点（包括对各子项目的影响）\n- **等待确认**: 提问后必须等待用户回答\n\n### 文件创建限制（强制）\n- **禁止主动创建文档**: 不主动创建文档文件(*.md)或README，除非用户明确要求\n- **优先编辑**: 优先编辑现有文件而非创建新文件\n- **必要性原则**: 只创建绝对必要的文件\n- **用户确认**: 创建新文件前必须征得用户同意\n\n---\n\n## Monorepo 特定规范\n\n### 跨项目通信规范\n\n1. **API 调用规范**\n   - 使用明确定义的 API 接口\n   - API 变更必须遵循版本管理策略\n   - 禁止直接访问其他子项目的内部实现\n\n2. **共享代码规范**\n   - 共享代码放在独立的包中\n   - 共享代码必须有完善的文档和测试\n   - 修改共享代码必须评估对所有依赖方的影响\n\n3. **数据共享规范**\n   - 优先使用 API 传递数据\n   - 必要时可共享数据库，但需明确所有权\n   - 禁止直接读写其他子项目的数据表\n\n### 构建和部署规范\n\n1. **独立构建**: 每个子项目应该能独立构建\n2. **依赖顺序**: 明确子项目的构建依赖顺序\n3. **并行构建**: 利用 workspace 工具进行并行构建\n4. **增量构建**: 只构建有变更的子项目\n\n---\n\n**最后更新**: [日期]\n```\n\n---\n\n## 执行步骤\n\n### 1. 前置检查\n\na. 检查当前目录是否已存在 CLAUDE.md 文件\n   - 使用 Read 工具尝试读取 ./CLAUDE.md\n   - 如果文件存在，使用 AskUserQuestion 询问用户是否要覆盖：\n     - 选项 1: \"备份后覆盖\"（推荐） - 将现有文件备份为 CLAUDE.md.backup-{timestamp}\n     - 选项 2: \"直接覆盖\" - 直接覆盖现有文件\n     - 选项 3: \"取消操作\" - 退出命令\n   - 如果用户选择取消，立即终止执行并输出提示信息\n\n### 1.5 检测 Monorepo 结构\n\n**目标**: 智能检测项目是否为 Monorepo（包含多个子项目）\n\n#### a. 检测显式 Monorepo 配置\n\n使用 Read 工具检查是否有 Monorepo 配置：\n\n```bash\n# 1. 检测 Node.js workspaces\nRead package.json → 检查 workspaces 字段\n  - 如果存在 workspaces 数组 → isMonorepo = true, confidence = \"high\", type = \"workspaces\"\n\n# 2. 检测 Lerna\nRead lerna.json → 是否存在\n  - 如果存在 → isMonorepo = true, confidence = \"high\", type = \"lerna\"\n\n# 3. 检测 Turborepo\nRead turbo.json → 是否存在\n  - 如果存在 → isMonorepo = true, confidence = \"high\", type = \"turborepo\"\n\n# 4. 检测 pnpm workspaces\nRead pnpm-workspace.yaml → 是否存在\n  - 如果存在 → isMonorepo = true, confidence = \"high\", type = \"pnpm-workspaces\"\n```\n\n#### b. 检测典型目录结构\n\n如果没有检测到显式配置，使用 Glob 检测常见目录组合：\n\n```bash\n# 检测前后端分离\nGlob: frontend\nGlob: backend\n  - 如果同时存在 → 检查是否有独立配置文件\n    - frontend/package.json 或 frontend/其他配置 存在\n    - backend/go.mod 或 backend/其他配置 存在\n    - 如果是 → isMonorepo = true, confidence = \"medium\", type = \"frontend-backend\"\n\n# 检测 client-server 结构\nGlob: client\nGlob: server\n  - 同上逻辑\n\n# 检测 web-api 结构\nGlob: web\nGlob: api\n  - 同上逻辑\n\n# 检测 Node.js packages/apps 结构\nGlob: packages/*/package.json\nGlob: apps/*/package.json\n  - 如果找到多个（≥2个）子项目 → isMonorepo = true, confidence = \"medium\", type = \"multi-packages\"\n\n# 检测 Go 多应用结构\nGlob: cmd/*\n  - 如果 cmd 目录下有多个子目录（≥2个）\n  - 且根目录有 go.mod\n  - → isMonorepo = true, confidence = \"medium\", type = \"go-multi-app\"\n\n# 检测 Python/其他多服务结构\nGlob: services/*/\n  - 如果 services 目录下有多个子目录（≥2个）\n  - 且子目录包含配置文件\n  - → isMonorepo = true, confidence = \"medium\", type = \"multi-services\"\n```\n\n#### c. 检测多配置文件（兜底检测）\n\n如果以上都未检测到，搜索所有配置文件：\n\n```bash\n# 搜索所有主要配置文件\nGlob: **/package.json\nGlob: **/go.mod\nGlob: **/pyproject.toml\nGlob: **/pom.xml\nGlob: **/Cargo.toml\n\n# 统计配置文件数量和位置\n如果在不同的一级子目录中找到多个配置文件（≥2个）:\n  - isMonorepo = true\n  - confidence = \"low\"  # 需要用户确认\n  - type = \"multi-project\"\n```\n\n#### d. 结果记录\n\n创建 Monorepo 检测结果数据结构：\n\n```javascript\nMonorepoDetection = {\n  isMonorepo: true/false,\n  confidence: \"high\" | \"medium\" | \"low\" | null,\n  type: \"workspaces\" | \"lerna\" | \"turborepo\" | \"pnpm-workspaces\" |\n        \"frontend-backend\" | \"multi-packages\" | \"go-multi-app\" |\n        \"multi-services\" | \"multi-project\" | null,\n  subProjectPaths: [\n    \"frontend/\",\n    \"backend/\",\n    // ... 其他子项目路径\n  ]\n}\n```\n\n#### e. 用户确认（confidence = \"low\" 时）\n\n如果置信度为 \"low\"，使用 AskUserQuestion 确认：\n\n```yaml\n使用 AskUserQuestion:\n  question: \"检测到项目中有多个配置文件，这是一个包含多个子项目的 Monorepo 吗？\"\n  header: \"Monorepo 确认\"\n  multiSelect: false\n  options:\n    - label: \"是，这是一个 Monorepo\"\n      description: \"项目包含多个独立的子项目（如前端+后端）\"\n    - label: \"否，这是单个项目\"\n      description: \"按照单项目模式分析\"\n```\n\n#### f. 输出检测结果\n\n输出检测摘要：\n\n```\n🔍 项目结构检测完成！\n\n📦 项目类型: [Monorepo / 单项目]\n🔧 检测方式: [检测到的配置类型]\n📂 子项目: [子项目数量] 个\n  - [子项目1路径]\n  - [子项目2路径]\n  ...\n```\n\n### 2. 项目分析（智能推断）\n\n**核心原则**: 数据驱动，避免猜测。通过分析项目文件自动推断信息，减少用户输入负担。\n\n#### a. 检测项目类型\n\n使用 Read 工具检查项目配置文件：\n\n**Node.js/TypeScript 项目检测**:\n```bash\n检测文件: package.json\n提取信息:\n  - 项目名称: name 字段\n  - 项目描述: description 字段\n  - 语言: 检查 devDependencies 中是否有 typescript\n  - 框架: 从 dependencies 推断\n    - \"next\" → Next.js\n    - \"react\" → React\n    - \"vue\" → Vue\n    - \"express\" → Express\n    - \"nestjs\" → NestJS\n  - 测试框架: 从 devDependencies 推断 (jest, vitest, mocha 等)\n  - 代码风格: 检查 eslintConfig, prettier 配置\n```\n\n**Go 项目检测**:\n```bash\n检测文件: go.mod\n提取信息:\n  - 项目名称: module 声明\n  - 语言版本: go 版本行\n  - 框架: 从 require 推断\n    - \"gin-gonic/gin\" → Gin\n    - \"labstack/echo\" → Echo\n    - \"gofiber/fiber\" → Fiber\n\n检测文件: go.sum (确认依赖)\n```\n\n**Python 项目检测**:\n```bash\n检测文件: pyproject.toml (优先) 或 requirements.txt 或 setup.py\n提取信息:\n  - 项目名称: [project].name 或从目录名推断\n  - 语言版本: requires-python 字段\n  - 框架: 从依赖推断\n    - \"fastapi\" → FastAPI\n    - \"django\" → Django\n    - \"flask\" → Flask\n  - 测试框架: pytest, unittest 等\n```\n\n**Java 项目检测**:\n```bash\n检测文件: pom.xml 或 build.gradle\n提取信息:\n  - 项目名称: artifactId 或 name\n  - 语言版本: Java version\n  - 框架: 从依赖推断\n    - \"spring-boot\" → Spring Boot\n    - \"micronaut\" → Micronaut\n    - \"quarkus\" → Quarkus\n```\n\n#### b. 分析项目结构\n\n使用 Glob 工具列举项目目录，推断架构模式：\n\n```bash\n# 检测顶层目录\n检测路径:\n  - src/, lib/, pkg/ (源代码目录)\n  - test/, tests/, __tests__/ (测试目录)\n  - docs/ (文档目录)\n\n架构模式推断:\n  - 存在 src/controllers, src/services, src/models → 分层架构（MVC）\n  - 存在 src/api, src/service, src/logic, src/data → 分层架构（四层）\n  - 存在 packages/, services/, apps/ → 微服务架构\n  - 存在 functions/, lambda/ → Serverless\n  - 否则 → 单体应用\n```\n\n#### c. 分析代码风格\n\n使用 Read 工具读取几个代码文件样本：\n\n```bash\n# 读取 2-3 个代码文件\n# 分析变量命名模式\n\n命名规范检测:\n  - 检测变量/函数名中的模式\n  - camelCase: 首字母小写 (userName, getUserData)\n  - PascalCase: 首字母大写 (UserName, GetUserData)\n  - snake_case: 下划线连接 (user_name, get_user_data)\n\nLint 配置检测:\n  - .eslintrc.* (JavaScript/TypeScript)\n  - .golangci.yml (Go)\n  - .flake8, pyproject.toml (Python)\n  - checkstyle.xml (Java)\n```\n\n#### d. 分析数据存储\n\n使用 Grep 工具搜索数据库相关导入和配置：\n\n```bash\n# 搜索数据库导入语句\n关键词:\n  - \"mysql\", \"pg\", \"postgres\" → PostgreSQL/MySQL\n  - \"mongodb\", \"mongo\" → MongoDB\n  - \"redis\" → Redis\n  - \"elasticsearch\", \"es\" → Elasticsearch\n\n# 搜索配置文件\n检查:\n  - docker-compose.yml (服务定义)\n  - .env.example (环境变量示例)\n  - config/ 目录下的配置文件\n```\n\n#### e. 检测测试配置\n\n```bash\n检测测试目录:\n  - test/, tests/, __tests__/ 是否存在\n  - 测试文件数量和覆盖情况\n\n检测测试配置:\n  - jest.config.js, vitest.config.ts (JS/TS)\n  - go.mod 中的测试依赖\n  - pytest.ini, tox.ini (Python)\n  - pom.xml 中的测试配置 (Java)\n\n推断测试要求:\n  - 存在完善测试配置 + 多个测试文件 → 建议 >80%\n  - 存在基础测试 → 建议 >60%\n  - 无测试 → 不强制要求\n```\n\n#### f. 记录推断结果\n\n创建推断结果数据结构,记录每项信息的值和置信度:\n\n```javascript\n分析结果 = {\n  projectName: {\n    value: \"从配置文件读取的名称\",\n    source: \"package.json\",\n    confidence: \"high\"  // high: 确定 | medium: 较确定 | low: 需确认 | none: 未检测到\n  },\n  projectDescription: {\n    value: \"从配置文件读取的描述\",\n    source: \"package.json\",\n    confidence: \"medium\"  // 描述可能不准确,建议用户确认\n  },\n  language: {\n    value: \"TypeScript 5.0+\",\n    source: \"package.json devDependencies\",\n    confidence: \"high\"\n  },\n  framework: {\n    value: \"Next.js\",\n    source: \"package.json dependencies\",\n    confidence: \"high\"\n  },\n  storage: {\n    value: [\"PostgreSQL\", \"Redis\"],\n    source: \"grep 搜索和 docker-compose.yml\",\n    confidence: \"medium\"\n  },\n  architecture: {\n    value: \"分层架构\",\n    source: \"目录结构分析\",\n    confidence: \"medium\"\n  },\n  namingStyle: {\n    value: \"驼峰命名（camelCase）\",\n    source: \"代码文件分析\",\n    confidence: \"high\"\n  },\n  testCoverage: {\n    value: \">80%\",\n    source: \"测试配置和文件检测\",\n    confidence: \"medium\"\n  },\n  gitApproval: {\n    value: null,  // 这个需要用户决策\n    source: null,\n    confidence: \"none\"\n  }\n}\n```\n\n#### g. 输出分析结果\n\n输出分析摘要供用户查看:\n\n```\n🔍 项目分析完成！\n\n📊 自动检测结果:\n✅ 项目类型: TypeScript 项目 (来源: package.json)\n✅ 项目名称: my-app (来源: package.json)\n✅ 开发语言: TypeScript 5.0+ (来源: package.json)\n✅ 主要框架: Next.js (来源: dependencies)\n✅ 数据存储: PostgreSQL, Redis (来源: docker-compose.yml)\n✅ 架构模式: 分层架构 (来源: 目录结构)\n✅ 命名规范: 驼峰命名 (来源: 代码分析)\n⚠️  测试要求: 建议 >80% (来源: 测试配置)\n\n❓ 需要您确认的信息:\n- 项目描述 (自动检测可能不准确)\n- Git 提交流程 (需要您的决策)\n```\n\n### 2.5 分析子项目（Monorepo 场景）\n\n**仅在步骤 1.5 检测到 Monorepo 时执行此步骤**\n\n#### a. 遍历子项目\n\n对 MonorepoDetection.subProjectPaths 中的每个子项目路径执行分析：\n\n```bash\n对于每个子项目路径 (例如 \"frontend/\", \"backend/\"):\n  1. 进入子项目目录上下文（相对路径）\n\n  2. 检测项目类型（重复步骤 2.a 的逻辑，但在子目录中）\n     - 读取 [子项目路径]/package.json\n     - 读取 [子项目路径]/go.mod\n     - 读取 [子项目路径]/pyproject.toml\n     - 读取 [子项目路径]/pom.xml\n     - ... 其他配置文件\n\n  3. 提取项目信息（重复步骤 2.a 的逻辑）\n     - 项目名称\n     - 项目描述\n     - 语言和框架\n     - 测试框架\n     - 代码风格\n\n  4. 分析项目结构（重复步骤 2.b 的逻辑）\n     - 使用 Glob 列举子项目的子目录\n     - 推断子项目的架构模式\n\n  5. 分析代码风格（重复步骤 2.c 的逻辑）\n     - 读取子项目中的代码文件样本\n\n  6. 分析数据存储（重复步骤 2.d 的逻辑）\n     - 搜索数据库相关导入\n     - 检查子项目的配置文件\n\n  7. 检测测试配置（重复步骤 2.e 的逻辑）\n     - 检测子项目的测试目录\n     - 检测子项目的测试配置\n```\n\n#### b. 汇总子项目分析结果\n\n创建子项目分析结果数据结构：\n\n```javascript\nSubProjectsAnalysis = [\n  {\n    path: \"frontend/\",\n    projectName: {\n      value: \"Web Frontend\",\n      source: \"frontend/package.json\",\n      confidence: \"high\"\n    },\n    projectDescription: {\n      value: \"用户界面应用\",\n      source: \"frontend/package.json\",\n      confidence: \"medium\"\n    },\n    language: {\n      value: \"TypeScript 5.0+\",\n      source: \"frontend/package.json\",\n      confidence: \"high\"\n    },\n    framework: {\n      value: \"Next.js 14\",\n      source: \"frontend/package.json dependencies\",\n      confidence: \"high\"\n    },\n    architecture: {\n      value: \"组件化架构\",\n      source: \"目录结构分析\",\n      confidence: \"medium\"\n    },\n    namingStyle: {\n      value: \"驼峰命名 (camelCase)\",\n      source: \"代码分析\",\n      confidence: \"high\"\n    },\n    storage: {\n      value: null,\n      source: null,\n      confidence: \"none\"  // 前端通常不直接访问数据库\n    },\n    testCoverage: {\n      value: \">80%\",\n      source: \"测试配置\",\n      confidence: \"medium\"\n    }\n  },\n  {\n    path: \"backend/\",\n    projectName: {\n      value: \"API Server\",\n      source: \"backend/go.mod\",\n      confidence: \"high\"\n    },\n    projectDescription: {\n      value: \"RESTful API 服务\",\n      source: \"推断\",\n      confidence: \"low\"\n    },\n    language: {\n      value: \"Go 1.21+\",\n      source: \"backend/go.mod\",\n      confidence: \"high\"\n    },\n    framework: {\n      value: \"Gin\",\n      source: \"backend/go.mod require\",\n      confidence: \"high\"\n    },\n    architecture: {\n      value: \"分层架构\",\n      source: \"目录结构分析\",\n      confidence: \"medium\"\n    },\n    namingStyle: {\n      value: \"驼峰命名 (camelCase)\",\n      source: \"代码分析\",\n      confidence: \"high\"\n    },\n    storage: {\n      value: [\"PostgreSQL\", \"Redis\"],\n      source: \"grep 搜索和配置文件\",\n      confidence: \"medium\"\n    },\n    testCoverage: {\n      value: \">80%\",\n      source: \"测试配置\",\n      confidence: \"medium\"\n    }\n  }\n  // ... 其他子项目\n]\n```\n\n#### c. 推断项目间关系\n\n基于子项目类型和配置，推断项目间的关系：\n\n```javascript\nProjectRelations = [\n  {\n    from: \"frontend/\",\n    to: \"backend/\",\n    relation: \"API 调用\",\n    confidence: \"high\",  // 基于前端是 web 应用，后端是 API 服务\n    description: \"前端通过 HTTP API 调用后端服务\"\n  }\n  // 可以根据配置文件中的 API 地址等信息进一步确认\n]\n```\n\n#### d. 限制子项目数量\n\n为了保证性能和可维护性：\n\n```bash\n如果检测到的子项目数量 > 10:\n  使用 AskUserQuestion 让用户选择：\n    question: \"检测到 [数量] 个子项目，数量较多。您希望如何处理？\"\n    header: \"子项目数量\"\n    multiSelect: false\n    options:\n      - label: \"分析前 10 个子项目\"\n        description: \"只分析最重要的 10 个子项目\"\n      - label: \"让我手动选择\"\n        description: \"展示所有子项目，让我选择要分析的\"\n      - label: \"全部分析（不推荐）\"\n        description: \"可能需要较长时间\"\n```\n\n#### e. 输出子项目分析摘要\n\n```\n📦 Monorepo 子项目分析完成！\n\n共检测到 [数量] 个子项目:\n\n📂 frontend/ - Web Frontend\n  ✅ 语言: TypeScript 5.0+\n  ✅ 框架: Next.js 14\n  ✅ 架构: 组件化架构\n\n📂 backend/ - API Server\n  ✅ 语言: Go 1.21+\n  ✅ 框架: Gin\n  ✅ 架构: 分层架构\n  ✅ 数据: PostgreSQL, Redis\n\n🔗 项目关系:\n  frontend/ → backend/ (API 调用)\n```\n\n### 2.6 检测可用 Skills\n\n**目标**: 检测当前环境中可用的 Skills，用于生成适配的 CLAUDE.md\n\n#### a. 获取可用 Skills 列表\n\n从系统提供的 `<available_skills>` 标签中提取当前可用的技能列表：\n\n```javascript\nAvailableSkills = [\n  {\n    name: \"skill-name\",           // 技能名称\n    description: \"技能描述\",       // 技能功能描述\n    location: \"user/plugin\"       // 技能来源\n  }\n  // ... 其他技能\n]\n```\n\n#### b. 分类 Skills\n\n根据技能描述将其分类：\n\n```javascript\nSkillCategories = {\n  design: [],        // 设计类技能（canvas-design, frontend-design 等）\n  document: [],      // 文档处理类技能（xlsx, docx, pptx, pdf 等）\n  data: [],          // 数据分析类技能\n  visualization: [], // 可视化类技能\n  other: []          // 其他技能\n}\n```\n\n分类规则：\n- 包含 \"design\"、\"visual\"、\"UI\"、\"界面\" → design\n- 包含 \"xlsx\"、\"docx\"、\"pptx\"、\"pdf\"、\"document\"、\"文档\" → document\n- 包含 \"data\"、\"分析\"、\"analysis\" → data\n- 包含 \"chart\"、\"图表\"、\"可视化\" → visualization\n- 其他 → other\n\n#### c. 记录 Skills 检测结果\n\n```javascript\nSkillsDetection = {\n  available: true/false,          // 是否有可用技能\n  count: N,                       // 可用技能数量\n  skills: AvailableSkills,        // 完整技能列表\n  categories: SkillCategories,    // 分类后的技能\n  forTemplate: [                  // 用于模板生成的技能信息\n    {\n      category: \"设计阶段\",\n      skills: [\"canvas-design - 创建视觉设计\", \"frontend-design - 前端界面开发\"]\n    },\n    {\n      category: \"文档处理\",\n      skills: [\"xlsx - 电子表格处理\", \"docx - 文档编辑\", \"pdf - PDF处理\"]\n    }\n  ]\n}\n```\n\n#### d. 输出检测结果\n\n```\n🔧 Skills 检测完成！\n\n📊 检测结果:\n✅ 可用技能数量: [数量] 个\n\n📋 技能分类:\n  🎨 设计类: [数量] 个\n  📄 文档类: [数量] 个\n  📊 数据类: [数量] 个\n  📈 可视化: [数量] 个\n  🔧 其他: [数量] 个\n\n💡 这些技能将被写入 CLAUDE.md 的 Skills 使用规范中\n```\n\n---\n\n### 3. 智能信息收集\n\n根据项目分析结果,**只对置信度低或无法推断的信息进行询问**。\n\n#### 询问策略:\n\n**A. confidence = \"high\" 的信息**:\n- ✅ 直接使用,不询问\n- 在最终确认时展示给用户\n\n**B. confidence = \"medium\" 的信息**:\n- ⚠️ 作为推荐选项,但仍询问用户确认\n- 在选项中标注 \"(已检测)\"\n\n**C. confidence = \"low\" 或 \"none\" 的信息**:\n- ❌ 必须询问用户\n- 提供常见选项供选择\n\n#### 询问示例:\n\n**场景 1: 项目名称 confidence=\"high\"**\n```\n不询问,直接使用检测到的值\n```\n\n**场景 2: 项目描述 confidence=\"medium\"**\n```yaml\n使用 AskUserQuestion:\n  question: \"请确认项目描述：\"\n  header: \"项目描述\"\n  multiSelect: false\n  options:\n    - label: \"使用检测到的描述 (已检测)\"\n      description: \"Web application for user management\"\n    - label: \"Web 应用后端服务\"\n      description: \"提供 RESTful API 的后端服务\"\n    - Other: 自定义描述\n```\n\n**场景 3: 数据存储 confidence=\"medium\"**\n```yaml\n使用 AskUserQuestion:\n  question: \"请确认项目使用的数据存储技术（可多选）：\"\n  header: \"数据存储\"\n  multiSelect: true\n  options:\n    - label: \"PostgreSQL (已检测)\"\n      description: \"关系型数据库\"\n    - label: \"Redis (已检测)\"\n      description: \"缓存系统\"\n    - label: \"MySQL\"\n      description: \"关系型数据库\"\n    - Other: 其他存储技术\n```\n\n**场景 4: Git 提交流程 confidence=\"none\"**\n```yaml\n使用 AskUserQuestion:\n  question: \"Git 提交是否需要审批确认？\"\n  header: \"提交规范\"\n  multiSelect: false\n  options:\n    - label: \"需要（使用 AskUserQuestion）\"\n      description: \"提交前必须询问用户确认\"\n    - label: \"不需要\"\n      description: \"允许直接提交\"\n```\n\n#### 分批询问流程:\n\n根据实际需要询问的问题数量,灵活分批:\n\n**如果需要询问 0-2 个问题**: 一次性询问\n**如果需要询问 3-5 个问题**: 分 2 批询问\n**如果需要询问 6+ 个问题**: 分 3-4 批询问\n\n**优先级排序**:\n1. 高优先级: 项目描述、架构模式 (影响模板填充)\n2. 中优先级: 数据存储、命名规范 (可能影响规范细节)\n3. 低优先级: 测试要求、Git 提交规范 (配置项)\n\n#### Monorepo 策略询问（仅 Monorepo 场景）:\n\n**仅在步骤 1.5 检测到 Monorepo 时执行**\n\n在完成常规信息收集后，询问用户如何生成 CLAUDE.md：\n\n```yaml\n使用 AskUserQuestion:\n  question: \"检测到这是一个 Monorepo 项目，包含 [数量] 个子项目。您希望如何生成 CLAUDE.md？\"\n  header: \"Monorepo 策略\"\n  multiSelect: false\n  options:\n    - label: \"只在根目录生成统一的 CLAUDE.md（推荐）\"\n      description: \"生成一个包含所有子项目信息的统一规范文件，便于整体管理\"\n    - label: \"为每个子项目生成独立的 CLAUDE.md\"\n      description: \"在根目录和每个子项目目录都生成独立的 CLAUDE.md，便于各自开发\"\n    - label: \"仅为根目录生成，忽略子项目\"\n      description: \"按照单项目模式生成，不体现子项目信息\"\n```\n\n记录用户选择：\n- 选项 1 → userStrategy = \"unified\"\n- 选项 2 → userStrategy = \"separate\"\n- 选项 3 → userStrategy = \"ignore\"\n\n### 4. 生成 CLAUDE.md\n\n根据分析结果和用户确认的信息，执行以下步骤：\n\n**判断项目类型**:\n- 如果是单项目 或 userStrategy = \"ignore\" → 使用**单项目模板**\n- 如果是 Monorepo 且 userStrategy = \"unified\" → 使用**Monorepo 统一模板**\n- 如果是 Monorepo 且 userStrategy = \"separate\" → 使用**Monorepo 统一模板 + 子项目模板**\n\n#### 4.0 Skills 适配（所有场景）\n\n**在填充模板前，根据步骤 2.6 检测到的 Skills 生成动态的 Skills 使用规范**：\n\na. 如果 SkillsDetection.available = true（有可用技能）：\n\n生成具体的 Skills 使用规范内容：\n\n```markdown\n### Skills 技能使用规范（强制）\n\nSkills 是可扩展的专业能力模块，**必须**根据场景强制使用对应技能。\n\n#### 强制使用场景映射表\n\n| 触发场景 | 关键词识别 | 必须使用的技能 |\n|---------|-----------|--------------|\n{根据 SkillsDetection.forTemplate 动态生成场景映射}\n{遍历每个技能，生成对应的触发场景行}\n\n**场景映射生成规则**：\n- 架构设计类技能 → 触发场景: 架构设计 | 关键词: 架构、设计方案、技术选型、系统设计\n- 可视化类技能 → 触发场景: 可视化图表 | 关键词: 架构图、流程图、时序图、画图\n- 文档处理类技能(docx) → 触发场景: 正式文档 | 关键词: Word文档、正式报告\n- 文档处理类技能(pptx) → 触发场景: 演示汇报 | 关键词: PPT、演示文稿\n- 文档处理类技能(xlsx) → 触发场景: 数据分析 | 关键词: 对比表格、Excel\n- 文档处理类技能(pdf) → 触发场景: PDF处理 | 关键词: PDF导出、PDF生成\n- 前端设计类技能 → 触发场景: UI/界面设计 | 关键词: 界面设计、UI原型\n\n#### 强制触发规则\n\n**以下场景必须调用对应技能，禁止跳过**：\n\n{根据检测到的技能分类，动态生成触发规则}\n\n1. **[场景类型]**（触发 `[skill-name]`）\n   - [根据技能描述生成具体触发条件]\n   - 用户提及\"[关键词]\"\n\n#### 技能调用检查清单\n\n在完成任务前，必须检查：\n- [ ] 是否识别到上述强制触发场景？\n- [ ] 是否已调用对应的必需技能？\n- [ ] 如未调用，是否有合理理由？（需向用户说明）\n\n#### 禁止行为\n\n- ❌ **禁止**在强制场景下不调用对应技能\n- ❌ **禁止**用文字描述替代可视化输出（有可视化技能时）\n- ❌ **禁止**跳过专业技能直接输出低质量结果\n\n#### 技能调用语法\n\n```\n使用 Skill 工具，参数 skill 设置为技能名称：\n{遍历所有可用技能，列出技能名称}\n- [skill-name-1]\n- [skill-name-2]\n...\n```\n\n#### 动态技能发现流程\n\n1. **识别任务类型**：分析用户需求，判断是否需要专业技能支持\n2. **查看可用技能**：通过系统提供的 `<available_skills>` 列表确认当前可用的技能\n3. **匹配场景映射**：根据上表的场景映射，确定必须调用的技能\n4. **调用技能**：使用 `Skill` 工具调用对应技能\n```\n\nb. 如果 SkillsDetection.available = false（无可用技能）：\n\n生成简化的 Skills 使用规范：\n\n```markdown\n### Skills 技能使用规范（强制）\n\nSkills 是可扩展的专业能力模块，**必须**根据场景强制使用对应技能。\n\n**当前状态**：当前环境未检测到可用的 Skills。\n\n如需使用 Skills 功能，请通过以下方式添加：\n1. 在 `.claude/skills/` 目录下添加自定义技能\n2. 安装支持 Skills 的插件\n\n#### 动态技能发现流程\n\n1. **查看可用技能**：通过系统提供的 `<available_skills>` 列表确认当前可用的技能\n2. **匹配场景映射**：根据技能类型确定触发场景\n3. **调用技能**：使用 `Skill` 工具调用对应技能\n\n**Skills 使用原则**：\n- **强制调用**: 识别到匹配场景时，必须调用对应技能\n- **禁止跳过**: 不得在强制场景下跳过技能调用\n```\n\nc. 用生成的 Skills 使用规范内容替换模板中的 `### Skills 技能使用规范（强制）` 整个章节\n\n#### 4.1 单项目场景\n\na. 从\"内置模板\"部分提取**单项目模板**内容（```template 和 ``` 之间的内容）\n\nb. 创建变量映射表并进行字符串替换：\n   - `[项目名称]` → 分析结果中的项目名称（或用户输入）\n   - `[项目一句话描述]` → 分析结果中的项目描述（或用户输入）\n   - `[框架名称和版本]` → 分析结果中的框架（或用户选择）\n   - `[数据库/缓存技术]` → 分析结果中的数据存储（多个则用逗号连接）\n   - `[语言和版本]` → 分析结果中的开发语言（或用户选择）\n   - `[命名规范]` → 分析结果中的代码风格（或用户选择）\n\nc. 添加生成时间戳：\n   - 使用 Bash date 命令获取当前日期\n   - 替换模板最后的 `[日期]` 为实际日期（格式：YYYY-MM-DD）\n\nd. 根据分析结果和用户配置，调整对应章节：\n   - 如果测试覆盖率选择\"不强制要求\"，修改\"测试规范\"章节，删除覆盖率要求\n   - 如果 Git 提交选择\"不需要\"审批，修改\"版本控制\"规则，移除 AskUserQuestion 要求\n\n#### 4.2 Monorepo 场景（unified 或 separate）\n\na. 从\"内置模板\"部分提取**Monorepo 模板**内容（```monorepo-template 和 ``` 之间的内容）\n\nb. 创建根项目变量映射并替换：\n   - `[项目名称]` → 根项目名称\n   - `[项目一句话描述]` → 根项目描述\n   - `[Monorepo类型]` → 检测到的类型（如 \"前后端分离\"、\"多服务架构\"等）\n   - `[子项目数量]` → SubProjectsAnalysis 的长度\n\nc. 生成子项目信息部分：\n\n```markdown\n### 项目架构（Monorepo）\n\n**项目类型**: Monorepo ([Monorepo类型])\n\n**整体架构**:\n```\nMonorepo 根目录\n├── [子项目1路径] - [子项目1名称] ([技术栈])\n├── [子项目2路径] - [子项目2名称] ([技术栈])\n└── [子项目N路径] - [子项目N名称] ([技术栈])\n```\n\n**子项目详情**:\n\n#### [子项目1名称] (`[子项目1路径]`)\n- **技术栈**: [框架] + [语言]\n- **职责**: [从描述推断或用户提供]\n- **主要目录**: [从分析结果提取]\n- **数据存储**: [如果有]\n- **架构模式**: [分析结果]\n\n#### [子项目2名称] (`[子项目2路径]`)\n...\n\n**项目间关系**:\n[根据 ProjectRelations 生成]\n- [子项目1] → [子项目2]: [关系描述]\n```\n\nd. 生成核心技术栈部分（汇总所有子项目）：\n\n```markdown\n### 核心技术栈\n\n**整体技术栈**:\n- **语言**: [去重后的所有语言]\n- **框架**: [去重后的所有框架]\n- **数据存储**: [去重后的所有数据存储]\n- **代码风格**: [统一或列举差异]\n```\n\ne. 添加生成时间戳\n\nf. 调整开发规范章节：\n   - 保留通用的开发规范\n   - 在必要时添加子项目特定的说明\n\n#### 4.3 Monorepo separate 场景（额外步骤）\n\n如果 userStrategy = \"separate\"，为每个子项目生成独立的 CLAUDE.md：\n\n对于每个子项目：\n  1. 使用单项目模板\n  2. 填充该子项目的分析数据\n  3. 添加\"父项目引用\"章节：\n     ```markdown\n     ## 父项目\n\n     本项目是 [根项目名称] Monorepo 的一部分。\n\n     **位置**: `[子项目路径]`\n     **其他子项目**: [列出其他子项目]\n\n     完整项目规范请参考根目录的 CLAUDE.md。\n     ```\n  4. 记录要写入的文件路径：[子项目路径]/CLAUDE.md\n\n### 5. 文件写入\n\n#### 5.1 备份现有文件（如需要）\n\na. 如果用户在步骤 1 中选择了\"备份后覆盖\"：\n   - 使用 Bash date 命令生成时间戳（格式：YYYYMMDDHHmmss）\n   - 使用 Read 工具读取现有的 CLAUDE.md\n   - 使用 Write 工具将内容写入 CLAUDE.md.backup-{timestamp}\n   - 输出备份成功信息\n\n#### 5.2 写入根目录 CLAUDE.md\n\nb. 使用 Write 工具将生成的内容写入 ./CLAUDE.md 文件\n\n#### 5.3 写入子项目 CLAUDE.md（仅 separate 场景）\n\n如果 userStrategy = \"separate\"：\n  - 对每个子项目路径\n  - 使用 Write 工具将子项目的 CLAUDE.md 写入 [子项目路径]/CLAUDE.md\n  - 输出每个文件的写入成功信息\n\n### 6. 确认完成\n\n输出成功信息，展示完整的配置信息：\n\n#### 6.1 单项目场景\n\n```\n✅ 项目规范文件生成成功！\n\n📄 文件位置: ./CLAUDE.md\n📅 生成时间: {当前时间}\n\n📊 项目配置摘要:\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n✅ 项目名称: {项目名称}\n✅ 项目描述: {项目描述}\n✅ 开发语言: {语言和版本}\n✅ 主要框架: {框架}\n✅ 数据存储: {数据存储技术}\n✅ 架构模式: {架构模式}\n✅ 命名规范: {命名规范}\n✅ 测试要求: {测试覆盖率}\n✅ Git 提交: {是否需要审批}\n\n🎯 自动检测项数: {检测成功的项数}/{总项数}\n\n💡 下一步操作:\n1. 查看生成的 CLAUDE.md 文件\n2. 根据项目实际情况调整细节\n3. 提交到版本控制系统\n\n🤖 Generated with Claude Code\n```\n\n#### 6.2 Monorepo 场景（unified）\n\n```\n✅ Monorepo 项目规范文件生成成功！\n\n📄 文件位置: ./CLAUDE.md\n📅 生成时间: {当前时间}\n\n📦 Monorepo 信息:\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n🏗️  项目类型: Monorepo ({Monorepo类型})\n📂 子项目数: {子项目数量}\n\n📊 子项目摘要:\n{对每个子项目}\n  📂 {子项目路径} - {子项目名称}\n     ✅ 语言: {语言}\n     ✅ 框架: {框架}\n     ✅ 架构: {架构模式}\n\n🔗 项目关系:\n  {项目间关系列表}\n\n🎯 自动检测项数: {检测成功的项数}/{总项数}\n\n💡 下一步操作:\n1. 查看生成的 CLAUDE.md 文件\n2. 根据各子项目实际情况调整细节\n3. 提交到版本控制系统\n\n🤖 Generated with Claude Code\n```\n\n#### 6.3 Monorepo 场景（separate）\n\n```\n✅ Monorepo 项目规范文件生成成功！\n\n📄 生成的文件:\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n  📄 ./CLAUDE.md (根目录统一规范)\n  📄 {子项目1路径}/CLAUDE.md\n  📄 {子项目2路径}/CLAUDE.md\n  ...\n\n📅 生成时间: {当前时间}\n\n📦 Monorepo 信息:\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n🏗️  项目类型: Monorepo ({Monorepo类型})\n📂 子项目数: {子项目数量}\n\n📊 子项目摘要:\n{对每个子项目}\n  📂 {子项目路径} - {子项目名称}\n     ✅ 语言: {语言}\n     ✅ 框架: {框架}\n     ✅ 架构: {架构模式}\n     ✅ 独立规范: {子项目路径}/CLAUDE.md\n\n🎯 自动检测项数: {检测成功的项数}/{总项数}\n\n💡 下一步操作:\n1. 查看根目录的 CLAUDE.md（整体规范）\n2. 查看各子项目的 CLAUDE.md（特定规范）\n3. 根据实际情况调整细节\n4. 提交到版本控制系统\n\n🤖 Generated with Claude Code\n```\n\n---\n\n## 跨平台兼容性说明\n\n此命令已优化为完全跨平台兼容：\n\n### ✅ 跨平台特性\n\n1. **内置模板** - 不需要读取外部文件，避免路径问题\n2. **Claude Code 工具** - 仅使用跨平台的内置工具\n   - Read/Write: 文件读写\n   - Glob: 文件查找（跨平台模式匹配）\n   - Grep: 内容搜索（跨平台正则表达式）\n   - AskUserQuestion: 用户交互\n   - Bash date: 时间戳生成（Windows/Mac/Linux 均支持）\n3. **最小依赖** - 仅依赖标准工具，无需额外安装\n4. **相对路径** - 使用 `./CLAUDE.md` 相对路径，适配所有系统\n\n### 🖥️ 系统支持\n\n- ✅ **Windows**: 完全支持（包括 CMD 和 PowerShell）\n- ✅ **macOS**: 完全支持\n- ✅ **Linux**: 完全支持\n- ✅ **WSL**: 完全支持\n\n### 📝 核心改进\n\n1. **智能分析优先**：\n   - 自动检测项目配置文件（package.json, go.mod, pyproject.toml 等）\n   - 智能推断技术栈、架构模式、代码风格\n   - 减少用户输入负担，提升体验\n\n2. **数据驱动决策**：\n   - 基于实际项目数据进行推断\n   - 避免猜测和假设\n   - 置信度评估确保准确性\n\n3. **按需询问**：\n   - 只对无法确定的信息询问用户\n   - 提供检测到的值作为推荐选项\n   - 灵活的分批询问策略\n\n4. **错误处理**：\n   - 文件读写失败时，提供清晰的错误信息\n   - 权限不足时，建议用户检查目录权限\n   - 用户输入验证（避免空值）\n\n5. **灵活性**：\n   - 支持空项目（使用传统询问模式）\n   - 支持已有项目（智能分析模式）\n   - 允许用户覆盖自动检测的结果\n\n6. **向后兼容**：\n   - 备份机制确保不会丢失现有配置\n   - 提供清晰的操作提示和确认\n\n7. **遵循 KISS 原则**：\n   - 不进行过度验证\n   - 不添加不必要的功能\n   - 专注于核心任务：分析项目 → 收集信息 → 生成文件\n\n### 🎯 最佳实践\n\n**对于新项目（空目录）**:\n- 命令会检测到没有配置文件\n- 自动切换到询问模式\n- 引导用户完成所有配置\n\n**对于已有项目**:\n- 命令会自动分析项目文件\n- 提取尽可能多的信息\n- 只对不确定的信息进行询问\n- 展示分析结果供用户确认\n\n**最佳工作流程**:\n1. 在项目根目录运行命令\n2. 查看自动分析结果\n3. 确认或修改推断的信息\n4. 生成规范文件\n5. 根据实际需求微调细节"
              }
            ],
            "skills": []
          },
          {
            "name": "session-manager",
            "description": "智能保存和恢复 Claude Code 会话，支持进度跟踪、决策记录和工作连续性，采用项目本地存储和智能数据访问设计",
            "source": "./plugins/session-manager",
            "category": "productivity",
            "version": "1.0.0",
            "author": {
              "name": "Wang Xuecheng",
              "email": "ahut17353766123@gmail.com"
            },
            "install_commands": [
              "/plugin marketplace add ChamHerry/claude-code-third-party-plugins",
              "/plugin install session-manager@claude-code-third-party-plugins"
            ],
            "signals": {
              "stars": 49,
              "forks": 5,
              "pushed_at": "2025-11-28T10:53:08Z",
              "created_at": "2025-11-03T06:28:24Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/continue-session",
                "description": "搜索并继续之前保存的会话",
                "path": "plugins/session-manager/commands/continue-session.md",
                "frontmatter": {
                  "allowed-tools": "Read, Write, AskUserQuestion, Bash, Grep, Glob",
                  "description": "搜索并继续之前保存的会话"
                },
                "content": "智能搜索已保存的会话，支持按项目、时间、关键词过滤，选择后生成 Markdown 格式的会话摘要供在新会话中继续工作。\n\n**核心特性**:\n- 🔍 **智能搜索**: 支持按项目、时间范围、关键词搜索\n- 📋 **可视化列表**: 清晰展示会话信息（标题、时间、进度）\n- 📝 **完整导出**: 生成包含进度、方案、决策的 Markdown 文档\n- 💡 **行动建议**: 自动生成后续工作建议\n\n---\n\n## 执行步骤\n\n### 1. 扫描已保存的会话\n\na. 检查存储目录是否存在（项目本地）\n   ```bash\n   SUMMARY_BASE=\"./.claude-sessions/summaries\"\n\n   if [ ! -d \"$SUMMARY_BASE\" ]; then\n       echo \"❌ 错误：未找到已保存的会话\"\n       echo \"提示：使用 /session-manager:save 保存当前会话\"\n       echo \"📁 会话将保存在项目目录: ./.claude-sessions/\"\n       exit 1\n   fi\n   ```\n\nb. 查找所有摘要文件（项目本地）\n   ```bash\n   # 查找当前项目的所有会话摘要\n   find \"$SUMMARY_BASE\" -maxdepth 2 -name \"summary.json\" -type f\n   ```\n\nc. 读取并解析所有摘要文件\n   - 使用 Read 工具读取每个 summary.json\n   - 提取关键信息用于展示：\n     * 会话标题\n     * 项目名称\n     * 保存时间\n     * 进度信息（已完成/总数）\n     * 会话 ID 和存储路径\n\nd. 按保存时间排序（最新的在前）\n   ```bash\n   # 使用 Python 脚本读取和排序\n   python3 << 'EOF'\n   import json\n   import glob\n   import os\n   from datetime import datetime\n\n   summary_files = glob.glob(os.path.expanduser(\"~/.claude/session-summary/**/summary.json\"), recursive=True)\n\n   sessions = []\n   for file_path in summary_files:\n       with open(file_path, 'r', encoding='utf-8') as f:\n           data = json.load(f)\n           data['_file_path'] = file_path\n           sessions.append(data)\n\n   # 按 savedAt 时间排序\n   sessions.sort(key=lambda x: x.get('savedAt', ''), reverse=True)\n\n   # 输出 JSON\n   print(json.dumps(sessions, ensure_ascii=False))\n   EOF\n   ```\n\n### 2. 首次展示（最近 10 个）\n\na. 提取最近 10 个会话信息\n\nb. 格式化展示选项\n   ```\n   每个选项格式：\n   label: \"[时间] 项目名 - 会话标题\"\n   description: \"进度：X/Y 已完成 | 文件变更：Z 个\"\n   ```\n\nc. 使用 AskUserQuestion 展示列表\n   ```yaml\n   question: \"选择要继续的会话（显示最近 10 个）：\"\n   header: \"会话列表\"\n   multiSelect: false\n   options:\n     - label: \"🔍 搜索和过滤\"\n       description: \"按项目、时间或关键词搜索会话\"\n\n     - label: \"[2025-11-03 16:00] claude-code-init - 添加会话管理插件\"\n       description: \"进度：4/6 已完成 | 文件变更：3 个\"\n\n     - label: \"[2025-11-03 14:30] my-project - 实现用户认证\"\n       description: \"进度：5/8 已完成 | 文件变更：12 个\"\n\n     ... (最多 10 个)\n\n     - label: \"📚 查看更多...\"\n       description: \"显示更多会话（第 11-20 个）\"\n   ```\n\n### 3. 搜索和过滤功能\n\n#### 如果用户选择\"搜索和过滤\"\n\na. 提供搜索选项\n   ```yaml\n   使用 AskUserQuestion:\n     question: \"选择搜索条件：\"\n     header: \"搜索选项\"\n     multiSelect: false\n     options:\n       - label: \"按项目过滤\"\n         description: \"只显示特定项目的会话\"\n\n       - label: \"按时间范围\"\n         description: \"选择时间范围（今天、本周、本月、自定义）\"\n\n       - label: \"按关键词搜索\"\n         description: \"在标题和描述中搜索关键词\"\n\n       - label: \"返回会话列表\"\n         description: \"返回主列表\"\n   ```\n\n#### 场景 A: 按项目过滤\n\n1. 提取所有唯一的项目名称\n   ```python\n   projects = list(set(s['projectName'] for s in sessions))\n   projects.sort()\n   ```\n\n2. 展示项目列表供选择\n   ```yaml\n   question: \"选择项目：\"\n   header: \"项目过滤\"\n   multiSelect: false\n   options:\n     - label: \"项目名称 1\"\n       description: \"{该项目的会话数} 个会话\"\n     - label: \"项目名称 2\"\n       description: \"{该项目的会话数} 个会话\"\n     ...\n   ```\n\n3. 过滤并展示该项目的会话列表\n\n#### 场景 B: 按时间范围\n\n1. 提供时间范围选项\n   ```yaml\n   question: \"选择时间范围：\"\n   header: \"时间过滤\"\n   multiSelect: false\n   options:\n     - label: \"今天\"\n       description: \"只显示今天保存的会话\"\n\n     - label: \"本周\"\n       description: \"显示本周保存的会话\"\n\n     - label: \"本月\"\n       description: \"显示本月保存的会话\"\n\n     - label: \"最近 7 天\"\n       description: \"显示最近 7 天的会话\"\n\n     - label: \"最近 30 天\"\n       description: \"显示最近 30 天的会话\"\n   ```\n\n2. 根据选择过滤会话\n   ```python\n   from datetime import datetime, timedelta\n\n   now = datetime.now()\n\n   # 根据选择计算时间范围\n   if choice == \"今天\":\n       start = now.replace(hour=0, minute=0, second=0)\n   elif choice == \"本周\":\n       start = now - timedelta(days=now.weekday())\n   elif choice == \"本月\":\n       start = now.replace(day=1, hour=0, minute=0, second=0)\n   # ...\n\n   # 过滤会话\n   filtered = [s for s in sessions if datetime.fromisoformat(s['savedAt']) >= start]\n   ```\n\n3. 展示过滤后的会话列表\n\n#### 场景 C: 按关键词搜索\n\n1. 询问用户输入关键词\n   ```yaml\n   question: \"请输入搜索关键词：\"\n   header: \"关键词搜索\"\n   multiSelect: false\n   options:\n     - label: \"输入关键词\"\n       description: \"在标题、描述、关键词中搜索\"\n   ```\n\n2. 从用户输入中提取关键词（使用 Other 选项）\n\n3. 在会话数据中搜索\n   ```python\n   keyword = user_input.lower()\n\n   filtered = []\n   for session in sessions:\n       # 搜索标题\n       if keyword in session['overview']['title'].lower():\n           filtered.append(session)\n           continue\n\n       # 搜索描述\n       if keyword in session['overview'].get('description', '').lower():\n           filtered.append(session)\n           continue\n\n       # 搜索关键词列表\n       if any(keyword in kw.lower() for kw in session['overview'].get('keywords', [])):\n           filtered.append(session)\n           continue\n   ```\n\n4. 展示搜索结果\n   - 如果找到 0 个：提示未找到，返回主列表\n   - 如果找到 1-10 个：直接展示\n   - 如果找到 >10 个：展示前 10 个 + \"查看更多\"\n\n### 4. 用户选择会话\n\n#### 提取会话数据\n\n1. 根据用户选择，定位到对应的 summary.json\n\n2. 读取完整的摘要数据\n   ```bash\n   # 读取 summary.json\n   Read tool: {SESSION_DIR}/summary.json\n   ```\n\n3. 可选：读取详细日志（如果需要提取更多上下文）\n   ```bash\n   # 读取 details.jsonl（可选）\n   Read tool: {SESSION_DIR}/details.jsonl\n   ```\n\n### 5. 生成导出文件\n\n#### 创建导出目录（项目本地）\n```bash\nEXPORT_DIR=\"./.claude-sessions/exports\"\nmkdir -p \"$EXPORT_DIR\"\n\n# 生成文件名\nTIMESTAMP=$(date +\"%Y-%m-%d-%H-%M\")\nEXPORT_FILE=\"$EXPORT_DIR/${TIMESTAMP}-${SESSION_UUID}.md\"\n```\n\n#### 生成 Markdown 内容\n\n使用以下模板生成导出文件：\n\n```markdown\n# 会话恢复：{会话标题}\n\n> **会话 ID**: {uuid}\n> **项目**: {项目名称} (`{项目路径}`)\n> **会话时间**: {开始时间} - {结束时间}\n> **保存时间**: {保存时间}\n> **消息总数**: {消息数} ({用户消息数} 用户 + {AI消息数} 助手)\n\n---\n\n## 📋 工作概述\n\n{从 summary.json 提取的描述}\n\n**关键词**: {关键词1}, {关键词2}, {关键词3}\n\n---\n\n## 📈 项目进度\n\n### ✅ 已完成任务 ({已完成数量})\n\n{遍历 todos，筛选 status === \"completed\"}\n- [x] {任务1内容}\n- [x] {任务2内容}\n...\n\n### 🔄 进行中任务 ({进行中数量})\n\n{遍历 todos，筛选 status === \"in_progress\"}\n- [ ] {任务内容} - 🔄 {activeForm}\n\n### 📋 待办任务 ({待办数量})\n\n{遍历 todos，筛选 status === \"pending\"}\n- [ ] {任务内容}\n\n**进度总览**: {已完成}/{总数} 已完成 ({完成百分比}%)\n\n---\n\n## 📐 实施方案\n\n{如果 implementation.hasDesignDoc === true}\n\n**方案文档**: `{implementation.designDocPath}`\n\n### 主要变更点\n\n{遍历 implementation.mainChanges}\n1. {变更点1}\n2. {变更点2}\n...\n\n{如果没有方案文档}\n_本会话未包含正式的实施方案文档_\n\n---\n\n## 💡 关键决策\n\n{遍历 keyDecisions}\n\n### 决策 {序号} - {格式化时间}\n\n**问题**: {decision.question}\n\n**选择**: {decision.answer}\n\n{如果有多个选项，展示所有选项}\n_可选项_:\n- {选项1描述}\n- {选项2描述}\n...\n\n---\n{如果没有关键决策}\n_本会话未记录关键决策_\n\n---\n\n## 📂 文件变更记录\n\n{遍历 filesModified，按类型分组}\n\n### ✨ 已创建文件 ({创建文件数量})\n\n{筛选 operation === \"created\"}\n- `{相对路径1}` - {格式化时间}\n- `{相对路径2}` - {格式化时间}\n...\n\n### 📝 已修改文件 ({修改文件数量})\n\n{筛选 operation === \"modified\"}\n- `{相对路径1}` - {格式化时间}\n- `{相对路径2}` - {格式化时间}\n...\n\n### 🗑️ 已删除文件 ({删除文件数量})\n\n{筛选 operation === \"deleted\"}\n- `{相对路径1}` - {格式化时间}\n...\n\n{如果没有文件变更}\n_本会话未修改任何文件_\n\n---\n\n## 🎯 后续行动建议\n\n根据当前进度和待办任务，建议：\n\n{自动生成建议，基于：}\n1. 继续完成进行中的任务：\n   {如果有 in_progress 任务}\n   - {任务内容} - 当前状态：{activeForm}\n\n2. 开始下一个待办任务：\n   {取第一个 pending 任务}\n   - {任务内容}\n\n3. 验证已完成功能：\n   {基于已完成的任务生成验证建议}\n   - 测试 {相关功能}\n   - 验证 {相关文件} 的正确性\n\n4. 更新文档：\n   {如果有文档相关的待办}\n   - 完善 {文档名称}\n\n{如果所有任务都已完成}\n🎉 **恭喜！所有任务已完成！**\n\n建议：\n- 进行全面测试\n- 更新项目文档\n- 准备提交代码\n\n---\n\n## 📚 详细对话记录\n\n完整的对话记录已保存在：\n\n```\n{SESSION_DIR}/details.jsonl\n```\n\n如需查看完整上下文，可以：\n1. 使用文本编辑器打开上述文件\n2. 使用 `cat` 命令查看：`cat {SESSION_DIR}/details.jsonl`\n3. 使用 `jq` 格式化查看：`jq -r '.content' {SESSION_DIR}/details.jsonl`\n\n---\n\n<!--\n═══════════════════════════════════════════════════════════════\n🤖 FOR AI ASSISTANT ONLY - 仅供 AI 助手参考\n═══════════════════════════════════════════════════════════════\n\n本部分专门提供给 AI 助手，用户通常不需要查看此内容。\n\n## 📁 完整对话数据源\n\n**文件路径**: `{SESSION_DIR}/details.jsonl`\n\n**数据格式**: JSONL (每行一个 JSON 对象)\n\n**包含内容**:\n- 所有用户消息 (type: \"user\")\n- 所有 AI 响应 (type: \"assistant\")\n- 所有工具调用 (type: \"tool_use\")\n- 时间戳和元数据\n\n## 🎯 何时读取完整对话\n\n**建议读取的场景**:\n1. ✅ 用户要求了解详细的讨论过程\n2. ✅ 需要理解某个决策的完整背景\n3. ✅ 任务涉及之前讨论的具体技术细节\n4. ✅ 当前摘要信息不足以完成任务\n5. ✅ 需要验证之前的某个结论或约定\n\n**无需读取的场景**:\n1. ❌ 只需要了解当前进度状态\n2. ❌ 只需要知道下一步做什么\n3. ❌ 摘要信息已经足够清晰\n4. ❌ 任务是全新的，不依赖历史细节\n\n## 📖 如何读取\n\n使用 Read 工具读取完整文件：\n\n```\nRead tool: {SESSION_DIR}/details.jsonl\n```\n\n**注意事项**:\n- 文件可能较大 (50KB - 10MB)，建议只在必要时读取\n- 可以使用 Grep 工具搜索特定内容而非读取全部\n- 如果只需要某类消息，可以用 Python 过滤\n\n## 💡 智能决策建议\n\n**第一步**: 评估摘要信息是否充足\n- 如果摘要中的进度、决策、文件变更信息足够 → 直接使用摘要\n- 如果用户询问\"为什么这样决定\"、\"当时怎么讨论的\" → 读取完整对话\n\n**第二步**: 按需读取\n- 如果决定读取，使用 Read 工具读取 details.jsonl\n- 可以结合 Grep 搜索关键词，避免读取全部\n\n**第三步**: 向用户解释\n- 如果读取了完整对话，告知用户：\"我查看了完整的对话记录...\"\n- 这样用户知道你的决策基于完整信息\n\n═══════════════════════════════════════════════════════════════\nEND OF AI ASSISTANT SECTION\n═══════════════════════════════════════════════════════════════\n-->\n\n---\n\n## 🔗 如何继续工作\n\n### 方式 1：粘贴到新会话（推荐）\n\n1. 复制上述内容（从\"工作概述\"到\"后续行动建议\"）\n2. 在新 Claude Code 会话中粘贴\n3. 添加你的新请求，例如：\n   ```\n   继续之前的工作，{描述你要做什么}\n   ```\n\n### 方式 2：引用导出文件\n\n在新会话中输入：\n```\n@./.claude-sessions/exports/{timestamp}-{uuid}.md\n\n继续之前的工作，{描述你要做什么}\n```\n\n### 方式 3：手动选择性恢复\n\n只复制你需要的部分：\n- 如果只需要恢复进度：复制\"项目进度\"部分\n- 如果需要方案细节：复制\"实施方案\"部分\n- 如果需要决策上下文：复制\"关键决策\"部分\n\n---\n\n**导出时间**: {当前时间}\n**导出工具**: session-manager v1.0.0\n\n🤖 Generated by session-manager plugin\n```\n\n#### 写入导出文件\n\n```bash\n# 使用 Write 工具写入\nWrite tool: $EXPORT_FILE\n```\n\n### 6. 展示结果\n\n输出格式化的成功信息：\n\n```\n✅ 会话已成功导出！\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n📄 导出信息\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n会话标题: {标题}\n项目名称: {项目名}\n会话时间: {开始时间} - {结束时间}\n进度状态: {已完成}/{总数} 已完成\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n📁 文件位置（项目本地）\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n导出文件: ./.claude-sessions/exports/{timestamp}-{uuid}.md\n文件大小: {文件大小}\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n💡 如何继续工作\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n方式 1（推荐）: 在新会话中输入\n\n  继续之前的工作：{会话标题}\n\n  @~/.claude/session-exports/{timestamp}-{uuid}.md\n\n  {描述你要继续做的具体工作}\n\n方式 2: 打开导出文件并复制相关内容\n\n  cat ~/.claude/session-exports/{timestamp}-{uuid}.md\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n🎯 后续建议行动\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n{列出 2-3 个具体的后续行动建议}\n1. {建议1}\n2. {建议2}\n3. {建议3}\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n🤖 Generated by session-manager plugin\n```\n\n---\n\n## 错误处理\n\n### 场景 1: 没有已保存的会话\n\n```\n❌ 错误：未找到已保存的会话\n\n存储目录: ~/.claude/session-summary/\n\n可能原因：\n1. 还没有保存过任何会话\n2. 存储目录被删除或移动\n3. 权限问题导致无法访问\n\n建议：\n- 使用 /session-manager:save 保存当前会话\n- 检查存储目录是否存在：ls -la ~/.claude/session-summary/\n- 检查目录权限\n```\n\n### 场景 2: 摘要文件读取失败\n\n```\n❌ 错误：无法读取会话摘要文件\n\n文件: {文件路径}\n错误: {错误信息}\n\n可能原因：\n1. 文件已损坏\n2. 文件权限问题\n3. JSON 格式错误\n\n建议：\n- 尝试读取其他会话\n- 检查文件完整性：cat {文件路径}\n- 如果多个文件都无法读取，可能需要重新保存会话\n```\n\n### 场景 3: 搜索无结果\n\n```\nℹ️ 未找到匹配的会话\n\n搜索条件: {条件描述}\n\n建议：\n- 尝试使用不同的关键词\n- 检查时间范围是否过窄\n- 查看所有会话：选择\"返回会话列表\"\n```\n\n### 场景 4: 导出文件创建失败\n\n```\n❌ 错误：无法创建导出文件\n\n目标文件: {文件路径}\n错误: {错误信息}\n\n可能原因：\n1. 磁盘空间不足\n2. 导出目录不存在或无写入权限\n3. 文件名包含非法字符\n\n建议：\n- 检查磁盘空间：df -h\n- 创建导出目录：mkdir -p ~/.claude/session-exports\n- 检查目录权限：ls -ld ~/.claude/session-exports\n```\n\n---\n\n## 交互流程示例\n\n### 示例 1: 快速选择最近的会话\n\n```\n用户: /session-manager:continue\n\n系统: 显示最近 10 个会话列表\n\n用户: 选择第二个会话\n\n系统: ✅ 会话已成功导出！\n      导出文件: ~/.claude/session-exports/2025-11-03-16-30-abc123.md\n```\n\n### 示例 2: 按项目搜索\n\n```\n用户: /session-manager:continue\n\n系统: 显示最近 10 个会话列表\n\n用户: 选择\"搜索和过滤\"\n\n系统: 显示搜索选项\n\n用户: 选择\"按项目过滤\"\n\n系统: 显示所有项目列表\n      - my-app (3 个会话)\n      - another-project (5 个会话)\n\n用户: 选择\"my-app\"\n\n系统: 显示 my-app 的 3 个会话\n\n用户: 选择第一个\n\n系统: ✅ 会话已成功导出！\n```\n\n### 示例 3: 按关键词搜索\n\n```\n用户: /session-manager:continue\n\n系统: 显示最近 10 个会话列表\n\n用户: 选择\"搜索和过滤\"\n\n系统: 显示搜索选项\n\n用户: 选择\"按关键词搜索\"\n\n系统: 请输入搜索关键词\n\n用户: 输入\"认证\"（通过 Other 选项）\n\n系统: 找到 2 个匹配的会话\n      - [2025-11-03] my-app - 实现用户认证功能\n      - [2025-11-02] api-service - 添加 JWT 认证\n\n用户: 选择第一个\n\n系统: ✅ 会话已成功导出！\n```\n\n---\n\n## 跨平台兼容性\n\n### 路径处理\n- ✅ 使用 `$HOME` 而非 `~`\n- ✅ 使用绝对路径\n- ✅ 使用 `find` 命令递归搜索（标准工具）\n\n### JSON 处理\n- ✅ 优先使用 Python 3（系统自带）\n- ✅ 处理 UTF-8 编码\n- ✅ 使用 `ensure_ascii=False` 保留中文\n\n### 时间处理\n- ✅ 解析 ISO 8601 格式\n- ✅ 格式化为本地可读格式\n- ✅ 计算时间范围（今天、本周等）\n\n### 文件操作\n- ✅ 使用 `mkdir -p` 创建目录\n- ✅ 使用 `date` 生成时间戳\n- ✅ 使用 `cat` 展示文件内容\n\n---\n\n## 性能优化\n\n### 会话列表加载\n- 只读取 summary.json（不读取 details.jsonl）\n- 默认只展示最近 10 个（减少交互负担）\n- 按需加载更多（\"查看更多\"选项）\n\n### 搜索性能\n- 在内存中进行搜索（Python 脚本）\n- 不使用磁盘索引（保持简单）\n- 对于大量会话（>100），可能需要 2-3 秒\n\n### 导出文件生成\n- 一次性生成完整内容\n- 不进行额外的文件读取\n- 使用模板字符串拼接\n\n---\n\n## 使用技巧\n\n### 最佳实践\n\n1. **定期保存会话**\n   - 完成重要阶段后立即保存\n   - 结束工作前保存当天进度\n\n2. **使用清晰的标题**\n   - 第一条消息描述清楚要做什么\n   - 便于后续搜索和识别\n\n3. **利用搜索功能**\n   - 项目较多时，先按项目过滤\n   - 记不清时间时，使用关键词搜索\n\n4. **选择性恢复**\n   - 不一定要恢复全部内容\n   - 只复制需要的部分到新会话\n\n5. **保持存储整洁**\n   - 定期清理旧会话（手动）\n   - 备份重要会话\n\n### 高级用法\n\n**多项目管理**:\n```bash\n# 在不同项目间快速切换\ncd ~/project-a\n/session-manager:continue  # 恢复 project-a 的工作\n\ncd ~/project-b\n/session-manager:continue  # 恢复 project-b 的工作\n```\n\n**长期项目跟踪**:\n```bash\n# 每周五保存\n/session-manager:save\n\n# 下周一恢复，按时间过滤\"本周\"\n/session-manager:continue\n→ 选择\"按时间范围\" → \"本周\"\n```\n\n**任务切换**:\n```bash\n# 紧急任务插入时\n/session-manager:save  # 保存当前任务\n\n# 完成紧急任务后\n/session-manager:continue  # 恢复之前的任务\n```\n\n---\n\n## 注意事项\n\n- ⚠️ 搜索只在摘要数据中进行（不搜索详细日志）\n- ⚠️ 导出文件不会自动清理，需要手动管理\n- ⚠️ 大量会话（>50）时，列表加载可能稍慢\n- ⚠️ 导出文件可能包含敏感信息，注意安全\n\n---\n\n## 未来增强\n\n以下功能计划在未来版本中添加：\n\n- [ ] 会话标签功能\n- [ ] 会话笔记添加\n- [ ] 自动清理旧会话\n- [ ] 导出格式自定义\n- [ ] 会话对比功能\n- [ ] 团队共享支持\n\n---\n\n🤖 Generated with Claude Code"
              },
              {
                "name": "/save-session",
                "description": "总结并保存当前会话到本地存储",
                "path": "plugins/session-manager/commands/save-session.md",
                "frontmatter": {
                  "allowed-tools": "Read, Write, Bash, Grep, Glob",
                  "description": "总结并保存当前会话到本地存储"
                },
                "content": "智能分析当前会话内容，提取关键信息（项目进度、实施方案、关键决策、文件变更），并保存到分层存储结构中。\n\n**核心特性**:\n- 📊 **智能提取**: 自动识别 TodoWrite、AskUserQuestion、文件操作等关键信息\n- 💾 **分层存储**: 摘要文件 + 完整日志，兼顾查询效率和数据完整性\n- 🔍 **防失真**: 保留完整对话记录，避免压缩导致信息丢失\n- 🌐 **跨平台**: 完全兼容 Windows / macOS / Linux\n\n---\n\n## 执行步骤\n\n### 1. 定位当前会话文件\n\n找到 Claude Code 当前会话的 JSONL 文件。\n\n**位置**：`~/.claude/projects/` 目录下\n\n**匹配规则**：\n- 项目目录名包含当前工作目录的路径信息\n  - 例如：项目在 `/Users/user/my-project`\n  - 对应目录可能是：`-Users-user-my-project/`\n- 文件名格式：`{session-uuid}.jsonl`\n- 排除 `agent-` 开头的文件\n- 选择最新的文件（按修改时间）\n\n**如果找不到**：\n- 输出错误信息\n- 说明可能原因：\n  - 当前不在 Claude Code 会话中\n  - 会话数据已被清理\n  - 项目路径不匹配\n\n**提取信息**：\n- 会话文件的完整路径\n- 会话 UUID（文件名不含扩展名）\n\n### 2. 读取并解析会话数据\n\na. 使用 Read 工具读取整个 JSONL 文件\n   ```bash\n   # 读取会话文件\n   Read tool: $CURRENT_SESSION\n   ```\n\nb. 解析 JSONL 数据并提取关键信息\n   - 使用 Python 脚本处理 JSON 数据（跨平台兼容）\n   - 提取以下信息：\n     * 第一条用户消息（作为会话标题）\n     * 所有用户消息和 AI 响应\n     * TodoWrite 工具调用（进度信息）\n     * AskUserQuestion 工具调用（关键决策）\n     * Write/Edit 工具调用（文件变更）\n     * 消息时间戳（开始和结束时间）\n\nc. 解析脚本实现\n   ```python\n   import json\n   import sys\n   from datetime import datetime\n\n   # 读取 JSONL 并解析\n   messages = []\n   todos = []\n   decisions = []\n   file_changes = []\n\n   for line in sys.stdin:\n       msg = json.loads(line.strip())\n       messages.append(msg)\n\n       # 提取 TodoWrite\n       if msg.get('type') == 'tool_use' and msg.get('name') == 'TodoWrite':\n           todos.append(msg.get('input', {}).get('todos', []))\n\n       # 提取 AskUserQuestion\n       if msg.get('type') == 'tool_use' and msg.get('name') == 'AskUserQuestion':\n           decisions.append({\n               'timestamp': msg.get('timestamp'),\n               'questions': msg.get('input', {}).get('questions', []),\n               'answers': msg.get('input', {}).get('answers', {})\n           })\n\n       # 提取文件操作\n       if msg.get('type') == 'tool_use' and msg.get('name') in ['Write', 'Edit']:\n           file_changes.append({\n               'operation': 'created' if msg.get('name') == 'Write' else 'modified',\n               'path': msg.get('input', {}).get('file_path', ''),\n               'timestamp': msg.get('timestamp')\n           })\n\n   # 输出结果\n   print(json.dumps({\n       'messages': messages,\n       'todos': todos,\n       'decisions': decisions,\n       'file_changes': file_changes\n   }))\n   ```\n\n### 3. 生成会话摘要\n\na. 提取会话元数据\n   ```json\n   {\n     \"version\": \"1.0\",\n     \"sessionId\": \"{SESSION_UUID}\",\n     \"projectPath\": \"{CURRENT_DIR}\",\n     \"projectName\": \"{从路径提取最后一部分}\",\n     \"savedAt\": \"{当前时间 ISO 8601}\",\n     \"startTime\": \"{第一条消息时间}\",\n     \"endTime\": \"{最后一条消息时间}\",\n     \"messageCount\": {总消息数},\n     \"userMessageCount\": {用户消息数},\n     \"assistantMessageCount\": {AI 响应数}\n   }\n   ```\n\nb. 生成会话概览\n   - 标题：使用第一条用户消息（限制 100 字符）\n   - 描述：简要总结会话内容（AI 生成，100-200 字）\n   - 关键词：从标题和主要操作中提取（3-5 个）\n\nc. 整理进度信息\n   - 从最后一次 TodoWrite 调用中提取任务列表\n   - 统计已完成/进行中/待办任务数量\n   - 保留任务的 content、status、activeForm\n\nd. 整理关键决策\n   - 记录所有 AskUserQuestion 交互\n   - 包含问题、选项、用户答案\n   - 记录时间戳\n\ne. 整理文件变更\n   - 列出所有文件操作\n   - 记录操作类型（创建/修改/删除）\n   - 记录相对路径和时间戳\n\nf. 检测实施方案文档\n   - 搜索 docs/todo/ 目录下的方案文档\n   - 如果找到，提取文件路径\n   - 提取方案要点（前 3-5 个要点）\n\n### 4. 保存到分层存储\n\na. 创建存储目录（项目本地）\n   ```bash\n   # 存储目录结构（相对路径，跨平台兼容）\n   SUMMARY_DIR=\"./.claude-sessions/summaries/$SESSION_UUID\"\n   mkdir -p \"$SUMMARY_DIR\"\n\n   # 创建导出目录\n   EXPORT_DIR=\"./.claude-sessions/exports\"\n   mkdir -p \"$EXPORT_DIR\"\n   ```\n\nb. 写入 summary.json\n   - 使用 Write 工具写入摘要文件\n   - 包含所有元数据、概览、进度、决策、文件变更信息\n   - 格式化 JSON（便于阅读）\n\nc. 复制完整 JSONL（使用 Bash cp 命令或 Read+Write 工具）\n   - 将找到的会话文件复制到存储目录\n   - 目标：`$SUMMARY_DIR/details.jsonl`\n   - 确保完整复制，不修改内容\n\nd. 验证保存成功\n   - 检查文件是否存在\n   - 验证文件大小 > 0\n   - 如果失败，输出错误信息\n\n### 5. 输出确认信息\n\n输出格式化的成功信息：\n\n```\n✅ 会话已成功保存！\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n📄 保存位置（项目本地）\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n存储目录: ./.claude-sessions/summaries/{session-uuid}/\n  ├── summary.json   ({文件大小})\n  └── details.jsonl  ({文件大小})\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n📊 会话信息\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n会话标题: {标题}\n项目名称: {项目名}\n会话时间: {开始时间} - {结束时间}\n消息总数: {数量} ({用户消息数} 用户 + {AI消息数} 助手)\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n📈 工作进度\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n✅ 已完成: {数量}\n🔄 进行中: {数量}\n📋 待办: {数量}\n总计: {总数}\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n📂 文件变更\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n{列出前5个文件变更，格式：}\n  ✨ 已创建: path/to/file1\n  📝 已修改: path/to/file2\n  ...\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n💡 下一步\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n使用以下命令在新会话中继续工作：\n  /session-manager:continue\n\n🤖 Generated by session-manager plugin\n```\n\n---\n\n## 错误处理\n\n### 场景 1: 会话文件不存在\n\n```\n❌ 错误：找不到当前会话文件\n\n可能原因：\n1. 当前不在有效的 Claude Code 会话中\n2. 会话数据已被清理\n3. 项目路径编码错误\n\n建议：\n- 确保在 Claude Code 会话中执行此命令\n- 检查 ~/.claude/projects/ 目录是否存在\n- 尝试在新会话中重试\n```\n\n### 场景 2: 存储目录创建失败\n\n```\n❌ 错误：无法创建存储目录\n\n目标目录: {目录路径}\n\n可能原因：\n1. 磁盘空间不足\n2. 权限不足\n3. 目录路径无效\n\n建议：\n- 检查磁盘空间：df -h\n- 检查目录权限：ls -ld ~/.claude\n- 手动创建目录：mkdir -p {目录路径}\n```\n\n### 场景 3: JSONL 解析失败\n\n```\n❌ 错误：会话数据解析失败\n\n文件: {文件路径}\n错误: {错误信息}\n\n可能原因：\n1. JSONL 文件格式损坏\n2. 文件编码问题\n3. 不完整的 JSON 行\n\n建议：\n- 检查文件完整性\n- 尝试使用文本编辑器查看文件\n- 联系支持获取帮助\n```\n\n### 场景 4: 文件写入失败\n\n```\n❌ 错误：无法写入摘要文件\n\n目标文件: {文件路径}\n错误: {错误信息}\n\n可能原因：\n1. 磁盘空间不足\n2. 文件权限问题\n3. 目标目录不存在\n\n建议：\n- 检查磁盘空间：df -h\n- 检查文件权限\n- 确保存储目录存在\n```\n\n---\n\n## 跨平台兼容性\n\n### 路径处理\n- ✅ 使用 `$HOME` 而非 `~`\n- ✅ 使用 `pwd` 获取绝对路径\n- ✅ 使用 `sed` 进行路径编码（标准工具）\n\n### JSON 处理\n- ✅ 优先使用 Python 3（系统自带）\n- ✅ 备选：使用 jq（如果可用）\n- ✅ 使用标准 JSON 格式\n\n### 时间处理\n- ✅ 使用 `date -u` 生成 UTC 时间\n- ✅ 使用 ISO 8601 格式（跨平台标准）\n\n### 文件操作\n- ✅ 使用 `cp` 复制文件\n- ✅ 使用 `mkdir -p` 创建目录\n- ✅ 使用 `ls -t` 排序文件\n\n---\n\n## 性能考虑\n\n### 大文件处理\n- 会话文件 < 1MB：直接处理\n- 会话文件 1MB - 10MB：正常处理，提示可能需要等待\n- 会话文件 > 10MB：警告用户，建议分批保存\n\n### 内存使用\n- 一次性读取整个 JSONL 文件到内存\n- 对于大文件，可考虑流式处理（未来优化）\n\n### 存储空间\n- 每个会话约占用 100KB - 2MB\n- 建议定期清理旧会话（手动或自动）\n\n---\n\n## 使用示例\n\n### 基本使用\n```bash\n# 在工作一段时间后保存会话\n/session-manager:save\n\n# 输出：\n# ✅ 会话已成功保存！\n# 会话标题: 实现用户认证功能\n# 进度: 5/8 已完成\n# ...\n```\n\n### 长期项目\n```bash\n# 每天结束工作前保存\n/session-manager:save\n\n# 第二天开始工作时恢复\n/session-manager:continue\n```\n\n### 任务切换\n```bash\n# 项目 A - 保存当前进度\n/session-manager:save\n\n# 切换到项目 B\ncd ~/project-b\n\n# 项目 B - 保存进度\n/session-manager:save\n\n# 稍后回到项目 A\ncd ~/project-a\n/session-manager:continue\n```\n\n---\n\n**最佳实践**:\n1. 🕐 定期保存：建议每完成一个重要阶段就保存一次\n2. 📝 清晰命名：第一条消息尽量描述清楚要做什么\n3. 📋 使用 TodoWrite：便于跟踪和恢复进度\n4. 💬 记录决策：重要选择使用 AskUserQuestion 记录\n5. 🗂️ 整理文件：重要方案保存到 docs/todo/ 目录\n\n---\n\n**注意事项**:\n- ⚠️ 此命令不会修改原始会话数据\n- ⚠️ 保存的数据仅在本地存储\n- ⚠️ 建议定期备份 ~/.claude/session-summary/ 目录\n- ⚠️ 敏感信息（API 密钥、密码）也会被保存，注意安全\n\n---\n\n🤖 Generated with Claude Code"
              }
            ],
            "skills": []
          }
        ]
      }
    }
  ]
}